
C ++********************************************************************
C
C  WINAVE2.F                            LONG FILE NAMES JAN 89 al
C              OPFILEC                  FEB  03 ARDEAN LEITH
C                                                                      *
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C                                                                      *
C  WINAVE2(LUN2,NDOC,LUN14)                                           *
C                                                                      *
C  PURPOSE:                                                            *
C                                                                      *
C  WINAVE2S_4.FOR  5/14/87 VERSION FOR I*4, ALBANY INPUT 10/30/87
C                     2/28/89 LONG FILE NAMES ADDED
C  WINAVE2(LUN2,NDOC,LUN4,LUN5,LUN14)
C	  LUN2		LOGICAL UNIT NUMBER OF SMALL FILE
C	  NDOC		LOGICAL UNIT NUMBER OF PEAK FILE
C         LUN14         LOCICAL UNIT NUMBER OF RAW INPUT FILE
C--*******************************************************************
C   INTERPOLATION FOR NONINTEGER AVERAGING INTRODUCED. 5/2/83 MR
C   THIS VERSION HAS BEEN RE-WRITTEN FOR THE MRC APPLICATIONS
C   J.F. -- WINAVE2 WITH PATCH AVERAGES AND RANK RANGE 5/14/87
C   J.F. -- WINAVE2S VERSION WITH SPIDER INPUT
C   J.F. -- CHANGED FOR USE WITH LONG FILE NAMES 2/28/89
C   A.L. -- ARRAYS PUT IN UNLABELED COMMON
C--*******************************************************************

	SUBROUTINE WINAVE2(LUN2,NDOC,LUN14)

	INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        CHARACTER(LEN=MAXNAM)     ::  FILNAM1, DOCNAM
        COMMON /COMMUN/ FILNAM1, DOCNAM

	PARAMETER (NPMAX=200)
C	MAX NUMBER OF INDEPENDENT PATCHES

	PARAMETER (NBUF=4000)
C	MAX NUMBER OF NON-ZERO PEAKS THAT CAN BE READ IN

	PARAMETER (MAXOUTY=240)
C       MAX DIMENSION OF SQUARE WINDOW

	INTEGER IBUF(1)
	EQUIVALENCE(BUF,IBUF)
	COMMON NCOUNT(MAXOUTY*NPMAX),NLIST(NBUF),FNC(NPMAX),
     &	       NPEAK(NBUF),XLIST(NBUF),YLIST(NBUF),CLIST(NBUF),BUF(1)

C	ONE PLUS THE MAXIMUM NUMBER OF REGISTERS PER KEY 
	PARAMETER (MAXREG=7)    
C	MAXIMUM NUMBER OF KEYS
	PARAMETER (MAXKEY=9999) 
        COMMON /DOC_BUF/ DBUF(MAXREG*MAXKEY*2)

	COMMON /AREA/ IXP

	REAL         RLIST(3)
	LOGICAL      LRANK
	INTEGER      XBIG,YBIG,IXWIN(2),IXPWIN(2),IXP(2,NPMAX),IX(2)
	INTEGER      NOFFP,NP,NTOTAL,NPEAK,NLIST,I,NPK,IPK,N
	INTEGER      IS4,NTOT4,J4,NOFF24,K4,KS4,NOFF34,LUN14,NOFF
	INTEGER      IPK1,IPK2,IPKR,IND,L,IPKMN,IPKMX

        CHARACTER    NULL

        NULL = CHAR(0)

        WRITE(NOUT,*) 'ALTERED JUNE 93 TO USE COMMON BUFFER, al'

C       OPEN INPUT FILE
        MAXIM = 0
        CALL OPFILEC(0,.TRUE.,FILNAM1,LUN14,'O',IFORM,
     &        NSAM1,NROW1,NSLICE,MAXIM,'SCANNED DATA',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

	IF (NSLICE .GT. 1) THEN
           CALL ERRT(101,'OPERATION DOES NOT WORK ON VOLUMES',NE)
           RETURN
	ENDIF

	CALL FILERD(FILNAM1,NLET1,NULL,'AVERAGE',IRTFLG)
	IF (IRTFLG .NE. 0) RETURN

	IFORM = 3
	CALL RDPRMI(NSAM2,NROW2,NOT_USED,'DIMENSIONS')
	IXWIN(1)=NSAM2
	IXWIN(2)=NROW2
	IF (NSAM2.EQ.0.OR.NROW2.EQ.0) RETURN

	CALL RDPRMI(IXPWIN(1),IXPWIN(2),NOT_USED,'PATCH DIMENSIONS')
	CALL RDPRMI(NP,NGEN,NOT_USED,
     &       'NUMBER OF PATCHES, GENERATE PATCHES?(0/1)')
	IF (NGEN.EQ.0) THEN
		CALL RDPRMI(IDUM1,IDUM2,NOT_USED,
     &            'INTEGER CORNER COOS OF PATCHES')
		DO  IP=1,NP
                   DO  I=1,2
                      IXP(I,IP)=IBUF(2*(IP-1)+I)
		   ENDDO
		ENDDO
	ELSE
		CALL RDPRMI(IXP(1,1),IXP(2,1),NOT_USED,
     &                     'STARTING COOS')
		CALL RDPRMI(INCREMX,INCREMY,NOT_USED,
     &                      'INCREMENTS X,Y')
		NHOR=(NSAM1-IXP(1,1)+1)/INCREMX
		DO  IP=1,NP
                  IYCOO=((IP-1)/NHOR)*INCREMY
                  IXCOO=(IP-((IP-1)/NHOR)*NHOR-1)*INCREMX
                  IXP(1,IP)=IXP(1,1)+IXCOO
                  IXP(2,IP)=IXP(2,1)+IYCOO
                  IF (IXP(2,IP) + INCREMY-1 .GT. NROW1) THEN
			NP=IP-1
			GOTO 65
                  ENDIF
		ENDDO
60		CONTINUE
65	CONTINUE
	WRITE(NOUT,62) NP
62	FORMAT(' ** NUMBER OF PATCHES USED ',I3)
	WRITE(NOUT,61)((IXP(K,I),K=1,2),I=1,NP)
61	FORMAT(10I6)
	ENDIF

C       OPEN VOLUME-FORMATTED FILE. EACH SLICE CORRESPONDS TO ONE
C       PATCH AVERAGE, IN THE ORDER PATCHES ARE SPECIFIED

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FILNAM1,LUN2,'U',IFORM,NSAM2,NROW2,NP,
     &             MAXIM,'XXXX',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9000

	NOFF1=NPMAX+NSAM1+1
	NTOT4=NSAM2*NROW2
	NOFFP=NTOT4+2*NSAM2
	NOFF=2*NTOT4+4*NSAM2
	NOF11=NOFF1+NSAM1
	NOFF24=NOFF1+2*NSAM1+NSAM2  
C       OFFSET ADDRESS FOR 1ST AVERAGE IMAGE
C NOTE THAT ONE RECORD BEFORE AND BEHIND EACH IMAGE IS RESERVED FOR OVERSPILL
	IB1=NOFF1	            
C       ALTERNATE INPUT BUFFER ADDRESS #1
	IB2=NOF11	            
C       ALTERNATE INPUT BUFFER ADDRESS #2

C       CLEAR OUTPUT BUFFERS

	NTOTAL=NP*NOFFP
	DO  IS4=1,NTOTAL
	  BUF(NOFF24+IS4-1)=0.
	ENDDO

C       NSAMC, NROWC ARE THE DIMENSIONS OF THE AREA USED IN THE
C       CORRELATION FUNCTION

	NSAMC=NSAM1-NSAM2
	NROWC=NROW1-NROW2

C       READ IN DOCUMENT FILE INTO LARGE BUFFER DBUF
	CALL FILERD(DOCNAM,NLETD,DATEXC,'DOCUMENT',IRTFLG)
	IF (IRTFLG .NE. 0) RETURN

	IKEY=1
C       IKEY IS ARBITRARY. WE ARE INTERESTED IN GETTING THE ENTIRE
C       REGISTER SET AT ONCE, SO WE WILL IGNORE THE CONTENTS OF RLIST
C       (WHICH FOR IKEY=1 RETURNS THE REGISTER UNDER THAT KEY)
	ISW=0
	CALL UNSDAL(DOCNAM,ISW,NDOC,IKEY,RLIST,3,DBUF,MAXKEY,
     &      MAXREG,NKEY,LERR)
	
	WRITE(NOUT,*) '** NUMBER OF PEAKS IN DOC FILE ',NKEY
C       NKEY= NUMBER OF KEYS FOUND IN DOCUMENT FILE
	CALL RDPRM2(THR1,THR2,NOT_USED,'PEAK VALUES (FROM,TO)')
	CALL RDPRM2(RANK1,RANK2,NOT_USED,
     &    'RANGE OF RANKS IN PERCENT (FROM,TO;100=BEST)')
	IF (RANK1.EQ.0.0.AND.RANK2.EQ.0.0) THEN
		LRANK=.FALSE.
		WRITE(NOUT,92)
	ELSE
		LRANK=.TRUE.
92		FORMAT(' *** NO RANK SORTING SPECIFIED ***')
	ENDIF

C       START READING, CHECK FOR PEAKS WITHIN SPECIFIED VALUE RANGE
	I=1 
	DO 905 II=1,NKEY
          J1=(II-1)*MAXREG+2
C         NOTE THAT THE FIRST ELEMENT CONTAINS THE KEY
          XLIST(I)=DBUF(J1)
          YLIST(I)=DBUF(J1+1)
          CLIST(I)=DBUF(J1+2)
          IF(CLIST(I).LT.THR1.OR.CLIST(I).GT.THR2) GOTO 905
          I=I+1
905	CONTINUE
	NPK=I-1
	WRITE(NOUT,911) NPK,THR1,THR2
911	FORMAT(/' ** ',I5,' PEAKS BETWEEN',F8.1,' AND ',F8.1,
     1            ' READ IN'/)

	CALL RDPRM2(XOFFS,YOFFS,NOT_USED,'X-OFFSET, Y-OFFSET')
	CALL RDPRM(SCALE,NOT_USED,'SCALE FACTOR')

        ILOWX=(NSAM1-NSAMC)/2+1
        ILOWY= (NROW1-NROWC)/2+1
        IHIGHX=NSAM1/2+NSAMC/2
        IHIGHY=NROW1/2+NROWC/2
	WRITE (NOUT,1111) ILOWX,ILOWY,IHIGHX,IHIGHY
1111    FORMAT(' ** ILOWX, ILOWY, IHIGHX, IHIGHY',4I6)

C NOW SORT PEAK PARAMETERS BY PEAK SIZE AND ESTABLISH RANKS
C (ARRAY NPEAK COULD BE USED IN PRINCIPLE TO KEEP TRACK OF
C "LEXICOGRAPHIC PEEK POSITION" IN ORIGINAL PEAK FILE)
	IF(LRANK) THEN
		CALL SORTZ(CLIST,XLIST,YLIST,NPEAK,NPK)
	ENDIF
C APPLY OFFSET AND SCALE FACTOR. THEN CHECK BOUNDARIES AND SET 
C UP ARRAY OF RANKS
	IPK=0
	DO 950 I=1,NPK
	XS=(FLOAT(NSAM1)+2.-(XLIST(I)+XOFFS))*SCALE
	YS=(FLOAT(NROW1)+2.-(YLIST(I)+YOFFS))*SCALE
	IF(XS.LT.ILOWX.OR.XS.GT.IHIGHX.OR.
     1       YS.LT.ILOWY.OR.YS.GT.IHIGHY) GOTO 950
	IX(1)=XS+0.5
	IX(2)=YS+0.5
	N=NAREA(IX,NP,IXWIN,IXPWIN)
	IF(N.EQ.0) GOTO 950
	IPK=IPK+1
	NPEAK(IPK)=IPK
	XLIST(IPK)=XS
	YLIST(IPK)=YS
	CLIST(IPK)=CLIST(I)
	NLIST(IPK)=N
C NLIST CONTAINS THE PATCH NUMBER THE PEAK BELONGS IN

950	CONTINUE
	WRITE(NOUT,951)IPK
951	FORMAT(/' ** NUMBER OF PEAKS AFTER COO CHECK = ',I5/)
	IF (IPK.EQ.0) STOP '*** NO QUALIFYING PEAKS FOUND'

	IF (LRANK) THEN
		IPK1=RANK1/100.*FLOAT(IPK)+0.5001
		IPK2=RANK2/100.*FLOAT(IPK)+0.5
		IPKR=IPK2-IPK1+1
		WRITE(NOUT,952) IPKR
952	FORMAT(/' ** NUMBER OF PEAKS WITHIN RANK RANGE = ',I5/)
	ELSE
C DEFAULT ASSIGNMENTS: ALL RANKS PASSED
		IPK1=1
		IPK2=IPK
		IPKR=IPK2-IPK1+1
	ENDIF

C---------------CONDENSE ARRAYS SO THAT ONLY REQUESTED RANK
C---------------RANGE IS LEFT!
	CALL RDPRMI(NUM,NDUMP,NOT_USED,
     &      'NO. OF PEAKS TO USE, DUMP?(1=YES)')
	IF (NDUMP.EQ.2) THEN
	  DO  I=IPK1,IPK2
	    WRITE(NOUT,*) XLIST(I),YLIST(I),CLIST(I),NPEAK(I)
	  ENDDO
	ENDIF

C NOW SORT THE REMAINING IPKR PEAKS BY ASCENDING Y-COORDINATE
	CALL SORTZ(YLIST(IPK1),XLIST(IPK1),CLIST(IPK1),
     &       NLIST(IPK1),IPKR)
C NOTE THAT NPEAK-ARRAY IS NOT BEING SORTED. THIS IS NOT
C NECESSARY IN THIS APPLICATION.
C APPLY OFFSET TO GET WINDOW STARTING COOS.
	DO  I=1,IPKR
	IND=I-1+IPK1
	XLIST(IND)=XLIST(IND)-NSAM2/2-1 
C        -1 ADDED 11/10/87
	YLIST(IND)=YLIST(IND)-NROW2/2-1 
C         -1 ADDED
	IF(NDUMP.EQ.2) WRITE(NOUT,*) XLIST(IND),YLIST(IND),
     1     CLIST(IND),NLIST(IND)
	ENDDO
	IF(NDUMP.EQ.2) RETURN

C	WRITE(NOUT,*) YLIST(IPK1),YLIST(IPK2)
C FIGURE OUT READING RANGE (FOR FIRST LINE TO BE READ IN)

	IYMIN=MAX0(0,INT(YLIST(IPK1)))
	IYMAX=MIN0(NROW1,INT(YLIST(IPK2)+NROW2-1))
C INITIALIZE MINIMUM, MAXIMUM OF PEAK NUMBER
	IPKMN=IPK1
	IPKMX=IPK1
C INITIALIZE RECORD CHECK ARRAY
	DO  IP=1,NP
	DO  I=1,NROW2
	IC=(IP-1)*NROW2+I
	NCOUNT(IC)=0
	ENDDO
	ENDDO

C SET REC. COUNTER;  FILL IN FIRST BUFFER
	IPREV=IYMIN
	CALL REDLIN(LUN14,BUF(IB1),NSAM1,IYMIN+1)
C NOW GO THROUGH ENTIRE IMAGE, LINE BY LINE, FILLING THE
C TWO BUFFERS ALTERNATELY
	DO  IY=IYMIN,IYMAX-1
C IY IS THE CURRENT Y-COORDINATE (RELATIVE TO 0 ORIGIN) OF THE 
C FIRST INPUT RECORD
C POSITION THE RECORD COUNTER FOR SECOND BUFFER LINE
	CALL REDLIN(LUN14,BUF(IB2),NSAM1,IY+2)

C ALLOW ONLY WINDOWS WHOSE TOP LEFT COOS ARE WITHIN THE
C RANGE IY-NROW2,IY+1
C THE EXTRA TWO ROWS ON EITHER SIDE ARE REQUIRED 
C FOR INTERPOLATION.
C FIND OUT WHICH OF THE SMALLEST Y CAN NOW BE ELIMINATED:

1000	IF(YLIST(IPKMN).LT.IY-NROW2) THEN
		IF(IPKMN.LT.IPK2) THEN
			IPKMN=IPKMN+1
			GOTO 1000
		ENDIF
	ENDIF
C FIND OUT WHICH OF THE LARGEST Y CAN NOW BE ADDED ON:
1100	IF(IPKMX.LT.IPK2) THEN
		IF(YLIST(IPKMX+1).LE.IY+1) THEN
			IPKMX=IPKMX+1
			GOTO 1100
		ENDIF
	ENDIF

C NOW GO THROUGH ALL AREAS DEFINED BY THE PEAK RANGE
C IPKMN, IPKMX TO FIND OUT WHICH SEGMENTS OF THE INPUT LINES
C ARE TO BE USED.
	DO 1200 L=IPKMN,IPKMX
	Y1=IY-YLIST(L)
	IY1=Y1
	IF(Y1.LT.0.0) IY1=-1
	IYPOS=Y1+1.500001
C NOTE THAT Y1 IS NEGATIVE FOR THE FIRST TIME THE
C SMALL AREA IS TOUCHED BY THE SLIDING BUFFER LINES!
C
C IYPOS IS THE CURRENT RECORD COUNT IN OUTPUT FILE
        IF(NDUMP.EQ.1)THEN
           WRITE(NOUT,*)
     1      'PK YCOO,INP REC,PEAK NO,CORR,OUTP REC = '
     1     ,YLIST(L),IY,L,CLIST(L),IY1
	   WRITE(NOUT,*) YLIST(L),IY,L,CLIST(L),IY1
        ENDIF

	DY=1-(Y1-IY1)
	X1=XLIST(L)+1
	IX1=X1
C IX1 IS THE X-COO (RELATIVE TO 1) OF THE FIRST ELEMENT IN THE INPUT
C ARRAY  
	DX=1-(X1-IX1)
	C1=(1-DX)*(1-DY)
	C2=DX*(1-DY)
	C3=DY*(1-DX)
	C4=DX*DY

C FIND WINDOW, PATCH AND ASSOCIATED BUFFER SEGMENT

	IX(1)=XLIST(L)+NSAM2/2+0.5
	IX(2)=YLIST(L)+NROW2/2+0.5
	N=NLIST(L)
	KS4=(IYPOS-1)*(NSAM2)+(N-1)*NOFFP
	IF(IYPOS.LT.1.OR.IYPOS.GT.NROW2) GOTO 1200
	IC=(N-1)*NROW2+IYPOS
	NCOUNT(IC)=NCOUNT(IC)+1
	DO  K4=1,NSAM2
	IX2=IX1+K4
	IF(IX2.GT.NSAM1) IX2=NSAM1
	I1=IB1-1+IX1+K4-1
	I2=IB1-1+IX2
	I3=IB2-1+IX1+K4-1
	I4=IB2-1+IX2
        VAL=BUF(I1)*C1
     $  +BUF(I2)*C2+BUF(I3)*C3+BUF(I4)*C4
	BUF(NOFF24+K4+KS4-1)=BUF(NOFF24+K4+KS4-1)+VAL
	ENDDO

1200	CONTINUE
C PERMUTATE BUFFERS
	ISAVE=IB1
	IB1=IB2
	IB2=ISAVE
	ENDDO

1550	CLOSE(NDOC)
C
C WRITE OUT AVERAGES

1560	CONTINUE

C WRITE OUT AVERAGES OF PATCHES

1680	CONTINUE
	DO  IP=1,NP
C 1ST AND LAST LINE REFUSE TO COME OUT RIGHT. SINCE THE
C BOUNDARIES ARE UNIMPORTANT, A FIXUP IS USED WHEREBY THE
C FIRST AND LAST LINE ARE REPLACED BY THE AVERAGE OF THE
C LINE NROW2-1. SEE BELOW.
	FNC(IP)=0.
	DO 1700 I=2,NROW2-1
	JREC=(IP-1)*NROW2+I
	KS4=(I-1)*NSAM2+(IP-1)*NOFFP
	IC=(IP-1)*NROW2+I
	FNC(IP)=FNC(IP)+FLOAT(NCOUNT(IC))

C SCALE AVERAGES
	IF(NCOUNT(IC).EQ.0) GOTO 1700
	DO  K=1,NSAM2
	  BUF(NOFF24+KS4+K-1)=BUF(NOFF24+KS4+K-1)/ FLOAT(NCOUNT(IC))
	ENDDO
1700	CALL WRTLIN(LUN2,BUF(NOFF24+KS4),NSAM2,JREC)
	FNC(IP)=FNC(IP)/FLOAT(NROW2-2)

C FIXUP OF BOUNDARY PROBLEM .....................
	B=0					
	DO  K=1,NSAM2			
	  B=B+BUF(NOFF24+KS4+K-1)			
	ENDDO
	B=B/FLOAT(NSAM2)			
	DO  K=1,NSAM2			
	  BUF(K)=B				
	ENDDO
	JREC=(IP-1)*NROW2+1			
	CALL WRTLIN(LUN2,BUF,NSAM2,JREC)	
	JREC=(IP-1)*NROW2+NROW2			
	CALL WRTLIN(LUN2,BUF,NSAM2,JREC)	
C END FIXUP .....................................

	ENDDO
	CLOSE(LUN2)

	WRITE(NDAT,1812)NSAMC,NROWC
1812    FORMAT(/' ** DIMENSIONS OF CCF WINDOW USED:',2I5/)

	WRITE(NDAT,1814)
1814	FORMAT(//' ** NUMBER OF WINDOWS IN EACH PATCH'/)

	WRITE(NDAT,1815) (FNC(I),I=1,NP)
1815	FORMAT(10F6.1)

	RETURN

9000	CALL ERRT(4,'WINAVE',IER)

	RETURN
	END
