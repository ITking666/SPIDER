head	1.36;
access;
symbols
	pre_mrcs:1.36
	healthdept_2018:1.36
	pre_getangas:1.33
	GPL2010:1.33
	pre_GPL2010:1.32
	pre_var_equation:1.26
	pre_fftwrings:1.26
	pre_opfiles:1.24
	src:1.24
	best-code:1.23
	x-named-regs:1.23
	x:1.23
	v13-00:1.23
	pre_GPL:1.22
	prec_CA:1.20
	noindx:1.20
	Bproc:1.17
	oct21:1.16
	last77:1.13;
locks; strict;
comment	@c @;


1.36
date	2018.10.03.14.34.06;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2015.09.08.17.21.38;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2011.12.06.14.05.31;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.24.13.25.38;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.19.15.28.03;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.14.17.48.29;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2010.01.13.18.52.09;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2009.12.30.20.01.20;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.23.20.23.09;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.19.21.29.40;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.23.12.54.43;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2007.03.05.20.44.12;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.20.16.37.11;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.17.20.54.27;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.05.19.54.39;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.30.19.51.35;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.22.20.11.40;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.04.14.40.28;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.23.15.45.23;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	99.11.02.17.46.47;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	99.10.20.18.25.22;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	99.10.18.19.14.37;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	99.10.15.17.22.10;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	98.11.12.15.49.25;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	98.11.10.15.26.58;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	98.10.20.13.30.50;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	98.01.29.16.22.27;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	98.01.05.18.51.57;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	97.12.31.17.01.24;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	97.12.03.15.32.20;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	97.10.17.19.03.08;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	97.09.25.13.16.49;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	97.09.17.15.53.26;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	97.01.06.18.37.44;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.05.17;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.48.52;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.36
log
@email_health_dept
@
text
@
C++*********************************************************************
C
C  FINDLBQ.F    ADAPTED FOR CHAR.                 AUG  89 ArDean Leith
C               MERGED WITH SEARCHQ STUFF         SEPT 97 ArDean Leith
C               ADDED IFLEVEL                     DEC. 97 ArDean Leith
C               INCORE PROCS                      JAN  01 ArDean Leith
C               LUNDONOW                          FEB  01 ArDean Leith
C               LNBLNKN                           MAY  04 ArDean Leith
C               DOC INSIDE LOOP BUG               JUL  07 ArDean Leith
C               NINSAVEOF                         NOV  09 ArDean Leith
C               PASS LOOP END WHILE HUNTING LB    DEC  09 Ardean Leith
C               PASS LB6 WHILE HUNTING LB7 BUG    JAN  10 Ardean Leith
C               IF CYCLE WITHIN DO BUG            JAN  10 Ardean Leith
C               ! COMMENT DELIMITER               DEC  11 Ardean Leith
C               GOTO LB WITHIN LOOP BUG           SEP  15 Ardean Leith
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  FINDLBQ(WANTLABEL,IDOTOP,NLOOPT,IDOSTK,NEWLOOP, IFLEVEL,IRTFLG)
C
C  PURPOSE: SEARCHES FOR 'LB*', OR 'ENDDO' IN SPIDER INCOMING
C           OPERATIONS. IF SUCCESSFUL RETURNS CURRENT LINE IN: FCHAR
C
C  PARAMETERS:
C        WANTLABEL      LABEL WE ARE SEARCHING FOR                (SENT)
C                          CAN BE LB#, ELSE, ENDIF, ENDDO
C        IDOTOP         DO-LOOP NESTING LEVEL                     (SENT)
C        NLOOPT         INSIDE DO-LOOP NOW IF > 0                 (SENT)
C	 IDOSTK         DO-LOOP STACK                             (SENT)
C	 NEWLOOP	IF PASS CURRENT A DO-LOOP END -            (RET)
C                          MUST POP DO-LOOP STACK IN CALLER         
C        IFLEVEL        IF CLAUSE NESTING LEVEL            (SENT & RET.) 
C        IRTFLG		ERROR NUMBER ZERO IS NORMAL               (RET.)
C
C--*******************************************************************

	SUBROUTINE FINDLBQ(WANTLABEL,IDOTOP,NLOOPT,IDOSTK,NEWLOOP,
     &                     IFLEVEL,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        COMMON /LUNDOECHO/ LUNDONOW,NDOLINE,NINSAVEOF

        CHARACTER (LEN=*)      :: WANTLABEL
        CHARACTER (LEN=MAXNAM) :: ANSW
        LOGICAL                :: KEEPGO
        INTEGER                :: IDOSTK(7,*)
        INTEGER                :: DOLABEL
        INTEGER                :: NEWLOOP 

        INTEGER                :: ICOMM,MYPID,MPIERR

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

	NEWLOOP    = 0
        KEEPGO     = .TRUE.
        NEEDENDIF  = 0
        NEEDENDO   = 1

C       KEEP READING AND DISCARDING LINES FROM INPUT AS NEEDED
        DO WHILE (KEEPGO) 
           ANSW(4:4) = ' '

           IF (COPT == 'B' .AND. NINSAVEOF == 0) THEN
C             INCREMENT PROCEDURE LINE COUNTER
              IBCNT = IBCNT + 1

C             READ FROM CURRENT STORED PROCEDURE LINE= IBCNT
              CALL PROC_GETPLINE(IBCNT,0,ANSW,NCHAR,IOS)
           ELSE
C             READ FROM FILE OPENED ON NIN (FOR INTERACTIVE LOOP)
              READ(NIN,FMT='(A)',IOSTAT=IOS) ANSW
              NCHAR = LNBLNKN(ANSW)
              IF (LUNDONOW > 0) THEN
C               MUST COPY INPUT LINE TO CURRENT INTERACTIVE DO-LOOP FILE
                WRITE(LUNDONOW,*) ANSW(1:NCHAR)
              ENDIF
           ENDIF

           IF (IOS .NE. 0) THEN
              WRITE(NOUT,91) WANTLABEL
 91           FORMAT(' *** JUMP DESTINATION NEVER FOUND: ',A)
              CALL ERRT(100,'FINDLBQ',NE)
              IRTFLG = 1
              RETURN
           ENDIF

C          REMOVE BLANKS FROM INPUT STRING
           CALL SHRINKQ(ANSW,MAXNAM,ANSW,NCHAR)

C          IGNORE ANY COMMENTS AT END OF INPUT STRING
           ISEMICOL = SCAN(ANSW(1:NCHAR),';!')
           IF (ISEMICOL > 0) THEN
              ANSW(ISEMICOL:NCHAR) = CHAR(0)
              NCHAR = ISEMICOL - 1
           ENDIF
           IF (NCHAR <= 0) CYCLE

C          CONVERT INPUT STRING TO ALL UPPER CASE
           CALL SSUPCAS(ANSW(1:NCHAR))

C          SEE IF INPUT LINE CONTAINS 'THEN'
           IIFTHEN = INDEX(ANSW(1:NCHAR),'THEN')

C          FIND LAST NON-BLANK IN WANTLABEL            
           LENLB = LNBLNKN(WANTLABEL)

C          FIND LAST NON-BLANK IN ANSW            
           LENANSW = LNBLNKN(ANSW)
           LENT    = INDEX(ANSW,CHAR(0)) - 1
           IF (LENT > 0) LENANSW = MIN(LENANSW,LENT)

        !write(6,*)' want: ',wantlabel(:lenlb),' answ: ',answ(1:lenansw)

C          -------------------------------------- SEARCHING FOR "ENDDO"
C          DO NOT CARE ABOUT IF'S, OR LABELS IN HERE

          IF (WANTLABEL(:LENLB) ==  'ENDDO' .AND.
     &         ANSW(1:2)        ==  'DO'    .AND.
     &         ANSW(3:3)       .NE. 'C'     .AND.
     &         ANSW(3:4)       .NE. 'LB') THEN

C              HUNTING FOR 'ENDDO' AND PASSING NESTED 'DO...ENDDO'
               NEEDENDO = NEEDENDO + 1
               !write(6,*) ' needendop1:',needendo

           ELSEIF (WANTLABEL(:LENLB) == 'ENDDO' .AND.
     &             ANSW(1:2)      == 'IF' .AND.
     &             IIFTHEN > 5 ) THEN
C              HUNTING FOR 'ENDDO' AND FOUND A NEW 'IF...THEN' CLAUSE
               NEEDENDIF = NEEDENDIF + 1

           ELSEIF (WANTLABEL(:LENLB) == 'ENDDO' .AND.
     &             ANSW(1:5)      == 'ENDIF') THEN
C              HUNTING FOR 'ENDDO' AND FOUND AN 'ENDIF' 
               NEEDENDIF = NEEDENDIF - 1

           ELSEIF (WANTLABEL(:LENLB) == 'ENDDO' .AND.
     &             ANSW(1:5)         == 'ENDDO') THEN

C              HUNTING FOR 'ENDDO' AND FOUND IT
               NEEDENDO = NEEDENDO - 1
               !write(6,*) ' needendom1:',needendo

C              IF FOUND CORRESPONDING ENDDO, HALT INPUT
               IF (NEEDENDO <= 0) THEN
                  KEEPGO  = .FALSE.
                  IFLEVEL = IFLEVEL + NEEDENDIF
                  IF (NEEDENDIF > 0) THEN
                     WRITE(NOUT,*)' WARNING: JUMP INTO "IF" CLAUSE'
                  ENDIF
              ENDIF

C          ----------------------------------------- SEARCHING FOR "LB"
C          MUST CARE ABOUT IF'S, DO's, 'LB**'s, AND ENDDO's IN HERE

           ELSEIF (ANSW(1:2) == 'LB' .AND.
     &             ANSW(:LENANSW) == WANTLABEL(:LENLB)) THEN
C              HUNTING FOR SPECIFIED 'LB??' AND FOUND IT, HALT INPUT
               KEEPGO  = .FALSE.

               IFLEVEL = IFLEVEL + NEEDENDIF
               IF (NEEDENDIF > 0) THEN
                  WRITE(NOUT,*)' WARNING: JUMP INTO "IF" CLAUSE'
               ENDIF
               !write(6,*) ' found:',ANSW(:LENANSW),':',WANTLABEL(:LENLB),':'

           ELSEIF (WANTLABEL(1:2) == 'LB' .AND.
     &             ANSW(1:2)      == 'IF' .AND.
     &             IIFTHEN > 5 ) THEN
C              HUNTING FOR 'LB..' AND FOUND A NEW 'IF...THEN' CLAUSE
               NEEDENDIF = NEEDENDIF + 1

           ELSEIF (WANTLABEL(1:2) == 'LB' .AND.
     &             ANSW(1:5)      == 'ENDIF') THEN
C              HUNTING FOR 'LB..' AND FOUND A 'ENDIF' 
               NEEDENDIF = NEEDENDIF - 1

           ELSEIF (WANTLABEL(1:2) ==  'LB' .AND.
     &             ANSW(1:2)      ==  'DO' .AND.
     &             ANSW(3:3)     .NE. 'C'  .AND.
     &             ANSW(3:4)     .NE. 'LB') THEN
C              HUNTING FOR 'LB..' AND FOUND A NEW UNLABELED 'DO' CLAUSE

               NEEDENDO = NEEDENDO + 1
               !write(6,*) ' needendop1:',needendo

           ELSEIF (WANTLABEL(1:2) == 'LB' .AND.
     &             ANSW(1:5)      == 'ENDDO') THEN
C              HUNTING FOR 'LB..' AND PASSING A "ENDDO" CLAUSE

               NEEDENDO = NEEDENDO - 1
               !write(6,*) ' needendom1:',needendo

           ENDIF

C          -------------------------------- PASS END OF ACTIVE DO-LOOP?

C          SET NEWLOOP IF WE PASS BY CURRENT DO-LOOP LABEL
           !write(6,*) ' keepgo,nloopt,newloop:',keepgo,nloopt,newloop

	   IF (KEEPGO .AND. NLOOPT > 0) THEN 
              IF (ANSW(1:2) == 'LB') THEN
C                PASSED BY LINE LABEL, MAY BE END OF A LOOP
                 CALL GETLBNO(ANSW,LBNO,IRTFLG)
                 IPROCNOW = IDOSTK(5,IDOTOP) 

                 DO I = IDOTOP,1,-1
                    ! write(6,*) ' idostk(5,6):',i,idostk(5,i),idostk(6,i)
                    IF (IPROCNOW > IDOSTK(5,I)) EXIT  ! OUT OF THIS PROC.
                    IF (LBNO == IDOSTK(6,I)) THEN
C                      FOUND END OF AN ACTIVE DO-LOOP
                       NEWLOOP = NEWLOOP - 1
                    ENDIF
                 ENDDO
                 !write(6,990)newloop,idotop,(idostk(6,i),i=1,idotop)
990              format(' newloop:',i4,' idotop:',i4,' stk:',10i5)

              ELSEIF (ANSW(1:5) == 'ENDDO') THEN
C                PASSED BY ENDDO, END OF A LOOP

                 IF (NEEDENDO <= 0) THEN
C                   MAY BE A CURRENT ACTIVE DO-LOOP
                    IF (IDOSTK(6,IDOTOP) < 0) THEN
C                       USING LB LESS DO LOOP SYNTAX
                        NEWLOOP = NEWLOOP - 1
                    !write(6,990)newloop,idotop,(idostk(6,i),i=1,idotop)
                    ENDIF
                  ENDIF
              ENDIF
           ENDIF
        ENDDO

C       FOUND DESIRED LABEL OR ENDIF CAN RETURN NOW
        IRTFLG = 0

C       SIMULATE ECHO OF OPERATION TO RESULTS FILE
        FCHAR = ANSW

        IF (MYPID <= 0) WRITE(NDAT,90) ANSW(1:NCHAR)
 90     FORMAT(' .OPERATION:',5X,A)

	END




C++*********************************************************************
C
C  FINDENDIF -- ADAPTED FOR CHAR.                  AUG  89 ArDean Leith
C               MERGED WITH SEARCHQ STUFF          SEPT 97 ArDean Leith
C               ADDED IFLEVEL                      DEC. 97 ArDean Leith
C               INCORE PROCS                       JAN  01 ArDean Leith
C               LUNDONOW                           FEB  01 ArDean Leith
C               LNBLNKN                            MAY  04 ArDean Leith
C               DOC INSIDE LOOP BUG                JUL  07 ArDean Leith
C               NINSAVEOF                          NOV  09 ArDean Leith
C               PASS LOOP END WHILE HUNTING LB     DEC  09 Ardean Leith
C **********************************************************************
C
C  FINDENDIF(WANTLABEL,IFLEVEL,IRTFLG)
C
C  PURPOSE: SEARCHES FOR LB*, ELSE, ENDIF, ENDDO IN SPIDER INCOMING
C           OPERATIONS. IF SUCCESSFUL RETURNS CURRENT LINE IN: FCHAR
C
C  PARAMETERS:
C        WANTLABEL      LABEL WE ARE SEARCHING FOR                (SENT)
C                          CAN BE 'ELSE' OR 'ENDIF'
C        IFLEVEL        IF CLAUSE NESTING LEVEL            (SENT & RET.) 
C        IRTFLG		ERROR RETURN, ZERO IS NORMAL              (RET.)
C
C--*******************************************************************

	SUBROUTINE FINDENDIF(WANTLABEL,IFLEVEL,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        COMMON /LUNDOECHO/ LUNDONOW,NDOLINE,NINSAVEOF

        CHARACTER (LEN=*)      :: WANTLABEL
        CHARACTER (LEN=MAXNAM) :: ANSW
        LOGICAL                :: KEEPGO

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

        KEEPGO     = .TRUE.
        NEEDENDIF  = 0

C       KEEP READING AND DISCARDING LINES FROM INPUT AS NEEDED
        DO WHILE (KEEPGO) 
           ANSW(4:4) = ' '

           IF (COPT == 'B' .AND. NINSAVEOF == 0) THEN
C             INCREMENT PROCEDURE LINE COUNTER
              IBCNT = IBCNT + 1

C             READ FROM CURRENT STORED PROCEDURE LINE= IBCNT
              CALL PROC_GETPLINE(IBCNT,0,ANSW,NCHAR,IOS)
           ELSE
C             READ FROM FILE OPENED ON NIN (FOR INTERACTIVE LOOP)
              READ(NIN,FMT='(A)',IOSTAT=IOS) ANSW
              NCHAR = LNBLNKN(ANSW)
              IF (LUNDONOW > 0) THEN
C               MUST COPY INPUT LINE TO CURRENT INTERACTIVE DO-LOOP FILE
                WRITE(LUNDONOW,*) ANSW(1:NCHAR)
              ENDIF
           ENDIF

           IF (IOS .NE. 0) THEN
              WRITE(NOUT,91) WANTLABEL
 91           FORMAT(' *** DESTINATION NEVER FOUND: ',A)
              CALL ERRT(100,'FINDENDIF',NE)
              IRTFLG = 1
              RETURN
           ENDIF

C          REMOVE BLANKS FROM INPUT STRING
           CALL SHRINKQ(ANSW,MAXNAM,ANSW,NCHAR)

C          IGNORE ANY COMMENTS AT END OF INPUT STRING
           ISEMICOL = SCAN(ANSW(1:NCHAR),';!')
           IF (ISEMICOL > 0) THEN
              ANSW(ISEMICOL:NCHAR) = CHAR(0)
              NCHAR = ISEMICOL - 1
           ENDIF
           IF (NCHAR <= 0) CYCLE

C          CONVERT INPUT STRING TO ALL UPPER CASE
           CALL SSUPCAS(ANSW(1:NCHAR))

C          SEE IF INPUT LINE CONTAINS 'THEN'
           IIFTHEN = INDEX(ANSW(1:NCHAR),'THEN')

C          FIND LAST NON-BLANK IN WANTLABEL            
           LENLB = LNBLNKN(WANTLABEL)

C          FIND LAST NON-BLANK IN ANSW            
           LENANSW = LNBLNKN(ANSW)
           LENT    = INDEX(ANSW,CHAR(0)) - 1
           IF (LENT > 0) LENANSW = MIN(LENANSW,LENT)

C          -------------------------------------- SEARCHING FOR "ELSE"

           IF (WANTLABEL == 'ELSE' .AND.
     &             ANSW(1:6) == 'ELSEIF') THEN
C              HUNTING FOR 'ELSE' AND FOUND 'ELSEIF'

C              IF NOT A NESTED ELSE, RETURN TO CALLER
               IF (NEEDENDIF <= 0)  THEN
                   KEEPGO = .FALSE.

C                  DECREMENT PROCEDURE LINE COUNTER TO RE-READ THIS LINE
                   IF (COPT == 'B' .AND. NINSAVEOF == 0)
     &                 IBCNT = IBCNT-1
               ENDIF

           ELSEIF (WANTLABEL == 'ELSE' .AND.
     &             ANSW(1:4) == 'ELSE') THEN
C              HUNTING FOR 'ELSE' AND FOUND IT
C              IF NOT A NESTED ELSE, RETURN TO CALLER
               IF (NEEDENDIF <= 0)  KEEPGO = .FALSE.

           ELSEIF (WANTLABEL == 'ELSE' .AND.
     &             ANSW(1:5) == 'ENDIF') THEN
C              HUNTING FOR 'ELSE' AND FOUND ENDIF

C              IF NOT A NESTED ENDIF, RETURN TO CALLER
               IF (NEEDENDIF <= 0) THEN
                  IFLEVEL = IFLEVEL - 1
                  KEEPGO  = .FALSE.
               ENDIF

C              IF NESTED ENDIF KEEP READING INPUT
               NEEDENDIF = NEEDENDIF - 1

           ELSEIF (WANTLABEL == 'ELSE' .AND.
     &             ANSW(1:2) == 'IF'   .AND.
     &             IIFTHEN > 5 ) THEN
C              HUNTING FOR 'ELSE' AND FOUND IF...THEN
C              THIS IS A NESTED IF,  KEEP READING INPUT
               NEEDENDIF = NEEDENDIF + 1

C          -------------------------------------- SEARCHING FOR "ENDIF"
C          DO NOT CARE ABOUT NEW LOOPS, OR LABELS IN HERE

           ELSEIF (WANTLABEL == 'ENDIF' .AND.
     &             ANSW(1:2) == 'IF'    .AND.
     &            IIFTHEN > 5 ) THEN
C              HUNTING FOR 'ENDIF' AND FOUND A NESTED IF...THEN
               NEEDENDIF = NEEDENDIF + 1

           ELSEIF (WANTLABEL == 'ENDIF' .AND.
     &             ANSW(1:5) == 'ENDIF') THEN
C              HUNTING FOR 'ENDIF' AND FOUND ENDIF

C              IF NOT A NESTED ENDIF, RETURN TO CALLER
               IF (NEEDENDIF <= 0) THEN
                  KEEPGO  = .FALSE.
                  IFLEVEL = IFLEVEL - 1
               ENDIF

C              IF NESTED ENDIF KEEP READING INPUT
               NEEDENDIF = NEEDENDIF - 1

           ENDIF
        ENDDO

C       FOUND DESIRED 'ELSE' OR 'ENDIF' CAN RETURN NOW
        IRTFLG = 0

C       SIMULATE ECHO OF OPERATION TO RESULTS FILE
        FCHAR = ANSW

        IF (MYPID <= 0) WRITE(NDAT,90) ANSW(1:NCHAR)
 90     FORMAT(' .OPERATION:',5X,A)

	END
@


1.35
log
@GOTO LB WITHIN LOOP BUG
@
text
@d24 1
a24 1
C=* Email: spider@@wadsworth.org                                        *
@


1.34
log
@! COMMENT DELIMITER
@
text
@d4 14
a17 12
C  FINDLBQ.F -- ADAPTED FOR CHAR.                  AUG  89 ArDean Leith
C               MERGED WITH SEARCHQ STUFF          SEPT 97 ArDean Leith
C               ADDED IFLEVEL                      DEC. 97 ArDean Leith
C               INCORE PROCS                       JAN  01 ArDean Leith
C               LUNDONOW                           FEB  01 ArDean Leith
C               LNBLNKN                            MAY  04 ArDean Leith
C               DOC INSIDE LOOP BUG                JUL  07 ArDean Leith
C               NINSAVEOF                          NOV  09 ArDean Leith
C               PASS LOOP END WHILE HUNTING LB     DEC  09 Ardean Leith
C               PASS LB6 WHILE HUNTING LB7 BUG     JAN  10 Ardean Leith
C               IF CYCLE WITHIN DO BUG             JAN  10 Ardean Leith
C               ! COMMENT DELIMITER                DEC  11 Ardean Leith
d22 1
a22 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d72 2
d85 1
a85 1
           IF (COPT .EQ. 'B' .AND. NINSAVEOF .EQ. 0) THEN
d95 1
a95 1
              IF (LUNDONOW .GT. 0) THEN
d114 1
a114 1
           IF (ISEMICOL .GT. 0) THEN
d118 1
a118 1
           IF (NCHAR .LE. 0) CYCLE
d132 1
a132 1
           IF (LENT .GT. 0) LENANSW = MIN(LENANSW,LENT)
d139 4
a142 4
          IF (WANTLABEL(:LENLB) .EQ. 'ENDDO' .AND.
     &         ANSW(1:2)         .EQ. 'DO'   .AND.
     &         ANSW(3:3)         .NE. 'C'    .AND.
     &         ANSW(3:4)         .NE. 'LB') THEN
d148 3
a150 3
           ELSEIF (WANTLABEL(:LENLB) .EQ. 'ENDDO' .AND.
     &             ANSW(1:2)      .EQ. 'IF' .AND.
     &             IIFTHEN .GT. 5 ) THEN
d154 2
a155 2
           ELSEIF (WANTLABEL(:LENLB) .EQ. 'ENDDO' .AND.
     &             ANSW(1:5)      .EQ. 'ENDIF') THEN
d159 2
a160 2
           ELSEIF (WANTLABEL(:LENLB) .EQ. 'ENDDO' .AND.
     &             ANSW(1:5)         .EQ. 'ENDDO') THEN
d167 1
a167 1
               IF (NEEDENDO .LE. 0) THEN
d170 1
a170 1
                  IF (NEEDENDIF .GT. 0) THEN
d178 2
a179 2
           ELSEIF (ANSW(1:2) .EQ. 'LB' .AND.
     &         ANSW(:LENANSW) .EQ. WANTLABEL(:LENLB)) THEN
d184 1
a184 1
               IF (NEEDENDIF .GT. 0) THEN
d189 3
a191 3
           ELSEIF (WANTLABEL(1:2) .EQ. 'LB' .AND.
     &             ANSW(1:2)      .EQ. 'IF' .AND.
     &             IIFTHEN .GT. 5 ) THEN
d195 2
a196 2
           ELSEIF (WANTLABEL(1:2) .EQ. 'LB' .AND.
     &             ANSW(1:5)      .EQ. 'ENDIF') THEN
d200 4
a203 4
           ELSEIF (WANTLABEL(1:2) .EQ. 'LB' .AND.
     &             ANSW(1:2)      .EQ. 'DO' .AND.
     &             ANSW(3:3)      .NE. 'C'  .AND.
     &             ANSW(3:4)      .NE. 'LB') THEN
d209 2
a210 2
           ELSEIF (WANTLABEL(1:2) .EQ. 'LB' .AND.
     &             ANSW(1:5)      .EQ. 'ENDDO') THEN
d223 2
a224 2
	   IF (KEEPGO .AND. NLOOPT .GT. 0) THEN 
              IF (ANSW(1:2) .EQ. 'LB') THEN
d227 2
d230 4
a233 2
                    IF (LBNO .EQ. IDOSTK(6,I)) THEN
C                      FOUND END OF ACTIVE DO-LOOP
a234 1
                       !write(6,*) ' LBNO,IDOSTK(6,I):',LBNO,IDOSTK(6,I)
d240 1
a240 1
              ELSEIF (ANSW(1:5) .EQ. 'ENDDO') THEN
d243 1
a243 1
                 IF (NEEDENDO .LE. 0) THEN
d245 1
a245 1
                    IF (IDOSTK(6,IDOTOP).LT.0) THEN
d261 1
a261 1
        IF (MYPID .LE. 0) WRITE(NDAT,90) ANSW(1:NCHAR)
a263 1
        RETURN
a280 1
C **********************************************************************
d314 1
a314 1
           IF (COPT .EQ. 'B' .AND. NINSAVEOF .EQ. 0) THEN
d324 1
a324 1
              IF (LUNDONOW .GT. 0) THEN
d343 1
a343 1
           IF (ISEMICOL .GT. 0) THEN
d347 1
a347 1
           IF (NCHAR .LE. 0) CYCLE
d361 1
a361 1
           IF (LENT .GT. 0) LENANSW = MIN(LENANSW,LENT)
d365 2
a366 2
           IF (WANTLABEL .EQ. 'ELSE' .AND.
     &             ANSW(1:6) .EQ. 'ELSEIF') THEN
d370 1
a370 1
               IF (NEEDENDIF .LE. 0)  THEN
d374 1
a374 1
                   IF (COPT .EQ. 'B' .AND. NINSAVEOF .EQ. 0)
d378 2
a379 2
           ELSEIF (WANTLABEL .EQ. 'ELSE' .AND.
     &             ANSW(1:4) .EQ. 'ELSE') THEN
d382 1
a382 1
               IF (NEEDENDIF .LE. 0)  KEEPGO = .FALSE.
d384 2
a385 2
           ELSEIF (WANTLABEL .EQ. 'ELSE' .AND.
     &             ANSW(1:5) .EQ. 'ENDIF') THEN
d389 1
a389 1
               IF (NEEDENDIF .LE. 0) THEN
d397 3
a399 3
           ELSEIF (WANTLABEL .EQ. 'ELSE' .AND.
     &             ANSW(1:2) .EQ. 'IF'   .AND.
     &             IIFTHEN .GT. 5 ) THEN
d407 3
a409 3
           ELSEIF (WANTLABEL .EQ. 'ENDIF' .AND.
     &             ANSW(1:2) .EQ. 'IF'    .AND.
     &            IIFTHEN .GT. 5 ) THEN
d413 2
a414 2
           ELSEIF (WANTLABEL .EQ. 'ENDIF' .AND.
     &             ANSW(1:5) .EQ. 'ENDIF') THEN
d418 1
a418 1
               IF (NEEDENDIF .LE. 0) THEN
d435 1
a435 1
        IF (MYPID .LE. 0) WRITE(NDAT,90) ANSW(1:NCHAR)
a437 1
        RETURN
@


1.33
log
@GPL_2010
@
text
@d15 1
d20 1
a20 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d109 1
a109 1
           ISEMICOL = INDEX(ANSW(1:NCHAR),';')
d337 1
a337 1
           ISEMICOL = INDEX(ANSW(1:NCHAR),';')
@


1.32
log
@removed debug output write LBNO,....
@
text
@d16 3
a18 2
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
d30 1
a30 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a31 1
C=*                                                                    *
a273 19
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
@


1.31
log
@IF CYCLE WITHIN DO BUG
@
text
@d226 1
a226 1
                      write(6,*) ' LBNO,IDOSTK(6,I):',LBNO,IDOSTK(6,I)
@


1.30
log
@added idotop parameter and pass enddo code
@
text
@d14 1
d129 1
a129 1
           !write(6,*)' want: ',wantlabel(:lenlb),' answ: ',answ(1:lenansw)
d144 11
d162 7
a168 1
               IF (NEEDENDO .LE. 0) KEEPGO = .FALSE.
d216 1
a216 1
           write(6,*) ' keepgo,nloopt,newloop:',keepgo,nloopt,newloop
@


1.29
log
@nested loop exit bug
@
text
@d13 1
d36 1
a36 1
C  FINDLBQ(WANTLABEL,DOLABEL,NEWLOOP,IFLEVEL,IRTFLG)
d44 1
d54 1
a54 1
	SUBROUTINE FINDLBQ(WANTLABEL,NLOOPT,IDOSTK,NEWLOOP,
d128 1
a128 2
           !write(6,*) ' want: ',wantlabel(:lenlb)
           !write(6,*) ' answ: ',answ(1:lenansw)
d164 1
d198 1
a198 1
           !write(6,*) ' keepgo,nloopt:',keepgo,nloopt
d204 1
a204 1
                 DO I = NLOOPT,1,-1
d208 1
d211 2
a212 1
                 !write(6,*) ' set newloopl:',newloop
d217 8
a224 5
                 IF (NEEDENDO .LE. 1) THEN
C                   MUST BE A CURRENT ACTIVE DO-LOOP
                    NEWLOOP = NEWLOOP - 1
                    !write(6,*) ' set newloop:',newloop
                 ENDIF
@


1.28
log
@@@@@proc
@
text
@d4 9
a12 8
C  FINDLBQ.F -- ADAPTED FOR CHAR.          AUG  89 ArDean Leith
C               MERGED WITH SEARCHQ STUFF  SEPT 97 ArDean Leith
C               ADDED IFLEVEL              DEC. 97 ArDean Leith
C               INCORE PROCS               JAN  01 ArDean Leith
C               LUNDONOW                   FEB  01 ArDean Leith
C               LNBLNKN                    MAY  04 ArDean Leith
C               DOC INSIDE LOOP BUG        JUL  07 ArDean Leith
C               NINSAVEOF                  NOV  09 ArDean Leith
d14 3
a16 2
C=* This file is part of:                                              * C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
d35 1
a35 1
C  FINDLBQ(WANTLABEL,IDO,DOLABEL,INTHELOOP,IFLEVEL,IRTFLG)
d37 2
a38 2
C  PURPOSE:   SEARCHES FOR LB*, ELSE, OR ENDIF IN SPIDER INCOMING
C             OPERATIONS.
d42 1
a42 1
C                          CAN BE LB#, ELSE, ENDIF, EXIT
d44 3
a46 4
C	 DOLABEL        CURRENT DO-LOOP LABEL                     (SENT)
C	 INTHELOOP	T, IF CURRENT DO-LOOP LABEL IS NOT PASSED (RET.)
C			F, IF PASS CURRENT DO-LOOP LABEL - MUST POP
C			   DO-LOOP STACK IN DRIVER
d52 1
a52 1
	SUBROUTINE FINDLBQ(WANTLABEL,NLOOPT,DOLABEL,INTHELOOP,
d62 1
d64 1
a64 1
        LOGICAL                :: INTHELOOP 
d68 1
a68 1
	INTHELOOP  = .TRUE.
d70 1
a70 1
        NEEDEND    = 0
d77 1
a77 1
10         IF (COPT .EQ. 'B' .AND. NINSAVEOF .EQ. 0) THEN
d95 1
a95 1
 91           FORMAT(' *** GOTO DESTINATION NEVER FOUND: ',A)
d110 1
a110 1
           IF (NCHAR .LE. 0) GOTO 777
d126 3
d130 8
a137 5
           IF (ANSW(1:2)         .EQ. 'DO' .AND.
     &         ANSW(3:4)         .NE. 'LB' .AND.
     &         ANSW(3:3)         .NE. 'C'  .AND.
     &         WANTLABEL(:LENLB) .EQ. 'ENDDO') THEN
C              HUNTING FOR 'ENDDO' AND FOUND NESTED 'DO'
d139 4
a143 2
           ELSEIF (ANSW(1:5)     .EQ. 'ENDDO' .AND.
     &         WANTLABEL(:LENLB) .EQ. 'ENDDO') THEN
d146 3
d152 2
d156 1
a156 1
C              HUNTING FOR 'LB??' AND FOUND IT, HALT INPUT
d158 3
a160 2
               IFLEVEL = IFLEVEL + NEEDEND
               IF (NEEDEND .GT. 0) THEN
d165 1
a165 1
     &             ANSW(1:2) .EQ. 'IF'   .AND.
d167 2
a168 2
C              HUNTING FOR 'LB..' AND FOUND A NEW "IF...THEN" CLAUSE
               NEEDEND = NEEDEND + 1
d171 181
a351 3
     &             ANSW(1:5) .EQ. 'ENDIF') THEN
C              HUNTING FOR 'LB..' AND FOUND A 'END IF' 
               NEEDEND = NEEDEND - 1
d353 1
a353 2
C          --------------------------------------- SEARCHING FOR "ELSE"
           ELSEIF (WANTLABEL .EQ. 'ELSE' .AND.
d356 1
d358 1
a358 1
               IF (NEEDEND .LE. 0)  THEN
d360 1
d370 1
a370 1
               IF (NEEDEND .LE. 0)  KEEPGO = .FALSE.
d377 1
a377 1
               IF (NEEDEND .LE. 0) THEN
d383 1
a383 1
               NEEDEND = NEEDEND - 1
d390 1
a390 1
               NEEDEND = NEEDEND + 1
d393 1
d399 1
a399 1
               NEEDEND = NEEDEND + 1
d406 1
a406 1
               IF (NEEDEND .LE. 0) THEN
d412 1
a412 1
               NEEDEND = NEEDEND - 1
a414 8

C          SET INTHELOOP IF WE PASS BY CURRENT DO-LOOP LABEL
	   IF (KEEPGO .AND. NLOOPT .GT. 0 .AND. ANSW(1:2) .EQ. 'LB')THEN
              CALL GETLBNO(ANSW,LBNO,IRTFLG)
              IF (LBNO .EQ. DOLABEL) INTHELOOP = .FALSE.
           ENDIF

 777       CONTINUE
d417 1
a417 1
C       FOUND DESIRED LABEL OR ENDIF CAN RETURN NOW
@


1.27
log
@ NINSAVEOF
@
text
@d75 3
a77 2
C          INCREMENT BATCH COUNTER
10         IBCNT = IBCNT + 1
d79 1
a79 2
           IF (COPT .EQ. 'B' .AND. NINSAVEOF .EQ. 0) THEN
C             READ FROM CURRENT STORED PROCEDURE LINE IBCNT
d166 3
a168 2
C                  DECREMENT BATCH COUNTER TO RE-READ THIS LINE
                   IBCNT = IBCNT - 1
@


1.26
log
@doc within do loop bug
@
text
@d11 1
a11 1
C
d13 4
a16 5
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d18 1
a18 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d23 1
a23 1
C=* This program is distributed in the hope that it will be useful,    *
d29 1
a29 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d55 8
a62 1
        COMMON /LUNDOECHO/ LUNDONOW
d64 1
a64 13
        CHARACTER *(*) WANTLABEL
        CHARACTER *80  ANSW
        LOGICAL        KEEPGO
        INTEGER        DOLABEL
        LOGICAL        INTHELOOP 

#ifdef USE_MPI
        INCLUDE 'mpif.h'
        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, IERR)
#else
        MYPID = -1
#endif
d78 1
a78 1
           IF (COPT .EQ. 'B') THEN
d83 1
a83 2
              READ(NIN,80,IOSTAT=IOS) ANSW
80            FORMAT(A)
d100 1
a100 1
           CALL SHRINKQ(ANSW,80,ANSW,NCHAR)
@


1.25
log
@nested do  exit bug
@
text
@d10 1
d14 1
a14 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d70 2
a71 3
        INTEGER MYPID, COMM, IERR
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
d138 1
@


1.24
log
@enddo, cycle, exit
@
text
@d79 1
d136 2
a137 1
           IF (ANSW(1:5)         .EQ. 'ENDDO' .AND.
d139 8
a146 2
C              HUNTING FOR 'ENDDO' AND FOUND IT, HALT INPUT
               KEEPGO  = .FALSE.
@


1.23
log
@GPL License fixed
@
text
@d44 1
d134 6
d141 1
a141 1
           IF (ANSW(1:2) .EQ. 'LB' .AND.
d163 10
d234 3
a236 8
        FCHAR  = ANSW
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
    	   WRITE(NDAT,90) ANSW(1:NCHAR)
        ENDIF
#else
 	WRITE(NDAT,90) ANSW(1:NCHAR)
#endif
@


1.22
log
@tab support
@
text
@d2 1
a2 1
C++************************************************************************
d12 23
a34 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.21
log
@mpi
@
text
@d9 1
d11 8
a18 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d76 1
a76 1
              NCHAR = lnblnk(ANSW)
d109 1
a109 1
           LENLB = lnblnk(WANTLABEL)
d112 1
a112 1
           LENANSW = lnblnk(ANSW)
@


1.20
log
@nchar char out in operation line
@
text
@d49 9
d201 5
d207 1
@


1.19
log
@lundonow write added
@
text
@d192 1
a192 1
 	WRITE(NDAT,90) ANSW
@


1.18
log
@incore procedures
@
text
@d8 1
d41 1
d68 4
@


1.17
log
@nloop now is 0 if not in a loop
@
text
@d4 4
a7 3
C  FINDLBQ.F -- ADAPTED FOR CHAR.          AUG 89 al
C               MERGED WITH SEARCHQ STUFF  SEPT 97 al
C               ADDED IFLEVEL              DEC. 97 al
d55 2
a56 3
C          READ ANSWER STRING
10         READ(NIN,80,IOSTAT=IOS) ANSW
80         FORMAT(A80)
d58 9
a66 2
C          INCREMENT BATCH COUNTER
	   IBCNT = IBCNT + 1
a74 3

C          FIND LAST NON-BLANK            
           NCHAR = lnblnk(ANSW)
@


1.16
log
@bad string passed to getlbno
@
text
@d25 1
a25 1
C        IDO            INSIDE DO-LOOP NOW IF == 1                (SENT)
d35 1
a35 1
	SUBROUTINE FINDLBQ(WANTLABEL,IDO,DOLABEL,INTHELOOP,
d169 1
a169 1
	   IF (KEEPGO .AND. IDO .EQ. 1 .AND. ANSW(1:2) .EQ. 'LB') THEN
@


1.15
log
@used frombatch, getlbno
@
text
@d170 1
a170 1
              CALL GETLBNO(ANSW(3:),LBNO,IRTFLG)
@


1.14
log
@needed check for if...then in search for endif needend incrment
@
text
@d18 1
a18 1
C  FINDLBQ(WANTLABEL,IDO,DOLABEL,IDOFLG,IFLEVEL,IRTFLG)
d27 2
a28 2
C	 IDOFLG		0, IF CURRENT DO-LOOP LABEL IS NOT PASSED (RET.)
C			1, IF PASS CURRENT DO-LOOP LABEL - MUST POP
d35 2
a36 1
	SUBROUTINE FINDLBQ(WANTLABEL,IDO,DOLABEL,IDOFLG,IFLEVEL,IRTFLG)
a37 2
CNO_SAVE

d40 1
a40 1
        CHARACTER *(*) WANTLABEL,DOLABEL
d43 2
d46 3
a48 3
	IDOFLG  = 0
        KEEPGO  = .TRUE.
        NEEDEND = 0
d146 1
a150 1

d168 5
a172 5
C          SET IDOFLG IF WE PASS BY CURRENT DO-LOOP LABEL
	   IF (KEEPGO .AND. IDO .EQ. 1 .AND. ANSW(1:2) .EQ. 'LB' .AND.
     &         (ANSW(3:4) .EQ. DOLABEL(1:2) .OR.
     &         (DOLABEL(2:2) .EQ. ' ' .AND. 
     &          ANSW(3:3) .EQ. DOLABEL(1:1)))) IDOFLG = 1
@


1.13
log
@if ... bugs fixed
@
text
@d145 4
a149 3
           ELSEIF (WANTLABEL .EQ. 'ENDIF' .AND.
     &             ANSW(1:2) .EQ. 'IF') THEN
C              HUNTING FOR 'ENDIF' AND FOUND A NESTED IF
@


1.12
log
@iflevel not set OK
@
text
@d20 3
d47 1
a47 1
        NEEDEND = 1
d96 1
d100 5
a104 1
               KEEPGO = .FALSE.
d107 3
a109 2
     &             ANSW(1:2) .EQ. 'IF') THEN
C              HUNTING FOR 'LB..' AND FOUND A NEW IF CLAUSE
a110 1
               IFLEVEL = IFLEVEL + 1
a115 1
               IFLEVEL = IFLEVEL - 1
d117 1
d122 1
a122 1
               IF (NEEDEND .LE. 1)  KEEPGO = .FALSE.
d129 1
a129 1
               IF (NEEDEND .LE. 1) THEN
d137 9
d156 1
a156 1
               IF (NEEDEND .LE. 1) THEN
a163 6
           ELSEIF (WANTLABEL .EQ. 'ELSE' .AND.
     &             ANSW(1:2) .EQ. 'IF'   .AND.
     &             IIFTHEN .GT. 5 ) THEN
C              HUNTING FOR 'ELSE' AND FOUND IF...THEN
C              THIS IS A NESTED IF,  KEEP READING INPUT
               NEEDEND = NEEDEND + 1
@


1.11
log
@doloop passed test not complete
@
text
@d102 1
d108 1
a108 3
               IF (NEEDEND .LE. 1) THEN
                  IFLEVEL = IFLEVEL - 1
               ENDIF
d122 1
a123 1
                  IFLEVEL = IFLEVEL - 1
@


1.10
log
@added iflevel for lb finding
@
text
@d158 3
a160 1
     &         ANSW(3:4) .EQ. DOLABEL(1:2)) IDOFLG = 1
@


1.9
log
@fixed simple goto confusion about 2 vs 29 when shud goto 2
@
text
@d18 1
a18 1
C  FINDLBQ(WANTLABEL,INLOOP,DOLABEL,IDOFLG,IRTFLG)
d21 3
a23 3
C        WANTLABEL      LABEL WE ARE SEARCHING FOR               (SENT)
C        IDO            INSIDE DO-LOOP NOW IF == 1               (SENT)
C	 DOLABEL        CURRENT DO-LOOP LABEL                    (SENT)
d27 2
a28 2
C        IFLEVEL        IF CLAUSE NESTING LEVEL           (SENT & RET.) 
C        IRTFLG		ERROR NUMBER ZERO IS NORMAL              (RET.)
a37 2
	COMMON ANSW

a49 5
#ifdef SP_VMS
C          NON-PORTABLE VAX FORTRAN
  10       READ(NIN,80,IOSTAT=IOS) NCHAR,ANSW
  80       FORMAT(Q,A80)
#else
d53 1
a53 1
#endif
d98 13
d123 1
a123 1
                  KEEPGO = .FALSE.
@


1.8
log
@fixed if...else nesting bug
@
text
@d93 1
a93 1
           LENLB = lnblnk(WANTLABEL) - 3
d95 5
d101 1
a101 1
     &         ANSW(3:3+LENLB) .EQ. WANTLABEL(3:3+LENLB)) THEN
@


1.7
log
@fixed ERROR: IF..ELSE NESTING LEVEL EXCEEDED
@
text
@d120 5
d130 2
a131 2
                  KEEPGO = .FALSE.
                  IFLEVEL = IFLEVEL -1
@


1.6
log
@ibcnt needed for comment (;) lines
@
text
@d6 1
d24 1
a24 1
C	 IDOFLG		0, IF CURRENT DO-LOOP LABEL IS NOT PASSED (RET)
d26 3
a28 2
C			   DO-LOOP STACK IN DRIVER 
C        IRTFLG		ERROR NUMBER ZERO IS NORMAL               (RET)
d32 1
a32 1
	SUBROUTINE FINDLBQ(WANTLABEL,IDO,DOLABEL,IDOFLG,IRTFLG)
a43 1

d104 1
a104 1
               IF (NEEDEND .LE. 1) KEEPGO = .FALSE.
d111 4
a114 1
               IF (NEEDEND .LE. 1) KEEPGO = .FALSE.
d124 4
a127 1
               IF (NEEDEND .LE. 1) KEEPGO = .FALSE.
d151 2
a152 2
        FCHAR  = WANTLABEL
 	WRITE(NDAT,90) WANTLABEL
@


1.5
log
@needed keepgo on test for pop loop stack
@
text
@d60 3
a87 3
C          INCREMENT BATCH COUNTER
	   IBCNT = IBCNT + 1

a92 1

@


1.4
log
@if...else added
@
text
@a93 3
C          SET IDOFLG IF WE PASS BY CURRENT DO-LOOP LABEL
	   IF (IDO .EQ. 1 .AND. ANSW(1:2) .EQ. 'LB' .AND.
     &         ANSW(3:4) .EQ. DOLABEL(1:2)) IDOFLG = 1
d133 5
@


1.3
log
@ used rdpr for ; handling
@
text
@d4 2
a5 1
C  FINDLBQ.F -- ADAPTED FOR CHAR. AUG 89 al
d17 1
a17 1
C  FINDLBQ(FLAB,LABEL,IDOFLG,IER)
d20 4
a23 3
C        FLAB		LABEL SEARCHING FOR
C	 LABEL          CURRENT DO-LOOP LABEL
C	 IDOFLG		0, IF CURRENT DO-LOOP LABEL IS NOT PASSED
d26 1
a26 1
C        IER		ERROR NUMBER
d30 1
a30 1
	SUBROUTINE FINDLBQ(FLAB,LABEL,IDOFLG,IER)
d38 1
a38 1
        CHARACTER *(*) FLAB,LABEL
d40 1
a41 1
	IDOFLG = 0
d43 3
a45 1
1	ANSW(4:4) = ' '
d47 4
d52 3
a54 3
C       NON-PORTABLE VAX FORTRAN
  10    READ(NIN,80,END=99) NCHAR,ANSW
  80    FORMAT(Q,A80)
d56 3
a58 3
C       READ ANSWER STRING
10      READ(NIN,80) ANSW
80      FORMAT(A80)
d60 86
a145 15

C       FIND LAST NON-BLANK            
        NCHAR = lnblnk(ANSW)

C       CONVERT INPUT STRING TO ALL UPPER CASE
        IF (NCHAR .GT. 0) CALL SSUPCAS(ANSW(1:NCHAR))

	IBCNT = IBCNT+1

	IF (ANSW(1:2) .NE. 'LB') GOTO 1
C       COMPARING INTEGERS, SO DON'T HAVE TO WORRY ABOUT UP/LOWER CASE...
        IF (ANSW(3:4) .EQ. FLAB(3:4)) THEN
           IER = 0
           RETURN
        ENDIF
a146 7
	IF (ANSW(3:4) .EQ. LABEL(1:2)) IDOFLG = 1
	GOTO 1


#ifdef SP_VMS
 99     IER = 1
        IF (COPT .EQ. 'B') STOP '*** END OF INPUT FILE IN BATCH MODE'
a147 2
#endif

@


1.2
log
@cpp_lines_added
@
text
@d4 1
a4 2
C $$ FINDLBQ.FOR
C                  ADAPTED FOR CHAR. AUG 89 al
d16 3
a18 2
C $$ FINDLBQ(FLAB,LABEL,IDOFLG,IER)
c
d30 1
a30 1
	COMMON FC
a31 1
#ifdef SP_UNIX
a32 8
#else
        INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
C
C	MAHIEDDINE LADJADJ
C
        CHARACTER *1 PROMPT

d34 1
a34 2
C**	COMMON /BATCH/IBCNT
C**	COMMON /UNITS/LUN,NIN,NOUT
d37 1
a37 2
        CHARACTER *80  FC
        CHARACTER      NULL
d39 1
a39 1
        NULL = CHAR(0)
d41 1
a41 1
	IDOFLG=0
d43 9
a51 1
1	FC(4:4) = ' '
d53 2
a54 7
C
C	MAHIEDDINE LADJADJ
C	CHANGE 3/29/93 TO ADD ON-LINE HELP
C
C        CALL READCH(NIN,NCHAR,FC,.TRUE.,IRTFLG)
        PROMPT(1:1) = ' '
        CALL READCH(PROMPT,NIN,NCHAR,FC,.TRUE.,IRTFLG)
d56 2
a57 1
        IF (IRTFLG .NE. 0) GOTO 99
d59 1
a59 1
	IBCNT=IBCNT+1
d61 1
a61 1
	IF (FC(1:2) .NE. 'LB' .AND. FC(1:2) .NE. 'lb') GOTO 1
d63 1
a63 1
        IF (FC(3:4) .EQ. FLAB(3:4)) THEN
d68 1
a68 1
	IF (FC(3:4) .EQ. LABEL(1:2)) IDOFLG=1
d71 6
a76 1
99	IER=1
a77 1
	RETURN
@


1.1
log
@Initial revision
@
text
@d32 3
d36 1
@
