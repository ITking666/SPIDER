head	1.46;
access;
symbols
	pre_mrcs:1.46
	healthdept_2018:1.46
	pre_getangas:1.27
	GPL2010:1.23
	pre_GPL2010:1.22
	pre_var_equation:1.21
	pre_fftwrings:1.19
	pre_opfiles:1.19
	src:1.19
	best-code:1.19
	x-named-regs:1.18
	x:1.18
	v13-00:1.18
	pre_GPL:1.16
	prec_CA:1.3;
locks; strict;
comment	@c @;


1.46
date	2018.10.03.14.33.55;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2013.01.07.17.38.29;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2012.07.27.18.19.42;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2012.06.13.13.14.44;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2012.05.08.14.05.14;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2011.12.02.14.09.20;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.28.15.57.25;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2011.09.09.17.26.14;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2011.09.08.13.53.18;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2011.08.29.17.42.52;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.28.16.27.00;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2011.07.25.15.58.47;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.25.15.05.17;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2011.06.16.16.37.38;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2011.06.15.14.17.22;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.25.19.46.59;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.12.15.14.02;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.01.15.50.10;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.01.15.46.35;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2010.10.21.17.33.47;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.14.14.17.53;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.29.17.45.27;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.24.14.00.11;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.24.13.25.04;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.11.13.55.27;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.25.15.47.48;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2008.05.19.12.02.38;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.16.01.48.35;	author cyang;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.17.20.46.49;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.17.18.37.12;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.02.16.57.57;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.09.16.48.45;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.17.15.11.51;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.09.18.47.38;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.20.15.57.52;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.18.20.10.35;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.30.16.47.10;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.13.12.36.33;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2004.06.29.14.49.22;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.29.14.24.57;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.22.13.20.54;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.21.17.56.58;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.20.16.40.09;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.05.14.22.58;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.02.14.55.05;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.27.14.35.32;	author leith;	state Exp;
branches;
next	;


desc
@'AP' support
@


1.46
log
@email_health_dept
@
text
@C++*********************************************************************
C                                                                      *
C APRINGS_NEW   USED CMLIMIT                       AUG 00 ARDEAN LEITH *
C               ADDED REF_CIRC FILE                APR 01 ARDEAN LEITH *
C               NORMASS -> NORMAS                  OCT 01 ARDEAN LEITH *
C               PROMPTS                            JAN 02 ARDEAN LEITH *
C               AUTO REF RINGS FILE                DEC 04 ARDEAN LEITH *
C               SPIDER REF RINGS FILE              FEB 05 ARDEAN LEITH *
C               INULL  = lnblnkn(SCRFILE)          APR 05 ARDEAN LEITH *
C               REWRITE FOR SPEED                  MAR 08 ARDEAN LEITH *
C               BCAST_MPI                          NOV 08 ARDEAN LEITH *
C               OUTPUT TO NOUT                     AUG 09 ARDEAN LEITH *
C               APRINGS_SATU                       OCT 10 ARDEAN LEITH *
C               ALRQ_MS_FBS                        AUG 11 G KISHCHENKO *
C               ALRQ_MS_QUAD                       AUG 11 ARDEAN LEITH *
C               TYPET                              MAY 12 ARDEAN LEITH
C **********************************************************************
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2011  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  APRINGS_NEW(ILIST,NUMREF,NX,NY,
C              NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
C              REFPAT,LUNREF,CIRCREF,CIRCREF_IN_CORE,
C              LUNRING,SCRFILE,IRTFLG)
C  
C  PARAMETERS: ILIST       LIST OF IMAGE FILE NUMBERS          (INPUT)
C              NIMREF      NO. OF IMAGES                       (INPUT)
C              NX,NY   IMAGE DIMENSIONS                    (INPUT)
C              REFPAT      IMAGE SERIES FILE TEMPLATE          (INPUT)
C              LUNREF      IMAGE FILE IO UNIT                  (INPUT)
C              CIRCREF     OUTPUT ARRAY                        (OUTPUT)
C
C              CIRCREF_IN_CORE   NO OUTPUT ARRAY FLAG          (OUTPUT)
C              LUNRING      REF-RINGS FILE IO UNIT             (INPUT)
C              SCRFILE      REF-RINGS FILE                     (INPUT)
C              IRTFLG       ERROR FLAG                         (OUTPUT)
C
C NOTE: MOST MEMORY DEMAND DEPENDENT ON LCIRC & NUMREF.  LCIRC IS THE 
C       TOTAL LENGTH OF ARRAY THAT HOLDS THE CIRCULAR RINGS, SO IT IS 
C       DEPENDENT ON NUMBER OF RINGS AND THEIR RADIUS. ARRAY ALLOCATED 
C       IS: CIRCREF(LCIRC,NUMREF) ANOTHER SMALL ALLOCATED ARRAY IS: 
C       A(NX,NY,NUMTH)
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

cpgi$g opt=3

C       -------------------- APRINGS_NEW ----------------------------

        SUBROUTINE APRINGS_NEW(ILIST,NUMREF, 
     &                     NX,NY,
     &                     NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &                     REFPAT,LUNREF,CIRCREF,CIRCREF_IN_CORE,
     &                     LUNRING,SCRFILE, IRTFLG)

        IMPLICIT NONE
	INCLUDE 'CMBLOCK.INC' 
	INCLUDE 'CMLIMIT.INC' 

        INTEGER                  :: ILIST(NUMREF)
        INTEGER                  :: NUMREF,NX,NY,NRING,LCIRC
        INTEGER                  :: NUMR(3,NRING) 
	CHARACTER(LEN=1)         :: MODE
        INTEGER*8                :: FFTW_PLANS(*) !POINTERS TO STRUCTURES
        CHARACTER (LEN=*)        :: REFPAT
        INTEGER                  :: LUNREF 
        REAL                     :: CIRCREF(LCIRC,*)
        LOGICAL                  :: CIRCREF_IN_CORE
        INTEGER                  :: LUNRING 
        CHARACTER (LEN=*)        :: SCRFILE
        INTEGER                  :: IRTFLG 

        CHARACTER (LEN=MAXNAM)   :: FILNAM
        LOGICAL                  :: USEREFFILE
        LOGICAL                  :: ISOPEN
        LOGICAL                  :: WINDOW,WEIGHT

        INTEGER                  :: ICOMM,MYPID,MPIERR
        INTEGER                  :: ILOCAT,INULL,NLET,NDUM,LUNOP
        INTEGER                  :: NUMTH,LCIRCT,NUMREFT,NSLICE,MAXIM
        INTEGER                  :: IMGNUM,NE,IREF
        REAL                     :: DUM
        LOGICAL                  :: INLNED
        CHARACTER(LEN=3)         :: TYPET = 'FI'
        INTEGER                  :: lnblnkn,lnblnk

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID 

C       SEE IF THIS FILE EXISTS, (RETURNS EX, ISOPEN, LUNOP)

C       SEE IF SCRATCH "FILE" EXISTS (MAY BE INCORE FILE)
        ILOCAT = INDEX(SCRFILE,'@@')
        INULL  = lnblnkn(SCRFILE)
        IF (INULL .GT. 0 .AND. SCRFILE(1:1) .NE. '_' .AND. 
     &      ILOCAT .EQ. 0) THEN
C          ADD EXTENSION TO PHYSICAL FILENAME
           CALL FILNAMANDEXT(SCRFILE,DATEXC,FILNAM,NLET,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ELSE
           FILNAM = SCRFILE
           NLET   = lnblnk(FILNAM)
        ENDIF
#ifdef USE_MPI
        IF (MYPID .LE. 0) THEN
           INQUIRE(FILE=FILNAM,EXIST=USEREFFILE,OPENED=ISOPEN,
     &             NUMBER=LUNOP,IOSTAT=IRTFLG)
        ENDIF
        CALL BCAST_MPI('APRINGS','USEREFFILE',USEREFFILE,1, 'L',ICOMM)
#else
        USEREFFILE = .FALSE. 
        IF (INULL .GT. 0) THEN
           CALL INQUIREIF1(LUNRING,FILNAM,TYPET,USEREFFILE,ISOPEN,
     &                     LUNOP,INLNED,IMGNUM,IRTFLG)
        ENDIF
#endif

        IF (USEREFFILE .AND. MYPID .LE. 0) THEN 
           WRITE(NOUT,*) ' Using existing reference rings file: ',
     &                     FILNAM(1:NLET)
        ELSEIF (INULL > 0  .AND. MYPID .LE. 0) THEN 
           WRITE(NOUT,*) ' No existing reference rings file: ',
     &                     FILNAM(1:NLET)
        ENDIF

        WEIGHT = .TRUE.   ! REFERENCES ARE WEIGHTED

C       NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)

        IF (CIRCREF_IN_CORE  .AND. .NOT. USEREFFILE) THEN
C          CALCULATE REF. RINGS DATA AND FILL CIRCREF ARRAY WITH IT

           CALL APRINGS_FILL_NEW(ILIST,NUMREF,  NX,NY,NUMTH,
     &                      NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &                      REFPAT,LUNREF,
     &                      CIRCREF,NUMREF,0,WEIGHT,
     &                      IRTFLG)

          !IF (MYPID .LE. 0) WRITE(NOUT,*) ' Created incore reference rings'

        ELSEIF (CIRCREF_IN_CORE .AND. USEREFFILE) THEN
C          READ EXISTING REF RINGS FILE AND FILL CIRCREF ARRAY WITH ITS DATA

C          OPEN EXISTING REFERENCE RINGS FILE
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'O',IFORM,
     &                 LCIRCT,NUMREFT,NSLICE,MAXIM,' ', .TRUE.,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN

           IF (LCIRCT .NE. LCIRC .OR. NUMREFT .NE. NUMREF) THEN
               CALL ERRT(101,'REF. RINGS FILE HAS WRONG SIZE',NE)
               IRTFLG = 1
               RETURN
           ENDIF

C          FILL CIRCREF WITH EXISTING RINGS DATA FROM FILE AND RETURN.
           DO IREF=1,NUMREF
              CALL REDLIN(LUNRING,CIRCREF(1,IREF),LCIRC,IREF) 
           ENDDO

           IF (MYPID .LE. 0) THEN
             WRITE(NOUT,*) ' Loaded reference rings file incore'
           ENDIF

        ELSEIF (.NOT. CIRCREF_IN_CORE .AND. USEREFFILE) THEN
C          OPEN EXISTING REF. RINGS FILE TO READ REF RINGS DATA
 
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'O',IFORM,
     &                 LCIRCT,NUMREFT,NSLICE,MAXIM,' ', .FALSE.,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN

           IF (LCIRCT .NE. LCIRC .OR. NUMREFT .NE. NUMREF) THEN
               CALL ERRT(101,'REF. RINGS FILE HAS DIFFERENT SIZE',NE)
               IRTFLG = 1
               RETURN
           ENDIF

        ENDIF

        END


C       --------------------- APRINGS_FILL_NEW --------------------------

        SUBROUTINE APRINGS_FILL_NEW(ILIST,NUMREF,
     &                        NX,NY,NUMTH,
     &                        NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &                        REFPAT,LUNREF,
     &                        CIRCREF,ICORE,LUNRING,WEIGHT,
     &                        IRTFLG)

        IMPLICIT NONE
	INCLUDE 'CMBLOCK.INC' 
	INCLUDE 'CMLIMIT.INC' 

        INTEGER              :: ILIST(NUMREF)
        INTEGER              :: NUMREF,NX,NY,NUMTH,NRING,LCIRC
        INTEGER              :: NUMR(3,NRING)
        CHARACTER(LEN=1)     :: MODE
        INTEGER*8            :: FFTW_PLANS(*) !POINTERS TO STRUCTURES
        CHARACTER (LEN=*)    :: REFPAT 
        INTEGER              :: LUNREF
        REAL                 :: CIRCREF(LCIRC,ICORE)
        INTEGER              :: ICORE,LUNRING
        LOGICAL              :: WEIGHT
        INTEGER              :: IRTFLG

C       AUTOMATIC ARRAYS
        REAL                 :: WR(NRING)

C       ALLOCATABLE ARRAYS
	REAL, ALLOCATABLE    :: BUFIMG(:,:,:)

        INTEGER              :: NXP,NYP,MAXRIN,MWANT,IGO,IEND
        INTEGER              :: IMI,IT,IPT,IV
        INTEGER              :: ICOMM,MYPID,MPIERR 
        REAL                 :: CNS2,CNR2,RDUM
        LOGICAL, PARAMETER   :: MPIBCAST   = .TRUE.
        LOGICAL, PARAMETER   :: WANTSTATS  = .FALSE.

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID 
        IRTFLG = 0

        !IF (MYPID .LE. 0)  WRITE(NOUT,'(A,i5)') 
        !&               '  Filling reference rings with threads:',NUMTH

        IF (WEIGHT) THEN
           MAXRIN = NUMR(3,NRING) - 2

C          RINGWE RETURNS WR WEIGHTS
	   CALL RINGWE_NEW(WR,NUMR,NRING,MAXRIN)
           IF (MODE .EQ. 'H') WR = WR * 0.5
        ELSE
           WR(1) = 0.0
        ENDIF

        MWANT = NX*NY*NUMTH
        ALLOCATE(BUFIMG(NX,NY,NUMTH),  STAT=IRTFLG)

        IF (IRTFLG .NE. 0) THEN
          CALL ERRT(46,'BUFIMG...',MWANT)
          RETURN
        ENDIF 

C       CALCULATE CENTER FOR APRINGS
	CNS2 = NX / 2 + 1
	CNR2 = NY / 2 + 1

        !write(6,*) ' numref,numth: ', numref,numth

C       PREPARE CIRCULAR RINGS DATA FOR ALL REFERENCE IMAGES
C       LOOP OVER ALL REF. IMAGES, CHUNKS OF NUMTH
        DO IGO=1,NUMREF,NUMTH  
           IEND = MIN(IGO+NUMTH-1,NUMREF)

C          LOAD SET OF REFERENCE IMAGES (THERE ARE NUMTH IMAGES IN SET)
           CALL AP_GETDATA(ILIST,NUMREF, 
     &                    NX,NY, NX,NY,0.0,
     &                    NUMTH,REFPAT,LUNREF, IGO,IEND,
     &                    MPIBCAST, BUFIMG, 
     &                    WANTSTATS,RDUM,RDUM,
     &                    IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

c$omp      parallel do private(imi,ipt,it)
	   DO IMI=IGO,IEND      
              IT  = IMI - IGO + 1           ! BUFIMG INDEX
              IPT = IMI                     ! CIRCREF INDEX
              IF (LUNRING .GT. 0) IPT = IT  

C             CONVERT BUFIMG TO POLAR RINGS, FFT, & WEIGHT THE RINGS
 	      CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, 
     &                 BUFIMG(1,1,IT),
     &                .FALSE.,MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                 CIRCREF(1,IPT),IRTFLG)

c              write(6,*) 'circref(1,',ipt,'):',CIRCREF(1,IPT),it
           ENDDO

           IF (LUNRING .GT. 0) THEN
C             SAVE CIRCREF IN FILE OPENED ON LUNRING
	      DO IMI=IGO,IEND
                 IV = IMI - IGO + 1 
                 CALL WRTLIN(LUNRING,CIRCREF(1,IV),LCIRC,IMI)
              ENDDO
           ENDIF
        ENDDO

C       DEALLOCATE ARRAY
9999    IF (ALLOCATED(BUFIMG))   DEALLOCATE(BUFIMG)

	END


C       --------------------- APRINGS_ONE_NEW --------------------------

	SUBROUTINE APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, XIM, USE_OMP,
     &                         MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                         CIRC,IRTFLG)

        IMPLICIT NONE
        INCLUDE 'CMBLOCK.INC'

        INTEGER,   INTENT(IN)   :: NX,NY
        REAL,      INTENT(IN)   :: CNS2,CNR2

        REAL,      INTENT(INOUT):: XIM(NX,NY)
        LOGICAL,   INTENT(IN)   :: USE_OMP
        CHARACTER(LEN=1)        :: MODE
        INTEGER,   INTENT(IN)   :: NUMR(3,NRING)
        INTEGER,   INTENT(IN)   :: NRING,LCIRC
        REAL,      INTENT(OUT)  :: WR(*)
        INTEGER*8, INTENT(IN)   :: FFTW_PLANS(*)!POINTERS TO STRUCTURES
        REAL,      INTENT(OUT)  :: CIRC(LCIRC)
        INTEGER,   INTENT(OUT)  :: IRTFLG

        LOGICAL                 :: WEIGHTIT
        INTEGER                 :: NSB,NSE,NRB,NRE,NXLD,MAXRING
        INTEGER                 :: I,J,IGOM1,NRAYS,IRING
        DOUBLE PRECISION        :: AVG,SIGINV
        LOGICAL, PARAMETER      :: NEWFFTW     = .TRUE.
        LOGICAL, PARAMETER      :: SPIDER_SIGN = .FALSE.

        integer :: nend

C       FIND PARAMETERS TO NORMALIZE UNDER THE MASK,  
C       TRIED DOING THIS COMPLETELY ON THE
C       POLAR RINGS BUT IT GIVES SOME DIFFERENT REF. CHOICES. al

C       CALCULATE DIMENSIONS FOR NORMALIZING MASK
	NSB  = -CNS2
	NSE  =  NSB + NX - 1
	NRB  = -CNR2
	NRE  =  NRB + NY - 1

        CALL NORMASC(XIM, NSB,NSE,NRB,NRE, NUMR,NUMR(1,NRING),
     &                  AVG,SIGINV,USE_OMP)
        !write(6,*) 'AVG,SIGINV,wr(1):',AVG,SIGINV,wr(1)

C       INTERPOLATE INTO POLAR COORDINATES & APPLY NORMALIZATION
C       CREATING CIRC (RADIAL IMAGE CIRCLES) FOR THIS IMAGE POSITION
        IF (USE_FBS_INTERP) THEN

           !write(6,*)' Using fbs interp on image:',NX,' x ',NY

 	   CALL ALRQ_MS_FBS(XIM,NX,NY, CNS2,CNR2,
     &               NUMR,CIRC,LCIRC, NRING,MODE, NEWFFTW,USE_OMP, 
     &               AVG,SIGINV)
        ELSE
           !write(6,*)' Using quadratic interp on image',NX,' x ',NY

  	   CALL ALRQ_MS_QUAD(XIM,NX,NY, CNS2,CNR2,
     &               NUMR,CIRC,LCIRC, NRING,MODE, NEWFFTW,USE_OMP, 
     &               AVG,SIGINV)
        ENDIF

        !nend = numr(3,1) - 2     ! Length of ring
        !call chkreal('real ring 1', circ,lcirc, nend,1, 1)

 
        WEIGHTIT = (WR(1) > 0.0)

        IF (WR(1) < 0.0) THEN
C          RETURN SUM SQ WEIGHT FOR EACH CIRC RING

           MAXRING         = NUMR(1,NRING) 
           WR(1:MAXRING+1) = 0.0

           DO I=1,NRING

	      IRING = NUMR(1,I)      ! RING NUMBER
	      IGOM1 = NUMR(2,I) - 1  ! START LOC. WITHIN CIRC -1
              NRAYS = NUMR(3,I) - 2  ! NUMBER OF RAYS = POINTS ON RING   

C             NORMALIZATION DETERMINATION
              DO J = 1,NRAYS
                 WR(IRING) = WR(IRING) + CIRC(IGOM1 + J)**2
              ENDDO

              WR(MAXRING + 1) = WR(MAXRING + 1) + WR(IRING)
 
	   ENDDO
        ENDIF

C       FOURIER TRANSFORM CIRC RINGS
        CALL FRNGS_NEWT(CIRC,LCIRC, NUMR,NRING, SPIDER_SIGN,
     &                  FFTW_PLANS, USE_OMP)

        IF (WEIGHTIT) THEN
C          WEIGHT TRANSFORMED CIRC RINGS  USING  FACTORS FROM: WR
           CALL APPLYWS_NEW(CIRC,LCIRC,NUMR,WR,NRING)
        ENDIF

        IRTFLG = 0
        END


C       ---------------  APRINGS_INIT_PLANS -----------------------------

        SUBROUTINE APRINGS_INIT_PLANS(NUMR,NRING,
     &                                FFTW_PLANS,NPLANS,
     &                                NX,NY,IRTFLG)

C       INITIALIZE REV. FFTW3 PLAN(S) FOR USE WITHIN OMP ||

	INCLUDE 'CMBLOCK.INC' 

        INTEGER, INTENT(IN)    :: NUMR(3,NRING)
        INTEGER, INTENT(IN)    :: NRING
        INTEGER, INTENT(IN)    :: NPLANS
        INTEGER, INTENT(IN)    :: NX,NY
        INTEGER, INTENT(OUT)   :: IRTFLG

C       FFTW_PLANS IS AN ARRAY OF POINTERS TO STRUCTURES 
        INTEGER*8, INTENT(OUT) :: FFTW_PLANS(NPLANS)

        FFTW_PLANS = 0
        IRTFLG     = 1
        NUMTH      = 1

        LENO = -1
        DO I=1,NRING
           LEN = NUMR(3,I) - 2     ! LENGTH OF RING

           IF (LEN > LENO) THEN
C             CREATE PLAN FOR THIS NEW RING LENGTH

              INDX = LOG2(LEN) - 1

              IF (INDX < 2 ) THEN
                 write(NOUT,'(A,3I6,I14)')' plan i,len,indx:',i,len,indx
                 CALL ERRT(102,'APRINGS_INIT_PLANS; BAD INDX',INDX)
                 RETURN
              ELSEIF (INDX > NPLANS) THEN
                 write(NOUT,'(A,3I6,I14)')' PLAN I,LEN,INDX:',i,len,indx
                 WRITE(NOUT,*) ' CREATING FFTW_PLANS(',INDX,')'
                 CALL ERRT(102,'APRINGS_INIT_PLANS; OVERFLOW',NPLANS)
                 RETURN
              ENDIF

 	      CALL FFTW3_MAKEPLAN(LEN,1,1, NUMTH,
     &                            FFTW_PLANS(INDX),+1,IRTFLG)

              IF (IRTFLG .NE. 0) RETURN
              !write(6,'(a,3i6,i14)')'plan i,len,indx:',i,len,indx,fftw_plans(indx)

              LENO = LEN
           ENDIF
        ENDDO

C       INITIALIZE REV. FFTW3 PLAN FOR USE WITHIN OMP ||
C       CAN USE INDX = 1 FOR REVERSE PLAN AS IT IS NEVER NEEDED ELSEWHERE.

        MAXRIN = NUMR(3,NRING) - 2
 	CALL FFTW3_MAKEPLAN(MAXRIN,1,1, NUMTH,
     &                      FFTW_PLANS(1),-1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        IF (USE_FBS_INTERP .AND. NX > 0 .AND. NY > 0) THEN
C          CREATE CACHED PLANS FOR FBS ALSO
           CALL FMRS_PLAN(.FALSE.,FDUM,NX,NY,1, NUMTH,+1,IRTFLG)
           CALL FMRS_PLAN(.FALSE.,FDUM,NX,NY,1, NUMTH,-1,IRTFLG)
        ENDIF

        IRTFLG = 0

        END




C **********************************************************************
C
C  APRINGS_SATU 
C  
C  PURPOSE: CONVERT IMAGE--> POLAR RINGS .

C  SOME PARAMETERS:
C       IMGBUF              IMAGE SIZE                        (INPUT)
C       NX,NY           ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
C       COEFFS              COEF.                             (INPUT)
C       IXY                 COEF.  LOCS.                      (INPUT)
C       CIRCT               SCRATCH AREA                      (OUTPUT)
C       CIRCIMG             IMAGE IN POLAR RINGS              (OUTPUT)
C       IRTFLG              ERROR FLAG                        (OUTPUT)
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

cpgi$g opt=3

        SUBROUTINE APRINGS_SATU(IMGBUF,NX,NY,CNS2,CNR2, 
     &                          MODE,NUMR,NRING,LCIRC,USE_OMP,
     &                          WR,FFTW_PLANS, NLOCS,NRAYSC,
     &                          COEFFS,IXY, USECOEF,TRANS,CPLX,
     &                          CIRCT,  CIRCIMG, IRTFLG)

C       NOTE: RUNS WITHIN OMP PARALLEL SECTION OF CODE!

        IMPLICIT NONE

	REAL                   :: IMGBUF(NX,NY)
        INTEGER                :: NX,NY
        REAL                   :: CNS2,CNR2
        CHARACTER (LEN=1)      :: MODE
        INTEGER                :: NRING,LCIRC
        INTEGER                :: NUMR(3,NRING) 
        LOGICAL                :: USE_OMP
        REAL                   :: WR(1)          ! WEIGHTS
        INTEGER *8             :: FFTW_PLANS(*)  ! STRUCTURE POINTERS
        INTEGER                :: NLOCS(2,*)     ! IF TRANS ONLY
        INTEGER                :: NRAYSC
        REAL                   :: COEFFS(6,LCIRC)! IF USECOEF ONLY
        INTEGER                :: IXY(2,LCIRC)   ! IF USECOEF ONLY

        LOGICAL                :: USECOEF        ! CREATE COEF
        LOGICAL                :: TRANS          ! TRANSFORMED RAYS
        LOGICAL                :: CPLX           ! COMPLEX CROSRNG
        REAL                   :: CIRCT(LCIRC)   ! WORK AREA IF TRANS

        REAL,   INTENT(OUT)    :: CIRCIMG(LCIRC)
        INTEGER,INTENT(OUT)    :: IRTFLG

        INTEGER                :: MAXRIN

        IRTFLG = 0
        MAXRIN = NUMR(3,NRING) - 2 ! ACTUAL LENGTH OF LONGEST RING

C       CONVERT IMAGE TO POLAR RINGS ----------------

        IF (TRANS) THEN
C          NOT USING COEFF ARRAY,  TRANSFORMED RINGS

           CALL APRINGS_TRANS_ONE(IMGBUF,NX,NY,  CNS2,CNR2,
     &                            NUMR,NRING, NLOCS,NRAYSC,
     &                            MODE,USE_OMP, WR,FFTW_PLANS,
     &                            CIRCT,LCIRC, CIRCIMG,LCIRC/2)

        ELSEIF (.NOT. USECOEF) THEN
C          NOT USING COEFF ARRAY, NON-TRANSFORMED RINGS

           CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, 
     &                          IMGBUF,USE_OMP,
     &                          MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                          CIRCIMG,IRTFLG)

        ELSEIF (USECOEF) THEN
C          USING COEFF ARRAY, EITHER TRANSFORMED RINGS OR NOT

           CALL APRINGS_ONE_COEF(IMGBUF, NX,NY, CNS2,CNR2, 
     &                           NUMR,NRING, NLOCS,NRAYSC,
     &                           COEFFS,IXY,
     &                           USE_OMP, WR, FFTW_PLANS, TRANS,
     &                           CIRCT,LCIRC, CIRCIMG, IRTFLG)
        ENDIF

        END














 




@


1.45
log
@can
can return WR sum sq of rings
@
text
@d22 1
a22 1
C=* Email: spider@@wadsworth.org                                        *
@


1.44
log
@added error msg to init_plans, nx
@
text
@d331 1
a331 1
        REAL,      INTENT(IN)   :: WR(NRING)
d336 3
a338 1
        INTEGER                 :: NSB,NSE,NRB,NRE,NXLD
d368 1
a368 1
       ELSE
d379 25
d408 1
a408 1
        IF (WR(1) > 0.0) THEN
@


1.43
log
@AVT,VRINV renamed,   nx,ny
@
text
@d38 1
a38 1
C  APRINGS_NEW(ILIST,NUMREF,NSAM,NROW,
d45 1
a45 1
C              NSAM,NROW   IMAGE DIMENSIONS                    (INPUT)
d59 1
a59 1
C       A(NSAM,NROW,NUMTH)
d69 1
a69 1
     &                     NSAM,NROW,
d79 1
a79 1
        INTEGER                  :: NUMREF,NSAM,NROW,NRING,LCIRC
d151 1
a151 1
           CALL APRINGS_FILL_NEW(ILIST,NUMREF,  NSAM,NROW,NUMTH,
d205 1
a205 1
     &                        NSAM,NROW,NUMTH,
d216 1
a216 1
        INTEGER              :: NUMREF,NSAM,NROW,NUMTH,NRING,LCIRC
d233 1
a233 1
        INTEGER              :: NSAMP,NROWP,MAXRIN,MWANT,IGO,IEND
d256 2
a257 2
        MWANT = NSAM*NROW*NUMTH
        ALLOCATE(BUFIMG(NSAM,NROW,NUMTH),  STAT=IRTFLG)
d265 2
a266 2
	CNS2 = NSAM / 2 + 1
	CNR2 = NROW / 2 + 1
d277 1
a277 1
     &                    NSAM,NROW, NSAM,NROW,0.0,
d291 1
a291 1
 	      CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, 
d394 1
a394 1
     &                                NSAM,NROW,IRTFLG)
d400 5
a404 6
        INTEGER, INTENT(IN)  :: NUMR(3,NRING)
        INTEGER, INTENT(IN)  :: NRING
        INTEGER, INTENT(IN)  :: NPLANS
        INTEGER, INTENT(OUT) :: IRTFLG

#ifdef SP_LIBFFTW3
d416 2
a417 1
           IF (LEN .GT. LENO) THEN
d422 6
a427 1
              IF (INDX .LT. 2 .OR. INDX .GT. NPLANS) THEN
d429 1
a429 1
                 CALL ERRT(102,'FFTW_PLANS LIMITED TO 2...',NPLANS)
d432 1
d437 1
a437 1
              !write(6,'a,3i6,i14')'plan i,len,indx:',i,len,indx,fftw_plans(indx)
d451 1
a451 2

        IF (USE_FBS_INTERP .AND. NSAM > 0 .AND. NROW > 0) THEN
d453 2
a454 2
           CALL FMRS_PLAN(.FALSE.,FDUM,NSAM,NROW,1, NUMTH,+1,IRTFLG)
           CALL FMRS_PLAN(.FALSE.,FDUM,NSAM,NROW,1, NUMTH,-1,IRTFLG)
a456 1
#endif
d472 1
a472 1
C       NSAM,NROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
d484 1
a484 1
        SUBROUTINE APRINGS_SATU(IMGBUF,NSAM,NROW,CNS2,CNR2, 
d494 2
a495 2
	REAL                   :: IMGBUF(NSAM,NROW)
        INTEGER                :: NSAM,NROW
d526 1
a526 1
           CALL APRINGS_TRANS_ONE(IMGBUF,NSAM,NROW,  CNS2,CNR2,
d534 1
a534 1
           CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, 
d542 1
a542 1
           CALL APRINGS_ONE_COEF(IMGBUF, NSAM,NROW, CNS2,CNR2, 
@


1.42
log
@typet for inquireif1
@
text
@d316 1
a316 1
	SUBROUTINE APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, XIM, USE_OMP,
d323 1
a323 1
        INTEGER,   INTENT(IN)   :: NSAM,NROW
d326 1
a326 1
        REAL,      INTENT(INOUT):: XIM(NSAM,NROW)
d337 1
a337 1
        DOUBLE PRECISION        :: AVT,VRINV
d349 1
a349 1
	NSE  =  NSB + NSAM - 1
d351 1
a351 1
	NRE  =  NRB + NROW - 1
d354 2
a355 3
     &               AVT,VRINV,USE_OMP)

        !write(6,*) 'avt,vrinv,wr(1):',avt,vrinv,wr(1)
d361 1
a361 1
           !write(6,*)' Using fbs interp on image:',nsam,' x ',nrow
d363 1
a363 1
 	   CALL ALRQ_MS_FBS(XIM,NSAM,NROW, CNS2,CNR2,
d365 1
a365 1
     &               AVT,VRINV)
d367 1
a367 1
           !write(6,*)' Using quadratic interp on image',nsam,' x ',nrow
d369 1
a369 1
  	   CALL ALRQ_MS_QUAD(XIM,NSAM,NROW, CNS2,CNR2,
d371 1
a371 1
     &               AVT,VRINV)
d381 1
a381 1
        IF (WR(1) .GT. 0.0) THEN
a387 1

@


1.41
log
@ MPIBCAST  = .TRUE. now on AP_GETDATA call
@
text
@d16 1
d102 1
d130 1
a130 1
           CALL INQUIREIF1(LUNRING,FILNAM,DUM,NDUM,USEREFFILE,ISOPEN,
@


1.40
log
@removed alrq_fbp
@
text
@d235 1
a235 1
        LOGICAL, PARAMETER   :: USEMPIREAD = .FALSE.
d277 1
a277 1
     &                    USEMPIREAD, BUFIMG, 
@


1.39
log
@wantpws paramter bug.
@
text
@a13 1
C               ALRQ_MS_FBP                        JUN 11 G KISHCHENKO *
d365 1
a365 8
        ELSEIF (USE_FBP_INTERP) THEN
           !write(6,*) ' Using fbp interp on image:',nsam,' x ',nrow

           NXLD = NSAM + 2 - MOD(NSAM,2)
 	   CALL ALRQ_MS_FBP(XIM,NSAM,NROW, CNS2,CNR2,
     &               NUMR,CIRC,LCIRC, NRING,MODE, NEWFFTW,USE_OMP, 
     &               AVT,VRINV)
        ELSE
d446 2
a447 2
        IF (USE_FBP_INTERP .AND. NSAM > 0 .AND. NROW > 0) THEN
C          CREATE CACHED PLANS FOR FBP ALSO
@


1.38
log
@removed pws stuff
@
text
@d3 1
a3 1
C    APRINGS.F  USED CMLIMIT                       AUG 00 ARDEAN LEITH *
a102 1
        LOGICAL                  :: WANTPWS = .FALSE.
a143 1

d154 1
a154 1
     &                      WANTPWS,IRTFLG)
@


1.37
log
@pws ring creation added
@
text
@a63 4

C   !!!!!!!!! alter: apref_p.f, apref_pm.f apsh_psc.f apsh_ps.f apsh_ss.f dsgrs.f


a201 135
C       -------------------- APRINGS_NEW_PWS ----------------------------

        SUBROUTINE APRINGS_NEW_PWS(ILIST,NUMREF, 
     &                     NSAM,NROW,
     &                     NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &                     REFPAT,LUNREF,CIRCREF,CIRCREF_IN_CORE,
     &                     LUNRING,SCRFILE, WANTPWS, IRTFLG)

        IMPLICIT NONE
	INCLUDE 'CMBLOCK.INC' 
	INCLUDE 'CMLIMIT.INC' 

        INTEGER                  :: ILIST(NUMREF)
        INTEGER                  :: NUMREF,NSAM,NROW,NRING,LCIRC
        INTEGER                  :: NUMR(3,NRING) 
	CHARACTER(LEN=1)         :: MODE
        INTEGER*8                :: FFTW_PLANS(*) !POINTERS TO STRUCTURES
        CHARACTER (LEN=*)        :: REFPAT
        INTEGER                  :: LUNREF 
        REAL                     :: CIRCREF(LCIRC,*)
        LOGICAL                  :: CIRCREF_IN_CORE
        INTEGER                  :: LUNRING 
        CHARACTER (LEN=*)        :: SCRFILE
        LOGICAL                  :: WANTPWS
        INTEGER                  :: IRTFLG 

        CHARACTER (LEN=MAXNAM)   :: FILNAM
        LOGICAL                  :: USEREFFILE
        LOGICAL                  :: ISOPEN
        LOGICAL                  :: WINDOW,WEIGHT

        INTEGER                  :: ICOMM,MYPID,MPIERR
        INTEGER                  :: ILOCAT,INULL,NLET,NDUM,LUNOP
        INTEGER                  :: NUMTH,LCIRCT,NUMREFT,NSLICE,MAXIM
        INTEGER                  :: IMGNUM,NE,IREF
        REAL                     :: DUM
        LOGICAL                  :: INLNED
        INTEGER                  :: lnblnkn,lnblnk

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID 

C       SEE IF THIS FILE EXISTS, (RETURNS EX, ISOPEN, LUNOP)

C       SEE IF SCRATCH "FILE" EXISTS (MAY BE INCORE FILE)
        ILOCAT = INDEX(SCRFILE,'@@')
        INULL  = lnblnkn(SCRFILE)
        IF (INULL .GT. 0 .AND. SCRFILE(1:1) .NE. '_' .AND. 
     &      ILOCAT .EQ. 0) THEN
C          ADD EXTENSION TO PHYSICAL FILENAME
           CALL FILNAMANDEXT(SCRFILE,DATEXC,FILNAM,NLET,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ELSE
           FILNAM = SCRFILE
           NLET   = lnblnk(FILNAM)
        ENDIF
#ifdef USE_MPI
        IF (MYPID .LE. 0) THEN
           INQUIRE(FILE=FILNAM,EXIST=USEREFFILE,OPENED=ISOPEN,
     &             NUMBER=LUNOP,IOSTAT=IRTFLG)
        ENDIF
        CALL BCAST_MPI('APRINGS','USEREFFILE',USEREFFILE,1, 'L',ICOMM)
#else
        USEREFFILE = .FALSE. 
        IF (INULL .GT. 0) THEN
           CALL INQUIREIF1(LUNRING,FILNAM,DUM,NDUM,USEREFFILE,ISOPEN,
     &                     LUNOP,INLNED,IMGNUM,IRTFLG)
        ENDIF
#endif

        IF (USEREFFILE .AND. MYPID .LE. 0) THEN 
           WRITE(NOUT,*) ' Using existing reference rings file: ',
     &                     FILNAM(1:NLET)
        ELSEIF (INULL > 0  .AND. MYPID .LE. 0) THEN 
           WRITE(NOUT,*) ' No existing reference rings file: ',
     &                     FILNAM(1:NLET)
        ENDIF

        WEIGHT = .TRUE.   ! REFERENCES ARE WEIGHTED


C       NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)

        IF (CIRCREF_IN_CORE  .AND. .NOT. USEREFFILE) THEN
C          CALCULATE REF. RINGS DATA AND FILL CIRCREF ARRAY WITH IT

           CALL APRINGS_FILL_NEW(ILIST,NUMREF,  NSAM,NROW,NUMTH,
     &                      NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &                      REFPAT,LUNREF,
     &                      CIRCREF,NUMREF,0,WEIGHT,
     &                      WANTPWS,IRTFLG)

          !IF (MYPID .LE. 0) WRITE(NOUT,*) ' Created incore reference rings'

        ELSEIF (CIRCREF_IN_CORE .AND. USEREFFILE) THEN
C          READ EXISTING REF RINGS FILE AND FILL CIRCREF ARRAY WITH ITS DATA

C          OPEN EXISTING REFERENCE RINGS FILE
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'O',IFORM,
     &                 LCIRCT,NUMREFT,NSLICE,MAXIM,' ', .TRUE.,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN

           IF (LCIRCT .NE. LCIRC .OR. NUMREFT .NE. NUMREF) THEN
               CALL ERRT(101,'REF. RINGS FILE HAS WRONG SIZE',NE)
               IRTFLG = 1
               RETURN
           ENDIF

C          FILL CIRCREF WITH EXISTING RINGS DATA FROM FILE AND RETURN.
           DO IREF=1,NUMREF
              CALL REDLIN(LUNRING,CIRCREF(1,IREF),LCIRC,IREF) 
           ENDDO

           IF (MYPID .LE. 0) THEN
             WRITE(NOUT,*) ' Loaded reference rings file incore'
           ENDIF

        ELSEIF (.NOT. CIRCREF_IN_CORE .AND. USEREFFILE) THEN
C          OPEN EXISTING REF. RINGS FILE TO READ REF RINGS DATA
 
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'O',IFORM,
     &                 LCIRCT,NUMREFT,NSLICE,MAXIM,' ', .FALSE.,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN

           IF (LCIRCT .NE. LCIRC .OR. NUMREFT .NE. NUMREF) THEN
               CALL ERRT(101,'REF. RINGS FILE HAS DIFFERENT SIZE',NE)
               IRTFLG = 1
               RETURN
           ENDIF

        ENDIF

        END
d210 1
a210 1
     &                        WANTPWS, IRTFLG)
a225 1
        LOGICAL              :: WANTPWS
a232 1
	REAL, ALLOCATABLE    :: BUFIMG_P(:,:,:)
d234 1
a234 1
        INTEGER              :: NSAMP,NROWP,MAXRIN,NXLD,MWANT,IGO,IEND
d237 1
a237 2
        REAL                 :: CNS2,CNR2
        DOUBLE PRECISION     :: DDUM
a240 6
        character(len=7)     :: filpws = 'jnkpws0'
        integer,save         :: nfil   = 0
        integer              :: lunout = 11
        integer              :: itype  = 1 
        integer              :: maxim  = 0

d257 3
a259 12
        IF (WANTPWS) THEN
C          DO POWER SPECTRUM ON IMAGE FIRST
           NXLD  = NSAM+2-MOD(NSAM,2)
           MWANT = NXLD*NROW*NUMTH + NSAM*NROW*NUMTH
           ALLOCATE(BUFIMG_P(NXLD,NROW,NUMTH),
     &              BUFIMG(NSAM,NROW,NUMTH), STAT=IRTFLG)
        ELSE
C          USE RAW POLAR IMAGE
           NXLD  = NSAM         ! NO FOURIER PAD
           MWANT = NSAM*NROW*NUMTH
           ALLOCATE(BUFIMG(NSAM,NROW,NUMTH),  STAT=IRTFLG)
        ENDIF
d277 1
a277 3
           IF (.NOT. WANTPWS) THEN
C             NO PADDING OF BUFIMG
              CALL AP_GETDATA(ILIST,NUMREF, 
d281 1
a281 1
     &                    WANTSTATS,DDUM,DDUM,
d283 1
a283 39
              IF (IRTFLG .NE. 0) GOTO 9999

           ELSE

C             PADDING OF BUFIMG_P
C             LOAD SET OF REFERENCE IMAGES (THERE ARE NUMTH IMAGES IN SET)
              CALL AP_GETDATA(ILIST,NUMREF, 
     &                    NSAM,NROW, NXLD,NROW,0.0,
     &                    NUMTH,REFPAT,LUNREF, IGO,IEND,
     &                    USEMPIREAD, BUFIMG_P, 
     &                    WANTSTATS,DDUM,DDUM,
     &                    IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999

C             CONVERT NXLD PADDED IMAGES TO POWER SPECTRA
	      DO IMI=IGO,IEND      
                 IT  = IMI - IGO + 1           ! BUFIMG INDEX

C                GET POWER SPECTRA FROM IMAGES, NO NEED TO SAVE FFT
	         CALL MAKEPWS(BUFIMG_P(1,1,IT),NXLD,NSAM,NROW, 
     &                        BUFIMG(1,1,IT), IRTFLG)

#ifdef DEBUGNEVER
c-----------------debug
                 nfil = nfil + 1
                 write(filpws(7:7),FMT='(i1)')nfil
                 write(6,*) ' Saving: ', filpws(:7)

                 maxim = 0
                 itype = 1
                 call opfilec(0,.false.,filpws,lunout,'U',itype,
     &                nsam,nrow,1,maxim,' ',.false.,irtflg)
                 call wrtvol(lunout,nsam,nrow,1,1,bufimg(1,1,it),irtflg)
                 close(lunout)
c---------------------------
#endif
              ENDDO
           ENDIF

a310 1
        IF (ALLOCATED(BUFIMG_P)) DEALLOCATE(BUFIMG_P)
@


1.36
log
@IMPLICIT NONE, INCLUDE 'CMBLOCK.INC'
@
text
@d15 2
a16 1
C               ALRQ_MS_FBS                        JUL 11 G KISHCHENKO *
d64 4
d76 1
a76 1
     &                     LUNRING,SCRFILE,IRTFLG)
d78 1
d82 26
a107 15
	CHARACTER(LEN=1)                  :: MODE
        INTEGER, DIMENSION(NUMREF)        :: ILIST
        INTEGER, DIMENSION(3,NRING)       :: NUMR 
        REAL,    DIMENSION(LCIRC,*)       :: CIRCREF 
        CHARACTER (LEN=MAXNAM)            :: FILNAM
        CHARACTER (LEN=*)                 :: SCRFILE,REFPAT
        LOGICAL                           :: USEREFFILE,CIRCREF_IN_CORE
        LOGICAL                           :: ISOPEN
        LOGICAL                           :: WINDOW,WEIGHT

C       FFTW_PLANS CONTAINS POINTERS TO STRUCTURES 
        INTEGER*8                         :: FFTW_PLANS(*)

C       ALLOCATABLE ARRAYS
	REAL, ALLOCATABLE, DIMENSION(:,:) :: XIM
d159 2
a160 1
     &                      CIRCREF,NUMREF,0,WEIGHT,IRTFLG)
d189 2
a190 1
C          OPEN EXISTING REF. RINGS FILE TO READ REF RINGS DATA 
d202 54
a255 8
        ELSEIF (.NOT. CIRCREF_IN_CORE .AND. .NOT. USEREFFILE) THEN
C          CALCULATE REF. RINGS DATA AND FILL REF RINGS FILE WITH DATA
C          i do not believe this is used any more???? al

C          CREATE REFERENCE RINGS FILE FOR OUTPUT
           NSL = 1
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'B',IFORM,
     &                  LCIRC,NUMREF,NSL,MAXIM,' ', .FALSE.,IRTFLG)
d257 17
d275 9
a283 2
           IF (MYPID .LE. 0) WRITE (NOUT,90) SCRFILE
90         FORMAT ('  Created reference rings file: ',A )
a284 1
C          FILL REF_CIRC FILE WITH RINGS DATA
d286 2
a287 4
           CALL APRINGS_FILL_NEW(ILIST,NUMREF, NSAM,NROW,NUMTH,
     &                  NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &                  REFPAT,LUNREF,
     &                  CIRCREF,NUMTH,LUNRING,WEIGHT,IRTFLG)
d289 48
a336 2
           IF (MYPID .LE. 0) WRITE (NOUT,92) SCRFILE
92         FORMAT ('  Filled reference rings file: ',A )
a341 1

d348 2
a349 1
     &                        CIRCREF,ICORE,LUNRING,WEIGHT,IRTFLG)
d351 1
d355 3
d359 1
d361 1
a361 5
        LOGICAL              :: WINDOW,WEIGHT

C       EXTERNAL ARRAYS
        INTEGER              :: ILIST(NUMREF)
        INTEGER              :: NUMR(3,NRING)
d363 4
a366 3

C       FFTW_PLANS CONTAINS POINTERS TO STRUCTURES 
        INTEGER*8            :: FFTW_PLANS(*)
d372 16
a387 1
	REAL, ALLOCATABLE    :: XIM(:,:,:)
d392 2
a393 2
!        IF (MYPID .LE. 0)  WRITE(NOUT,'(A,i5)') 
!     &               '  Filling reference rings with threads:',NUMTH
a395 2
           MAXRIN = NUMR(3,NRING)
#ifdef SP_LIBFFTW3
a396 1
#endif
d405 15
a419 4
        ALLOCATE(XIM(NSAM,NROW,NUMTH), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
            CALL ERRT(46,'XIM',NSAM*NROW*NUMTH)
            RETURN
d426 2
d434 16
a449 1
	   CALL AP_GETDAT(ILIST,NUMREF,NSAM,NROW,NSAM,NROW,
d451 30
a480 2
     &                    1,NROW,1,NSAM, XIM, IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
d482 1
a482 1
c$omp      parallel do private(IMI,IPT,IT)
d484 1
a484 1
              IT  = IMI - IGO + 1           ! XIM INDEX
d488 3
a490 2
C             CONVERT XIM TO POLAR RINGS, FFT, & WEIGHT THE RINGS
 	      CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, XIM(1,1,IT),
d492 1
a492 1
     &                CIRCREF(1,IPT),IRTFLG)
d507 2
a508 1
9999    IF (ALLOCATED(XIM)) DEALLOCATE(XIM)
d522 2
a523 1
        INTEGER                  :: NSAM,NROW,NRING,LCIRC
d525 14
a538 17
        REAL                     :: CNS2,CNR2
C       EXTERNAL ARRAYS
	REAL, INTENT(IN)         :: XIM(NSAM,NROW)
        REAL, INTENT(OUT)        :: CIRC(LCIRC)
        INTEGER, INTENT(IN)      :: NUMR(3,NRING)
        REAL, INTENT(IN)         :: WR(NRING)

        LOGICAL, INTENT(IN)      :: USE_OMP
        CHARACTER(LEN=1)         :: MODE
        INTEGER                  :: IRTFLG

C       FFTW_PLANS CONTAINS POINTERS TO STRUCTURES 
        INTEGER*8, INTENT(IN)    :: FFTW_PLANS(*)

        DOUBLE PRECISION         :: AVT,VRINV
        LOGICAL, PARAMETER       :: NEWFFTW     = .TRUE.
        LOGICAL, PARAMETER       :: SPIDER_SIGN = .FALSE.
d540 1
a540 1
        INTEGER                  :: NSB,NSE,NRB,NRE
d555 1
a555 1
        !write(6,*) 'avt,vrinv:',avt,vrinv,wr(1)
d559 5
a563 2
        IF (USE_FBP_INTERP) THEN
  	   CALL ALRQ_MS_FBP(XIM,NSAM,NROW, CNS2,CNR2,
d566 5
a570 2
        ELSEIF (USE_FBS_INTERP) THEN
  	   CALL ALRQ_MS_FBS(XIM,NSAM,NROW, CNS2,CNR2,
d574 3
a576 1
  	   CALL ALRQ_MS_NEW(XIM,NSAM,NROW, CNS2,CNR2,
d581 3
d654 2
a655 3
        IF ((USE_FBP_INTERP .AND. NSAM > 0 .AND. NROW > 0) .OR.
     &      (USE_FBS_INTERP .AND. NSAM > 0 .AND. NROW > 0)) THEN
C          CREATE CACHED PLANS FOR FBP/FBS ALSO
d659 1
@


1.35
log
@typo
@
text
@d315 6
d329 1
d337 2
@


1.34
log
@calls FBP interp now
@
text
@d432 2
a433 2
        IF ((USE_FBP_INTERP .AND. NSAM > 0 .AND. NROW > 0 .OR.
     &      (USE_FBS_INTERP .AND. NSAM > 0 .AND. NROW > 0) THEN
@


1.33
log
@IF (USE_FBP_INTERP
@
text
@d15 1
d352 4
d432 3
a434 2
        IF (USE_FBP_INTERP .AND. NSAM > 0 .AND. NROW > 0) THEN
C          CREATE CACHED PLANS FOR FBP ALSO
a437 1

@


1.32
log
@removed unused: APRINGS_ONE
@
text
@d2 13
a14 12
C
C    APRINGS.F      USED CMLIMIT                  AUG 00 ARDEAN LEITH
C                   ADDED REF_CIRC FILE           APR 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   AUTO REF RINGS FILE           DEC 04 ARDEAN LEITH
C                   SPIDER REF RINGS FILE         FEB 05 ARDEAN LEITH
C                   INULL  = lnblnkn(SCRFILE)     APR 05 ARDEAN LEITH
C                   REWRITE FOR SPEED             MAR 08 ARDEAN LEITH
C                   BCAST_MPI                     NOV 08 ARDEAN LEITH
C                   OUTPUT TO NOUT                AUG 09 ARDEAN LEITH
C                   APRINGS_SATU                  OCT 10 ARDEAN LEITH
d36 4
a39 4
C  APRINGS(ILIST,NUMREF,NSAM,NROW,NDUM,NDUM,
C          NRING,LCIRC,NUMR,MODE, 
C          REFPAT,LUNREF,CIRCREF,CIRCREF_IN_CORE,
C          LUNRING,SCRFILE,IRTFLG)
d184 1
a184 1
C          i do not beleive this is used any more???? al
d347 6
a352 1
  	CALL ALRQ_MS_NEW(XIM,NSAM,NROW, CNS2,CNR2,
d355 1
d374 2
a375 1
     &                                FFTW_PLANS,NPLANS,IRTFLG)
d379 2
a417 1
C       CAN USE INDX = 1 FOR REVERSE PLAN AS IT IS NEVER NEEDED ELSEWISE
d419 1
d425 8
@


1.31
log
@CALL ERRT(102,'FFTW_PLANS LIMITED TO 2...',NPLANS
@
text
@d17 1
a17 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
a420 112

C       --------------------- APRINGS_ONE --------------------------

C  still used in: writpro_n.f should be replaced !!!!!!!!!!!!!!!!!



	SUBROUTINE APRINGS_ONE(NSAM,NROW,WR,
     &                         XIM,CIRC,MODE,NUMR,NRING,LCIRC,
     &                         IRTFLG)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

C       EXTERNAL ARRAYS
	REAL, DIMENSION(NSAM,NROW)      :: XIM
        REAL, DIMENSION(LCIRC)          :: CIRC
        INTEGER, DIMENSION(3,NRING)     :: NUMR
        REAL,DIMENSION(NRING)           :: WR

        CHARACTER(LEN=1)                :: MODE
        DOUBLE PRECISION                :: PI,DFI

C       DEFAULT RETURN FLAG
        IRTFLG = 1

C       CALCULATE DIMENSIONS FOR NORMASS
        NSB = -NSAM/2
        NSE = -NSB-1+MOD(NSAM,2)
        NRB = -NROW/2
        NRE = -NRB-1+MOD(NROW,2)

C       NORMALIZE UNDER THE MASK,  TRIED DOING THIS ON THE
C       POLAR RINGS BUT IT GIVES DIFFERENT ANSWERS. al
        CALL NORMASS(XIM,NSB,NSE,NRB,NRE,NUMR,NUMR(1,NRING))

        MAXRIN = NUMR(3,NRING)
        NS2    = NSAM / 2 + 1
        NR2    = NROW / 2 + 1
        FNR2   = NR2
        FNS2   = NS2
        PI     = 2 * DATAN(1.0D0)

C       CONVERT WINDOW FROM IMAGE INTO POLAR COORDINATES
        
        IF (MODE .EQ. 'F')  THEN
           LTF = 4

           DO I=1,NRING

C             RADIUS OF THE RING
              INR             = NUMR(1,I)
              YQ              = INR
              LT              = NUMR(3,I) / LTF
              LT2             = LT  + LT
              LT3             = LT2 + LT
              DFI             = PI / LT
              KCIRC           = NUMR(2,I)

              CIRC(KCIRC)     = XIM(NS2,     NR2+INR)
              CIRC(LT+KCIRC)  = XIM(NS2+INR, NR2)
              CIRC(LT2+KCIRC) = XIM(NS2,     NR2-INR)
              CIRC(LT3+KCIRC) = XIM(NS2-INR, NR2)

              DO J=1,LT - 1
                 FI           = DFI     * J
                 X            = SIN(FI) * YQ
                 Y            = COS(FI) * YQ
                 JT           = J + KCIRC

                 CIRC(JT)     = QUADRI(FNS2+X, FNR2+Y, NSAM,NROW,XIM)
                 CIRC(JT+LT)  = QUADRI(FNS2+Y, FNR2-X, NSAM,NROW,XIM)
                 CIRC(JT+LT2) = QUADRI(FNS2-X, FNR2-Y, NSAM,NROW,XIM)
                 CIRC(JT+LT3) = QUADRI(FNS2-Y, FNR2+X, NSAM,NROW,XIM)
              ENDDO
           ENDDO

        ELSEIF (MODE .EQ. 'H')  THEN
           LTF = 2
           DO I=1,NRING

C             RADIUS OF THE RING
              INR            = NUMR(1,I)
              YQ             = INR
              LT             = NUMR(3,I) / LTF
              DFI            = PI / LT
              KCIRC          = NUMR(2,I)

              CIRC(KCIRC)    = XIM(NS2,     NR2+INR)
              CIRC(LT+KCIRC) = XIM(NS2+INR, NR2)
 
              DO J=1,LT - 1
                 FI          = DFI * J
                 X           = SIN(FI) * YQ
                 Y           = COS(FI) * YQ
                 JT          = J + KCIRC

                 CIRC(JT)    = QUADRI(FNS2+X, FNR2+Y, NSAM,NROW,XIM)
                 CIRC(JT+LT) = QUADRI(FNS2+Y, FNR2-X, NSAM,NROW,XIM)
            ENDDO
           ENDDO
        ENDIF

        CALL FRNGS(CIRC,LCIRC,NUMR,NRING)

C       WEIGHT CIRC  USING WR
        IF (WR(1) .GT. 0.0) THEN
           CALL APPLYWS(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
        ENDIF

        IRTFLG = 0
        END
@


1.30
log
@INULL > 0 ,    removed filling ref. reings with threads etc msgs
@
text
@d395 1
a395 1
                 CALL ERRT(101,'FFTW_PLANS LIMITED TO 2...',NPLANS)
@


1.29
log
@typo
@
text
@d123 1
a123 1
        ELSEIF (MYPID .LE. 0) THEN 
d142 1
a142 2
           IF (MYPID .LE. 0) 
     &        WRITE(NOUT,*) ' Created incore reference rings'
d241 2
a242 2
        IF (MYPID .LE. 0)  WRITE(NOUT,'(A,i5)') 
     &               '  Filling reference rings with threads:',NUMTH
@


1.28
log
@cosmetic and note on unused code
@
text
@a185 3


ZZ
@


1.27
log
@ APRINGS_SATU added
@
text
@d184 1
d186 3
d245 2
a246 2
        IF (MYPID .LE. 0) 
     &     WRITE(NOUT,*) ' Filling reference rings with threads:',NUMTH
@


1.26
log
@opt
@
text
@d13 1
d61 1
a61 1
cpgi$g opt=O3
d533 89
@


1.25
log
@normasc added use_omp parameter
@
text
@d60 1
@


1.24
log
@WEIGHT PAR. FOR _FILL_NEW
@
text
@d307 1
a307 1
	SUBROUTINE APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, XIM, OMP_FRNG,
d317 1
a317 1
        LOGICAL, INTENT(IN)      :: OMP_FRNG
d338 1
a338 1
     &               AVT,VRINV)
d345 1
a345 1
     &               NUMR,CIRC,LCIRC, NRING,MODE, NEWFFTW,OMP_FRNG, 
d350 1
a350 1
     &                  FFTW_PLANS, OMP_FRNG)
@


1.23
log
@GPL_2010
@
text
@a13 1
C=*                                                                    *
d41 1
a41 1
C              NSAM,NROW   IMAGE DIMENSIONS                   (INPUT)
d80 1
a80 1
        LOGICAL                           :: WINDOW
d126 3
d138 1
a138 1
     &                      CIRCREF,NUMREF,0,IRTFLG)
d197 1
a197 1
     &                  CIRCREF,NUMTH,LUNRING,IRTFLG)
d213 1
a213 1
     &                        CIRCREF,ICORE,LUNRING,IRTFLG)
d218 3
a220 3
        CHARACTER(LEN=1)                    :: MODE
        CHARACTER (LEN=*)                   :: REFPAT 
        LOGICAL                             :: WINDOW
d223 3
a225 3
        INTEGER,DIMENSION(NUMREF)           :: ILIST 
        INTEGER,DIMENSION(3,NRING)          :: NUMR
        REAL,DIMENSION(LCIRC,ICORE)         :: CIRCREF
d228 1
a228 1
        INTEGER*8                           :: FFTW_PLANS(*)
d231 1
a231 1
        REAL,DIMENSION(NRING)               :: WR
d234 1
a234 1
	REAL, ALLOCATABLE, DIMENSION(:,:,:) :: XIM
d242 2
a243 1
        MAXRIN = NUMR(3,NRING)
d245 1
a245 1
        MAXRIN = NUMR(3,NRING) - 2
d248 6
a253 3
C       RINGWE RETURNS WR WEIGHTS
	CALL RINGWE_NEW(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H') WR = WR * 0.5
d340 2
a389 1
              !write(6,*) 'plans; i,len,indx: ',i,len,indx
d398 1
d400 1
d419 1
a536 66
#ifdef DEBUGNEVER        
           write(6,*) ' circ(1..50) ------ '
           write(6,901)  (circ(ii),ii=1,50)
 901       format(5f11.2)
           write(6,*) ' circ(1000..1050) ------ '
           write(6,901)  (circ(ii),ii=1000,1050)
#endif

#ifdef NEVER
C       FOURIER OF CIRC 
        DO I=1,NRING
            L = LOG2(NUMR(3,I))
            CALL FFTR_Q(CIRC(NUMR(2,I)),L)
        ENDDO
C       WEIGHT CIRC  USING WR
        IF (WR(1) .GT. 0.0) THEN
           CALL APPLYWS(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
        ENDIF

        IF (WR(1) .GT. 0.0) THEN
C          WEIGHT CIRC  USING WR
	   DO I=1,NRING
	      NUMR3I       = NUMR(3,I)
	      NUMR2I       = NUMR(2,I)
	      W            = WR(I)
	      CIRC(NUMR2I) = CIRC(NUMR2I)*W
	      IF (NUMR3I .EQ. MAXRIN)  THEN
	         CIRC(NUMR2I+1) = CIRC(NUMR2I+1) * 0.5*W
	      ELSE
	         CIRC(NUMR2I+1) = CIRC(NUMR2I+1) * W
	      ENDIF

	      DO J=3,NUMR3I
	         JC = J + NUMR2I-1
	         CIRC(JC) = CIRC(JC)*W
	      ENDDO 
	   ENDDO
	ENDIF


c        write(6,*) ' unweighted (1-100):',circ(1),circ(100)
c        avtt = 0
c        vrtt = 0
c        do i =1,lcirc
c           avtt = avtt + circ(i)
c           vrtt = vrtt + circ(i) * circ(i)
c        enddo
c        write(6,*) 'n,avtt,vrtt:',n,avtt,vrtt
c        write(6,*) 'n,sumavt,sumvr:',n,avt,vr
c        avtn = avt / n
c        vrn  = dsqrt((vr - n * avtn * avtn) / (n-1))
c        tt   = vr - n * avt * avt 
c        write(6,*) 'n,avtn,vrn:',n,avtn,vrn,tt
cc        AVT = AVT / N
C       MULTIPLICATION IS FASTER
cc        VRINV = 1.0 / (DSQRT((VR - N * AVT * AVT) / (N-1)))

C       NORMALIZE CIRC 
cc  CIRC = (CIRC - AVT) * VRINV




C      unused development idea

C       --------------------- APRINGS_TWO --------------------------
a537 3
	SUBROUTINE APRINGS_TWO(NSAM,NROW,WR,
     &                         XIM,CIRC,MODE,NUMR,NRING,LCIRC,
     &                         IRTFLG)
a538 5
C       EXTERNAL ARRAYS
	REAL, DIMENSION(NSAM,NROW)      :: XIM
        REAL, DIMENSION(LCIRC)          :: CIRC
        INTEGER, DIMENSION(3,NRING)     :: NUMR
        REAL,DIMENSION(NRING)           :: WR
a539 95
        CHARACTER(LEN=1)                :: MODE
        DOUBLE PRECISION                :: PI,DFI

C       DEFAULT RETURN FLAG
        IRTFLG = 1

C       CALCULATE DIMENSIONS FOR NORMASS
        NSB = -NSAM/2
        NSE = -NSB-1+MOD(NSAM,2)
        NRB = -NROW/2
        NRE = -NRB-1+MOD(NROW,2)

C       NORMALIZE UNDER THE MASK,  TRIED DOING THIS ON THE
C       POLAR RINGS BUT IT GIVES DIFFERENT ANSWERS. al
        CALL NORMASS(XIM,NSB,NSE,NRB,NRE,NUMR,NUMR(1,NRING))

        MAXRIN = NUMR(3,NRING)
        NS2    = NSAM / 2 + 1
        NR2    = NROW / 2 + 1
        FNR2   = NR2
        FNS2   = NS2
        PI     = 2 * DATAN(1.0D0)

C       CONVERT WINDOW FROM IMAGE INTO POLAR COORDINATES
        
        IF (MODE .EQ. 'F')  THEN
           LTF = 4

           DO I=1,NRING

C             RADIUS OF THE RING
              INR             = NUMR(1,I)
              YQ              = INR
              LT              = NUMR(3,I) / LTF
              LT2             = LT  + LT
              LT3             = LT2 + LT
              DFI             = PI / LT
              KCIRC           = NUMR(2,I)

              CIRC(KCIRC)     = XIM(NS2,     NR2+INR)
              CIRC(LT+KCIRC)  = XIM(NS2+INR, NR2)
              CIRC(LT2+KCIRC) = XIM(NS2,     NR2-INR)
              CIRC(LT3+KCIRC) = XIM(NS2-INR, NR2)

              DO J=1,LT - 1
                 FI           = DFI     * J
                 X            = SIN(FI) * YQ
                 Y            = COS(FI) * YQ
                 JT           = J + KCIRC

                 CIRC(JT)     = QUADRI(FNS2+X, FNR2+Y, NSAM,NROW,XIM)
                 CIRC(JT+LT)  = QUADRI(FNS2+Y, FNR2-X, NSAM,NROW,XIM)
                 CIRC(JT+LT2) = QUADRI(FNS2-X, FNR2-Y, NSAM,NROW,XIM)
                 CIRC(JT+LT3) = QUADRI(FNS2-Y, FNR2+X, NSAM,NROW,XIM)
              ENDDO
           ENDDO

        ELSEIF (MODE .EQ. 'H')  THEN
           LTF = 2
           DO I=1,NRING

C             RADIUS OF THE RING
              INR            = NUMR(1,I)
              YQ             = INR
              LT             = NUMR(3,I) / LTF
              DFI            = PI / LT
              KCIRC          = NUMR(2,I)

              CIRC(KCIRC)    = XIM(NS2,     NR2+INR)
              CIRC(LT+KCIRC) = XIM(NS2+INR, NR2)
 
              DO J=1,LT - 1
                 FI          = DFI * J
                 X           = SIN(FI) * YQ
                 Y           = COS(FI) * YQ
                 JT          = J + KCIRC

                 CIRC(JT)    = QUADRI(FNS2+X, FNR2+Y, NSAM,NROW,XIM)
                 CIRC(JT+LT) = QUADRI(FNS2+Y, FNR2-X, NSAM,NROW,XIM)
            ENDDO
           ENDDO
        ENDIF

C       FOURIER OF CIRC 
        CALL FRNGS_NEW(CIRC,LCIRC,NUMR,NRING,MAXRIN)
 
C       WEIGHT CIRC  USING WR
        IF (WR(1) .GT. 0.0) THEN
           CALL APPLYWS(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
        ENDIF

        IRTFLG = 0
        END

#endif
@


1.22
log
@outputs to nout, not 6 now
@
text
@d14 4
a17 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.                          *
d28 1
a28 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a29 1
C=*                                                                    *
@


1.21
log
@ bcast,mpi
@
text
@d12 1
a12 1
C
d14 5
a18 7
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
d20 1
a20 1
C=* This program is free software; you can redistribute it and/or      *
d25 1
a25 1
C=* This program is distributed in the hope that it will be useful,    *
d31 1
a31 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d89 1
a89 8
#ifdef USE_MPI
        include 'mpif.h' 
        ICOMM  = MPI_COMM_WORLD 
        MPIERR = 0  
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else 
        MYPID = -1    
#endif    
d187 1
a187 1
           IF (MYPID .LE. 0) WRITE (6,90) SCRFILE
d197 1
a197 1
           IF (MYPID .LE. 0) WRITE (6,92) SCRFILE
d234 1
a234 7
#ifdef USE_MPI
        include 'mpif.h' 
        ICOMM  = MPI_COMM_WORLD 
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else 
        MYPID = -1    
#endif    
d385 1
a385 1
                 WRITE(6,*) ' CREATING FFTW_PLANS(',INDX,')'
@


1.20
log
@FFTW3 plan changes, FFTW aprings
@
text
@d11 1
a102 11
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
           INQUIRE(FILE=SCRFILE,EXIST=USEREFFILE,OPENED=ISOPEN,
     &             NUMBER=LUNOP,IOSTAT=IRTFLG)
        ENDIF

        CALL MPI_BCAST(USEREFFILE,1,MPI_LOGICAL,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) ' APRINGS: FAILED TO BCAST USEREFFILE'
           STOP
        ENDIF
a103 12
        CALL MPI_BCAST(ISOPEN,1,MPI_LOGICAL,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) ' APRINGS: FAILED TO BCAST ISOPEN'
           STOP
        ENDIF
        CALL MPI_BCAST(IRTFLG,1,MPI_INTEGER,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) ' APRINGS: FAILED TO BCAST IRTFLG'
           STOP
        ENDIF

#else
d116 7
a122 1

d128 1
d130 1
a130 1
        IF (USEREFFILE) THEN 
d133 1
a133 1
        ELSE
a136 1
#endif
d172 3
a174 1
           WRITE(NOUT,*) ' Loaded reference rings file incore'
d247 2
a248 3
        icomm  = mpi_comm_world 
        mpierr = 0  
        call mpi_comm_rank(icomm, mypid, mpierr)
@


1.19
log
@sync write to stdout for MPI
@
text
@d10 1
d14 1
a14 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d64 6
a69 3
        SUBROUTINE APRINGS(ILIST,NUMREF, 
     &                     NSAM,NROW,NDUM1,NDUM2,
     &                     NRING,LCIRC,NUMR,MODE, 
d86 3
a154 2
        NUMTH = 1
#ifdef SP_MP
a155 1
#endif
d160 2
a161 3
           CALL APRINGS_FILL(ILIST,NUMREF,
     &                      NSAM,NROW,NUMTH,
     &                      NRING,LCIRC,NUMR,MODE, 
d174 1
a174 1
     &                 LCIRCT,NUMREFT,NSLICE,MAXIM,' ', .FALSE.,IRTFLG)
d208 1
a208 1
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'U',IFORM,
d217 2
a218 3
           CALL APRINGS_FILL(ILIST,NUMREF,
     &                  NSAM,NROW,NUMTH,
     &                  NRING,LCIRC,NUMR,MODE, 
d230 1
a230 1
C       --------------------- APRINGS_FILL --------------------------
d232 1
a232 1
        SUBROUTINE APRINGS_FILL(ILIST,NUMREF,
d234 1
a234 1
     &                        NRING,LCIRC,NUMR,MODE, 
d250 3
d261 3
a263 3
        ICOMM  = MPI_COMM_WORLD 
        MPIERR = 0  
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
a268 1
#ifdef USE_MPI
a270 1
#endif
d273 3
d278 1
a278 1
	CALL RINGWE(WR,NUMR,NRING,MAXRIN)
d287 4
d309 3
a311 3
	      CALL APRINGS_ONE(NSAM,NROW,WR,
     &                XIM(1,1,IT),CIRCREF(1,IPT),MODE,NUMR,NRING,LCIRC,
     &               IRTFLG)
d330 112
d444 4
a543 1
C       FOURIER OF CIRC 
d559 8
d597 1
a597 1
#endif
d622 1
d624 1
d626 9
d636 2
d639 2
d642 5
d648 3
d652 79
@


1.18
log
@GPL License fixed
@
text
@d162 2
a163 1
           WRITE(NOUT,*) ' Created incore reference rings'
d254 8
d264 4
a267 1
        WRITE(NOUT,*) ' Filling reference rings with threads:',NUMTH
@


1.17
log
@HRI GPL License used
@
text
@a11 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d15 1
a15 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a34 6

C * COPYRIGHT (C)1985, 2005. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
a61 1
C--************************************************************************
@


1.16
log
@scrfile null gave bug
@
text
@d13 24
d68 1
@


1.15
log
@APRINGS_ONE
@
text
@d9 1
d104 5
a108 2
        IF (FILNAM(1:1) .NE. '_' .AND. ILOCAT .EQ. 0) THEN
           CALL FILNAMANDEXT(SCRFILE,DATEXC,FILNAM,NLET,.FALSE.,IRTFLG)
d115 6
a120 2
        CALL INQUIREIF1(LUNRING,FILNAM,DUM,NDUM,USEREFFILE,ISOPEN,
     &                  LUNOP,INLNED,IMGNUM,IRTFLG)
@


1.14
log
@no irtflg test after inquireif
@
text
@d19 1
a19 1
C  APRINGS(ILIST,NUMREF, LSAM,LROW,NSAM,NROW,
d23 1
a23 1
  
d26 1
a26 2
C              LSAM,LROW   IMAGE DIMENSIONS                    (INPUT)
C              NSAM,NROW   OUTPUT IMAGE DIMENSIONS             (INPUT)
d46 1
a46 1
     &                     LSAM,LROW,NSAM,NROW,
d57 2
a58 1
        REAL,    DIMENSION(LCIRC,NUMREF)  :: CIRCREF 
d64 3
d102 10
a111 1
        CALL INQUIREIF1(LUNRING,SCRFILE,DUM,NDUM,USEREFFILE,ISOPEN,
d113 7
a119 2
c       IF (IRTFLG .NE. 0) RETURN
        
d131 7
a137 5
           CALL INITAP_NEW(ILIST,NUMREF,
     &                     LSAM,LROW,NSAM,NROW,
     &                     NRING,LCIRC,NUMR,MODE, 
     &                     REFPAT,LUNREF,NUMTH,
     &                     CIRCREF,NUMREF,0,IRTFLG)
d159 2
d177 5
a181 6
           WINDOW = (LSAM .NE. NSAM .OR. LROW .NE. NROW) 
           CALL APRINGS_WRITE(ILIST,NUMREF, 
     &                       LSAM,LROW,NUMTH,
     &                       NRING,LCIRC,NUMR,MODE, 
     &                       REFPAT,LUNREF,CIRCREF,NUMTH,
     &                       LUNRING,SCRFILE,WINDOW,IRTFLG)
d183 2
a184 3
        ENDIF

        END
d186 1
d188 5
d194 2
a195 10
C       --------------------- APRINGS_WRITE --------------------------

        SUBROUTINE APRINGS_WRITE(ILIST,NUMREF, 
     &                     LSAM,LROW,NUMTH,
     &                     NRING,LCIRC,NUMR,MODE, 
     &                     REFPAT,LUNREF,CIRCREF,ICORE,
     &                     LUNRING,SCRFILE,WINDOW,IRTFLG)

	INCLUDE 'CMBLOCK.INC' 
	INCLUDE 'CMLIMIT.INC' 
a196 35
        INTEGER, DIMENSION(NUMREF)        :: ILIST
        INTEGER, DIMENSION(3,NRING)       :: NUMR
	CHARACTER(LEN=1)                  :: MODE
        REAL,    DIMENSION(LCIRC,ICORE)   :: CIRCREF 
        CHARACTER (LEN=*)                 :: SCRFILE,REFPAT
        LOGICAL                           :: WINDOW

#ifdef USE_MPI
        include 'mpif.h' 
        ICOMM   = MPI_COMM_WORLD 
        MPIERR  = 0  
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else 
        MYPID = -1    
#endif    

C       FIND CIRCULAR REDUCED NSAM, NROW
C       CALCULATION OF ACTUAL DIMENSION OF AN IMAGE TO BE INTERPOLATED
C       2*(NO.OF RINGS)+(0'TH ELEMENT)+2*(MARGIN OF 1)
        NR    = NUMR(1,NRING) 
        NSAM  = MIN0(((LSAM-1)/2)*2+1, ((LROW-1)/2)*2+1, 2*NR+3)
        NROW  = NSAM

C       CREATE REFERENCE RINGS FILE FOR OUTPUT
        NSL = 1
        CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'U',IFORM,
     &               LCIRC,NUMREF,NSL,MAXIM,' ', .FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        IF (MYPID .LE. 0) WRITE (NOUT,90) SCRFILE
90      FORMAT ('  Creating reference rings file: ',A )

        IF (.NOT. WINDOW) THEN
           NSAM = LSAM
           NROW = LROW
a198 8
C       FILL REF_CIRC FILE WITH RINGS DATA
        CALL INITAP_NEW(ILIST,NUMREF,
     &                  LSAM,LROW,NSAM,NROW,
     &                  NRING,LCIRC,NUMR,MODE, 
     &                  REFPAT,LUNREF,NUMTH,
     &                  CIRCREF,ICORE,LUNRING,IRTFLG)

9999    RETURN
d202 1
a202 24
C++************************************************************************
C
C    INITAP_NEW.F   SPLIT FROM MRQLI.F            APR 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************

C  INITAP
C  
C  PURPOSE:  PREPARE CIRCULAR RINGS DATA FOR REFERENCE IMAGES
C
C  PARAMETERS: 
C
C IMAGE_PROCESSING_ROUTINE
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
d204 2
a205 2
        SUBROUTINE INITAP_NEW(ILIST,NUMREF,
     &                        LSAM,LROW,NSAM,NROW,
d207 1
a207 1
     &                        REFPAT,LUNREF,NUMTH,
d218 2
a219 2
        INTEGER,DIMENSION(NUMREF)           :: ILIST(NUMREF) 
        INTEGER,DIMENSION(3,NRING)          :: NUMR(3,NRING)
d226 1
a226 1
	REAL, ALLOCATABLE, DIMENSION(:,:,:) :: A
d230 2
a231 1
C       CALCULATE WR WEIGHTS
d234 1
a234 1
C       RINGWE RETURNS WR
d238 1
a238 3
        WINDOW = (LSAM .NE. NSAM .OR. LROW .NE. NROW)

        ALLOCATE(A(NSAM,NROW,NUMTH), STAT=IRTFLG)
d240 1
a240 1
            CALL ERRT(46,'A...',NSAM*NROW*NUMTH)
a243 34
C       CALCULATE LOAD DIMENSIONS FOR A
        IF (WINDOW) THEN
C          REDUCE LOAD DIMENSIONS FOR A
           LQ   = LROW/2+1
           LR1  = (NROW-1)/2
           LR2  = LQ+LR1
           LR1  = LQ-LR1
           LQ   = LSAM/2+1
           LS1  = (NSAM-1)/2
           LS2  = LQ+LS1
           LS1  = LQ-LS1

C          I THINK THIS IS WRONG FOR EVEN SIZED WINDOW BUT IT SHOULD
C          NEVER GET EVEN SIZED WINDOW (al)
           ITT = MOD(NSAM,2)
           IF (ITT .EQ. 0) THEN
                CALL ERRT(102,
     &            'PGM. ERROR.  WINDOW SIZE SHOULD NEVER BE EVEN',NSAM)
            RETURN
           ENDIF
        ELSE
C          FULL LOAD DIMENSIONS FOR A
           LR1  = 1
           LR2  = NROW
           LS1  = 1
           LS2  = NSAM
        ENDIF

C       CALCULATE DIMENSIONS FOR NORMAS
	NSB  = -NSAM/2
	NSE  = -NSB-1+MOD(NSAM,2)
	NRB  = -NROW/2
	NRE  = -NRB-1+MOD(NROW,2)

d245 3
a247 4
        DO IGO=1,NUMREF,NUMTH

C          LOAD SET OF REFERENCE IMAGES
           IEND = MIN(NUMREF,IGO+NUMTH-1)
d249 2
a250 1
	   CALL AP_GETDAT(ILIST,NUMREF,LSAM,LROW,NSAM,NROW,
d252 1
a252 1
     &                    LR1,LR2,LS1,LS2, A, IRTFLG)
d256 11
a266 19
	   DO IMI=IGO,IEND
              IT  = IMI - IGO + 1
              IPT = IMI 
              IF (LUNRING .GT. 0) IPT = IT

C             NORMALIZE UNDER THE MASK
	      CALL NORMASS(A(1,1,IT),NSB,NSE,NRB,NRE,
     &                    NUMR,NUMR(1,NRING))

C             INTERPOLATE RECTANGULAR COORDINATES INTO POLAR COORDINATES 
	      CALL ALRQS(A(1,1,IT),  NSAM,NROW,NUMR,
     &                   CIRCREF(1,IPT), LCIRC,NRING,MODE)

C             FOURIER OF CIRCREF
	      CALL FRNGS(CIRCREF(1,IPT),LCIRC,NUMR,NRING)

C             WEIGHT CIRCREF USING WR
  	      CALL APPLYWS(CIRCREF(1,IPT),LCIRC,NUMR,WR,
     &                    NRING,MAXRIN)
a267 2
c$omp      end parallel do 

d271 3
a273 2
	      DO IV=1,NUMTH
                 CALL WRTLIN(LUNRING,CIRCREF(1,IV),LCIRC,IGO+IV-1) 
d279 1
a279 1
9999    IF (ALLOCATED(A)) DEALLOCATE(A)
d283 183
@


1.13
log
@SPIDER REF RINGS FILE used now
@
text
@d21 1
a21 1
C          REFPAT,LUNREF,BFC,BFC_IN_CORE,
d30 1
a30 1
C              BFC          OUTPUT ARRAY                       (OUTPUT)
d32 1
a32 1
C              BFC_INCORE   NO OUTPUT ARRAY FLAG               (OUTPUT)
d40 1
a40 1
C       IS: BFC(LCIRC,NUMREF) ANOTHER SMALL ALLOCATED ARRAY IS: 
d49 1
a49 1
     &                     REFPAT,LUNREF,BFC,BFC_IN_CORE,
d55 1
a55 1
	CHARACTER(LEN=1)                  :: MODE,NULL
d57 2
a58 2
        INTEGER, DIMENSION(3,NRING)       :: NUMR(3,NRING)
        REAL,    DIMENSION(LCIRC,NUMREF)  :: BFC 
d60 1
a60 1
        LOGICAL                           :: USEREFFILE,BFC_IN_CORE
a72 2
        NULL = CHAR(0)

d101 1
a101 1
        IF (IRTFLG .NE. 0) RETURN
d111 2
a112 2
        IF (BFC_IN_CORE  .AND. .NOT. USEREFFILE) THEN
C          CALCULATE REF. RINGS DATA AND FILL BFC ARRAY WITH IT
d118 1
a118 1
     &                     BFC,NUMREF,0,IRTFLG)
d120 2
a121 2
        ELSEIF (BFC_IN_CORE .AND. USEREFFILE) THEN
C          READ EXISTING REF RINGS FILE AND FILL BFC ARRAY WITH ITS DATA
d135 1
a135 1
C          FILL BFC WITH EXISTING RINGS DATA FROM FILE AND RETURN.
d137 1
a137 2
              CALL REDLIN(LUNRING,BFC(1,IREF),LCIRC,IREF) 
C             READ(LUNRING,IOSTAT=IRTFLG)(BFC(IRING,IREF),IRING=1,LCIRC)
d140 1
a140 1
        ELSEIF (.NOT. BFC_IN_CORE .AND. USEREFFILE) THEN
d153 1
a153 1
        ELSEIF (.NOT. BFC_IN_CORE .AND. .NOT. USEREFFILE) THEN
a156 1
           NR     =  NUMR(1,NRING) 
d158 1
a158 1
     &                       LSAM,LROW,NR,
d160 1
a160 1
     &                       REFPAT,LUNREF,BFC,NUMTH,
d172 1
a172 1
     &                     LSAM,LROW,NR,
d174 1
a174 1
     &                     REFPAT,LUNREF,BFC,ICORE,
d181 1
a181 1
        INTEGER, DIMENSION(3,NRING)       :: NUMR(3,NRING)
d183 1
a183 1
        REAL,    DIMENSION(LCIRC,ICORE)   :: BFC 
a186 3
	DOUBLE PRECISION, DIMENSION(1)    :: TTDUM
	CHARACTER(LEN=1)                  :: NULL

d196 6
a201 5
        NULL = CHAR(0)

C       FIND NSAM & NROW
	CALL APMASTER_1(MODE,DUM,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                  TTDUM,0)
d222 1
a222 1
     &                  BFC,ICORE,LUNRING,IRTFLG)
d257 1
a257 1
     &                        BFC,ICORE,LUNRING,IRTFLG)
d269 1
a269 1
        REAL,DIMENSION(LCIRC,ICORE)         :: BFC
d329 1
a329 1
        DO IMIT=1,NUMREF,NUMTH
d332 1
a332 1
           IEND = MIN(NUMREF,IMIT+NUMTH-1)
d335 1
a335 1
     &                    NUMTH,REFPAT,LUNREF, IMIT,IEND,
d339 3
a341 3
cddd      parallel do private(IMI,IPT,IT)
	   DO IMI=IMIT,MIN(NUMREF,IMIT+NUMTH-1)
              IT  = IMI - IMIT + 1
d343 1
a343 1
              IF (LUNRING .GT. 0) IPT = IMI - IMIT + 1
d351 1
a351 1
     &                   BFC(1,IPT), LCIRC,NRING,MODE)
d353 2
a354 2
C             FOURIER OF BFC
	      CALL FRNGS(BFC(1,IPT),LCIRC,NUMR,NRING)
d356 2
a357 2
C             WEIGHT BFC USING WR
  	      CALL APPLYWS(BFC(1,IPT),LCIRC,NUMR,WR,
d360 1
d364 1
a364 1
C             SAVE BFC IN FILE OPENED ON LUNRING
d366 1
a366 1
                 CALL WRTLIN(LUNRING,BFC(1,IV),LCIRC,IMIT+IV-1) 
@


1.12
log
@unchanged
@
text
@d1 1
a1 1
C++************************************************************************
a6 1
C                   OPFILEC                       FEB 03 ARDEAN LEITH
d8 1
d12 1
a12 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d30 6
a35 1
C              BFC          OUTPUT ARRAY                      (OUTPUT)
d37 5
a41 12
C              BFC_INCORE   NO OUTPUT ARRAY FLAG              (OUTPUT)
C              LUNRING      REF-RINGS FILE IO UNIT            (INPUT)
C              SCRFILE      REF-RINGS FILE                    (INPUT)
C              IRTFLG       ERROR FLAG                        (OUTPUT)
C
C NOTE:  MOST MEMORY DEMAND DEPENDENT 
C        ON LCIRC & NUMREF.  LCIRC IS THE TOTAL LENGTH OF THE ARRAY
C        THAT HOLDS THE CIRCULAR RINGS, SO IT IS DEPENDENT ON
C        NUMBER OF RINGS AND THEIR RADIUS. ARRAY ALLOCATED IS: BFC(LCIRC,NUMREF)
C        ANOTHER SMALL ALLOCATED ARRAY IS: A(NSAM,NROW,NUMTH)
C        FOR 83 IMAGES of 125x125 WITH RINGS AT 5...47 SIZE=45MB
C        ARRAYS ONLY APPEAR TO TAKE: 3.6MB?
d81 1
d87 1
d100 5
a104 2
        INQUIRE(FILE=SCRFILE,EXIST=USEREFFILE,OPENED=ISOPEN,
     &          NUMBER=LUNOP,IOSTAT=IRTFLG)
d125 11
a135 4
C          OPEN REFERENCE RINGS FILE
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-LUNRING,0,
     &                    'O',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d137 1
a137 1
C          FILL BFC WITH RINGS DATA AND RETURN.
d139 2
a140 5
              READ(LUNRING,IOSTAT=IRTFLG)(BFC(IRING,IREF),IRING=1,LCIRC)
              IF (IRTFLG .NE. 0) THEN
                 CALL ERRT(102,'READING REFERENCE RINGS FILE',IRTFLG)
                 RETURN
              ENDIF
d145 10
a154 2
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-LUNRING,0,
     &                 'O',' ',.TRUE.,IRTFLG)
d210 4
a213 3
        CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-LUNRING,0,
     &                 'U',' ',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999
d215 2
a216 2
        IF (MYPID .LE. 0) WRITE (NOUT,90)
90      FORMAT (/,' ',15 ('-'),' Create Reference rings file. ',28('-'))
a237 1
C                   OPFILEC                       FEB 03 ARDEAN LEITH
d250 2
a275 1
        REAL,DIMENSION(3,NUMREF)            :: SA 
d290 1
a290 1
        IF (MODE .EQ. 'H')   WR = WR * 0.5
d294 7
d302 1
a302 4
	   ALLOCATE(A(NSAM,NROW,NUMTH), STAT=IRTFLG)
           MWANT = LSAM + NSAM*NROW*NUMTH

C          CALCULATE LOAD DIMENSIONS FOR A
d317 1
a317 1
     &             'PGM. ERROR.  WINDOW SIZE SHOULD NVER BE EVEN',NSAM)
d321 1
a321 4
	   ALLOCATE(A(LSAM,LROW,NUMTH), STAT=IRTFLG)
           MWANT = LSAM*LROW*NUMTH

C          CALCULATE LOAD DIMENSIONS FOR A
a326 4
        IF (IRTFLG.NE.0) THEN
            CALL ERRT(46,'A...',MWANT)
            RETURN
        ENDIF 
d345 1
a345 2
C          NORMALIZE UNDER THE MASK
c$omp      parallel do private(IMI,IPT,IT)
d355 3
a357 2
	      CALL ALRQS(A(1,1,IT),NSAM,NROW,NUMR,
     &                    BFC(1,IPT), LCIRC,NRING,MODE)
d359 1
d362 3
a364 2
	      CALL APPLYWS(BFC(1,IPT),LCIRC,NUMR,WR,
     &                     NRING,MAXRIN)
d367 1
d371 1
a371 5
	         WRITE(LUNRING,IOSTAT=IRTFLG) (BFC(J,IV),J=1,LCIRC)
                 IF (IRTFLG .NE. 0) THEN
                   CALL ERRT(102,'WRITING REFERENCE RINGS FILE',IRTFLG)
                   RETURN
                 ENDIF
@


1.11
log
@can create ref rings file on fly now
@
text
@d68 1
a68 2
        INTEGER :: COMM
        COMM   = MPI_COMM_WORLD 
d70 1
a70 1
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d83 1
a83 1
        CALL MPI_BCAST(USEREFFILE,1,MPI_LOGICAL,0,COMM,MPIERR)
d88 1
a88 1
        CALL MPI_BCAST(ISOPEN,1,MPI_LOGICAL,0,COMM,MPIERR)
d93 1
a93 1
        CALL MPI_BCAST(IRTFLG,1,MPI_INTEGER,0,COMM,MPIERR)
d178 1
d181 3
a183 4
        INTEGER  COMM 
        COMM   = MPI_COMM_WORLD 
        MPIERR = 0  
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
@


1.10
log
@mpi
@
text
@d8 1
d64 2
d68 1
a68 1
        INTEGER MYPID, COMM, MPIERR
d105 17
a122 2
        IF (BFC_IN_CORE .AND. USEREFFILE) THEN
C          READ REF RINGS FILE INTO BFC
d137 2
a138 2
        ELSEIF (.NOT. BFC_IN_CORE) THEN
C          OPEN REFERENCE RINGS FILE FOR FUTURE READING
d142 2
a143 6
        ELSE
C          FILL BFC WITH CALCULATED RINGS DATA
           NUMTH = 1
#ifdef SP_MP
           CALL GETTHREADS(NUMTH)
#endif
d145 7
a151 5
           CALL INITAP_NEW(ILIST,NUMREF,
     &                     LSAM,LROW,NSAM,NROW,
     &                     NRING,LCIRC,NUMR,MODE, 
     &                     REFPAT,LUNREF,NUMTH,
     &                     BFC,NUMREF,0,IRTFLG)
d181 1
a181 1
        INTEGER MYPID, COMM, MPIERR
d201 1
a201 3
90      FORMAT (/,' ',72('-'),/,
     &            '  Create Reference rings file.',/,
     &            ' ',72('-'))
d208 1
a208 1
C       FILL REF_CIRC FILE WITH RINGS DATA AND QUIT.
d215 1
a215 2
9999    CLOSE(LUNRING)
        RETURN
d221 1
a221 1
C    INITAP.F       SPLIT FROM MRQLI.F            APR 01 ARDEAN LEITH
@


1.9
log
@undefined null
@
text
@d63 9
d76 22
d100 1
d163 9
d184 1
a184 1
        WRITE (NOUT,90)
@


1.8
log
@replaced normas with normass (for altix)
@
text
@d56 1
a56 1
	CHARACTER(LEN=1)                  :: MODE
d64 2
d69 1
@


1.7
log
@lR1 wrong (no effect)
@
text
@d284 1
a284 1
	      CALL NORMAS(A(1,1,IT),NSB,NSE,NRB,NRE,
@


1.6
log
@error trap
@
text
@d250 1
a250 1
           LR2  = NSAM
d252 1
a252 1
           LS2  = NROW
@


1.5
log
@comment
@
text
@d235 1
d238 6
@


1.4
log
@bad LS1 if not window
@
text
@d235 2
@


1.3
log
@'OR MQ' support
@
text
@d225 10
d238 6
a254 10

C       CALCULATE LOAD DIMENSIONS FOR A
        LQ   = LROW/2+1
        LR1  = (NROW-1)/2
        LR2  = LQ+LR1
        LR1  = LQ-LR1
        LQ   = LSAM/2+1
        LS1  = (NSAM-1)/2
        LS2  = LQ+LS1
        LS1  = LQ-LS1
@


1.2
log
@AP rewrite
@
text
@d18 4
a21 4
C       SUBROUTINE APRINGS(ILIST,NUMREF, LSAM,LROW,NSAM,NROW,
C                          NRING,LCIRC,NUMR,MODE, 
C                          REFPAT,LUNREF,BFC,BFC_IN_CORE,
C                          LUNRING,SCRFILE,IRTFLG)
d23 7
a29 1
C  PARAMETERS:  ILIST          REF. LIST                         (INPUT)
d31 5
d39 1
a39 2
C        NUMBER OF RINGS AND THEIR RADIUS.  NUMREF IS NUMBER OF REFERENCE
C        IMAGES.   ARRAY ALLOCATED IS: BFC(LCIRC,NUMREF)
@


1.1
log
@Initial revision
@
text
@d104 1
a104 1
     &                     LUNRING,SCRFILE,IRTFLG)
a108 1
	CHARACTER(LEN=1)                  :: MODE
d111 1
d114 2
d117 1
d119 2
d131 8
a138 3
90      FORMAT (/,' ',72('-'),//,
     &               '  Multi-reference alignment, Refer-circ.',//,
     &               ' ',72('-'),/)
@
