head	1.21;
access;
symbols
	healthdept_2018:1.21
	pre_getangas:1.20
	GPL2010:1.20
	pre_GPL2010:1.19
	pre_var_equation:1.19
	pre_fftwrings:1.19
	pre_opfiles:1.19
	src:1.19
	best-code:1.19
	x-named-regs:1.19
	x:1.19
	v13-00:1.19
	pre_GPL:1.17
	prec_CA:1.17
	noindx:1.15
	Bproc:1.12
	oct21:1.10
	last77:1.10;
locks; strict;
comment	@c @;


1.21
date	2018.10.03.14.51.09;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.24.13.27.17;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.17.19.59.19;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.17.17.55.25;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.10.17.20.43;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.19.15.56.14;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.20.16.36.09;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.19.15.50.59;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.11.14.07.45;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	99.12.07.16.35.49;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	99.11.10.23.11.25;	author yuchen;	state Exp;
branches;
next	1.10;

1.10
date	99.02.05.15.09.46;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	98.01.21.18.07.00;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	97.10.15.17.10.16;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	97.09.15.20.02.45;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	97.01.31.13.15.59;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	96.09.10.15.49.11;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	95.10.05.18.44.40;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	95.10.04.20.31.03;	author mladjadj;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.12.43;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.53.51;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.21
log
@email_health_dept
@
text
@
C ++********************************************************************
C
C  WINAVE2.F                            LONG FILE NAMES JAN 89 al
C              OPFILEC                  FEB  03 ARDEAN LEITH
C                                                                      *
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C                                                                      *
C  WINAVE2(LUN2,NDOC,LUN14)                                           *
C                                                                      *
C  PURPOSE:                                                            *
C                                                                      *
C  WINAVE2S_4.FOR  5/14/87 VERSION FOR I*4, ALBANY INPUT 10/30/87
C                     2/28/89 LONG FILE NAMES ADDED
C  WINAVE2(LUN2,NDOC,LUN4,LUN5,LUN14)
C	  LUN2		LOGICAL UNIT NUMBER OF SMALL FILE
C	  NDOC		LOGICAL UNIT NUMBER OF PEAK FILE
C         LUN14         LOCICAL UNIT NUMBER OF RAW INPUT FILE
C--*******************************************************************
C   INTERPOLATION FOR NONINTEGER AVERAGING INTRODUCED. 5/2/83 MR
C   THIS VERSION HAS BEEN RE-WRITTEN FOR THE MRC APPLICATIONS
C   J.F. -- WINAVE2 WITH PATCH AVERAGES AND RANK RANGE 5/14/87
C   J.F. -- WINAVE2S VERSION WITH SPIDER INPUT
C   J.F. -- CHANGED FOR USE WITH LONG FILE NAMES 2/28/89
C   A.L. -- ARRAYS PUT IN UNLABELED COMMON
C--*******************************************************************

	SUBROUTINE WINAVE2(LUN2,NDOC,LUN14)

	INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        CHARACTER(LEN=MAXNAM)     ::  FILNAM1, DOCNAM
        COMMON /COMMUN/ FILNAM1, DOCNAM

	PARAMETER (NPMAX=200)
C	MAX NUMBER OF INDEPENDENT PATCHES

	PARAMETER (NBUF=4000)
C	MAX NUMBER OF NON-ZERO PEAKS THAT CAN BE READ IN

	PARAMETER (MAXOUTY=240)
C       MAX DIMENSION OF SQUARE WINDOW

	INTEGER IBUF(1)
	EQUIVALENCE(BUF,IBUF)
	COMMON NCOUNT(MAXOUTY*NPMAX),NLIST(NBUF),FNC(NPMAX),
     &	       NPEAK(NBUF),XLIST(NBUF),YLIST(NBUF),CLIST(NBUF),BUF(1)

C	ONE PLUS THE MAXIMUM NUMBER OF REGISTERS PER KEY 
	PARAMETER (MAXREG=7)    
C	MAXIMUM NUMBER OF KEYS
	PARAMETER (MAXKEY=9999) 
        COMMON /DOC_BUF/ DBUF(MAXREG*MAXKEY*2)

	COMMON /AREA/ IXP

	REAL         RLIST(3)
	LOGICAL      LRANK
	INTEGER      XBIG,YBIG,IXWIN(2),IXPWIN(2),IXP(2,NPMAX),IX(2)
	INTEGER      NOFFP,NP,NTOTAL,NPEAK,NLIST,I,NPK,IPK,N
	INTEGER      IS4,NTOT4,J4,NOFF24,K4,KS4,NOFF34,LUN14,NOFF
	INTEGER      IPK1,IPK2,IPKR,IND,L,IPKMN,IPKMX

        CHARACTER    NULL

        NULL = CHAR(0)

        WRITE(NOUT,*) 'ALTERED JUNE 93 TO USE COMMON BUFFER, al'

C       OPEN INPUT FILE
        MAXIM = 0
        CALL OPFILEC(0,.TRUE.,FILNAM1,LUN14,'O',IFORM,
     &        NSAM1,NROW1,NSLICE,MAXIM,'SCANNED DATA',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

	IF (NSLICE .GT. 1) THEN
           CALL ERRT(101,'OPERATION DOES NOT WORK ON VOLUMES',NE)
           RETURN
	ENDIF

	CALL FILERD(FILNAM1,NLET1,NULL,'AVERAGE',IRTFLG)
	IF (IRTFLG .NE. 0) RETURN

	IFORM = 3
	CALL RDPRMI(NSAM2,NROW2,NOT_USED,'DIMENSIONS')
	IXWIN(1)=NSAM2
	IXWIN(2)=NROW2
	IF (NSAM2.EQ.0.OR.NROW2.EQ.0) RETURN

	CALL RDPRMI(IXPWIN(1),IXPWIN(2),NOT_USED,'PATCH DIMENSIONS')
	CALL RDPRMI(NP,NGEN,NOT_USED,
     &       'NUMBER OF PATCHES, GENERATE PATCHES?(0/1)')
	IF (NGEN.EQ.0) THEN
		CALL RDPRMI(IDUM1,IDUM2,NOT_USED,
     &            'INTEGER CORNER COOS OF PATCHES')
		DO  IP=1,NP
                   DO  I=1,2
                      IXP(I,IP)=IBUF(2*(IP-1)+I)
		   ENDDO
		ENDDO
	ELSE
		CALL RDPRMI(IXP(1,1),IXP(2,1),NOT_USED,
     &                     'STARTING COOS')
		CALL RDPRMI(INCREMX,INCREMY,NOT_USED,
     &                      'INCREMENTS X,Y')
		NHOR=(NSAM1-IXP(1,1)+1)/INCREMX
		DO  IP=1,NP
                  IYCOO=((IP-1)/NHOR)*INCREMY
                  IXCOO=(IP-((IP-1)/NHOR)*NHOR-1)*INCREMX
                  IXP(1,IP)=IXP(1,1)+IXCOO
                  IXP(2,IP)=IXP(2,1)+IYCOO
                  IF (IXP(2,IP) + INCREMY-1 .GT. NROW1) THEN
			NP=IP-1
			GOTO 65
                  ENDIF
		ENDDO
60		CONTINUE
65	CONTINUE
	WRITE(NOUT,62) NP
62	FORMAT(' ** NUMBER OF PATCHES USED ',I3)
	WRITE(NOUT,61)((IXP(K,I),K=1,2),I=1,NP)
61	FORMAT(10I6)
	ENDIF

C       OPEN VOLUME-FORMATTED FILE. EACH SLICE CORRESPONDS TO ONE
C       PATCH AVERAGE, IN THE ORDER PATCHES ARE SPECIFIED

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FILNAM1,LUN2,'U',IFORM,NSAM2,NROW2,NP,
     &             MAXIM,'XXXX',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9000

	NOFF1=NPMAX+NSAM1+1
	NTOT4=NSAM2*NROW2
	NOFFP=NTOT4+2*NSAM2
	NOFF=2*NTOT4+4*NSAM2
	NOF11=NOFF1+NSAM1
	NOFF24=NOFF1+2*NSAM1+NSAM2  
C       OFFSET ADDRESS FOR 1ST AVERAGE IMAGE
C NOTE THAT ONE RECORD BEFORE AND BEHIND EACH IMAGE IS RESERVED FOR OVERSPILL
	IB1=NOFF1	            
C       ALTERNATE INPUT BUFFER ADDRESS #1
	IB2=NOF11	            
C       ALTERNATE INPUT BUFFER ADDRESS #2

C       CLEAR OUTPUT BUFFERS

	NTOTAL=NP*NOFFP
	DO  IS4=1,NTOTAL
	  BUF(NOFF24+IS4-1)=0.
	ENDDO

C       NSAMC, NROWC ARE THE DIMENSIONS OF THE AREA USED IN THE
C       CORRELATION FUNCTION

	NSAMC=NSAM1-NSAM2
	NROWC=NROW1-NROW2

C       READ IN DOCUMENT FILE INTO LARGE BUFFER DBUF
	CALL FILERD(DOCNAM,NLETD,DATEXC,'DOCUMENT',IRTFLG)
	IF (IRTFLG .NE. 0) RETURN

	IKEY=1
C       IKEY IS ARBITRARY. WE ARE INTERESTED IN GETTING THE ENTIRE
C       REGISTER SET AT ONCE, SO WE WILL IGNORE THE CONTENTS OF RLIST
C       (WHICH FOR IKEY=1 RETURNS THE REGISTER UNDER THAT KEY)
	ISW=0
	CALL UNSDAL(DOCNAM,ISW,NDOC,IKEY,RLIST,3,DBUF,MAXKEY,
     &      MAXREG,NKEY,LERR)
	
	WRITE(NOUT,*) '** NUMBER OF PEAKS IN DOC FILE ',NKEY
C       NKEY= NUMBER OF KEYS FOUND IN DOCUMENT FILE
	CALL RDPRM2(THR1,THR2,NOT_USED,'PEAK VALUES (FROM,TO)')
	CALL RDPRM2(RANK1,RANK2,NOT_USED,
     &    'RANGE OF RANKS IN PERCENT (FROM,TO;100=BEST)')
	IF (RANK1.EQ.0.0.AND.RANK2.EQ.0.0) THEN
		LRANK=.FALSE.
		WRITE(NOUT,92)
	ELSE
		LRANK=.TRUE.
92		FORMAT(' *** NO RANK SORTING SPECIFIED ***')
	ENDIF

C       START READING, CHECK FOR PEAKS WITHIN SPECIFIED VALUE RANGE
	I=1 
	DO 905 II=1,NKEY
          J1=(II-1)*MAXREG+2
C         NOTE THAT THE FIRST ELEMENT CONTAINS THE KEY
          XLIST(I)=DBUF(J1)
          YLIST(I)=DBUF(J1+1)
          CLIST(I)=DBUF(J1+2)
          IF(CLIST(I).LT.THR1.OR.CLIST(I).GT.THR2) GOTO 905
          I=I+1
905	CONTINUE
	NPK=I-1
	WRITE(NOUT,911) NPK,THR1,THR2
911	FORMAT(/' ** ',I5,' PEAKS BETWEEN',F8.1,' AND ',F8.1,
     1            ' READ IN'/)

	CALL RDPRM2(XOFFS,YOFFS,NOT_USED,'X-OFFSET, Y-OFFSET')
	CALL RDPRM(SCALE,NOT_USED,'SCALE FACTOR')

        ILOWX=(NSAM1-NSAMC)/2+1
        ILOWY= (NROW1-NROWC)/2+1
        IHIGHX=NSAM1/2+NSAMC/2
        IHIGHY=NROW1/2+NROWC/2
	WRITE (NOUT,1111) ILOWX,ILOWY,IHIGHX,IHIGHY
1111    FORMAT(' ** ILOWX, ILOWY, IHIGHX, IHIGHY',4I6)

C NOW SORT PEAK PARAMETERS BY PEAK SIZE AND ESTABLISH RANKS
C (ARRAY NPEAK COULD BE USED IN PRINCIPLE TO KEEP TRACK OF
C "LEXICOGRAPHIC PEEK POSITION" IN ORIGINAL PEAK FILE)
	IF(LRANK) THEN
		CALL SORTZ(CLIST,XLIST,YLIST,NPEAK,NPK)
	ENDIF
C APPLY OFFSET AND SCALE FACTOR. THEN CHECK BOUNDARIES AND SET 
C UP ARRAY OF RANKS
	IPK=0
	DO 950 I=1,NPK
	XS=(FLOAT(NSAM1)+2.-(XLIST(I)+XOFFS))*SCALE
	YS=(FLOAT(NROW1)+2.-(YLIST(I)+YOFFS))*SCALE
	IF(XS.LT.ILOWX.OR.XS.GT.IHIGHX.OR.
     1       YS.LT.ILOWY.OR.YS.GT.IHIGHY) GOTO 950
	IX(1)=XS+0.5
	IX(2)=YS+0.5
	N=NAREA(IX,NP,IXWIN,IXPWIN)
	IF(N.EQ.0) GOTO 950
	IPK=IPK+1
	NPEAK(IPK)=IPK
	XLIST(IPK)=XS
	YLIST(IPK)=YS
	CLIST(IPK)=CLIST(I)
	NLIST(IPK)=N
C NLIST CONTAINS THE PATCH NUMBER THE PEAK BELONGS IN

950	CONTINUE
	WRITE(NOUT,951)IPK
951	FORMAT(/' ** NUMBER OF PEAKS AFTER COO CHECK = ',I5/)
	IF (IPK.EQ.0) STOP '*** NO QUALIFYING PEAKS FOUND'

	IF (LRANK) THEN
		IPK1=RANK1/100.*FLOAT(IPK)+0.5001
		IPK2=RANK2/100.*FLOAT(IPK)+0.5
		IPKR=IPK2-IPK1+1
		WRITE(NOUT,952) IPKR
952	FORMAT(/' ** NUMBER OF PEAKS WITHIN RANK RANGE = ',I5/)
	ELSE
C DEFAULT ASSIGNMENTS: ALL RANKS PASSED
		IPK1=1
		IPK2=IPK
		IPKR=IPK2-IPK1+1
	ENDIF

C---------------CONDENSE ARRAYS SO THAT ONLY REQUESTED RANK
C---------------RANGE IS LEFT!
	CALL RDPRMI(NUM,NDUMP,NOT_USED,
     &      'NO. OF PEAKS TO USE, DUMP?(1=YES)')
	IF (NDUMP.EQ.2) THEN
	  DO  I=IPK1,IPK2
	    WRITE(NOUT,*) XLIST(I),YLIST(I),CLIST(I),NPEAK(I)
	  ENDDO
	ENDIF

C NOW SORT THE REMAINING IPKR PEAKS BY ASCENDING Y-COORDINATE
	CALL SORTZ(YLIST(IPK1),XLIST(IPK1),CLIST(IPK1),
     &       NLIST(IPK1),IPKR)
C NOTE THAT NPEAK-ARRAY IS NOT BEING SORTED. THIS IS NOT
C NECESSARY IN THIS APPLICATION.
C APPLY OFFSET TO GET WINDOW STARTING COOS.
	DO  I=1,IPKR
	IND=I-1+IPK1
	XLIST(IND)=XLIST(IND)-NSAM2/2-1 
C        -1 ADDED 11/10/87
	YLIST(IND)=YLIST(IND)-NROW2/2-1 
C         -1 ADDED
	IF(NDUMP.EQ.2) WRITE(NOUT,*) XLIST(IND),YLIST(IND),
     1     CLIST(IND),NLIST(IND)
	ENDDO
	IF(NDUMP.EQ.2) RETURN

C	WRITE(NOUT,*) YLIST(IPK1),YLIST(IPK2)
C FIGURE OUT READING RANGE (FOR FIRST LINE TO BE READ IN)

	IYMIN=MAX0(0,INT(YLIST(IPK1)))
	IYMAX=MIN0(NROW1,INT(YLIST(IPK2)+NROW2-1))
C INITIALIZE MINIMUM, MAXIMUM OF PEAK NUMBER
	IPKMN=IPK1
	IPKMX=IPK1
C INITIALIZE RECORD CHECK ARRAY
	DO  IP=1,NP
	DO  I=1,NROW2
	IC=(IP-1)*NROW2+I
	NCOUNT(IC)=0
	ENDDO
	ENDDO

C SET REC. COUNTER;  FILL IN FIRST BUFFER
	IPREV=IYMIN
	CALL REDLIN(LUN14,BUF(IB1),NSAM1,IYMIN+1)
C NOW GO THROUGH ENTIRE IMAGE, LINE BY LINE, FILLING THE
C TWO BUFFERS ALTERNATELY
	DO  IY=IYMIN,IYMAX-1
C IY IS THE CURRENT Y-COORDINATE (RELATIVE TO 0 ORIGIN) OF THE 
C FIRST INPUT RECORD
C POSITION THE RECORD COUNTER FOR SECOND BUFFER LINE
	CALL REDLIN(LUN14,BUF(IB2),NSAM1,IY+2)

C ALLOW ONLY WINDOWS WHOSE TOP LEFT COOS ARE WITHIN THE
C RANGE IY-NROW2,IY+1
C THE EXTRA TWO ROWS ON EITHER SIDE ARE REQUIRED 
C FOR INTERPOLATION.
C FIND OUT WHICH OF THE SMALLEST Y CAN NOW BE ELIMINATED:

1000	IF(YLIST(IPKMN).LT.IY-NROW2) THEN
		IF(IPKMN.LT.IPK2) THEN
			IPKMN=IPKMN+1
			GOTO 1000
		ENDIF
	ENDIF
C FIND OUT WHICH OF THE LARGEST Y CAN NOW BE ADDED ON:
1100	IF(IPKMX.LT.IPK2) THEN
		IF(YLIST(IPKMX+1).LE.IY+1) THEN
			IPKMX=IPKMX+1
			GOTO 1100
		ENDIF
	ENDIF

C NOW GO THROUGH ALL AREAS DEFINED BY THE PEAK RANGE
C IPKMN, IPKMX TO FIND OUT WHICH SEGMENTS OF THE INPUT LINES
C ARE TO BE USED.
	DO 1200 L=IPKMN,IPKMX
	Y1=IY-YLIST(L)
	IY1=Y1
	IF(Y1.LT.0.0) IY1=-1
	IYPOS=Y1+1.500001
C NOTE THAT Y1 IS NEGATIVE FOR THE FIRST TIME THE
C SMALL AREA IS TOUCHED BY THE SLIDING BUFFER LINES!
C
C IYPOS IS THE CURRENT RECORD COUNT IN OUTPUT FILE
        IF(NDUMP.EQ.1)THEN
           WRITE(NOUT,*)
     1      'PK YCOO,INP REC,PEAK NO,CORR,OUTP REC = '
     1     ,YLIST(L),IY,L,CLIST(L),IY1
	   WRITE(NOUT,*) YLIST(L),IY,L,CLIST(L),IY1
        ENDIF

	DY=1-(Y1-IY1)
	X1=XLIST(L)+1
	IX1=X1
C IX1 IS THE X-COO (RELATIVE TO 1) OF THE FIRST ELEMENT IN THE INPUT
C ARRAY  
	DX=1-(X1-IX1)
	C1=(1-DX)*(1-DY)
	C2=DX*(1-DY)
	C3=DY*(1-DX)
	C4=DX*DY

C FIND WINDOW, PATCH AND ASSOCIATED BUFFER SEGMENT

	IX(1)=XLIST(L)+NSAM2/2+0.5
	IX(2)=YLIST(L)+NROW2/2+0.5
	N=NLIST(L)
	KS4=(IYPOS-1)*(NSAM2)+(N-1)*NOFFP
	IF(IYPOS.LT.1.OR.IYPOS.GT.NROW2) GOTO 1200
	IC=(N-1)*NROW2+IYPOS
	NCOUNT(IC)=NCOUNT(IC)+1
	DO  K4=1,NSAM2
	IX2=IX1+K4
	IF(IX2.GT.NSAM1) IX2=NSAM1
	I1=IB1-1+IX1+K4-1
	I2=IB1-1+IX2
	I3=IB2-1+IX1+K4-1
	I4=IB2-1+IX2
        VAL=BUF(I1)*C1
     $  +BUF(I2)*C2+BUF(I3)*C3+BUF(I4)*C4
	BUF(NOFF24+K4+KS4-1)=BUF(NOFF24+K4+KS4-1)+VAL
	ENDDO

1200	CONTINUE
C PERMUTATE BUFFERS
	ISAVE=IB1
	IB1=IB2
	IB2=ISAVE
	ENDDO

1550	CLOSE(NDOC)
C
C WRITE OUT AVERAGES

1560	CONTINUE

C WRITE OUT AVERAGES OF PATCHES

1680	CONTINUE
	DO  IP=1,NP
C 1ST AND LAST LINE REFUSE TO COME OUT RIGHT. SINCE THE
C BOUNDARIES ARE UNIMPORTANT, A FIXUP IS USED WHEREBY THE
C FIRST AND LAST LINE ARE REPLACED BY THE AVERAGE OF THE
C LINE NROW2-1. SEE BELOW.
	FNC(IP)=0.
	DO 1700 I=2,NROW2-1
	JREC=(IP-1)*NROW2+I
	KS4=(I-1)*NSAM2+(IP-1)*NOFFP
	IC=(IP-1)*NROW2+I
	FNC(IP)=FNC(IP)+FLOAT(NCOUNT(IC))

C SCALE AVERAGES
	IF(NCOUNT(IC).EQ.0) GOTO 1700
	DO  K=1,NSAM2
	  BUF(NOFF24+KS4+K-1)=BUF(NOFF24+KS4+K-1)/ FLOAT(NCOUNT(IC))
	ENDDO
1700	CALL WRTLIN(LUN2,BUF(NOFF24+KS4),NSAM2,JREC)
	FNC(IP)=FNC(IP)/FLOAT(NROW2-2)

C FIXUP OF BOUNDARY PROBLEM .....................
	B=0					
	DO  K=1,NSAM2			
	  B=B+BUF(NOFF24+KS4+K-1)			
	ENDDO
	B=B/FLOAT(NSAM2)			
	DO  K=1,NSAM2			
	  BUF(K)=B				
	ENDDO
	JREC=(IP-1)*NROW2+1			
	CALL WRTLIN(LUN2,BUF,NSAM2,JREC)	
	JREC=(IP-1)*NROW2+NROW2			
	CALL WRTLIN(LUN2,BUF,NSAM2,JREC)	
C END FIXUP .....................................

	ENDDO
	CLOSE(LUN2)

	WRITE(NDAT,1812)NSAMC,NROWC
1812    FORMAT(/' ** DIMENSIONS OF CCF WINDOW USED:',2I5/)

	WRITE(NDAT,1814)
1814	FORMAT(//' ** NUMBER OF WINDOWS IN EACH PATCH'/)

	WRITE(NDAT,1815) (FNC(I),I=1,NP)
1815	FORMAT(10F6.1)

	RETURN

9000	CALL ERRT(4,'WINAVE',IER)

	RETURN
	END
@


1.20
log
@GPL_2010
@
text
@d13 1
a13 1
C=* Email: spider@@wadsworth.org                                        *
@


1.19
log
@GPL License fixed
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.18
log
@HRI GPL License used
@
text
@a7 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d11 1
a11 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a30 6

C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.17
log
@*** empty log message ***
@
text
@d9 24
@


1.16
log
@opfilec
@
text
@d85 1
a85 1
           CALL ERRT(2,'WINAVE2',NE)
d158 1
a158 1
	BUF(NOFF24+IS4-1)=0.
d161 2
a162 2
C NSAMC, NROWC ARE THE DIMENSIONS OF THE AREA USED IN THE
C CORRELATION FUNCTION
d167 4
a170 4
C READ IN DOCUMENT FILE INTO LARGE BUFFER DBUF
	CALL FILERD(DOCNAM,NLETD,NULL,'DOCUMENT',IRTFLG)
	IF (DOCNAM(1:1).EQ.'*') RETURN
        CALL FILCAN(DOCNAM,NLETD,NULL,NULL,DOCNAM,DATEXC,IER)        
d172 3
a174 3
C IKEY IS ARBITRARY. WE ARE INTERESTED IN GETTING THE ENTIRE
C REGISTER SET AT ONCE, SO WE WILL IGNORE THE CONTENTS OF RLIST
C (WHICH FOR IKEY=1 RETURNS THE REGISTER UNDER THAT KEY)
d177 1
a177 1
     1      MAXREG,NKEY,LERR)
d180 1
a180 1
C NKEY= NUMBER OF KEYS FOUND IN DOCUMENT FILE
d183 1
a183 1
     1    'RANGE OF RANKS IN PERCENT (FROM,TO;100=BEST)')
d192 1
a192 1
C START READING, CHECK FOR PEAKS WITHIN SPECIFIED VALUE RANGE
d196 1
a196 1
C NOTE THAT THE FIRST ELEMENT CONTAINS THE KEY
@


1.15
log
@,, bug
@
text
@d3 3
a5 2
C                                                                      *
C                                                                      *
d16 1
a17 1
C                                                                      *
a19 3
C  PARAMETERS:                                                         *
C                                                                      *
C
d37 2
a38 1
 
d40 2
a41 1
	INCLUDE 'CMBLOCK.INC'
a63 1
        COMMON /COMMUN/ FILNAM1, DOCNAM
d71 1
a71 1
        CHARACTER*81 FILNAM1,DOCNAM
d74 1
a74 1
        NULL=CHAR(0)
d80 2
a81 2
        CALL OPFIL(.TRUE.,FILNAM1,LUN14,'O',NSAM1,NROW1,NSLICE,
     &             MAXIM,'SCANNED DATA',.FALSE.,IRTFLG)
d84 1
a84 1
	IF (NSLICE.GT.1) THEN
d90 2
a91 1
	IF (FILNAM1(1:1) .EQ. '*') RETURN
d137 1
a137 1
        CALL OPFIL(.FALSE.,FILNAM1,LUN2,'U',NSAM2,NROW2,NP,
@


1.14
log
@bad rdprmi nloop,iloop remains fixed
@
text
@d102 1
a102 1
		CALL RDPRMI(IDUM1,IDUM2,,NOT_USED,
@


1.13
log
@nloop,iloop_removed
@
text
@d100 1
a100 1
     1       'NUMBER OF PATCHES, GENERATE PATCHES?(0/1)')
d102 2
a103 2
		CALL RDPRMI(IDUM1,IDUM2,NP,1,
     1            'INTEGER CORNER COOS OF PATCHES$')
d111 1
a111 1
     &                     'STARTING COOs')
d265 2
a266 2
     1      'NO. OF PEAKS TO USE, DUMP?(1=YES)')
	IF(NDUMP.EQ.2) THEN
d274 1
a274 1
     1       NLIST(IPK1),IPKR)
@


1.12
log
@header
@
text
@d93 1
a93 1
	CALL RDPRMI(NSAM2,NROW2,NLOOP,ILOOP,'DIMENSIONS')
d98 2
a99 2
	CALL RDPRMI(IXPWIN(1),IXPWIN(2),NLOOP,ILOOP,'PATCH DIMENSIONS')
	CALL RDPRMI(NP,NGEN,NLOOP,ILOOP,
d110 1
a110 1
		CALL RDPRMI(IXP(1,1),IXP(2,1),NLOOP,ILOOP,
d112 1
a112 1
		CALL RDPRMI(INCREMX,INCREMY,NLOOP,ILOOP,
d181 2
a182 2
	CALL RDPRM2(THR1,THR2,NLOOP,ILOOP,'PEAK VALUES (FROM,TO)')
	CALL RDPRM2(RANK1,RANK2,NLOOP,ILOOP,
d208 2
a209 2
	CALL RDPRM2(XOFFS,YOFFS,NLOOP,ILOOP,'X-OFFSET, Y-OFFSET')
	CALL RDPRM(SCALE,NLOOP,ILOOP,'SCALE FACTOR')
d264 1
a264 1
	CALL RDPRMI(NUM,NDUMP,NLOOP,ILOOP,
@


1.11
log
@a
@
text
@d2 19
a20 1
C**********************************************************************
@


1.10
log
@CNO_SAVE
@
text
@d21 1
a21 1
CNO_SAVE 
@


1.9
log
@used opfil
@
text
@d21 2
@


1.8
log
@*** empty log message ***
@
text
@d5 1
a5 1
C                     2/28/89 long file names added
d60 5
a64 3
	CALL FILERD(FILNAM1,NLET1,NULL,'SCANNED DATA',IRTFLG)
	IF (FILNAM1(1:1).EQ.'*') RETURN
	CALL OPENF(FILNAM1,LUN14,NSAM1,NROW1,'OLD',NF,NSLICE)
d70 4
a73 4
	CALL FILERD(FILNAM1,NLET1,NULL,'AVERAGE',irtflg)
	IF (FILNAM1(1:1).EQ.'*') RETURN
	IFORM=3
	CALL RDPRMI(NSAM2,NROW2,NLOOP,ILOOP,'DIMENSIONS$')
d81 1
a81 1
	IF(NGEN.EQ.0) THEN
d85 3
a87 3
                DO  I=1,2
                   IXP(I,IP)=IBUF(2*(IP-1)+I)
		ENDDO
d113 2
a114 2
C OPEN VOLUME-FORMATTED FILE. EACH SLICE CORRESPONDS TO ONE
C PATCH AVERAGE, IN THE ORDER PATCHES ARE SPECIFIED
d116 4
a119 2
	CALL OPENF(FILNAM1,LUN2,NSAM2,NROW2,'UNKNOWN',NF,NP)
	IF (NF.NE.2) GOTO 9000
d134 1
a134 1
C CLEAR OUTPUT BUFFERS
d422 2
a423 1
1812      FORMAT(/' ** DIMENSIONS OF CCF WINDOW USED:',2I5/)
d426 1
d429 1
a429 1
1813	FORMAT(1X,(10I8))
d431 1
@


1.7
log
@removed NECHO=0
@
text
@d82 2
a83 2
		DO 30 IP=1,NP
                DO 20 I=1,2
d85 2
a86 2
20		CONTINUE
30		CONTINUE
d93 1
a93 1
		DO 50 IP=1,NP
d102 1
a102 1
50		CONTINUE
d133 3
a135 2
	DO 5 IS4=1,NTOTAL
5	BUF(NOFF24+IS4-1)=0.
d243 1
a243 1
	  DO 970 I=IPK1,IPK2
d245 1
a245 1
970	  CONTINUE
d254 1
a254 1
	DO 980 I=1,IPKR
d262 1
a262 1
980	CONTINUE
d274 2
a275 2
	DO 990 IP=1,NP
	DO 990 I=1,NROW2
d277 3
a279 1
990	NCOUNT(IC)=0
d286 1
a286 1
	DO 1300 IY=IYMIN,IYMAX-1
d351 1
a351 1
	DO 1150 K4=1,NSAM2
d361 1
a361 1
1150	CONTINUE
d368 1
a368 1
1300	CONTINUE
d379 1
a379 1
	DO 1750 IP=1,NP
d393 3
a395 2
	DO 1690 K=1,NSAM2
1690	BUF(NOFF24+KS4+K-1)=BUF(NOFF24+KS4+K-1)/ FLOAT(NCOUNT(IC))
d401 3
a403 3
	DO 1710 K=1,NSAM2			
	B=B+BUF(NOFF24+KS4+K-1)			
1710	CONTINUE				
d405 3
a407 2
	DO 1720 K=1,NSAM2			
1720	BUF(K)=B				
d414 1
a414 1
1750	CONTINUE
@


1.6
log
@SORTZ4 replaced by SORTZ
@
text
@a56 2
	NECHO=0
 
@


1.5
log
@changed doc file common
@
text
@d199 1
a199 1
		CALL SORTZ4(CLIST,XLIST,YLIST,NPEAK,NPK)
d250 1
a250 1
	CALL SORTZ4(YLIST(IPK1),XLIST(IPK1),CLIST(IPK1),
@


1.4
log
@non f77 continuation satatement
@
text
@d16 1
a16 1
C   a.l. -- ARRAYS PUT IN UNLABELED COMMON
d37 6
a42 2
        COMMON /DOC_DIMS/MAXKEY,MAXREG,NKEY,NREG
	COMMON /DOC_BUF/ DBUF(1)
@


1.3
log
@replace type by write
@
text
@a20 1
#ifdef SP_UNIX
a21 3
#else
	INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
d74 1
a74 1
	CALL RDPRMI(IXPWIN(1),IXPWIN(2),NLOOP,ILOOP,'PATCH DIMENSIONS$')
d76 1
a76 1
     1 'NUMBER OF PATCHES, GENERATE PATCHES?(0/1)$')
d88 2
a89 1
		CALL RDPRMI(INCREMX,INCREMY,NLOOP,ILOOP,'INCREMENTS X,Y')
d389 1
a389 2
1690	BUF(NOFF24+KS4+K-1)=BUF(NOFF24+KS4+K-1)/
	1 FLOAT(NCOUNT(IC))
@


1.2
log
@cpp_lines_added
@
text
@d153 3
a155 2
	1 MAXREG,NKEY,LERR)
	TYPE *,'** NUMBER OF PEAKS IN DOC FILE ',NKEY
d182 1
a182 1
	1       ' READ IN'/)
d207 1
a207 1
	1  YS.LT.ILOWY.OR.YS.GT.IHIGHY) GOTO 950
d241 1
a241 1
	1 'NO. OF PEAKS TO USE, DUMP?(1=YES)')
d243 3
a245 3
		DO 970 I=IPK1,IPK2
		TYPE *,XLIST(I),YLIST(I),CLIST(I),NPEAK(I)
970	CONTINUE
d249 2
a250 2
	CALL SORTZ4(YLIST(IPK1),XLIST(IPK1),CLIST(IPK1),NLIST(IPK1)
	1 ,IPKR)
d260 2
a261 2
	IF(NDUMP.EQ.2)
	1 TYPE *,XLIST(IND),YLIST(IND),CLIST(IND),NLIST(IND)
d265 1
a265 1
C	TYPE *,YLIST(IPK1),YLIST(IPK2)
d323 4
a326 3
           TYPE *,'PK YCOO,INP REC,PEAK NO,CORR,OUTP REC = '
     1 ,YLIST(L),IY,L,CLIST(L),IY1
	   TYPE *,YLIST(L),IY,L,CLIST(L),IY1
@


1.1
log
@Initial revision
@
text
@d21 3
d25 1
@
