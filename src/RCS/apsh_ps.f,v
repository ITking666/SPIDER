head	1.110;
access;
symbols
	healthdept_2018:1.110
	pre_getangas:1.98
	GPL2010:1.93
	pre_GPL2010:1.92
	pre_var_equation:1.87
	pre_fftwrings:1.84
	pre_opfiles:1.81
	src:1.81
	best-code:1.80
	x-named-regs:1.80
	x:1.80
	v13-00:1.80
	pre_GPL:1.78
	prec_CA:1.64
	noindx:1.58
	Bproc:1.43
	oct21:1.33
	last77:1.20;
locks; strict;
comment	@c @;


1.110
date	2018.10.03.14.33.55;	author leith;	state Exp;
branches;
next	1.109;

1.109
date	2015.04.24.14.03.58;	author leith;	state Exp;
branches;
next	1.108;

1.108
date	2012.04.16.17.13.14;	author leith;	state Exp;
branches;
next	1.107;

1.107
date	2012.01.18.13.38.28;	author leith;	state Exp;
branches;
next	1.106;

1.106
date	2012.01.11.14.48.50;	author leith;	state Exp;
branches;
next	1.105;

1.105
date	2011.12.23.16.21.57;	author leith;	state Exp;
branches;
next	1.104;

1.104
date	2011.12.23.16.15.56;	author leith;	state Exp;
branches;
next	1.103;

1.103
date	2011.12.02.13.56.12;	author leith;	state Exp;
branches;
next	1.102;

1.102
date	2011.12.01.20.23.25;	author leith;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.14.14.47.05;	author leith;	state Exp;
branches;
next	1.100;

1.100
date	2011.02.16.20.20.46;	author leith;	state Exp;
branches;
next	1.99;

1.99
date	2011.02.16.18.51.11;	author leith;	state Exp;
branches;
next	1.98;

1.98
date	2011.01.21.16.22.37;	author leith;	state Exp;
branches;
next	1.97;

1.97
date	2010.10.12.18.32.23;	author leith;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.25.17.48.23;	author leith;	state Exp;
branches;
next	1.95;

1.95
date	2010.06.24.19.10.08;	author leith;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.24.16.12.45;	author leith;	state Exp;
branches;
next	1.93;

1.93
date	2010.06.24.13.26.16;	author leith;	state Exp;
branches;
next	1.92;

1.92
date	2010.03.02.15.52.53;	author leith;	state Exp;
branches;
next	1.91;

1.91
date	2010.03.02.13.04.24;	author leith;	state Exp;
branches;
next	1.90;

1.90
date	2010.02.09.19.25.46;	author leith;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.31.16.12.05;	author leith;	state Exp;
branches;
next	1.88;

1.88
date	2009.08.28.15.36.09;	author leith;	state Exp;
branches;
next	1.87;

1.87
date	2008.11.25.17.41.05;	author leith;	state Exp;
branches;
next	1.86;

1.86
date	2008.11.25.15.47.33;	author leith;	state Exp;
branches;
next	1.85;

1.85
date	2008.05.19.12.02.35;	author leith;	state Exp;
branches;
next	1.84;

1.84
date	2008.04.08.13.48.15;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	2008.03.19.12.12.12;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.19.14.06.36;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	2006.06.23.13.40.58;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2005.10.17.19.53.45;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.17.17.50.48;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2005.06.03.18.18.01;	author cyang;	state Exp;
branches;
next	1.77;

1.77
date	2005.05.25.15.32.48;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2005.05.03.19.09.09;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2005.03.03.02.34.19;	author cyang;	state Exp;
branches;
next	1.74;

1.74
date	2005.01.27.15.59.03;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	2004.10.07.14.33.19;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	2004.09.30.16.48.38;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	2004.08.18.14.15.55;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	2004.08.17.19.28.10;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2004.08.17.17.37.40;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2004.08.05.13.43.38;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.30.16.36.39;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.23.16.35.03;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2004.03.18.14.48.27;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.08.18.14.46;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2003.08.27.15.01.26;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2003.08.27.14.51.14;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.24.14.36.14;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.14.13.03.44;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2003.02.19.21.41.02;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2002.12.30.14.50.49;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.01.14.04.09;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2002.04.30.19.06.06;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2002.03.11.14.07.52;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.22.20.57.27;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.22.18.36.01;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2001.11.05.19.08.18;	author hxgao;	state Exp;
branches;
next	1.51;

1.51
date	2001.10.09.16.58.30;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2001.08.27.14.25.18;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.13.16.04.35;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.09.14.05.04;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.28.15.21.44;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2001.02.02.20.33.04;	author pawel;	state Exp;
branches;
next	1.45;

1.45
date	2000.12.15.18.29.33;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2000.10.03.19.57.10;	author bimal;	state Exp;
branches;
next	1.43;

1.43
date	2000.08.22.18.47.47;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2000.03.21.21.02.28;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2000.03.20.20.31.53;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2000.01.27.15.56.54;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2000.01.06.18.31.29;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2000.01.06.18.18.47;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.06.17.54.24;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	99.12.03.20.33.51;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	99.12.03.20.21.56;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	99.10.25.18.22.43;	author pawel;	state Exp;
branches;
next	1.33;

1.33
date	99.10.20.21.39.19;	author pawel;	state Exp;
branches;
next	1.32;

1.32
date	99.08.05.13.27.37;	author pawel;	state Exp;
branches;
next	1.31;

1.31
date	99.08.04.21.12.19;	author pawel;	state Exp;
branches;
next	1.30;

1.30
date	99.08.04.13.04.42;	author pawel;	state Exp;
branches;
next	1.29;

1.29
date	99.08.03.20.51.39;	author pawel;	state Exp;
branches;
next	1.28;

1.28
date	99.08.03.19.36.59;	author pawel;	state Exp;
branches;
next	1.27;

1.27
date	99.08.03.19.23.15;	author pawel;	state Exp;
branches;
next	1.26;

1.26
date	99.08.03.18.58.21;	author pawel;	state Exp;
branches;
next	1.25;

1.25
date	99.07.30.14.36.34;	author pawel;	state Exp;
branches;
next	1.24;

1.24
date	99.07.26.21.25.04;	author pawel;	state Exp;
branches;
next	1.23;

1.23
date	99.06.03.20.50.54;	author pawel;	state Exp;
branches;
next	1.22;

1.22
date	99.05.03.19.53.19;	author pawel;	state Exp;
branches;
next	1.21;

1.21
date	99.04.16.14.12.11;	author pawel;	state Exp;
branches;
next	1.20;

1.20
date	99.03.19.15.01.06;	author pawel;	state Exp;
branches;
next	1.19;

1.19
date	99.03.01.18.34.14;	author pawel;	state Exp;
branches;
next	1.18;

1.18
date	99.03.01.14.55.11;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	99.02.13.18.55.34;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	99.02.11.15.31.05;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	99.02.10.16.08.42;	author pawel;	state Exp;
branches;
next	1.14;

1.14
date	98.11.30.19.20.33;	author pawel;	state Exp;
branches;
next	1.13;

1.13
date	98.11.06.20.53.04;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	98.11.05.21.16.55;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	98.11.03.23.32.35;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	98.11.02.20.31.40;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	98.10.30.16.23.50;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	98.04.06.19.25.35;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	97.10.17.15.19.05;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	97.10.10.17.48.04;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	97.08.15.16.15.54;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	97.08.15.16.05.56;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	97.08.15.13.27.04;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	97.07.24.15.08.46;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	97.01.21.15.29.57;	author pawel;	state Exp;
branches;
next	;


desc
@AP MQ
@


1.110
log
@email_health_dept
@
text
@C++*********************************************************************
C
C    APSH_PS.F      USED CMLIMIT                  AUG 00 ARDEAN LEITH
C                   ADDED REF_CIRC FILE           APR 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   OPFILEC                       FEB 03 ARDEAN LEITH
C                   APMASTER REWRITE              AUG 03 ARDEAN LEITH
C                   USED AP_OUT                   FEB 04 ARDEAN LEITH
C                   NORMASS USED FOR ALTIX        JUN 04 ARDEAN LEITH
C                   INTERPOLATION ON EDGE BUG     AUG 04 ARDEAN LEITH
C                   CROSRNG_E SPEEDS UP           AUG 04 ARDEAN LEITH
C                   AP_END CALL HAS PARLIST       OCT 04 ARDEAN LEITH
C                   PEAKV = 1                     JAN 05 ARDEAN LEITH
C                   RANGNEWT OPT 64 BUG FIXED     MAY 05 ARDEAN LEITH
C                   DISCARD MIRROR ...            JUN 06 ARDEAN LEITH
C                   AP_STAT CALL                  JAN 07 ARDEAN LEITH
C                   REF-RINGS FILE ADDED          MAR 08 ARDEAN LEITH
C                   CROSRNG_E REWRITE             MAR 08 ARDEAN LEITH
C                   IREFLIST VAR. NAME            MAR 08 ARDEAN LEITH
C                   APRINGS_ONE_NEW               MAR 08 ARDEAN LEITH
C                   AP_END CALL CHANGED           NOV 08 ARDEAN LEITH
C                   AP_STAT_ADD                   NOV 08 ARDEAN LEITH
C                   NPROJ BUG                     AUG 09 ARDEAN LEITH
C                   ISHRANGEX                     FEB 10 ARDEAN LEITH
C                   LENTT, TT REMOVED             JUN 10 ARDEAN LEITH
C                   CROSRNG_2                     JUN 10 ARDEAN LEITH
C                   AP_STAT NBORDER               OCT 10 ARDEAN LEITH
C                   RENAMED FROM MRQLI_PS         JAN 11 ARDEAN LEITH
C                   AP_GETDATA                    DEC 11 ARDEAN LEITH
C                   ROTFIRST                      DEC 11 ARDEAN LEITH
C                   FBS_WANTED                    JAN 12 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C APSH_PS 
C  
C PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SAMPLE IMAGES
C           USED IF:  CIRCREF_IN_CORE .AND. NUMEXP >= NUMTH 
C
C PARAMETERS:
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS      (SENT)
C       NUMREF              NO. OF IMAGES                        (SENT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS      (SENT)
C       NUMEXP              NO. OF IMAGES                        (SENT)
C       NX,NY           ACTUAL (NOT-WINDOWED) IMAGE SIZE     (SENT)
C       ISHRANGEX,ISHRANGEY ALLOWED SHIFT RANGE                  (SENT)
C       ISTEP               SHIFT STEP WITHIN RANGE              (SENT)
C       NRING                                                    (SENT)
C       LCIRC                                                    (SENT)
C       NUMR                                                     (SENT)
C       CIRCREF                                                  (SENT)
C       CIRCREF_IN_CORE                                          (SENT)
C       MODE                                                     (SENT)
C       REFANGDOC           REF. ANGLES FILE NAME                (SENT)
C       EXPANGDOC           EXP. ANGLES FILE NAME                (SENT)
C       SCRFILE                                                  (SENT)
C       FFTW_PLANS                                               (SENT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE      (SENT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE      (SENT)
C       RANGE                                                    (SENT)
C       ROTFIRST            USE RTSQ ON EXP INPUT IMAGES         (SENT)
C       CKMIRROR            LOGICAL FLAG TO CHECK MIRRORING      (SENT)
C       CTYPE                                                    (SENT)
C       LUNDOC                                                   (SENT)
C
C
C NOTE:  IF USING APSH_PS, MOST MEMORY DEMAND APPEARS TO BE DEPENDENT 
C        ON LCIRC & NUMREF.  LCIRC IS THE TOTAL LENGTH OF THE ARRAY
C        THAT HOLDS THE CIRCULAR RINGS, SO IT IS DEPENDENT ON
C        NUMBER OF RINGS AND THEIR RADIUS.  NUMREF IS NUMBER OF REFERENCE
C        IMAGES. BIGGEST ARRAY ALLOCATED IS: CIRCREF(LCIRC,NUMREF)
C        ANOTHER SMALL ALLOCATED ARRAY IS: A(NX,NY,NUMTH)
C        FOR 83 IMAGES of 125x125 WITH RINGS AT 5...47 SIZE=45MB
C        ARRAYS ONLY APPEAR TO TAKE: 3.6MB?
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************


C ---------------------  NON-MPI CODE --------------------------------
#ifndef USE_MPI

       SUBROUTINE APSH_PS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
     &               NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,
     &               CKMIRROR,CTYPE,LUNDOC,FBS_WANTED)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	INTEGER                :: IREFLIST(NUMREF) 
	INTEGER                :: NUMREF 
	INTEGER                :: IEXPLIST(NUMEXP) 
	INTEGER                :: NUMEXP 
        INTEGER                :: NX,NY,ISHRANGEX,ISHRANGEY,ISTEP
        INTEGER                :: NRING,LCIRC
        INTEGER                :: NUMR(3,NRING)
	REAL                   :: CIRCREF(LCIRC,NUMREF)
	LOGICAL                :: CIRCREF_IN_CORE
        CHARACTER (LEN=1)      :: MODE
        CHARACTER (LEN=*)      :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)      :: SCRFILE
        INTEGER *8             :: FFTW_PLANS(*)
        CHARACTER (LEN=*)      :: REFPAT,EXPPAT 
        REAL                   :: RANGE
	LOGICAL                :: ROTFIRST,CKMIRROR
        CHARACTER (LEN=*)      :: CTYPE
        INTEGER                :: LUNDOC
        LOGICAL                :: FBS_WANTED


C       AUTOMATIC ARRAYS
	REAL                   :: ANGOUT(3)

C       ALLOCATED ARRAYS
	REAL, ALLOCATABLE      :: EXPBUF(:,:,:)
	INTEGER, ALLOCATABLE   :: NPROJA(:) 
	REAL, ALLOCATABLE      :: DLIST(:,:) 
	REAL, ALLOCATABLE      :: REFDIR(:,:),EXPDIR(:,:) 
	REAL, ALLOCATABLE      :: ANGREF(:,:),ANGEXP(:,:)
	REAL, ALLOCATABLE      :: TMPBUF(:,:)

        INTEGER, PARAMETER     :: NLISTMAX = 15
        REAL                   :: PARLIST(NLISTMAX)

        REAL                   :: ADUM
        LOGICAL                :: ANGINHEADER  
	LOGICAL                :: GOTREFANG,LIMITRANGE
	LOGICAL                :: MIRRORNEW

        INTEGER                :: NBORDER = 0      ! # BORDER PIXELS
        INTEGER                :: NSUBPIX = 0      ! # SUBPIX PIXELS

        INTEGER, PARAMETER     :: LUNPIC  = 77
        INTEGER, PARAMETER     :: LUNANG   = 78
        INTEGER, PARAMETER     :: LUNRING = 50

        LOGICAL, PARAMETER     :: MPIBCAST = .FALSE.
	REAL, PARAMETER        :: QUADPI     = 3.14159265358979323846
	REAL, PARAMETER        :: DGR_TO_RAD = (QUADPI/180)


        MYPID = -1
 
C       SET TYPE OF OUTPUT DOC FILES WANTED
        NWANTOUT = 7
        IF (CTYPE(1:2) == 'SH') NWANTOUT = 15

C       INITIALIZE CCROT STATISTICS COUNTERS
        ANGDIFTHR   = 0.0
        CALL  AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
     &                   CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                   CCROTIMPROV,IWORSECCROT,CCROTWORSE)

        LIMITRANGE  = (RANGE > 0.0)
        RANGECOS    = COS(RANGE * DGR_TO_RAD)  
        !write(6,*) ' range,rangecos:',range,rangecos

C       FIND NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)
        CALL FLUSHRESULTS()

        !write(6,*) ' aprings_new called '
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
        CALL APRINGS_NEW(IREFLIST,NUMREF, NX,NY,
     &               NRING,LCIRC,NUMR,MODE,FFTW_PLANS,
     &               REFPAT,LUNPIC,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)

	ALLOCATE(EXPBUF(NX,NY,NUMTH), 
     &           DLIST(5,NUMTH), 
     &           NPROJA(NUMTH), 
     &           STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = NX*NY*NUMTH + 6*NUMTH  
           CALL  ERRT(46,'APSH_PS; EXPBUF & DLIST',MWANT)
           RETURN
        ENDIF 
        DLIST = 0.0    ! ZEROS WHOLE DLIST

        GOTREFANG = .FALSE.
        IF (LIMITRANGE .OR. CTYPE(1:2) == 'SH') THEN
C          REFANGLES FILE FOR RESTRICTED ANGULAR SEARCH  OR 'SH'
	   ALLOCATE(REFDIR(3,NUMREF),
     &              ANGREF(3,NUMREF), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
               MWANT = 6*NUMREF  
               CALL ERRT(46,'APSH_PS; REFDIR, ANGREF',MWANT)
               GOTO 9999
           ENDIF 
C          READ REF. ANGLES INTO ANGREF
C          CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	   CALL AP_GETANGAS(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                      LUNPIC,LUNANG,3,ANGREF,GOTREFANG,NGOTREF,
     &                      .TRUE.,REFDIR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF

        NGOTPAR = 0
        IF ((CTYPE(1:2) == 'SH' .AND. EXPANGDOC .NE. CHAR(0))) THEN
	   ALLOCATE(ANGEXP(8,NUMEXP), 
     &              EXPDIR(3,NUMEXP), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              MWANT = 11*NUMEXP 
              CALL ERRT(46,'APSH_PS; ANGEXP....',MWANT)
              GOTO 9999
           ENDIF 

C          READ EXP. ANGLES INTO ANGEXP
C          CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS(EXPDIR).
	   CALL AP_GETANGAS(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                      LUNPIC,LUNANG,8,ANGEXP,GOTEXPANG,NGOTPAR,
     &                      .TRUE.,EXPDIR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

       ELSE
C          DUMMY ALLOCATE TO AVOID BUS ERROR ON SOME SYSTEMS
	   ALLOCATE(ANGEXP(8,1), 
     &              EXPDIR(3,1), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              MWANT = 11  
              CALL ERRT(46,'APSH_PS; ANGEXP....',MWANT)
              GOTO 9999
           ENDIF 
        ENDIF

        anginheader = .FALSE. ! unfinished !!!!!!!!!!!
        IF (ROTFIRST) THEN
	   ALLOCATE(TMPBUF(NX,NY), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_PS; TMPBUF',NX*NY)
              GOTO 9999
           ENDIF
           anginheader = (expangdoc == '*') ! unfinished !!!!!!!!!!!
           IF (FBS_WANTED) THEN
            WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH FBS INTERPOLATION'
           ELSE
           WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH QUAD INTERPOLATION'
           ENDIF
        ENDIF 

C       LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES -----------
 	DO IEXPT=1,NUMEXP,NUMTH

C          LOAD EXP. IMAGE DATA FOR THIS SET OF IMAGES
           IEND = MIN(NUMEXP,IEXPT+NUMTH-1)
           IF (ROTFIRST) THEN
C             WANT TO ROTATE/SHIFT EXP IMAGES WHEN READING THEM
	      CALL AP_GETDATA_RTSQ(IEXPLIST,NUMEXP, 
     &                    NX,NY, NX,NY,0.0,
     &                    NUMTH,EXPPAT,LUNPIC, IEXPT,IEND,
     &                    ANGINHEADER, ANGEXP, 
     &                    MPIBCAST, TMPBUF,EXPBUF,
     &                    .FALSE., ADUM, ADUM, FBS_WANTED,IRTFLG)
           ELSE
	      CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                    NX,NY, NX,NY,0.0,
     &                    NUMTH,EXPPAT,LUNPIC, IEXPT,IEND,
     &                    .TRUE., EXPBUF,
     &                    .FALSE.,ADUM,ADUM, IRTFLG)
           ENDIF
           IF (IRTFLG .NE. 0) GOTO 9999

C          NUMTH INPUT IMAGES READY TO BE ALIGNED
c$omp      parallel do private(iexp,it)
	   DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
              IT = IEXP - IEXPT + 1
	      CALL APRQ2D(EXPBUF(1,1,IT),CIRCREF,NUMR,
     &	            NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &	            LCIRC,NRING,NUMREF,MODE,
     &              REFDIR,EXPDIR(1,IEXP),RANGECOS,
     &              DLIST(1,IT),DLIST(2,IT),
     &              DLIST(3,IT),DLIST(4,IT),
     &              DLIST(5,IT),NPROJA(IT),
     &              CKMIRROR,LIMITRANGE,FFTW_PLANS)
	   ENDDO
c$omp      end parallel do

C          OUTPUT FROM DLIST POSITION 
C          1 - NUMBER OF MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION) RANGNEW
C          4 - SX SHIFT
C          5 - SY SHIFT
    
           DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
              IT     = IEXP - IEXPT + 1
              IMGEXP = IEXPLIST(IEXP)

C             DLIST(1,IT) IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
C                 (<0 IF MIRRORED, 0 IF NO SIMILAR IMAGE )

              IREF = INT(DLIST(1,IT))
              IF (IREF .LT. 0) THEN
C                MIRRORED REFERENCE IMAGE
                 IMGREF = IREFLIST(-IREF)

C                IREFT IS FOR REFDIR INDEX
                 IREFT     = -IREF
                 MIRRORNEW = .TRUE.

              ELSEIF (IREF == 0) THEN
C                NO NEARBY REFERENCE IMAGE
                 IMGREF = 0

C                IREFT IS FOR REFDIR INDEX
                 IREFT  = 1
                 MIRRORNEW = .FALSE.

              ELSE
                 IMGREF = IREFLIST(IREF)
C                IREFT IS FOR REFDIR INDEX
                 IREFT     = IREF
                 MIRRORNEW = .FALSE.
              ENDIF
 
              CCROT     = DLIST(2,IT)
              RANGNEW   = DLIST(3,IT)
              XSHNEW    = DLIST(4,IT)
              YSHNEW    = DLIST(5,IT)
              NPROJ     = NPROJA(IT)
              PEAKV     = 1.0

              CALL AP_END(IEXP,IMGEXP,IMGREF,
     &                ANGREF(1,IREFT),REFDIR(1,IREFT),
     &                ANGEXP(1,IEXP), EXPDIR(1,IEXP),ISHRANGEX,
     &                GOTREFANG, NGOTPAR, CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW, MIRRORNEW,REFPAT,
     &                NPROJ, CTYPE, LUNDOC,PARLIST)

              CALL AP_STAT_ADD(NGOTPAR,CCROT,PARLIST(10),
     &                       ANGDIFTHR,ANGEXP(8,IEXP),
     &                       CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                       CCROTIMPROV,IWORSECCROT,CCROTWORSE)
	   ENDDO
	ENDDO

        IF (LUNDOC > 0) THEN
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
          CALL AP_STAT(NUMEXP,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,
     &                 NBORDER,NSUBPIX,LUNDOC)
        ENDIF

9999    CONTINUE

C       DEALLOCATE  ARRAYS
        IF (ALLOCATED(DLIST))      DEALLOCATE(DLIST)
        IF (ALLOCATED(NPROJA))     DEALLOCATE(NPROJA)
	IF (ALLOCATED(EXPBUF))     DEALLOCATE(EXPBUF)
	IF (ALLOCATED(REFDIR))     DEALLOCATE(REFDIR)
	IF (ALLOCATED(ANGEXP))     DEALLOCATE(ANGEXP)
	IF (ALLOCATED(ANGREF))     DEALLOCATE(ANGREF)

	END


#else

C------------------------  MPI SPECIFIC SUBROUTINE --------------------

       SUBROUTINE APSH_PS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
     &               NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,
     &               CKMIRROR,CTYPE,LUNDOC,FBS_WANTED)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	INTEGER               :: IREFLIST(NUMREF) 
	INTEGER               :: NUMREF 
	INTEGER               :: IEXPLIST(NUMEXP) 
	INTEGER               :: NUMEXP 
        INTEGER               :: NX,NY,ISHRANGEX,ISHRANGEY,ISTEP
        INTEGER               :: NRING,LCIRC
        INTEGER               :: NUMR(3,NRING)
	REAL                  :: CIRCREF(LCIRC,NUMREF)
	LOGICAL               :: CIRCREF_IN_CORE
        CHARACTER (LEN=1)     :: MODE
        CHARACTER (LEN=*)     :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)     :: SCRFILE
        INTEGER *8            :: FFTW_PLANS(*)
        CHARACTER (LEN=*)     :: REFPAT,EXPPAT 
        REAL                  :: RANGE
	LOGICAL               :: ROTFIRST,CKMIRROR
        CHARACTER (LEN=*)     :: CTYPE
        INTEGER               :: LUNDOC
        LOGICAL               :: FBS_WANTED

        LOGICAL               :: MIRRORNEW
        LOGICAL               :: GOTREFANG,LIMITRANGE

        INTEGER, PARAMETER    :: NLISTMAX = 15
        REAL                  :: PARLIST(NLISTMAX)
        LOGICAL               :: ANGINHEADER  

        INCLUDE 'mpif.h'

        INTEGER               :: MYPID, COMM, MPIERR, NPROCS
        INTEGER               :: NEXPLOC, NREM
        INTEGER               :: IPROC, ISAM, JROW, JLOC, ILOC
        INTEGER               :: TAG,TI, IMIT,IGLB, IBEG,IEND
        INTEGER               :: ISTAT(MPI_STATUS_SIZE)

C       AUTOMATIC ARRAYS
        REAL                  :: ANGOUT(3)

C       ALLOCATED ARRAYS
        REAL,    ALLOCATABLE  :: DLIST (:,:) 
        REAL,    ALLOCATABLE  :: REFDIR(:,:),EXPDIR(:,:) 
        REAL,    ALLOCATABLE  :: ANGREF(:,:),ANGEXP(:,:)
	REAL,    ALLOCATABLE  :: TMPBUF(:,:)
        REAL,    ALLOCATABLE  :: ALOC(:,:,:)
        REAL,    ALLOCATABLE  :: EXPBUF(:,:,:)
        REAL,    ALLOCATABLE  :: DLISTLOC(:,:)
        INTEGER, ALLOCATABLE  :: NPROJA(:)
        REAL,    ALLOCATABLE  :: PARTAB(:,:),PARTABLOC(:,:)
        INTEGER, ALLOCATABLE  :: NBASE(:), PSIZE(:)

#ifdef MPI_DEBUG
        DOUBLE PRECISION      :: TCOM1, TCOM2
#endif

        PARAMETER (QUADPI = 3.14159265358979323846)
        PARAMETER (DGR_TO_RAD =   (QUADPI/180))

        INTEGER, PARAMETER     :: LUNPIC  = 77
        INTEGER, PARAMETER     :: LUNANG  = 78
        INTEGER, PARAMETER     :: LUNRING = 50

        LOGICAL, PARAMETER     :: MPIBCAST = .FALSE.

        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID , MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
 
C       SET TYPE OF OUTPUT DOC FILES WANTED
        NWANTOUT = 7
        IF (CTYPE(1:2) == 'SH') NWANTOUT = 15

C       INITIALIZE CCROT STATISTICS COUNTERS
        ANGDIFTHR   = 0.0

C       INITIALIZE CCROT STATISTICS
        CALL AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
     &                   CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                   CCROTIMPROV,IWORSECCROT,CCROTWORSE)

        LIMITRANGE  = (RANGE > 0.0) 
        MAXRIN      = NUMR(3,NRING)
        RANGECOS    = COS(RANGE*DGR_TO_RAD)

C       FIND NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)
        CALL FLUSHRESULTS()

C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
        CALL APRINGS_NEW(IREFLIST,NUMREF,  NX,NY, 
     &               NRING,LCIRC,NUMR,MODE,FFTW_PLANS,
     &               REFPAT,LUNPIC,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)
 
        GOTREFANG = .FALSE.
        IF (LIMITRANGE .OR.  CTYPE(1:2) == 'SH') THEN
C          REFANGLES FILE FOR RESTRICTED ANGULAR SEARCH  OR 'SH'
	   ALLOCATE(REFDIR(3,NUMREF),
     &              ANGREF(3,NUMREF), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
               MWANT = 6*NUMREF  
               CALL ERRT(46,'APSH_PS; REFDIR, ANGREF',MWANT)
               RETURN
           ENDIF 

C          READ REF. ANGLES INTO ANGREF FROM HEADER OR DOC FILE
	   CALL AP_GETANGAS(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                      LUNPIC,LUNANG,3,ANGREF,GOTREFANG,NGOTREF,
     &                      .TRUE.,REFDIR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF

        NGOTPAR = 0
        IF (CTYPE(1:2) == 'RQ' .OR.
     &     (CTYPE(1:2) == 'SH' .AND. 
     &     EXPANGDOC .NE. CHAR(0))) THEN

           ALLOCATE(ANGEXP(8,NUMEXP), 
     &              EXPDIR(3,NUMEXP), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              MWANT = 11*NUMEXP 
              CALL ERRT(46,'APSH_PS; ANGEXP & EXPDIR',MWANT)
              RETURN
           ENDIF 

C          READ EXP. ANGLES INTO ANGEXP
C          CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS(EXPDIR).
           CALL AP_GETANGAS(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                      LUNPIC,LUNANG,8,ANGEXP,NGOTPAR,GOTEXPANG,
     &                      .TRUE.,EXPDIR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

       ELSE
C          DUMMY ALLOCATE TO AVOID BUS ERROR ON SOME SYSTEMS
           ALLOCATE(ANGEXP(8,1), 
     &              EXPDIR(3,1), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              MWANT = 11*1 
              CALL ERRT(46,'APSH_PS; EXPDIR',MWANT)
              RETURN
           ENDIF 
       ENDIF

C       === PARTITION AND DISTRIBUTE EXPERIMENTAL IMAGES ===

        ALLOCATE(PSIZE(NPROCS),
     &           NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'APSH_PS; PSIZE & NBASE.',2*NPROCS)
           RETURN
        ENDIF

        CALL SETPART(NUMEXP, PSIZE, NBASE)
        NEXPLOC = PSIZE(MYPID+1)

        ALLOCATE(ALOC  (NX,NY,NEXPLOC),
     &           EXPBUF(NX,NY,PSIZE(1)), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MWANT = NX*NY*NEXPLOC + NX*NY*PSIZE(1)
           CALL ERRT(46,'APSH_PS; ALOC...',MWANT)
           RETURN
        ENDIF
        ALOC = 0.0

#ifdef MPI_DEBUG
        WRITE(6,111) NBASE(MYPID+1), MYPID
        CALL FLUSHFILE(6)
 111    FORMAT(' APSH_PS: NBASE = ', I5, ' MYPID = ', I5)
        TCOM0 = MPI_WTIME()
#endif

        ANGINHEADER = .FALSE. ! unfinished !!!!!!!!!!!
        IF (ROTFIRST) THEN
	   ALLOCATE(TMPBUF(NX,NY), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_PS; TMPBUF',NX*NY)
              GOTO 9999
           ENDIF
           anginheader = (expangdoc == '*') ! unfinished !!!!!!!!!!!
           IF (FBS_WANTED .AND. MYPID == 0) THEN
            WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH FBS INTERPOLATION'
           ELSE
           WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH QUAD INTERPOLATION'
           ENDIF
        ENDIF 


C       PROCESS 0 READS IMAGES & DISTRIBUTES TO DIFFERENT PROCESSORS. ===
        DO IPROC = 1, NPROCS
           NLOC = PSIZE(IPROC)

C          === CALCULATE THE GLOBAL INDEX ===

           IBEG = NBASE(IPROC) + 1
           IEND = NBASE(IPROC) + NLOC 

C          ALTHOUGH THE FOLLOWING IS CALLED BY ALL PROCESSORS,
C          ONLY ONE PROCESSOR (MYPID=0) READS IMAGES INTO EXPBUF
C          IT DOES NOT BROADCAST EXPBUF!

           IF (ROTFIRST) THEN
C             WANT TO ROTATE/SHIFT EXP IMAGES WHEN READING THEM
	      CALL AP_GETDATA_RTSQ(IEXPLIST,NUMEXP, 
     &                    NX,NY, NX,NY,0.0,
     &                    NUMTH,EXPPAT,LUNPIC, IBEG,IEND,
     &                    ANGINHEADER, ANGEXP, 
     &                    MPIBCAST, TMPBUF,EXPBUF,
     &                    .FALSE., ADUM, ADUM, FBS_WANTED,IRTFLG)
           ELSE
              CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                    NX,NY, NX,NY,0.0,
     &                    NUMTH,EXPPAT,LUNPIC, IBEG,IEND,
     &                    .FALSE., EXPBUF,
     &                    .FALSE., ADUM,ADUM,IRTFLG)
           ENDIF
           IF (IRTFLG .NE. 0) STOP

           IF (IPROC > 1) THEN
              IF (MYPID == 0) THEN
#ifdef MPI_DEBUG
                 WRITE(6,222) IPROC-1
                 CALL FLUSHFILE(6)
 222             FORMAT(' APSH_PS: SENDING TO PID = ', I3)
#endif
                 CALL MPI_SEND(EXPBUF   , NX*NY*NLOC, MPI_REAL,
     &                         IPROC-1, IPROC-1       , COMM    ,
     &                         MPIERR)

              ELSEIF (MYPID == IPROC-1) THEN

C                === SLAVES RECEIVE LOCAL PIECES ===

                 CALL MPI_RECV(ALOC , NX*NY*NLOC, MPI_REAL,
     &                         0    , MPI_ANY_TAG   , COMM    ,
     &                         ISTAT, MPIERR)
                 IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) ' RECV FAILED'
                     STOP
                 ENDIF
#ifdef MPI_DEBUG
                 WRITE(6,223) MYPID
                 CALL FLUSHFILE(6)
 223             FORMAT(' APSH_PS: RECEIVED BY MYPID = ', I3)
#endif
              ENDIF
           ELSEIF (MYPID == 0) THEN  

C             === SIMPLY COPY FROM EXPBUF TO ALOC ===
              DO JLOC = 1, NLOC
                 DO ISAM = 1, NX
                    DO JROW = 1, NY
                       ALOC(ISAM,JROW,JLOC) = EXPBUF(ISAM,JROW,JLOC)
                    ENDDO
                 ENDDO
              ENDDO
           ENDIF
        ENDDO

        IF (ALLOCATED(EXPBUF)) DEALLOCATE(EXPBUF)
        IF (ALLOCATED(TMPBUF)) DEALLOCATE(TMPBUF)

        ALLOCATE(PARTAB(15,NUMEXP), 
     &           PARTABLOC(15,NEXPLOC),
     &           DLISTLOC(5,NEXPLOC),
     &           NPROJA(NEXPLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MWANT = 15*NUMEXP + 15*NEXPLOC + 6*NEXPLOC
           CALL ERRT(46,'APSH_PS; PARTAB..',MWANT)
           RETURN
        ENDIF

#ifdef MPI_DEBUG
        TCOM1 = MPI_WTIME()
        IF (MYPID == 0) WRITE(6,440) TCOM1-TCOM0
 440    FORMAT(' APSH_PS: DATA DIST TIME = ', 1PE11.3)
        WRITE(6,444) MYPID
 444    FORMAT(' APSH_PS: CALLING APRQ2D.., MYPID = ', I3)
#endif

        PARTAB     = 0.0
        PARTABLOC = 0.0

        DO  IT=1,NEXPLOC
           IGLB = NBASE(MYPID+1) + IT
           CALL APRQ2D(ALOC(1,1,IT),CIRCREF,NUMR,
     &              NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &              LCIRC,NRING,NUMREF,MODE,
     &              REFDIR,EXPDIR(1,IGLB),RANGECOS,
     &              DLISTLOC(1,IT),DLISTLOC(2,IT),
     &              DLISTLOC(3,IT),DLISTLOC(4,IT),
     &              DLISTLOC(5,IT),NPROJA(IT),
     &              CKMIRROR,LIMITRANGE, FFTW_PLANS)

C          OUTPUT IN DLISTLOC
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX SHIFT
C          5 - SY SHIFT
 
           IMGEXP = IEXPLIST(IGLB)
 
C          DLISTLOC(1,IT) IS LIST NUMBER OF MOST SIMILAR REF. IMAGE
C              (<0 IF MIRRORED, 0 IF NONE )
 
           IREF = INT(DLISTLOC(1,IT))
           IF (IREF < 0) THEN
C             MIRRORED REFERENCE IMAGE
              IMGREF = IREFLIST(-IREF)
 
C             IREFT IS FOR REFDIR INDEX
              IREFT     = -IREF
              MIRRORNEW = .TRUE.
 
           ELSEIF (IREF == 0) THEN
C             NO NEARBY REFERENCE IMAGE
              IMGREF = 0
 
C             IREFT IS FOR REFDIR INDEX
              IREFT  = 1
              MIRRORNEW = .FALSE.
 
           ELSE
              IMGREF = IREFLIST(IREF)
C             IREFT IS FOR REFDIR INDEX
              IREFT  = IREF
              MIRRORNEW = .FALSE.
           ENDIF
 
           CCROT     = DLISTLOC(2,IT)
           RANGNEW   = DLISTLOC(3,IT)
           XSHNEW    = DLISTLOC(4,IT)
           YSHNEW    = DLISTLOC(5,IT)
           NPROJ     = NPROJA(IT)
           PEAKV     = 1.0
 
           CALL AP_END(IGLB,IMGEXP,IMGREF,
     &             ANGREF(1,IREFT),REFDIR(1,IREFT),
     &             ANGEXP(1,IGLB), EXPDIR(1,IGLB),ISHRANGEX,
     &             GOTREFANG, NGOTPAR, CCROT,PEAKV,
     &             RANGNEW,XSHNEW,YSHNEW,MIRRORNEW, REFPAT,
     &             NPROJ, CTYPE,  LUNDOC, PARTABLOC(1,IT))
        ENDDO
C
        DO IPROC = 1, NPROCS
           PSIZE(IPROC) = 15 * PSIZE(IPROC)
           NBASE(IPROC) = 15 * NBASE(IPROC)
        ENDDO
        CALL MPI_ALLGATHERV(PARTABLOC, PSIZE(MYPID+1),
     &                      MPI_REAL, PARTAB, PSIZE, NBASE,
     &                      MPI_REAL, COMM  , MPIERR)

C       WRITE HAS BEEN SYNCHRONIZED WITHIN LUNDOCWRTDAT

        IF (NWANTOUT > 7) THEN
           IF (LUNDOC > 0) THEN
C             SAVE IN ALIGNMENT DOC FILE

C             <,<,<, MIR-REF#,IMG#,INPLANE<, SX,SY,NPROJ,DIF,CCROT,INPLANE<,SX,SY

              DO IT = 1, NUMEXP
                 CALL LUNDOCWRTDAT(LUNDOC,IT,PARTAB(1,IT),
     &                             NWANTOUT,IRTFLG)
              ENDDO
           ENDIF
        ELSE
           IF (LUNDOC >. 0) THEN
C             SAVE IN ALIGNMENT DOC FILE
C             MIR-REF#, CCROT, INPLANE<, SX,SY, IMG#, < DIFF
              DO IT = 1, NUMEXP
                 CALL LUNDOCWRTDAT(LUNDOC,IT,PARTAB(1,IT),
     &                             NWANTOUT,IRTFLG)
              ENDDO
           ENDIF
        ENDIF
9999    CONTINUE


C       DEALLOCATE  ARRAYS
        IF (ALLOCATED(ALOC))       DEALLOCATE(ALOC)
        IF (ALLOCATED(PSIZE))      DEALLOCATE(PSIZE)
        IF (ALLOCATED(NBASE))      DEALLOCATE(NBASE)
        IF (ALLOCATED(NPROJA))     DEALLOCATE(NPROJA)
        IF (ALLOCATED(DLISTLOC))   DEALLOCATE(DLISTLOC)
        IF (ALLOCATED(PARTAB))     DEALLOCATE(PARTAB)
        IF (ALLOCATED(PARTABLOC))  DEALLOCATE(PARTABLOC)
        IF (ALLOCATED(REFDIR))     DEALLOCATE(REFDIR)
        IF (ALLOCATED(ANGEXP))     DEALLOCATE(ANGEXP)
        IF (ALLOCATED(ANGREF))     DEALLOCATE(ANGREF)

        END
C ------------------------- END OF MPI CODE -----------------------
#endif






C+**********************************************************************
C
C APRQ2D.F
C 
C  PARAMETERS:
C                DIREF    NUMBER OF  MOST SIMILAR REF. PROJ.  (OUTPUT)
C                            (NEGATIVE IF MIRRORED)
C                CCROT    CORR COEFF.                         (OUTPUT)
C                RANGNEW  INPLANE ANGLE                       (OUTPUT)
C                XSHSUM   SHIFT                               (OUTPUT)
C                YSHSUM   SHIFT                               (OUTPUT)
C                NPROJ                                        (OUTPUT)
C
C-**********************************************************************

	SUBROUTINE APRQ2D(EXPBUF,CIRCREF,NUMR,
     &	             NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &	             LCIRC,NRING,NUMREF,MODE,
     &               REFDIR,EXPDIR,RANGECOS,
     &               DIREF,CCROT,RANGNEW,XSHSUM,YSHSUM,NPROJ,
     &               CKMIRROR,LIMITRANGE,FFTW_PLANS)

C       NOTE: RUNS WITHIN OMP PARALLEL SECTION OF CODE IF NOT UNDER MPI!

        INCLUDE 'MAKE_CLOSE_LIST.INC'  

	REAL                      :: EXPBUF(NX,NY)
        REAL                      :: CIRCREF(LCIRC,NUMREF)
        INTEGER                   :: NUMR(3,NRING) 

	DOUBLE PRECISION          :: FITP(-1:1,-1:1)
        CHARACTER (LEN=1)         :: MODE
	REAL                      :: REFDIR(3,NUMREF), EXPDIR(3)
        INTEGER *8                :: FFTW_PLANS(*)

C       AUTOMATIC ARRAYS
	DOUBLE PRECISION          :: FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
	REAL                      :: ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)

C       ALLOCATABLE ARRAYS
        INTEGER, POINTER          :: LCG(:)
        REAL, ALLOCATABLE         :: CIRCEXP(:)

	DOUBLE PRECISION          :: CCROTD,PEAK,CCROTD_INTERP
	DOUBLE PRECISION          :: CCOA
        LOGICAL                   :: CKMIRROR,LIMITRANGE
        LOGICAL                   :: MIRRORED
        LOGICAL                   :: ISMIRRORED,USE_UN,USE_MIR
        REAL                      :: ADUM

        LOGICAL, PARAMETER        :: USE_OMP = .FALSE.

        REAL, PARAMETER           :: QUADPI = 3.1415926535
        REAL, PARAMETER           :: DGR_TO_RAD = (QUADPI/180)


        PEAK   = 0.0
        WR     = 0.0    ! DUMMY VALUE FLAG FOR APRINGS CALL

        MAXRIN = NUMR(3,NRING)   ! ACTUAL LENGTH OF LONGEST RING
#ifdef SP_LIBFFTW3
        MAXRIN = NUMR(3,NRING) - 2
#endif

	ALLOCATE(CIRCEXP(LCIRC),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'APRQ2D; CIRCEXP',LCIRC)
           RETURN
        ENDIF

        IEND  = NUMREF

C       write(6,*) 'numref,range: ',numref,rangecos,'expdir: ',expdir

C       IF LIMITRANGE, MAKE LIST OF CLOSE REF. IMAGES, RETURNS: NPROJ
        CALL MAKE_CLOSE_LIST(NUMREF,LIMITRANGE,
     &                       REFDIR,EXPDIR,
     &                       RANGECOS, CKMIRROR, 
     &                       LCG, NPROJ, IRTFLG)

	IF (NPROJ .LE. 0) THEN
C          THERE IS NO REFERENCE WITHIN SEARCH RANGE
           XSHSUM  = 0
	   YSHSUM  = 0
           DIREF   = 0
           RANGNEW = 0
           CCROT   = -1.0 
           GOTO 9999	
        ENDIF
        IEND = NPROJ

	CCROTD = -HUGE(CCROTD)

c       GO THROUGH CENTERS FOR SHIFT ALIGNMENT ------------------------
	DO JT=-ISHRANGEY,ISHRANGEY,ISTEP
	   CNR2 = NY / 2 + 1 + JT

	   DO IT=-ISHRANGEX,ISHRANGEX,ISTEP
	      CNS2 = NX / 2 + 1 + IT

C             NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE RANGE
C             INTERPOLATE TO POLAR COORD., CREATE FOURIER OF: A_CIRC
C             NO WEIGHTING OF RINGS
              !write(6,*) ' aprings one:,',jt,it,cns2,cnr2

	      CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, EXPBUF,.FALSE.,
     &                             MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                             CIRCEXP,IRTFLG)

C             COMPARE EXP. IMAGE WITH ALL REFERENCE IMAGES ------------
	      DO IRR=1,IEND
                 IR = IRR
                 IF (LIMITRANGE) IR = ABS(LCG(IRR))
                
                 IF (CKMIRROR .AND. LIMITRANGE) THEN
C                   ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                    USE_UN  = (LCG(IRR) .GE. 0)
                    USE_MIR = (LCG(IRR) .LT. 0)
                 ELSE
C                   SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
                    USE_UN  = .TRUE.
                    USE_MIR = CKMIRROR
                 ENDIF

	         CALL CROSRNG_2(CIRCREF(1,IR),CIRCEXP,
     &                          LCIRC,NRING, MAXRIN,NUMR, 
     &                          USE_OMP,FFTW_PLANS(1),
     &                          USE_UN,USE_MIR,
     &                          ISMIRRORED,CCOA,RANGO)

                 IF (CCOA .GE. CCROTD)  THEN
C                   BETTER MATCH WITH THIS POSITION 
	            CCROTD  = CCOA
	            IBE     = IR
	            ISX     = IT
	            ISY     = JT
	            RANGNEW = ANG_N(RANGO,MODE,MAXRIN)
	            IDIS    = IR
                    IF (ISMIRRORED) IDIS = -IR
	         ENDIF

	      ENDDO ! END OF:  DO IRR=1,IEND ---------------------- REFS.
	   ENDDO    ! END OF:  DO IT=-ISHRANGEX,ISHRANGEX,ISTEP
	ENDDO       ! END OF:  DO JT=-ISHRANGEY,ISHRANGEY,ISTEP

        SX       = ISX              ! BEST SHIFTS
        SY       = ISY
        CCROT    = CCROTD           ! BEST ROTATION

#ifdef NEVER
        write(6,921) idis,isx,isy,ccrotd,rangnew
921     format(' 1 ',i5,' (',i3,',',i3,'): ',f12.4,' ',2f8.2,f6.1)
#endif
       
C       CHECK LOCATIONS WITHIN ISHRANGE AROUND MAX  ------------------
        DIREF  = IDIS
C       WHEN (IDIS .LT. 0)  CHECK MIRRORED ONLY
        MIRRORED = (IDIS .LT. 0)

C       DO NOT INTERPOLATE FOR POINT ON THE EDGE
        IF (IABS(ISX).NE.ISHRANGEX .AND. IABS(ISY).NE.ISHRANGEY) THEN
C          NOT ON BOUNDARY, HAVE TO FIND NEIGHBOURING VALUES

	   FIT(0,0)   = CCROTD
           ROTMP(0,0) = RANGNEW

           DO JT=-ISTEP,ISTEP
	      CNR2 = NY / 2 + 1 + JT + ISY
	      DO IT=-ISTEP,ISTEP
	         CNS2 = NX / 2 + 1 + IT + ISX

   	         IF (IT.NE.0 .OR. JT.NE.0) THEN
C                   NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE RANGE
C                   INTERPOLATE INTO POLAR COORDINATES
C                   CREATES FOURIER OF: CIRCEXP

                    !!write(6,*) ' aprings max:,',jt,it,cns2,cnr2
 
	            CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, 
     &                           EXPBUF,.FALSE.,
     &                           MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                           CIRCEXP,IRTFLG)

	            CALL CROSRNG_2(CIRCREF(1,IBE),CIRCEXP,
     &                          LCIRC,NRING, MAXRIN,NUMR, 
     &                          USE_OMP,FFTW_PLANS(1),
     &                          .NOT. MIRRORED,MIRRORED,
     &                          ISMIRRORED,FIT(IT,JT),ROTMP(IT,JT))

C                   RECORD BEST ANGLE IN ROTMP
                    ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODE,MAXRIN)

                 ENDIF  ! END OF:  IF (IT.NE.0 .OR. JT.NE.0)
	      ENDDO     ! END OF:  DO IT=-ISTEP,ISTEP
           ENDDO        ! END OF:  DO JT=-ISTEP,ISTEP

#ifdef NEVER
          fit(it,jt) = fit(it,jt) 
          write(6,961) it,jt, fit(it,jt),cns2,cnr2, rotmp(it,jt)
961       format(' fit(',i2,',',i2,') : ',f12.4,' ',2f8.2,f6.1)
#endif


C          FIND THE MAXIMUM CC ANGLE WITHIN +/-ISTEP
C          MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP

	   AFIT     = FIT(0,0)
	   JTMA     = 0
	   ITMA     = 0
           RANGNEWT = ROTMP(0,0)

	   IF (ISTEP > 1)  THEN
	      DO JT=-ISTEP+1,ISTEP-1
	         DO IT=-ISTEP+1,ISTEP-1
	            IF (FIT(IT,JT) > AFIT)  THEN
	               AFIT     = FIT(IT,JT)
	               RANGNEWT = ROTMP(IT,JT) !compiler bug on OPT64
	               ITMA     = IT
	               JTMA     = JT
	            ENDIF
	         ENDDO  ! END OF:  DO IT=-ISTEP,ISTEP
              ENDDO     ! END OF:  DO JT=-ISTEP,ISTEP
           ENDIF

C          TEMP VARIABLE OVERCOMES COMPILER BUG ON OPT 64 PGI 6.0
           RANGNEW = RANGNEWT
           CCROTD  = AFIT
        
C          COPY VALUES AROUND THE PEAK.
           DO JT=-1,1
              DO IT=-1,1
                 FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
c                write(6,910) it,jt,fitp(it,jt)
910              format(' fitp(',i5,',',i5,') : ',f14.4)
              ENDDO
           ENDDO

C          UPDATE INTEGRAL LOCATION OF PEAK
	   ISX    = ISX + ITMA
	   ISY    = ISY + JTMA
           SX     = ISX
           SY     = ISY

#ifdef NEVER
	   cnr2 = NY / 2 + 1 + isy
           cns2 = NX / 2 + 1 + isx
           write(6,905) idis,isx,isy, ccrotd,rangnew, cns2,cnr2,sx,sy
905        format(' 2 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)
#endif

C          SUB-PIXEL INTERPOLATION -----------------------------------
           CALL PARABLD(FITP,SSX,SSY,PEAK)

	   IF (ABS(SSX) .LT. 1.0 .AND. ABS(SSY) .LT. 1.0)  THEN
C             NOT ON EDGE OF 3x3 INTERPOLATION AREA

	      CNS2 = NX/2+1 + SX + SSX
	      CNR2 = NY/2+1 + SY + SSY

C             NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE RANGE
C             INTERPOLATE INTO POLAR COORDINATES, 
C             CREATE FOURIER OF: CIRCEXP
              !write(6,*) ' aprings sub:,',sx,sy,cns2,cnr2
	      CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, EXPBUF,.FALSE.,
     &                           MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                           CIRCEXP,IRTFLG)

	      CALL CROSRNG_2(CIRCREF(1,IBE),CIRCEXP,
     &                       LCIRC,NRING, MAXRIN,NUMR, 
     &                       USE_OMP,FFTW_PLANS(1),
     &                      .NOT. MIRRORED,MIRRORED,
     &                       ISMIRRORED,CCROTD_INTERP,RANGNEW_INTERP)

#ifdef NEVER
	      rt1 = ang_n(rangnew_interp,mode,maxrin)
              write(6,904) idis,isx,isy, ccrotd_interp,rt1,
     &                     cns2,cnr2, sx+ssx,sy+ssy
904           format(' 3 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)
#endif

              IF (CCROTD_INTERP > CCROTD) THEN
C                USE SUB-PIXEL LOCATION
                 CCROTD  = CCROTD_INTERP
	         RANGNEW = ANG_N(RANGNEW_INTERP,MODE,MAXRIN)
	         SX      = SX + SSX 
	         SY      = SY + SSY 
              ENDIF
           ENDIF
        ENDIF

        CCROT = CCROTD
	SX    = -SX
	SY    = -SY
 
C       HAVE TO CHANGE ORDER OF SHIFT & ROTATION.
C       IN THIS PROGRAM IMAGE IS SHIFTED FIRST, ROTATED SECOND.
C       IN 'RT SQ' IT IS ROTATION FIRST, SHIFT SECOND.
C       THIS CODE CORRESPONDS TO 'SA P'.
	CO     =  COS(RANGNEW * DGR_TO_RAD)
	SO     = -SIN(RANGNEW * DGR_TO_RAD)
	XSHSUM = SX*CO - SY*SO
	YSHSUM = SX*SO + SY*CO
C       ALMOST ZERO IS LIKELY TO BE ZERO
        IF (ABS(XSHSUM)  .LT. 0.08) XSHSUM  = 0.0
        IF (ABS(YSHSUM)  .LT. 0.08) YSHSUM  = 0.0
        IF (ABS(RANGNEW) .LT. 0.08) RANGNEW = 0.0

#ifdef NEVER
        cns2 = NX / 2 + 1 - sx
        cnr2 = NY / 2 + 1 - sy
        write(6,906) idis,isx,isy, ccrotd,rangnew,
     &               cns2,cnr2, xshsum,yshsum
906     format(' 4 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)

        write(6,*) ' ------------------------------------- '
        write(6,*) '  '
#endif

9999    IF (ASSOCIATED(LCG))     DEALLOCATE(LCG)
        IF (ALLOCATED(CIRCEXP))  DEALLOCATE(CIRCEXP)
        NULLIFY(LCG)

	END

@


1.109
log
@undefined anginheader
@
text
@d39 1
a39 1
C=* Email: spider@@wadsworth.org                                        *
@


1.108
log
@logical FBS_WANTED
@
text
@d250 1
d567 1
@


1.107
log
@added rtsq call msg.
@
text
@d131 2
a132 1
        INTEGER                :: LUNDOC,FBS_WANTED
d413 2
a414 1
        INTEGER               :: LUNDOC,FBS_WANTED
@


1.106
log
@FBS_WANTED
/
@
text
@d256 5
d571 5
@


1.105
log
@typos fixed
@
text
@d32 1
d37 1
a37 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d109 1
a109 1
     &               CKMIRROR,CTYPE,LUNDOC)
d131 1
a131 1
        INTEGER                :: LUNDOC
d270 1
a270 1
     &                    .FALSE., ADUM, ADUM, IRTFLG)
d385 1
a385 1
     &               CKMIRROR,CTYPE,LUNDOC)
d407 1
a407 1
        INTEGER               :: LUNDOC
d589 1
a589 1
     &                    .FALSE., ADUM, ADUM, IRTFLG)
@


1.104
log
@renamed nsam,nrow,inpic,inang
added rotfirst support
many cosmetic in MPI
@
text
@d389 6
a394 2
        INTEGER               :: IREFLIST(NUMREF) 
        INTEGER,              :: IEXPLIST(NUMEXP) 
d396 2
a397 2
        REAL                  :: CIRCREF(LCIRC,NUMREF)
        LOGICAL               :: CIRCREF_IN_CORE
d401 1
d403 2
a405 1
	LOGICAL               :: ROTFIRST,CKMIRROR
a410 5
        INTEGER *8            :: FFTW_PLANS(*)

C       AUTOMATIC ARRAYS
        REAL                  :: ANGOUT(3)

d416 1
d420 1
a420 1
        INTEGER               :: TAG, MASTER,TI, IMIT,IGLB, IBEG,IEND
d423 3
d449 1
a449 1
        LOGICAL, PARAMETER  :: MPIBCAST = .FALSE.
a453 1
        MASTER = 0
d508 1
a508 1
              CALL ERRT(46,''APSH_PS; ANGEXP & EXPDIR',MWANT)
d525 1
a525 1
              CALL ERRT(46,''APSH_PS; EXPDIR',MWANT)
d639 2
a640 2
        IF (ALLOCATED(EXPBUF))  DEALLOCATE(EXPBUF)
        IF (ALLOCATED(TMPPBUF)) DEALLOCATE(TMPBUF)
@


1.103
log
@mpibcast T on getdata (not really used) for non-mpi
@
text
@d31 1
d65 1
a65 1
C       NSAM,NROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE     (SENT)
d81 1
d92 1
a92 1
C        ANOTHER SMALL ALLOCATED ARRAY IS: A(NSAM,NROW,NUMTH)
d104 1
a104 1
     &               NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d107 2
a108 1
     &               REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,LUNDOC)
d114 1
d116 3
a121 3
        LOGICAL                :: CKMIRROR
	LOGICAL                :: MIRRORNEW
	LOGICAL                :: GOTREFANG,LIMITRANGE
d125 1
d127 2
d130 1
a131 1
        INTEGER *8             :: FFTW_PLANS(*)
d137 1
a137 1
	REAL, ALLOCATABLE      :: A(:,:,:)
d142 1
d146 1
d148 10
d159 1
a162 6
        INTEGER                :: NBORDER = 0       ! # BORDER PIXELS
        INTEGER                :: NSUBPIX = 0       ! # SUBPIX PIXELS

        INTEGER, PARAMETER     :: INPIC   = 77
        INTEGER, PARAMETER     :: INANG   = 78
        INTEGER, PARAMETER     :: LUNRING = 50
d168 1
a168 1
        IF (CTYPE(1:2) .EQ. 'SH') NWANTOUT = 15
d176 1
a176 1
        LIMITRANGE  = (RANGE .GT. 0.0)
d186 1
a186 1
        CALL APRINGS_NEW(IREFLIST,NUMREF, NSAM,NROW,
d188 1
a188 1
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
d191 1
a191 1
	ALLOCATE(A(NSAM,NROW,NUMTH), 
d196 2
a197 2
           MWANT = NSAM*NROW*NUMTH + 6*NUMTH  
           CALL  ERRT(46,'APSH_PS; A & DLIST',MWANT)
d203 1
a203 1
        IF (LIMITRANGE .OR. CTYPE(1:2) .EQ. 'SH') THEN
d210 1
a210 1
               RETURN
d215 1
a215 1
     &                      INPIC,INANG,3,ANGREF,GOTREFANG,NGOTREF,
d221 3
a223 2
        IF ((CTYPE(1:2) .EQ. 'SH' .AND. EXPANGDOC .NE. CHAR(0))) THEN
	   ALLOCATE(ANGEXP(8,NUMEXP), EXPDIR(3,NUMEXP), STAT=IRTFLG)
d227 1
a227 1
              RETURN
d233 1
a233 1
     &                      INPIC,INANG,8,ANGEXP,GOTEXPANG,NGOTPAR,
d239 2
a240 1
	   ALLOCATE(ANGEXP(8,1), EXPDIR(3,1), STAT=IRTFLG)
d244 1
a244 1
              RETURN
d248 9
d262 13
a274 4
	   CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                    NSAM,NROW, NSAM,NROW,0.0,
     &                    NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                    .TRUE., A,
d276 1
d283 2
a284 2
	      CALL APRQ2D(A(1,1,IT),CIRCREF,NUMR,
     &	            NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d317 1
a317 1
              ELSEIF (IREF .EQ. 0) THEN
d353 1
a353 1
        IF (LUNDOC .GT. 0) THEN
d367 1
a367 1
	IF (ALLOCATED(A))          DEALLOCATE(A)
d380 1
a380 1
     &               NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d383 2
a384 1
     &               REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,LUNDOC)
d389 12
a400 12
        INTEGER, DIMENSION(NUMREF)             :: IREFLIST 
        INTEGER, DIMENSION(NUMEXP)             :: IEXPLIST 
        INTEGER, DIMENSION(3,NRING)            :: NUMR
        REAL, DIMENSION(LCIRC,NUMREF)          :: CIRCREF
        LOGICAL                                :: CIRCREF_IN_CORE
        LOGICAL                                :: CKMIRROR,MIRRORNEW
        LOGICAL                                :: GOTREFANG,LIMITRANGE
        CHARACTER (LEN=1)                      :: MODE
        CHARACTER (LEN=*)                      :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)                      :: SCRFILE
        CHARACTER (LEN=*)                      :: REFPAT,EXPPAT 
        CHARACTER (LEN=*)                      :: CTYPE
d402 4
a405 1
        INTEGER *8                             :: FFTW_PLANS(*)
d408 12
a419 1
        REAL, DIMENSION(3)                     :: ANGOUT
d422 10
a431 4
        REAL, ALLOCATABLE, DIMENSION(:,:,:)    :: A
        REAL, ALLOCATABLE, DIMENSION(:,:)      :: DLIST 
        REAL, ALLOCATABLE,DIMENSION(:,:)       :: REFDIR,EXPDIR 
        REAL, ALLOCATABLE,DIMENSION(:,:)       :: ANGREF,ANGEXP
d433 3
a435 2
        INTEGER, PARAMETER                     :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)              :: PARLIST
d440 10
a449 21
        DATA  INPIC/77/,INANG/78/,NSCF/50/
 
        include 'mpif.h'
        integer  mypid, comm, mpierr, nprocs, nexploc, nrem
        integer  istat(mpi_status_size)
        real   , allocatable, dimension(:,:,:) :: aloc
        real   , allocatable, dimension(:,:,:) :: abuf
        real   , allocatable, dimension(:,:)   :: DLISTLOC
        integer, allocatable, dimension(:)     :: NPROJA
        real   , allocatable, dimension(:,:)   :: partab,partabloc
        integer, allocatable, dimension(:)     :: nbase, psize
        integer  iproc, isam, jrow, jloc, iloc, tag, master,
     &           iti, imit, iglb, ibeg, iend
#ifdef MPI_DEBUG
        double precision tcom1, tcom2
#endif
c
        comm = mpi_comm_world
        call mpi_comm_rank(comm, mypid , mpierr)
        call mpi_comm_size(comm, nprocs, mpierr)
        master = 0
d453 1
a453 1
        IF (CTYPE(1:2) .EQ. 'SH') NWANTOUT = 15
d463 1
a463 1
        LIMITRANGE  = (RANGE .GT. 0.0) 
d472 1
a472 1
        CALL APRINGS_NEW(IREFLIST,NUMREF,  NSAM,NROW, 
d474 2
a475 2
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
     &               NSCF,SCRFILE,IRTFLG)
d478 1
a478 1
        IF (LIMITRANGE .OR. CTYPE(1:2) .EQ. 'SH') THEN
d490 1
a490 1
     &                      INPIC,INANG,3,ANGREF,GOTREFANG,NGOTREF,
d496 2
a497 2
        IF (CTYPE(1:2) .EQ. 'RQ' .OR.
     &     (CTYPE(1:2) .EQ. 'SH' .AND. 
d500 2
a501 1
           ALLOCATE(ANGEXP(8,NUMEXP), EXPDIR(3,NUMEXP), STAT=IRTFLG)
d504 1
a504 1
              CALL ERRT(46,'ANGEXP....',MWANT)
d511 1
a511 1
     &                      INPIC,INANG,8,ANGEXP,NGOTPAR,GOTEXPANG,
d517 2
a518 1
           ALLOCATE(ANGEXP(8,1), EXPDIR(3,1), STAT=IRTFLG)
d520 2
a521 2
              MWANT = 10*1 
              CALL ERRT(46,'ANGEXP....',MWANT)
d531 1
a531 1
           WRITE(6,*) 'APSH_PS: FAILED TO ALLOCATE PSIZE & NBASE'
d538 2
a539 2
        ALLOCATE(ALOC(NSAM,NROW,NEXPLOC),
     &           ABUF(NSAM,NROW,PSIZE(1)),STAT=IRTFLG)
d541 2
a542 1
           WRITE(6,*) ' APSH_PS: FAILED TO ALLOCATE ABUF & ALOC'
d554 10
d574 18
a591 7
C          ONLY ONE PROCESSOR (MYPID=0) READS IMAGES INTO ABUF
C          IT DOES NOT BROADCAST ABUF!
           CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                     NSAM,NROW,NSAM,NROW,0.0,
     &                     NUMTH,EXPPAT,INPIC, IBEG,IEND,
     &                     .FALSE., ABUF,
     &                     .FALSE.,ADUM,ADUM,IRTFLG)
d594 2
a595 2
           IF (IPROC .GT. 1) THEN
              IF (MYPID .EQ. 0) THEN
d601 1
a601 1
                 CALL MPI_SEND(ABUF   , NSAM*NROW*NLOC, MPI_REAL,
d604 2
a605 1
              ELSE IF (MYPID .EQ. IPROC-1) THEN
d609 1
a609 1
                 CALL MPI_RECV(ALOC , NSAM*NROW*NLOC, MPI_REAL,
d622 1
a622 1
           ELSE IF (MYPID .EQ. 0) THEN  
d624 1
a624 1
C             === SIMPLY COPY FROM ABUF TO ALOC ===
d626 3
a628 3
                 DO ISAM = 1, NSAM
                    DO JROW = 1, NROW
                       ALOC(ISAM,JROW,JLOC) = ABUF(ISAM,JROW,JLOC)
d634 3
a636 1
        IF (ALLOCATED(ABUF)) DEALLOCATE(ABUF)
d648 1
d651 1
a651 1
        IF (MYPID .EQ. 0) WRITE(6,440) TCOM1-TCOM0
d656 1
d663 1
a663 1
     &              NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d684 1
a684 1
           IF (IREF .LT. 0) THEN
d692 1
a692 1
           ELSEIF (IREF .EQ. 0) THEN
d732 2
a733 2
        IF (NWANTOUT .GT. 7) THEN
           IF (LUNDOC .GT. 0) THEN
d735 1
d737 1
d744 1
a744 1
           IF (LUNDOC .GT. 0) THEN
d793 1
a793 1
     &	             NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d803 1
a803 1
	REAL                      :: EXPBUF(NSAM,NROW)
d872 1
a872 1
	   CNR2 = NROW / 2 + 1 + JT
d875 1
a875 1
	      CNS2 = NSAM / 2 + 1 + IT
d882 1
a882 1
	      CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, EXPBUF,.FALSE.,
d944 1
a944 1
	      CNR2 = NROW / 2 + 1 + JT + ISY
d946 1
a946 1
	         CNS2 = NSAM / 2 + 1 + IT + ISX
d955 1
a955 1
	            CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, 
d988 1
a988 1
	   IF (ISTEP .GT. 1)  THEN
d991 1
a991 1
	            IF (FIT(IT,JT) .GT. AFIT)  THEN
d1021 2
a1022 2
	   cnr2 = nrow / 2 + 1 + isy
           cns2 = nsam / 2 + 1 + isx
d1033 2
a1034 2
	      CNS2 = NSAM/2+1 + SX + SSX
	      CNR2 = NROW/2+1 + SY + SSY
d1040 1
a1040 1
	      CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, EXPBUF,.FALSE.,
d1057 1
a1057 1
              IF (CCROTD_INTERP .GT. CCROTD) THEN
d1085 2
a1086 2
        cns2 = nsam / 2 + 1 - sx
        cnr2 = nrow / 2 + 1 - sy
@


1.102
log
@AP_GETDATA --> AP_GETDAT, AP_GETDAT1P--> AP_GETDATA
@
text
@d240 1
a240 1
     &                    .FALSE., A,
@


1.101
log
@IF (ASSOCIATED(LCG))     DEALLOCATE(LCG)
@
text
@d30 1
d138 1
d237 2
a238 1
	   CALL AP_GETDAT(IEXPLIST,NUMEXP,NSAM,NROW,NSAM,NROW,
d240 2
a241 2
     &                    1,NROW,1,NSAM, A,
     &                    IRTFLG)
d516 6
a521 4

           CALL AP_GETDAT1P(IEXPLIST,NUMEXP,NSAM,NROW,NSAM,NROW,
     &                      NUMTH,EXPPAT,INPIC, IBEG,IEND,
     &                      1,NROW,1,NSAM, ABUF,IRTFLG)
d748 1
@


1.100
log
@NULLIFY(LCG) added
@
text
@d1012 2
a1013 2
9999    IF (ALLOCATED(LCG))     DEALLOCATE(LCG)
        IF (ALLOCATED(CIRCEXP)) DEALLOCATE(CIRCEXP)
@


1.99
log
@ap_sh --> apsh in names, MAKE_CLOSE_LIST, '*' in refangdoc
@
text
@d1014 1
@


1.98
log
@renamed, allocated circexp
@
text
@d3 1
a3 1
C    AP_SH_PS.F     USED CMLIMIT                  AUG 00 ARDEAN LEITH
d52 1
a52 1
C  AP_SH_PS 
d54 1
a54 1
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
d56 1
a56 1
C           USED IF:  CIRCREF_IN_CORE .AND. NUMEXP .GE. NUMTH 
d59 23
a81 9
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NUMREF              NO. OF IMAGES                     (INPUT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NUMEXP              NO. OF IMAGES                     (INPUT)
C       NSAM,NROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
C       EXPANGDOC           EXP. ANGLES FILE NAME             (INPUT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
d83 2
a84 1
C NOTE:  IF USING AP_SH_PS, MOST MEMORY DEMAND APPEARS TO BE DEPENDENT 
d100 1
a100 1
       SUBROUTINE AP_SH_PS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d109 13
a121 13
	INTEGER, DIMENSION(NUMREF)             :: IREFLIST 
	INTEGER, DIMENSION(NUMEXP)             :: IEXPLIST 
        INTEGER, DIMENSION(3,NRING)            :: NUMR
	REAL, DIMENSION(LCIRC,NUMREF)          :: CIRCREF
	LOGICAL                                :: CIRCREF_IN_CORE
        LOGICAL                                :: CKMIRROR
	LOGICAL                                :: MIRRORNEW
	LOGICAL                                :: GOTREFANG,LIMITRANGE
        CHARACTER(LEN=1)                       :: MODE
        CHARACTER (LEN=*)                      :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)                      :: SCRFILE
        CHARACTER (LEN=*)                      :: REFPAT,EXPPAT 
        CHARACTER (LEN=*)                      :: CTYPE
d123 1
a123 1
        INTEGER *8                             :: FFTW_PLANS(*)
d126 1
a126 1
	REAL, DIMENSION(3)                     :: ANGOUT
d129 18
a146 11
	REAL, ALLOCATABLE, DIMENSION(:,:,:)    :: A
	INTEGER, ALLOCATABLE, DIMENSION(:)     :: NPROJA 
	REAL, ALLOCATABLE, DIMENSION(:,:)      :: DLIST 
	REAL, ALLOCATABLE,DIMENSION(:,:)       :: REFDIR,EXPDIR 
	REAL, ALLOCATABLE,DIMENSION(:,:)       :: ANGREF,ANGEXP

        INTEGER, PARAMETER                     :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)              :: PARLIST

	REAL, PARAMETER      :: QUADPI     = 3.14159265358979323846
	REAL, PARAMETER      :: DGR_TO_RAD =   (QUADPI/180)
a147 5
        INTEGER              :: NBORDER = 0       ! # BORDER PIXELS
        INTEGER              :: NSUBPIX = 0       ! # SUBPIX PIXELS

	DATA  INPIC/77/,INANG/78/,LUNRING/50/
 
d181 1
a181 1
           CALL  ERRT(46,'AP_SH_PS; A & DLIST',MWANT)
d193 1
a193 1
               CALL ERRT(46,'AP_SH_PS; REFDIR, ANGREF',MWANT)
a195 2
           GOTREFANG = .TRUE.

d197 4
a200 2
	   CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                    INPIC,INANG,3,ANGREF,NGOTREF,IRTFLG)
a201 3

C          CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
a205 2
C          READ EXP. ANGLES INTO ANGEXP

d209 1
a209 1
              CALL ERRT(46,'AP_SH_PS; ANGEXP....',MWANT)
d213 5
a217 2
	   CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                       INPIC,INANG,8,ANGEXP,NGOTPAR,IRTFLG)
a219 2
C          CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS(EXPDIR).
	   CALL AP_GETSATA(ANGEXP,EXPDIR,8,NUMEXP,IRTFLG)
d225 1
a225 1
              CALL ERRT(46,'AP_SH_PS; ANGEXP....',MWANT)
d341 1
a341 1
       SUBROUTINE AP_SH_PS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d431 1
a431 1
           ALLOCATE(REFDIR(3,NUMREF),
d433 1
a433 1
           IF (IRTFLG .NE. 0) THEN
d435 1
a435 1
               CALL ERRT(46,'REFDIR, ANGREF',MWANT)
a437 1
           GOTREFANG = .TRUE.
d439 4
a442 3
C          READ REF. ANGLES INTO ANGREF
           CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                    INPIC,INANG,3,ANGREF,NGOTREF,IRTFLG)
a443 3

C          CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
           CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
a449 1
C          READ EXP. ANGLES INTO ANGEXP
d458 5
a462 2
           CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                       INPIC,INANG,8,ANGEXP,NGOTPAR,IRTFLG)
a464 2
C          CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS(EXPDIR).
           CALL AP_GETSATA(ANGEXP,EXPDIR,7,NUMEXP,IRTFLG)
d480 1
a480 1
           WRITE(6,*) 'AP_SH_PS: FAILED TO ALLOCATE PSIZE & NBASE'
d490 1
a490 1
           WRITE(6,*) ' AP_SH_PS: FAILED TO ALLOCATE ABUF & ALOC'
d498 1
a498 1
 111    FORMAT(' AP_SH_PS: NBASE = ', I5, ' MYPID = ', I5)
d524 1
a524 1
 222             FORMAT(' AP_SH_PS: SENDING TO PID = ', I3)
d543 1
a543 1
 223             FORMAT(' AP_SH_PS: RECEIVED BY MYPID = ', I3)
d567 1
a567 1
           CALL ERRT(46,'AP_SH_PS; PARTAB..',MWANT)
d573 1
a573 1
 440    FORMAT(' AP_SH_PS: DATA DIST TIME = ', 1PE11.3)
d575 1
a575 1
 444    FORMAT(' AP_SH_PS: CALLING APRQ2D.., MYPID = ', I3)
d719 2
d735 1
a735 1
        INTEGER, ALLOCATABLE      :: LCG(:)
a764 11
        IF (.NOT. LIMITRANGE) THEN
C          DUMMY ALLOCATE TO AVOID BUS ERROR ON SOME SYSTEMS
	   ALLOCATE(LCG(1),STAT=IRTFLG)
           NPROJ = NUMREF
        ELSE
C          RESTRICTED RANGE SEARCH
	   ALLOCATE(LCG(NUMREF),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL  ERRT(46,'APRQ2D; LCG',NUMREF)
              GOTO 9999
           ENDIF
d766 1
a766 26
C          MAKE LIST OF NEARBY REFERENCE IMAGES
	   NPROJ = 0
C          write(6,*) 'numref,range: ',numref,rangecos,'expdir: ',expdir

	   DO IREF=1,NUMREF 
C             DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED
	      DT    = (EXPDIR(1) * REFDIR(1,IREF) + 
     &                 EXPDIR(2) * REFDIR(2,IREF) +
     &                 EXPDIR(3) * REFDIR(3,IREF))
	      DTABS = ABS(DT)

              IF (DTABS .GE. RANGECOS)  THEN
C                MIRRORED OR NON-MIRRORED IS WITHIN RANGE

                 IF (CKMIRROR .OR. DT .GT. 0) THEN
C                   DO NOT DISCARD IF NOT MIRRORED OR WANT MIRRORED
	            NPROJ      = NPROJ + 1
	            LCG(NPROJ) = IREF
                    IF (DT .LT. 0) LCG(NPROJ) = -IREF

c                   if (mod(iref,50) .le. 0) then
c                   write(110,*)'in  iref: ',iref,' dt: ',dt,lcg(nproj)
c                   endif
                 ENDIF
              ENDIF
	   ENDDO
d768 16
a783 11
	   IF (NPROJ .LE. 0) THEN
C             THERE IS NO REFERENCE WITHIN SEARCH RANGE
              XSHSUM  = 0
	      YSHSUM  = 0
              DIREF   = 0
              RANGNEW = 0
              CCROT   = -1.0 
              GOTO 9999	
           ENDIF
           IEND = NPROJ
        ENDIF     ! END OF RESTRICTED RANGE SEARCH
@


1.97
log
@AP_STAT NBORDER
@
text
@d3 1
a3 1
C    MRQLI_PS.F     USED CMLIMIT                  AUG 00 ARDEAN LEITH
d29 1
d34 1
a34 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d52 1
a52 1
C  MRQLI_PS 
d69 1
a69 1
C NOTE:  IF USING MRQLI_PS, MOST MEMORY DEMAND APPEARS TO BE DEPENDENT 
d85 1
a85 1
       SUBROUTINE MRQLI_PS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d164 1
a164 1
           CALL  ERRT(46,'A & DLIST',MWANT)
d176 1
a176 1
               CALL ERRT(46,'REFDIR, ANGREF',MWANT)
d197 1
a197 1
              CALL ERRT(46,'ANGEXP....',MWANT)
d212 1
a212 1
              CALL ERRT(46,'ANGEXP....',MWANT)
d328 1
a328 1
       SUBROUTINE MRQLI_PS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d470 1
a470 1
           WRITE(6,*) 'MRQLI_PS: FAILED TO ALLOCATE PSIZE & NBASE'
d480 1
a480 1
           WRITE(6,*) ' MRQLI_PS: FAILED TO ALLOCATE ABUF & ALOC'
d488 1
a488 1
 111    FORMAT(' MRQLI_PS: NBASE = ', I5, ' MYPID = ', I5)
d514 1
a514 1
 222             FORMAT(' MRQLI_PS: SENDING TO PID = ', I3)
d533 1
a533 1
 223             FORMAT(' MRQLI_PS: RECEIVED BY MYPID = ', I3)
d557 1
a557 1
           CALL ERRT(46,'MRQLI_PS; PARTAB..',MWANT)
d563 1
a563 1
 440    FORMAT(' MRQLI_PS: DATA DIST TIME = ', 1PE11.3)
d565 1
a565 1
 444    FORMAT(' MRQLI_PS: CALLING APRQ2D.., MYPID = ', I3)
a720 1
        REAL                      :: CIRCEXP(LCIRC)
d722 1
d724 1
d746 6
d761 2
a762 2
              CALL  ERRT(46,'LCG',NUMREF)
              RETURN
d799 1
a799 1
              RETURN	
d1031 2
a1032 1
9999    IF (ALLOCATED(LCG)) DEALLOCATE(LCG)
@


1.96
log
@CROSRNG_EP should not have been left in
@
text
@d28 1
d122 5
a126 2
	PARAMETER (QUADPI = 3.14159265358979323846)
	PARAMETER (DGR_TO_RAD =   (QUADPI/180))
d306 2
a307 1
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
@


1.95
log
@CROSRNG_2
/
@
text
@d186 1
a186 3
        IF (CTYPE(1:2) .EQ. 'RQ' .OR.
     &     (CTYPE(1:2) .EQ. 'SH' .AND. 
     &     EXPANGDOC .NE. CHAR(0))) THEN
a965 4

	      CALL CROSRNG_EP(CIRCREF(1,IBE),CIRCEXP,LCIRC,NRING,
     &		            MAXRIN,NUMR, CCROTD_INTERP,RANGNEW_INTERP, 
     &                      MIRRORED, FFTW_PLANS(1))
@


1.94
log
@CROSRNG_EP used
@
text
@d27 1
d722 1
a722 1
	DOUBLE PRECISION          :: CCOA,CCMA
d725 6
a731 2
	PARAMETER (QUADPI = 3.14159265358979323846)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
d816 4
a819 9
                 IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &               (.NOT. CKMIRROR)) THEN
                    IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
                    IF (LIMITRANGE)     MIRRORED = (LCG(IRR) .LT. 0) 
	            CALL CROSRNG_EP(CIRCREF(1,IR),CIRCEXP,
     &                         LCIRC,NRING, MAXRIN,NUMR, 
     &                         CCOA,RANGO, 
     &                         MIRRORED, FFTW_PLANS(1))

d821 3
a823 16
C                   CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	            CALL CROSRNG_MSP(CIRCREF(1,IR),CIRCEXP,
     &                         LCIRC,NRING,MAXRIN,NUMR, 
     &                         CCOA,RANGO, CCMA,RANGM,
     &                         FFTW_PLANS(1))

#ifdef NEVER
                 if(it .eq. -10 .and. jt .eq. -1 .and. ir .eq. 47)then
                    rt1 = ang_n(tot,mode,maxrin)
                    write(6,821) it,jt, tota,rt1
821                 format(' tota(',i3,',',i3,'): ',f14.4,' ',2f8.2)
                    rt1 = ang_n(tmt,mode,maxrin)
                    write(6,826) it,jt, tmta,rt1
826                 format(' tmta(',i3,',',i3,'): ',f14.4,' ',2f8.2)
                 endif
#endif
d826 5
d833 1
a833 1
C                   GOOD MATCH WITH CCOA (MIRRORED OR NOT) POSITION 
d840 1
a840 1
                    IF (LIMITRANGE .AND. (LCG(IRR) .LT. 0)) IDIS = -IR
a842 13
                 IF (CKMIRROR .AND. .NOT. LIMITRANGE) THEN 
C                   HAVE TO COMPARE WITH MIRRORED POSITION 
                    IF (CCMA .GE. CCROTD) THEN
C                      GOOD MATCH WITH MIRRORED POSITION 
	               CCROTD  = CCMA
	               IBE     = IR
	               ISX     = IT
	               ISY     = JT
	               RANGNEW =  ANG_N(RANGM,MODE,MAXRIN)
	               IDIS    = -IR
	            ENDIF
                 ENDIF

a843 1

d847 3
a849 3
        SX    = ISX
        SY    = ISY
        CCROT = CCROTD
a860 1

d885 5
a889 4
	            CALL CROSRNG_EP(CIRCREF(1,IBE),CIRCEXP,
     &                           LCIRC,NRING,MAXRIN,NUMR,
     &                           FIT(IT,JT),ROTMP(IT,JT),
     &                           MIRRORED, FFTW_PLANS(1))
d972 6
@


1.93
log
@GPL_2010
@
text
@d26 1
d60 1
a60 1
C       LSAM,LROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
d83 1
a83 1
     &               LSAM,LROW,NR,LENTT,ISHRANGEX,ISHRANGEY,ISTEP,
a107 1
	DOUBLE PRECISION, DIMENSION(LENTT)     :: TT
a136 1
   
d141 3
a143 4

C       FIND DIVAS, NUMTH, NSAM, & NROW
	CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                   TT,LENTT)
d147 1
a147 1
        CALL APRINGS_NEW(IREFLIST,NUMREF, LSAM,LROW,
a150 2
        NSAM = LSAM
        NROW = LROW
d152 1
a152 1
	ALLOCATE(A(LSAM,LROW,NUMTH), 
d157 1
a157 1
           MWANT = LSAM*LROW*NUMTH + 6*NUMTH  
d218 1
a218 1
	   CALL AP_GETDAT(IEXPLIST,NUMEXP,LSAM,LROW,LSAM,LROW,
d220 1
a220 1
     &                    1,LROW,1,LSAM, A,
d228 1
a228 1
	      CALL APRQ2D(A(1,1,IT),CIRCREF,TT,NUMR,
d324 1
a324 1
     &               LSAM,LROW,NR,LENTT,ISHRANGEX,ISHRANGEY,ISTEP,
a347 1
        DOUBLE PRECISION, DIMENSION(LENTT)     :: TT
d400 3
a402 3
C       FIND DIVAS, NUMTH, NSAM, & NROW
        CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                   TT,LENTT)
d405 1
a405 1
        CALL APRINGS_NEW(IREFLIST,NUMREF,  LSAM,LROW, 
d409 1
a409 3
        NSAM = LSAM
        NROW = LROW

d499 1
a499 1
           CALL AP_GETDAT1P(IEXPLIST,NUMEXP,LSAM,LROW,LSAM,LROW,
d501 1
a501 1
     &                      1,LROW,1,LSAM, ABUF,IRTFLG)
d567 1
a567 1
           CALL APRQ2D(ALOC(1,1,IT),CIRCREF,TT,NUMR,
d695 1
a695 1
	SUBROUTINE APRQ2D(EXPBUF,CIRCREF,TT,NUMR,
a708 1
	DOUBLE PRECISION          :: TT(*)
d815 1
a815 1
	            CALL CROSRNG_EP_NEW(CIRCREF(1,IR),CIRCEXP,
d818 1
a818 1
     &                         TT,MIRRORED, FFTW_PLANS(1))
d822 1
a822 1
	            CALL CROSRNG_MSP_NEW(CIRCREF(1,IR),CIRCEXP,
d825 1
a825 1
     &                         TT, FFTW_PLANS(1))
d908 1
a908 1
	            CALL CROSRNG_EP_NEW(CIRCREF(1,IBE),CIRCEXP,
d911 1
a911 1
     &                           TT,MIRRORED, FFTW_PLANS(1))
d991 1
a991 1
	      CALL CROSRNG_EP_NEW(CIRCREF(1,IBE),CIRCEXP,LCIRC,NRING,
d993 1
a993 2
     &                      TT,MIRRORED,
     &                      FFTW_PLANS(1))
@


1.92
log
@ALMOST ZERO IS LIKELY TO BE ZERO range
@
text
@d27 4
a30 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2010  Health Research Inc.                          *
d41 1
a41 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a42 1
C=*                                                                    *
d44 1
a44 1
C=* along with this program. If not, see <http://www.gnu.org/licenses> *       
@


1.91
log
@x & y shift now can be different
@
text
@d1034 3
a1036 3
        IF (ABS(XSHSUM)  .LT. 0.04) XSHSUM = 0.0
        IF (ABS(YSHSUM)  .LT. 0.04) YSHSUM = 0.0
        IF (ABS(RANGNEW) .LT. 0.04) RANGNEW = 0.0
@


1.90
log
@NEWMAX = .FALSE. removed
@
text
@d25 1
d29 1
a29 1
C=* Copyright 1985-2009  Health Research Inc.                          *
d82 1
a82 1
     &               LSAM,LROW,NR,LENTT,ISHRANGE,ISTEP,
d233 1
a233 1
     &	            NSAM,NROW,ISHRANGE,ISTEP,
d290 1
a290 1
     &                ANGEXP(1,IEXP), EXPDIR(1,IEXP),ISHRANGE,
d328 1
a328 1
     &               LSAM,LROW,NR,LENTT,ISHRANGE,ISTEP,
d575 1
a575 1
     &              NSAM,NROW,ISHRANGE,ISTEP,
d628 1
a628 1
     &             ANGEXP(1,IGLB), EXPDIR(1,IGLB),ISHRANGE,
d703 1
a703 1
     &	             NSAM,NROW,ISHRANGE,ISTEP,
d799 1
a799 1
	DO JT=-ISHRANGE,ISHRANGE,ISTEP
d802 1
a802 1
	   DO IT=-ISHRANGE,ISHRANGE,ISTEP
d874 2
a875 2
	   ENDDO    ! END OF:  DO IT=-ISHRANGE,ISHRANGE,ISTEP
	ENDDO       ! END OF:  DO JT=-ISHRANGE,ISHRANGE,ISTEP
d893 1
a893 1
        IF (IABS(ISX).NE.ISHRANGE .AND. IABS(ISY).NE.ISHRANGE) THEN
@


1.89
log
@MRQLI_PS; PARTAB..
@
text
@a795 1
        NEWMAX = .FALSE.
@


1.88
log
@nproj bug
@
text
@d558 1
a558 1
           CALL ERRT(46,MRQLI_PS; PARTAB..,MWANT)
@


1.87
log
@ngotpar for 8
@
text
@d24 1
a24 1
C
d26 5
a30 7
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
d32 1
a32 1
C=* This program is free software; you can redistribute it and/or      *
d37 1
a37 1
C=* This program is distributed in the hope that it will be useful,    *
d43 1
a43 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d51 1
d111 1
a118 1
        PARAMETER (NLIST=7)
d136 5
a140 3
        LIMITRANGE  = (RANGE .GT. 0.0 .AND. RANGE .LT. 360.0) 
        RANGE       = COS(RANGE*DGR_TO_RAD)
        NIMALCG     = NUMREF
d146 1
d156 2
a157 1
     &           DLIST(NLIST,NUMTH),  
d160 1
a160 1
           MWANT = LSAM*LROW*NUMTH + NLIST*NUMTH  
d164 1
a164 1
        DLIST = 0.0
d195 1
a195 1
              MWANT = 10*NUMEXP 
d205 1
a205 1
	   CALL AP_GETSATA(ANGEXP,EXPDIR,7,NUMEXP,IRTFLG)
d210 1
a210 1
              MWANT = 10  
d234 5
a238 6
     &              REFDIR,EXPDIR(1,IEXP),RANGE,
     &              DLIST(2,IT),DLIST(3,IT),
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),
     &              NIMALCG,CKMIRROR,LIMITRANGE,FFTW_PLANS)


d240 1
d242 2
a243 2
C          OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
d245 1
a245 1
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
a247 1
C          6 - INPUT IMAGE NUMBER.
d250 1
a250 2
              IT     = IEXP-IEXPT+1

d253 2
a254 2
C             DLIST(2,IT IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
C                 (<0 IF MIRRORED, 0 IF NONE )
d256 1
a256 1
              IREF      = INT(DLIST(2,IT))
d280 5
a284 4
              CCROT     = DLIST(3,IT)
              RANGNEW   = DLIST(4,IT)
              XSHNEW    = DLIST(5,IT)
              YSHNEW    = DLIST(6,IT)
d292 1
a292 1
     &                NIMALCG, CTYPE, LUNDOC,PARLIST)
d313 1
d340 1
a340 2
        LOGICAL                                :: CKMIRROR
        LOGICAL                                :: MIRRORNEW
d342 1
a342 1
        CHARACTER(LEN=1)                       :: MODE
a362 1
        PARAMETER (NLIST=7)
d374 1
d376 1
a376 1
        integer, allocatable, dimension(:) :: nbase, psize
d380 1
a380 1
        DOUBLE PRECISION TCOM1, TCOM2
d400 1
a400 1
        LIMITRANGE  = (RANGE .GT. 0.0 .AND. RANGE .LT. 360.0) 
d402 1
a402 2
        RANGE       = COS(RANGE*DGR_TO_RAD)
        NIMALCG     = NUMREF
d468 2
a469 1
        ALLOCATE(PSIZE(NPROCS),STAT=IRTFLG)
d471 1
a471 7
           WRITE(6,*) 'MRQLI_PS: FAILED TO ALLOCATE PSIZE'
           RETURN
        ENDIF

        ALLOCATE(NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           WRITE(6,*) 'MRQLI_PS: FAILED TO ALLOCATE NBASE'
d478 2
a479 1
        ALLOCATE(ALOC(NSAM,NROW,NEXPLOC),STAT=IRTFLG)
d481 1
a481 1
           WRITE(6,*) ' MRQLI_PS: FAILED TO ALLOCATE ALOC'
d483 1
a483 1
        END IF
d490 1
a491 9
C
C       === PROCESS 0 READS ALL IMAGES AND DISTRIBUTE
C           THEM TO DIFFERENT PROCESSORS. ===

        ALLOCATE(ABUF(NSAM,NROW,PSIZE(1)),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           WRITE(6,*) ' MRQLI_PS: FAILED TO ALLOCATE ABUF'
           RETURN
        ENDIF
d493 1
a493 3
#ifdef MPI_DEBUG
        TCOM0 = MPI_WTIME()
#endif
a538 1

a539 1

d543 1
a543 2
                         ALOC(ISAM,JROW,JLOC) 
     &                 = ABUF(ISAM,JROW,JLOC)
d551 5
a555 1
        ALLOCATE(DLISTLOC(7,NEXPLOC),STAT=IRTFLG)
d557 2
a558 1
           WRITE(6,*) ' MRQLI_PS: FAILED TO ALLOCATE DLISTLOC'
a567 6
        ALLOCATE(PARTAB(15,NUMEXP), PARTABLOC(15,NEXPLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'PARTAB',NUMEXP)
           RETURN
        ENDIF
d576 5
a580 4
     &              REFDIR,EXPDIR(1,IGLB),RANGE,
     &              DLISTLOC(2,IT),DLISTLOC(3,IT),
     &              DLISTLOC(4,IT),DLISTLOC(5,IT),DLISTLOC(6,IT),
     &              NIMALCG,CKMIRROR,LIMITRANGE, FFTW_PLANS)
d582 1
a582 1
C          OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
a587 1
C          6 - INPUT IMAGE NUMBER.
d591 1
a591 1
C          DLIST(2,IT IS LIST NUMBER OF MOST SIMILAR REF. IMAGE
d594 1
a594 1
           IREF      = INT(DLISTLOC(2,IT))
d618 5
a622 4
           CCROT     = DLISTLOC(3,IT)
           RANGNEW   = DLISTLOC(4,IT)
           XSHNEW    = DLISTLOC(5,IT)
           YSHNEW    = DLISTLOC(6,IT)
d630 1
a630 1
     &             NIMALCG, CTYPE,  LUNDOC, PARTABLOC(1,IT))
d634 2
a635 2
           PSIZE(IPROC) = 15*PSIZE(IPROC)
           NBASE(IPROC) = 15*NBASE(IPROC)
d669 1
a685 2


d697 1
a697 1
C                NIMALCG                                      (OUTPUT)
d704 2
a705 2
     &               REFDIR,EXPDIR,RANGE,
     &               DIREF,CCROT,RANGNEW,XSHSUM,YSHSUM,NIMALCG,
d728 1
a728 1
	DOUBLE PRECISION          :: TOTA,TMTA
d747 1
a754 1
C          write(6,*) 'range: ',range,'  nima:',nima
d757 4
a760 2
	   NIMALCG = 0
	   DO IMI=1,NUMREF 
d762 3
a764 3
	      DT    = (EXPDIR(1) * REFDIR(1,IMI) + 
     &                 EXPDIR(2) * REFDIR(2,IMI) +
     &                 EXPDIR(3) * REFDIR(3,IMI))
d767 1
a767 1
              IF (DTABS .GE. RANGE)  THEN
d772 7
a778 6
	            NIMALCG      = NIMALCG + 1
	            LCG(NIMALCG) = IMI
                    IF (DT .LT. 0) LCG(NIMALCG) = -IMI

C                   write(6,*) 'imi: ',imi,' dt: ',dt,' dtabs: ',dtabs, 
C     &             refdir(1,imi),refdir(2,imi),refdir(3,imi)
d783 1
a783 1
	   IF (NIMALCG .LE. 0) THEN
d792 1
a792 1
           IEND = NIMALCG
d794 1
a794 1
	
d806 1
a806 1
C             INTERPOLATE TO POLAR COORDINATES, CREATE FOURIER OF: A_CIRC
d808 2
d825 1
a825 1
     &                         TOTA,TOT, 
d831 3
a833 3
     &                                LCIRC,NRING,MAXRIN,NUMR, 
     &                                TOTA,TOT, TMTA,TMT,
     &                                TT, FFTW_PLANS(1))
a844 1

d848 3
a850 3
                 IF (TOTA .GE. CCROTD)  THEN
C                   GOOD MATCH WITH TOTA (MIRRORED OR NOT)  POSITION 
	            CCROTD  = TOTA
d854 1
a854 1
	            RANGNEW = ANG_N(TOT,MODE,MAXRIN)
d861 1
a861 1
                    IF (TMTA .GE. CCROTD) THEN
d863 1
a863 1
	               CCROTD  = TMTA
d867 1
a867 1
	               RANGNEW =  ANG_N(TMT,MODE,MAXRIN)
d871 1
d881 1
a881 1
#ifdef DEBUG
d908 2
d964 1
a964 1
c                  write(6,910) it,jt,fitp(it,jt)
d975 1
a975 1
#ifdef DEBUG
d994 1
d1004 1
a1004 1
#ifdef DEBUG
a1032 1

d1038 1
a1038 1
#ifdef DEBUG
@


1.86
log
@ apstat,mpi
@
text
@d192 1
a192 1
	   ALLOCATE(ANGEXP(7,NUMEXP), EXPDIR(3,NUMEXP), STAT=IRTFLG)
d200 1
a200 1
     &                       INPIC,INANG,7,ANGEXP,NGOTPAR,IRTFLG)
d207 1
a207 1
	   ALLOCATE(ANGEXP(7,1), EXPDIR(3,1), STAT=IRTFLG)
d444 1
a444 1
           ALLOCATE(ANGEXP(7,NUMEXP), EXPDIR(3,NUMEXP), STAT=IRTFLG)
d446 1
a446 1
              MWANT = 10*NUMEXP 
d452 1
a452 1
     &                       INPIC,INANG,7,ANGEXP,NGOTPAR,IRTFLG)
d459 1
a459 1
           ALLOCATE(ANGEXP(7,1), EXPDIR(3,1), STAT=IRTFLG)
@


1.85
log
@FFTW3 plan changes, FFTW aprings
@
text
@d22 2
d135 3
a137 7
        IBIGANGDIF  = 0
        ANGDIFAVG   = 0.0
        CCROTAVG    = 0.0
        IMPROVCCROT = 0
        CCROTIMPROV = 0.0
        IWORSECCROT = 0
        CCROTWORSE  = 0.0
d290 8
a297 24
     &                GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &                NIMALCG, CTYPE, A,LUNDOC,PARLIST)



              CCROTAVG = CCROTAVG + CCROT
              IF (NGOTPAR .GE. 8) THEN
C                COMPILE CCROT CHANGE STATISTICS

                 ANGDIF = PARLIST(10)
                 IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
                 CCROTLAS  = ANGEXP(8,IEXP)
                 ANGDIFAVG = ANGDIFAVG + PARLIST(10)

                 IF (CCROT .GE. CCROTLAS) THEN
                    IMPROVCCROT = IMPROVCCROT + 1
                    CCROTIMPROV = CCROTIMPROV + CCROT
                 ELSE
                    IWORSECCROT = IWORSECCROT + 1
                    CCROTWORSE  = CCROTWORSE + CCROT
                 ENDIF
               ENDIF   ! END OF: IF (NGOTPAR .GE. 8)
d394 5
a398 7
        IBIGANGDIF  = 0
        ANGDIFAVG   = 0.0
        CCROTAVG    = 0.0
        IMPROVCCROT = 0
        CCROTIMPROV = 0.0
        IWORSECCROT = 0
        CCROTWORSE  = 0.0
d646 3
a648 3
     &             GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
     &             RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &             NIMALCG, CTYPE, A, LUNDOC, PARTABLOC(1,IT))
@


1.84
log
@reverted to pre aprings change
@
text
@d14 8
a21 4
C                   PEAKV = 1                     Jan 05 ARDEAN LEITH
C                   RANGNEWT OPT 64 BUG FIXED     May 05 ARDEAN LEITH
C                   DISCARD MIRROR ...            Jun 06 ARDEAN LEITH
C                   AP_STAT CALL                  Jan 07 ARDEAN LEITH
d25 1
a25 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d49 1
a49 1
C  MRQLI 
d51 13
a63 1
C  PARAMETERS:                (INPUT)
d66 1
a66 1
C        ON LCIRC & NIMA.  LCIRC IS THE TOTAL LENGTH OF THE ARRAY
d68 2
a69 2
C        NUMBER OF RINGS AND THEIR RADIUS.  NIMA IS NUMBER OF REFERENCE
C        IMAGES. BIGGEST ARRAY ALLOCATED IS: BFC(LCIRC,NIMA)
d77 5
a81 1
       SUBROUTINE MRQLI_PS(ILIST,NIMA,ILIP,NIDI, 
d83 2
a84 2
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,
d90 2
a91 2
	INTEGER, DIMENSION(NIMA)               :: ILIST 
	INTEGER, DIMENSION(NIDI)               :: ILIP 
d93 3
a95 2
	REAL, DIMENSION(LCIRC,NIMA)            :: BFC
	LOGICAL                                :: BFC_IN_CORE,CKMIRROR
d104 2
d123 263
a385 1
	DATA  INPIC/77/,INANG/78/,NSCF/50/
a386 1
#ifdef USE_MPI
a404 3
#else
        MYPID = -1
#endif
d412 2
a413 2
        IBIGANGDIF  = -1
        ANGDIFAVG   = HUGE(ANGDIFAVG)
d423 1
a423 1
        NIMALCG     = 1
d426 1
a426 1
	CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
d429 4
a432 5
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (BFC) ARRAY 
        CALL APRINGS(ILIST,NIMA, 
     &               LSAM,LROW,LSAM,LROW,
     &               NRING,LCIRC,NUMR,MODE,
     &               REFPAT,INPIC,BFC,BFC_IN_CORE,
a436 19
C       CALCULATE DIMENSIONS FOR NORMAS
	NSB  = -NSAM/2
	NSE  = -NSB-1+MOD(NSAM,2)
	NRB  = -NROW/2
	NRE  = -NRB-1+MOD(NROW,2)

#ifndef USE_MPI
C       THE MPI VERSION ALLOCATES LOCAL ARRAYS ALOC AND DLIST 
	ALLOCATE(A(LSAM,LROW,NUMTH), 
     &           DLIST(NLIST,NUMTH),  
     &           STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = LSAM*LROW*NUMTH + NLIST*NUMTH + NUMTH  
           CALL  ERRT(46,'A...',MWANT)
           RETURN
        ENDIF 
        DLIST = 0.0
#endif

d440 4
a443 4
	   ALLOCATE(REFDIR(3,NIMA),
     &              ANGREF(3,NIMA), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
               MWANT = 6*NIMA  
d450 1
a450 1
	   CALL AP_GETANGA(ILIST,NIMA,0,REFANGDOC,REFPAT,
d455 1
a455 1
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NIMA,IRTFLG)
d464 3
a466 3
	   ALLOCATE(ANGEXP(7,NIDI), EXPDIR(3,NIDI), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              MWANT = 10*NIDI 
d471 1
a471 1
	   CALL AP_GETANGA(ILIP,NIDI,0,EXPANGDOC,EXPPAT,
d476 1
a476 1
	   CALL AP_GETSATA(ANGEXP,EXPDIR,7,NIDI,IRTFLG)
d479 2
a480 2
	   ALLOCATE(ANGEXP(7,1), EXPDIR(3,1), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
a486 2
#ifdef USE_MPI

d501 1
a501 1
        CALL SETPART(NIDI, PSIZE, NBASE)
d540 1
a540 1
           CALL AP_GETDAT1P(ILIP,NIDI,LSAM,LROW,LSAM,LROW,
d574 1
d597 1
a597 1
 440    FORMAT(1X,'MRQLI_PS: DATA DIST TIME = ', 1PE11.3)
d599 1
a599 1
 444    FORMAT(1X,'MRQLI_PS: CALLING APRQ2D.., MYPID = ', I3)
d601 1
a601 1
        ALLOCATE(PARTAB(15,NIDI), PARTABLOC(15,NEXPLOC),
d604 1
a604 1
           CALL  ERRT(46,'PARTAB',NIDI)
d612 1
a612 1
           CALL APRQ2D(ALOC(1,1,IT),BFC,TT,NUMR,
d614 1
a614 1
     &              NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
d617 3
a619 2
     &              DLISTLOC(4,IT),DLISTLOC(5,IT),
     &              DLISTLOC(6,IT),NIMALCG,CKMIRROR,LIMITRANGE)
d628 1
a628 1
           IMGEXP = ILIP(IGLB)
d636 1
a636 1
              IMGREF = ILIST(-IREF)
d651 1
a651 1
              IMGREF = ILIST(IREF)
d678 1
a678 1
C
d680 1
a680 1
C
d684 2
a685 3
C             <,<,<, MIR-REF#,IMG#,INPLANE<, SX,SY,NPROJ,
C             <DIF,CCROT,INPLANE<,SX,SY
              DO IT = 1, NIDI
d694 1
a694 1
              DO IT = 1, NIDI
a701 110
#else
C       LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES
 	DO IEXPT=1,NIDI,NUMTH

C          LOAD EXP. IMAGE DATA FOR THIS SET OF IMAGES
           IEND = MIN(NIDI,IEXPT+NUMTH-1)
	   CALL AP_GETDAT(ILIP,NIDI,LSAM,LROW,LSAM,LROW,
     &                       NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                       1,LROW,1,LSAM, A,
     &                       IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          NUMTH INPUT IMAGES READY TO BE ALIGNED
c$omp      parallel do private(iexp,it)
	   DO IEXP=IEXPT,MIN(NIDI,IEXPT+NUMTH-1)
              IT = IEXP-IEXPT+1

	      CALL APRQ2D(A(1,1,IT),BFC,TT,NUMR,
     &	            NSAM,NROW,ISHRANGE,ISTEP,
     &	            NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &              REFDIR,EXPDIR(1,IEXP),RANGE,
     &              DLIST(2,IT),DLIST(3,IT),
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),
     &              NIMALCG,CKMIRROR,LIMITRANGE)
	   ENDDO

C          OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX SHIFT
C          5 - SY SHIFT
C          6 - INPUT IMAGE NUMBER.
    
           DO IEXP=IEXPT,MIN(NIDI,IEXPT+NUMTH-1)
              IT     = IEXP-IEXPT+1

              IMGEXP = ILIP(IEXP)

C             DLIST(2,IT IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
C                 (<0 IF MIRRORED, 0 IF NONE )

              IREF      = INT(DLIST(2,IT))
              IF (IREF .LT. 0) THEN
C                MIRRORED REFERENCE IMAGE
                 IMGREF = ILIST(-IREF)

C                IREFT IS FOR REFDIR INDEX
                 IREFT     = -IREF
                 MIRRORNEW = .TRUE.

              ELSEIF (IREF .EQ. 0) THEN
C                NO NEARBY REFERENCE IMAGE
                 IMGREF = 0

C                IREFT IS FOR REFDIR INDEX
                 IREFT  = 1
                 MIRRORNEW = .FALSE.

              ELSE
                 IMGREF = ILIST(IREF)
C                IREFT IS FOR REFDIR INDEX
                 IREFT     = IREF
                 MIRRORNEW = .FALSE.
              ENDIF
 
              CCROT     = DLIST(3,IT)
              RANGNEW   = DLIST(4,IT)
              XSHNEW    = DLIST(5,IT)
              YSHNEW    = DLIST(6,IT)
              PEAKV     = 1.0

              CALL AP_END(IEXP,IMGEXP,IMGREF,
     &                ANGREF(1,IREFT),REFDIR(1,IREFT),
     &                ANGEXP(1,IEXP), EXPDIR(1,IEXP),ISHRANGE,
     &                GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &                NIMALCG, CTYPE, A,LUNDOC,PARLIST)

              IF (NGOTPAR .GE. 8) THEN
C                COMPILE CCROT CHANGE STATISTICS

                 ANGDIF = PARLIST(10)
                 IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
                 CCROTLAS  = ANGEXP(8,IEXP)
                 ANGDIFAVG = ANGDIFAVG + PARLIST(10)

                 CCROTAVG = CCROTAVG + CCROT
                 IF (CCROT .GE. CCROTLAS) THEN
                    IMPROVCCROT = IMPROVCCROT + 1
                    CCROTIMPROV = CCROTIMPROV + CCROT
                 ELSE
                    IWORSECCROT = IWORSECCROT + 1
                    CCROTWORSE  = CCROTWORSE + CCROT
                 ENDIF
               ENDIF   ! END OF: IF (NGOTPAR .GE. 8)
	   ENDDO
	ENDDO

        IF (NGOTPAR .GE. 8 .AND. LUNDOC .GT. 0) THEN
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
          CALL AP_STAT(NIDI,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
        ENDIF

9999    CONTINUE
#endif 
a703 1
#ifdef USE_MPI
d710 6
a715 3
#else
        IF (ALLOCATED(DLIST))      DEALLOCATE(DLIST)
	IF (ALLOCATED(A))          DEALLOCATE(A)
a716 3
	IF (ALLOCATED(REFDIR))     DEALLOCATE(REFDIR)
	IF (ALLOCATED(ANGEXP))     DEALLOCATE(ANGEXP)
	IF (ALLOCATED(ANGREF))     DEALLOCATE(ANGREF)
d718 4
a721 1
	END
d733 1
a733 1
C                RANGNEW  inplane ANGLE                       (OUTPUT)
d740 1
a740 1
	SUBROUTINE APRQ2D(A,BFC,TT,NUMR,
d742 1
a742 1
     &	             NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
d745 1
a745 1
     &               CKMIRROR,LIMITRANGE)
d747 1
a747 1
	DIMENSION A(NSAM,NROW),BFC(LCIRC,NIMA),NUMR(3,NRING) 
d749 9
a757 5
	DOUBLE PRECISION  FITP(-1:1,-1:1)
	DOUBLE PRECISION, DIMENSION(*)    :: TT
        CHARACTER (LEN=1)                 :: MODE
	REAL, DIMENSION(3,NIMA)           :: REFDIR
	REAL, DIMENSION(3)                :: EXPDIR
d760 10
a769 10
	DOUBLE PRECISION  FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION         ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
        REAL, DIMENSION(LCIRC)             :: A_CIRC

        INTEGER, ALLOCATABLE, DIMENSION(:) :: LCG

	DOUBLE PRECISION                   :: CCROTD,PEAK
	DOUBLE PRECISION                   :: TOTA,TMTA
        LOGICAL                            :: CKMIRROR,LIMITRANGE
        LOGICAL                            :: MIRRORED
d774 2
a775 1
        PEAK = 0.0
d777 6
a782 1
        IEND  = NIMA
d788 3
a790 4
	   ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	   IF (IRTFLG.NE.0) THEN
              MWANT = NIMA
              CALL  ERRT(46,'LCG',MWANT)
d797 1
a797 1
	   DO IMI=1,NIMA
a817 1
C          write(6,*) ' '
d829 1
a829 2
C       END OF RESTRICTED RANGE SEARCH
        ENDIF
d831 2
a832 1
	CCROTD = -1.0D23
d834 1
a834 1
c       GO THROUGH CENTERS FOR SHIFT ALIGNMENT
d836 2
a837 1
	   CNR2 = NROW/2+1+JT
d839 1
a839 12
	      CNS2 = NSAM/2+1+IT

C             NORMALIZE UNDER THE MASK
	      
C             'NORMALIZE' IMAGE VALUES OVER VARIANCE RANGE
	      CALL NORMASS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,
     &                     NUMR(1,NRING))

C             INTERPOLATION INTO POLAR COORDINATES
C             CREATES A_CIRC (EXP. IMAGE CIRCLES) FOR THIS POSITION
	      CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
     &                      LCIRC,NRING,MODE)
d841 6
a846 2
C             CREATES FOURIER OF: A_CIRC
	      CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)
d848 1
a848 1
C             COMPARE EXP. IMAGE WITH ALL REFERENCE IMAGES
d852 28
a879 19
                   
                 IF (CKMIRROR) THEN
                    IF (LIMITRANGE) THEN
                       MIRRORED = (LCG(IRR) .LT. 0) 
C                      CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	               CALL CROSRNG_E(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		                    MAXRIN,NUMR,TOTA,TOT,TT,MIRRORED)

c                      write(6,*) 'ir, tota, tot:' ,ir,tota,tot

                    ELSE
C                      CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	               CALL CROSRNG_MS(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		                      MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)
                     ENDIF
                 ELSE 
C                   DO NOT CHECK MIRRORED POSITION
	            CALL CROSRNG_E(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		                    MAXRIN,NUMR,TOTA,TOT,TT,.FALSE.)
d882 1
d906 1
a906 6
C	      END OF: DO IRR=1,IEND
	      ENDDO 
C          END OF:  DO IT=-ISHRANGE,ISHRANGE,ISTEP
	   ENDDO
C       END OF:  DO JT=-ISHRANGE,ISHRANGE,ISTEP
	ENDDO
d908 2
d911 10
a920 4
C       TRY TO INTERPOLATE
        CCROT  = CCROTD
        SX     = ISX
        SY     = ISY
d922 43
d966 17
a982 27
C          DO NOT INTERPOLATE FOR POINT ON THE EDGE
	   IF (IABS(ISX).NE.ISHRANGE .AND. IABS(ISY).NE.ISHRANGE) THEN
C             HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)   = CCROTD
	      ROTMP(0,0) = RANGNEW

	      DO JT=-ISTEP,ISTEP
	         DO IT=-ISTEP,ISTEP
	            IF (IT.NE.0 .OR. JT.NE.0) THEN
	               CNR2 = NROW/2+1+JT+ISY
	               CNS2 = NSAM/2+1+IT+ISX

	               CALL NORMASS(A, NSB-(IT+ISX),NSE-(IT+ISX),
     &                             NRB-(JT+ISY),NRE-(JT+ISY),
     &	                           NUMR,NUMR(1,NRING))

	               CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,
     &                               A_CIRC,LCIRC,NRING,MODE)

	               CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

C                      IF (IDIS .LT. 0)  CHECK MIRRORED ONLY
                       MIRRORED = (IDIS .LT. 0)
	               CALL CROSRNG_E(BFC(1,IBE),A_CIRC,
     &                           LCIRC,NRING,MAXRIN,NUMR,FIT(IT,JT),
     &                           ROTMP(IT,JT),TT,MIRRORED)
                       ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODE,MAXRIN)
d984 3
a986 54
C	         END OF:  DO IT=-ISTEP,ISTEP
	         ENDDO
C	      END OF:  DO JT=-ISTEP,ISTEP
	      ENDDO

C             FIND THE MAXIMUM WITHIN +/-ISTEP
C             MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	      AFIT     = FIT(0,0)
	      JTMA     = 0
	      ITMA     = 0
              RANGNEWT = ROTMP(0,0)
	      IF (ISTEP .GT. 1)  THEN
	         DO JT=-ISTEP+1,ISTEP-1
	            DO IT=-ISTEP+1,ISTEP-1
	               IF (FIT(IT,JT) .GT. AFIT)  THEN
	                  AFIT     = FIT(IT,JT)
	                  RANGNEWT = ROTMP(IT,JT) !compiler bug on OPT64
	                  ITMA     = IT
	                  JTMA     = JT
	               ENDIF
	            ENDDO
	         ENDDO
	      ENDIF
C             TEMP VARIABLE OVERCOMES COMPILER BUG ON OPT 64 PGI 6.0
	      RANGNEW = RANGNEWT

C             COPY VALUES AROUND THE PEAK.
	      DO JT=-1,1
	         DO IT=-1,1
	            FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	         ENDDO
	      ENDDO

C             UPDATE LOCATION OF THE PEAK
	      CCROTD = AFIT
	      ISX    = ISX+ITMA
	      ISY    = ISY+JTMA
	      CALL PARABLD(FITP,SX,SY,PEAK)

C             CHECK WHETHER INTERPOLATION IS OK.
	      IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
C                NOT ON EDGE OF 3x3 AREA
	         SX   = SX+ISX
	         SY   = SY+ISY
	         CNR2 = NROW/2+1+SY
	         CNS2 = NSAM/2+1+SX

	         CALL NORMASS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
     &	                      NUMR,NUMR(1,NRING))

	         CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
     &                        LCIRC,NRING,MODE)

	         CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)
d988 25
a1012 2
C                IF (IDIS .LT. 0)  CHECK MIRRORED ONLY
                 MIRRORED = (IDIS .LT. 0)
d1014 2
a1015 2
	         CALL CROSRNG_E(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		            MAXRIN,NUMR,CCROTD,RANGNEW,TT,MIRRORED)
d1017 5
a1021 8
	         CCROT   = CCROTD
	         RANGNEW = ANG_N(RANGNEW,MODE,MAXRIN)
              ELSE
C                NOT ON EDGE OF 3x3 AREA
                 SX = ISX
                 SY = ISY
	      ENDIF
	   ENDIF
d1023 18
a1040 2
	SX = -SX
	SY = -SY
d1042 15
a1056 1
C       NOW HAVE TO CHANGE ORDER OF SHIFT & ROTATION.
d1059 1
a1059 1
C       THIS PART CORRESPONDS TO 'SA P'.
d1065 16
@


1.83
log
@ crosrng calls, variable names, split out mpi
@
text
@d14 4
a17 7
C                   PEAKV = 1                     JAN 05 ARDEAN LEITH
C                   RANGNEWT OPT 64 BUG FIXED     MAY 05 ARDEAN LEITH
C                   DISCARD MIRROR ...            JUN 06 ARDEAN LEITH
C                   AP_STAT CALL                  JAN 07 ARDEAN LEITH
C                   REF-RINGS FILE ADDED          MAR 08 ARDEAN LEITH
C                   CROSRNG_E REWRITE             MAR 08 ARDEAN LEITH
C                   IREFLIST VAR. NAME            MAR 08 ARDEAN LEITH
d21 1
a21 1
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d45 1
a45 1
C  MRQLI_PS 
d47 1
a47 13
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SAMPLE IMAGES
C
C PARAMETERS:
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NUMREF              NO. OF IMAGES                     (INPUT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NUMEXP              NO. OF IMAGES                     (INPUT)
C       LSAM,LROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
C       EXPANGDOC           EXP. ANGLES FILE NAME             (INPUT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
d50 1
a50 1
C        ON LCIRC & NUMREF.  LCIRC IS THE TOTAL LENGTH OF THE ARRAY
d52 2
a53 2
C        NUMBER OF RINGS AND THEIR RADIUS.  NUMREF IS NUMBER OF REFERENCE
C        IMAGES. BIGGEST ARRAY ALLOCATED IS: CIRCREF(LCIRC,NUMREF)
d61 1
a61 270

C ---------------------  NON-MPI CODE --------------------------------
#ifndef USE_MPI

       SUBROUTINE MRQLI_PS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
     &               LSAM,LROW,NR,LENTT,ISHRANGE,ISTEP,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN,
     &               REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,LUNDOC)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	INTEGER, DIMENSION(NUMREF)             :: IREFLIST 
	INTEGER, DIMENSION(NUMEXP)             :: IEXPLIST 
        INTEGER, DIMENSION(3,NRING)            :: NUMR
	REAL, DIMENSION(LCIRC,NUMREF)          :: CIRCREF
	LOGICAL                                :: CIRCREF_IN_CORE
        LOGICAL                                :: CKMIRROR
	LOGICAL                                :: MIRRORNEW
	LOGICAL                                :: GOTREFANG,LIMITRANGE
        CHARACTER(LEN=1)                       :: MODE
        CHARACTER (LEN=*)                      :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)                      :: SCRFILE
        CHARACTER (LEN=*)                      :: REFPAT,EXPPAT 
        CHARACTER (LEN=*)                      :: CTYPE

C       AUTOMATIC ARRAYS
	DOUBLE PRECISION, DIMENSION(LENTT)     :: TT
	REAL, DIMENSION(3)                     :: ANGOUT

C       ALLOCATED ARRAYS
	REAL, ALLOCATABLE, DIMENSION(:,:,:)    :: A
	REAL, ALLOCATABLE, DIMENSION(:,:)      :: DLIST 
	REAL, ALLOCATABLE,DIMENSION(:,:)       :: REFDIR,EXPDIR 
	REAL, ALLOCATABLE,DIMENSION(:,:)       :: ANGREF,ANGEXP

        INTEGER, PARAMETER                     :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)              :: PARLIST

        PARAMETER (NLIST=7)
	PARAMETER (QUADPI = 3.14159265358979323846)
	PARAMETER (DGR_TO_RAD =   (QUADPI/180))

	DATA  INPIC/77/,INANG/78/,NSCF/50/
 
        MYPID = -1
 
C       SET TYPE OF OUTPUT DOC FILES WANTED
        NWANTOUT = 7
        IF (CTYPE(1:2) .EQ. 'SH') NWANTOUT = 15

C       INITIALIZE CCROT STATISTICS COUNTERS
        ANGDIFTHR   = 0.0
        IBIGANGDIF  = -1
        ANGDIFAVG   = HUGE(ANGDIFAVG)
        CCROTAVG    = 0.0
        IMPROVCCROT = 0
        CCROTIMPROV = 0.0
        IWORSECCROT = 0
        CCROTWORSE  = 0.0

        LIMITRANGE  = (RANGE .GT. 0.0 .AND. RANGE .LT. 360.0) 
        MAXRIN      = NUMR(3,NRING)
        RANGE       = COS(RANGE*DGR_TO_RAD)
        NIMALCG     = 1

C       FIND DIVAS, NUMTH, NSAM, & NROW
	CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                   TT,LENTT)

C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
        CALL APRINGS(IREFLIST,NUMREF, 
     &               LSAM,LROW,LSAM,LROW,
     &               NRING,LCIRC,NUMR,MODE,
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
     &               NSCF,SCRFILE,IRTFLG)
        NSAM = LSAM
        NROW = LROW

C       CALCULATE DIMENSIONS FOR NORMAS
	NSB  = -NSAM/2
	NSE  = -NSB-1+MOD(NSAM,2)
	NRB  = -NROW/2
	NRE  = -NRB-1+MOD(NROW,2)

	ALLOCATE(A(LSAM,LROW,NUMTH), 
     &           DLIST(NLIST,NUMTH),  
     &           STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = LSAM*LROW*NUMTH + NLIST*NUMTH + NUMTH  
           CALL  ERRT(46,'A...',MWANT)
           RETURN
        ENDIF 
        DLIST = 0.0

        GOTREFANG = .FALSE.
        IF (LIMITRANGE .OR. CTYPE(1:2) .EQ. 'SH') THEN
C          REFANGLES FILE FOR RESTRICTED ANGULAR SEARCH  OR 'SH'
	   ALLOCATE(REFDIR(3,NUMREF),
     &              ANGREF(3,NUMREF), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
               MWANT = 6*NUMREF  
               CALL ERRT(46,'REFDIR, ANGREF',MWANT)
               RETURN
           ENDIF 
           GOTREFANG = .TRUE.

C          READ REF. ANGLES INTO ANGREF
	   CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                    INPIC,INANG,3,ANGREF,NGOTREF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
        ENDIF

        NGOTPAR = 0
        IF (CTYPE(1:2) .EQ. 'RQ' .OR.
     &     (CTYPE(1:2) .EQ. 'SH' .AND. 
     &     EXPANGDOC .NE. CHAR(0))) THEN
C          READ EXP. ANGLES INTO ANGEXP

	   ALLOCATE(ANGEXP(7,NUMEXP), EXPDIR(3,NUMEXP), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              MWANT = 10*NUMEXP 
              CALL ERRT(46,'ANGEXP....',MWANT)
              RETURN
           ENDIF 

	   CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                       INPIC,INANG,7,ANGEXP,NGOTPAR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS(EXPDIR).
	   CALL AP_GETSATA(ANGEXP,EXPDIR,7,NUMEXP,IRTFLG)
       ELSE
C          DUMMY ALLOCATE TO AVOID BUS ERROR ON SOME SYSTEMS
	   ALLOCATE(ANGEXP(7,1), EXPDIR(3,1), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              MWANT = 10*1 
              CALL ERRT(46,'ANGEXP....',MWANT)
              RETURN
           ENDIF 
        ENDIF

C       LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES -----------
 	DO IEXPT=1,NUMEXP,NUMTH

C          LOAD EXP. IMAGE DATA FOR THIS SET OF IMAGES
           IEND = MIN(NUMEXP,IEXPT+NUMTH-1)
	   CALL AP_GETDAT(IEXPLIST,NUMEXP,LSAM,LROW,LSAM,LROW,
     &                       NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                       1,LROW,1,LSAM, A,
     &                       IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          NUMTH INPUT IMAGES READY TO BE ALIGNED
c$omp      parallel do private(iexp,it)
	   DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
              IT = IEXP-IEXPT+1

	      CALL APRQ2D(A(1,1,IT),CIRCREF,TT,NUMR,
     &	            NSAM,NROW,ISHRANGE,ISTEP,
     &	            NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NUMREF,MODE,
     &              REFDIR,EXPDIR(1,IEXP),RANGE,
     &              DLIST(2,IT),DLIST(3,IT),
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),
     &              NIMALCG,CKMIRROR,LIMITRANGE,FFTW3PLAN)
	   ENDDO

C          OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX SHIFT
C          5 - SY SHIFT
C          6 - INPUT IMAGE NUMBER.
    
           DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
              IT     = IEXP-IEXPT+1

              IMGEXP = IEXPLIST(IEXP)

C             DLIST(2,IT IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
C                 (<0 IF MIRRORED, 0 IF NONE )

              IREF      = INT(DLIST(2,IT))
              IF (IREF .LT. 0) THEN
C                MIRRORED REFERENCE IMAGE
                 IMGREF = IREFLIST(-IREF)

C                IREFT IS FOR REFDIR INDEX
                 IREFT     = -IREF
                 MIRRORNEW = .TRUE.

              ELSEIF (IREF .EQ. 0) THEN
C                NO NEARBY REFERENCE IMAGE
                 IMGREF = 0

C                IREFT IS FOR REFDIR INDEX
                 IREFT  = 1
                 MIRRORNEW = .FALSE.

              ELSE
                 IMGREF = IREFLIST(IREF)
C                IREFT IS FOR REFDIR INDEX
                 IREFT     = IREF
                 MIRRORNEW = .FALSE.
              ENDIF
 
              CCROT     = DLIST(3,IT)
              RANGNEW   = DLIST(4,IT)
              XSHNEW    = DLIST(5,IT)
              YSHNEW    = DLIST(6,IT)
              PEAKV     = 1.0

              CALL AP_END(IEXP,IMGEXP,IMGREF,
     &                ANGREF(1,IREFT),REFDIR(1,IREFT),
     &                ANGEXP(1,IEXP), EXPDIR(1,IEXP),ISHRANGE,
     &                GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &                NIMALCG, CTYPE, A,LUNDOC,PARLIST)

              IF (NGOTPAR .GE. 8) THEN
C                COMPILE CCROT CHANGE STATISTICS

                 ANGDIF = PARLIST(10)
                 IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
                 CCROTLAS  = ANGEXP(8,IEXP)
                 ANGDIFAVG = ANGDIFAVG + PARLIST(10)

                 CCROTAVG = CCROTAVG + CCROT
                 IF (CCROT .GE. CCROTLAS) THEN
                    IMPROVCCROT = IMPROVCCROT + 1
                    CCROTIMPROV = CCROTIMPROV + CCROT
                 ELSE
                    IWORSECCROT = IWORSECCROT + 1
                    CCROTWORSE  = CCROTWORSE + CCROT
                 ENDIF
               ENDIF   ! END OF: IF (NGOTPAR .GE. 8)
	   ENDDO
	ENDDO

        IF (NGOTPAR .GE. 8 .AND. LUNDOC .GT. 0) THEN
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
          CALL AP_STAT(NUMEXP,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
        ENDIF

9999    CONTINUE

C       DEALLOCATE  ARRAYS
        IF (ALLOCATED(DLIST))      DEALLOCATE(DLIST)
	IF (ALLOCATED(A))          DEALLOCATE(A)
	IF (ALLOCATED(REFDIR))     DEALLOCATE(REFDIR)
	IF (ALLOCATED(ANGEXP))     DEALLOCATE(ANGEXP)
	IF (ALLOCATED(ANGREF))     DEALLOCATE(ANGREF)

	END


#else

C------------------------  MPI SPECIFIC SUBROUTINE --------------------

       SUBROUTINE MRQLI_PS(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d63 2
a64 2
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN,
d70 2
a71 2
	INTEGER, DIMENSION(NUMREF)             :: IREFLIST 
	INTEGER, DIMENSION(NUMEXP)             :: IEXPLIST 
d73 2
a74 3
	REAL, DIMENSION(LCIRC,NUMREF)          :: CIRCREF
	LOGICAL                                :: CIRCREF_IN_CORE
        LOGICAL                                :: CKMIRROR
d102 1
d121 3
d148 2
a149 2
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
        CALL APRINGS(IREFLIST,NUMREF, 
d152 1
a152 1
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
d163 13
d179 2
a180 2
	   ALLOCATE(REFDIR(3,NUMREF),
     &              ANGREF(3,NUMREF), STAT=IRTFLG)
d182 1
a182 1
               MWANT = 6*NUMREF  
d189 1
a189 1
	   CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
d194 1
a194 1
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
d203 1
a203 1
	   ALLOCATE(ANGEXP(7,NUMEXP), EXPDIR(3,NUMEXP), STAT=IRTFLG)
d205 1
a205 1
              MWANT = 10*NUMEXP 
d210 1
a210 1
	   CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
d215 1
a215 1
	   CALL AP_GETSATA(ANGEXP,EXPDIR,7,NUMEXP,IRTFLG)
d226 2
d242 1
a242 1
        CALL SETPART(NUMEXP, PSIZE, NBASE)
d281 1
a281 1
           CALL AP_GETDAT1P(IEXPLIST,NUMEXP,LSAM,LROW,LSAM,LROW,
a314 1

d337 1
a337 1
 440    FORMAT(' MRQLI_PS: DATA DIST TIME = ', 1PE11.3)
d339 1
a339 1
 444    FORMAT(' MRQLI_PS: CALLING APRQ2D.., MYPID = ', I3)
d341 1
a341 1
        ALLOCATE(PARTAB(15,NUMEXP), PARTABLOC(15,NEXPLOC),
d344 1
a344 1
           CALL  ERRT(46,'PARTAB',NUMEXP)
d352 1
a352 1
           CALL APRQ2D(ALOC(1,1,IT),CIRCREF,TT,NUMR,
d354 1
a354 1
     &              NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NUMREF,MODE,
d358 1
a358 2
     &              DLISTLOC(6,IT),NIMALCG,CKMIRROR,LIMITRANGE,
     &              FFTW3PLAN)
d367 1
a367 1
           IMGEXP = IEXPLIST(IGLB)
d375 1
a375 1
              IMGREF = IREFLIST(-IREF)
d390 1
a390 1
              IMGREF = IREFLIST(IREF)
d425 1
a425 1
              DO IT = 1, NUMEXP
d434 1
a434 1
              DO IT = 1, NUMEXP
d442 110
d554 1
d561 4
a569 6
#endif
C ------------------------- END OF MPI CODE -----------------------




d581 1
a581 1
C                RANGNEW  INPLANE ANGLE                       (OUTPUT)
d588 1
a588 1
	SUBROUTINE APRQ2D(A,CIRCREF,TT,NUMR,
d590 1
a590 1
     &	             NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NUMREF,MODE,
d593 1
a593 1
     &               CKMIRROR,LIMITRANGE,FFTW3PLAN)
d595 1
a595 1
C       NOTE: RUNS WITHIN OMP PARALLEL SECTION OF CODE IF NOT UNDER MPI!
d597 5
a601 9
	REAL                      :: A(NSAM,NROW)
        REAL                      :: CIRCREF(LCIRC,NUMREF)
        REAL                      :: NUMR(3,NRING) 

	DOUBLE PRECISION          :: FITP(-1:1,-1:1)
	DOUBLE PRECISION          :: TT(*)
        CHARACTER (LEN=1)         :: MODE
	REAL                      :: REFDIR(3,NUMREF)
	REAL                      :: EXPDIR(3)
d604 10
a613 10
	DOUBLE PRECISION          :: FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
	REAL                      :: ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
        REAL                      :: A_CIRC(LCIRC)

        INTEGER, ALLOCATABLE      :: LCG(:)

	DOUBLE PRECISION          :: CCROTD,PEAK
	DOUBLE PRECISION          :: TOTA,TMTA
        LOGICAL                   :: CKMIRROR,LIMITRANGE
        LOGICAL                   :: MIRRORED
d620 1
a620 1
        IEND  = NUMREF
d626 4
a629 3
	   ALLOCATE(LCG(NUMREF),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL  ERRT(46,'LCG',NUMREF)
d636 1
a636 1
	   DO IMI=1,NUMREF
d669 2
a670 1
        ENDIF     ! END OF RESTRICTED RANGE SEARCH
d680 3
a682 1
C             NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE RANGE
d686 1
a686 1
C             INTERPOLATE INTO POLAR COORDINATES
d689 1
a689 1
     &                     LCIRC,NRING,MODE)
d703 2
a704 3
	               CALL CROSRNG_EP(CIRCREF(1,IR),A_CIRC,LCIRC,
     &                         NRING, MAXRIN,NUMR,TOTA,TOT,TT,MIRRORED,
     &                         FFTW3PLAN)
d710 2
a711 4
	               CALL CROSRNG_MSP(CIRCREF(1,IR),A_CIRC,
     &                                LCIRC,NRING,
     &		                      MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT,
     &                                FFTW3PLAN)
d715 2
a716 3
	            CALL CROSRNG_EP(CIRCREF(1,IR),A_CIRC,LCIRC,NRING,
     &		                    MAXRIN,NUMR,TOTA,TOT,TT,.FALSE.,
     &                              FFTW3PLAN)
d742 6
a747 3
	      ENDDO ! END OF: DO IRR=1,IEND
	   ENDDO    ! END OF:  DO IT=-ISHRANGE,ISHRANGE,ISTEP
	ENDDO       ! END OF:  DO JT=-ISHRANGE,ISHRANGE,ISTEP
d756 24
a779 24
C       DO NOT INTERPOLATE FOR POINT ON THE EDGE
        IF (IABS(ISX).NE.ISHRANGE .AND. IABS(ISY).NE.ISHRANGE) THEN
C          HAVE TO FIND NEIGHBOURING VALUES
	   FIT(0,0)   = CCROTD
           ROTMP(0,0) = RANGNEW

           DO JT=-ISTEP,ISTEP
	      DO IT=-ISTEP,ISTEP
	         IF (IT.NE.0 .OR. JT.NE.0) THEN
	            CNR2 = NROW/2+1+JT+ISY
	            CNS2 = NSAM/2+1+IT+ISX

	            CALL NORMASS(A, NSB-(IT+ISX),NSE-(IT+ISX),
     &                           NRB-(JT+ISY),NRE-(JT+ISY),
     &	                         NUMR,NUMR(1,NRING))

	            CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,
     &                              A_CIRC,LCIRC,NRING,MODE)

	            CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

C                   WHEN (IDIS .LT. 0)  CHECK MIRRORED ONLY
                    MIRRORED = (IDIS .LT. 0)
	            CALL CROSRNG_EP(CIRCREF(1,IBE),A_CIRC,
d781 2
a782 21
     &                           ROTMP(IT,JT),TT,MIRRORED,
     &                           FFTW3PLAN)
                    ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODE,MAXRIN)
	         ENDIF
	      ENDDO   ! END OF:  DO IT=-ISTEP,ISTEP
           ENDDO      ! END OF:  DO JT=-ISTEP,ISTEP

C          FIND THE MAXIMUM WITHIN +/-ISTEP
C          MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	   AFIT     = FIT(0,0)
	   JTMA     = 0
	   ITMA     = 0
           RANGNEWT = ROTMP(0,0)
	   IF (ISTEP .GT. 1)  THEN
	      DO JT=-ISTEP+1,ISTEP-1
	         DO IT=-ISTEP+1,ISTEP-1
	            IF (FIT(IT,JT) .GT. AFIT)  THEN
	               AFIT     = FIT(IT,JT)
	               RANGNEWT = ROTMP(IT,JT) !compiler bug on OPT64
	               ITMA     = IT
	               JTMA     = JT
d784 46
a829 27
	         ENDDO  ! END OF:  DO IT=-ISTEP,ISTEP
              ENDDO     ! END OF:  DO JT=-ISTEP,ISTEP
           ENDIF

C          TEMP VARIABLE OVERCOMES COMPILER BUG ON OPT 64 PGI 6.0
           RANGNEW = RANGNEWT

C          COPY VALUES AROUND THE PEAK.
           DO JT=-1,1
              DO IT=-1,1
                 FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
              ENDDO
           ENDDO

C          UPDATE LOCATION OF THE PEAK
           CCROTD = AFIT
	   ISX    = ISX+ITMA
	   ISY    = ISY+JTMA
           CALL PARABLD(FITP,SX,SY,PEAK)

C          CHECK WHETHER INTERPOLATION IS OK.
	   IF (ABS(SX) .LT. 1.0 .AND. ABS(SY) .LT. 1.0)  THEN
C             NOT ON EDGE OF 3x3 AREA
	      SX   = SX+ISX
	      SY   = SY+ISY
	      CNR2 = NROW/2+1+SY
	      CNS2 = NSAM/2+1+SX
d831 1
a831 1
	      CALL NORMASS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
d834 1
a834 1
	      CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
d837 1
a837 1
	      CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)
d839 2
a840 2
C             IF (IDIS .LT. 0)  CHECK MIRRORED ONLY
              MIRRORED = (IDIS .LT. 0)
d842 2
a843 3
	      CALL CROSRNG_EP(CIRCREF(1,IBE),A_CIRC,LCIRC,NRING,
     &		            MAXRIN,NUMR,CCROTD,RANGNEW,TT,MIRRORED,
     &                      FFTW3PLAN)
d845 8
a852 8
	      CCROT   = CCROTD
	      RANGNEW = ANG_N(RANGNEW,MODE,MAXRIN)
           ELSE
C             NOT ON EDGE OF 3x3 AREA
              SX = ISX
              SY = ISY
           ENDIF
        ENDIF
@


1.82
log
@statfile output
@
text
@d14 7
a20 4
C                   PEAKV = 1                     Jan 05 ARDEAN LEITH
C                   RANGNEWT OPT 64 BUG FIXED     May 05 ARDEAN LEITH
C                   DISCARD MIRROR ...            Jun 06 ARDEAN LEITH
C                   AP_STAT CALL                  Jan 07 ARDEAN LEITH
d24 1
a24 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d48 1
a48 1
C  MRQLI 
d50 13
a62 1
C  PARAMETERS:                (INPUT)
d65 1
a65 1
C        ON LCIRC & NIMA.  LCIRC IS THE TOTAL LENGTH OF THE ARRAY
d67 2
a68 2
C        NUMBER OF RINGS AND THEIR RADIUS.  NIMA IS NUMBER OF REFERENCE
C        IMAGES. BIGGEST ARRAY ALLOCATED IS: BFC(LCIRC,NIMA)
d76 270
a345 1
       SUBROUTINE MRQLI_PS(ILIST,NIMA,ILIP,NIDI, 
d347 2
a348 2
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,
d354 2
a355 2
	INTEGER, DIMENSION(NIMA)               :: ILIST 
	INTEGER, DIMENSION(NIDI)               :: ILIP 
d357 3
a359 2
	REAL, DIMENSION(LCIRC,NIMA)            :: BFC
	LOGICAL                                :: BFC_IN_CORE,CKMIRROR
a386 1
#ifdef USE_MPI
a404 3
#else
        MYPID = -1
#endif
d429 2
a430 2
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (BFC) ARRAY 
        CALL APRINGS(ILIST,NIMA, 
d433 1
a433 1
     &               REFPAT,INPIC,BFC,BFC_IN_CORE,
a443 13
#ifndef USE_MPI
C       THE MPI VERSION ALLOCATES LOCAL ARRAYS ALOC AND DLIST 
	ALLOCATE(A(LSAM,LROW,NUMTH), 
     &           DLIST(NLIST,NUMTH),  
     &           STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = LSAM*LROW*NUMTH + NLIST*NUMTH + NUMTH  
           CALL  ERRT(46,'A...',MWANT)
           RETURN
        ENDIF 
        DLIST = 0.0
#endif

d447 2
a448 2
	   ALLOCATE(REFDIR(3,NIMA),
     &              ANGREF(3,NIMA), STAT=IRTFLG)
d450 1
a450 1
               MWANT = 6*NIMA  
d457 1
a457 1
	   CALL AP_GETANGA(ILIST,NIMA,0,REFANGDOC,REFPAT,
d462 1
a462 1
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NIMA,IRTFLG)
d471 1
a471 1
	   ALLOCATE(ANGEXP(7,NIDI), EXPDIR(3,NIDI), STAT=IRTFLG)
d473 1
a473 1
              MWANT = 10*NIDI 
d478 1
a478 1
	   CALL AP_GETANGA(ILIP,NIDI,0,EXPANGDOC,EXPPAT,
d483 1
a483 1
	   CALL AP_GETSATA(ANGEXP,EXPDIR,7,NIDI,IRTFLG)
a493 2
#ifdef USE_MPI

d508 1
a508 1
        CALL SETPART(NIDI, PSIZE, NBASE)
d547 1
a547 1
           CALL AP_GETDAT1P(ILIP,NIDI,LSAM,LROW,LSAM,LROW,
d581 1
d604 1
a604 1
 440    FORMAT(1X,'MRQLI_PS: DATA DIST TIME = ', 1PE11.3)
d606 1
a606 1
 444    FORMAT(1X,'MRQLI_PS: CALLING APRQ2D.., MYPID = ', I3)
d608 1
a608 1
        ALLOCATE(PARTAB(15,NIDI), PARTABLOC(15,NEXPLOC),
d611 1
a611 1
           CALL  ERRT(46,'PARTAB',NIDI)
d619 1
a619 1
           CALL APRQ2D(ALOC(1,1,IT),BFC,TT,NUMR,
d621 1
a621 1
     &              NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
d625 2
a626 1
     &              DLISTLOC(6,IT),NIMALCG,CKMIRROR,LIMITRANGE)
d635 1
a635 1
           IMGEXP = ILIP(IGLB)
d643 1
a643 1
              IMGREF = ILIST(-IREF)
d658 1
a658 1
              IMGREF = ILIST(IREF)
d693 1
a693 1
              DO IT = 1, NIDI
d702 1
a702 1
              DO IT = 1, NIDI
a709 110
#else
C       LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES
 	DO IEXPT=1,NIDI,NUMTH

C          LOAD EXP. IMAGE DATA FOR THIS SET OF IMAGES
           IEND = MIN(NIDI,IEXPT+NUMTH-1)
	   CALL AP_GETDAT(ILIP,NIDI,LSAM,LROW,LSAM,LROW,
     &                       NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                       1,LROW,1,LSAM, A,
     &                       IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          NUMTH INPUT IMAGES READY TO BE ALIGNED
c$omp      parallel do private(iexp,it)
	   DO IEXP=IEXPT,MIN(NIDI,IEXPT+NUMTH-1)
              IT = IEXP-IEXPT+1

	      CALL APRQ2D(A(1,1,IT),BFC,TT,NUMR,
     &	            NSAM,NROW,ISHRANGE,ISTEP,
     &	            NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &              REFDIR,EXPDIR(1,IEXP),RANGE,
     &              DLIST(2,IT),DLIST(3,IT),
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),
     &              NIMALCG,CKMIRROR,LIMITRANGE)
	   ENDDO

C          OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX SHIFT
C          5 - SY SHIFT
C          6 - INPUT IMAGE NUMBER.
    
           DO IEXP=IEXPT,MIN(NIDI,IEXPT+NUMTH-1)
              IT     = IEXP-IEXPT+1

              IMGEXP = ILIP(IEXP)

C             DLIST(2,IT IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
C                 (<0 IF MIRRORED, 0 IF NONE )

              IREF      = INT(DLIST(2,IT))
              IF (IREF .LT. 0) THEN
C                MIRRORED REFERENCE IMAGE
                 IMGREF = ILIST(-IREF)

C                IREFT IS FOR REFDIR INDEX
                 IREFT     = -IREF
                 MIRRORNEW = .TRUE.

              ELSEIF (IREF .EQ. 0) THEN
C                NO NEARBY REFERENCE IMAGE
                 IMGREF = 0

C                IREFT IS FOR REFDIR INDEX
                 IREFT  = 1
                 MIRRORNEW = .FALSE.

              ELSE
                 IMGREF = ILIST(IREF)
C                IREFT IS FOR REFDIR INDEX
                 IREFT     = IREF
                 MIRRORNEW = .FALSE.
              ENDIF
 
              CCROT     = DLIST(3,IT)
              RANGNEW   = DLIST(4,IT)
              XSHNEW    = DLIST(5,IT)
              YSHNEW    = DLIST(6,IT)
              PEAKV     = 1.0

              CALL AP_END(IEXP,IMGEXP,IMGREF,
     &                ANGREF(1,IREFT),REFDIR(1,IREFT),
     &                ANGEXP(1,IEXP), EXPDIR(1,IEXP),ISHRANGE,
     &                GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &                NIMALCG, CTYPE, A,LUNDOC,PARLIST)

              IF (NGOTPAR .GE. 8) THEN
C                COMPILE CCROT CHANGE STATISTICS

                 ANGDIF = PARLIST(10)
                 IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
                 CCROTLAS  = ANGEXP(8,IEXP)
                 ANGDIFAVG = ANGDIFAVG + PARLIST(10)

                 CCROTAVG = CCROTAVG + CCROT
                 IF (CCROT .GE. CCROTLAS) THEN
                    IMPROVCCROT = IMPROVCCROT + 1
                    CCROTIMPROV = CCROTIMPROV + CCROT
                 ELSE
                    IWORSECCROT = IWORSECCROT + 1
                    CCROTWORSE  = CCROTWORSE + CCROT
                 ENDIF
               ENDIF   ! END OF: IF (NGOTPAR .GE. 8)
	   ENDDO
	ENDDO

        IF (NGOTPAR .GE. 8 .AND. LUNDOC .GT. 0) THEN
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
          CALL AP_STAT(NIDI,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
        ENDIF

9999    CONTINUE
#endif 
a711 1
#ifdef USE_MPI
a717 4
#else
        IF (ALLOCATED(DLIST))      DEALLOCATE(DLIST)
	IF (ALLOCATED(A))          DEALLOCATE(A)
#endif
d723 6
d740 1
a740 1
C                RANGNEW  inplane ANGLE                       (OUTPUT)
d747 1
a747 1
	SUBROUTINE APRQ2D(A,BFC,TT,NUMR,
d749 1
a749 1
     &	             NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
d752 1
a752 1
     &               CKMIRROR,LIMITRANGE)
d754 1
a754 1
	DIMENSION A(NSAM,NROW),BFC(LCIRC,NIMA),NUMR(3,NRING) 
d756 9
a764 5
	DOUBLE PRECISION  FITP(-1:1,-1:1)
	DOUBLE PRECISION, DIMENSION(*)    :: TT
        CHARACTER (LEN=1)                 :: MODE
	REAL, DIMENSION(3,NIMA)           :: REFDIR
	REAL, DIMENSION(3)                :: EXPDIR
d767 10
a776 10
	DOUBLE PRECISION  FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION         ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
        REAL, DIMENSION(LCIRC)             :: A_CIRC

        INTEGER, ALLOCATABLE, DIMENSION(:) :: LCG

	DOUBLE PRECISION                   :: CCROTD,PEAK
	DOUBLE PRECISION                   :: TOTA,TMTA
        LOGICAL                            :: CKMIRROR,LIMITRANGE
        LOGICAL                            :: MIRRORED
d783 1
a783 1
        IEND  = NIMA
d789 3
a791 4
	   ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	   IF (IRTFLG.NE.0) THEN
              MWANT = NIMA
              CALL  ERRT(46,'LCG',MWANT)
d798 1
a798 1
	   DO IMI=1,NIMA
d831 1
a831 2
C       END OF RESTRICTED RANGE SEARCH
        ENDIF
d841 1
a841 3
C             NORMALIZE UNDER THE MASK
	      
C             'NORMALIZE' IMAGE VALUES OVER VARIANCE RANGE
d845 1
a845 1
C             INTERPOLATION INTO POLAR COORDINATES
d848 1
a848 1
     &                      LCIRC,NRING,MODE)
d862 3
a864 2
	               CALL CROSRNG_E(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		                    MAXRIN,NUMR,TOTA,TOT,TT,MIRRORED)
d870 4
a873 2
	               CALL CROSRNG_MS(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		                      MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)
d877 3
a879 2
	            CALL CROSRNG_E(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		                    MAXRIN,NUMR,TOTA,TOT,TT,.FALSE.)
d905 3
a907 6
C	      END OF: DO IRR=1,IEND
	      ENDDO 
C          END OF:  DO IT=-ISHRANGE,ISHRANGE,ISTEP
	   ENDDO
C       END OF:  DO JT=-ISHRANGE,ISHRANGE,ISTEP
	ENDDO
d916 24
a939 24
C          DO NOT INTERPOLATE FOR POINT ON THE EDGE
	   IF (IABS(ISX).NE.ISHRANGE .AND. IABS(ISY).NE.ISHRANGE) THEN
C             HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)   = CCROTD
	      ROTMP(0,0) = RANGNEW

	      DO JT=-ISTEP,ISTEP
	         DO IT=-ISTEP,ISTEP
	            IF (IT.NE.0 .OR. JT.NE.0) THEN
	               CNR2 = NROW/2+1+JT+ISY
	               CNS2 = NSAM/2+1+IT+ISX

	               CALL NORMASS(A, NSB-(IT+ISX),NSE-(IT+ISX),
     &                             NRB-(JT+ISY),NRE-(JT+ISY),
     &	                           NUMR,NUMR(1,NRING))

	               CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,
     &                               A_CIRC,LCIRC,NRING,MODE)

	               CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

C                      IF (IDIS .LT. 0)  CHECK MIRRORED ONLY
                       MIRRORED = (IDIS .LT. 0)
	               CALL CROSRNG_E(BFC(1,IBE),A_CIRC,
d941 21
a961 2
     &                           ROTMP(IT,JT),TT,MIRRORED)
                       ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODE,MAXRIN)
d963 27
a989 46
C	         END OF:  DO IT=-ISTEP,ISTEP
	         ENDDO
C	      END OF:  DO JT=-ISTEP,ISTEP
	      ENDDO

C             FIND THE MAXIMUM WITHIN +/-ISTEP
C             MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	      AFIT     = FIT(0,0)
	      JTMA     = 0
	      ITMA     = 0
              RANGNEWT = ROTMP(0,0)
	      IF (ISTEP .GT. 1)  THEN
	         DO JT=-ISTEP+1,ISTEP-1
	            DO IT=-ISTEP+1,ISTEP-1
	               IF (FIT(IT,JT) .GT. AFIT)  THEN
	                  AFIT     = FIT(IT,JT)
	                  RANGNEWT = ROTMP(IT,JT) !compiler bug on OPT64
	                  ITMA     = IT
	                  JTMA     = JT
	               ENDIF
	            ENDDO
	         ENDDO
	      ENDIF
C             TEMP VARIABLE OVERCOMES COMPILER BUG ON OPT 64 PGI 6.0
	      RANGNEW = RANGNEWT

C             COPY VALUES AROUND THE PEAK.
	      DO JT=-1,1
	         DO IT=-1,1
	            FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	         ENDDO
	      ENDDO

C             UPDATE LOCATION OF THE PEAK
	      CCROTD = AFIT
	      ISX    = ISX+ITMA
	      ISY    = ISY+JTMA
	      CALL PARABLD(FITP,SX,SY,PEAK)

C             CHECK WHETHER INTERPOLATION IS OK.
	      IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
C                NOT ON EDGE OF 3x3 AREA
	         SX   = SX+ISX
	         SY   = SY+ISY
	         CNR2 = NROW/2+1+SY
	         CNS2 = NSAM/2+1+SX
d991 1
a991 1
	         CALL NORMASS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
d994 1
a994 1
	         CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
d997 1
a997 1
	         CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)
d999 2
a1000 2
C                IF (IDIS .LT. 0)  CHECK MIRRORED ONLY
                 MIRRORED = (IDIS .LT. 0)
d1002 3
a1004 2
	         CALL CROSRNG_E(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		            MAXRIN,NUMR,CCROTD,RANGNEW,TT,MIRRORED)
d1006 8
a1013 8
	         CCROT   = CCROTD
	         RANGNEW = ANG_N(RANGNEW,MODE,MAXRIN)
              ELSE
C                NOT ON EDGE OF 3x3 AREA
                 SX = ISX
                 SY = ISY
	      ENDIF
	   ENDIF
@


1.81
log
@C                      DO NOT DISCARD IF NOT MIRRORED OR WANT MIRRORED
@
text
@d13 1
a13 1
C                   AP_END CALL HAS DUMLIST       OCT 04 ARDEAN LEITH
d17 1
d21 1
a21 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d94 1
a94 1
        REAL, DIMENSION(NLISTMAX)              :: DUMLIST
d129 14
a142 4
        LIMITRANGE = (RANGE .GT. 0.0 .AND. RANGE .LT. 360.0) 
        MAXRIN     = NUMR(3,NRING)
        RANGE      = COS(RANGE*DGR_TO_RAD)
        NIMALCG    = 1
d504 1
a504 1
                 IREFT  = IREF
d519 1
a519 1
     &                NIMALCG, CTYPE, A,LUNDOC,DUMLIST)
d521 18
d542 8
@


1.80
log
@GPL License fixed
@
text
@d16 1
d597 1
d607 1
a607 4
C                MIRORED OR NON-MIRRORED IS WITHIN RANGE
	         NIMALCG      = NIMALCG + 1
	         LCG(NIMALCG) = IMI
                 IF (DT .LT. 0) LCG(NIMALCG) = -IMI
d609 5
a613 2
C                write(6,*) 'imi: ',imi,' dt: ',dt,' dtabs: ',dtabs, 
C     &              refdir(1,imi),refdir(2,imi),refdir(3,imi)
d615 3
@


1.79
log
@HRI GPL License used
@
text
@a1 1
C++************************************************************************
a17 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d21 1
a21 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a40 6

C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
a57 1
C--************************************************************************
@


1.78
log
@remove some MPI_BARRIERs to reduce comm overhead
@
text
@d1 1
d20 24
d65 1
@


1.77
log
@RANGNEWT undefined bug
@
text
@a226 1
        CALL MPI_BARRIER(COMM,MPIERR)
a255 1
           CALL MPI_BARRIER(COMM, MPIERR)
a296 1
           CALL MPI_BARRIER(COMM,MPIERR)
a379 1
        CALL MPI_BARRIER(COMM,MPIERR)
a410 1
        CALL MPI_BARRIER(COMM,MPIERR)
@


1.76
log
@rangnew compiler bug on opt 64 pig 6.0
@
text
@d15 1
d737 5
a741 4
	      AFIT = FIT(0,0)
	      JTMA = 0
	      ITMA = 0
	      IF (ISTEP.GT.1)  THEN
d753 1
a753 1
C             TEMP VARIABLE OVERCOMES COMPILER BUG ON OPT ^$ PGI 6.0
@


1.75
log
@Replaced AP_GETDAT with AP_GETDAT1P to avoid unnecessary broadcast; added MPI_Wtime to time data distribution
@
text
@d743 4
a746 4
	                  AFIT    = FIT(IT,JT)
	                  RANGNEW = ROTMP(IT,JT)
	                  ITMA    = IT
	                  JTMA    = JT
d751 2
@


1.74
log
@PEAKV = 1
@
text
@d93 3
d238 3
d252 3
a254 3
           CALL AP_GETDAT(ILIP,NIDI,LSAM,LROW,LSAM,LROW,
     &                    NUMTH,EXPPAT,INPIC, IBEG,IEND,
     &                    1,LROW,1,LSAM, ABUF,IRTFLG)
d308 3
@


1.73
log
@AP_END CALL HAS DLIST
@
text
@d14 1
d364 1
a364 1
           PEAKV     = 0.0
d478 1
a478 1
              PEAKV     = 0.0
@


1.72
log
@mpi
@
text
@d13 1
d72 3
d83 14
a96 14
        INTEGER  MYPID, COMM, MPIERR, NPROCS, NEXPLOC, NREM
        INTEGER  ISTAT(MPI_STATUS_SIZE)
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: ALOC
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: ABUF
        REAL   , ALLOCATABLE, DIMENSION(:,:)   :: DLISTLOC
        REAL   , ALLOCATABLE, DIMENSION(:,:)   :: PARTAB,PARTABLOC
        INTEGER, ALLOCATABLE, DIMENSION(:) :: NBASE, PSIZE
        INTEGER  IPROC, ISAM, JROW, JLOC, ILOC, TAG, MASTER,
     &           ITI, IMIT, IGLB, IBEG, IEND
C
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID , MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
        MASTER = 0
d129 2
a130 3
#ifdef USE_MPI
C       THE MPI VERSION ALLOCATES LOCAL ARRAYS ALOC AND DLISTLOC 
#else
d365 1
a365 1
           CALL AP_END2(IGLB,IMGEXP,IMGREF,
d370 1
a370 1
     &             NIMALCG, CTYPE, A, PARTABLOC(1,IT))
d484 1
a484 1
     &                NIMALCG, CTYPE, A,LUNDOC)
@


1.71
log
@cosmetic.
@
text
@d79 14
a92 13
        integer  mypid, comm, ierr, nprocs, nexploc, nrem
        integer  istat(MPI_STATUS_SIZE)
        real   , allocatable, dimension(:,:,:) :: A_loc
        real   , allocatable, dimension(:,:,:) :: A_buf
        real   , allocatable, dimension(:,:)   :: DLIST_loc
        integer, allocatable, dimension(:) :: nbase, psize
        integer  iproc, isam, jrow, jloc, iloc, tag, master, 
     &           iti, imit, iglb
c
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid , ierr)
        call MPI_COMM_SIZE(comm, nprocs, ierr)
        master = 0
d94 1
a94 1
        mypid = -1
d126 1
a126 1
c       The MPI version allocates local arrays A_loc and DLIST_loc 
d191 1
a191 1
c       === partition and distribute experimental images ===
d193 3
a195 3
        allocate(psize(nprocs),STAT=IRTFLG)
        if (IRTFLG .NE. 0) THEN
           write(6,*) 'mrqli_ps: failed to allocate psize'
d197 1
a197 1
        endif
d199 3
a201 3
        allocate(nbase(nprocs), STAT=IRTFLG)
        if (IRTFLG .NE. 0) THEN
           write(6,*) 'mrqli_ps: failed to allocate nbase'
d203 1
a203 1
        endif
d205 2
a206 2
        call setpart(nidi, psize, nbase)
        nexploc = psize(mypid+1)
d208 6
a213 6
        allocate(A_loc(NSAM,NROW,nexploc),stat=irtflg)
        if (irtflg .ne. 0) then
           write(6,*) ' mrqli_ps: failed to allocate A_loc'
           return
        end if
        A_loc = 0.0
d216 4
a219 4
        write(6,111) nbase(mypid+1), mypid
        call flushfile(6)
 111    format(' mrqli_ps: nbase = ', I5, ' mypid = ', I5)
        call MPI_BARRIER(comm,ierr)
d221 12
d234 1
a234 2
c       === process 0 reads all images at once and distribute
c           them to different processors. ===
d236 2
a237 1
        if (mypid .eq. 0) then
d239 2
a240 1
c           === read images into the buffer first ===
d242 5
a246 5
            allocate(A_buf(NSAM,NROW, nexploc),stat=irtflg)
            if (irtflg .ne. 0) then
               write(6,*) ' mrqli_ps: failed to allocate A_buf'
               return
            endif
d248 28
a275 2
            do iproc = 1, nprocs
               nloc = psize(iproc)
d277 1
a277 1
c                 === calculate the global index ===
d279 12
a290 6
                  IEXPT = nbase(iproc) + 1
                  IEND  = nbase(iproc) + nloc 
                  CALL AP_GETDAT(ILIP,NIDI,LSAM,LROW,LSAM,LROW,
     &                           NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                           1,LROW,1,LSAM, A_buf,IRTFLG)
                  IF (IRTFLG .NE. 0) stop
d292 5
a296 1
               if (iproc .gt. 1) then
d298 2
a299 3
                  write(6,222) iproc-1
                  call flushfile(6)
 222              format(' mrqli_ps: sending to pid = ', I3)
d301 18
a318 49
                  call MPI_SEND(A_buf  , NSAM*NROW*nloc, MPI_REAL,
     &                          iproc-1, iproc-1       , comm    ,
     &                          ierr)
               else

c                 === simply copy from A_buf to A_loc ===

                  do jloc = 1, nloc
                     do isam = 1, NSAM
                        do jrow = 1, NROW
                             A_loc(isam,jrow,jloc) 
     &                     = A_buf(isam,jrow,jloc)
                        enddo
                     enddo
                  enddo
               endif
            enddo
            if (allocated(A_buf)) deallocate(A_buf)
        else

c           === slaves receive local pieces ===

            call MPI_RECV(A_loc , nsam*nrow*nexploc, MPI_REAL,
     &                    0     , MPI_ANY_TAG       , comm    ,
     &                    istat , ierr)
            if (ierr .ne. 0) then
               write(6,*) ' recv failed'
               stop
            endif
        endif

        allocate(DLIST_loc(7,nexploc),stat=irtflg)
        if (irtflg .ne. 0) then
           write(6,*) ' mrqli_ps: failed to allocate DLIST_loc'
           return
        endif
#ifdef MPI_DEBUG
        write(6,444) mypid
 444    format(1x,'mrqli_ps: calling apmq2d.., mypid = ', I3)
#endif
        DO  IT=1,nexploc
              imi = nbase(mypid+1) + it
	      CALL APRQ2D(A_loc(1,1,IT),BFC,TT,NUMR,
     &	            NSAM,NROW,ISHRANGE,ISTEP,
     &	            NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &              REFDIR,EXPDIR(1,IEXPT),RANGE,
     &              DLIST_loc(2,IT),DLIST_loc(3,IT),
     &              DLIST_loc(4,IT),DLIST_loc(5,IT),
     &              DLIST_loc(6,IT),NIMALCG,CKMIRROR,LIMITRANGE)
d326 3
a328 5
        ENDDO
c
        DO IT=1,nexploc
           iglb = nbase(mypid+1) + it

d331 23
a353 11

           IREF    = INT(DLIST_loc(2,IT))
           IREFABS = ABS(IREF)
                                                                                
           DLIST_loc(2,IT) = 0.0
           IF (IREFABS .NE. 0) THEN
C             SAVE NUMBER OF MOST SIMILAR REF. IMAGE
              DLIST_loc(2,IT) = ILIST(IREFABS)
                                                                               
C             SET NUMBER <0 IF MIRRORED
              IF (IREF .LT. 0) DLIST_loc(2,IT) = -DLIST_loc(2,IT)
d355 19
a373 2
                                                                                
           DLIST_loc(7,IT) = ILIP(iglb)
d375 28
a402 58
        call MPI_BARRIER(comm,ierr)

c       === the master collect all the results from slaves ===

        master = 0
        if (mypid .eq. 0) then
           do it = 1, nexploc
               CALL LUNDOCWRTDAT(LUNDOC,IT,DLIST_loc(2,IT),NLIST-1,
     &                           IRTFLG)
           enddo

           call flushfile(LUNDOC)

           do iloc = 2, nprocs
              nloc = psize(iloc)
              tag  = iloc - 1
              write(6,777) iloc-1
 777          format(' mrqli_ps: trying to receive from ', I5)
              call flushfile(6)
              call MPI_RECV(DLIST_loc, nloc*7, MPI_REAL, iloc-1,
     &                      tag      , comm  , istat   , ierr)
#ifdef MPI_DEBUG
              write(6,888) iloc-1
 888          format(1x,'mrqli_ps: received from          ', I5)
              call flushfile(6)
#endif
              do it = 1, nloc
                 iglb = nbase(iloc) + it
                 CALL LUNDOCWRTDAT(LUNDOC,iglb,DLIST_loc(2,IT),NLIST-1,
     &                             IRTFLG)
              enddo
              call flushfile(LUNDOC)
           enddo
        else
           tag = mypid
#ifdef MPI_DEBUG
           write(6,333) mypid
 333       format(' mrqli_ps: sending to master, mypid = ', I3)
           call flushfile(6)
#endif
           call MPI_SEND(DLIST_loc, nexploc*7,
     &                   MPI_REAL , master    ,
     &                   tag      , comm      ,
     &                   ierr)
#ifdef MPI_DEBUG
           write(6,555) mypid
 555       format(' mrqli_ps: myid = ', I3, ' sent to master')
           call flushfile(6)
#endif
c           IBCNT = IBCNT + 1
        endif 

 9999   continue
        call MPI_BARRIER(comm,ierr)
        if (mypid .eq. 0) then
           CALL SAVDC
           CLOSE(LUNDOC)
        endif
d491 6
a496 4
        IF (allocated(A_loc))      DEALLOCATE(A_loc)
        IF (allocated(psize))      DEALLOCATE(psize)
        IF (allocated(nbase))      DEALLOCATE(nbase) 
        IF (allocated(DLIST_loc))  DEALLOCATE(DLIST_loc)
@


1.70
log
@if limitrange no longer finds cc for both mirror & non-mirror (if chkmirror)
@
text
@d567 2
a568 2
                write(6,*) 'imi: ',imi,' dt: ',dt,' dtabs: ',dtabs, 
     &              refdir(1,imi),refdir(2,imi),refdir(3,imi)
d572 1
a572 1
          write(6,*) ' '
d635 1
a635 1
C                   GOOD MATCH WITH NON-MIRRORED POSITION 
@


1.69
log
@CROSRNG_E SPEEDS UP
@
text
@d178 8
d540 4
a543 1
        IF (LIMITRANGE) THEN
d567 1
a567 1
C                write(6,*) 'imi: ',imi,' dt: ',dt,' dtabs: ',dtabs, 
d572 1
a572 1
c          write(6,*) ' '
d617 1
a617 1
C                      CHECK ONLY NON-MIRRORED POSITION 
a626 10

                       IF (TMTA .GE. CCROTD) THEN
C                         GOOD MATCH WITH MIRRORED POSITION 
	                  CCROTD  = TMTA
	                  IBE     = IR
	                  ISX     = IT
	                  ISY     = JT
	                  RANGNEW =  ANG_N(TMT,MODE,MAXRIN)
	                  IDIS    = -IR
	               ENDIF
a642 1

d645 12
@


1.68
log
@parabolic interp on edge bug
@
text
@d12 1
d524 1
d540 1
d545 1
a545 1
	      DT = ABS(EXPDIR(1) * REFDIR(1,IMI) + 
d548 3
a550 1
              IF (DT .GE. RANGE)  THEN
d554 5
d561 1
d601 2
a602 2
                IF (LIMITRANGE) IR = LCG(IRR)

d604 23
a626 14
C                   CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS 
	            CALL CROSRNG_MS(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		           MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)

                    IF (TMTA .GE. CCROTD) THEN
C                      GOOD MATCH WITH MIRRORED POSITION 
	               CCROTD  = TMTA
	               IBE     = IR
	               ISX     = IT
	               ISY     = JT
	               RANGNEW =  ANG_N(TMT,MODE,MAXRIN)
	               IDIS    = -IR
	            ENDIF

d628 3
a630 3
C                   DO NOT EVEN CHECK MIRRORED POSITION
	            CALL CROSRNG_DS(BFC(1,IR),A_CIRC,LCIRC,NRING,
     &		                  MAXRIN,NUMR,TOTA,TOT,TT)
d641 2
d679 4
a682 3
                       IF (IDIS .LT. 0) THEN
C                         MIRRORED
	                  CALL CROSRMG_DS(BFC(1,IBE),A_CIRC,
d684 1
a684 7
     &                           ROTMP(IT,JT),TT)

                       ELSE
C                         NOT-MIRRORED
	                  CALL CROSRNG_DS(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		                 MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
                       ENDIF
a685 1

d739 5
a743 8
                 IF (IDIS .LT. 0) THEN
C                   MIRRORED
	            CALL CROSRMG_DS(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		            MAXRIN,NUMR,CCROTD,RANGNEW,TT)
                 ELSE
	            CALL CROSRNG_DS(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		                 MAXRIN,NUMR,CCROTD,RANGNEW,TT)
                 ENDIF
@


1.67
log
@ NORMASS USED FOR ALTIX
@
text
@d11 1
d709 1
d734 4
@


1.66
log
@limitrange for not sh g3tanga
@
text
@d10 1
d575 1
a575 1
	      CALL NORMAS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,
d648 1
a648 1
	               CALL NORMAS(A, NSB-(IT+ISX),NSE-(IT+ISX),
d713 1
a713 1
	         CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
@


1.65
log
@AP SH, AP REF major changes
@
text
@d136 1
a136 1
        IF (RANGE .GT. 0 .OR. CTYPE(1:2) .EQ. 'SH') THEN
@


1.64
log
@c yangs mpi
@
text
@d9 1
d37 1
a37 1
     &               LSAM,LROW,NR,LENTT,NSI,ISTEP,
d39 2
a40 2
     &               MODE, REFANG,EXPANG,SCRFILE,
     &               REFPAT,EXPPAT,RANGE,CTYPE)
d49 3
a51 1
	LOGICAL                                :: BFC_IN_CORE
d53 1
a53 1
        CHARACTER (LEN=*)                      :: REFANG,EXPANG
d60 1
d65 2
a66 2
	REAL, ALLOCATABLE,DIMENSION(:,:)       :: SA 
	REAL, ALLOCATABLE,DIMENSION(:,:)       :: TA
d69 1
a69 1
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d72 2
a73 1
	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/
d89 2
d93 8
a100 2
        MAXRIN = NUMR(3,NRING)
        IF (CTYPE(1:2) .EQ. 'RQ') RANGE  = COS(RANGE*DGR_TO_RAD)
d124 3
a126 1
	ALLOCATE(A(LSAM,LROW,NUMTH), DLIST(NLIST,NUMTH),  STAT=IRTFLG)
d128 1
a128 1
           MWANT = LSAM*LROW*NUMTH + NLIST*NUMTH  
d135 5
a139 2
        IF (CTYPE(1:2) .EQ. 'RQ') THEN
	   ALLOCATE(SA(3,NIMA), TA(3,NIDI),STAT=IRTFLG)
d141 2
a142 2
               MWANT = 3*NIMA + 3*NIDI 
               CALL  ERRT(46,'SA, TA',MWANT)
d145 1
d147 3
a149 3
C          READ REF. ANGLES & CONVERT TO SA (UNITARY DIRECTIONAL VECTORS.
	   CALL AP_GETANG(ILIST,NIMA,0,REFANG,REFPAT,
     &                    INPIC,INANG,SA,IRTFLG)
d152 19
a170 3
C          READ EXP. ANGLES & CONVERT TO TA (UNITARY DIRECTIONAL VECTOR
	   CALL AP_GETANG(ILIP,NIDI,0,EXPANG,EXPPAT,
     &                    INPIC,INANG,TA,IRTFLG)
d172 4
a175 1
        ENDIF
d178 1
a178 1
c
d180 1
a180 1
c
d185 2
a186 2
        end if
c
d192 1
a192 1
c
d195 1
a195 1
c
d202 1
a202 1
c
d206 1
a206 1
 111    format(1x,'mrqli_ps: nbase = ', I5, ' mypid = ', I5)
d209 1
a209 1
c
d212 1
a212 1
c
d214 1
a214 1
c
d216 1
a216 1
c
d221 2
a222 2
            end if
c
d225 1
a225 1
c
d227 5
a231 5
c
                  IMIT = nbase(iproc) + 1
                  IEND = nbase(iproc) + nloc 
                  CALL AP_GETDAT(ILIP,NIMA,LSAM,LROW,LSAM,LROW,
     &                           NUMTH,EXPPAT,INPIC, IMIT,IEND,
d234 1
a234 1
c
d239 1
a239 1
 222              format(1x, 'mrqli_ps: sending to pid = ', I3)
d245 1
a245 1
c
d247 1
a247 1
c
d253 5
a257 5
                        end do
                     end do
                  end do
               end if
            end do
d260 1
a260 1
c
d262 1
a262 1
c
d269 3
a271 3
            end if
        end if
c
d276 1
a276 1
        end if
d284 1
a284 1
     &	            NSAM,NROW,NSI,ISTEP,
d286 1
a286 1
     &              SA,TA(1,IMI),RANGE,
d289 1
a289 1
     &              DLIST_loc(6,IT),CTYPE)
d301 1
a301 1
C 
d304 3
a306 3
C
           IMI    = INT(DLIST_loc(2,IT))
           IMIABS = ABS(IMI)
d309 1
a309 1
           IF (IMIABS .NE. 0) THEN
d311 1
a311 1
              DLIST_loc(2,IT) = ILIST(IMIABS)
d314 1
a314 1
              IF (IMI .LT. 0) DLIST_loc(2,IT) = -DLIST_loc(2,IT)
d320 1
a320 1
c
d322 1
a322 1
c
d326 1
a326 1
               CALL LUNDOCWRTDAT(NDOC,IT,DLIST_loc(2,IT),NLIST-1,
d328 4
a331 2
           end do
           call flushfile(NDOC)
d336 1
a336 1
 777          format(1x,'mrqli_ps: trying to receive from ', I5)
d347 1
a347 1
                 CALL LUNDOCWRTDAT(NDOC,iglb,DLIST_loc(2,IT),NLIST-1,
d349 3
a351 3
              end do
              call flushfile(NDOC)
           end do
d356 1
a356 1
 333       format(1x, 'mrqli_ps: sending to master, mypid = ', I3)
d365 1
a365 1
 555       format(1x,'mrqli_ps: myid = ', I3, ' sent to master')
d369 2
a370 2
        end if 
c
d375 1
a375 1
           CLOSE(NDOC)
d377 1
a377 1
c
d380 1
a380 1
 	DO IMIT=1,NIDI,NUMTH
d383 3
a385 3
           IEND = MIN(NIDI,IMIT+NUMTH-1)
	   CALL AP_GETDAT(ILIP,NIMA,LSAM,LROW,LSAM,LROW,
     &                       NUMTH,EXPPAT,INPIC, IMIT,IEND,
d391 3
a393 3
c$omp      parallel do private(IMI)
	   DO IMI=IMIT,MIN(NIDI,IMIT+NUMTH-1)
              IT = IMI-IMIT+1
d396 1
a396 1
     &	            NSAM,NROW,NSI,ISTEP,
d398 1
a398 1
     &              SA,TA(1,IMI),RANGE,
d400 2
a401 1
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),CTYPE)
d412 4
a415 2
           DO ITI=IMIT,MIN(NIDI,IMIT+NUMTH-1)
              IT = ITI-IMIT+1
d420 22
a441 10
              IMI    = INT(DLIST(2,IT))
              IMIABS = ABS(IMI)

              DLIST(2,IT) = 0.0
              IF (IMIABS .NE. 0) THEN
C                SAVE NUMBER OF MOST SIMILAR REF. IMAGE
                 DLIST(2,IT) = ILIST(IMIABS)

C                SET NUMBER <0 IF MIRRORED
                 IF (IMI .LT. 0) DLIST(2,IT) = -DLIST(2,IT) 
d443 13
a456 2
              DLIST(7,IT) = ILIP(ITI)
              CALL LUNDOCWRTDAT(NDOC,ITI,DLIST(2,IT),NLIST-1,IRTFLG)
d460 1
a460 2
C       OVER AND OUT
9999    CLOSE(NDOC)
d468 1
a468 1
        IF (allocated(DLIST_loc))   deallocate(DLIST_loc)
d473 3
a475 2
	IF (ALLOCATED(SA))         DEALLOCATE(SA)
	IF (ALLOCATED(TA))         DEALLOCATE(TA)
d485 8
a492 3
C  OUTPUT PARAMETERS:
C                NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C                CORR COEFF.(D5), ANGLE (D4), SHIFT: XSHSUM, YSHSUM
d497 5
a501 4
     &	                NSAM,NROW,NSI,ISTEP,
     &	                NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &                  SA,TA,RANGE,
     &                  D2,D5,D4,XSHSUM,YSHSUM,CTYPE)
d508 2
a509 3
        CHARACTER (LEN=*)                 :: CTYPE
	REAL, DIMENSION(3,NIMA)           :: SA
	REAL, DIMENSION(3 )               :: TA
d518 1
a518 1
	DOUBLE PRECISION                   :: QT,QM,PEAK
d520 1
a520 1
        LOGICAL                            :: MIRRORCK
d522 1
a522 1
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d525 1
a525 2
        MIRRORCK = (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &             (CTYPE(1:2) .EQ. 'RQ' .AND. CTYPE(3:3) .NE. 'N'))
d527 2
a528 2
        IEND = NIMA
        IF (CTYPE(1:2) .EQ. 'RQ') THEN
d539 6
a544 3
	      DT = ABS(TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI))
	      IF (DT .GE. RANGE) THEN
C                THIS REFERENCE IS WITHIN SEARCH RANGE
d547 1
a547 1
	      ENDIF
d549 1
d552 5
a556 5
              XSHSUM = 0
	      YSHSUM = 0
              D2     = 0
              D4     = 0
              D5     = -1.0 
d560 1
a561 1

d563 1
a563 2
	QT = -1.0D23
	QM = -1.0D23
d566 1
a566 1
	DO JT=-NSI,NSI,ISTEP
d568 1
a568 1
	   DO IT=-NSI,NSI,ISTEP
d573 1
d577 1
d588 1
d590 3
a592 4
                 IF (CTYPE(1:2) .EQ. 'MQ' .OR. CTYPE(1:2) .EQ. 'RQ')THEN

                    IF (CTYPE(1:2) .EQ. 'RQ') IR = LCG(IRR)
	            CALL CROSRNG_MS (BFC(1,IR),A_CIRC,LCIRC,NRING,
d595 8
a602 7
	            IF (TMTA .GE. QM)  THEN
	               QM   = TMTA
	               IME  = IR
	               IMX  = IT
	               IMY  = JT
	               E4   =  ANG_N(TMT,MODE,MAXRIN)
	               IDIM = -IR
d605 2
a606 1
                 ELSE IF (CTYPE(1:2) .EQ. 'NQ') THEN 
d611 8
a618 8
	         IF (TOTA .GE. QT)  THEN
	            QT   = TOTA
	            IBE  = IR
	            ISX  = IT
	            ISY  = JT
	            D4   = ANG_N(TOT,MODE,MAXRIN)
	            IDIS = IR
	            D6   = IR
d621 1
d623 1
a623 1
C             END-OF-LOOP 1 OVER REFERENCE IMAGES
d625 1
a627 2
C       TRY TO INTERPOLATE FOR NOT-MIRRORED
        DLIST2 = D6
d629 5
a633 3
	IF (QT .GT. QM .OR. .NOT. MIRRORCK)  THEN
C          FOR NOT-MIRRORED
           D2 = IDIS
d636 1
a636 1
	   IF (IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d638 3
a640 2
	      FIT(0,0)   = QT
	      ROTMP(0,0) = D4
d644 2
a645 2
	               CNR2=NROW/2+1+JT+ISY
	               CNS2=NSAM/2+1+IT+ISX
d655 11
a665 4

	               CALL CROSRNG_DS(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		            MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)

d669 1
d671 1
d683 4
a686 4
	                  AFIT = FIT(IT,JT)
	                  D4   = ROTMP(IT,JT)
	                  ITMA = IT
	                  JTMA = JT
d700 4
a703 4
	      QT  = AFIT
	      ISX = ISX+ITMA
	      ISY = ISY+JTMA
	      CALL  PARABLD(FITP,SX,SY,PEAK)
d720 11
a730 9
	         CALL CROSRNG_DS(BFC(1,IBE),A_CIRC,LCIRC,NRING,
     &		                 MAXRIN,NUMR,QT,D4,TT)
	         D5 = QT
	         D4 = ANG_N(D4,MODE,MAXRIN)
	      ELSE
C                INTERPOLATION FAILED
	         D5  = QT
	         SX  = ISX
	         SY  = ISY
a731 4
	   ELSE
	      D5 = QT
	      SX = ISX
	      SY = ISY
a733 99
	ELSE
           D2 = IDIM

C          INTERPOLATE FOR MIRRORED
	   IF (IABS(IMX).NE.NSI .AND. IABS(IMY).NE.NSI)  THEN
C             HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)   = QM
	      ROTMP(0,0) = E4
	      DO JT=-ISTEP,ISTEP
	         DO IT=-ISTEP,ISTEP
	            IF (IT.NE.0 .OR. JT.NE.0) THEN
	               CNR2 = NROW/2+1+JT+IMY
	               CNS2 = NSAM/2+1+IT+IMX
	               CALL NORMAS(A,NSB-(IT+IMX),NSE-(IT+IMX),
     &                             NRB-(JT+IMY),NRE-(JT+IMY),
     &	                           NUMR,NUMR(1,NRING))

	               CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,
     &                              A_CIRC,LCIRC,NRING,MODE)

	               CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

	               CALL CROSRMG_DS(BFC(1,IME),A_CIRC,
     &                     LCIRC,NRING,MAXRIN,NUMR,FIT(IT,JT),
     &                     ROTMP(IT,JT),TT)

	               ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODEi,
     &                     MAXRIN)
	            ENDIF
	         ENDDO
	      ENDDO

C             FIND THE MAXIMUM WITHIN +/-ISTEP
C             MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	      AFIT = FIT(0,0)
	      JTMA = 0
	      ITMA = 0
	      IF (ISTEP.GT.1)  THEN
	         DO JT=-ISTEP+1,ISTEP-1
	            DO IT=-ISTEP+1,ISTEP-1
	               IF (FIT(IT,JT) .GT. AFIT)  THEN
	                  AFIT = FIT(IT,JT)
	                  E4   = ROTMP(IT,JT)
	                  ITMA = IT
	                  JTMA = JT
	               ENDIF
	            ENDDO
	         ENDDO
	      ENDIF

C             COPY VALUES AROUND THE PEAK.
	      DO JT=-1,1
	         DO IT=-1,1
	            FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	         ENDDO
	      ENDDO

C             UPDATE LOCATION OF THE PEAK
	      QM  = AFIT
	      IMX = IMX+ITMA
	      IMY = IMY+JTMA
	      CALL PARABLD(FITP,SX,SY,PEAK)

C             CHECK WHETHER INTERPOLATION IS OK.
	      IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	         SX=SX+IMX
	         SY=SY+IMY
	         CNR2=NROW/2+1+SY
	         CNS2=NSAM/2+1+SX

	         CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,
     &                        NUMR,NUMR(1,NRING))

	         CALL ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
     &                         LCIRC,NRING,MODE)

	         CALL FRNGS(A_CIRC,LCIRC,NUMR,NRING)

	         CALL CROSRMG_DS(BFC(1,IME),A_CIRC,LCIRC,NRING,
     &		            MAXRIN,NUMR,QM,D4,TT)
	         D5 = QM
	         D4 = ANG_N(D4,MODE,MAXRIN)

	      ELSE
C                INTERPOLATION FAILED
	         SX = IMX
	         SY = IMY
	         D4 = E4
	         D5 = QM
	      ENDIF

	   ELSE
	      SX = IMX
	      SY = IMY
	      D4 = E4
	      D5 = QM
	   ENDIF
	ENDIF
 
d741 4
a744 5
	CO     = COS(D4*DGR_TO_RAD)
	SO     = -SIN(D4*DGR_TO_RAD)
	XSHSUM = SX*CO-SY*SO
	YSHSUM = SX*SO+SY*CO
        
@


1.63
log
@rewrite
@
text
@d69 17
a85 1

d108 3
a110 1

d118 1
d139 200
d396 1
d399 6
d407 1
@


1.62
log
@*** empty log message ***
@
text
@d3 1
a3 1
C    MRQLI.F        USED CMLIMIT                  AUG 00 ARDEAN LEITH
d8 1
a8 1
C                   APMASTER                      AUG 03 ARDEAN LEITH
d21 1
a21 1
C  PARAMETERS:  MAKEREFFILE   CREATE BFC FILE              (INPUT)
a34 6
C **************************************************************************
C
C  MRQLI_PS
C
C--************************************************************************

a186 468
C++************************************************************************
C
C MRQLI_SS.F
C
C  VERSION FOR MP AND A SMALL NUMBER OF IMAGES TO BE ALIGNED
C  NEEDS ERROR RECOVERY
C
C--************************************************************************


       SUBROUTINE MRQLI_SS(ILIST,NIMA,ILIP,NIDI, 
     &               LSAM,LROW,NR,LENTT,NSI,ISTEP,
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
     &               MODE,REFANG,EXPANG,SCRFILE,
     &               REFPAT,EXPPAT,RANGE,CTYPE)

	INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

	INTEGER, DIMENSION(NIMA)            :: ILIST
	INTEGER, DIMENSION(NIDI)            :: ILIP
	INTEGER, DIMENSION(3,NRING)         :: NUMR
	REAL, DIMENSION(LCIRC,NIMA)         :: BFC
	LOGICAL                             :: BFC_IN_CORE
	CHARACTER(LEN=1)                    :: MODE 
        CHARACTER (LEN=*)                   :: REFANG,EXPANG,SCRFILE
        CHARACTER (LEN=*)                   :: REFPAT,EXPPAT
        CHARACTER (LEN=*)                   :: CTYPE

        PARAMETER (NLIST=7)
        REAL, DIMENSION(NLIST)              :: DLIST
	DOUBLE PRECISION  FITP(-1:1,-1:1)
	DOUBLE PRECISION                    :: QT,QM,PEAK

C       AUTOMATIC ARRAYS
	DOUBLE PRECISION  TOTA(NIMA,-NSI:NSI,-NSI:NSI)
	DOUBLE PRECISION  TMTA(NIMA,-NSI:NSI,-NSI:NSI)
	DIMENSION         TOT(NIMA, -NSI:NSI,-NSI:NSI),
     &                    TMT(NIMA, -NSI:NSI,-NSI:NSI)
	DOUBLE PRECISION  FIT(  -ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION         ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DOUBLE PRECISION, DIMENSION(LENTT)    :: TT
	INTEGER, DIMENSION(NIMA)              :: LCG

C       ALLOCATED ARRAYS
	REAL, ALLOCATABLE, DIMENSION(:,:,:)   :: A_CIRC
	REAL, ALLOCATABLE, DIMENSION(:,:,:,:) :: AA
	REAL, ALLOCATABLE, DIMENSION(:,:)     :: A
	REAL, ALLOCATABLE,DIMENSION(:,:)      :: SA 
	REAL, ALLOCATABLE,DIMENSION(:,:)      :: TA
 
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))

	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

        MAXRIN = NUMR(3,NRING)
	RANGE  = COS(RANGE*DGR_TO_RAD)

C       FIND DIVAS, NUMTH, NSAM, & NROW
	CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                  TT,LENTT)

C       READ REFERENCE IMAGES INTO REFERENCE RINGS (BFC) ARRAY 
        CALL APRINGS(ILIST,NIMA, 
     &               LSAM,LROW,LSAM,LROW,
     &               NRING,LCIRC,NUMR,MODE,
     &               REFPAT,INPIC,BFC,BFC_IN_CORE,
     &               NSCF,SCRFILE,IRTFLG)

        NSAM = LSAM
        NROW = LROW

C       CALCULATE DIMENSIONS FOR NORMAS
	NSB=-NSAM/2
	NSE=-NSB-1+MOD(NSAM,2)
	NRB=-NROW/2
	NRE=-NRB-1+MOD(NROW,2)

	NSIS = MAX(NSI/ISTEP,ISTEP)
	ALLOCATE(A_CIRC(LCIRC,-NSIS:NSIS,-NSIS:NSIS),
     &           A(NSAM,NROW), AA(NSAM,NROW,-NSIS:NSIS,-NSIS:NSIS),
     &           STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = LCIRC*2*NSIS * 2*NSIS + NSAM*NROW + NSAM*NROW*2*NSIS
           CALL  ERRT(46,' A_CIRC,....',MWANT)
           GOTO 9999
        ENDIF 
CCH

        IEND = NIMA
        IF (CTYPE(1:2) .EQ. 'RQ') THEN
	   ALLOCATE(SA(3,NIMA), TA(3,NIDI),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
               MWANT = 3*NIMA + 3*NIDI 
               CALL  ERRT(46,'SA, TA',MWANT)
               RETURN
           ENDIF 

C          READ REF. ANGLES & CONVERT TO SA (UNITARY DIRECTIONAL VECTORS.
	   CALL AP_GETANG(ILIST,NIMA,0,REFANG,REFPAT,
     &                    INPIC,INANG,SA,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          READ EXP. ANGLES & CONVERT TO TA (UNITARY DIRECTIONAL VECTOR
	   CALL AP_GETANG(ILIP,NIDI,0,EXPANG,EXPPAT,
     &                    INPIC,INANG,TA,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF

C       LOOP OVER EXP. IMAGES TO BE ALIGNED
	DO IMI=1,NIDI
           IF (CTYPE(1:2) .EQ. 'RQ') THEN
	      NIMALCG = 0
	      DO IMIR=1,NIMA
C                LOOP OVER REFERENCE IMAGES 
	         DT = ABS(TA(1,IMI)*SA(1,IMIR) +
     &                    TA(2,IMI)*SA(2,IMIR) +
     &                    TA(3,IMI)*SA(3,IMIR))

	         IF (DT .GE. RANGE) THEN
	             NIMALCG      = NIMALCG + 1
	             LCG(NIMALCG) = IMIR
	         ENDIF
                 IEND = NIMALCG
	      ENDDO

              IF (NIMALCG .LE. 0) THEN
C                NO NEARBY REFERENCE IMAGES
                 DLIST(2) =  0.0
                 DLIST(3) = -1.0
                 DLIST(4) =  0.0
                 DLIST(5) =  0.0
                 DLIST(6) =  0.0
                 DLIST(7) = ILIP(IMI)

                 CALL LUNDOCWRTDAT(NDOC,IMI,DLIST(2),NLIST-1,IRTFLG)
                 CYCLE
              ENDIF
           ENDIF

C          LOAD EXP. IMAGE DATA FOR THIS IMAGE
	   CALL AP_GETDAT(ILIP,NIMA,lSAM,lROW,lSAM,lROW,
     &                       NUMTH,EXPPAT,INPIC,IMI,IMI,
     &                       1,LROW,1,LSAM, A,
     &                       IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          GO THROUGH REFERENCE IMAGES AND CENTERS
c$omp      parallel do private(jt,it,irr,ir,cnr2,cns2)
           DO JT=-NSI,NSI,ISTEP
              CNR2=NROW/2+1+JT

              DO IT=-NSI,NSI,ISTEP
                 CNS2=NSAM/2+1+IT

C                NORMALIZE UNDER THE MASK

	         CALL NORMASC(A,AA(1,1,IT/ISTEP,JT/ISTEP),
     &                NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))

                 CALL ALRQ_MS(AA(1,1,IT/ISTEP,JT/ISTEP),NSAM,NROW,
     &                CNS2,CNR2,NUMR,A_CIRC(1,IT/ISTEP,JT/ISTEP),
     &                LCIRC,NRING,MODE)

	         CALL FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                NUMR,NRING)
CCH
                 DO IRR=1,IEND
C                   LOOP OVER REFERENCE IMAGES
                    IR = IRR
                    IF (CTYPE(1:2) .EQ. 'RQ') IR = LCG(IRR)
CCH*
                    IF (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &                  CTYPE(1:2) .EQ. 'RQ')THEN
	               CALL CROSRNG_MS(BFC(1,IR),
     &                      A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                      NRING,MAXRIN,NUMR,
     &                      TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &                      TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)

                    ELSE IF (CTYPE(1:2) .EQ. 'NQ') THEN
	               CALL CROSRNG_DS(BFC(1,IR),
     &                      A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                      NRING, MAXRIN,NUMR,
     &	                    TOTA(IR,IT,JT),TOT(IR,IT,JT),TT)

                    ENDIF
	         ENDDO
              ENDDO
           ENDDO

C          END OF THE PARALLEL SECTION
C          LOCATE BEST MATCH

           QT=-1.0D23
           QM=-1.0D23
           DO JT=-NSI,NSI,ISTEP
              DO IT=-NSI,NSI,ISTEP
CCH
                 DO IRR=1,IEND
C                   LOOP OVER REFERENCE IMAGES
                    IR = IRR
                    IF (CTYPE(1:2) .EQ. 'RQ') IR = LCG(IRR)
CCH*
                    IF (TOTA(IR,IT,JT) .GE. QT)  THEN
	               QT   = TOTA(IR,IT,JT)
	               IBE  = IR
                       ISX  = IT
                       ISY  = JT
                       D4   = ANG_N(TOT(IR,IT,JT),MODE,MAXRIN)
                       D6   = ILIST(IR)
                    ENDIF

                    IF (CTYPE .NE. 'NQ'.AND. TMTA(IR,IT,JT) .GE. QM)THEN
                       QM   = TMTA(IR,IT,JT)
                       IME  = IR
                       IMX  = IT
                       IMY  = JT
                       E4   = ANG_N(TMT(IR,IT,JT),MODE,MAXRIN)
                       E6   = -ILIST(IR)
                    ENDIF
                 ENDDO
              ENDDO
           ENDDO

C          TRY TO INTERPOLATE
	   IF (QT .GT. QM .OR. 
     &         CTYPE(3:3) .EQ. 'N' .OR.
     &         CTYPE(1:2) .EQ. 'NQ')  THEN
C             FOR NOT-MIRRORED

              DLIST(2) = D6

C             DO NOT INTERPOLATE FOR POINT ON THE EDGE

	      IF (IABS(ISX).NE.NSI .AND. IABS(ISY).NE.NSI)  THEN
C                HAVE TO FIND NEIGHBOURING VALUES
	         FIT(0,0)=QT
	         ROTMP(0,0)=D4
c$omp            parallel do private(jt,it,cnr2,cns2)
	         DO JT=-ISTEP,ISTEP
	            DO IT=-ISTEP,ISTEP
	               IF (IT.NE.0 .OR. JT.NE.0) THEN
	                  CNR2=NROW/2+1+JT+ISY
	                  CNS2=NSAM/2+1+IT+ISX

	                  CALL NORMASC(A,AA(1,1,IT,JT),
     &	                      NSB-(IT+ISX),NSE-(IT+ISX),NRB-(JT+ISY),
     &                        NRE-(JT+ISY),NUMR,NUMR(1,NRING))

	                  CALL  ALRQ_MS
     &                       (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &                        A_CIRC(1,IT,JT),LCIRC,NRING,MODE)

	                  CALL FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)

	                  CALL CROSRNG_DS(BFC(1,IBE),
     &                        A_CIRC(1,IT,JT),LCIRC,NRING,
     &		              MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)

	                  ROTMP(IT,JT) = ANG_N(ROTMP(IT,JT),MODE,MAXRIN)
	               ENDIF
	            ENDDO
	         ENDDO
	         
C                FIND THE MAXIMUM WITHIN +/-ISTEP
C                MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	         AFIT=FIT(0,0)
	         JTMA=0
	         ITMA=0
	         IF (ISTEP .GT. 1)  THEN
	            DO JT=-ISTEP+1,ISTEP-1
	               DO IT=-ISTEP+1,ISTEP-1
	                  IF (FIT(IT,JT) .GT. AFIT)  THEN
	                     AFIT = FIT(IT,JT)
	                     D4   = ROTMP(IT,JT)
	                     ITMA = IT
	                     JTMA = JT
	                  ENDIF
	               ENDDO
	            ENDDO
	         ENDIF

C                COPY VALUES AROUND THE PEAK.
	         DO JT=-1,1
	            DO IT=-1,1
	               FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	            ENDDO
	         ENDDO

C                UPDATE LOCATION OF THE PEAK
	         QT  = AFIT
	         ISX = ISX+ITMA
	         ISY = ISY+JTMA

	         CALL PARABLD(FITP,SX,SY,PEAK)

C                CHECK WHETHER INTERPOLATION IS OK.
	         IF (ABS(SX) .LT. 1.0 .AND. ABS(SY) .LT. 1.0)  THEN
	            SX   = SX+ISX
	            SY   = SY+ISY
	            CNR2 = NROW/2+1+SY
	            CNS2 = NSAM/2+1+SX

	            CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
     &                   NUMR,NUMR(1,NRING))

	            CALL ALRQ_M(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,
     &                   LCIRC,NRING,MODE)

	            CALL FRNG(A_CIRC,LCIRC,NUMR,NRING)

	            CALL CROSRNG_DS(BFC(1,IBE),A_CIRC,LCIRC,
     &                   NRING,MAXRIN,NUMR,QT,D4,TT)

	            D5 = QT
	            D4 = ANG_N(D4,MODE,MAXRIN)
	         ELSE
C                   INTERPOLATION FAILED
	            D5 = QT
	            SX = ISX
	            SY = ISY
	         ENDIF
	      ELSE
	         D5 = QT
	         SX = ISX
	         SY = ISY
              ENDIF

	   ELSE
              DLIST(2)=E6

C             INTERPOLATE FOR MIRRORED
	      IF (IABS(IMX).NE.NSI .AND. IABS(IMY).NE.NSI)  THEN
C                HAVE TO FIND NEIGHBOURING VALUES
	         FIT(0,0)   = QM
	         ROTMP(0,0) = E4
c$omp            parallel do private(jt,it,cnr2,cns2)
	         DO JT=-ISTEP,ISTEP
	            DO IT=-ISTEP,ISTEP
	               IF (IT.NE.0 .OR. JT.NE.0) THEN
	                 CNR2 = NROW/2+1+JT+IMY
	                 CNS2 = NSAM/2+1+IT+IMX

	                 CALL NORMASC(A,AA(1,1,IT,JT),
     &	                     NSB-(IT+IMX),NSE-(IT+IMX),NRB-(JT+IMY),
     &                       NRE-(JT+IMY), NUMR,NUMR(1,NRING))

	                 CALL ALRQ_MS
     &                      (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &                      A_CIRC(1,IT,JT),LCIRC,NRING,MODE)

	                 CALL FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)

	                 CALL CROSRMG_DS
     &		         (BFC(1,IME),A_CIRC(1,IT,JT),LCIRC,NRING,
     &		            MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)

	                 ROTMP(IT,JT)=ANG_N(ROTMP(IT,JT),MODE,MAXRIN)
	              ENDIF
	           ENDDO
	        ENDDO

C               FIND THE MAXIMUM WITHIN +/-ISTEP
C               MAXIMUM CANNOT BE ON THE EDGE, I.E., IT,JT/=ISTEP
	        AFIT = FIT(0,0)
	        JTMA = 0
	        ITMA = 0
	        IF (ISTEP .GT. 1)  THEN
	           DO JT=-ISTEP+1,ISTEP-1
	              DO IT=-ISTEP+1,ISTEP-1
	                  IF (FIT(IT,JT) .GT. AFIT)  THEN
	                     AFIT   = FIT(IT,JT)
	                     E4     = ROTMP(IT,JT)
	                     ITMA   = IT
	                     JTMA   = JT
	                  ENDIF
	               ENDDO
	            ENDDO
	         ENDIF

C                COPY VALUES AROUND THE PEAK.
	         DO JT=-1,1
	            DO IT=-1,1
	               FITP(IT,JT) = FIT(ITMA+IT,JTMA+JT)
	            ENDDO
	         ENDDO

C                UPDATE LOCATION OF THE PEAK
	         QM  = AFIT
	         IMX = IMX+ITMA
	         IMY = IMY+JTMA

	         CALL PARABLD(FITP,SX,SY,PEAK)

C                CHECK WHETHER INTERPOLATION IS OK.
	         IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	            SX=SX+IMX
	            SY=SY+IMY
	            CNR2 = NROW/2+1+SY
	            CNS2 = NSAM/2+1+SX
	            CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,
     &                          NUMR,NUMR(1,NRING))

	            CALL ALRQ_M(A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,
     &                  NRING,MODE)

	            CALL FRNG(A_CIRC,LCIRC,NUMR,NRING)

	            CALL CROSRMG_DS (BFC(1,IME),A_CIRC,LCIRC,
     &                  NRING,MAXRIN,NUMR,QM,D4,TT)

	            D5 = QM
	            D4 = ANG_N(D4,MODEi,MAXRIN)
	         ELSE
C                   INTERPOLATION FAILED
	            SX = IMX
	            SY = IMY
	            D4 = E4
	            D5 = QM
	         ENDIF
	      ELSE
	         SX = IMX
	         SY = IMY
	         D4=E4
	         D5=QM
	      ENDIF
           ENDIF
	
	   SX = -SX
	   SY = -SY

C          NOW HAVE TO CHANGE ORDER OF SHIFT&ROTATION.
C          IN THIS PROGRAM IMAGE IS SHIFTED FIRST, ROTATED SECOND.
C          IN RT SQ IT IS ROTATION FIRST, SHIFT SECOND.
C          THIS PART CORRESPONDS TO SA P.
	   CO     = COS(D4*DGR_TO_RAD)
	   SO     = -SIN(D4*DGR_TO_RAD)
	   XSHSUM = SX*CO-SY*SO
	   YSHSUM = SX*SO+SY*CO

C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX
C          5 - SY
C          6 - INPUT IMAGE NUMBER.

           DLIST(3) = D5
           DLIST(4) = D4
           DLIST(5) = XSHSUM
           DLIST(6) = YSHSUM
           DLIST(7) = ILIP(IMI)
           DLIST(1) = IMI

           CALL LUNDOCWRTDAT(NDOC,IMI,DLIST(2),NLIST-1,IRTFLG)
	ENDDO
	
9999    CLOSE(NDOC)

	IF (ALLOCATED(AA))         DEALLOCATE(AA)
	IF (ALLOCATED(A_CIRC))     DEALLOCATE(A_CIRC)
	IF (ALLOCATED(A))          DEALLOCATE(A)
	IF (ALLOCATED(SA))         DEALLOCATE(SA)
	IF (ALLOCATED(TA))         DEALLOCATE(TA)

	END
a534 32

C++************************************************************************
C
C  ANG.F                               
C
C **********************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
C **********************************************************************
C
C  ANG_N(RKK,MODE,MAXRIN)
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        FUNCTION  ANG_N(RKK,MODE,MAXRIN)

        CHARACTER (LEN=1) ::  MODE
        INTEGER           :: MAXRIN

        IF (MODE .EQ. 'H')  THEN
           ANG_N  = AMOD(((RKK-1.0) / MAXRIN+1.)*180.0, 180.)

        ELSEIF (MODE .EQ. 'F')  THEN
           ANG_N  = AMOD(((RKK-1.0) / MAXRIN+1.)*360.0, 360.)
        ENDIF

        END
@


1.61
log
@changed key back to consecutive
@
text
@d8 1
d19 1
a19 1
C  MRQLI(ITYPE,MAKEREFFILE,USEREFFILE)
d21 1
a21 17
C  PARAMETERS:  MAKEREFFILE   CREATE REFER_CIRC FILE              (INPUT)
C               USEREFFILE    RUN USING EXISTING REFER_CIRC FILE  (INPUT)
C               ITYPE         SETS NRQLI=1 OR MRQLI = 0           (INPUT)
C
C  CALLS:
C     MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,...
C     MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,...
C     NRQLI(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,...
C     APMQ2D(A,REFER_CIRC,TT,NUMR,...
C     NORMASC(X,Y,NS1,NS2,NR1,NR2,IR1,IR2)
C     NORMAS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C     ALRQ_MS
C     CROSRNG_MS
C     CROSRMG_DS
C     FRNGS
C     APPLYWS
C     ALRQS
d27 1
a27 1
C        IMAGES. BIGGEST ARRAY ALLOCATED IS: REFER_CIRC(LCIRC,NIMA)
a31 2
C IMAGE_PROCESSING_ROUTINE
C
a34 210
	SUBROUTINE MRQLI(ITYPE,MAKEREFFILE,USEREFFILE)

	INCLUDE 'CMBLOCK.INC' 
	INCLUDE 'CMLIMIT.INC' 

C       be careful with the common, it has to agree with 64 bits...
	CHARACTER*80      FINPAT,FINPIC,FILTOA
	COMMON  /FISPEC/  FINPAT,FINPIC,FILTOA,NLET,NLETI

	COMMON /MXR/ MAXRIN

	CHARACTER(LEN=1) ::                      MODE
        CHARACTER(LEN=80) ::                     FILREF
	INTEGER, ALLOCATABLE, DIMENSION(:,:) ::  NUMR
	INTEGER, ALLOCATABLE, DIMENSION(:) ::    ILIST,IRIST
	REAL, ALLOCATABLE, DIMENSION(:,:) ::     REFER_CIRC
        LOGICAL ::                               MAKEREFFILE,USEREFFILE

	DATA  INPIC,LUNREF/77,78/

C       ALLOCATE SPACE FOR REFERENCE IMAGE FILE LIST
	NILMAX = NIMAX
	ALLOCATE(ILIST(NILMAX),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'AP MQ, NUMR',IER)
           RETURN
        ENDIF

C       ASK FOR REFERENCE IMAGE FILE LIST
	CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NIMA,
     &      'ENTER TEMPLATE FOR REFERENCE IMAGE SERIES',IRTFLG)
	IF (IRTFLG .NE. 0) GOTO 9999

        IF (NIMA .GT. 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT(' Number of reference images: ',I6)
        ELSE
           CALL ERRT(101,'No reference images!',IDUM)
           GOTO 9999
        ENDIF

C       GET FIRST REFERENCE IMAGE TO DETERMINE DIMS
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
        MAXIM = 0
	CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG.NE.0)  GOTO 9999
        CLOSE(INPIC)

	CALL RDPRMI(NSI,ISTEP,NOT_USED,
     &             'TRANSLATION SEARCH RANGE, STEP SIZE')
	NSI   = MAX0(NSI,1)
	ISTEP = MAX0(ISTEP,1)

        CALL  RDPRMI(MR,NR,NOT_USED,'FIRST AND LAST RING')
        IF (NR .GT. NSAM/2-1)  THEN
            NR = NSAM/2-1
            WRITE(NOUT,*)  ' Last ring limited to ',NR
        ENDIF
        MR    = MAX0(1,MIN0(NR,MR))
        ISKIP = 1
        MODE  = 'F'
        NRING = 0
        DO I=MR,NR,ISKIP
           NRING = NRING+1
	ENDDO

	ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'AP MQ, NUMR',IER)
           GOTO 9999
        ENDIF

        NRING = 0
        DO I=MR,NR,ISKIP
           NRING=NRING+1
           NUMR(1,NRING)=I
	ENDDO

C       ADJUST SEARCH RANGE AND STEP SIZE.
	IF (NSI+NR .GT. NSAM/2-2)  THEN
	   CALL ERRT(101,'SEARCH RANGE TOO LARGE',NE)
           GOTO 9999
	ENDIF

	IF (MOD(NSI,ISTEP) .NE. 0) THEN
	   CALL ERRT(101,'SEARCH RANGE MUST BE DIVISIBLE BY STEP SIZE',
     &               NE)
           GOTO 9999
	ENDIF

C       PUTS CIRCULAR RINGS IN A LINEAR ARRAY, CONCATENATED TOGETHER.
C       RETURNS NUMR & LCIRC.
        CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
        MAXRIN = NUMR(3,NRING)

C       ALLOCATE SPACE FOR REFERENCE CIRCLES ARRAY
	ALLOCATE(REFER_CIRC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            CALL  ERRT(46,'MRQLI, REFER_CIRC',IER)
            RETURN
        ENDIF 

C       DETERMINE NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)
        WRITE(NOUT,*) ' NUMBER OF OMP THREADS: ',NUMTH

        IF (USEREFFILE) THEN
C          OPEN REFERENCE RINGS FILE
           MAXIM = 0
	   CALL OPFILEC(0,.TRUE.,FILREF,LUNREF,'O',IFORM,LCIRCT,NIMAT,
     &                NDUM,MAXIM,'REFERENCE RINGS',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
           IF (LCIRC .NE. LCIRCT .OR. NIMA .NE. NIMAT) THEN
              CALL ERRT(102,
     &           'REFERENCE RINGS FILE SIZE NOT COMPATIBLE',NDUM)
              GOTO 9999
           ENDIF

C          RECOVER REFER_CIRC FROM REFERENCE RINGS FILE
           DO J=1,NIMA
	      CALL REDLIN(LUNREF,REFER_CIRC(1,J),LCIRC,J)
           ENDDO

           CLOSE(LUNREF)

        ELSEIF (MAKEREFFILE) THEN
C          CREATE REFERENCE RINGS FILE
           MAXIM = 0
           IFORM = 1
	   CALL OPFILEC(0,.TRUE.,FILREF,LUNREF,'N',IFORM,LCIRC,NIMA,
     &                1, MAXIM,'REFERENCE RINGS',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
           CALL NORM3(LUNREF,LCIRC,NIMA,1,FMAX,FMIN,AV)

           WRITE (NOUT,2601)
2601       FORMAT (/,' ',72('-'),//,
     &               '  Multi-reference alignment, Refer-circ.',//,
     &               ' ',72('-'),/)

C          FILL REF_CIRC FILE WITH RINGS DATA AND QUIT.
           CALL INITAP(ILIST,NIMA,NSAM,NROW,
     &                MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,LUNREF,
     &                INPIC,REFER_CIRC,IRTFLG)

           GOTO 9999

        ELSE
C          CREATE ON-DISK REFERENCE RINGS ARRAY AND USE IT
           CALL INITAP(ILIST,NIMA,NSAM,NROW,
     &                MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,0,
     &                 INPIC,REFER_CIRC,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
 
C       ALLOCATE SPACE FOR ALIGNED IMAGES FILE LIST
	ALLOCATE(IRIST(NILMAX),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'AP MQ, NUMR',IER)
           GOTO 9999
        ENDIF

C       GET LIST OF SAMPLE IMAGES TO BE ALIGNED
	CALL FILELIST(.TRUE.,INPIC,FILTOA,NLETI,IRIST,NILMAX,NTOTAL,
     &     'ENTER TEMPLATE FOR IMAGE SERIES TO BE ALIGNED',IRTFLG)
	IF (IRTFLG.NE.0) GOTO 9999

        IF (NTOTAL .GT. 0)  THEN
           WRITE(NOUT,2002) NTOTAL
2002       FORMAT(' Number of experimental images: ',I6/)
        ELSE
           CALL ERRT(101,'No experimental images!',IDUM)
           GOTO 9999
        ENDIF

C       NIMA NUMBER OF THE REFERENCE IMAGES
C       NTOTAL IS NUMBER OF THE SAMPLE IMAGES

        IF (ITYPE .EQ. 1) THEN
C          USE NRQLI FOR 'AP NQ'
           CALL NRQLI(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &          ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,REFER_CIRC)

	ELSEIF (NTOTAL .GE. NUMTH)  THEN
C          FOR MP, LARGE NUMBER OF IMAGES TO BE ALIGNED, OR SP.
           CALL MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,ISTEP,
     &          MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,REFER_CIRC)
	ELSE
C          FOR SMALL NUMBER OF IMAGES TO BE ALIGNED USE DIFFERENT 
C          STRATEGY TO MAKE MP EFFICIENT.
           CALL MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &             ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,REFER_CIRC)
 	ENDIF

        WRITE (NOUT,2600)
2600    FORMAT (/,' ',72('-'),//,
     &            '  Multi-reference alignment, end of computation',//,
     &            ' ',72('-'),/)

9999    IF (ALLOCATED(IRIST))      DEALLOCATE(IRIST)
        IF (ALLOCATED(ILIST))      DEALLOCATE(ILIST)
        IF (ALLOCATED(NUMR))       DEALLOCATE(NUMR)
        IF (ALLOCATED(REFER_CIRC)) DEALLOCATE(REFER_CIRC)

         RETURN
         END




d41 19
a59 3
        SUBROUTINE MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &                ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,
     &                REFER_CIRC)
d61 2
a62 1
	INCLUDE 'CMBLOCK.INC'
d64 5
a68 4
	INTEGER, DIMENSION(NIMA) ::       ILIST
	INTEGER, DIMENSION(NTOTAL) ::     IRIST
	INTEGER, DIMENSION(3,NRING) ::    NUMR
	REAL, DIMENSION(LCIRC,NIMA) ::    REFER_CIRC
d70 3
a72 4
C       AUTOMATIC ARRAYS
        PARAMETER (NDLI=7)
        DIMENSION  DLIST(NDLI,NUMTH)
	INTEGER    NASSIG(NUMTH)
d74 1
a74 2
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::          A
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT
d76 2
a77 1
        CHARACTER(LEN=1)  :: MODE
d79 12
a90 2
        CHARACTER*80     FINPAT,FINPIC,FILTOA
        COMMON  /FISPEC/ FINPAT,FINPIC,FILTOA,NLET,NLETI
a91 2
        DATA  NDOC/56/,INPIC/58/

d98 6
a103 8
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C       ALIGNMENT
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	ALLOCATE(A(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
            CALL  ERRT(46,'AM MQ, A ',IER)
            RETURN
d105 20
d126 2
a127 14
#ifdef  SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
           CALL  ERRT(46,'AM MQ, TT',IER)
           GOTO 9999
        ENDIF 
	CALL DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'AM MQ, TT',IER)
           GOTO 9999
        ENDIF 
#endif
d129 7
a135 20
C       LOOP OVER IMAGES TO BE ALIGNED
 	DO  IMIT=1,NTOTAL,NUMTH
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)

	      CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
	      MAXIM = 0
	      CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
     &             NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG.NE.0) GOTO 9999

              IF (NSAMT.NE.NSAM .OR. NROWT.NE.NROW)  THEN
                 CALL ERRT(1,'AP MQ',NE)
                 CLOSE(INPIC)
	         GOTO 9999
	      ENDIF
	      DO J=1,NROW
	         CALL REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
	      ENDDO
	      CLOSE(INPIC)
	   ENDDO
d139 2
a140 7
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	      CALL APMQ2D(A(1,1,IMI-IMIT+1),REFER_CIRC,TT,NUMR,
     &	         NSAM,NROW,NSI,ISTEP,
     &	         NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &	         NASSIG(IMI-IMIT+1),
     &	         DLIST(3,IMI-IMIT+1),DLIST(4,IMI-IMIT+1),
     &	         DLIST(5,IMI-IMIT+1),DLIST(6,IMI-IMIT+1))
d142 6
a147 3
C                OUTPUT PARAMETERS ARE:
C                NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C                CORR COEFF.(D5), ANGLE (D4), SHIFT: XSHSUM, YSHSUM
d154 2
a155 2
C          4 - SX
C          5 - SY
d157 18
d176 2
a177 6
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	      DLIST(2,IMI-IMIT+1) =
     &	      ISIGN(ILIST(IABS(NASSIG(IMI-IMIT+1))),NASSIG(IMI-IMIT+1))
              DLIST(7,IMI-IMIT+1) = IRIST(IMI)
              DLIST(1,IMI-IMIT+1) = IMI
              CALL SAVD(NDOC,DLIST(1,IMI-IMIT+1),NDLI,IRTFLG)
a178 1
C---------------------------------------------------------------------
d182 1
a182 2
	CLOSE(NDOC)
        CALL  SAVDC
d184 2
a185 2
C       DEALLOCATE LOCAL ARRAYS
9999    IF (ALLOCATED(TT))         DEALLOCATE(TT)
d187 2
d202 6
a207 3
        SUBROUTINE  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &                ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH,
     &                REFER_CIRC)
d210 1
d212 9
a220 8
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER  (DGR_TO_RAD = (QUADPI/180))
        PARAMETER         (NDLI=7)

	INTEGER, DIMENSION(NIMA) ::       ILIST
	INTEGER, DIMENSION(NTOTAL) ::     IRIST
	INTEGER, DIMENSION(3,NRING) ::    NUMR
	REAL, DIMENSION(LCIRC,NIMA) ::    REFER_CIRC
d222 2
a223 1
        DIMENSION         DLIST(NDLI)
d225 1
a225 1
	DOUBLE PRECISION  QT,QM,PEAK
d230 3
a232 3
	DIMENSION         TOT(NIMA,-NSI:NSI,-NSI:NSI),
     &                    TMT(NIMA,-NSI:NSI,-NSI:NSI)
	DOUBLE PRECISION  FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
d234 12
a245 1
	DIMENSION         WR(NRING)
d247 1
a247 19
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::          A_CIRC
	REAL, ALLOCATABLE, DIMENSION(:,:,:,:) ::        AA
	REAL, ALLOCATABLE, DIMENSION(:,:) ::            A
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT

        CHARACTER*1      MODE
        CHARACTER*80     FINPAT,FINPIC,FILTOA
        COMMON  /FISPEC/ FINPAT,FINPIC,FILTOA,NLET,NLETI

        DATA  NDOC/56/,INPIC/58/

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
#endif
d249 17
d272 60
a331 27
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C       ALIGNMENT
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	ALLOCATE(A(NSAM,NROW),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL  ERRT(46,'AM MQ, A',IER)

	NSIS=MAX(NSI/ISTEP,ISTEP)
	ALLOCATE(A_CIRC(LCIRC,-NSIS:NSIS,-NSIS:NSIS),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, A_CIRC',IER)

	ALLOCATE(AA(NSAM,NROW,-NSIS:NSIS,-NSIS:NSIS),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, AA',IER)

C       IMAGES TO BE ALIGNED
C       LOOP OVER IMAGES TO BE ALIGNED
	DO IMI=1,NTOTAL
           CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &             NSAMT,NROWT,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG.NE.0) RETURN

           IF (NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
              CALL ERRT(1,'AP MQ',NE)
              CLOSE(INPIC)
              RETURN
d333 7
a339 4
           DO J=1,NROW
              CALL  REDLIN(INPIC,A(1,J),NSAM,J)
           ENDDO
           CLOSE(INPIC)
d342 1
a342 1
c$omp      parallel do private(jt,it,ir,cnr2,cns2)
d345 1
d353 1
d357 1
d360 21
a380 6
                 DO IR=1,NIMA
	            CALL CROSRNG_MS(REFER_CIRC(1,IR),
     &                 A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                 NRING,MAXRIN,NUMR,
     &                 TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &                 TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
d392 13
a404 8
                 DO IR=1,NIMA
                    IF(TOTA(IR,IT,JT).GE.QT)  THEN
	               QT=TOTA(IR,IT,JT)
	               IBE=IR
                       ISX=IT
                       ISY=JT
                       D4=ANG(TOT(IR,IT,JT),MODE)
                       D6=ILIST(IR)
d406 8
a413 7
                    IF (TMTA(IR,IT,JT).GE.QM)  THEN
                       QM=TMTA(IR,IT,JT)
                       IME=IR
                       IMX=IT
                       IMY=JT
                       E4=ANG(TMT(IR,IT,JT),MODE)
                       E6=-ILIST(IR)
d420 3
a422 1
	   IF (QT.GT.QM)  THEN
d424 3
a426 1
              DLIST(2)=D6
d429 1
a429 1
	      IF (IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d434 3
a436 3
	         DO     JT=-ISTEP,ISTEP
	            DO     IT=-ISTEP,ISTEP
	               IF(IT.NE.0 .OR. JT.NE.0) THEN
d439 1
d443 1
d447 1
d449 2
a450 1
	                  CALL CROSRNG_DS(REFER_CIRC(1,IBE),
d453 2
a454 1
	                  ROTMP(IT,JT) = ANG(ROTMP(IT,JT),MODE)
d464 1
a464 1
	         IF (ISTEP.GT.1)  THEN
d467 5
a471 5
	                  IF (FIT(IT,JT).GT.AFIT)  THEN
	                     AFIT=FIT(IT,JT)
	                     D4=ROTMP(IT,JT)
	                     ITMA=IT
	                     JTMA=JT
d476 1
d480 1
a480 1
	               FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
d483 1
d485 3
a487 3
	         QT=AFIT
	         ISX=ISX+ITMA
	         ISY=ISY+JTMA
d490 1
d492 6
a497 5
	         IF (ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	            SX=SX+ISX
	            SY=SY+ISY
	            CNR2=NROW/2+1+SY
	            CNS2=NSAM/2+1+SX
d500 1
d503 1
d505 2
a506 1
	            CALL CROSRNG_DS(REFER_CIRC(1,IBE),A_CIRC,LCIRC,
d508 3
a510 2
	            D5=QT
	            D4=ANG(D4,MODE)
d513 3
a515 3
	            D5=QT
	            SX=ISX
	            SY=ISY
d518 3
a520 3
	         D5=QT
	         SX=ISX
	         SY=ISY
d524 2
a525 1
              DLIST(2) = E6
d527 1
a527 1
	      IF (IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
d529 2
a530 2
	         FIT(0,0)=QM
	         ROTMP(0,0)=E4
d532 6
a537 5
	         DO     JT=-ISTEP,ISTEP
	            DO     IT=-ISTEP,ISTEP
	               IF(IT.NE.0 .OR. JT.NE.0) THEN
	                 CNR2=NROW/2+1+JT+IMY
	                 CNS2=NSAM/2+1+IT+IMX
d539 4
a542 3
     &	                 NSB-(IT+IMX),NSE-(IT+IMX),NRB-(JT+IMY),
     &                   NRE-(JT+IMY), NUMR,NUMR(1,NRING))
	                 CALL  ALRQ_MS
d545 5
a549 3
	                 CALL  FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
	                 CALL  CROSRMG_DS
     &		         (REFER_CIRC(1,IME),A_CIRC(1,IT,JT),LCIRC,NRING,
d551 2
a552 1
	                 ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d566 4
a569 4
	                     AFIT=FIT(IT,JT)
	                     E4 = ROTMP(IT,JT)
	                     ITMA=IT
	                     JTMA=JT
d574 1
d578 1
a578 1
	               FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
d583 3
a585 3
	         QM=AFIT
	         IMX=IMX+ITMA
	         IMY=IMY+JTMA
d587 2
a588 1
	         CALL  PARABLD(FITP,SX,SY,PEAK)
d591 2
a592 2
	            SX   = SX+IMX
	            SY   = SY+IMY
d597 1
d600 1
d602 2
a603 1
	            CALL CROSRMG_DS (REFER_CIRC(1,IME),A_CIRC,LCIRC,
d605 1
d607 1
a607 1
	            D4 = ANG(D4,MODE)
d618 2
a619 2
	         D4 = E4
	         D5 = QM
d625 1
d641 1
d646 1
a646 1
           DLIST(7) = IRIST(IMI)
a647 1
           CALL SAVD(NDOC,DLIST,NDLI,IRTFLG)
d649 1
a649 1
C---------------------------------------------------------------------
d651 2
a652 2
	CLOSE(NDOC)
        CALL  SAVDC
d657 3
a659 1
	IF (ALLOCATED(TT))         DEALLOCATE(TT)
d662 1
a662 3


C++************************************************************************
d664 5
a668 1
C APMQ2D.F
d670 1
a670 1
C--************************************************************************
d672 5
a676 4
	SUBROUTINE APMQ2D(A,REFER_CIRC,TT,NUMR,
     &	     NSAM,NROW,NSI,ISTEP,
     &	     NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &	     IDI,D5,D4,XSHSUM,YSHSUM)
d678 1
a678 2
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
a679 1
	DIMENSION  A(NSAM,NROW),REFER_CIRC(LCIRC,NIMA),NUMR(3,NRING)
d681 5
a685 2
	DOUBLE PRECISION  TT(*)
        CHARACTER*1       MODE
d690 43
a732 8
	DOUBLE PRECISION  QT,QM,PEAK
	DOUBLE PRECISION  TOTA,TMTA
	REAL, ALLOCATABLE, DIMENSION(:) ::  A_CIRC

	ALLOCATE(A_CIRC(LCIRC),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
           CALL  ERRT(46,'AP MQ, A_CIRC',IER)
           RETURN
d735 1
d738 1
d746 1
d758 24
a781 4
	      DO IR=1,NIMA
	         CALL CROSRNG_MS (REFER_CIRC(1,IR),A_CIRC,LCIRC,NRING,
     &		        MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)
	         IF (TOTA.GE.QT)  THEN
d786 1
a786 1
	            D4   = ANG(TOT,MODE)
d788 1
d790 1
a790 8
	         IF (TMTA.GE.QM)  THEN
	            QM   = TMTA
	            IME  = IR
	            IMX  = IT
	            IMY  = JT
	            E4   =  ANG(TMT,MODE)
	            IDIM = -IR
	         ENDIF
d792 1
a792 1
C             END-OF-LOOP OVER REFERENCE IMAGES
d796 4
a799 2
C       TRY TO INTERPOLATE
	IF (QT .GT. QM)  THEN
d801 2
a802 1
           IDI=IDIS
d813 1
d817 1
d820 1
d822 2
a823 2
	               CALL CROSRNG_DS
     &		            (REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d825 3
a827 1
	                    ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d840 1
a840 1
	               IF (FIT(IT,JT).GT.AFIT)  THEN
d849 1
d853 1
a853 1
	            FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
d858 1
a858 1
	      QT = AFIT
d861 1
a862 1
	      CALL  PARABLD(FITP,SX,SY,PEAK)
d869 1
d872 1
d875 1
d877 2
a878 1
	         CALL CROSRNG_DS(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d881 1
a881 1
	         D4 = ANG(D4,MODE)
d893 1
d895 2
a896 1
           IDI = IDIM
d898 1
a898 1
	   IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
d900 7
a906 7
	      FIT(0,0)=QM
	      ROTMP(0,0)=E4
	      DO     JT=-ISTEP,ISTEP
	         DO     IT=-ISTEP,ISTEP
	            IF(IT.NE.0 .OR. JT.NE.0) THEN
	               CNR2=NROW/2+1+JT+IMY
	               CNS2=NSAM/2+1+IT+IMX
d910 2
a911 1
	               CALL  ALRQ_MS(A,NSAM,NROW,CNS2,CNR2,NUMR,
d913 4
a916 2
	               CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	               CALL  CROSRMG_DS(REFER_CIRC(1,IME),A_CIRC,
d919 3
a921 1
	               ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d928 3
a930 3
	      AFIT=FIT(0,0)
	      JTMA=0
	      ITMA=0
d934 5
a938 5
	               IF (FIT(IT,JT).GT.AFIT)  THEN
	                  AFIT=FIT(IT,JT)
	                  E4=ROTMP(IT,JT)
	                  ITMA=IT
	                  JTMA=JT
d943 1
d947 1
a947 1
	            FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
d950 1
d952 4
a955 3
	      QM=AFIT
	      IMX=IMX+ITMA
	      IMY=IMY+JTMA
a956 1
	      CALL  PARABLD(FITP,SX,SY,PEAK)
d963 1
d966 1
d969 1
d971 2
a972 1
	         CALL CROSRMG_DS(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
d975 2
a976 1
	         D4 = ANG(D4,MODE)
d984 1
d995 2
a996 1
C       NOW HAVE TO CHANGE ORDER OF SHIFT&ROTATION.
d1004 3
a1007 1
9999    DEALLOCATE(A_CIRC)
d1009 33
@


1.60
log
@savd key changed to image number from consecutive
@
text
@a7 1
C                   KEY NUMBER CHANGED            JUL 03 ARDEAN LEITH
d17 1
a17 1

d352 4
a358 3
     &	         NASSIG(IMI-IMIT+1),
     &	         DLIST(3,IMI-IMIT+1),DLIST(4,IMI-IMIT+1),
     &	         DLIST(5,IMI-IMIT+1),DLIST(6,IMI-IMIT+1))
d373 1
a373 2
C             DLIST(1,IMI-IMIT+1) = IMI
              DLIST(1,IMI-IMIT+1) = IRIST(IMI)
d737 1
a737 2
C          DLIST(1) = IMI
           DLIST(1) = IRIST(IMI)
@


1.59
log
@opfilec
@
text
@d8 1
d370 1
a370 1
	      DLIST(2,IMI-IMIT+1)=
d372 3
a374 2
              DLIST(7,IMI-IMIT+1)=IRIST(IMI)
              DLIST(1,IMI-IMIT+1)=IMI
d629 1
a629 1
              DLIST(2)=E6
d658 4
a661 4
	        AFIT=FIT(0,0)
	        JTMA=0
	        ITMA=0
	        IF (ISTEP.GT.1)  THEN
d664 1
a664 1
	                  IF (FIT(IT,JT).GT.AFIT)  THEN
d666 1
a666 1
	                     E4=ROTMP(IT,JT)
d688 4
a691 4
	            SX=SX+IMX
	            SY=SY+IMY
	            CNR2=NROW/2+1+SY
	            CNS2=NSAM/2+1+SX
d699 2
a700 2
	            D5=QM
	            D4=ANG(D4,MODE)
d703 4
a706 4
	            SX=IMX
	            SY=IMY
	            D4=E4
	            D5=QM
d709 4
a712 4
	         SX=IMX
	         SY=IMY
	         D4=E4
	         D5=QM
d716 2
a717 2
	   SX=-SX
	   SY=-SY
d722 4
a725 4
	   CO=COS(D4*DGR_TO_RAD)
	   SO=-SIN(D4*DGR_TO_RAD)
	   XSHSUM=SX*CO-SY*SO
	   YSHSUM=SX*SO+SY*CO
d733 8
a740 7
           DLIST(3)=D5
           DLIST(4)=D4
           DLIST(5)=XSHSUM
           DLIST(6)=YSHSUM
           DLIST(7)=IRIST(IMI)
           DLIST(1)=IMI
           CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
@


1.58
log
@unused AI removed
@
text
@d7 1
d96 1
a96 1
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d162 1
a162 1
	   CALL OPFILE(.TRUE.,FILREF,LUNREF,'O',IFORM,LCIRCT,NIMAT,
d182 1
a182 1
	   CALL OPFILE(.TRUE.,FILREF,LUNREF,'N',IFORM,LCIRC,NIMA,
d331 1
a331 1
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
d471 1
a471 1
           CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
@


1.57
log
@numth wrong
@
text
@a427 1
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::          AI
@


1.56
log
@comment changed
@
text
@d156 1
a156 1
        WRITE(NOUT,*) ' NUMBER OF OMP THREADS: ',I3
@


1.55
log
@nloop,iloop_removed
@
text
@d206 1
a206 1
C       ALLOCATE SPACE FOR REFERENCE IMAGE FILE LIST
@


1.54
log
@*** empty log message ***
@
text
@d100 1
a100 1
	CALL RDPRMI(NSI,ISTEP,NLOOP,ILOOP,
d105 1
a105 1
        CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
@


1.53
log
@prompts changed (again)
@
text
@d220 1
a220 1
2002       FORMAT(' Number of sample images: ',I6/)
d222 1
a222 1
           CALL ERRT(101,'No sample images!',IDUM)
@


1.52
log
@unchanged
@
text
@d6 1
d81 1
a81 1
     &      'ENTER TEMPLATE FOR 2-D REFERENCE IMAGES',IRTFLG)
d215 1
a215 1
     &     'ENTER TEMPLATE FOR 2-D EXPERIMENTAL PROJECTIONS',IRTFLG)
@


1.51
log
@normass --> normas
@
text
@d785 1
a785 1
c       GO THROUGH CENTERS
a791 1

d794 2
d798 2
d801 2
a802 1
C             LOOP OVER REFERENCE IMAGES
d823 1
a823 1
C             END-OF-LOOP 1 OVER REFERENCE IMAGES
@


1.50
log
@echos number of threads
@
text
@d3 3
a5 2
C    MRQLI.F                           USED CMLIMIT AUG 00 ARDEAN LEITH
C                               ADDED REF_CIRC FILE APR 01 ARDEAN LEITH
d22 1
a22 1
C  USES:
d28 1
a28 1
C     NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
d80 1
a80 1
     &      'ENTER TEMPLATE FOR 2-D REFERENCE IMAGE NAME',IRTFLG)
d99 2
a100 1
	CALL RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'SEARCH RANGE, STEP SIZE')
d214 1
a214 1
     &      'ENTER TEMPLATE FOR 2-D IMAGES TO BE ALIGNED',IRTFLG)
d244 1
a244 1
9998    WRITE (NOUT,2600)
d793 1
a793 1
	      CALL NORMASS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,
d837 1
a837 1
	               CALL NORMASS(A, NSB-(IT+ISX),NSE-(IT+ISX),
d887 1
a887 1
	         CALL NORMASS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
d919 1
a919 1
	               CALL NORMASS(A,NSB-(IT+IMX),NSE-(IT+IMX),
d968 1
a968 1
	         CALL NORMASS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,
@


1.49
log
@ref rings file support
@
text
@d153 1
@


1.48
log
@comments & cosmetic
@
text
@d4 1
d6 28
a33 22
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C  MRQLI
C  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
C  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
C  APMQ2D(A,REFER_CIRC,TT,NUMR,
C  NORMASC(X,Y,NS1,NS2,NR1,NR2,IR1,IR2)
C  NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C  ALRQ_MS
C  CROSRNG_MS
C  CROSRMG_DS
C  FRNGS
C  APPLYWS
C  ALRQS
d49 1
a49 1
	SUBROUTINE MRQLI
d60 2
a61 1
	CHARACTER*1  MODE
d63 3
a65 1
	INTEGER, ALLOCATABLE, DIMENSION(:) ::   ILIST,IRIST
d67 1
a67 1
	DATA  INPIC/77/
d69 1
d84 1
a84 1
2001       FORMAT(' Number of reference images =',I5)
d90 1
a90 1
C       GET FIRST PICTURE TO DETERMINE DIMS
d139 2
d144 59
d204 1
a204 1
	IF (IRTFLG.NE.0) THEN
d213 1
d216 1
a216 1
2002       FORMAT(' Number of sample images =',I5)
d222 2
a223 1
        CALL GETTHREADS(NUMTH)
d225 4
a228 1
C       NIMA NUMBER OF THE REFERENCE IMAGES
d230 1
a230 1
	IF (NTOTAL .GE. NUMTH)  THEN
d232 2
a233 2
           CALL  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &          ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH)
d237 13
a249 3
           CALL  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &          ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH)
	ENDIF
a250 9
9999    IF (ALLOCATED(IRIST)) DEALLOCATE(IRIST)
        IF (ALLOCATED(ILIST)) DEALLOCATE(ILIST)
        IF (ALLOCATED(NUMR))  DEALLOCATE(NUMR)

         WRITE (NOUT,2600)
2600     FORMAT (/,' ',72('-'),//,
     &      ' ',' Multi-reference alignment, end of computation',//,
     &      ' ',72('-'),/)

d255 129
d388 2
a389 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
a390 3
C  THIS IS VERSION FOR MP AND A SMALL NUMBER OF IMAGES TO BE ALIGNED
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d394 2
a395 1
     &                ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH)
d398 1
d400 9
a408 5
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NDLI=7)
        DIMENSION  ILIST(NIMA),IRIST(NTOTAL)
        DIMENSION DLIST(NDLI)
        INTEGER    NUMR(3,NRING),MAXRIN
d412 1
a412 1
C       Automatic arrays
d415 2
a416 2
	DIMENSION  TOT(NIMA,-NSI:NSI,-NSI:NSI),
     &             TMT(NIMA,-NSI:NSI,-NSI:NSI)
d418 7
a424 7
	DIMENSION  ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION  WR(NRING)
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  A_CIRC
	REAL, ALLOCATABLE, DIMENSION(:,:,:,:) ::  AA
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  A
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  AI
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  REFER_CIRC
d427 3
a429 3
        CHARACTER*1  MODE
        COMMON  /FISPEC/  FINPAT,FINPIC,FILTOA,NLET,NLETI
        CHARACTER*80  FINPAT,FINPIC,FILTOA
a432 3
	ALLOCATE(REFER_CIRC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, REFER_CIRC',IER)

d435 1
a435 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
d439 1
a439 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
a440 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
a441 6
	ALLOCATE(AI(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, AI',IER)

	NSNR=NSAM*NROW
	LO=2*NSI+1
	LT=LO*LO
d448 3
a450 17
C       PREPARE REFERENCES

C       do it for all the reference images
	DO    IMIT=1,NIMA,NUMTH
	   DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	      CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
     &                   NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG.NE.0)  RETURN
	      DO    J=1,NROW
	         CALL  REDLIN(INPIC,AI(1,J,IMI-IMIT+1),NSAM,J)
	      ENDDO
	      CLOSE(INPIC)
	   ENDDO

C          NORMALIZE UNDER THE MASK
a451 12
c$omp parallel do private(IMI)
	   DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	      CALL NORMASS(AI(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,
     &		NUMR(1,NRING))
	      CALL  ALRQS(AI(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
     &          REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
	      CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	     CALL  APPLYWS(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
	   ENDDO
	ENDDO

	DEALLOCATE(AI)
d453 1
a453 2
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, A',IER)

a454 3
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C  alignment
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
d464 1
a464 1
	DO    IMI=1,NTOTAL
d482 2
a483 2
c$omp parallel do private(jt,it,ir,cnr2,cns2)
           DO    JT=-NSI,NSI,ISTEP
d485 1
a485 1
              DO    IT=-NSI,NSI,ISTEP
d491 12
a502 12
     &             NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
                 CALL  ALRQ_MS
     &             (AA(1,1,IT/ISTEP,JT/ISTEP),NSAM,NROW,CNS2,CNR2,NUMR,
     &              A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NRING,MODE)
	         CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &              NUMR,NRING)
                 DO    IR=1,NIMA
	            CALL  CROSRNG_MS
     &             (REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &              NRING,MAXRIN,NUMR,
     &              TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &              TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
d507 2
a508 2
C          end of the parallel section
C          Locate best match
d512 3
a514 3
           DO    JT=-NSI,NSI,ISTEP
              DO    IT=-NSI,NSI,ISTEP
                 DO    IR=1,NIMA
d523 1
a523 1
                    IF(TMTA(IR,IT,JT).GE.QM)  THEN
d536 2
a537 2
	   IF(QT.GT.QM)  THEN
C             For not-mirrored
d539 1
a539 1
C             Do not interpolate for point on the edge
d541 1
a541 1
	      IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d545 1
a545 1
c$omp parallel do private(jt,it,cnr2,cns2)
d552 2
a553 2
     &	NSB-(IT+ISX),NSE-(IT+ISX),NRB-(JT+ISY),NRE-(JT+ISY),
     &	NUMR,NUMR(1,NRING))
d555 7
a561 7
     &      (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &      A_CIRC(1,IT,JT),LCIRC,NRING,MODE)
	    CALL  FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
	                  CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC(1,IT,JT),LCIRC,NRING,
     &		MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	                  ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d571 4
a574 4
	         IF(ISTEP.GT.1)  THEN
	            DO     JT=-ISTEP+1,ISTEP-1
	               DO     IT=-ISTEP+1,ISTEP-1
	                  IF(FIT(IT,JT).GT.AFIT)  THEN
d583 3
a585 3
C                Copy values around the peak.
	         DO     JT=-1,1
	            DO     IT=-1,1
d594 1
a594 1
	         CALL  PARABLD(FITP,SX,SY,PEAK)
d603 2
a604 2
	            CALL  ALRQ_M
     &              (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
d606 2
a607 3
	            CALL CROSRNG_DS
     &		       (REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		    MAXRIN,NUMR,QT,D4,TT)
d625 1
a625 1
	      IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
d629 1
a629 1
c$omp parallel do private(jt,it,cnr2,cns2)
d644 1
a644 1
     &		         MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
d739 5
a743 5
	DEALLOCATE(AA)
	DEALLOCATE(A_CIRC)
	DEALLOCATE(A)
	DEALLOCATE(TT)
	DEALLOCATE(REFER_CIRC)
d747 1
d750 1
a750 11
C  MRQLI_PS.F 
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
a751 2
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d754 1
a754 153
        SUBROUTINE  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
     &                ISTEP,MODE,LCIRC,NUMR,NRING,MAXRIN,NUMTH)

	INCLUDE 'CMBLOCK.INC'
        DIMENSION  ILIST(NIMA),IRIST(NTOTAL)
        INTEGER    NUMR(3,NRING),MAXRIN

C       AUTOMATIC ARRAYS
        PARAMETER (NDLI=7)
        DIMENSION  DLIST(NDLI,NUMTH)
	DIMENSION  WR(NRING)
	INTEGER    NASSIG(NUMTH)
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  A
	REAL, ALLOCATABLE, DIMENSION(:,:) ::    REFER_CIRC
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT

        CHARACTER*1  MODE
        COMMON  /FISPEC/  FINPAT,FINPIC,FILTOA,NLET,NLETI
        CHARACTER*80  FINPAT,FINPIC,FILTOA
        DATA  NDOC/56/,INPIC/58/

	ALLOCATE(A(NSAM,NROW,NUMTH),REFER_CIRC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
            CALL  ERRT(46,'AM MQ, A & REFER_CIRC',IER)
            RETURN
        ENDIF 

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
            CALL  ERRT(46,'AM MQ, TT',IER)
            RETURN
        ENDIF 
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF(IRTFLG.NE.0) THEN
            CALL  ERRT(46,'AM MQ, TT',IER)
            RETURN
        ENDIF 
#endif
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)

	NSNR = NSAM*NROW
	LO   = 2*NSI+1
	LT   = LO*LO

C       CALCULATE DIMENSIONS FOR NORMAS
	NSB  = -NSAM/2
	NSE  = -NSB-1+MOD(NSAM,2)
	NRB  = -NROW/2
	NRE  = -NRB-1+MOD(NROW,2)

C       PREPARE REFERENCES
C       DO IT FOR ALL THE REFERENCE IMAGES
	DO  IMIT=1,NIMA,NUMTH
	   DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	      CALL FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
     &             NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0)  GOTO 9999

	      DO J=1,NROW
	         CALL REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
	      ENDDO
	      CLOSE(INPIC)
	   ENDDO

C          NORMALIZE UNDER THE MASK

c$omp      parallel do private(IMI)
	   DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	      CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,
     &                 NUMR,NUMR(1,NRING))
	      CALL ALRQS(A(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
     &              REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
	      CALL FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	      CALL APPLYWS(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
	   ENDDO
	ENDDO

C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C  ALIGNMENT
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C       LOOP OVER IMAGES TO BE ALIGNED
 	DO  IMIT=1,NTOTAL,NUMTH
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)

	      CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
     &             NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG.NE.0)  GOTO 9999

              IF (NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
                 CALL ERRT(1,'AP MQ',NE)
                 CLOSE(INPIC)
	         GOTO 9999
	      ENDIF
	      DO J=1,NROW
	         CALL  REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
	      ENDDO
	      CLOSE(INPIC)
	   ENDDO

C          NUMTH INPUT IMAGES READY TO BE ALIGNED
c$omp      parallel do private(IMI)
	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	      CALL APMQ2D(A(1,1,IMI-IMIT+1),REFER_CIRC,TT,NUMR,
     &	         NSAM,NROW,NSI,ISTEP,
     &	         NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
C             OUTPUT PARAMETERS ARE:
C             NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C             CORR COEFF.(D5), ANGLE (D4), SHIFT: XSHSUM, YSHSUM
     &	      NASSIG(IMI-IMIT+1),
     &	      DLIST(3,IMI-IMIT+1),DLIST(4,IMI-IMIT+1),
     &	      DLIST(5,IMI-IMIT+1),DLIST(6,IMI-IMIT+1))
	   ENDDO

C          OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX
C          5 - SY
C          6 - INPUT IMAGE NUMBER.

	   DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	      DLIST(2,IMI-IMIT+1)=
     &	       ISIGN(ILIST(IABS(NASSIG(IMI-IMIT+1))),NASSIG(IMI-IMIT+1))
              DLIST(7,IMI-IMIT+1)=IRIST(IMI)
              DLIST(1,IMI-IMIT+1)=IMI
              CALL SAVD(NDOC,DLIST(1,IMI-IMIT+1),NDLI,IRTFLG)
	   ENDDO
C---------------------------------------------------------------------
	ENDDO

C       OVER AND OUT
	CLOSE(NDOC)
        CALL  SAVDC

C       DEALLOCATE LOCAL ARRAYS
9999    IF (ALLOCATED(TT))         DEALLOCATE(TT)
	IF (ALLOCATED(REFER_CIRC)) DEALLOCATE(REFER_CIRC)
	IF (ALLOCATED(A))          DEALLOCATE(A)
	END


C       --------------------- APMQ2D ----------------------------------

	SUBROUTINE  APMQ2D(A,REFER_CIRC,TT,NUMR,
d761 1
d767 1
a767 1
C       Automatic arrays
@


1.47
log
@comments on memory usage
@
text
@d31 4
a34 4
C        NUMBER OF RINGS AND THEIR RADIUS.  NIMA IS NUMBER OF IMAGES.
C        BIGGEST ARRAY ALLOCATED IS REFER_CIRC(LCIRC,NIMA)
C        ANOTHER LARGE ARRAY IS: A(NSAM,NROW,NUMTH)
C        FOR 83 IMAGES of 125x125 with rings at 5...47 SIZE=45MB
a36 1
C
d66 1
a66 1
C       ASK FOR DATA FILE
d73 1
a73 1
2001       FORMAT(' Number of images =',I5)
d75 1
a75 1
           CALL ERRT(101,'No images!',IDUM)
d137 1
a137 1
C       IMAGES TO BE ALIGNED
d141 7
d191 1
a191 1
C  This is version for mp and a small number of images to be aligned
d403 2
a404 2
C  Find the maximum within +/-ISTEP
C  Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
d426 1
a426 1
C                Update location of the peak
d430 1
a430 1
C
d432 2
a433 2
C CHECK WHETHER INTERPOLATION IS OK.
	         IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
d438 2
a439 1
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
d441 4
a444 4
     &           (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	            CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	            CALL  CROSRNG_DS
     &		    (REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d449 6
a454 1
C                INTERPOLATION FAILED
d458 1
a458 6
	      ENDIF
	   ELSE
	      D5=QT
	      SX=ISX
	      SY=ISY
           ENDIF
d463 4
a466 4
	 IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
C             HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)=QM
	      ROTMP(0,0)=E4
d468 16
a483 16
	      DO     JT=-ISTEP,ISTEP
	         DO     IT=-ISTEP,ISTEP
	            IF(IT.NE.0 .OR. JT.NE.0) THEN
	              CNR2=NROW/2+1+JT+IMY
	              CNS2=NSAM/2+1+IT+IMX
	              CALL NORMASC(A,AA(1,1,IT,JT),
     &	NSB-(IT+IMX),NSE-(IT+IMX),NRB-(JT+IMY),NRE-(JT+IMY),
     &	NUMR,NUMR(1,NRING))
	              CALL  ALRQ_MS
     &   (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &   A_CIRC(1,IT,JT),LCIRC,NRING,MODE)
	              CALL  FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
	              CALL  CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC(1,IT,JT),LCIRC,NRING,
     &		   MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	           ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d488 2
a489 2
C               Find the maximum within +/-ISTEP
C            Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
d493 4
a496 4
	        IF(ISTEP.GT.1)  THEN
	           DO     JT=-ISTEP+1,ISTEP-1
	              DO     IT=-ISTEP+1,ISTEP-1
	                  IF(FIT(IT,JT).GT.AFIT)  THEN
d505 3
a507 3
C                Copy values around the peak.
	         DO     JT=-1,1
	            DO     IT=-1,1
d512 1
a512 1
C                Update location of the peak
d519 1
a519 1
	         IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
d524 7
a530 7
	CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,NUMR,NUMR(1,NRING))
	            CALL  ALRQ_M
     &       (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	            CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	            CALL  CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
     &		    MAXRIN,NUMR,QM,D4,TT)
d550 4
a553 4
C          Now have to change order of shift&rotation.
C          In this program image is shifted first, rotated second.
C          In RT SQ it is rotation first, shift second.
C          This part corresponds to SA P.
d559 6
a564 6
c 1 - Number of the most similar reference projection.
c 2 - Not-normalized correlation coefficient.
c 3 - Psi angle. (in=plane rotation)
c 4 - SX
c 5 - SY
c 6 - input image number.
@


1.46
log
@MR
@
text
@d15 21
a35 12
C        SUBROUTINE MRQLI
C        SUBROUTINE  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
C        SUBROUTINE  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
C        SUBROUTINE  APMQ2D(A,REFER_CIRC,TT,NUMR,
C        SUBROUTINE  NORMASC(X,Y,NS1,NS2,NR1,NR2,IR1,IR2)
C        SUBROUTINE  NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C        SUBROUTINE  ALRQ_MS
C        SUBROUTINE  CROSRNG_MS
C        SUBROUTINE  CROSRMG_DS
C        SUBROUTINE  FRNGS
C        SUBROUTINE  APPLYWS
C        SUBROUTINE  ALRQS
d37 1
a39 1
C        1         2         3         4         5         6         7
d93 1
a93 1
        IF(NR.GT.NSAM/2-1)  THEN
d102 1
a102 1
           NRING=NRING+1
d163 1
a163 1
2600     FORMAT (/,' ',80('-'),//,
d165 1
a165 1
     &      ' ',80('-'),/)
d603 1
a603 1
C       Automatic arrays
d605 1
a605 1
        DIMENSION DLIST(NDLI,NUMTH)
d607 1
a607 1
	INTEGER  NASSIG(NUMTH)
d609 1
a609 1
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  REFER_CIRC
@


1.45
log
@cosmetic & error recovery
@
text
@d88 1
a88 1
        MR    = MAX0(2,MIN0(NR,MR))
@


1.44
log
@header & cosmetic
@
text
@d65 1
a65 1
2001       FORMAT('  Number of images =',I5)
d67 1
a67 1
           CALL ERRT(101,'  No images !',IDUM)
d79 1
a79 1
	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'SEARCH RANGE, STEP SIZE')
d88 4
a91 4
        MR=MAX0(2,MIN0(NR,MR))
        ISKIP=1
        MODE='F'
        NRING=0
d102 2
a103 2
        NRING=0
        DO    I=MR,NR,ISKIP
d121 1
a121 1
        MAXRIN=NUMR(3,NRING)
d131 1
a131 1
     &   'ENTER TEMPLATE FOR 2-D IMAGES TO BE ALIGNED',IRTFLG)
d571 1
a571 1
C $$ MRQLI_PS.FOR
a586 1

d602 1
a602 1
C
d608 5
a612 4
	ALLOCATE(A(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, A',IER)
	ALLOCATE(REFER_CIRC(LCIRC,NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, REFER_CIRC',IER)
d616 4
a619 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
d623 4
a626 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, TT',IER)
d630 9
a638 8
	NSNR=NSAM*NROW
	LO=2*NSI+1
	LT=LO*LO
C       Calculate dimensions for NORMAS
	NSB=-NSAM/2
	NSE=-NSB-1+MOD(NSAM,2)
	NRB=-NROW/2
	NRE=-NRB-1+MOD(NROW,2)
d640 2
a641 3
C PREPARE REFERENCES
	
C do it for all the reference images
d644 1
a644 1
	  CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
d646 6
a651 8
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSLICE,
     &        MAXIM,' ',.FALSE.,IRTFLG)
              IF(IRTFLG.NE.0)  THEN
                 WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
                 RETURN
              ENDIF
	      DO    J=1,NROW
	         CALL  REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
d656 1
a656 1
C          Normalize under the mask
d658 1
a658 1
c$omp parallel do private(IMI)
d662 4
a665 4
	  CALL  ALRQS(A(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
     &		LCIRC,NRING,MODE)
	      CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	  CALL  APPLYWS(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
d670 1
a670 1
C  alignment
d673 1
a673 1
C Loop over images to be aligned
d679 5
a683 7
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSLICE,
     &        MAXIM,' ',.FALSE.,IRTFLG)
              IF(IRTFLG.NE.0)  THEN
                 WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
                 RETURN
              ENDIF
              IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
d686 1
a686 1
	         RETURN
d688 1
a688 1
	      DO    J=1,NROW
d693 3
a695 2
C          NUMTH input images ready to be aligned
c$omp parallel do private(IMI)
d697 6
a702 6
	CALL  APMQ2D(A(1,1,IMI-IMIT+1),REFER_CIRC,TT,NUMR,
     &	   NSAM,NROW,NSI,ISTEP,
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
C             Output parameters are:
C             Number of the most similar reference projection.
C             Corr coeff.(D5), Angle (D4), Shift: XSHSUM, YSHSUM
d708 7
a714 7
C output (in DLIST position is increased by 1, No.1 is the key).
c 1 - Number of the most similar reference projection.
c 2 - Not-normalized correlation coefficient.
c 3 - Psi angle. (in=plane rotation)
c 4 - SX
c 5 - SY
c 6 - input image number.
d718 1
a718 1
     &	    ISIGN(ILIST(IABS(NASSIG(IMI-IMIT+1))),NASSIG(IMI-IMIT+1))
d721 1
a721 1
              CALL  SAVD(NDOC,DLIST(1,IMI-IMIT+1),NDLI,IRTFLG)
d725 2
a726 1
C       Over and out
d730 4
a733 4
C       Deallocate local arrays
	DEALLOCATE(TT)
	DEALLOCATE(REFER_CIRC)
	DEALLOCATE(A)
d737 1
d740 3
a742 3
     &	   NSAM,NROW,NSI,ISTEP,
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MODE,
     &	   IDI,D5,D4,XSHSUM,YSHSUM)
d749 2
a750 1
        CHARACTER*1  MODE
d753 1
a753 1
	DIMENSION  ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
d759 4
a762 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, A_CIRC',IER)
d764 26
a789 26
	QT=-1.0D23
	QM=-1.0D23
c       go through centers
	DO    JT=-NSI,NSI,ISTEP
	   CNR2=NROW/2+1+JT
	   DO    IT=-NSI,NSI,ISTEP
	      CNS2=NSAM/2+1+IT
C
C             Normalize under the mask
C
	CALL NORMASS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
	      CALL  ALRQ_MS
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	      CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
C  Loop over reference images
	      DO    IR=1,NIMA
	         CALL  CROSRNG_MS
     &		 (REFER_CIRC(1,IR),A_CIRC,LCIRC,NRING,
     &		 MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)
	         IF(TOTA.GE.QT)  THEN
	            QT=TOTA
	            IBE=IR
	            ISX=IT
	            ISY=JT
	            D4=ANG(TOT,MODE)
	            IDIS=IR
d791 7
a797 7
	         IF(TMTA.GE.QM)  THEN
	            QM=TMTA
	            IME=IR
	            IMX=IT
	            IMY=JT
	            E4=ANG(TMT,MODE)
	            IDIM=-IR
d803 4
a806 3
C TRY TO INTERPOLATE
	IF(QT.GT.QM)  THEN
C  For not-mirrored
d808 8
a815 8
C  Do not interpolate for point on the edge
	   IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
C  HAVE TO FIND NEIGHBOURING VALUES
	      FIT(0,0)=QT
	      ROTMP(0,0)=D4
	      DO     JT=-ISTEP,ISTEP
	         DO     IT=-ISTEP,ISTEP
	            IF(IT.NE.0 .OR. JT.NE.0) THEN
d818 10
a827 10
	               CALL NORMASS(A,
     &	NSB-(IT+ISX),NSE-(IT+ISX),NRB-(JT+ISY),NRE-(JT+ISY),
     &	               NUMR,NUMR(1,NRING))
	               CALL  ALRQ_MS
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	               CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	               CALL  CROSRNG_DS
     &		       (REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		       MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	               ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
d832 13
a844 13
C             Find the maximum within +/-ISTEP
C             Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
	      AFIT=FIT(0,0)
	      JTMA=0
	      ITMA=0
	      IF(ISTEP.GT.1)  THEN
	         DO     JT=-ISTEP+1,ISTEP-1
	            DO     IT=-ISTEP+1,ISTEP-1
	               IF(FIT(IT,JT).GT.AFIT)  THEN
	                  AFIT=FIT(IT,JT)
	                  D4=ROTMP(IT,JT)
	                  ITMA=IT
	                  JTMA=JT
d849 3
a851 3
C             Copy values around the peak.
	      DO     JT=-1,1
	         DO     IT=-1,1
d855 5
a859 4
C             Update location of the peak
	      QT=AFIT
	      ISX=ISX+ITMA
	      ISY=ISY+JTMA
d863 5
a867 5
	      IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	         SX=SX+ISX
	         SY=SY+ISY
	         CNR2=NROW/2+1+SY
	         CNS2=NSAM/2+1+SX
d869 8
a876 8
     &	         NUMR,NUMR(1,NRING))
	         CALL  ALRQ_MS
     &    (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	 CALL    FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL    CROSRNG_DS(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		 MAXRIN,NUMR,QT,D4,TT)
	         D5=QT
	         D4=ANG(D4,MODE)
d879 3
a881 3
	         D5=QT
	         SX=ISX
	         SY=ISY
d884 3
a886 3
	      D5=QT
	      SX=ISX
	      SY=ISY
d889 1
a889 1
           IDI=IDIM
d900 5
a904 5
	               CALL NORMASS(A,
     &	NSB-(IT+IMX),NSE-(IT+IMX),NRB-(JT+IMY),NRE-(JT+IMY),
     &	NUMR,NUMR(1,NRING))
	               CALL  ALRQ_MS
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
d906 3
a908 3
	               CALL  CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
d914 2
a915 2
C             Find the maximum within +/-ISTEP
C             Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
d919 4
a922 4
	      IF(ISTEP.GT.1)  THEN
	         DO     JT=-ISTEP+1,ISTEP-1
	            DO     IT=-ISTEP+1,ISTEP-1
	               IF(FIT(IT,JT).GT.AFIT)  THEN
d931 3
a933 3
C             Copy values around the peak.
	      DO     JT=-1,1
	         DO     IT=-1,1
d937 1
a937 1
C             Update location of the peak
d944 1
a944 1
	      IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
d950 8
a957 9
     &           NUMR,NUMR(1,NRING))
	         CALL  ALRQ_MS
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	         CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL    CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
     &		 MAXRIN,NUMR,QM,D4,TT)
	         D5=QM
	         D4=ANG(D4,MODE)
d960 4
a963 4
	         SX=IMX
	         SY=IMY
	         D4=E4
	         D5=QM
d966 4
a969 4
	      SX=IMX
	      SY=IMY
	      D4=E4
	      D5=QM
d973 12
a984 12
	SX=-SX
	SY=-SY
C  Now have to change order of shift&rotation.
C  In this program image is shifted first, rotated second.
C  In RT SQ it is rotation first, shift second.
C  This part corresponds to SA P.
	CO=COS(D4*DGR_TO_RAD)
	SO=-SIN(D4*DGR_TO_RAD)
	XSHSUM=SX*CO-SY*SO
	YSHSUM=SX*SO+SY*CO
C
	DEALLOCATE(A_CIRC)
@


1.43
log
@used CMLIMIT, ALOC. traps fixed, & cosmetic
@
text
@d28 4
d87 8
a94 8
         ENDIF
         MR=MAX0(2,MIN0(NR,MR))
         ISKIP=1
         MODE='F'
         NRING=0
         DO I=MR,NR,ISKIP
            NRING=NRING+1
	 ENDDO
d102 5
a106 5
         NRING=0
         DO    I=MR,NR,ISKIP
            NRING=NRING+1
            NUMR(1,NRING)=I
	 ENDDO
d108 2
a109 2
C        ADJUST SEARCH RANGE AND STEP SIZE.
	 IF (NSI+NR .GT. NSAM/2-2)  THEN
d245 3
a247 3
	     CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
	     MAXIM = 0
	     CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,
d249 6
a254 6
             IF (IRTFLG.NE.0)  RETURN
	     DO    J=1,NROW
	        CALL  REDLIN(INPIC,AI(1,J,IMI-IMIT+1),NSAM,J)
	     ENDDO
	     CLOSE(INPIC)
	  ENDDO
d256 1
a256 1
C         NORMALIZE UNDER THE MASK
d259 2
a260 2
	  DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	     CALL NORMASS(AI(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,
d262 1
a262 1
	     CALL  ALRQS(AI(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
d264 1
a264 1
	     CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
d266 1
a266 1
	  ENDDO
d318 3
a320 3
     &                NUMR,NRING)
	         DO    IR=1,NIMA
	           CALL  CROSRNG_MS
d322 5
a326 5
     &             NRING,MAXRIN,NUMR,
     &             TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &             TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
	        ENDDO
             ENDDO
d362 1
d368 6
a373 6
	  DO     JT=-ISTEP,ISTEP
	   DO     IT=-ISTEP,ISTEP
	   IF(IT.NE.0 .OR. JT.NE.0) THEN
	    CNR2=NROW/2+1+JT+ISY
	    CNS2=NSAM/2+1+IT+ISX
	    CALL NORMASC(A,AA(1,1,IT,JT),
d376 3
a378 3
	    CALL  ALRQ_MS
     &   (AA(1,1,IT,JT),NSAM,NROW,CNS2,CNR2,NUMR,
     &   A_CIRC(1,IT,JT),LCIRC,NRING,MODE)
d380 1
a380 1
	    CALL  CROSRNG_DS
d383 5
a387 5
	    ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	   ENDIF
	   ENDDO
	  ENDDO

d390 25
a414 25
	  AFIT=FIT(0,0)
	  JTMA=0
	  ITMA=0
	  IF(ISTEP.GT.1)  THEN
	   DO     JT=-ISTEP+1,ISTEP-1
	    DO     IT=-ISTEP+1,ISTEP-1
	     IF(FIT(IT,JT).GT.AFIT)  THEN
	      AFIT=FIT(IT,JT)
	      D4=ROTMP(IT,JT)
	      ITMA=IT
	      JTMA=JT
	     ENDIF
	    ENDDO
	   ENDDO
	  ENDIF
C  Copy values around the peak.
	  DO     JT=-1,1
	   DO     IT=-1,1
	    FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	   ENDDO
	  ENDDO
C Update location of the peak
	  QT=AFIT
	  ISX=ISX+ITMA
	  ISY=ISY+JTMA
d416 1
a416 1
	  CALL  PARABLD(FITP,SX,SY,PEAK)
d418 5
a422 5
	  IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	   SX=SX+ISX
	   SY=SY+ISY
	   CNR2=NROW/2+1+SY
	   CNS2=NSAM/2+1+SX
d424 23
a446 22
	   CALL  ALRQ_M
     &          (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	   CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	   CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,QT,D4,TT)
	   D5=QT
	   D4=ANG(D4,MODE)
	  ELSE
C INTERPOLATION FAILED
	   D5=QT
	   SX=ISX
	   SY=ISY
	  ENDIF
	 ELSE
	  D5=QT
	  SX=ISX
	  SY=ISY
	 ENDIF
	ELSE
         DLIST(2)=E6
C INTERPOLATE FOR MIRRORED
d448 3
a450 3
C  HAVE TO FIND NEIGHBOURING VALUES
	  FIT(0,0)=QM
	  ROTMP(0,0)=E4
d452 6
a457 6
	  DO     JT=-ISTEP,ISTEP
	   DO     IT=-ISTEP,ISTEP
	    IF(IT.NE.0 .OR. JT.NE.0) THEN
	     CNR2=NROW/2+1+JT+IMY
	     CNS2=NSAM/2+1+IT+IMX
	     CALL NORMASC(A,AA(1,1,IT,JT),
d460 1
a460 1
	     CALL  ALRQ_MS
d463 2
a464 2
	     CALL  FRNGS(A_CIRC(1,IT,JT),LCIRC,NUMR,NRING)
	     CALL  CROSRMG_DS
d466 42
a507 41
     &		MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	     ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	    ENDIF
	   ENDDO
	  ENDDO
C
C  Find the maximum within +/-ISTEP
C  Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
	  AFIT=FIT(0,0)
	  JTMA=0
	  ITMA=0
	  IF(ISTEP.GT.1)  THEN
	   DO     JT=-ISTEP+1,ISTEP-1
	    DO     IT=-ISTEP+1,ISTEP-1
	     IF(FIT(IT,JT).GT.AFIT)  THEN
	      AFIT=FIT(IT,JT)
	      E4=ROTMP(IT,JT)
	      ITMA=IT
	      JTMA=JT
	     ENDIF
	    ENDDO
	   ENDDO
	  ENDIF
C  Copy values around the peak.
	   DO     JT=-1,1
	    DO     IT=-1,1
	     FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	    ENDDO
	   ENDDO
C Update location of the peak
	   QM=AFIT
	   IMX=IMX+ITMA
	   IMY=IMY+JTMA
C
	   CALL  PARABLD(FITP,SX,SY,PEAK)
C CHECK WHETHER INTERPOLATION IS OK.
	   IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	    SX=SX+IMX
	    SY=SY+IMY
	    CNR2=NROW/2+1+SY
	    CNS2=NSAM/2+1+SX
d509 4
a512 4
	    CALL  ALRQ_M
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	    CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	    CALL  CROSRMG_DS
d514 29
a542 29
     &		MAXRIN,NUMR,QM,D4,TT)
	    D5=QM
	    D4=ANG(D4,MODE)
	   ELSE
C INTERPOLATION FAILED
	    SX=IMX
	    SY=IMY
	    D4=E4
	    D5=QM
	   ENDIF
	  ELSE
	   SX=IMX
	   SY=IMY
	   D4=E4
	   D5=QM
	  ENDIF
	 ENDIF
C
	 SX=-SX
	 SY=-SY
C  Now have to change order of shift&rotation.
C  In this program image is shifted first, rotated second.
C  In RT SQ it is rotation first, shift second.
C  This part corresponds to SA P.
	 CO=COS(D4*DGR_TO_RAD)
	 SO=-SIN(D4*DGR_TO_RAD)
	 XSHSUM=SX*CO-SY*SO
	 YSHSUM=SX*SO+SY*CO
C
d549 8
a556 7
         DLIST(3)=D5
         DLIST(4)=D4
         DLIST(5)=XSHSUM
         DLIST(6)=YSHSUM
         DLIST(7)=IRIST(IMI)
         DLIST(1)=IMI
         CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
d627 1
a627 1
C  Calculate dimensions for NORMAS
d634 1
a634 1

d637 1
a637 1
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
d639 1
a639 1
	  MAXIM = 0
d641 9
a649 7
     &               MAXIM,' ',.FALSE.,IRTFLG)
           IF(IRTFLG.NE.0)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
            RETURN
           ENDIF
	   DO    J=1,NROW
	    CALL  REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
a650 2
	   CLOSE(INPIC)
	 ENDDO
d652 1
a652 1
C  Normalize under the mask
d655 2
a656 2
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	  CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,
d660 1
a660 1
	  CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
d662 1
a662 1
	 ENDDO
d664 1
d670 2
a671 2
	DO  IMIT=1,NTOTAL,NUMTH
	 DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
d673 2
a674 2
	  CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
	  MAXIM = 0
d676 16
a691 16
     &               MAXIM,' ',.FALSE.,IRTFLG)
          IF(IRTFLG.NE.0)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
            RETURN
          ENDIF
          IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
            CALL ERRT(1,'AP MQ',NE)
            CLOSE(INPIC)
	    RETURN
	  ENDIF
	  DO    J=1,NROW
	   CALL  REDLIN(INPIC,A(1,J,IMI-IMIT+1),NSAM,J)
	  ENDDO
	  CLOSE(INPIC)
	 ENDDO
C NUMTH input images ready to be aligned
d693 2
a694 2
	 DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	  CALL  APMQ2D(A(1,1,IMI-IMIT+1),REFER_CIRC,TT,NUMR,
d697 7
a703 7
C Output parameters are:
C Number of the most similar reference projection.
C Corr coeff.(D5), Angle (D4), Shift: XSHSUM, YSHSUM
     &		NASSIG(IMI-IMIT+1),
     &		DLIST(3,IMI-IMIT+1),DLIST(4,IMI-IMIT+1),
     &		DLIST(5,IMI-IMIT+1),DLIST(6,IMI-IMIT+1))
	 ENDDO
d713 2
a714 2
	 DO  IMI=IMIT,MIN(NTOTAL,IMIT+NUMTH-1)
	  DLIST(2,IMI-IMIT+1)=
d716 4
a719 4
          DLIST(7,IMI-IMIT+1)=IRIST(IMI)
          DLIST(1,IMI-IMIT+1)=IMI
          CALL  SAVD(NDOC,DLIST(1,IMI-IMIT+1),NDLI,IRTFLG)
	 ENDDO
d759 3
a761 3
	CNR2=NROW/2+1+JT
	DO    IT=-NSI,NSI,ISTEP
	CNS2=NSAM/2+1+IT
d763 1
a763 1
C       Normalize under the mask
d766 1
a766 1
	CALL  ALRQ_MS
d768 1
a768 1
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
d770 23
a792 23
	 DO    IR=1,NIMA
	 CALL  CROSRNG_MS
     &		(REFER_CIRC(1,IR),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,TOTA,TOT,TMTA,TMT,TT)
	  IF(TOTA.GE.QT)  THEN
	   QT=TOTA
	   IBE=IR
	   ISX=IT
	   ISY=JT
	   D4=ANG(TOT,MODE)
	   IDIS=IR
	  ENDIF
	  IF(TMTA.GE.QM)  THEN
	   QM=TMTA
	   IME=IR
	   IMX=IT
	   IMY=JT
	   E4=ANG(TMT,MODE)
	   IDIM=-IR
	  ENDIF
	 ENDDO 
C  END-OF-LOOP 1 OVER REFERENCE IMAGES
	ENDDO
d797 1
a797 1
        IDI=IDIS
d799 1
a799 1
	IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d801 8
a808 8
	 FIT(0,0)=QT
	 ROTMP(0,0)=D4
	 DO     JT=-ISTEP,ISTEP
	  DO     IT=-ISTEP,ISTEP
	   IF(IT.NE.0 .OR. JT.NE.0) THEN
	    CNR2=NROW/2+1+JT+ISY
	    CNS2=NSAM/2+1+IT+ISX
	    CALL NORMASS(A,
d810 2
a811 2
     &	NUMR,NUMR(1,NRING))
	    CALL  ALRQ_MS
d813 63
a875 22
	    CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	    CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,FIT(IT,JT),ROTMP(IT,JT),TT)
	    ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	  ENDIF
	 ENDDO
	ENDDO
C
C  Find the maximum within +/-ISTEP
C  Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
	AFIT=FIT(0,0)
	JTMA=0
	ITMA=0
	IF(ISTEP.GT.1)  THEN
	 DO     JT=-ISTEP+1,ISTEP-1
	  DO     IT=-ISTEP+1,ISTEP-1
	   IF(FIT(IT,JT).GT.AFIT)  THEN
	    AFIT=FIT(IT,JT)
	    D4=ROTMP(IT,JT)
	    ITMA=IT
	    JTMA=JT
a876 36
	  ENDDO
	 ENDDO
	ENDIF
C  Copy values around the peak.
	DO     JT=-1,1
	 DO     IT=-1,1
	  FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	 ENDDO
	ENDDO
C Update location of the peak
	QT=AFIT
	ISX=ISX+ITMA
	ISY=ISY+JTMA
C
	CALL  PARABLD(FITP,SX,SY,PEAK)
C CHECK WHETHER INTERPOLATION IS OK.
	IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	 SX=SX+ISX
	 SY=SY+ISY
	 CNR2=NROW/2+1+SY
	 CNS2=NSAM/2+1+SX
	 CALL NORMASS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
     &	              NUMR,NUMR(1,NRING))
	 CALL  ALRQ_MS
     &    (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	 CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL  CROSRNG_DS(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
     &		MAXRIN,NUMR,QT,D4,TT)
	 D5=QT
	 D4=ANG(D4,MODE)
	ELSE
C INTERPOLATION FAILED
	 D5=QT
	 SX=ISX
	 SY=ISY
	ENDIF
d878 12
a889 17
	D5=QT
	SX=ISX
	SY=ISY
	ENDIF
	ELSE
        IDI=IDIM
C INTERPOLATE FOR MIRRORED
	IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
C  HAVE TO FIND NEIGHBOURING VALUES
	 FIT(0,0)=QM
	 ROTMP(0,0)=E4
	 DO     JT=-ISTEP,ISTEP
	  DO     IT=-ISTEP,ISTEP
	   IF(IT.NE.0 .OR. JT.NE.0) THEN
	    CNR2=NROW/2+1+JT+IMY
	    CNS2=NSAM/2+1+IT+IMX
	    CALL NORMASS(A,
d892 1
a892 1
	    CALL  ALRQ_MS
d894 2
a895 2
	   CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	   CALL  CROSRMG_DS
d898 43
a940 43
	    ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	   ENDIF
	  ENDDO
	 ENDDO
C
C  Find the maximum within +/-ISTEP
C  Maximum cannot be on the edge, i.e., IT,JT/=ISTEP
	AFIT=FIT(0,0)
	JTMA=0
	ITMA=0
	IF(ISTEP.GT.1)  THEN
	 DO     JT=-ISTEP+1,ISTEP-1
	  DO     IT=-ISTEP+1,ISTEP-1
	   IF(FIT(IT,JT).GT.AFIT)  THEN
	    AFIT=FIT(IT,JT)
	    E4=ROTMP(IT,JT)
	    ITMA=IT
	    JTMA=JT
	   ENDIF
	  ENDDO
	 ENDDO
	ENDIF
C  Copy values around the peak.
	DO     JT=-1,1
	 DO     IT=-1,1
	  FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	 ENDDO
	ENDDO
C Update location of the peak
	QM=AFIT
	IMX=IMX+ITMA
	IMY=IMY+JTMA
C
	CALL  PARABLD(FITP,SX,SY,PEAK)
C CHECK WHETHER INTERPOLATION IS OK.
	IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	 SX=SX+IMX
	 SY=SY+IMY
	 CNR2=NROW/2+1+SY
	 CNS2=NSAM/2+1+SX
	 CALL NORMASS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,
     &   NUMR,NUMR(1,NRING))
	 CALL  ALRQ_MS
d942 2
a943 2
	 CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL  CROSRMG_DS
d945 16
a960 15
     &		MAXRIN,NUMR,QM,D4,TT)
	 D5=QM
	 D4=ANG(D4,MODE)
	ELSE
C INTERPOLATION FAILED
	 SX=IMX
	 SY=IMY
	 D4=E4
	 D5=QM
	ENDIF
	ELSE
	SX=IMX
	SY=IMY
	D4=E4
	D5=QM
d962 1
a962 2
	ENDIF
C
@


1.42
log
@used getthreads & format 2600 changed to add ,s
@
text
@d3 1
a3 1
C    MRQLI.F
d15 1
a15 1
C       SUBROUTINE MRQLI
d24 1
a24 1
C         SUBROUTINE  FRNGS
d31 1
a31 1
	PARAMETER  (NILMAX=99998)
d33 4
a36 1
C be careful with the common, it has to agree with 64 bits...
d38 1
a38 1
	CHARACTER*80  FINPAT,FINPIC,FILTOA
d40 1
a40 1
	INTEGER  MAXRIN
d43 2
a44 1
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  ILIST,IRIST
d46 9
a54 3
C
	ALLOCATE(ILIST(NILMAX))
C  ASK FOR DATA FILE
d56 15
a70 13
     &   'ENTER TEMPLATE FOR 2-D REFERENCE IMAGE NAME',IRTFLG)
	IF (IRTFLG .NE. 0) RETURN
         IF(NIMA.GT.0)  THEN
         WRITE(NOUT,2001) NIMA
2001     FORMAT('  Number of images =',I5)
         ELSE
         WRITE(NOUT,*)  '  No images !'
         RETURN
         ENDIF
C     GET FIRST PICTURE TO DETERMINE DIMS
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d72 3
a74 6
         IF(IRTFLG.NE.0)  THEN
          CALL ERRT(4,'AP MQ ',NE)
          RETURN
         ENDIF
         CLOSE(INPIC)
C
d76 7
a82 7
	NSI=MAX0(NSI,1)
	ISTEP=MAX0(ISTEP,1)
C
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
         IF(NR.GT.NSAM/2-1)  THEN
          NR=NSAM/2-1
          WRITE(NOUT,*)  ' Last ring limited to ',NR
d88 2
a89 2
         DO    I=MR,NR,ISKIP
          NRING=NRING+1
d91 1
d93 5
a97 1
	IF(IRTFLG.NE.0) CALL ERRT(46,'AP MQ, NUMR',IER)
d100 2
a101 2
          NRING=NRING+1
          NUMR(1,NRING)=I
d103 5
a107 4
C  Adjust search range and step size.
	 IF(NSI+NR.GT.NSAM/2-2)  THEN
	  CALL ERRT(101,'Search range too large',NE)
	  RETURN
d109 5
a113 3
	IF(MOD(NSI,ISTEP).NE.0) THEN
	CALL ERRT(101,'Search range has to be divisible by step size',NE)
	RETURN
d115 11
a125 7
C
         CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)
C
	ALLOCATE(IRIST(NILMAX))
C
C  images to be aligned
d128 1
a128 1
	IF(IRTFLG.NE.0) RETURN
d132 5
a136 5
C NIMA number of the reference images
C
	IF(NTOTAL.GE.NUMTH)  THEN
C for mp, large number of images to be aligned, or sp.
         CALL  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d139 3
a141 3
C  For a small number of images to be aligned use different strategy
C  to make mp efficient.
         CALL  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d144 5
a148 4
C
	 DEALLOCATE(IRIST)
	 DEALLOCATE(ILIST)
	 DEALLOCATE(NUMR)
a149 1
         RETURN
d153 2
d156 2
a157 1
C
d160 1
a160 1
C $$ MRQLI_SS.FOR
d176 1
a176 3
C
C $$ MRQLI_SS.FOR
C
d179 1
d189 2
a190 1
C Automatic arrays
d204 1
a204 1
C
d208 1
d210 1
a210 3
C
C -------------------------
C
d212 2
a213 2
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AM MQ, REFER_CIRC',IER)
C -------------------------
d223 1
a223 1
C
d226 1
a226 1
C
d230 1
a230 1
C  Calculate dimensions for NORMAS
d235 4
a238 4
C
C PREPARE REFERENCES
C
C do it for all the reference images
d240 14
a253 17
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	  CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(IMI),INTFLAG)
	  MAXIM = 0
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
           IF(IRTFLG.NE.0)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
            RETURN
           ENDIF
	   DO    J=1,NROW
	    CALL  REDLIN(INPIC,AI(1,J,IMI-IMIT+1),NSAM,J)
	   ENDDO
	   CLOSE(INPIC)
	 ENDDO
C
C  Normalize under the mask
C
d255 2
a256 2
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
	  CALL NORMASS(AI(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,
d258 1
a258 1
	  CALL  ALRQS(AI(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
d260 3
a262 3
	  CALL  FRNGS(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	  CALL  APPLYWS(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
	 ENDDO
d264 1
a264 1
C
d268 2
d275 2
a276 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, A_CIRC',IER)
d278 4
a281 4
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MQ, AA',IER)
C
C  images to be aligned
C Loop over images to be aligned
d283 14
a296 11
C
	CALL  FILGET(FILTOA,FINPIC,NLETI,IRIST(IMI),INTFLAG)
	  MAXIM = 0
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
          IF(IRTFLG.NE.0)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
            RETURN
          ENDIF
          IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
           CALL ERRT(1,'AP MQ',NE)
d298 2
a299 8
	   RETURN
	  ENDIF
	  DO    J=1,NROW
	   CALL  REDLIN(INPIC,A(1,J),NSAM,J)
	   ENDDO
	   CLOSE(INPIC)
C
c go through reference images and centers
d301 13
a313 13
	DO    JT=-NSI,NSI,ISTEP
	 CNR2=NROW/2+1+JT
	 DO    IT=-NSI,NSI,ISTEP
	  CNS2=NSAM/2+1+IT
C
C  Normalize under the mask
C
	 CALL NORMASC(A,AA(1,1,IT/ISTEP,JT/ISTEP),
     &    NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
	  CALL  ALRQ_MS
     &    (AA(1,1,IT/ISTEP,JT/ISTEP),NSAM,NROW,CNS2,CNR2,NUMR,
     &    A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NRING,MODE)
	  CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
d315 47
a361 46
	   DO    IR=1,NIMA
	    CALL  CROSRNG_MS
     &		(REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &          NRING,MAXRIN,NUMR,
     &	        TOTA(IR,IT,JT),TOT(IR,IT,JT),
     &	        TMTA(IR,IT,JT),TMT(IR,IT,JT),TT)
	   ENDDO
	 ENDDO
	ENDDO
C end of the parallel section
C Locate best match
C
	QT=-1.0D23
	QM=-1.0D23
	DO    JT=-NSI,NSI,ISTEP
	 DO    IT=-NSI,NSI,ISTEP
	  DO    IR=1,NIMA
	  IF(TOTA(IR,IT,JT).GE.QT)  THEN
	   QT=TOTA(IR,IT,JT)
	   IBE=IR
	   ISX=IT
	   ISY=JT
	   D4=ANG(TOT(IR,IT,JT),MODE)
	   D6=ILIST(IR)
	  ENDIF
	  IF(TMTA(IR,IT,JT).GE.QM)  THEN
	   QM=TMTA(IR,IT,JT)
	   IME=IR
	   IMX=IT
	   IMY=JT
	   E4=ANG(TMT(IR,IT,JT),MODE)
	   E6=-ILIST(IR)
	  ENDIF
	  ENDDO
	 ENDDO
	ENDDO
C
C TRY TO INTERPOLATE
	IF(QT.GT.QM)  THEN
C  For not-mirrored
         DLIST(2)=D6
C  Do not interpolate for point on the edge
	 IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
C  HAVE TO FIND NEIGHBOURING VALUES
	  FIT(0,0)=QT
	  ROTMP(0,0)=D4
d382 1
a382 1
C
d559 2
a560 2
C
C
a575 1
C
d578 2
a579 3
C
C $$ MRQLI_PS.FOR
C
d582 1
d586 2
a587 1
C Automatic arrays
d600 1
a600 1
C -------------------------
d605 1
a605 1
C -------------------------
d615 1
a615 1
C
d624 1
a624 1
C
d626 1
a626 1
C
d643 1
a643 1
C
d645 1
a645 1
C
d659 1
a659 1
C
d663 1
a663 1
C
d695 1
d703 1
a703 1
C
d713 1
a713 1
C Over and out
d716 2
a717 1
C  Deallocate local arrays
d722 3
a724 1
C
d729 1
d736 1
a736 1
C Automatic arrays
d742 1
a742 1
C
d745 1
a745 1
C
d748 1
a748 1
c go through centers
d754 1
a754 1
C  Normalize under the mask
@


1.41
log
@reverted to r1.37
@
text
@d46 1
a46 1
     &   'Enter template for 2-D reference image name',IRTFLG)
d66 1
a66 1
	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'Search range, step size')
d106 1
a106 1
     &   'Enter template for 2-D images to be aligned',IRTFLG)
d108 3
a110 12
C
#ifdef SP_MP
c$omp parallel private(np)
        np = OMP_GET_NUM_THREADS()
c$omp single
        NUMTH=np
c$omp end single
c$omp end parallel
#else
         NUMTH=1
#endif
C
d129 3
a131 2
2600     FORMAT (/' ',80('-')//' ',' Multi-reference alignment,  ',
     &   'end of computation',//' ',80('-')/)
@


1.40
log
@Used getthreads & cosmetic
@
text
@d15 1
a15 3
C   MRQLI.
C
C        SUBROUTINE  MRQLI
d24 1
a24 1
C        SUBROUTINE  FRNGS
a30 1

a40 1

d42 1
a42 1

d44 1
a44 1
C       ASK FOR DATA FILE
d46 1
a46 1
     &   'ENTER TEMPLATE FOR 2-D REFERENCE IMAGE NAME',IRTFLG)
d48 11
a58 14

        IF (NIMA .GT. 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT(' NUMBER OF IMAGES =',I5)
        ELSE
           WRITE(NOUT,*)  ' NO IMAGES !'
           RETURN
        ENDIF

C       GET FIRST PICTURE TO DETERMINE DIMS
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)

	MAXIM = 0
	CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d60 10
a69 10
        IF (IRTFLG .NE. 0)  THEN
            CALL ERRT(4,'AP MQ ',NE)
            RETURN
        ENDIF
        CLOSE(INPIC)

	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'SEARCH RANGE, STEP SIZE')
	NSI   = MAX0(NSI,1)
	ISTEP = MAX0(ISTEP,1)

d71 3
a73 3
         IF (NR .GT. NSAM/2-1)  THEN
            NR = NSAM/2-1
            WRITE(NOUT,*)  ' LAST RING LIMITED TO ',NR
d79 2
a80 2
         DO I=MR,NR,ISKIP
            NRING=NRING+1
d82 2
a83 4

	 ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	 IF(IRTFLG.NE.0) CALL ERRT(46,'AP MQ, NUMR',IER)

d95 1
a95 2
	CALL ERRT(101,
     &     'Search range has to be divisible by step size',NE)
d98 1
a98 1

d101 24
a124 16

	 ALLOCATE(IRIST(NILMAX))

C        IMAGES TO BE ALIGNED
	 CALL FILELIST(.TRUE.,INPIC,FILTOA,NLETI,IRIST,NILMAX,NTOTAL,
     &     'ENTER TEMPLATE FOR 2-D IMAGES TO BE ALIGNED',IRTFLG)
	 IF(IRTFLG.NE.0) RETURN

C        FIND NUMBER OF OMP THREADS
         CALL GETTHREADS(NUMTH)

C        NIMA NUMBER OF THE REFERENCE IMAGES

	IF (NTOTAL.GE.NUMTH)  THEN
C          FOR MP, LARGE NUMBER OF IMAGES TO BE ALIGNED, OR SP.
           CALL  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d127 3
a129 3
C          FOR A SMALL NUMBER OF IMAGES TO BE ALIGNED USE DIFFERENT 
C          STRATEGY TO MAKE MP EFFICIENT.
           CALL  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d138 2
a139 5

2600     FORMAT (/' ',80('-'),//,
     &            ' ',' MULTI-REFERENCE ALIGNMENT,  ',
     &                'END OF COMPUTATION',//,
     &            ' ',80('-')/)
d141 1
a141 2


d144 1
a144 1
C    MRQLI_SS.F 
d160 3
a162 1

a164 1

d247 1
a247 1
     &           REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
d301 2
a302 1
	  CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NUMR,NRING)
d305 2
a306 3
     &		(REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),
     &          LCIRC,NRING,
     &		MAXRIN,NUMR,
d405 1
a405 2
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,
     &              NUMR,NUMR(1,NRING))
d407 1
a407 1
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
d488 1
a488 2
	CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,NUMR,
     &              NUMR(1,NRING))
d546 2
a547 2


d550 1
a550 1
C MRQLI_PS.F
d562 2
d566 3
a568 1

a570 1

d582 1
a582 1

d602 1
a602 1

d611 1
a611 1

d613 1
a613 1

d630 1
a630 1

d632 1
a632 1

d635 3
a637 4
	  CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,
     &                NUMR(1,NRING))
	  CALL  ALRQS(A(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,
     &                REFER_CIRC(1,IMI),
d643 1
a643 1

d645 2
a646 1

d682 1
a682 1
C output (in DLIST position is increased by 1, #1 is the key).
@


1.39
log
@ibm did not like line length, etc
@
text
@d3 1
a3 1
C    MRQLI.FOR
d15 1
a15 1
C   MRQLI.FOR
d17 1
a17 1
C       SUBROUTINE MRQLI
d26 1
a26 1
C         SUBROUTINE  FRNGS
d33 1
d44 1
d46 1
a46 1
C
d48 1
a48 1
C  ASK FOR DATA FILE
d50 1
a50 1
     &   'Enter template for 2-D reference image name',IRTFLG)
d52 14
a65 11
         IF(NIMA.GT.0)  THEN
         WRITE(NOUT,2001) NIMA
2001     FORMAT('  Number of images =',I5)
         ELSE
         WRITE(NOUT,*)  '  No images !'
         RETURN
         ENDIF
C     GET FIRST PICTURE TO DETERMINE DIMS
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d67 10
a76 10
         IF(IRTFLG.NE.0)  THEN
          CALL ERRT(4,'AP MQ ',NE)
          RETURN
         ENDIF
         CLOSE(INPIC)
C
	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'Search range, step size')
	NSI=MAX0(NSI,1)
	ISTEP=MAX0(ISTEP,1)
C
d78 3
a80 3
         IF(NR.GT.NSAM/2-1)  THEN
          NR=NSAM/2-1
          WRITE(NOUT,*)  ' Last ring limited to ',NR
d86 2
a87 2
         DO    I=MR,NR,ISKIP
          NRING=NRING+1
d89 4
a92 2
	ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL ERRT(46,'AP MQ, NUMR',IER)
d108 1
a108 1
C
d111 16
a126 24
C
	ALLOCATE(IRIST(NILMAX))
C
C  images to be aligned
	CALL FILELIST(.TRUE.,INPIC,FILTOA,NLETI,IRIST,NILMAX,NTOTAL,
     &   'ENTER TEMPLATE FOR 2-D IMAGES TO BE ALIGNED',IRTFLG)
	IF(IRTFLG.NE.0) RETURN
C
#ifdef SP_MP
c$omp parallel private(np)
        np = OMP_GET_NUM_THREADS()
c$omp single
        NUMTH=np
c$omp end single
c$omp end parallel
#else
         NUMTH=1
#endif
C
C NIMA number of the reference images
C
	IF(NTOTAL.GE.NUMTH)  THEN
C for mp, large number of images to be aligned, or sp.
         CALL  MRQLI_PS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d129 3
a131 3
C  For a small number of images to be aligned use different strategy
C  to make mp efficient.
         CALL  MRQLI_SS(ILIST,NIMA,IRIST,NTOTAL,NSAM,NROW,NSI,
d140 5
a144 2
2600     FORMAT (/' ',80('-')//' ',' Multi-reference alignment,  ',
     &   'end of computation',//' ',80('-')/)
d146 2
a147 1
C
d150 1
a150 1
C $$ MRQLI_SS.FOR
d166 1
a166 3
C
C $$ MRQLI_SS.FOR
C
d169 1
d553 2
a554 2
C
C
d648 1
a648 1
C
d650 1
a650 2
C
C
@


1.38
log
@*** empty log message ***
@
text
@d3 1
a3 1
C    MRQLI.F
d15 2
d97 2
a98 1
	CALL ERRT(101,'Search range has to be divisible by step size',NE)
d109 1
a109 1
     &   'Enter template for 2-D images to be aligned',IRTFLG)
d250 1
a250 1
     &          REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
d304 1
a304 2
	  CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &                NUMR,NRING)
d307 3
a309 2
     &		(REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,
     &          NRING,MAXRIN,NUMR,
d408 2
a409 1
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
d411 1
a411 1
     &          (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
d492 2
a493 1
	CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,NUMR,NUMR(1,NRING))
d555 1
a555 1
C $$ MRQLI_PS.FOR
a566 2
C
C
d569 1
a569 3
C
C $$ MRQLI_PS.FOR
C
d572 1
d584 1
a584 1
C
d604 1
a604 1
C
d613 1
a613 1
C
d615 1
a615 1
C
d632 1
a632 1
C
d634 1
a634 2
C
         ITEMP = IMIT+NUMTH-1
d636 3
a638 3
	 DO  IMI=IMIT,MIN(NIMA,ITEMP)
	  CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,
     &                 NUMR,NUMR(1,NRING))
d640 2
a641 1
     &                REFER_CIRC(1,IMI), LCIRC,NRING,MODE)
d646 1
a646 1
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
d648 1
a648 1
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
d685 1
a685 1
C output (in DLIST position is increased by 1, No.1 is the key).
@


1.37
log
@line length over 72
@
text
@d633 1
d635 1
a635 1
	 DO  IMI=IMIT,MIN(NIMA,IMIT+NUMTH-1)
d638 2
a639 2
	  CALL  ALRQS(A(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
     &		LCIRC,NRING,MODE)
@


1.36
log
@ # continue char fails on NT f90
@
text
@d177 2
a178 1
	DIMENSION  TOT(NIMA,-NSI:NSI,-NSI:NSI),TMT(NIMA,-NSI:NSI,-NSI:NSI)
d246 2
a247 2
	  CALL  ALRQS(AI(1,1,IMI-IMIT+1),NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
     &		LCIRC,NRING,MODE)
d635 2
a636 1
	  CALL NORMASS(A(1,1,IMI-IMIT+1),NSB,NSE,NRB,NRE,NUMR,NUMR(1,NRING))
@


1.35
log
@overlength lines fixed
@
text
@d3 1
a3 1
C    MRQLI.FOR
a14 2
C   MRQLI.FOR
C
d139 1
a139 1
     #   'end of computation',//' ',80('-')/)
d680 1
a680 1
C output (in DLIST position is increased by 1, #1 is the key).
@


1.34
log
@negative mirror
@
text
@d302 2
a303 1
	  CALL  FRNGS(A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NUMR,NRING)
d306 2
a307 2
     &		(REFER_CIRC(1,IR),A_CIRC(1,IT/ISTEP,JT/ISTEP),LCIRC,NRING,
     &		MAXRIN,NUMR,
d408 1
a408 1
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
@


1.33
log
@*** empty log message ***
@
text
@a256 2
c find max element on ILIST
	MAXIMA=MAXVAL(ILIST)
d334 1
a334 1
	   E6=ILIST(IR)
d426 1
a426 1
         DLIST(2)=E6+MAXIMA
d578 1
a641 2
c find max element on ILIST
	MAXIMA=MAXVAL(ILIST)
d673 1
a673 1
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,ILIST,NIMA,MAXIMA,MODE,
d677 1
a677 1
     &		DLIST(2,IMI-IMIT+1),
d690 2
d709 2
a710 2
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,ILIST,NIMA,MAXIMA,MODE,
     &	   DLIST2,D5,D4,XSHSUM,YSHSUM)
a712 1
	INTEGER  ILIST(NIMA)
d752 1
a752 1
	   D6=ILIST(IR)
d760 1
a760 1
	   E6=ILIST(IR)
d769 1
a769 1
        DLIST2=D6
d850 1
a850 1
        DLIST2=E6+MAXIMA
@


1.32
log
@*** empty log message ***
@
text
@d676 1
a676 1
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MAXIMA,MODE,
d710 1
a710 1
     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MAXIMA,MODE,
d714 1
d754 1
a754 1
	   D6=IR
d762 1
a762 1
	   E6=IR
@


1.31
log
@*** empty log message ***
@
text
@a948 603
C
        SUBROUTINE  NORMASC(X,Y,NS1,NS2,NR1,NR2,IR1,IR2)
        DIMENSION  X(NS1:NS2,NR1:NR2),Y(NS1:NS2,NR1:NR2)
        INTEGER  IR1,IR2
        REAL*8  AV,VR
        R1=IR1
        R2=IR2
        AV=0.0
        VR=0.0
        N=0
        DO    J=NR1,NR2
         DO    I=NS1,NS2
          R=SQRT(FLOAT(J*J+I*I))
          IF(R.GE.R1.AND.R.LE.R2)  THEN
	   N=N+1
           AV=AV+X(I,J)
           VR=VR+X(I,J)*X(I,J)
          ENDIF
        ENDDO
        ENDDO
C
        AV=AV/N
        VR=DSQRT((VR-N*AV*AV)/(N-1))
C
        Y=(X-AV)/VR
        END
C
        SUBROUTINE  NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
        DIMENSION  X(NS1:NS2,NR1:NR2)
        INTEGER  IR1,IR2
        REAL*8  AV,VR
        R1=IR1
        R2=IR2
        AV=0.0
        VR=0.0
        N=0
        DO    J=NR1,NR2
         DO    I=NS1,NS2
          R=SQRT(FLOAT(J*J+I*I))
          IF(R.GE.R1.AND.R.LE.R2)  THEN
	   N=N+1
           AV=AV+X(I,J)
           VR=VR+X(I,J)*X(I,J)
          ENDIF
        ENDDO
        ENDDO
C
        AV=AV/N
        VR=DSQRT((VR-N*AV*AV)/(N-1))
C
        X=(X-AV)/VR
        END
C
        SUBROUTINE  ALRQ_MS
     &  (XIM,NSAM,NROW,CNS2,CNR2,NUMR,CIRC,LCIRC,NRING,MODE)
        DIMENSION  XIM(NSAM,NROW),CIRC(LCIRC)
        INTEGER  NUMR(3,NRING)
        CHARACTER*1  MODE
        DOUBLE PRECISION  PI,DFI
C
C  INTERPOLATION INTO POLAR COORDINATES
C
C        CNS2 and CNR2 are predefined centers
CC no need to set to zero, all elements are defined
C        DO  10  I=1,LCIRC
C 10     CIRC(I)=0.0
C
        PI=2*DATAN(1.0D0)
        DO  I=1,NRING
C
C  RADIUS OF THE RING
        INR=NUMR(1,I)
        YQ=INR
C
        L=NUMR(3,I)
        IF(MODE.EQ.'H')  THEN
        LT=L/2
        ENDIF
        IF(MODE.EQ.'F')  THEN
        LT=L/4
        ENDIF
        NSIM=LT-1
        DFI=PI/(NSIM+1)
        KCIRC=NUMR(2,I)
        XOLD=0.0
        YOLD=INR
        CIRC(KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        XOLD=INR
        YOLD=0.0
        CIRC(LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        IF(MODE.EQ.'F')  THEN
        XOLD=0.0
        YOLD=-INR
        CIRC(LT+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        XOLD=-INR
        YOLD=0.0
        CIRC(LT+LT+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        ENDIF
        DO   J=1,NSIM
        FI=DFI*J
        X=SIN(FI)*YQ
        Y=COS(FI)*YQ
C
        XOLD=X
        YOLD=Y
        CIRC(J+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        XOLD=Y
        YOLD=-X
        CIRC(J+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        IF(MODE.EQ.'F')  THEN
        XOLD=-X
        YOLD=-Y
        CIRC(J+LT+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        XOLD=-Y
        YOLD=X
        CIRC(J+LT+LT+LT+KCIRC)=QUADRI(XOLD+CNS2,YOLD+CNR2,NSAM,NROW,XIM)
        ENDIF
	ENDDO
	ENDDO
C
        END
C++************************************************************************
C
C $$ CROSRNG_MS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ CROSRNG_MS.FOR
C
	SUBROUTINE  CROSRNG_MS
     &   (CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,QM,TMT,TT)
C
C  INPUT - Fourier transforms of rings!!!
C  CIRC1 already multiplied by weights!!
C
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*)
	DOUBLE PRECISION  QN,QM,T7(-3:3)
C  Automatic arrays
	DOUBLE PRECISION  T(MAXRIN+2),Q(MAXRIN+2)
	IP=MAXRIN
#ifdef SP_LIBFFT
#else
	IP=-LOG2_P(IP)
#endif
C
C C - straight  = CIRC1*CONJG(CIRC2)
	Q=0.0D0
C T - mirrored  = CONJG(CIRC1)*CONJG(CIRC2)
	T=0.0D0
C
	DO    I=1,NRING
	NUMR3I=NUMR(3,I)
	NUMR2I=NUMR(2,I)
C
	T1=CIRC1(NUMR2I)*CIRC2(NUMR2I)
	Q(1)=Q(1)+T1
	T(1)=T(1)+T1
C
	IF(NUMR3I.EQ.MAXRIN)  THEN
	T1=CIRC1(NUMR2I+1)*CIRC2(NUMR2I+1)
	Q(2)=Q(2)+T1
	T(2)=T(2)+T1
C
	ELSE
	T1=CIRC1(NUMR2I+1)*CIRC2(NUMR2I+1)
	Q(NUMR3I+1)=Q(NUMR3I+1)+T1
C###
	ENDIF
C
	DO   J=3,NUMR3I,2
	JC=J+NUMR2I-1
	C1=CIRC1(JC)
	C2=CIRC1(JC+1)
	T1=C1*CIRC2(JC)
	T2=C2*CIRC2(JC+1)
	T3=C1*CIRC2(JC+1)
	T4=C2*CIRC2(JC)
	Q(J)=Q(J)+T1+T2
	Q(J+1)=Q(J+1)-T3+T4
	T(J)=T(J)+T1-T2
	T(J+1)=T(J+1)-T3-T4
	ENDDO
	ENDDO
C  STRAIGHT
#ifdef SP_LIBFFT
	INV=-1
	LDA=1
	Q(MAXRIN+1)=Q(2)
	Q(2)=0.0
	Q(MAXRIN+2)=0.0
	CALL  ZDFFT1DU(INV,IP,Q,LDA,TT)
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),Q,LDA)
#else
	CALL  FFTR_D(Q,IP)
#endif
C
	QN=-1.0D20
	DO    J=1,MAXRIN
	IF(Q(J).GE.QN)  THEN
	QN=Q(J)
	JTOT=J
	ENDIF
	ENDDO
#ifdef SP_LIBFFT
	QN=QN/MAXRIN
#endif
C
	DO    K=-3,3
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=Q(J)
	ENDDO
	CALL  PRB1D(T7,7,POS)
	TOT=FLOAT(JTOT)+POS
C  MIRRORED
#ifdef SP_LIBFFT
 	T(MAXRIN+1)=T(2)
	T(2)=0.0
	T(MAXRIN+2)=0.0
	CALL  ZDFFT1DU(INV,IP,T,LDA,TT)
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),T,LDA)
#else
	CALL  FFTR_D(T,IP)
#endif
C
	QM=-1.0D20
	DO    J=1,MAXRIN
	IF(T(J).GE.QM)  THEN
	QM=T(J)
	JTOT=J
	ENDIF
	ENDDO
#ifdef SP_LIBFFT
	QM=QM/MAXRIN
#endif
C
	DO    K=-3,3
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=T(J)
	ENDDO
	CALL  PRB1D(T7,7,POS)
	TMT=FLOAT(JTOT)+POS
	END
C++************************************************************************
C
C $$ CROSRMG_DS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ CROSRMG_DS.FOR
C
	SUBROUTINE  CROSRMG_DS
     &   (CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,TT)
C
C  INPUT - Fourier transforms of rings!!!
C  First set is conjugated (mirrored)
C  CIRC1 already multiplied by weights!!
C
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*)
	DOUBLE PRECISION  QN,T7(-3:3)
C  Automatic arrays
	DIMENSION  T(MAXRIN+2)
	DOUBLE PRECISION  Q(MAXRIN+2)
	IP=MAXRIN
#ifdef SP_LIBFFT
#else
	IP=-LOG2_P(IP)
#endif
C
	Q=0.0D0
	T(MAXRIN+1)=0.0
	T(MAXRIN+2)=0.0
C
	DO    I=1,NRING
	NUMR3I=NUMR(3,I)
	NUMR2I=NUMR(2,I)
C
	T(1)=(CIRC1(NUMR2I))*CIRC2(NUMR2I)
	IF(NUMR3I.EQ.MAXRIN)  THEN
	T(2)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	DO    J=3,MAXRIN,2
	JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)-(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)-(CIRC1(JC+1))*CIRC2(JC)
	ENDDO
	Q=Q+T
	ELSE
	T(NUMR3I+1)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	T(2)=0.0
	DO    J=3,NUMR3I,2
	JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)-(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)-(CIRC1(JC+1))*CIRC2(JC)
	ENDDO
C  ###
	DO    J=1,NUMR3I+1
	Q(J)=Q(J)+T(J)
	ENDDO
	ENDIF
	ENDDO
C
#ifdef SP_LIBFFT
	INV=-1
	LDA=1
	Q(MAXRIN+1)=Q(2)
	Q(2)=0.0
	Q(MAXRIN+2)=0.0
	CALL  ZDFFT1DU(INV,IP,Q,LDA,TT)
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),Q,LDA)
#else
	CALL  FFTR_D(Q,IP)
#endif
C
	QN=-1.0D20
	DO    J=1,MAXRIN
	IF(Q(J).GE.QN)  THEN
	QN=Q(J)
	JTOT=J
	ENDIF
	ENDDO
#ifdef SP_LIBFFT
	QN=QN/MAXRIN
#endif
	DO    K=-3,3
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=Q(J)
	ENDDO
	CALL  PRB1D(T7,7,POS)
	TOT=FLOAT(JTOT)+POS
	END
C++************************************************************************
C
C $$ CROSRNG_DS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ CROSRNG_DS.FOR
C
	SUBROUTINE  CROSRNG_DS
     &   (CIRC1,CIRC2,LCIRC,NRING,MAXRIN,NUMR,QN,TOT,TT)
C
C  INPUT - Fourier transforms of rings!!!
C  CIRC1 already multiplied by weights!!
C
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
	DOUBLE PRECISION  TT(*)
	DOUBLE PRECISION  QN,T7(-3:3)
C Automatic arrays
	DIMENSION  T(MAXRIN+2)
	DOUBLE PRECISION  Q(MAXRIN+2)
C
	IP=MAXRIN
#ifdef SP_LIBFFT
#else
	IP=-LOG2_P(IP)
#endif
C
	Q=0.0D0
	T(MAXRIN+1)=0.0
	T(MAXRIN+2)=0.0
C
	DO    I=1,NRING
	NUMR3I=NUMR(3,I)
	NUMR2I=NUMR(2,I)
C
	T(1)=(CIRC1(NUMR2I))*CIRC2(NUMR2I)
	IF(NUMR3I.EQ.MAXRIN)  THEN
	T(2)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	DO    J=3,MAXRIN,2
	JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)+(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)+(CIRC1(JC+1))*CIRC2(JC)
	ENDDO
	Q=Q+T
	ELSE
	T(NUMR3I+1)=(CIRC1(NUMR2I+1))*CIRC2(NUMR2I+1)
	T(2)=0.0
	DO    J=3,NUMR3I,2
	JC=J+NUMR2I-1
	T(J)=(CIRC1(JC))*CIRC2(JC)+(CIRC1(JC+1))*CIRC2(JC+1)
	T(J+1)=-(CIRC1(JC))*CIRC2(JC+1)+(CIRC1(JC+1))*CIRC2(JC)
	ENDDO
C###
	DO    J=1,NUMR3I+1
	Q(J)=Q(J)+T(J)
	ENDDO
	ENDIF
	ENDDO
C
#ifdef SP_LIBFFT
	INV=-1
	LDA=1
	Q(MAXRIN+1)=Q(2)
	Q(2)=0.0
	Q(MAXRIN+2)=0.0
	CALL  ZDFFT1DU(INV,IP,Q,LDA,TT)
C skip the normalization, divide the maximum instead.
C	CALL  DSCAL1D(IP,1.0D0/DBLE(FLOAT(IP)),Q,LDA)
#else
	CALL  FFTR_D(Q,IP)
#endif
C
	QN=-1.0D20
	DO    J=1,MAXRIN
	IF(Q(J).GE.QN)  THEN
	QN=Q(J)
	JTOT=J
	ENDIF
	ENDDO
#ifdef SP_LIBFFT
	QN=QN/MAXRIN
#endif
C
	DO    K=-3,3
        J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
	T7(K)=Q(J)
	ENDDO
	CALL  PRB1D(T7,7,POS)
	TOT=FLOAT(JTOT)+POS
	END
C++************************************************************************
C
C $$ FRNGS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ FRNGS.FOR
C
         SUBROUTINE  FRNGS(CIRC,LCIRC,NUMR,NRING)
         INTEGER  NUMR(3,NRING)
         DIMENSION  CIRC(LCIRC)
         DO    I=1,NRING
          L=LOG2_P(NUMR(3,I))
          CALL  FFTR_Q(CIRC(NUMR(2,I)),L)
	 ENDDO
         END
C++************************************************************************
C
C $$ APPLYWS.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ APPLYWS.FOR
C
	SUBROUTINE  APPLYWS(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
	INTEGER  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I
	DIMENSION  CIRC(LCIRC),WR(NRING)
	DO    I=1,NRING
	 NUMR3I=NUMR(3,I)
	 NUMR2I=NUMR(2,I)
	 W=WR(I)
	 CIRC(NUMR2I)=CIRC(NUMR2I)*W
	 IF(NUMR3I.EQ.MAXRIN)  THEN
	  CIRC(NUMR2I+1)=CIRC(NUMR2I+1)*W
	 ELSE
	  CIRC(NUMR2I+1)=CIRC(NUMR2I+1)*0.5*W
	 ENDIF
C
	 DO    J=3,NUMR3I
	  JC=J+NUMR2I-1
	  CIRC(JC)=CIRC(JC)*W
	 ENDDO
	ENDDO
	END
C
 	SUBROUTINE  ALRQS
     &	(XIM,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE)
	DIMENSION  XIM(NSAM,NROW),CIRC(LCIRC)
	INTEGER  NUMR(3,NRING)
	CHARACTER*1  MODE
	DOUBLE PRECISION  PI,DFI
C
C  INTERPOLATION INTO POLAR COORDINATES
CC no need to set CIRC to zero, all elements are defined
C
	NS2=NSAM/2+1
	NR2=NROW/2+1
	PI=2*DATAN(1.0D0)
	DO I=1,NRING
C
C  RADIUS OF THE RING
	INR=NUMR(1,I)
	YQ=INR
C
	L=NUMR(3,I)
	IF(MODE.EQ.'H')  THEN
	LT=L/2
	ENDIF
	IF(MODE.EQ.'F')  THEN
	LT=L/4
	ENDIF
	NSIM=LT-1
	DFI=PI/(NSIM+1)
	KCIRC=NUMR(2,I)
	XOLD=0.0
	YOLD=INR
	CIRC(KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	XOLD=INR
	YOLD=0.0
	CIRC(LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	IF(MODE.EQ.'F')  THEN
	XOLD=0.0
	YOLD=-INR
	CIRC(LT+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	XOLD=-INR
	YOLD=0.0
	CIRC(LT+LT+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	ENDIF
	DO  J=1,NSIM
	FI=DFI*J
	X=SIN(FI)*YQ
	Y=COS(FI)*YQ
C
	XOLD=X
	YOLD=Y
	CIRC(J+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	XOLD=Y
	YOLD=-X
	CIRC(J+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	IF(MODE.EQ.'F')  THEN
	XOLD=-X
	YOLD=-Y
	CIRC(J+LT+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	XOLD=-Y
	YOLD=X
	CIRC(J+LT+LT+LT+KCIRC)=QUADRI(XOLD+NS2,YOLD+NR2,NSAM,NROW,XIM)
	ENDIF
	ENDDO
	ENDDO
C
	END
@


1.30
log
@*** empty log message ***
@
text
@d248 1
a248 1
     &		LCIRC,NRING,MODE,IPIC)
d638 1
a638 1
     &		LCIRC,NRING,MODE,IPIC)
d1487 1
a1487 1
     &	(XIM,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,IPIC)
@


1.29
log
@bugs in PARABL fixed
@
text
@d17 1
a17 1
C       SUBROUTINE MRQLI(MAXMEM)
d32 1
a32 1
	SUBROUTINE MRQLI(MAXMEM)
@


1.28
log
@*** empty log message ***
@
text
@d483 1
a483 1
	   CALL  PARABLD(FIT,SX,SY,PEAK)
d904 1
a904 1
	CALL  PARABLD(FIT,SX,SY,PEAK)
@


1.27
log
@prints removed
@
text
@d524 1
a524 13



c	  CALL  APMQ2S(A,REFER_CIRC,TT,NUMR,
c     &	   NSAM,NROW,NSI,ISTEP,ILIST,
c     &	   NSB,NSE,NRB,NRE,LCIRC,NRING,MAXRIN,NIMA,MAXIMA,MODE,
C Output parameters are:
C Number of the most similar reference projection.
C Corr coeff.(D5), Angle (D4), Shift: XSHSUM, YSHSUM
c     &		DLIST(2),
c     &		DLIST(3),DLIST(4),
c     &		DLIST(5),DLIST(6))
C output (in DLIST position is increased by 1, #1 is the key).
@


1.26
log
@New f90 version
@
text
@a199 1
	print  *,' MRQLI_SS'
a599 1
	print  *,' MRQLI_PS'
@


1.25
log
@Last version that has f77 code included
@
text
@a0 2
C   f77 code is at the very end of this file.
#ifdef SP_F90
d17 8
a24 3
C        SUBROUTINE MRQLI(MAXMEM)
C         SUBROUTINE  MRQLI_P(ILIST,NSAM,NROW,NSI,NIMA,MODE,
C        SUBROUTINE  CROSRNG_DS
d26 3
a28 5
C        SUBROUTINE  FOURING_M(CIRC,LCIRC,NUMR,NRING)
C        SUBROUTINE  ALRQ_M
C	CALL NORMAS(A,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
C	CALL  ALRQ(A,NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
C	CALL  FOURING
d33 1
a33 3
	PARAMETER  (NILMAX=21000)
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
a34 5
	COMMON  BUF(1024),ILIST(NILMAX),NUMR,BAF(1)
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q
	LOGICAL         RUNTIME
d36 2
a37 2
	COMMON  /FISPEC/  FINPAT,FINPIC,DOCFIL,NLET,NLETI
	CHARACTER*80  FINPAT,FINPIC,DOCFIL
d40 3
a42 1
	CHARACTER*1  NULL,MODE
d44 2
a45 1
	NULL=CHAR(0)
d47 1
a47 1
	CALL  FILERD(FINPAT,NLET,NULL,
d49 1
a49 18
	CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
         K=0
         K2=1
         NIMA=0
778      LERR=-1
         IF(NIMA.EQ.NILMAX)  THEN
         WRITE(NOUT,*) '  Too many images, list truncated'
         GOTO  779
         ENDIF
         KP1=K+1
         CALL  UNSAV(DOCFIL,K,INPIC,KP1,BUF,1,LERR,K2)
         IF(LERR.EQ.0)  THEN
         NIMA=NIMA+1
         ILIST(NIMA)=BUF(1)
         K=K+1
         GOTO  778
         ENDIF
779      CLOSE(INPIC)
d52 1
a52 1
2001     FORMAT('  Number of images =',i5)
d57 1
d59 6
a64 4
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         CALL ERRT(4,'AP MQ ',NE)
         RETURN
d74 2
a75 2
         NR=NSAM/2-1
         WRITE(NOUT,*)  ' Last ring limited to ',NR
d82 8
a89 2
         NRING=NRING+1
         NUMR(1,NRING)=I
d92 3
a94 3
	IF(NSI+NR.GT.NSAM/2-2)  THEN
	CALL ERRT(101,'Search range too large',NE)
	RETURN
d104 7
a110 27
C   memory division    K
C       numr           1  !int*2
C       a              2
C       refer_circ     4
C       rotmpp         5 
C       fitp           6  !double precision *9
C       tt             7  !double precision 
C       tota           9 !double precision 
C       tot           10
C       tmta          11 !double precision 
C       tmt           12
C
C
C K1 not used
        K1=-1
        K2=1
         K3=IPALIGN64(K2+NSAM*NROW)
         K4=IPALIGN64(K3)
         K5=IPALIGN64(K4+LCIRC*NIMA)
         K6=IPALIGN64(K5)
         K7=IPALIGN64(K6+2*9)
#ifdef SP_LIBFFT
         K8=IPALIGN64(K7+(LCIRC+15)*2)
#else
         K8=K7
#endif
         K9=IPALIGN64(K8)
d112 6
a117 11
	NUMTH=mp_numthreads()
	IF(NIMA.GT.NUMTH)  THEN
         K10=IPALIGN64(K9+NIMA*2)
         K11=IPALIGN64(K10+NIMA)
         K12=IPALIGN64(K11+NIMA*2)
         K13=IPALIGN64(K12+NIMA)
	ELSE
C For small number of reference images do not need these
C arrays.
         K13=K9
	ENDIF
d119 1
a119 4
         K10=IPALIGN64(K9+NIMA*2)
         K11=IPALIGN64(K10+NIMA)
         K12=IPALIGN64(K11+NIMA*2)
         K13=IPALIGN64(K12+NIMA)
a120 10
        MEMTOT=K13
        MAXM=MAXMEM-1024-NILMAX-3*MNUMR
        CALL CHKMEM(MEMTOT,BAF,MAXM,RUNTIME,IPQ,IRTFLG)
              IF(IRTFLG.NE.0)  THEN
                CLOSE(INPIC)
                CALL  ERRT(6,'AP MQ',NE)
                RETURN
              ENDIF
         Q = >IPQ
	WRITE (NOUT,2500)  MEMTOT
d124 4
a127 7
#ifdef SP_MP
	IF(NIMA.GT.NUMTH)  THEN
         CALL  MRQLI_PS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &          Q(K2),Q(K4),
     &          Q(K6),Q(K7),
     &          Q(K9),Q(K10),Q(K11),Q(K12),
     &          LCIRC,NUMR,NRING,MAXRIN)
d129 1
a129 1
C  For a small number of reference images use different strategy
d131 2
a132 4
         CALL  MRQLI_SS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &          Q(K2),Q(K4),
     &          Q(K6),Q(K7),
     &          LCIRC,NUMR,NRING,MAXRIN)
a133 7
#else
         CALL  MRQLI_PS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &          Q(K2),Q(K4),
     &          Q(K6),Q(K7),
     &          Q(K9),Q(K10),Q(K11),Q(K12),
     &          LCIRC,NUMR,NRING,MAXRIN)
#endif
d135 3
a137 1
      IF(RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'AP MQ',IRTFLG)
a139 2
2500     FORMAT (/,' MEMORY RESERVATION: YOU HAVE',
     #   ' ALLOCATED ',I8)
d158 1
a158 1
C  This is version for mp and small number of reference images
d165 3
a167 4
         SUBROUTINE  MRQLI_SS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &   A,REFER_CIRC,
     &	 FITP,TT,
     &   LCIRC,NUMR,NRING,MAXRIN)
d171 1
a171 1
        COMMON  BUF(1024)
a172 2
	INCLUDE 'CMBLOCK.INC'
        DIMENSION  A(NSAM,NROW),WRK(1),ILIST(NIMA)
a173 2
	DOUBLE PRECISION TT(*)
	DIMENSION  REFER_CIRC(LCIRC,NIMA)
d177 3
a179 2
	DOUBLE PRECISION  TOTA(-NSI:NSI,-NSI:NSI),TMTA(-NSI:NSI,-NSI:NSI)
	DIMENSION  TOT(-NSI:NSI,-NSI:NSI),TMT(-NSI:NSI,-NSI:NSI)
a181 2
        DIMENSION  AA(NSAM,NROW)
        DIMENSION  A_CIRC(LCIRC)
d183 11
a194 4
        CHARACTER*1  MODE,NULL
        COMMON  /FISPEC/  FINPAT,FINPIC,DOCFIL,NLET,NLETI
        CHARACTER*80  FINPAT,FINPIC,DOCFIL
        DATA  NDOC/56/,INDOC/57/,INPIC/58/
d196 5
a200 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
d202 2
d205 3
d209 4
d226 15
a240 13
	DO    IMI=1,NIMA
	L=ILIST(IMI)
	NULL=CHAR(0)
	CALL  FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
	DO    J=1,NROW
	CALL  REDLIN(INPIC,A(1,J),NSAM,J)
	ENDDO
	CLOSE(INPIC)
d244 5
a248 2
	CALL NORMAS(A,NSB,NSE,NRB,NRE,NUMR,NUMR(1,NRING))
	CALL  ALRQ(A,NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
d250 3
a252 2
	CALL  FRNG(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	CALL  APPLYW(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
d254 6
a259 5
c find max element on  ILIST
	MAXIMA=ILIST(1)
	DO  IMI=1,NIMA
	MAXIMA=MAX(MAXIMA,ILIST(IMI))
	ENDDO
d263 5
d270 23
a292 37
        NULL=CHAR(0)
	CALL  FILERD(FINPAT,NLET,NULL,
     &   'Enter template for 2-D image name',IRTFLG)
	CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
	K=0
	K2=1
	IMI=0
878      LERR=-1
         KP1=K+1
	CALL  UNSAV(DOCFIL,K,INDOC,KP1,WRK,1,LERR,K2)
	IF(LERR.EQ.0)  THEN
	IMI=IMI+1
C
	LIM=WRK(1)
	NULL=CHAR(0)
	CALL  FILGET(FINPAT,FINPIC,NLET,LIM,INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
        IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
        CALL ERRT(1,'AP MQ',NE)
        CLOSE(INPIC)
	RETURN
	ENDIF
	DO    J=1,NROW
	CALL  REDLIN(INPIC,A(1,J),NSAM,J)
	ENDDO
	CLOSE(INPIC)
        DLIST(5)=-1.0E23
	QT=-1.0D23
	QM=-1.0D23
	DO    IR=1,NIMA
c go through centers
c$omp parallel do private(jt,it,cnr2,cns2,aa,a_circ),
c$omp&  shared(lcirc,nring,maxrin)
d296 1
a296 3
	 CNS2=NSAM/2+1+IT
C put A in a private array
	 AA=A
d300 9
a308 6
	 CALL NORMASS(AA,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
	 CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	 CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	 CALL  CROSRNG_MS
     &		(REFER_CIRC(1,IR),A_CIRC,LCIRC,NRING,
d310 3
a312 1
     &		TOTA(IT,JT),TOT(IT,JT),TMTA(IT,JT),TMT(IT,JT),TT)
d316 5
a320 1
	 DO    JT=-NSI,NSI,ISTEP
d322 3
a324 2
	  IF(TOTA(IT,JT).GE.QT)  THEN
	   QT=TOTA(IT,JT)
d328 1
a328 1
	   D4=ANG(TOT(IT,JT),MODE)
d331 2
a332 2
	  IF(TMTA(IT,JT).GE.QM)  THEN
	   QM=TMTA(IT,JT)
d336 1
a336 1
	   E4=ANG(TMT(IT,JT),MODE)
d339 1
a339 1
	 ENDDO
a340 1
C  END-OF-LOOP 1 OVER REFERENCE IMAGES
d342 1
d346 1
a346 1
        DLIST(2)=D6
d348 1
a348 1
	IF(IABS(ISX).NE.NSI.AND.IABS(ISY).NE.NSI)  THEN
d350 9
a358 11
	FIT(0,0)=QT
	ROTMP(0,0)=D4
c$omp parallel do private(jt,it,aa,a_circ,cnr2,cns2)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
C put A in a private array
	AA=A
	CNR2=NROW/2+1+JT+ISY
	CNS2=NSAM/2+1+IT+ISX
	CALL NORMASS(AA,
d361 6
a366 5
	CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d368 4
a371 4
	ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	ENDIF
	ENDDO
	ENDDO
d375 15
a389 15
	AFIT=FIT(0,0)
	JTMA=0
	ITMA=0
	IF(ISTEP.GT.1)  THEN
	DO     JT=-ISTEP+1,ISTEP-1
	DO     IT=-ISTEP+1,ISTEP-1
	 IF(FIT(IT,JT).GT.AFIT)  THEN
	  AFIT=FIT(IT,JT)
	  D4=ROTMP(IT,JT)
	  ITMA=IT
	  JTMA=JT
	 ENDIF
	ENDDO
	ENDDO
	ENDIF
d391 5
a395 5
	DO     JT=-1,1
	DO     IT=-1,1
	  FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	ENDDO
	ENDDO
d397 3
a399 3
	QT=AFIT
	ISX=ISX+ITMA
	ISY=ISY+JTMA
d401 1
a401 1
	CALL  PARABLD(FITP,SX,SY,PEAK)
d403 5
a407 5
	IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	SX=SX+ISX
	SY=SY+ISY
	CNR2=NROW/2+1+SY
	CNS2=NSAM/2+1+SX
d409 1
a409 1
	CALL  ALRQ_M
d411 2
a412 2
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRNG_DS
d415 3
a417 3
	D5=QT
	D4=ANG(D4,MODE)
	ELSE
d419 9
a427 9
	D5=QT
	SX=ISX
	SY=ISY
	ENDIF
	ELSE
	D5=QT
	SX=ISX
	SY=ISY
	ENDIF
d429 1
a429 1
        DLIST(2)=E6+MAXIMA
d431 1
a431 1
	IF(IABS(IMX).NE.NSI.AND.IABS(IMY).NE.NSI)  THEN
d433 9
a441 11
	FIT(0,0)=QM
	ROTMP(0,0)=E4
c$omp parallel do private(jt,it,aa,a_circ,cnr2,cns2)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
C put A in a private array
	AA=A
	CNR2=NROW/2+1+JT+IMY
	CNS2=NSAM/2+1+IT+IMX
	CALL NORMASS(AA,
d444 6
a449 5
	CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRMG_DS
     &		(REFER_CIRC(1,IME),A_CIRC,LCIRC,NRING,
d451 4
a454 4
	ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	ENDIF
	ENDDO
	ENDDO
d458 15
a472 15
	AFIT=FIT(0,0)
	JTMA=0
	ITMA=0
	IF(ISTEP.GT.1)  THEN
	DO     JT=-ISTEP+1,ISTEP-1
	DO     IT=-ISTEP+1,ISTEP-1
	IF(FIT(IT,JT).GT.AFIT)  THEN
	  AFIT=FIT(IT,JT)
	  E4=ROTMP(IT,JT)
	  ITMA=IT
	  JTMA=JT
	ENDIF
	ENDDO
	ENDDO
	ENDIF
d474 5
a478 5
	DO     JT=-1,1
	DO     IT=-1,1
	  FITP(IT,JT)=FIT(ITMA+IT,JTMA+JT)
	ENDDO
	ENDDO
d480 3
a482 3
	QM=AFIT
	IMX=IMX+ITMA
	IMY=IMY+JTMA
d484 1
a484 1
	CALL  PARABLD(FIT,SX,SY,PEAK)
d486 5
a490 5
	IF(ABS(SX).LT.1.0 .AND. ABS(SY).LT.1.0)  THEN
	SX=SX+IMX
	SY=SY+IMY
	CNR2=NROW/2+1+SY
	CNS2=NSAM/2+1+SX
d492 1
a492 1
	CALL  ALRQ_M
d494 2
a495 2
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRMG_DS
d498 3
a500 3
	D5=QM
	D4=ANG(D4,MODE)
	ELSE
d502 12
a513 12
	SX=IMX
	SY=IMY
	D4=E4
	D5=QM
	ENDIF
	ELSE
	SX=IMX
	SY=IMY
	D4=E4
	D5=QM
	ENDIF
	ENDIF
d515 2
a516 2
	SX=-SX
	SY=-SY
d521 16
a536 4
	CO=COS(D4*DGR_TO_RAD)
	SO=-SIN(D4*DGR_TO_RAD)
	XSHSUM=SX*CO-SY*SO
	YSHSUM=SX*SO+SY*CO
d544 7
a550 7
        DLIST(3)=D5
        DLIST(4)=D4
        DLIST(5)=XSHSUM
        DLIST(6)=YSHSUM
        DLIST(7)=LIM
        DLIST(1)=IMI
        CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
d552 1
a552 4
	K=K+1
	GOTO  878
	ENDIF
879	CLOSE(INDOC)
d555 5
d584 2
a585 10
         SUBROUTINE  MRQLI_PS(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &   A,REFER_CIRC,
     &	 FITP,TT,
     &	 TOTA,TOT,TMTA,TMT,
     &   LCIRC,NUMR,NRING,MAXRIN)
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NDLI=7)
        COMMON  BUF(1024)
        DIMENSION DLIST(NDLI)
d587 1
a587 1
        DIMENSION  A(NSAM,NROW),WRK(1),ILIST(NIMA)
a588 6
	DOUBLE PRECISION TT(*)
	DIMENSION  REFER_CIRC(LCIRC,NIMA)
	DOUBLE PRECISION  TOTA(NIMA),TMTA(NIMA)
	DIMENSION  TOT(NIMA),TMT(NIMA)
	DOUBLE PRECISION  FITP(-1:1,-1:1)
	DOUBLE PRECISION  QT,QM,PEAK
d590 2
a591 4
	DOUBLE PRECISION  FIT(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DIMENSION  ROTMP(-ISTEP:ISTEP,-ISTEP:ISTEP)
        DIMENSION  AA(NSAM,NROW)
        DIMENSION  A_CIRC(LCIRC)
d593 3
d597 10
a606 4
        CHARACTER*1  MODE,NULL
        COMMON  /FISPEC/  FINPAT,FINPIC,DOCFIL,NLET,NLETI
        CHARACTER*80  FINPAT,FINPIC,DOCFIL
        DATA  NDOC/56/,INDOC/57/,INPIC/58/
a607 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
d609 2
d612 3
d616 1
d630 15
a644 13
	DO    IMI=1,NIMA
	L=ILIST(IMI)
	NULL=CHAR(0)
	CALL  FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
	DO    J=1,NROW
	CALL  REDLIN(INPIC,A(1,J),NSAM,J)
	ENDDO
	CLOSE(INPIC)
d648 4
a651 2
	CALL NORMAS(A,NSB,NSE,NRB,NRE,NUMR,NUMR(1,NRING))
	CALL  ALRQ(A,NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
d653 3
a655 7
	CALL  FRNG(REFER_CIRC(1,IMI),LCIRC,NUMR,NRING)
	CALL  APPLYW(REFER_CIRC(1,IMI),LCIRC,NUMR,WR,NRING,MAXRIN)
	ENDDO
c find max element on  ILIST
	MAXIMA=ILIST(1)
	DO  IMI=1,NIMA
	MAXIMA=MAX(MAXIMA,ILIST(IMI))
d657 2
d663 49
a711 29
C  images to be aligned
        NULL=CHAR(0)
	CALL  FILERD(FINPAT,NLET,NULL,
     &   'Enter template for 2-D image name',IRTFLG)
	CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
	K=0
	K2=1
	IMI=0
878      LERR=-1
         KP1=K+1
	CALL  UNSAV(DOCFIL,K,INDOC,KP1,WRK,1,LERR,K2)
	IF(LERR.EQ.0)  THEN
	IMI=IMI+1
C
	LIM=WRK(1)
	NULL=CHAR(0)
	CALL  FILGET(FINPAT,FINPIC,NLET,LIM,INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
        IF(NSAMT.NE.NSAM.OR.NROWT.NE.NROW)  THEN
        CALL ERRT(1,'AP MQ',NE)
        CLOSE(INPIC)
	RETURN
	ENDIF
	DO    J=1,NROW
	CALL  REDLIN(INPIC,A(1,J),NSAM,J)
d713 29
a741 2
	CLOSE(INPIC)
        DLIST(5)=-1.0E23
d752 2
a753 2
	CALL NORMAS(A,NSB-IT,NSE-IT,NRB-JT,NRE-JT,NUMR,NUMR(1,NRING))
	CALL  ALRQ_M
d755 2
a756 2
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
c$omp parallel do private(ir),shared(lcirc,nring,maxrin)
d760 3
a762 6
     &		MAXRIN,NUMR,TOTA(IR),TOT(IR),TMTA(IR),TMT(IR),TT)
	 ENDDO 
C  END-OF-LOOP 1 OVER REFERENCE IMAGES
	 DO    IR=1,NIMA
	  IF(TOTA(IR).GE.QT)  THEN
	   QT=TOTA(IR)
d766 2
a767 2
	   D4=ANG(TOT(IR),MODE)
	   D6=ILIST(IR)
d769 2
a770 2
	  IF(TMTA(IR).GE.QM)  THEN
	   QM=TMTA(IR)
d774 2
a775 2
	   E4=ANG(TMT(IR),MODE)
	   E6=ILIST(IR)
d777 2
a778 1
	 ENDDO
d784 1
a784 1
        DLIST(2)=D6
d788 8
a795 11
	FIT(0,0)=QT
	ROTMP(0,0)=D4
c$omp parallel do private(jt,it,aa,a_circ,cnr2,cns2)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
C put A in a private array
	AA=A
	CNR2=NROW/2+1+JT+ISY
	CNS2=NSAM/2+1+IT+ISX
	CALL NORMASS(AA,
d798 4
a801 4
	CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRNG_DS
d804 3
a806 3
	ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	ENDIF
	ENDDO
d815 10
a824 10
	DO     JT=-ISTEP+1,ISTEP-1
	DO     IT=-ISTEP+1,ISTEP-1
	 IF(FIT(IT,JT).GT.AFIT)  THEN
	  AFIT=FIT(IT,JT)
	  D4=ROTMP(IT,JT)
	  ITMA=IT
	  JTMA=JT
	 ENDIF
	ENDDO
	ENDDO
d828 1
a828 1
	DO     IT=-1,1
d830 1
a830 1
	ENDDO
d840 10
a849 10
	SX=SX+ISX
	SY=SY+ISY
	CNR2=NROW/2+1+SY
	CNS2=NSAM/2+1+SX
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
	CALL  ALRQ_M
     &   (A,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRNG_DS
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d851 2
a852 2
	D5=QT
	D4=ANG(D4,MODE)
d855 3
a857 3
	D5=QT
	SX=ISX
	SY=ISY
d865 1
a865 1
        DLIST(2)=E6+MAXIMA
d869 8
a876 11
	FIT(0,0)=QM
	ROTMP(0,0)=E4
c$omp parallel do private(jt,it,aa,a_circ,cnr2,cns2)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
C put A in a private array
	AA=A
	CNR2=NROW/2+1+JT+IMY
	CNS2=NSAM/2+1+IT+IMX
	CALL NORMASS(AA,
d879 4
a882 4
	CALL  ALRQ_MS
     &   (AA,NSAM,NROW,CNS2,CNR2,NUMR,A_CIRC,LCIRC,NRING,MODE)
	CALL  FRNGS(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRMG_DS
d885 4
a888 4
	ROTMP(IT,JT)=ANG(ROTMP(IT,JT),MODE)
	ENDIF
	ENDDO
	ENDDO
d896 10
a905 10
	DO     JT=-ISTEP+1,ISTEP-1
	DO     IT=-ISTEP+1,ISTEP-1
	IF(FIT(IT,JT).GT.AFIT)  THEN
	  AFIT=FIT(IT,JT)
	  E4=ROTMP(IT,JT)
	  ITMA=IT
	  JTMA=JT
	ENDIF
	ENDDO
	ENDDO
d909 1
a909 1
	DO     IT=-1,1
d911 1
a912 1
	ENDDO
d921 7
a927 6
	SX=SX+IMX
	SY=SY+IMY
	CNR2=NROW/2+1+SY
	CNS2=NSAM/2+1+SX
	CALL NORMAS(A,NSB-IMX,NSE-IMX,NRB-IMY,NRE-IMY,NUMR,NUMR(1,NRING))
	CALL  ALRQ_M
d929 2
a930 2
	CALL  FRNG(A_CIRC,LCIRC,NUMR,NRING)
	CALL  CROSRMG_DS
d933 2
a934 2
	D5=QM
	D4=ANG(D4,MODE)
d937 4
a940 4
	SX=IMX
	SY=IMY
	D4=E4
	D5=QM
d960 2
a961 21
C output (in DLIST position is increased by 1, #1 is the key).
c 1 - Number of the most similar reference projection.
c 2 - Not-normalized correlation coefficient.
c 3 - Psi angle. (in=plane rotation)
c 4 - SX
c 5 - SY
c 6 - input image number.
        DLIST(3)=D5
        DLIST(4)=D4
        DLIST(5)=XSHSUM
        DLIST(6)=YSHSUM
        DLIST(7)=LIM
        DLIST(1)=IMI
        CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
C---------------------------------------------------------------------
	K=K+1
	GOTO  878
	ENDIF
879	CLOSE(INDOC)
	CLOSE(NDOC)
        CALL  SAVDC
d964 26
d1000 7
a1006 7
        DO    I=NS1,NS2
        R=SQRT(FLOAT(J*J+I*I))
        IF(R.GE.R1.AND.R.LE.R2)  THEN
	N=N+1
        AV=AV+X(I,J)
        VR=VR+X(I,J)*X(I,J)
        ENDIF
d1454 2
a1455 2
         L=LOG2_P(NUMR(3,I))
         CALL  FFTR_Q(CIRC(NUMR(2,I)),L)
a1457 1
#else
d1460 1
a1460 1
C    MRQLI.FOR
d1469 1
a1469 1
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
a1471 1
C   MRQLI.FOR
a1472 9
C        SUBROUTINE MRQLI(MAXMEM)
C         SUBROUTINE  MRQLI_P(ILIST,NSAM,NROW,NSI,NIMA,MODE,
C        SUBROUTINE  CROSRNG_D
C        SUBROUTINE  CROSRMG_D
C        SUBROUTINE  FOURING_M(CIRC,LCIRC,NUMR,NRING)
C        SUBROUTINE  ALRQ_M
C	CALL NORMAS(A,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
C	CALL  ALRQ(A,NSAM,NROW,NUMR,REFER_CIRC(1,IMI),
C	CALL  FOURING
d1474 1
d1476 2
a1477 59

	SUBROUTINE MRQLI(MAXMEM)
	PARAMETER  (NILMAX=21000)
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
	INCLUDE 'CMBLOCK.INC' 
	COMMON  BUF(1024),ILIST(NILMAX),NUMR,BAF(1)
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q
#else
	DIMENSION Q(1)
	POINTER   (IPQ,Q) 
#endif
	LOGICAL         RUNTIME
C be careful with the common, it has to agree with 64 bits...
	COMMON  /FISPEC/  FINPAT,FINPIC,DOCFIL,NLET,NLETI
	CHARACTER*80  FINPAT,FINPIC,DOCFIL
	COMMON /MXR/ MAXRIN
	INTEGER     MAXRIN
	CHARACTER*1  NULL,MODE
	DATA  INPIC/77/
	NULL=CHAR(0)
C  ASK FOR DATA FILE
	CALL  FILERD(FINPAT,NLET,NULL,
     &   'Enter template for 2-D reference image name',IRTFLG)
	CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
         K=0
         K2=1
         NIMA=0
778      LERR=-1
         IF(NIMA.EQ.NILMAX)  THEN
         WRITE(NOUT,*) '  Too many images, list truncated'
         GOTO  779
         ENDIF
         KP1=K+1
         CALL  UNSAV(DOCFIL,K,INPIC,KP1,BUF,1,LERR,K2)
         IF(LERR.EQ.0)  THEN
         NIMA=NIMA+1
         ILIST(NIMA)=BUF(1)
         K=K+1
         GOTO  778
         ENDIF
779      CLOSE(INPIC)
         IF(NIMA.GT.0)  THEN
         WRITE(NOUT,2001) NIMA
2001     FORMAT('  Number of images =',i5)
         ELSE
         WRITE(NOUT,*)  '  No images !'
         RETURN
         ENDIF
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
         IF(NF.NE.2)  THEN
         CALL ERRT(4,'AP MQ ',NE)
         RETURN
         ENDIF
         CLOSE(INPIC)
d1479 13
a1491 3
	CALL  RDPRMI(NSI,ISTEP,NLOOP,ILOOP,'Search range, step size')
	NSI=MAX0(NSI,1)
	ISTEP=MAX0(ISTEP,1)
d1493 3
a1495 12
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
         IF(NR.GT.NSAM/2-1)  THEN
         NR=NSAM/2-1
         WRITE(NOUT,*)  ' Last ring limited to ',NR
         ENDIF
         MR=MAX0(2,MIN0(NR,MR))
         ISKIP=1
         MODE='F'
         NRING=0
         DO    I=MR,NR,ISKIP
         NRING=NRING+1
         NUMR(1,NRING)=I
d1497 9
a1505 9
C  Adjust search range and step size.
	IF(NSI+NR.GT.NSAM/2-2)  THEN
	CALL ERRT(101,'Search range too large',NE)
	RETURN
	ENDIF
	IF(MOD(NSI,ISTEP).NE.0) THEN
	CALL ERRT(101,'Search range has to be divisible by step size',NE)
	RETURN
	ENDIF
d1507 2
a1508 2
         CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)
d1510 4
a1513 56
C   memory division    K
C       numr           1  !int*2
C       a              2
C       a_circ         3
C       refer_circ     4
C       rotmpp         5 
C       fitp           6  !double precision *9
C       tt             7  !double precision 
C       wr             8  
C       tota           9 !double precision 
C       tot           10
C       tmta          11 !double precision 
C       tmt           12
C       rotmp         13
C       fit           14
C       temp          15   !double precision (not in MP)
C
C
C K1 not used
        K1=-1
        K2=1
         K3=IPALIGN64(K2+NSAM*NROW)
         K4=IPALIGN64(K3+LCIRC)
         K5=IPALIGN64(K4+LCIRC*NIMA)
         K6=IPALIGN64(K5)
         K7=IPALIGN64(K6+2*9)
#ifdef SP_LIBFFT
         K8=IPALIGN64(K7+(LCIRC+15)*2)
#else
         K8=K7
#endif
         K9=IPALIGN64(K8+NRING)
         K10=IPALIGN64(K9+NIMA*2)
         K11=IPALIGN64(K10+NIMA)
         K12=IPALIGN64(K11+NIMA*2)
         K13=IPALIGN64(K12+NIMA)
         K14=IPALIGN64(K13+(2*ISTEP+1)**2)
         K15=IPALIGN64(K14+2*(2*ISTEP+1)**2)
#ifdef SP_MP
         K16=K15
#else
C  have to add 2 due to libfft
         K16=IPALIGN64(K15+4*(MAXRIN+2))
#endif
        MEMTOT=K16
        MAXM=MAXMEM-1024-NILMAX-3*MNUMR
        CALL CHKMEM(MEMTOT,BAF,MAXM,RUNTIME,IPQ,IRTFLG)
              IF(IRTFLG.NE.0)  THEN
                CLOSE(INPIC)
                CALL  ERRT(6,'AP MQ',NE)
                RETURN
              ENDIF
#ifdef SP_F90
         Q = >IPQ
#endif
	WRITE (NOUT,2500)  MEMTOT
d1515 3
a1517 1
C NIMA number of the reference images
d1519 45
a1563 7
         CALL  MRQLI_P(ILIST,NSAM,NROW,NSI,ISTEP,NIMA,MODE,
     &          Q(K2),Q(K3),Q(K4),
     &          Q(K6),Q(K7),Q(K8),
     &          Q(K13),Q(K14),
     &          Q(K9),Q(K10),Q(K11),Q(K12),
     &          Q(K15),
     &          LCIRC,NUMR,NRING,MAXRIN)
d1565 1
a1565 9
      IF(RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'AP MQ',IRTFLG)
         WRITE (NOUT,2600)
         RETURN
2500     FORMAT (/,' MEMORY RESERVATION: YOU HAVE',
     #   ' ALLOCATED ',I8)
2600     FORMAT (/' ',80('-')//' ',' Multi-reference alignment,  ',
     #   'end of computation',//' ',80('-')/)
         END
#endif
@


1.24
log
@mistake for mirrored particles fixed
@
text
@d1 1
a1 1
C  f77 code is at the very end of this file.
@


1.23
log
@OpenMP
@
text
@d524 2
a525 2
	ISX=ISX+ITMA
	ISY=ISY+JTMA
d534 1
a534 1
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
d539 1
a539 1
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
d905 2
a906 2
	ISX=ISX+ITMA
	ISY=ISY+JTMA
d915 1
a915 1
	CALL NORMAS(A,NSB-ISX,NSE-ISX,NRB-ISY,NRE-ISY,NUMR,NUMR(1,NRING))
d920 1
a920 1
     &		(REFER_CIRC(1,IBE),A_CIRC,LCIRC,NRING,
@


1.22
log
@*** empty log message ***
@
text
@a89 13
C
	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	CALL ERRT(31,'OR 2',NE)
	RETURN
	ENDIF
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
C	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
	ISKIP=MAX0(1,ISKIP)
C
d340 2
a341 1
c$doacross local(jt,it,cnr2,cns2,aa,a_circ),shared(lcirc,nring,maxrin)
d346 1
a346 1
C put A in a local array
d393 1
a393 1
c$doacross local(jt,it,aa,a_circ,cnr2,cns2)
d397 1
a397 1
C put A in a local array
d477 1
a477 1
c$doacross local(jt,it,aa,a_circ,cnr2,cns2)
d481 1
a481 1
C put A in a local array
d738 1
a738 1
c$doacross local(ir),shared(lcirc,nring,maxrin)
d774 1
a774 1
c$doacross local(jt,it,aa,a_circ,cnr2,cns2)
d778 1
a778 1
C put A in a local array
d858 1
a858 1
c$doacross local(jt,it,aa,a_circ,cnr2,cns2)
d862 1
a862 1
C put A in a local array
a1532 13
C
	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	CALL ERRT(31,'OR 2',NE)
	RETURN
	ENDIF
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
C	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
C	ISKIP=MAX0(1,ISKIP)
C
@


1.21
log
@*** empty log message ***
@
text
@d100 1
a100 1
	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
d1555 2
a1556 2
	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
	ISKIP=MAX0(1,ISKIP)
@


1.20
log
@*** empty log message ***
@
text
@d90 13
d1545 13
@


1.19
log
@*** empty log message ***
@
text
@a127 1
#ifdef SP_ALLOC
a130 4
#else
         K1=1
         K2=IPALIGN64(K1+3*NRING)
#endif
a255 1
CNO_SAVE
a974 1
CNO_SAVE
a1097 1
CNO_SAVE
a1237 1
CNO_SAVE
a1574 1
#ifdef SP_ALLOC
a1577 4
#else
         K1=1
         K2=IPALIGN64(K1+3*NRING)
#endif
@


1.18
log
@ff
@
text
@d33 2
a34 1
	INTEGER  NUMR(3,480)
d166 1
a166 1
        MAXM=MAXMEM-1024-NILMAX-3*480/2
d1479 2
a1480 1
	INTEGER  NUMR(3,480)
d1616 1
a1616 1
        MAXM=MAXMEM-1024-NILMAX-3*480/2
@


1.17
log
@fixed
@
text
@d33 1
a33 1
	INTEGER*2  NUMR(3,480)
d44 1
a44 1
	INTEGER*2  MAXRIN
a46 1
CNO_SAVE
d133 1
a133 1
         K2=IPALIGN64(K1+(3*NRING+3)/2)
d241 1
a241 1
        INTEGER*2  NUMR(3,NRING),MAXRIN
d263 1
a263 2
	IP=MAXRIN
	CALL  DZFFT1DUI(IP,TT)
d629 1
a629 1
        INTEGER*2  NUMR(3,NRING),MAXRIN
a647 1
CNO_SAVE
d650 1
a650 2
	IP=MAXRIN
	CALL  DZFFT1DUI(IP,TT)
d978 1
a978 1
        INTEGER*2  IR1,IR2
d1006 1
a1006 1
        INTEGER*2  NUMR(3,NRING)
a1008 1
CNO_SAVE
d1098 1
a1098 1
	INTEGER*2  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I,CMP
d1175 1
a1175 2
        CMP = JTOT+K+MAXRIN-1
        J=MOD(CMP,MAXRIN)+1
d1204 1
a1204 2
        CMP = JTOT+K+MAXRIN-1
        J=MOD(CMP,MAXRIN)+1
d1238 1
a1238 1
	INTEGER*2  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I,CMP
d1308 1
a1308 5
C
C Use of additional variable to convert type
C
        CMP = JTOT+K+MAXRIN-1
        J=MOD(CMP,MAXRIN)+1
d1341 1
a1341 1
	INTEGER*2  NUMR(3,NRING),MAXRIN,NUMR3I,NUMR2I,CMP
a1348 1
CNO_SAVE
d1412 1
a1412 5
C
C Use of additional variable to convert type
C
        CMP = JTOT+K+MAXRIN-1
        J=MOD(CMP,MAXRIN)+1
d1440 1
a1440 1
         INTEGER*2  NUMR(3,NRING)
a1441 1
CNO_SAVE
d1443 1
a1443 2
         NSIRT=NUMR(3,I)
         L=LOG2_P(NSIRT)
d1478 1
a1478 1
	INTEGER*2  NUMR(3,480)
d1494 1
a1494 1
	INTEGER*2  MAXRIN
a1496 1
CNO_SAVE
d1588 1
a1588 1
         K2=IPALIGN64(K1+(3*NRING+3)/2)
@


1.16
log
@*** empty log message ***
@
text
@d139 1
a139 1
         K6=IPALIGN64(K5+9)
d155 1
a155 1
C For small number of refernce images do not need these
d182 1
a182 1
     &          Q(K5),Q(K6),Q(K7),
d190 1
a190 1
     &          Q(K5),Q(K6),Q(K7),
d196 1
a196 1
     &          Q(K5),Q(K6),Q(K7),
d233 1
a233 1
     &	 ROTMPP,FITP,TT,
a244 1
	DIMENSION  ROTMPP(-1:1,-1:1)
a419 17
C make all the angles in ROTMP similar to the central one
C  (problem of modulus 360 degs)
C  It is assumed that angles have range (-180,180), as given by ANG()
	DIPX=ROTMP(0,0)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	 IF(IT.NE.0 .OR. JT.NE.0) THEN
	  IF(ABS(ROTMP(IT,JT)-DIPX).GE.180.0) THEN
	   IF(ROTMP(IT,JT).GT.0.0)  THEN
	    ROTMP(IT,JT)=ROTMP(IT,JT)-360.0
	   ELSE
	    ROTMP(IT,JT)=ROTMP(IT,JT)+360.0
	   ENDIF
	  ENDIF
	 ENDIF
	ENDDO
	ENDDO
d431 1
a441 1
	  ROTMPP(IT,JT)=ROTMP(ITMA+IT,JTMA+JT)
a451 11
	IQX=IFIX(SX+1.0)
	DIPX=SX+1-IQX
	IQY=IFIX(SY+1.0)
	DIPY=SY+1-IQY
	IQX=IQX-1
	IQY=IQY-1
	D4=
     1     +ROTMPP(IQX,IQY)+DIPY*(ROTMPP(IQX,IQY+1)-ROTMPP(IQX,IQY))
     2     +DIPX*(ROTMPP(IQX+1,IQY)-ROTMPP(IQX,IQY)
     3          +DIPY*(ROTMPP(IQX+1,IQY+1)-ROTMPP(IQX+1,IQY)
     4          -ROTMPP(IQX,IQY+1)+ROTMPP(IQX,IQY)))
d454 11
a464 1
	D5=PEAK
a503 17
C make all the angles in ROTMP similar to the central one
C  (problem of modulus 360 degs)
C  It is assumed that angles have range (-180,180), as given by ANG()
	DIPX=ROTMP(0,0)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
	IF(ABS(ROTMP(IT,JT)-DIPX).GE.180.0) THEN
	IF(ROTMP(IT,JT).GT.0.0)  THEN
	ROTMP(IT,JT)=ROTMP(IT,JT)-360.0
	ELSE
	ROTMP(IT,JT)=ROTMP(IT,JT)+360.0
	ENDIF
	ENDIF
	ENDIF
	ENDDO
	ENDDO
d515 1
a525 1
	  ROTMPP(IT,JT)=ROTMP(ITMA+IT,JTMA+JT)
a535 11
	IQX=IFIX(SX+1.0)
	DIPX=SX+1-IQX
	IQY=IFIX(SY+1.0)
	DIPY=SY+1-IQY
	IQX=IQX-1
	IQY=IQY-1
	D4=
     1     +ROTMPP(IQX,IQY)+DIPY*(ROTMPP(IQX,IQY+1)-ROTMPP(IQX,IQY))
     2     +DIPX*(ROTMPP(IQX+1,IQY)-ROTMPP(IQX,IQY)
     3          +DIPY*(ROTMPP(IQX+1,IQY+1)-ROTMPP(IQX+1,IQY)
     4          -ROTMPP(IQX,IQY+1)+ROTMPP(IQX,IQY)))
d538 11
a548 1
	D5=PEAK
d621 1
a621 1
     &	 ROTMPP,FITP,TT,
a635 1
	DIMENSION  ROTMPP(-1:1,-1:1)
a802 17
C make all the angles in ROTMP similar to the central one
C  (problem of modulus 360 degs)
C  It is assumed that angles have range (-180,180), as given by ANG()
	DIPX=ROTMP(0,0)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	 IF(IT.NE.0 .OR. JT.NE.0) THEN
	  IF(ABS(ROTMP(IT,JT)-DIPX).GE.180.0) THEN
	   IF(ROTMP(IT,JT).GT.0.0)  THEN
	    ROTMP(IT,JT)=ROTMP(IT,JT)-360.0
	   ELSE
	    ROTMP(IT,JT)=ROTMP(IT,JT)+360.0
	   ENDIF
	  ENDIF
	 ENDIF
	ENDDO
	ENDDO
d814 1
a824 1
	  ROTMPP(IT,JT)=ROTMP(ITMA+IT,JTMA+JT)
a834 11
	IQX=IFIX(SX+1.0)
	DIPX=SX+1-IQX
	IQY=IFIX(SY+1.0)
	DIPY=SY+1-IQY
	IQX=IQX-1
	IQY=IQY-1
	D4=
     1     +ROTMPP(IQX,IQY)+DIPY*(ROTMPP(IQX,IQY+1)-ROTMPP(IQX,IQY))
     2     +DIPX*(ROTMPP(IQX+1,IQY)-ROTMPP(IQX,IQY)
     3          +DIPY*(ROTMPP(IQX+1,IQY+1)-ROTMPP(IQX+1,IQY)
     4          -ROTMPP(IQX,IQY+1)+ROTMPP(IQX,IQY)))
d837 11
a847 1
	D5=PEAK
a886 17
C make all the angles in ROTMP similar to the central one
C  (problem of modulus 360 degs)
C  It is assumed that angles have range (-180,180), as given by ANG()
	DIPX=ROTMP(0,0)
	DO     JT=-ISTEP,ISTEP
	DO     IT=-ISTEP,ISTEP
	IF(IT.NE.0 .OR. JT.NE.0) THEN
	IF(ABS(ROTMP(IT,JT)-DIPX).GE.180.0) THEN
	IF(ROTMP(IT,JT).GT.0.0)  THEN
	ROTMP(IT,JT)=ROTMP(IT,JT)-360.0
	ELSE
	ROTMP(IT,JT)=ROTMP(IT,JT)+360.0
	ENDIF
	ENDIF
	ENDIF
	ENDDO
	ENDDO
d898 1
a908 1
	  ROTMPP(IT,JT)=ROTMP(ITMA+IT,JTMA+JT)
a918 11
	IQX=IFIX(SX+1.0)
	DIPX=SX+1-IQX
	IQY=IFIX(SY+1.0)
	DIPY=SY+1-IQY
	IQX=IQX-1
	IQY=IQY-1
	D4=
     1     +ROTMPP(IQX,IQY)+DIPY*(ROTMPP(IQX,IQY+1)-ROTMPP(IQX,IQY))
     2     +DIPX*(ROTMPP(IQX+1,IQY)-ROTMPP(IQX,IQY)
     3          +DIPY*(ROTMPP(IQX+1,IQY+1)-ROTMPP(IQX+1,IQY)
     4          -ROTMPP(IQX,IQY+1)+ROTMPP(IQX,IQY)))
d921 11
a931 1
	D5=PEAK
d1612 1
a1612 1
         K6=IPALIGN64(K5+9)
d1649 1
a1649 1
     &          Q(K5),Q(K6),Q(K7),Q(K8),
@


1.15
log
@trig
@
text
@d236 1
a236 1
	PARAMETER (DRG_TO_RAD = (QUADPI/180))
d607 2
a608 2
	CO=COS(D4*DRG_TO_RAD)
	SO=-SIN(D4*DRG_TO_RAD)
d662 1
a662 1
	PARAMETER (DRG_TO_RAD = (QUADPI/180))
d1027 2
a1028 2
	CO=COS(D4*DRG_TO_RAD)
	SO=-SIN(D4*DRG_TO_RAD)
@


1.14
log
@buffer 99999
@
text
@d235 2
d607 2
a608 2
	CO=COSD(D4)
	SO=-SIND(D4)
d661 2
d1027 2
a1028 2
	CO=COSD(D4)
	SO=-SIND(D4)
@


1.13
log
@range changed
@
text
@d32 1
a32 1
	PARAMETER  (NILMAX=10000)
d1565 1
a1565 1
	PARAMETER  (NILMAX=10000)
@


1.12
log
@small number of images added
@
text
@d103 1
a103 1
	IF(NSI+NR.GE.NSAM/2-2)  THEN
d1641 1
a1641 1
	IF(NSI+NR.GE.NSAM/2-2)  THEN
@


1.11
log
@inserted f90-only code
@
text
@d147 3
d154 11
d178 16
d199 1
d209 423
@


1.10
log
@TEMP fixed
@
text
@d1 1081
d1279 1
@


1.9
log
@new version
@
text
@d164 2
a165 1
         K16=IPALIGN64(K15+4*MAXRIN)
@


1.8
log
@f90 alloc
@
text
@d88 3
a90 9
	CALL  RDPRMI(NSI,NR,NLOOP,ILOOP,'EXPECTED SIZE OF THE OBJECT')
	IF(NSI.GE.NSAM)  THEN
         WRITE(NOUT,*) ' Object size cannot be larger than window size'
         NSI=NSAM
         WRITE(NOUT,*) ' Object size set to',NSI
	ENDIF
	NSI=MAX0(0,NSAM-NSI)/2
	LTR=(2*NSI+1)**2
	WRITE(NOUT,*) ' Shifts will be in the range +/-',NSI
d105 9
d123 2
a124 2
C       rotmp          5 
C       fit            6  !double precision *9
d131 2
d148 1
a148 1
         K7=IPALIGN64(K6+9*2)
d159 2
a160 2
         K14=K13
         K15=K14
d181 1
a181 1
         CALL  MRQLI_P(ILIST,NSAM,NROW,NSI,NIMA,MODE,
d184 1
@


1.7
log
@R
@
text
@d34 5
d41 1
d169 3
@


1.6
log
@*** empty log message ***
@
text
@d75 1
a75 1
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'R',NF,NSL)
@


1.5
log
@*** empty log message ***
@
text
@d101 1
a101 1
         DO  1  I=MR,NR,ISKIP
d103 2
a104 1
1        NUMR(1,NRING)=I
@


1.4
log
@*** empty log message ***
@
text
@d155 1
a155 1
        MAXM=MAXMEM-1024-NILMAX-3*1000/2
@


1.3
log
@ipalign64
@
text
@d30 2
a31 2
	PARAMETER  (NILMAX=9998)
	INTEGER*2  NUMR(3,1000)
@


1.2
log
@libfft
@
text
@d130 1
a130 3
         K2=K1+(3*NRING+3)/2
        K2=K2/4
        K2=K2*4+5
d132 5
a136 15
         K3=K2+NSAM*NROW
        K3=K3/4
        K3=K3*4+5
         K4=K3+LCIRC
        K4=K4/4
        K4=K4*4+5
         K5=K4+LCIRC*NIMA
        K5=K5/4
        K5=K5*4+5
         K6=K5+9
        K6=K6/4
        K6=K6*4+5
         K7=K6+9*2
        K7=K7/4
        K7=K7*4+5
d138 1
a138 3
         K8=K7+(LCIRC+15)*2
        K8=K8/4
        K8=K8*4+5
d142 5
a146 15
         K9=K8+NRING
        K9=K9/4
        K9=K9*4+5
         K10=K9+NIMA*2
        K10=K10/4
        K10=K10*4+5
         K11=K10+NIMA
        K11=K11/4
        K11=K11*4+5
         K12=K11+NIMA*2
        K12=K12/4
        K12=K12*4+5
         K13=K12+NIMA
        K13=K13/4
        K13=K13*4+5
a147 2
        K14=K14/4
        K14=K14*4+5
a148 2
        K15=K15/4
        K15=K15*4+5
d152 1
a152 3
         K16=K15+4*MAXRIN
        K16=K16/4
        K16=K16*4+5
@


1.1
log
@Initial revision
@
text
@d113 9
a121 6
C       rotmp          5
C       ibe            6
C       totmin         7
C       tota           8  !double precision 
C       tot            9
C       temp          10   !double precision (not in MP)
d143 1
a143 1
         K6=K5+LTR
d146 1
a146 1
         K7=K6+LTR
d149 2
a150 1
         K8=K7+LTR*2
d153 4
a156 1
         K9=K8+NIMA*2
d159 1
a159 1
         K10=K9+NIMA
d162 1
a162 1
         K11=K10+LTR
d165 1
a165 1
         K12=K11+LTR
d168 1
a168 1
         K13=K12+LTR*2
d171 1
a171 1
         K14=K13+NIMA*2
d174 1
a174 1
         K15=K14+NIMA
d198 2
a199 2
     &          Q(K5),Q(K6),Q(K7),Q(K8),Q(K9),
     &          Q(K10),Q(K11),Q(K12),Q(K13),Q(K14),
@
