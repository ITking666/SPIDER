head	1.37;
access;
symbols
	pre_mrcs:1.35
	healthdept_2018:1.35
	pre_getangas:1.34
	GPL2010:1.34
	pre_GPL2010:1.33
	pre_var_equation:1.33
	pre_fftwrings:1.32
	pre_opfiles:1.32
	src:1.32
	best-code:1.32
	x-named-regs:1.30
	x:1.30
	v13-00:1.30
	pre_GPL:1.29
	prec_CA:1.28
	noindx:1.26
	Bproc:1.23
	oct21:1.22
	last77:1.22;
locks; strict;
comment	@c @;


1.37
date	2019.12.20.16.39.16;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2019.11.04.17.35.09;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2018.10.03.14.51.09;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.24.13.27.19;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2008.11.25.15.47.45;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.05.15.43.46;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.30.16.50.37;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.17.20.58.37;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2004.09.30.16.37.32;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.16.15.31.05;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.28.19.23.18;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2002.09.19.14.27.56;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.23.15.46.02;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.16.19.40.19;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.12.18.46.26;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	99.03.29.20.16.09;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	99.03.12.20.50.36;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	99.03.05.16.53.07;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	98.04.07.14.19.43;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	98.02.24.15.04.41;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	98.02.02.16.00.24;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	98.01.30.19.34.59;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	98.01.27.17.09.58;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	97.12.10.20.18.41;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	97.01.23.18.51.55;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	96.12.19.18.50.00;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	96.11.22.19.40.57;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	96.11.21.19.28.11;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	96.09.26.16.15.32;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	95.08.17.18.26.41;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	95.08.11.17.40.21;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	95.05.23.20.05.12;	author mladjadj;	state Exp;
branches;
next	1.5;

1.5
date	95.05.04.18.04.59;	author mladjadj;	state Exp;
branches;
next	1.4;

1.4
date	95.04.28.16.29.34;	author mladjadj;	state Exp;
branches;
next	1.3;

1.3
date	95.04.17.18.41.28;	author mladjadj;	state Exp;
branches;
next	1.2;

1.2
date	95.03.01.18.41.37;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.53.56;	author leith;	state Exp;
branches;
next	;


desc
@copied from USER2:[PSIDER.CMSREF] on 11 May 1994
@


1.37
log
@more mrc support
@
text
@
C++*********************************************************************
C   WRTLIN.F             IOSTAT ADDED              DEC 97 ArDean Leith
C                        FILE NAME FOR ERROR       SEP 02 ArDean Leith
C                        ENDEDNESS                 FEB 03 ArDean Leith
C                        ONLYONE_WRT               NOV 08 ArDean Leith
C                        MRC SUPPORT               JUL 19 ArDean Leith
C                        MORE MRC SUPPORT          DEC 19 ArDean Leith
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2019  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C     WRTLIN(LUNT,BUF,NB,NREC)
C
C     PURPOSE:  WRITE A LINE OF FLOATING POINT NUMBERS INTO FILE
C
C     PARAMETERS:
C        LUNT   LOGICAL UNIT NUMBER OF FILE BEING WRITTEN
C        BUF    BUFFER WHERE RECORD IS READ IN
C        NB     NUMBER OF VALUES IN RECORD TO BE READ
C        NREC   RECORD TO BE READ
C
C        IERR   ERROR CODE 1 IS RETURNED IN CASE OF ERROR
C               IERR IS DEFINED IN COMMON /IOERR/IERR
C 
C     MRC_MODE  TYPE                           MY_NBYT
C         0       : INTEGER*1 (UNSIGNED BYTES)   -1 
C         1       : INTEGER*2 (SIGNED)            2 
C         2       : REALS                         4
C         6       : INTEGER*2 (UNSIGNED)         -2
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

      MODULE WRTLIN_PIPE_STUFF
         SAVE
         LOGICAL            :: IMGPIPE    = .FALSE.
         INTEGER, PARAMETER :: LUNIMGPIPE = 303
      END MODULE WRTLIN_PIPE_STUFF


C     ---------------------- WRTLIN -------------------------------------

      SUBROUTINE WRTLIN(LUNT,BUF,NB,IREC)

C     HAS  IMG PIPING INFO
      USE WRTLIN_PIPE_STUFF

C     USE INLINE BUFFER COMMON AREA
      INCLUDE 'INLN_INFO.INC'
      INCLUDE 'CMLIMIT.INC'

      INTEGER         :: LUNT,NB,IREC
      REAL            :: BUF(NB)

      INTEGER         :: IERR,LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      INTEGER         :: LUNARA,LUNSTK,LUNARB,LUNFLIP
      COMMON /IOERR/  IERR
      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100),LUNFLIP(100)

      INTEGER *8      :: LUNMRCPOS
      INTEGER         :: LUNMRCNBYT
      COMMON /LUNMRC/    LUNMRCPOS(100),LUNMRCNBYT(100)

C     AUTOMATIC ARRAY 
      REAL                   :: FLIPBUF(NB)

      CHARACTER(LEN=MAXNAM)  :: FILOPEND
      LOGICAL                :: ISOPEN

C     INCLUSION FOR OPTIONAL MPI INITIALIZATION.  
      INTEGER            :: MYPID = -1
#include "MPI_INIT.INC"


      IF (ISINLINE(LUNT)) THEN    ! FROM: INLN_INFO.INC
C        USE INLINED BUFFER FOR I/O (SEE OPENINLN.F)
         CALL INLN_WRTLIN(LUNT,BUF,NB,IREC)
         RETURN

      ELSEIF (IMGPIPE) THEN
C        USE PIPE FOR OUTPUT
         CALL WRTLIN_PIPE(BUF,NB,IREC,IRTFLG)
         RETURN
      ENDIF

      LUN = LUNARB(LUNT)

      IF (LUNMRCPOS(LUN) == 0) THEN
C       DIRECT ACCESS SPIDER FILE

C       ADD LUNARA(LUN) (FOR LABEL REC) AND LUNSTK (FOR STACK OFFSET)
C       TO IREC TO GET THE CORRECT RECORD NUMBER
        I = IREC + LUNARA(LUN) + LUNSTK(LUNT)

        IERR = 0
        IF (MYPID <= 0) THEN
           IF (LUNFLIP(LUN) == 0) THEN
              WRITE(LUN,REC=I,IOSTAT=IERR) BUF
           ELSE
              CALL FLIPBYTES(BUF,FLIPBUF,NB,IRTFLG)
              WRITE(LUN,REC=I,IOSTAT=IERR) FLIPBUF
           ENDIF

           IF (IERR .NE. 0) THEN
              INQUIRE(UNIT=LUN,OPENED=ISOPEN,NAME=FILOPEND)
              LENT = lnblnkn(FILOPEND)
              WRITE(NOUT,99) IERR,I,NB,LUN,FILOPEND(:LENT)
99            FORMAT( '  *** ERROR(',I4,') WRITING RECORD: ',I6,
     &                ' LENGTH: ', I5,' ON UNIT: ',I3,' TO FILE: ',A)
           ENDIF
        ENDIF

      ELSE

C       STREAM ACCESS MRC FILE
        CALL WRTLIN_MRC(LUN,BUF,NB,IREC, MYPID,IERR) 

      ENDIF

#ifdef USE_MPI
      IF (ONLYONE_WRT) THEN
         CALL BCAST_MPI('WRTLIN','IERR',IERR,1,'I', ICOMM,MPIERR)
         CALL MPI_BARRIER(ICOMM,MPIERR)
      ENDIF
#endif

      END

C----------------------------- WRTLIN_MRC ----------------------------

      SUBROUTINE WRTLIN_MRC(LUN,BUF,NB,IREC, MYPID,IERR)

C     PURPOSE:  WRITE BUF TO STREAM ACCESS MRC IMAGE/VOLUME FILE

      IMPLICIT NONE

      INCLUDE 'CMLIMIT.INC'   ! NEED: NBUFSIZ

      INTEGER         :: LUN,NB,IREC
      REAL            :: BUF(NB)
      INTEGER         :: MYPID,IERR

      INTEGER *8      :: LUNMRCPOS
      INTEGER         :: LUNMRCNBYT
      COMMON /LUNMRC/    LUNMRCPOS(100),LUNMRCNBYT(100)
      INTEGER         :: LUNARA,LUNSTK,LUNARB,LUNFLIP
      COMMON /LUNARA/   LUNARA(100),LUNSTK(100),LUNARB(100),LUNFLIP(100)

      INTEGER *1      :: I1BUF(NBUFSIZ)
      INTEGER *2      :: I2BUF(NBUFSIZ)

      INTEGER         :: I,IX,IRTFLG
      INTEGER         :: NBYT_PER_VAL,NBYT_PER_REC,MRCMODE,NX,NE
      INTEGER *8      :: IPOSMRC

C     LUNARA CARRIES NX (PIXELS IN X)
      NX = ABS(LUNARA(LUN))

C     DIFFERENT MRC MODES DIFFER IN DATA LENGTHS
      MRCMODE      = LUNMRCNBYT(LUN)   
      NBYT_PER_VAL = ABS(MRCMODE)
      NBYT_PER_REC = NBYT_PER_VAL * NX

C     FILE POSITION TO BEGIN WRITING DEPENDS ON IREC AND ORIGIN

C     LUNARA SIGN DENOTES IMAGE ORIGIN
      IF (LUNARA(LUN) > 0) THEN
C        ORIGIN IS LOWER LEFT
         IPOSMRC = LUNMRCPOS(LUN) - IREC * NBYT_PER_REC

      ELSEIF (LUNARA(LUN) < 0) THEN
C        ORIGIN IS UPPER LEFT
         IPOSMRC = LUNMRCPOS(LUN) + IREC * NBYT_PER_REC

      ELSE
         IRTFLG = 1
         RETURN
      ENDIF

      IF (NBYT_PER_VAL == 4) THEN
C        MRC FILE NEEDS 32 BIT REAL VALUES
         IF (MYPID <= 0) WRITE(LUN, POS=IPOSMRC,IOSTAT=IERR) BUF(1:NB)

      ELSEIF (NBYT_PER_VAL == 2) THEN      
C        MRC FILE NEEDS  16 BIT, INTEGER*2 VALUES        

         I2BUF(1:NB) = BUF(1:NB)   
         IF (MYPID <= 0) WRITE(LUN, POS=IPOSMRC,IOSTAT=IERR) I2BUF(1:NB)

      ELSEIF (NBYT_PER_VAL == 1) THEN         
C        MRC FILE NEEDS   8 BIT INTEGER*1 VALUES 

         I1BUF(1:NB) = BUF(1:NB)   
         IF (MYPID <= 0) WRITE(LUN,POS=IPOSMRC,IOSTAT=IERR)I1BUF(1:NB)
 
      ENDIF

      !if (irec==1) write(3,'(A,2X,i9,f8.1)')
      !&            '  In wrtlin, i1buf,buf:',i1buf(1),buf(1)
      ! if (irec==1) write(3,*)' i1buf(1, 1),(1, nx):',i1buf(1),i1buf(nx) 
      ! if (irec==64)write(3,*)' i1buf(64,1),(64,nx):',i1buf(1),i1buf(nx) 
      ! if (irec==63)  write(3,*)'  irec,lunmrcpos,ipos: ',
      ! &                          irec,lunmrcpos(lun),iposmrc
      ! if (irec==63)  write(3,*)'  irec,lunmrcpos,ipos: ',
      ! &                          irec,lunmrcpos(lun),iposmrc
c     CALL ERRT(101, '16 BIT MRC FILE OUTPUT IS NOT SUPPORTED YET',NE)
c     IERR = 1

      END



C++*********************************************************************
C
C WRTLIN_OPENPIPE                   NEW           JAN 2006 ArDean Leith
C
C **********************************************************************
C
C    WRTLIN_OPENPIPE(PIPENAME,IRTFLG)
C
C    PURPOSE:     OPENS PIPE FOR IMAGE/VOLUME    
C
C    PARAMETERS:  PIPENAME  PIPE NAME                           (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE WRTLIN_OPENPIPE(PIPENAME,IRTFLG)

      USE WRTLIN_PIPE_STUFF

      INCLUDE 'CMLIMIT.INC'
      CHARACTER(LEN=MAXNAM)    :: PIPENAME
      CHARACTER(LEN=MAXNAM+24) :: MSG


      OPEN(UNIT=LUNIMGPIPE, 
     &    FILE=PIPENAME,
     &    FORM='UNFORMATTED',
     &    ACCESS='SEQUENTIAL',
     &    STATUS='OLD',
     &    ACTION='WRITE',
     &    IOSTAT=IRTFLG)

      IF (IRTFLG .NE. 0) THEN 
         MSG = 'FAILED TO OPEN PIPE: ' // PIPENAME
         CALL ERRT(101,MSG,IRTFLG)
         RETURN
      ENDIF

      IMGPIPE = .TRUE.
      IRTFLG  = 0

      END


C++*********************************************************************
C
C WRTLIN_PIPE                         NEW        JAN 2006 ArDean Leith
C
C **********************************************************************
C
C    WRTLIN_PIPE(BUF,LENT,NB,IRTFLG)
C
C    PURPOSE:    SENDS IMAGE DOWN LUNIMGPIPE   
C
C    PARAMETERS:  BUF   DATA BUFFER LINE                        (SENT)
C                 NB    LENGTH OF DATA BUFFER LINE              (SENT)
C                 NREC  NUMBER OF DATA BUFFER LINE              (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*********************************************************************

      SUBROUTINE WRTLIN_PIPE(BUF,NB,NREC,IRTFLG)

      USE WRTLIN_PIPE_STUFF

      REAL,DIMENSION(NB) :: BUF

      IF (IMGPIPE) THEN
C        WRITE IMAGE/VOL. LINE TO NAMED PIPE
         WRITE(LUNIMGPIPE,IOSTAT=IRTFLG) BUF
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'PIPING IMAGE LINE',NREC)
            RETURN
         ENDIF
      ELSE
         CALL ERRT(101,'NO IMAGE PIPE OPEN',NE)
         IRTFLG = 1
      ENDIF
 
      END

C++*********************************************************************
C
C WRTLIN_PIPE_TOG                     NEW        JAN 2006 ArDean Leith
C
C **********************************************************************
C
C    WRTLIN_PIPE_TOG()
C
C    PURPOSE:    SETS IMAGE PIPLINE TOGGLE    
C
C    PARAMETERS:  
C
C--*********************************************************************

      SUBROUTINE WRTLIN_PIPE_TOG()

      USE WRTLIN_PIPE_STUFF
      INCLUDE 'CMLIMIT.INC' 

      CHARACTER (LEN=MAXNAM), SAVE :: PIPENAME = CHAR(0)
      CHARACTER (LEN=1)            :: NULL = CHAR(0)
      LOGICAL                      :: ISOPEN = .FALSE.
      LOGICAL, SAVE                :: NEEDOPEN = .TRUE.

      INCLUDE 'CMBLOCK.INC'

      IF (IMGPIPE) THEN
C        WRITE IMAGE/VOL. LINE TO FILE(S) 
         WRITE(NOUT,*) '  IMAGES SENT TO FILES'
         IMGPIPE = .NOT. IMGPIPE

      ELSE
C        WRITE IMAGE/VOL. LINE TO NAMED PIPE

         IF (PIPENAME .EQ. NULL) THEN
C           NO FILE OPEN
            CALL FILERD(PIPENAME,NLET,NULL,'PIPE NAME~',IRTFLG)
            IF (IRTFLG .NE. 0) RETURN

            CALL WRTLIN_OPENPIPE(PIPENAME(1:NLET),IRTFLG)
            IF (IRTFLG .NE. 0) RETURN


         ELSE
C          SEE IF THIS PIPE EXISTS, (RETURNS ISOPEN, LUNOP)
           NLET = lnblnkn(PIPENAME)
           INQUIRE(FILE=PIPENAME(:NLET),OPENED=ISOPEN,NUMBER=LUNOP,
     &             IOSTAT=IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           IF (.NOT. ISOPEN) THEN
C             MUST RE-OPEN PIPE
              CALL WRTLIN_OPENPIPE(PIPENAME(1:NLET),IRTFLG)
              IF (IRTFLG .NE. 0) RETURN
           ENDIF
           IMGPIPE = .TRUE.

           WRITE(NOUT,*)'  IMAGES PIPED TO: PIPENAME(1:NLET) ',
     &                  ' INSTEAD OF FILES'
         ENDIF
      ENDIF
 
      END
@


1.36
log
@mrc_support
@
text
@d8 1
a171 3
      INTEGER *2      :: I2V
      INTEGER *1      :: I1V

d173 1
a173 1
      INTEGER         :: NBYT_PER_VAL,NBYT_PER_REC,MRCTYP,NX,NE
d176 1
a176 4
      integer *8      :: iposmrcjnk


C     LUNARA SIGN DENOTES IMAGE ORIGIN
d180 2
a181 2
      MRCTYP       = LUNMRCNBYT(LUN)   
      NBYT_PER_VAL = ABS(MRCTYP)
d184 1
a184 1
C     FILE POSITION TO BEGIN WRITING DEPENDS ON IREC
d186 1
a199 8

c      if (irec==1) write(3,'(A,2X,3i9)')
c     &            '  In wrtlin, irec,lunmrcpos(),iposmrc:',
c     &                          irec,lunmrcpos(lun),iposmrc
      !if (irec==1)write(3,*)' irec,lunara(lun):    ',irec,lunara(lun)
      !if (irec==1)write(3,*)' irec,lunmrcpos(lun): ',irec,lunmrcpos(lun)
      !if (irec==1)write(3,*)' irec,iposmrc:        ',irec,iposmrc

d201 1
a201 5
C        MRC FILE CONTAINS 32 BIT REAL VALUES

         ! if (irec==63)  write(3,*)'  irec,lunmrcpos,ipos: ',
         ! &                          irec,lunmrcpos(lun),iposmrc

d204 2
a205 18
      ELSEIF (NBYT_PER_VAL == 2) THEN     ! UNTESTED!!
C        MRC FILE CONTAINS 16 BIT, INTEGER*2 VALUES        

         CALL ERRT(101,
     &             '16 BIT MRC FILE OUTPUT IS NOT SUPPORTED YET',NE)
         IERR = 1
         RETURN
#ifdef NEVER
         IF (MRCTYP > 0) THEN
C           CONVERT SIGNED 16 BIT INTEGER TO UNSIGNED 16 BIT INTEGER
            DO IX = 1,NB
               I2V              = BUF(IX)
               IF (I2V < 0) I2V = 65536 + I2V
               I2BUF(IX)        = I2V    
            ENDDO
         ELSE
            I2BUF(1:NB) = BUF(1:NB)  
         ENDIF
d207 1
a208 1
#endif
d210 2
a211 17
      ELSEIF (NBYT_PER_VAL == 1) THEN        ! UNTESTED!!
C        MRC FILE CONTAINS 8 BIT INTEGER*1 VALUES 
       
         CALL ERRT(101,'8 BIT MRC FILE OUTPUT IS NOT SUPPORTED YET',NE)
         IERR = 1
         RETURN
#ifdef NEVER
         IF (MRCTYP < 0  ) THEN
            I1BUF(1:NB) = BUF(1:NB)  ! SPIDER HAS REALS
         ELSE
C           CONVERT SIGNED 8 BIT INTEGER TO UNSIGNED 8 BIT INTEGER
            DO IX = 1,NB
               I1V              = I1BUF(IX)
               IF (I2V < 0) I1V = 256 + I1V
               I1BUF(IX)        = I1V      
            ENDDO
         ENDIF
d213 3
a215 2
         IF (MYPID <= 0) WRITE(LUN, POS=IPOSMRC,IOSTAT=IERR)I1BUF(1:NB)
#endif
d218 11
a228 2
      !if (irec == 3) write(3,*)' buf(1,1),buf(1,nx):',  buf(1),buf(nx) 
      !if (irec == 64)write(3,*)' buf(64,1),buf(64,nx):',buf(1),buf(nx) 
a229 5





@


1.35
log
@email_health_dept
@
text
@d2 6
a7 5
C++*******************************************************************
C   WRTLIN.F                        IOSTAT ADDED             DEC 97 al
C                                   FILE NAME FOR ERROR      SEP 02 al
C                                   ENDEDNESS                FEB 03 al
C                                   ONLYONE_WRT              NOV 08 al
d12 1
a12 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d43 8
a50 1
C--*******************************************************************
d59 1
d61 1
a61 1
      SUBROUTINE WRTLIN(LUNT,BUF,NB,NREC)
d68 4
d73 2
a74 1
      REAL            BUF(NB)
d79 4
d84 4
a87 1
      REAL,DIMENSION(NB) :: FLIPBUF(NB)
d89 3
a91 2
      CHARACTER(LEN=80)  :: FILOPEND
      LOGICAL            :: ISOPEN
a92 10
#ifdef USE_MPI
      LOGICAL            :: ONLYONE_RED,ONLYONE_WRT
      COMMON /COMM_MPI/ONLYONE_RED,ONLYONE_WRT
      include 'mpif.h'
      ICOMM   = MPI_COMM_WORLD
      CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
      IF (.NOT. ONLYONE_WRT) MYPID = -1
#else
      MYPID = -1 
#endif
d94 1
a94 1
      IF (ISINLINE(LUNT)) THEN
d96 1
a96 1
         CALL INLN_WRTLIN(LUNT,BUF,NB,NREC)
d101 1
a101 1
         CALL WRTLIN_PIPE(BUF,NB,NREC,IRTFLG)
d107 29
a135 12
C     ADD LUNARA(LUN) (FOR LABEL REC) AND LUNSTK (FOR STACK OFFSET)
C     TO NREC TO GET THE CORRECT RECORD NUMBER
      I = NREC + LUNARA(LUN) + LUNSTK(LUNT)

      IERR = 0
      IF (MYPID .LE. 0) THEN
         IF (LUNFLIP(LUN) .EQ. 0) THEN
            WRITE(LUN,REC=I,IOSTAT=IERR) BUF
         ELSE
            CALL FLIPBYTES(BUF,FLIPBUF,NB,IRTFLG)
            WRITE(LUN,REC=I,IOSTAT=IERR) FLIPBUF
         ENDIF
a136 7
         IF (IERR .NE. 0) THEN
            INQUIRE(UNIT=LUN,OPENED=ISOPEN,NAME=FILOPEND)
            LENT = lnblnkn(FILOPEND)
            WRITE(NOUT,99) IERR,I,NB,LUN,FILOPEND(:LENT)
99          FORMAT( '  *** ERROR(',I4,') WRITING RECORD: ',I6,
     &              ' LENGTH: ', I5,' ON UNIT: ',I3,' TO FILE: ',A)
         ENDIF
d148 123
d277 1
a277 1
C WRTLIN_OPENPIPE                   NEW           JAN 2006 ARDEAN LEITH
a297 13
#ifdef sgi
C     SETS NAME FOR ASSIGN OBJECT FILE
      CALL SETENV('FILENV','jnkASSIGN1',IRTFLG)
C     CLEAR ANY EXISTING ASSIGN OBJECT FILE
      CALL ASNRM(IRTFLG)
C     INITIALIZE THE ASSIGN OBJECT FILE FOR WRITING
      MSG = '-s u -a ' // PIPENAME
      CALL ASNUNIT(LUNREGPIPE,MSG,IRTFLG)
      IF (IRTFLG .NE. 0) THEN
         CALL ERRT(102,'ASNUNIT TO SET PIPE, RETURNS:',IER)
         RETURN
      ENDIF
#endif
a315 1
      RETURN
d321 1
a321 1
C WRTLIN_PIPE                         NEW           JAN 2006 ARDEAN LEITH
a353 1
      RETURN
d358 1
a358 1
C WRTLIN_PIPE_TOG                      NEW        JAN 2006 ARDEAN LEITH
@


1.34
log
@GPL_2010
@
text
@d13 1
a13 1
C=* Email: spider@@wadsworth.org                                        *
@


1.33
log
@ BCAST COM
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.32
log
@save
@
text
@d3 4
a6 3
C   WRTLIN.F                        IOSTAT ADDED DEC. 97 al
C                                   FILE NAME FOR ERROR SEP 02 al
C                                   ENDEDNESS FEB 03 al
d9 1
a9 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d54 2
d76 2
d79 3
a81 5
      INTEGER MYPID, COMM, MPIERR

      COMM   = MPI_COMM_WORLD
      MPIERR = 0
      CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d102 4
a105 3
      IF (LUNFLIP(LUN) .EQ. 0) THEN
#ifdef USE_MPI
         IF (MYPID .EQ. 0) THEN
d107 2
a108 13
         ENDIF
         CALL MPI_BCAST(IERR,1,MPI_INTEGER,0,COMM,MPIERR)
         IF (MPIERR .NE. 0) THEN
            WRITE(0,*) '  WRTLIN: FAILED TO BCAST IERR'
            STOP
         ENDIF
#else
         WRITE(LUN,REC=I,IOSTAT=IERR) BUF
#endif
      ELSE
         CALL FLIPBYTES(BUF,FLIPBUF,NB,IRTFLG)
#ifdef USE_MPI
         IF (MYPID .EQ. 0) THEN
d111 7
a117 4
         CALL MPI_BCAST(IERR,1,MPI_INTEGER,0,COMM,MPIERR)
         IF (MPIERR .NE. 0) THEN
            WRITE(0,*) '  WRTLIN: FAILED TO BCAST IERR'
            STOP
a118 3
#else
         WRITE(LUN,REC=I,IOSTAT=IERR) FLIPBUF
#endif
d121 4
a124 5
      IF (IERR .NE. 0 .AND. MYPID .LE. 0 ) THEN
         INQUIRE(UNIT=LUN,OPENED=ISOPEN,NAME=FILOPEND)

         WRITE(NOUT,*) '  *** ERROR(',IERR,') WRITING RECORD: ',I, 
     &           ' LENGTH: ',NB,' ON UNIT: ',LUN,' TO FILE: ',FILOPEND
a125 2
#ifdef USE_MPI
      CALL MPI_BARRIER(COMM,MPIERR)
a127 1
      RETURN
@


1.31
log
@img pipe
@
text
@a264 2
      SAVE NEEDOPEN, PIPENAME

@


1.30
log
@GPL License fixed
@
text
@d47 6
d55 3
d67 1
a67 1
      REAL,DIMENSION(NB) ::      FLIPBUF(NB)
d69 2
a70 2
      CHARACTER(LEN=80) :: FILOPEND
      LOGICAL :: ISOPEN
d87 5
d106 1
a106 1
            WRITE(0,*) 'WRTLIN: FAILED TO BCAST IERR'
d120 1
a120 1
            WRITE(0,*) 'WRTLIN: FAILED TO BCAST IERR'
d131 1
a131 1
         WRITE(NOUT,*) '*** ERROR(',IERR,') WRITING RECORD: ',I, 
d143 163
@


1.29
log
@mpi
@
text
@d7 23
a29 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.28
log
@mpi
@
text
@d48 7
a54 4
      integer mypid, comm, ierr
                                                                                
      comm = MPI_COMM_WORLD
      call MPI_COMM_RANK(comm, mypid, ierr)
a67 1

d70 1
a70 1
         if (mypid .eq. 0) then
d72 6
a77 1
         endif
d84 1
a84 1
         if (mypid .eq. 0) then
d86 6
a91 1
         endif 
d97 1
a97 1
      IF (IERR .NE. 0) THEN
d103 3
@


1.27
log
@endedness
@
text
@d46 8
d67 5
d73 1
d76 5
d82 1
@


1.26
log
@added error output of filename
@
text
@d5 1
a5 1
C 
d38 4
a41 1
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)
d57 8
a64 2
      WRITE(LUN,REC=I,IOSTAT=IERR) BUF
     
@


1.25
log
@virtual lun
@
text
@d3 3
a5 1
C   WRTLIN.FOR                       IOSTAT ADDED DEC. 97 al 
d7 6
a12 6
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
d40 3
d57 4
a60 2
         WRITE(NOUT,*) '*** ERROR (',IERR,') WRITING RECORD: ',I, 
     &                 ' LENGTH: ',NB,' ON UNIT: ',LUN
@


1.24
log
@added lunarb to common /lunara/
@
text
@d13 1
a13 1
C     WRTLIN(LUN,BUF,NB,NREC)
d18 1
a18 1
C        LUN    LOGICAL UNIT NUMBER OF FILE BEING WRITTEN
d28 1
a28 1
      SUBROUTINE WRTLIN(LUN,BUF,NB,NREC)
d38 1
a38 2

      IF (ISINLINE(LUN)) THEN
d40 1
a40 1
         CALL INLN_WRTLIN(LUN,BUF,NB,NREC)
d44 2
d48 1
a48 1
      I = NREC + LUNARA(LUN) + LUNSTK(LUN)
@


1.23
log
@f90 only now
@
text
@d36 2
a37 1
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
@


1.22
log
@USE INLN_INFO ALTERED
@
text
@a27 4
#ifdef SP_F90

C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------

a56 38
#else

C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------

      SUBROUTINE WRTLIN(LUN,BUF,NB,NREC)

      REAL            BUF(NB)
      COMMON /IOERR/  IERR
      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)

#if defined(SP_SUN4) || defined(SP_NT)
      INTEGER * 4     LOCLUN
#else
      INTEGER * 8     LOCLUN
#endif


      IF (LOCLUN(LUN) .GT. 0) THEN
C        USER HAS ASKED FOR INLINED BUFFER
         CALL INLN_WRTLIN(LUN,BUF,NB,NREC)
         RETURN
      ENDIF

C     ADD LUNARA(LUN) (FOR LABEL REC) AND LUNSTK (FOR STACK OFFSET)
C     TO NREC TO GET THE CORRECT RECORD NUMBER
      I = NREC + LUNARA(LUN) + LUNSTK(LUN)
      WRITE(LUN,REC=I,IOSTAT=IERR) BUF
     
      IF (IERR .NE. 0) THEN
         WRITE(NOUT,*) '*** ERROR (',IERR,') WRITING RECORD: ',I, 
     &                 ' LENGTH: ',NB,' ON UNIT: ',LUN
      ENDIF

      RETURN
      END
#endif
@


1.21
log
@removed USEINLN
@
text
@a32 1
CNO_SAVE
a33 1

d35 1
a35 1
      USE INLN_INFO
d42 2
a43 2
      IF (ASSOCIATED(LOCLUN(LUN)%IPT)) THEN
C        USE INLINED BUFFER FOR I/O
a100 156
C++********************************************************************
C   INLN_WRTLIN.F                                
C **********************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
C **********************************************************************
C
C     INLN_WRTLIN(LUN,BUF,NB,NREC)
C
C     PURPOSE:    READ A LINE OF FLOATING POINT NUMBERS FROM BUFFER
C
C     PARAMETERS:
C        LUN    LOGICAL UNIT NUMBER OF FILE BEING READ
C        BUF    BUFFER WHERE RECORD IS READ IN
C        NB     NUMBER OF VALUES IN RECORD TO BE READ
C        NREC   RECORD TO BE READ
C 
C        IERR   ERROR CODE 1 IS RETURNED IN CASE OF ERROR
C               IERR IS DEFINED IN COMMON /IOERR/IERR
C 
C       MANY COMMANDS IN SPIDER READ A FILE, MANIPULATE THE DATA, AND
C       WRITE THE RESULTS INTO A FILE, ONLY TO HAVE THE NEXT COMMAND
C       READ THE DATA BACK AGAIN IN CORE TO MANIPULATE IT AND STORE
C       IT BACK TO A FILE THEN START THE CYCLE AGAIN...
C       TO SPEED UP THE PROCESS, THE USER HAS THE ABILITY TO HAVE THAT 
C       DATA KEPT IN INCORE MEMORY UNTIL HE DECIDES THAT HE WANTS IT IN
C       A FILE. FOR THAT, SPIDER OFFERS AN INCORE MEMORY IN A COMMON BLOCK
C       BUFFER:
C
C       ON VAX SYSTEMS, SPIDER OFFERS AN INCORE MEMORY IN A COMMON 
C       BLOCK.  THIS BUFFER CAN BE SUBDIVIDED INTO TWO PARTS TO HOLD 
C       AT MOST TWO FILES, FILES ARE CALLED _1 AND _2. 
C
C       DATA FROM A FILE IS STORED EXACTLY THE SAME WAY AS IT IS IN A
C       DISK FILE (I.E: A HEADER FOLLOWED BY NROWS OF DATA OF LENGTH NSAMS
C       REPEATED NSLICE TIMES).
C 
C--*******************************************************************

#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------

      SUBROUTINE INLN_WRTLIN(LUN,BUF,NB,NREC)

C     USE INLINE BUFFER COMMON AREA
      USE INLN_INFO

      REAL   BUF(NB)

      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100)

      REAL, DIMENSION(:), POINTER :: IPTNOW

      IPTNOW => LOCLUN(LUN)%IPT

      ILOC   = 0
C     RUN-TIME ALLOCATION SPECIFIC CODE LINE ENDS

C     GET THE CORRECT OFFSET INTO THE BUFFER.
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN) + ILOC 

      IF ((IGO + NB - 1 - ILOC) .GT. NWORDLUN(LUN)) THEN
C        GOES OUT OF RESERVED BUFFER!
         WRITE(NOUT,*) '*** INLN_WRTLIN ARRAY OVERFLOW, LUN: ',LUN,
     &      '   LENGTH:',IGO + NB,'   NREC: ',NREC,
     &      '   LUNARA(LUN) :',LUNARA(LUN),'  LUNSTK(LUN):',LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :',NSAMLUN(LUN)  
         CALL ERRT(100,'WRTLIN',NE)
         IERR = 1
         RETURN

      ELSEIF (IGO .LT. ILOC) THEN
C        BEFORE RESERVED BUFFER!
         WRITE(NOUT,*) '*** INLN_WRTLIN ARRAY UNDERFLOW, LUN: ',LUN,
     &      '   IGO:',IGO,'   NREC: ',NREC,
     &      '   LUNARA(LUN) :',LUNARA(LUN),'  LUNSTK(LUN):',LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :',NSAMLUN(LUN)  
         CALL ERRT(100,'WRTLIN',NE)
         IERR = 1
         RETURN
      ENDIF

C     WRITE THE BUFFER (THERE MAY BE A FASTER WAY TO DO THIS!!)
      DO I= 1,NB
         IPTNOW(IGO + I) = BUF(I) 
      ENDDO
      IERR = 0

      RETURN
      END


#else
C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------


      SUBROUTINE INLN_WRTLIN(LUN,BUF,NB,NREC)

      REAL   BUF(NB)

      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)

#if defined(SP_SUN4) || defined(SP_NT)
      INTEGER * 4     LOCLUN
#else
      INTEGER * 8     LOCLUN
#endif

      POINTER (IPT,Q)
      DIMENSION Q(1)

      IPT  = LOCLUN(LUN)
      ILOC = 0
C     RUN-TIME ALLOCATION SPECIFIC CODE LINE ENDS

C     GET THE CORRECT OFFSET INTO THE BUFFER.
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN) + ILOC 

      IF ((IGO + NB - 1 - ILOC) .GT. NWORDLUN(LUN)) THEN
C        GOES OUT OF RESERVED BUFFER!
         WRITE(NOUT,*) '*** INLN_WRTLIN ARRAY OVERFLOW, LUN: ',LUN,
     &      '   LENGTH:',IGO + NB,'   NREC: ',NREC,
     &      '   LUNARA(LUN) :',LUNARA(LUN),'  LUNSTK(LUN):',LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :',NSAMLUN(LUN)  
         CALL ERRT(100,'WRTLIN',NE)
         IERR = 1
         RETURN

      ELSEIF (IGO .LT. ILOC) THEN
C        BEFORE RESERVED BUFFER!
         WRITE(NOUT,*) '*** INLN_WRTLIN ARRAY UNDERFLOW, LUN: ',LUN,
     &      '   IGO:',IGO,'   NREC: ',NREC,
     &      '   LUNARA(LUN) :',LUNARA(LUN),'  LUNSTK(LUN):',LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :',NSAMLUN(LUN)  
         CALL ERRT(100,'WRTLIN',NE)
         IERR = 1
         RETURN
      ENDIF

C     WRITE THE BUFFER (THERE MAY BE A FASTER WAY TO DO THIS!!)
      DO I= 1,NB
         Q(IGO + I) = BUF(I) 
      ENDDO
      IERR = 0

      RETURN
      END

#endif
@


1.20
log
@SP_ALLOC and close(ndat) removed
@
text
@d73 1
a73 2
      LOGICAL         USEINLN
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
d75 2
a76 2
#ifdef SP_NT
      INTEGER         LOCLUN
d81 1
d210 1
a210 2
      LOGICAL         USEINLN
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
@


1.19
log
@f90 changes
@
text
@a75 4
CNO_SAVE

#ifdef SP_ALLOC
C     RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
a80 4
#else
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
      INTEGER * 4     LOCLUN
#endif
a150 2
CNO_SAVE

a174 1
         CLOSE(NDAT)
a184 1
         CLOSE(NDAT)
a212 4
CNO_SAVE

#ifdef SP_ALLOC
C     RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
d214 1
a214 1
        INTEGER * 4     LOCLUN
d216 1
a216 1
        INTEGER * 8     LOCLUN
a224 12
#else
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
C     CAN NOT USE POINTER IMPLEMENTATION SINCE POINTER SIZE
C     VARIES BETWEEN ALPHA AND NOT-ALPHA VMS

      PARAMETER       (INLNSIZ = 500000)
      COMMON /LUNARD/ Q(INLNSIZ)

      ILOC = LOCLUN(LUN) -1 

C     NON-RUN-TIME ALLOCATION SPECIFIC CODE LINE ENDS
#endif
a234 1
         CLOSE(NDAT)
a244 1
         CLOSE(NDAT)
@


1.18
log
@NT specific stuff
@
text
@d28 39
d108 1
d154 62
d229 2
a230 2
#ifdef SP_NT
      INTEGER        LOCLUN
d232 1
a232 1
      INTEGER * 8     LOCLUN
d289 1
@


1.17
log
@recovered correct version
@
text
@d127 3
d131 1
@


1.16
log
@ifdef SP_NT
@
text
@d39 1
a39 1

d41 1
a41 1

d43 7
a49 2


d125 1
a125 1

d127 1
a127 2

      INTEGER     LOCLUN
d135 9
d145 2
@


1.15
log
@used INteger instead of integer *8 for pointers in nt
@
text
@d39 1
a39 1
#ifdef SP_ALLOC
d41 1
a41 1
#ifdef SP_NT
d43 2
a44 7
#else
      INTEGER * 8     LOCLUN
#endif
#else
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
      INTEGER * 4     LOCLUN
#endif
d120 1
a120 1
#ifdef SP_ALLOC
d122 2
a123 1
      INTEGER * 8     LOCLUN
a130 9
#else
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
C     CAN NOT USE POINTER IMPLEMENTATION SINCE POINTER SIZE
C     VARIES BETWEEN ALPHA AND NOT-ALPHA VMS

      PARAMETER       (INLNSIZ = 500000)
      COMMON /LUNARD/ Q(INLNSIZ)

      ILOC = LOCLUN(LUN) -1 
a131 2
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE LINE ENDS
#endif
@


1.14
log
@used iostat and used errt in inln_wrtlin
@
text
@d41 3
d45 1
@


1.13
log
@added inline underflow trap
@
text
@d3 9
a11 10
C   WRTLIN.FOR                       DATE LAST MODIFIED: 8/4/95 al
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d30 1
a30 1
      REAL   BUF(NB)
d32 1
a32 1
      COMMON /UNITS/LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
d34 1
a34 1
      LOGICAL USEINLN
d53 1
a53 1
C     ADD LUNARA(LUN)(FOR LABEL REC) AND LUNSTK( FOR STACK OFFSET)
d56 6
a61 5
      WRITE(LUN,REC=I,ERR=1000) BUF
      RETURN

1000  IERR = 1
      WRITE(NOUT,*) '*** ERROR IN WRTLIN:',LUN,NB,NREC,I
d67 10
a76 11
C++*******************************************************************
C   inln_WRTLIN.FOR                       MAHIEDDINE LADJADJ
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d87 1
a87 1
C
d100 3
a102 3
C       THIS BUFFER CAN BE SUBDIVIDED INTO TWO PART TO HOLD TWO FILES, 
C       CALLED INFILES.
C       BY DEFAULT, THE INFILES ARE CALLED ___1 AND ___2. 
d104 1
a104 1
C       DATA FROM A FILE IS STORED EXACTLY THE SAME WAY AS IT IS IN 
a112 1
      COMMON /IOERR/IERR
d114 1
a114 1
      COMMON /UNITS/LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
d116 1
a116 1
      LOGICAL USEINLN
d154 3
a156 1
         STOP
d165 3
a167 1
         STOP
d174 1
@


1.12
log
@better error msg in inline failure
@
text
@d155 9
a163 1
         IERR = 1
@


1.11
log
@added lunstk in inline
@
text
@d152 3
a154 1
     &       'LENGTH:' ,IGO + NB
d156 1
@


1.10
log
@added useinln to lunarb
@
text
@d147 1
a147 1
      IGO = (LUNARA(LUN) + NREC - 1) * NSAMLUN(LUN) + ILOC
@


1.9
log
@stacks introduced
@
text
@d35 2
a36 1
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)
d118 2
a119 1
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)
@


1.8
log
@fixed integer 8 in inline buffer (not available on non-alpha)
@
text
@d32 3
a34 3
      COMMON /IOERR/IERR

      COMMON /LUNARA/ LUNARA(100),LASLAB
d53 3
a55 3
C     ADD LUNARA(LUN)(FOR LABEL REC) TO NREC TO GET THE CORRECT 
C     RECORD NUMBER
      I = NREC + LUNARA(LUN)
d59 2
a60 2
1000  IERR=1
      WRITE(6,*) '*** ERROR IN WRTLIN:',LUN,NB,NREC,I
d116 1
a116 1
      COMMON /LUNARA/ LUNARA(100),LASLAB
@


1.7
log
@new runtime inline buffer alteration
@
text
@a34 1
      INTEGER * 8     LOCLUN
d39 8
a116 1
      INTEGER * 8     LOCLUN
d120 5
a124 1
 
d128 16
a143 2
      IPT = LOCLUN(LUN)
     
d145 1
a145 1
      IGO = (LUNARA(LUN) + NREC - 1) * NSAMLUN(LUN) 
d147 1
a147 1
      IF ((IGO + NB - 1) .GT. NWORDLUN(LUN)) THEN
@


1.6
log
@allow use of inlined buff 1 and 2 simultaneously
@
text
@d1 1
d3 1
a3 3
C
C WRTLIN.FOR                            DATE LAST MODIFIED: 07/15/93 al
C                                          I4 OK 7/16/87 al
d14 1
a14 1
C  WRTLIN(LUN,BUF,NB,NREC)
d16 1
a16 1
C  PURPOSE:    WRITE A LINE OF REAL NUMBERS TO A FILE OPENED ON LUN
d18 5
a22 1
C  PARAMETERS:
d24 3
a26 5
C        LUN    LOGICAL UNIT NUMBER OF FILE TO BE WRITTEN TO
C        BUF    BUFFER THAT RECORD IS READ FROM
C        NB     NUMBER OF VALUES IN RECORD TO BE WRITTEN
C        NREC   RECORD TO BE WRITTEN INTO
C
d29 1
a29 1
      SUBROUTINE   WRTLIN(LUN,BUF,NB,NREC)
d32 6
a37 9
#ifdef SP_VMS
      COMMON /LUNARA/ LUNARA(100),LASLAB,LUNINI(100)
#else
      COMMON /LUNARA/ LUNARA(100),LASLAB,NOFFSET,
     &                  LUNOFF(100),LUNFORM(100),LUNINI(100)
#endif
	INTEGER ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
	COMMON/LUNYP/ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
	INTEGER ACTIV
d40 3
a42 8
C     CHECK IF USER HAS ASKED FOR INLINED BUFFER
      IF(LUNINI(LUN).GT.0) THEN
         IF(LUN .EQ. ACT1) THEN
	    ACTIV = 1
	 ELSE
	    ACTIV = 2
	 END IF
         CALL INLN_WRTLIN(ACTIV,LUN,BUF,NB,NREC)
d44 1
a44 1
      END IF
d46 2
a47 1
C     ADD LUNARA(LUN)(FOR LABEL REC) TO NREC TO GET THE CORRECT RECORD NUMBER
a48 1

d52 1
a52 1
1000  CONTINUE
a53 1
      STOP
d55 1
d58 1
d60 1
a60 3
C
C inln_WRTLIN.FOR                            DATE LAST MODIFIED: 07/15/93 al
C                                          I4 OK 7/16/87 al
d71 1
a71 1
C  WRTLIN(LUN,BUF,NB,NREC)
d73 1
a73 1
C  PURPOSE:    WRITE A LINE OF REAL NUMBERS TO A FILE OPENED ON LUN
d75 5
a79 1
C  PARAMETERS:
d81 3
a83 7
C	 INI    INLINED BUFFER 1 OR 2
C        LUN    LOGICAL UNIT NUMBER OF FILE TO BE WRITTEN TO
C        BUF    BUFFER THAT RECORD IS READ FROM
C        NB     NUMBER OF VALUES IN RECORD TO BE WRITTEN
C        NREC   RECORD TO BE WRITTEN INTO
C
C
a91 3
C               PARAMETER (ISZBUF = 500000)
C               COMMON/SPI_FILEB/FBUF(ISZBUF)
C       note:  ISZBUF0=ISZBUF
d95 1
a95 9
C       BY DEFAULT, THE INFILES ARE CALLED ___1 AND ___2. THE USER
C       CAN RENAME THEM, WITH THE MD COMMAND (SETMODE.FOR ROUTINES).
C       THE USER NAMES ARE STORED AS INLNAM1 AND INLNAM2.
C               CHARACTER * 80 INLNAM1,INLNAM2
C               COMMON/CINLN_NAMES/INLNAM1,INLNAM2
C
C       THE SIZES OF THESE BUFFERS ARE INLNSIZE AND (ISZBUF0 - INLNSIZE).
C               INTEGER INLNSIZE, ISZBUF0
C               COMMON/INLN_FLAGS/INLNSIZE,ISZBUF0
d97 1
a97 1
C       A DATA FROM A FILE IS STORED EXACTLY THE SAME WAY AS IT IS IN 
a99 8
C       SPIDER OPENS A FILE TWICE. FIRST TO READ/WRITE THE HEADER WITH
C       A (COMPUTED) RECORD SIZE REC1, THEN A SECOND TIME, TO  READ/WRITE
C       THE IMAGE DATE ITSELF WITH A  (COMPUTED) RECORD SIZE REC2.
C       THE RECORD SIZES, REC1 AND REC2 ARE STORED IN RECLN0* AND RECLN1*
C       RESPECTIVELY FOR EACH INLINED BUFFER.
C               INTEGER INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
C               COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
C       where INLUN* is the unit associated with each inlined buffer (90,91)
d103 1
a103 1
      SUBROUTINE   INLN_WRTLIN(INI,LUN,BUF,NB,NREC)
d106 2
a107 14
#ifdef SP_VMS
      COMMON /LUNARA/ LUNARA(100),LASLAB,LUNINI(100)
#else
      COMMON /LUNARA/ LUNARA(100),LASLAB,NOFFSET,
     &                  LUNOFF(100),LUNFORM(100),LUNINI(100)
#endif
C     DEFAULT VALUE OF INLNSIZE = ISZBUF/2 
      INTEGER INLNSIZE, ISZBUF0
      COMMON/INLN_FLAGS/INLNSIZE,ISZBUF0
      PARAMETER (ISZBUF = 500000)
      COMMON/SPI_FILEB/FBUF(ISZBUF)
      INTEGER INI,J,K,I, II,ENDSIZE,ACTIV
      INTEGER ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
      COMMON/LUNYP/ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
d109 4
a112 2
      INTEGER       LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      
d114 21
a135 39
C     ADD LUNARA(LUN)(FOR LABEL REC) TO NREC TO GET THE CORRECT RECORD NUMBER
C     AND OFFSET.
      II = NREC + LUNINI(LUN)

      IF(INI.EQ.1) THEN
	 J=0
         RECL1=RECLN01
         RECL2=RECLN11
         ENDSIZE = INLNSIZE 
      ELSE
         J = INLNSIZE
         RECL1=RECLN02
         RECL2=RECLN12
         ENDSIZE = ISZBUF0 - INLNSIZE
      END IF      
      
      IF(II.EQ.1) THEN
         IF(NB .GT. RECL1) GOTO 1000 
C	 WRITE HEADER
	 
         DO I=1,NB
            FBUF(J+I) = BUF(I)
         END DO
	 DO I = NB+1,RECL1
            FBUF(J+I) = 0
         END DO
      ELSE
         K = (II-1) * RECL2 + 1
         IF((K+RECL2).GE.ENDSIZE) GOTO 1000
         IF(NB .GT. RECL2) GOTO 1000 
         J = J + K
C	 WRITE HEADER
         DO I=1,NB
            FBUF(J+I) = BUF(I)
         END DO
	 DO I = NB+1,RECL2
            FBUF(J+I) = 0
         END DO
      END IF
a136 5

1000  CONTINUE
      WRITE(NOUT,*) '*** INLN_WRTLIN: buffer too small ',INI,NB,NREC
      STOP

@


1.5
log
@changes for inlined buff by adding lunini array
@
text
@d37 3
a39 2
      INTEGER ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
      COMMON/LUNYP/ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
d44 5
d144 3
a146 3
      INTEGER INI,J,K,I, II,ENDSIZE
      INTEGER ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
      COMMON/LUNYP/ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
@


1.4
log
@added comments for inlined buffers
@
text
@d31 8
a38 6
      COMMON /LUNARA/ LUNARA(100)

C	FORTRAN UNIT ASSOCIATED WITH EACH inlined buff
	INTEGER INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
	COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12

d42 2
a43 7
C     INLUN1(2) IS THE UNIT FOR INLINED BUFFER 1(2)
      IF(LUN.EQ.INLUN1) THEN
         CALL INLN_WRTLIN(1,LUN,BUF,NB,NREC)
         RETURN
      END IF
      IF(LUN.EQ.INLUN2) THEN
         CALL INLN_WRTLIN(2,LUN,BUF,NB,NREC)
a46 1

d127 6
a132 1
      COMMON /LUNARA/ LUNARA(100)
a137 1

d139 4
a142 4

C     FORTRAN UNIT ASSOCIATED WITH EACH inlined buff
      INTEGER INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
      COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
d148 1
a148 1
      II = NREC + LUNARA(LUN)
d173 1
a173 1
         K = II * RECL2 - 1
d188 1
a188 1
      WRITE(6,*) '*** INLN_WRTLIN: buffer too small ',INI,NB,NREC
@


1.3
log
@add write to   inlined buffer
@
text
@d40 1
d83 1
d89 37
@


1.2
log
@nosave
@
text
@d32 5
d38 12
d58 92
@


1.1
log
@Initial revision
@
text
@d32 1
a32 1

@
