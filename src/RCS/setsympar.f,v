head	1.29;
access;
symbols
	healthdept_2018:1.29
	pre_getangas:1.26
	GPL2010:1.25
	pre_GPL2010:1.24
	pre_var_equation:1.21
	pre_fftwrings:1.21
	pre_opfiles:1.20
	src:1.20
	best-code:1.19
	named-reg:1.18
	x-named-regs:1.17
	x:1.17
	v13-00:1.16
	pre_GPL:1.15
	prec_CA:1.14
	noindx:1.14;
locks; strict;
comment	@c @;


1.29
date	2018.10.03.14.34.16;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2015.06.15.15.36.36;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2015.06.15.13.46.31;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2010.12.02.18.46.52;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.24.13.26.54;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.01.15.50.29;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.16.18.46.28;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.26.13.17.24;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.27.15.48.02;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.01.19.21.09;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.07.19.48.29;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.12.15.30.30;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.15.21.51.21;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.17.21.06.40;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.24.17.24.44;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.02.18.21.41;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.01.12.37.01;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.26.20.19.20;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.26.19.52.49;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.14.14.48.18;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.04.15.18.06;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.10.19.15.02;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.05.13.58.00;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.05.12.35.57;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.26.18.57.10;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.21.16.05.28;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.19.18.04.27;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.08.20.24.41;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.22.14.28.12;	author leith;	state Exp;
branches;
next	;


desc
@?xxxx?<1> anywhere now
@


1.29
log
@email_health_dept
@
text
@

C++*********************************************************************
C
C  SETSYMPAR.F -- CREATED 2/20/01 FROM SPIDER.F     ARDEAN LEITH 
C                 ?<ANYTHING? BUG              FEB 2002 ARDEAN LEITH
C                 REWRITTEN                    JUN 2002 ARDEAN LEITH
C                 [] DEFAULT FOR VARIABLES     OCT 2005 ARDEAN LEITH
C                 GLOBAL DUPLICATES OK         FEB 2006 ARDEAN LEITH
C                 CVAR                         OCT 2006 ARDEAN LEITH
C                 NCHAR IN SYMPAR_SUB          NOV 2009 ARDEAN LEITH
C                 DONOTRECURSE IN SYMPAR_SUB   MAY 2010 ARDEAN LEITH
C                 ISSYMPAR IRTFLG BUG          MAY 2010 ARDEAN LEITH
C                 UNDEFINED VARS FIXED         DEC 2010 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    SETSYMPAR(SYMPARID,SYMPARVAL,LOCAL,IRTFLG)
C
C    PURPOSE:       RECORD VARIABLE IN CVAR ARRAY
C
C    PARAMETERS:    SYMPARID   ID (WITH <>)                    (SENT)
C                   SYMPARVAL  VALUE                           (SENT)
C                   LOCAL      FLAG FOR LOCAL                  (SENT)
C                   IRTFLG     RETURN FLAG (0 IS NORMAL)   (RETURNED)
C   
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************


      MODULE SYMPAR_STUFF

         SAVE

C        DANGER, MAXPRC IS ALSO SET IN spider.f!!
         INTEGER, PARAMETER :: MAXPRC = 20      ! NO. OF PROC. LEVELS
         INTEGER, PARAMETER :: MAXVARNAME_LEN  = 80

C        BANK ZERO IS FOR GLOBAL BANK
         INTEGER, DIMENSION(0:MAXPRC) :: IGOCSTRQ,   IENDCSTRQ
         INTEGER, DIMENSION(0:MAXPRC) :: IGOCVARNUM, IENDCVARNUM
         INTEGER, DIMENSION(0:MAXPRC) :: LENCSTRQ,   NCVAR

C        THIS SHOULD BE RE-DONE WITH ALLOCATABLE CHAR. ARRAY??
         INTEGER, PARAMETER         :: MAXCSTRQG     = 6000
         INTEGER, PARAMETER         :: MAXCSTRQ      = 16000

         INTEGER, PARAMETER         :: NUMCVARG_ORIG = 2000
         INTEGER, PARAMETER         :: NUMCVAR_ORIG  = 5300

         INTEGER                    :: NUMCVAR       = 0
         INTEGER                    :: NUMCVARG      = 0

         CHARACTER(LEN=MAXCSTRQ+MAXCSTRQG) :: CSTRQ  = ' '

         INTEGER, PARAMETER         :: MAXCVAR_LEN = 120
         CHARACTER(LEN=MAXCVAR_LEN), ALLOCATABLE, 
     &                   DIMENSION(:) :: CVARVALUES 

      END MODULE SYMPAR_STUFF

C------------------------- END MODULE ---------------------------------

C CONTENTS:
C       ISSYMPAR(NAME,IBANK,ICVAR,IRTFLG)
C       SETSYMPAR(SYMPARID,SYMPARVAL,LOCAL,IRTFLG)
C       SYMPAR_NEW(IBANK,NAME,CVALUE,ICVAR,IRTFLG)
C       SYMPAR_OLD(ICVAR,CVALUE,IRTFLG)
C       SYMPAR_INIT(IBANK,IRTFLG)
C       SYMPAR_FIND(IBANK,NAME,ICVAR,IRTFLG)
C       SYMPAR_SUB(INPUT,OUTPUT,NCHAR,ILEVEL,IRTFLG)
C       SYMPAR_REINIT(IRTFLG)
C       SYMPAR_GET_NUMS(ICVARS,NCHAR)
C       ASSOCARRAY(QSTRQ,QFIND,IGO,IEND,IRTFLG)


C------------------------- SETSYMPAR ---------------------------------


      SUBROUTINE SETSYMPAR(SYMPARID,SYMPARVAL,LOCAL,IRTFLG)

      COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

      CHARACTER(LEN=*)  :: SYMPARID,SYMPARVAL
      LOGICAL           :: LOCAL
      CHARACTER(LEN=1)  :: NULL = CHAR(0)

      IBANK = 0
      IF (LOCAL) IBANK = ISTOP

      IF (SYMPARID == NULL) THEN
C        SET INITIAL VARIABLE INFO (BEST MIGRATED INTO SPIDER CALL)
         CALL SYMPAR_INIT(IBANK,IRTFLG)
         IRTFLG = 0
         RETURN
      ENDIF

C     SEARCH FOR AN EXISTING VARIABLE OF SAME NAME
      CALL SYMPAR_FIND(IBANK,SYMPARID,ICVAR,IRTFLG)

      IF (ICVAR <= 0) THEN
C        CREATE NEW VARIABLE 
         CALL SYMPAR_NEW(IBANK,SYMPARID,SYMPARVAL,ICVAR,IRTFLG)

      ELSE
C        REPLACE VARIABLE VALUE 
         CALL SYMPAR_OLD(ICVAR,SYMPARVAL,IRTFLG)
      ENDIF

      END

C++*********************************************************************
C
C SYMPAR_NEW                         NEW            OCT 2006 ARDEAN LEITH
C
C **********************************************************************
C
C    SYMPAR_NEW(IBANK,NAME,CVALUE,ICVAR,IRTFLG)
C 
C    PURPOSE:     CREATES A NEW CVAR VARIABLE & ASSOCIATED VALUE   
C
C    PARAMETERS:  IBANK     STACK LEVEL                         (SENT)
C                 NAME      VARIABLE NAME, WITH [...]           (SENT)
C                 CVALUE    VARIABLE VALUE                      (SENT)
C                 ICVAR     VARIABLE NUMBER                     (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C     NOTES: VARIABLE SHOULD NOT ALREADY EXIST (NOT CHECKED)
C
C--*******************************************************************

      SUBROUTINE SYMPAR_NEW(IBANK,NAME,CVALUE,ICVAR,IRTFLG)

      USE SYMPAR_STUFF

      INCLUDE 'CMBLOCK.INC'

      CHARACTER(LEN=*)  :: NAME,CVALUE
      CHARACTER(LEN=20) :: CICVAR

C     NOTE: IF VARIABLE ALREADY EXISTS THIS GIVES ERROR
      IRTFLG = 1

C     VARIABLE DOES NOT EXIST, CREATE IT
C     WRITE(NDAT,*)' CREATING VARIABLE: ',NAME

C     INCREMENT VARIABLE NUMBER
      ICVAR = IENDCVARNUM(IBANK) + 1

      IF (IBANK == 0 .AND. ICVAR > NCVAR(IBANK)) THEN
C        OVER-RUN OF GLOBAL VARIABLE VALUE ARRAY
         IT = NCVAR(IBANK)
         CALL ERRT(102,'TOO MANY GLOBAL VARIABLES REQUESTED, LIMIT',IT)
         RETURN

      ELSEIF (ICVAR > NCVAR(IBANK)) THEN
C        OVER-RUN OF CVAR VARIABLE VALUE ARRAY

         write(6,*) ' NEW VARIABLE NAME:  ',NAME
         write(6,*) ' BANK:               ',IBANK
         write(6,*) ' IGOCSTRQ(IBANK):    ',IGOCSTRQ(IBANK)
         write(6,*) ' IGOCVARNUM(IBANK):  ',IGOCVARNUM(IBANK)
         write(6,*) ' IENDCVARNUM(IBANK): ',IENDCVARNUM(IBANK)
         write(6,*) 'CSTRQ(IBANK)(1:60): ',
     &          CSTRQ(IGOCSTRQ(IBANK):IGOCSTRQ(IBANK)+60)

         IT = NCVAR(IBANK)
         CALL ERRT(102,'TOO MANY LOCAL VARIABLES REQUESTED, LIMIT',IT)
         RETURN
      ENDIF

C     PLACE VARIABLE NAME STRING IN CSTRQ ARRAY
      CALL INTTOCHAR(ICVAR,CICVAR,LENNUM,1)  ! LENGTH OF VARIABLE NUM.
      LENVAR  = LEN(CVALUE)         ! LENGTH OF VARIABLE VALUE
      LENNAM  = LEN(NAME)           ! LENGTH OF VARIABLE NAME

      IF (LENNAM > 80) THEN
         WRITE(NOUT,*) '  VARIABLE NAME: ',NAME
         CALL ERRT(102, 'OVERLENGTH VARIABLE NAME, CHARS.',LENNAM)
         RETURN
      ELSEIF (LENVAR .GE. MAXCVAR_LEN) THEN
         WRITE(NOUT,*) '  VARIABLE NAME: ',NAME
         CALL ERRT(102,'OVERLENGTH VARIABLE, CHARS.',LENVAR)
         RETURN
      ENDIF

      LENADD  = LENNAM + LENNUM          ! LENGTH OF CSTRQ ENTRY
      IGOQ    = IENDCSTRQ(IBANK) + 1
      IENDQAT = IENDCSTRQ(IBANK) + LENADD 

      IF (IENDQAT .GE. LENCSTRQ(IBANK)) THEN
C        OVER-RUN OF CSTRQG ARRAY
         CALL ERRT(102,'CSTRQG OVERFLOW, TOO MANY VARIABLES',IENDQAT)
         RETURN
      ENDIF

#ifdef DEBUGD
      write(6,*) ' BANK:               ',IBANK
      write(6,*) ' IENDCSTRQ(IBANK):  ',IENDCSTRQ(IBANK)
      write(6,*) ' LENVAR:  ',LENVAR
      write(6,*) ' LENADD:  ',LENADD
      write(6,*) ' LENNAM:  ',LENNAM
      write(6,*) ' LENNUM:  ',LENNUM
      write(6,*) ' NEW VARIABLE NAME:  ',NAME(2:LENNAM-1)
      write(6,*) ' NEW VARIABLE VALUE:  ',CVALUE
      write(6,*) ' IGOQ:  ',IGOQ,'   IENDQAT:  ',IENDQAT
      write(6,*) ' CICVAR(1:LENNUM):  ',CICVAR(1:LENNUM)
      write(6,*) ' ICVAR:  ',ICVAR
#endif

      CSTRQ(IGOQ:IGOQ+LENADD-1) = NAME(2:LENNAM-1) // '>' // 
     &                            CICVAR(1:LENNUM) // '<' 
      CVARVALUES(ICVAR) = CVALUE(1:LENVAR) 

#ifdef DEBUGD
      write(6,*) ' CSTRQ(1:50): ',CSTRQ(1:50)
      write(6,*) ' CSTRQ(6000:6050): ',CSTRQ(6000:6050)
      write(6,*) ' CVARVALUES(ICVAR): ',CVARVALUES(ICVAR)(1:LENVAR)
#endif

      IENDCSTRQ(IBANK)   = IENDQAT 
      IENDCVARNUM(IBANK) = ICVAR
      IRTFLG             = 0

      END

C++*********************************************************************
C
C SYMPAR_OLD                         NEW            OCT 2006 ARDEAN LEITH
C
C **********************************************************************
C
C    SYMPAR_OLD(ICVAR,CVALUE,IRTFLG)
C 
C    PURPOSE:     REPLACES EXISTING CVAR VARIABLE'S ASSOCIATED VALUE   
C
C    PARAMETERS:  ICVAR     VARIABLE NUMBER                     (SENT)
C                 CVALUE    VARIABLE VALUE                      (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C     NOTES: VARIABLE SHOULD NOT ALREADY EXIST (NOT CHECKED)
C
C--*******************************************************************

      SUBROUTINE SYMPAR_OLD(ICVAR,CVALUE,IRTFLG)

      USE SYMPAR_STUFF
         
      CHARACTER(LEN=*) :: CVALUE 

C     IF VARIABLE NOT ALREADY EXISTS (ERROR)
      CVARVALUES(ICVAR) = CVALUE

      IRTFLG = 0

      END

C++*********************************************************************
C
C SYMPAR_INIT                         NEW            OCT 2006 ARDEAN LEITH
C
C **********************************************************************
C
C    SYMPAR_INIT(IBANK,IRTFLG)
C 
C    PURPOSE:     INITIALIZES CVAR VARIABLE'S    
C
C    PARAMETERS:  IBANK     PROCEDURE BANK NUMBER               (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C
C--*******************************************************************

      SUBROUTINE SYMPAR_INIT(IBANK,IRTFLG)

      USE SYMPAR_STUFF

      IRTFLG = 1
      IF (IBANK .LT. 0) THEN
         CALL ERRT(102,'ILLEGAL VARIABLE BANK:',IBANK)
         RETURN
      ELSEIF (IBANK > MAXPRC) THEN
         IT     = MAXPRC
         CALL ERRT(102,'VARIABLE BANK EXCEEDS MAXPRC',IT)
         RETURN
      ENDIF

      IF (NUMCVAR <= 0) THEN
C        CREATE THE CVAR STORAGE ARRAY (ONLY OCCURS ONCE)
         MWANT = NUMCVAR_ORIG + NUMCVARG_ORIG
         ALLOCATE (CVARVALUES(MWANT), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'UNABLE TO ALLOCATE CVARS:',MWANT)
            RETURN
         ENDIF
         NUMCVAR  = NUMCVAR_ORIG
         NUMCVARG = NUMCVARG_ORIG

         NCVAR(0)           = NUMCVARG
         NCVAR(1:MAXPRC)    = MWANT

         LENCSTRQ(0)        = MAXCSTRQ
         LENCSTRQ(1:MAXPRC) = MAXCSTRQ + MAXCSTRQG
      ENDIF

      IF (IBANK == 0) THEN
C        INITIALIZE GLOBAL BANK ZERO, (SHOULD ONLY OCCUR ONCE)

         IGOCSTRQ(IBANK)    = 1
         IGOCVARNUM(IBANK)  = 1
         IENDCVARNUM(IBANK) = 0

      ELSEIF (IBANK == 1) THEN
         IGOCSTRQ(IBANK)    = MAXCSTRQG         + 1
         IGOCVARNUM(IBANK)  = NUMCVARG          + 1
         IENDCVARNUM(IBANK) = IGOCVARNUM(IBANK) - 1
      ELSE
         IGOCSTRQ(IBANK)    = IENDCSTRQ(IBANK-1)   + 1
         IGOCVARNUM(IBANK)  = IENDCVARNUM(IBANK-1) + 1
         IENDCVARNUM(IBANK) = IGOCVARNUM(IBANK)    - 1
      ENDIF

C     PUT INITIAL < IN CSTRQ
      CSTRQ(IGOCSTRQ(IBANK):IGOCSTRQ(IBANK)) = '<'  
      IENDCSTRQ(IBANK) = IGOCSTRQ(IBANK) 

#ifdef DEBUGD
      write(6,*) 'initial IBANK:',IBANK 
      write(6,*) 'initial IENDCSTRQ(IBANK):',IENDCSTRQ(IBANK) 
#endif
      IRTFLG = 0
 
      END

C++*********************************************************************
C
C ISSYMPAR                          NEW            JUN 2009 ARDEAN LEITH
C
C **********************************************************************
C
C    ISSYMPAR(NAME,IBANK,ICVAR,IRTFLG)
C 
C    PURPOSE:     SEES IF A CVAR VARIABLE ALREADY EXISTS   
C
C    PARAMETERS:  IBANK     STACK LEVEL                         (SENT)
C                 NAME      VARIABLE NAME, WITH [...]           (SENT)
C                 ICVAR     VARIABLE NUMBER                     (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C
C--*******************************************************************

      SUBROUTINE ISSYMPAR(NAME,IBANK,ICVAR,IRTFLG)

      INCLUDE 'CMLIMIT.INC'

      CHARACTER(LEN=*), INTENT(IN)  :: NAME
      INTEGER, INTENT(IN)           :: IBANK
      INTEGER, INTENT(OUT)          :: ICVAR,IRTFLG
 
C     FOR ISTOP 
      INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK,IPARNUM
      COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

      ILEVEL = IBANK
      IF (ILEVEL .LT. 0) ILEVEL = ISTOP

      CALL SYMPAR_FIND(ILEVEL,NAME,ICVAR,IRTFLG)
      IF (IRTFLG == 1 .OR. ICVAR <= 0) THEN
C        NOT AT THIS BANK, TRY GLOBAL
         IF (ILEVEL .NE. 0) THEN
            ILEVEL = 0
            CALL SYMPAR_FIND(ILEVEL,NAME,ICVAR,IRTFLG)
         ENDIF
      ENDIF
 
      END

C++*********************************************************************
C
C SYMPAR_FIND                       NEW            OCT 2006 ARDEAN LEITH
C
C **********************************************************************
C
C    SYMPAR_FIND(IBANKT,NAME,ICVAR,IRTFLG)
C
C    PURPOSE:     FINDS IF VARIABLE EXISTS, RETURNS VARIABLE NUMBER  
C
C    PARAMETERS:  IBANK     STACK LEVEL () IS CURRENT TOP       (SENT)
C                 NAME      VARIABLE NAME, WITH [...]           (SENT)
C                 ICVAR     VARIABLE NUMBER                     (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE SYMPAR_FIND(IBANK,NAME,ICVAR,IRTFLG)

      USE SYMPAR_STUFF

      CHARACTER(LEN=*)                :: NAME
      CHARACTER(LEN=MAXVARNAME_LEN+2) :: NAMET

C     SEE IF VARIABLE EXISTS YET

C     <> ARE USED AS VARIABLE ID DELIMITERS IN CSTRQ
      LENT  = LEN(NAME)
      NAMET = '<' // NAME(2:LENT-1) // '>' 

      IGOQ   = IGOCSTRQ(IBANK)
      IENDQ  = IENDCSTRQ(IBANK)
      IRTFLG = 0
      ICVAR  = 0

      IF (IENDQ > IGOQ) THEN
C        SEARCH FOR THIS VARIABLE AT THIS LEVEL
         CALL ASSOCARRAY(CSTRQ(IGOQ:IENDQ),NAMET(1:LENT),
     &                   IGO,IEND,IRTFLG)

#ifdef DEBUGD
         write(6,*) ' HUNTING, BANK:',IBANK,':', NAMET(1:LENT)
         write(6,*) ' IN: ',CSTRQ(IGOQ:IENDQ)
#endif

         IF (IRTFLG == 0) THEN
C           VARIABLE EXISTS, FIND VARIABLE NUMBER
#ifdef DEBUGD
            write(6,*) ' FOUND VAR NUMBER: ', CSTRQ(IGO:IEND)
            write(6,*) ' AT CSTRQ: ',IGO,'..',IEND
#endif
            READ(CSTRQ(IGOQ+IGO-1:IGOQ+IEND-1),*) ICVAR
            LENVAR = lnblnk(CVARVALUES(ICVAR))

#ifdef DEBUGD
            !write(6,*) ' INTEGERIZED VAR. NUM: ', ICVAR
#endif

#ifdef DEBUGD
        ELSE
            write(6,*) ' SYMPAR_FIND, IRTFLG: ', IRTFLG
#endif
        ENDIF


      ENDIF

      END



C++*************************************************************************
C
C  SYMPAR_SUB.F   CREATED  FROM SPIDER.F         Sep 2000  ARDEAN LEITH 
C                 MULTIPLE VARIABLE SUBSTITUTION JAN 2001  ARDEAN LEITH
C                 ALPHABETICAL VARIABLES         JUN 2002  ARDEAN LEITH
C                 NESTED VARIABLES               SEP 2002  ARDEAN LEITH
C                 [] DEFAULT FOR VARIABLES       OCT 2005  ARDEAN LEITH
C                 CVAR                           OCT 2006  ARDEAN LEITH
C                 DONOTRECURSE                   JUN 2010  ARDEAN LEITH
C              
C **********************************************************************
C
C    SYMPAR_SUB(INPUT,OUTPUT,NCHAR,ILEVELT,DONOTRECURSE,IRTFLG)
C
C    PURPOSE:       RUN-TIME VARIABLE SUBSTITUTION FOR ALL [ID] IN
C                   INPUT STRING AT THIS STACK LEVEL
C
C    PARAMETERS:    INPUT     INPUT LINE CONTAINING [STRING..] (SENT)
C                   OUTPUT    SUBSTITUTED OUTPUT LINE         (RET.)
C                   NCHAR     LAST NON_BLANK CHAR BEFORE ;    (RET.)
C                   ILEVEL    NESTING LEVEL                   (SENT)
C                   IRTFLG    RETURN FLAG (0 IS NORMAL)       (RETURNED)
C   
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE SYMPAR_SUB(INPUT,OUTPUT,NCHAR,ILEVEL,
     &                      DONOTRECURSE,IRTFLG)

      USE SYMPAR_STUFF

      INCLUDE 'CMBLOCK.INC'

      CHARACTER(LEN=*)           :: INPUT,OUTPUT
      CHARACTER(LEN=MAXCVAR_LEN) :: CVALUE
      LOGICAL                    :: LOCAL
      INTEGER, DIMENSION(160)    :: DONOT
      LOGICAL                    :: DONOTRECURSE

      INOT   = 0     
      LENT   = LEN(INPUT)
      OUTPUT = INPUT
      NCHAR  = lnblnk(INPUT)

      IDONE  = 0
      IP2N   = INDEX(OUTPUT,']',BACK=.TRUE.)

      DO
C        REPLACE ALL SYMBOL [] SETS IN POSITIONS 1...LENT

C        FIND START AND END OF FIRST VARIABLE STRING IN OUTPUT 
         CALL CHARINSIDE(OUTPUT(1:LENT),'[',']',.FALSE.,.FALSE.,
     &                  IP1,IP2,NCT)

C        GET OUT OF LOOP IF NO SYMBOL SET [] FOUND
         IF (NCT <= 0) EXIT

C        FIND SYMBOL STRING FOR SUBSTITUTION.

         IRTFLG = 1

C        <> ARE USED AS SYMBOL ID DELIMITERS IN CSTRQ
         OUTPUT(IP1:IP1) = '<'
         OUTPUT(IP2:IP2) = '>'

         IGOQ            = IGOCSTRQ(ILEVEL)
         IENDQ           = IENDCSTRQ(ILEVEL)

         IF (IENDQ > IGOQ) THEN
C           SEARCH FOR THIS LOCAL VARIABLE
            IGOQ   = IGOCSTRQ(ILEVEL)
            IENDQ  = IENDCSTRQ(ILEVEL)
            CALL SYMPAR_FIND(ILEVEL,OUTPUT(IP1:IP2),ICVAR,IRTFLG)

            IF (ICVAR > 0) THEN
C              VARIABLE WAS FOUND
#ifdef DEBUGD
               write(6,*) ' ILEVEL: ',ILEVEL
               write(6,*) ' OUTPUT(IP1:IP2) :',OUTPUT(IP1:IP2)
               write(6,*) ' IENDCSTRQ(s):',(IENDCSTRQ(I),I=1,ILEVEL)
               write(6,*) ' ICVAR: ',ICVAR
#endif
               CVALUE   = CVARVALUES(ICVAR)
               LENVALUE = lnblnk(CVALUE)

#ifdef DEBUGD
               write(6,*) ' CVALUE: ',CVALUE(:LENVALUE)
               write(6,*) ' CSTRQ(1:50): ',CSTRQ(1:50)
#endif

C              COPY CORRESPONDING CSTRQ STRING TO OUTPUT & UPDATE NCHAR
               CALL SUBCHAR(CVALUE(:LENVALUE),OUTPUT,
     &                      IP1,IP2,NCHAR,IRTFLG)
            ENDIF
         ENDIF

         IF (IRTFLG .NE. 0 .AND. IENDCSTRQ(0) > 0) THEN
C           SEARCH FOR A GLOBAL VARIABLE
            IGOQ   = IGOCSTRQ(ILEVEL)
            IENDQ  = IENDCSTRQ(ILEVEL)
            CALL SYMPAR_FIND(0,OUTPUT(IP1:IP2),ICVAR,IRTFLG)

            IF (ICVAR > 0) THEN
C              FOUND A GLOBAL VARIABLE
#ifdef DEBUGD
               write(6,*) ' ILEVEL: ',ILEVEL
               write(6,*) ' OUTPUT(IP1:IP2) :',OUTPUT(IP1:IP2)
               write(6,*) ' IENDCSTRQ(s):',(IENDCSTRQ(I),I=1,ILEVEL)
               write(6,*) ' ICVAR: ',ICVAR
#endif

               CVALUE   = CVARVALUES(ICVAR)
               LENVALUE = lnblnk(CVALUE)

#ifdef DEBUGD
               write(6,*) ' CVALUE: ',CVALUE(:LENVALUE)
               write(6,*) ' CSTRQ(1:50): ',CSTRQ(1:50)
#endif
C              COPY CORRESPONDING CSTRQ STRING TO OUTPUT & UPDATE NCHAR
               CALL SUBCHAR(CVALUE(:LENVALUE),OUTPUT,
     &                      IP1,IP2,NCHAR,IRTFLG)
            ENDIF
        ENDIF

C        END OF SUBSTITUTION
         IP2N = IP2N + (IENDQ - IGOQ) - (IP2 - IP1)

         IF (ICVAR == 0) THEN
C           NO SUBSTITUTION, PROBABLY A REGISTER VARIABLE
            INOT          = INOT + 1
            DONOT(INOT)   = IP1
            INOT          = INOT + 1
            DONOT(INOT)   = IP2
         ENDIF

C        NEXT SEARCH IS OVER WHOLE STRING
         LENT  = NCHAR
         IDONE = IDONE + 1
         IF (IDONE > 100000) THEN
            CALL ERRT(102,'RECURSIVE VARIABLE ???? LOOPS',IDONE)
            RETURN
         ENDIF
         IF (DONOTRECURSE) EXIT       ! NON-RECURSIVE SUBSTITUTION
      ENDDO

C     END SYMBOL SUBSTITUTION 
c     write(6,*) ' in sub, now:',nchar,':',output(1:16)

C     FIX <> BEFORE RETURNING
      IF (INOT > 0) THEN
         DO IV=1,INOT,2
            I = DONOT(IV)
            IF (OUTPUT(I:I) == '<') THEN
               OUTPUT(I:I) = '['
            ELSE
               CALL ERRT(102,'LOCATION IS NOT <',I)
            ENDIF
            I = DONOT(IV+1)
            IF (OUTPUT(I:I) == '>') THEN
               OUTPUT(I:I) = ']'
            ELSE
               CALL ERRT(102,'LOCATION IS NOT >',I)
            ENDIF
         ENDDO
      ENDIF

C     SET NORMAL RETURN FLAG
      IRTFLG = 0

      END


C++*********************************************************************
C
C SYMPAR_REINIT                    NEW            OCT 2006 ARDEAN LEITH
C
C **********************************************************************
C
C    SYMPAR_REINIT()
C
C    PURPOSE:     RESIZES   CVAR SPACE   
C
C    PARAMETERS:  IRTFLG    ERROR FLAG                          (RET.)
C
C    YES, I KNOW THAT IT SHOULD BE WRITTEN USING POINTERS BUT
C    I DOUBT ANYONE WILL EVER USE THIS!! AL
C
C--*********************************************************************

      SUBROUTINE SYMPAR_REINIT(IRTFLG)

      USE SYMPAR_STUFF

      INCLUDE 'CMBLOCK.INC'
      CHARACTER(LEN=MAXCVAR_LEN), ALLOCATABLE, DIMENSION(:)::CVARVALUEST

      NCVAR     = NUMCVAR
      NCHARCVAR = MAXCSTRQ
      NCHAREACH = MAXCVAR_LEN

      WRITE(NOUT,90)NCVAR,NCHARCVAR,NCHAREACH  
90    FORMAT(' CURRENT NUMBER OF VARIABLES: ',I6,
     &       ' CHARACTERS FOR VARIABLE NAMES: ',I8,/,
     &       ' CHARACTERS / VARIABLE NAME: ',I4)
  
      CALL RDPRI1S(NCVARN,NOT_USED,
     &            'NUMBER OF VARIABLES WANTED',IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

      IF (NCVARN > NCVAR(MAXPRC)) THEN
         ALLOCATE (CVARVALUEST(NCVARN), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'UNABLE TO INCREASE VARIABLES:',NCVAR)
            RETURN
         ENDIF
              
         CVARVALUEST(1:NUMCVAR) = CVARVALUES
         DEALLOCATE(CVARVALUES)

         ALLOCATE (CVARVALUES(NCVARN), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'UNABLE TO INCREASE VARIABLES:',NCVARN)
            RETURN
         ENDIF

         CVARVALUES(1:NUMCVAR) = CVARVALUEST
         DEALLOCATE(CVARVALUEST)
         
         NUMCVAR = NCVARN
      ENDIF

      IRTFLG = 0
 
      END

C++*********************************************************************
C
C SYMPAR_GET_NUMS                    NEW            AUG 2006 ARDEAN LEITH
C
C **********************************************************************
C
C    SYMPAR_GET_NUMS(ICVARS,NCHAR)
C
C    PURPOSE:     RETRIEVE VAR INFO   
C
C    PARAMETERS:  ICVARS                              (RET.)
C                 NCHAR                               (RET.)
C
C
C--*******************************************************************

       SUBROUTINE SYMPAR_GET_NUMS(ICVARS,NCHAR)

       USE SYMPAR_STUFF

       ICVARS =  NUMCVARG  + NUMCVAR
       NCHAR  =  MAXCSTRQG + MAXCSTRQ

       END


C++*********************************************************************
C
C  ASSOCARRAY.F                NEW JUNE 2002               ARDEAN LEITH
C
C **********************************************************************
C
C  ASSOCARRAY(QSTRQ,QFIND,IGO,IEND,IRTFLG)
C
C  PURPOSE:     RETURN POSITION OF ASSOCIATED VARIABLE FOR QFIND IN QSTRQ
C               QFIND WILL BE SURROUNDED IN <>
C               QFIND WILL BE FOLLWED BY ASSOCIATED VARIABLE AND < 
C
C  PARAMETERS:  
C               QSTRQ                                             (SENT)
C               QFIND                                             (SENT)
C               IGO                                               (RET.)
C               IEND                                              (RET.)
C               IRTFLG                                            (RET.)
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE ASSOCARRAY(QSTRQ,QFIND,IGO,IEND,IRTFLG)

      CHARACTER(LEN=*), INTENT(IN)  :: QSTRQ,QFIND
      INTEGER, INTENT(OUT)          :: IGO,IEND,IRTFLG
      CHARACTER(LEN=1)              :: TAGEND

      IRTFLG = 1

C     FIND LENGTH OF SEARCH STRING
      LENFIND  = LEN(QFIND)
       
C     FIND STARTING LOCATION OF SEARCH STRING IN QSTRQ
      IGO = INDEX(QSTRQ,QFIND)

C     RETURN IF NO SEARCH STRING IN QSTRQ  xlf90 compiler bug hack
      IF (IGO <= 0) THEN
          IRTFLG = 1
          RETURN
      ENDIF

C     FIND START OF ASSOCIATED VALUE 
      IGO = IGO + LENFIND

C     FIND END OF ASSOCIATED VALUE
      TAGEND = '<' 
      IEND   = IGO + INDEX(QSTRQ(IGO:),TAGEND) - 2 

C     RETURN IF NO ASSOCIATED VALUE xlf90 compiler bug hack
      IF (IEND .LT. IGO) THEN
          IRTFLG = 1
          RETURN
      ENDIF

      IRTFLG = 0

      END


@


1.28
log
@==, detab
@
text
@d22 1
a22 1
C=* Email: spider@@wadsworth.org                                        *
@


1.27
log
@==
@
text
@a50 1

d107 1
a107 1
      CHARACTER(LEN=1)  :: NULL
d112 1
a112 2
      NULL = CHAR(0)
      IF (SYMPARID .EQ. NULL) THEN
d114 1
a114 1
	 CALL SYMPAR_INIT(IBANK,IRTFLG)
d122 1
a122 1
      IF (ICVAR .LE. 0) THEN
a130 1
      RETURN
d171 1
a171 1
      IF (IBANK .EQ. 0 .AND. ICVAR > NCVAR(IBANK)) THEN
a245 1
      RETURN
d309 1
a309 1
      IF (NUMCVAR .LE. 0) THEN
d327 1
a327 1
      IF (IBANK .EQ. 0) THEN
d334 1
a334 1
      ELSEIF (IBANK .EQ. 1) THEN
a353 1
      RETURN
d391 1
a391 1
      IF (IRTFLG .EQ. 1 .OR. ICVAR .LE. 0) THEN
d446 1
a446 1
         IF (IRTFLG .EQ. 0) THEN
a467 1
      RETURN
d527 1
a527 1
         IF (NCT .LE. 0) EXIT
d599 1
a599 1
         IF (ICVAR .EQ. 0) THEN
d624 1
a624 1
            IF (OUTPUT(I:I) .EQ. '<') THEN
d630 1
a630 1
            IF (OUTPUT(I:I) .EQ. '>') THEN
a704 1
      RETURN
d732 1
d770 1
a770 1
      IF (IGO .LE. 0) THEN
a789 1
      RETURN
@


1.26
log
@UNDEFINED VARS, IEND IGO NCHAR,NCHAREACH fixed
@
text
@d20 1
a20 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d174 1
a174 1
      IF (IBANK .EQ. 0 .AND. ICVAR .GT. NCVAR(IBANK)) THEN
d180 1
a180 1
      ELSEIF (ICVAR .GT. NCVAR(IBANK)) THEN
d201 1
a201 1
      IF (LENNAM .GT. 80) THEN
d307 1
a307 1
      ELSEIF (IBANK .GT. MAXPRC) THEN
d441 1
a441 1
      IF (IENDQ .GT. IGOQ) THEN
d546 1
a546 1
         IF (IENDQ .GT. IGOQ) THEN
d552 1
a552 1
            IF (ICVAR .GT. 0) THEN
d574 1
a574 1
         IF (IRTFLG .NE. 0 .AND. IENDCSTRQ(0) .GT. 0) THEN
d580 1
a580 1
            IF (ICVAR .GT. 0) THEN
d616 1
a616 1
         IF (IDONE .GT. 100000) THEN
d624 1
d627 1
a627 1
      IF (INOT .GT. 0) THEN
d687 1
a687 1
      IF (NCVARN .GT. NCVAR(MAXPRC)) THEN
@


1.25
log
@GPL_2010
@
text
@d14 1
d603 1
a603 1
         IP2N = IP2N + (IEND - IGO) - (IP2 - IP1)
d677 1
a677 1
      WRITE(NOUT,90)NCVAR,NCHAR,NCHAREACH  
d730 2
@


1.24
log
@SYMPAR_SUB, DONOTRECURSE  & issympar: IF (IRTFLG
@
text
@d16 1
d18 1
a18 1
C=* Author: J. Frank & A. Leith                                        *
d30 1
a30 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
@


1.23
log
@NCHAR IN SYMPAR_SUB
@
text
@d6 8
a13 6
C                 ?<ANYTHING? BUG          FEB 2002 ARDEAN LEITH
C                 REWRITTEN                JUN 2002 ARDEAN LEITH
C                 [] DEFAULT FOR VARIABLES OCT 2005 ARDEAN LEITH
C                 GLOBAL DUPLICATES OK     FEB 2006 ARDEAN LEITH
C                 CVAR                     OCT 2006 ARDEAN LEITH
C                 NCHAR IN SYMPAR_SUB      NOV 2009 ARDEAN LEITH
d16 3
a18 4
C=*                                                                    *
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
a30 1
C=*                                                                    *
d394 1
a394 1
      IF (IRTFLG .EQ. 0 .AND. ICVAR .LE. 0) THEN
d445 2
a446 2
         write(6,*) ' HUNTING: ', NAMET(1:LENT)
         write(6,*) ' IN: ',      CSTRQ(IGOQ:IENDQ)
d459 6
a464 1
            write(6,*) ' INTEGERIZED VAR. NUM: ', ICVAR
d478 1
a478 1
C  SYMPAR_SUB.F -- CREATED 9/8/00 FROM SPIDER.F      ARDEAN LEITH 
d480 5
a484 4
C                 ALPHABETICAL VARIABLES JUNE 2002         ARDEAN LEITH
C                 NESTED VARIABLES SEPT 2002               ARDEAN LEITH
C                 [] DEFAULT FOR VARIABLES OCT 2005        ARDEAN LEITH
C                 CVAR                     OCT 2006        ARDEAN LEITH
d488 1
a488 1
C    SYMPAR_SUB(INPUT,OUTPUT,NCHAR,ILEVELT,IRTFLG)
d502 2
a503 1
      SUBROUTINE SYMPAR_SUB(INPUT,OUTPUT,NCHAR,ILEVEL,IRTFLG)
d513 1
d618 1
@


1.22
log
@added issympar routine
@
text
@d11 2
a13 5
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 5
a19 1
C=* Email:  spider@@wadsworth.org                                       *
d21 1
a21 1
C=* This program is free software; you can redistribute it and/or      *
d26 1
a26 1
C=* This program is distributed in the hope that it will be useful,    *
d32 1
a32 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d219 1
a219 1
#ifdef DEBUG
d237 1
a237 1
#ifdef DEBUG
d350 1
a350 1
#ifdef DEBUG
d444 1
a444 1
#ifdef DEBUG
d451 1
a451 1
#ifdef DEBUG
d458 1
a458 1
#ifdef DEBUG
d510 2
d544 1
a544 1
#ifdef DEBUG
d553 1
a553 1
#ifdef DEBUG
d572 1
a572 1
#ifdef DEBUG
d582 1
a582 1
#ifdef DEBUG
@


1.21
log
@xlf90 compiler bug hack
@
text
@d2 1
d84 15
d360 44
@


1.20
log
@cvar variables
@
text
@d700 5
a704 2
C     RETURN IF NO SEARCH STRING IN QSTRQ
      IF (IGO .LE. 0) RETURN
d713 5
a717 2
C     RETURN IF NO ASSOCIATED VALUE 
      IF (IEND .LT. IGO) RETURN
@


1.19
log
@GLOBAL DUPLICATES OK
@
text
@d9 1
d38 1
a38 1
C    PURPOSE:       RECORD VARIABLES
d40 1
a40 1
C    PARAMETERS:    SYMPARID   ID                              (SENT)
d48 36
d86 1
a86 11
      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      CHARACTER(LEN=*) ::       SYMPARID,SYMPARVAL
      CHARACTER(LEN=MAXNAM) ::  CORRECT
      LOGICAL ::                LOCAL
      CHARACTER(LEN=1) ::       NULL

C     FOR LOCAL VARIABLE HANDLING 
      INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK,IPARNUM
      COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,IPSTACK,
d89 3
a91 5
      INTEGER, DIMENSION (MAXPRC) :: IGOQSTR,IENDQSTR,NREGSTR
      COMMON /QSTR_STUFF2/IGOQSTR,IENDQSTR,NREGSTR

      CHARACTER(LEN=MAXQSTR):: QSTRQ
      COMMON /QSTR_STUFF3/ QSTRQ
d93 2
a94 2
C     FOR GLOBAL VARIABLE HANDLING 
      COMMON /QSTR_STUFF4/IENDQSTRG
d98 40
a137 5
C        SET INITIAL LOCAL VARIABLE INFO 
	 IGOQSTR(ISTOP)  = 1
         IENDQSTR(ISTOP) = 0
         IPARNUM(ISTOP)  = 0
         NREGSTR(ISTOP)  = 10
d139 11
a149 4
         IF (ISTOP .GT. 1) THEN
            IGOQSTR(ISTOP)  = IENDQSTR(ISTOP-1) + 1 
            IENDQSTR(ISTOP) = IENDQSTR(ISTOP-1)
         ENDIF
d151 2
a152 2
C        SET INITIAL GLOBAL VARIABLE INFO 
         IF (ISTOP .LE. 1) IENDQSTRG = 0
d154 7
a160 1
         IRTFLG          = 0
d163 13
a175 3
      ELSEIF (.NOT. LOCAL) THEN
C        SET GLOBAL VARIABLE
         CALL SETSYMPARG(SYMPARID,SYMPARVAL,IRTFLG)
d179 12
a190 7
C     SEARCH FOR PRE-EXISTING SYMBOL
      IGOQT  = IGOQSTR(ISTOP) 
      IENDQT = IENDQSTR(ISTOP) 
      
      CALL ASSOCARRAY(QSTRQ(IGOQT:IENDQT),SYMPARID,IGOT,IENDT,IRTFLG)
      IF (IGOT .GT. 0) THEN
         CALL ERRT(101,'SYMBOL ALREADY EXISTS',NE)
d194 7
a200 8
C     PLACE VARIABLE STRING IN QSTRQA ARRAY
      IENDQAT = IENDQSTR(ISTOP) + 2 * LEN(SYMPARID) + LEN(SYMPARVAL)+1
 
C     MAXQSTR IS IN CMLIMIT.INC
      IF (IENDQAT .GE. MAXQSTR) THEN
C        OVER-RUN OF QSTRQ ARRAY
         CALL ERRT(102,'QSTRQ OVERFLOW IN SETSYMPAR',IENDQAT)
         IRTFLG = 1
a202 6
     
C     FIND START FOR NEW VARIABLE IN QSTRQ
      IGOQ            = IENDQSTR(ISTOP) + 1
      QSTRQ(IGOQ:)    = SYMPARID // SYMPARVAL // '</' // SYMPARID(2:)  
      IENDQSTR(ISTOP) = IGOQ + LEN(SYMPARID) + LEN(SYMPARVAL) + 2 +
     &                         LEN(SYMPARID) - 1 
d204 13
a216 1
      IRTFLG          = 0
d218 13
d235 103
a337 7
#ifdef NEVER
      write(6,*) ' '
      write(6,*) 'igoq: ',igoq
      write(6,*) 'istop: ',istop,'  : ',symparid,symparval
      write(6,*) 'igoqstr: ',(igoqstr(i),i=1,istop)
      write(6,*) 'iendqstr:',(iendqstr(i),i=1,istop)
      write(6,*) 'qstrq(1:70): ',qstrq(1:70)
d339 24
d364 1
d366 2
d369 71
a439 1
      SUBROUTINE SETSYMPARG(SYMPARID,SYMPARVAL,IRTFLG)
a441 1
      INCLUDE 'CMLIMIT.INC'
d443 53
a495 1
      CHARACTER(LEN=*) ::   SYMPARID,SYMPARVAL
d497 53
a549 2
C     FOR VARIABLE HANDLING 
      COMMON /QSTR_STUFF4/IENDQSTRG
d551 1
a551 2
      CHARACTER(LEN=MAXQSTRG):: QSTRQG
      COMMON /QSTR_STUFF5/ QSTRQG
d553 16
a568 7
C     SEARCH FOR PRE-EXISTING SYMBOL
      CALL ASSOCARRAY(QSTRQG(1:IENDQSTRG),SYMPARID,IGOT,IENDT,IRTFLG)
      IF (IGOT .GT. 0) THEN
         WRITE(NOUT,*) ' *** THIS GLOBAL SYMBOL ALREADY EXISTS, IGNORED'
CC         CALL ERRT(101,'GLOBAL SYMBOL ALREADY EXISTS',NE) feb 06 al
           IRTFLG = 0
           RETURN
d571 66
a636 3
C     PLACE VARIABLE STRING IN QSTRQG ARRAY
      IENDQAT = IENDQSTRG + LEN(SYMPARID) + LEN(SYMPARVAL) + 2 + 
     &                      LEN(SYMPARID) - 1  
d638 74
a711 19
C     MAXQSTRG IS IN CMLIMIT.INC
      IF (IENDQAT .GE. MAXQSTRG) THEN
C        OVER-RUN OF QSTRQG ARRAY
         CALL ERRT(102,'QSTRQG OVERFLOW IN SETSYMPARG',IENDQAT)
         IRTFLG = 1
         RETURN
      ENDIF
     
C     FIND START FOR NEW VARIABLE IN QSTRQ
      IGOQG            = IENDQSTRG + 1
      QSTRQG(IGOQG:)   = SYMPARID // SYMPARVAL // '</' // SYMPARID(2:) 
      IENDQSTRG        = IENDQAT

#ifdef NEVER
      write(6,*) ' '
      write(6,*) 'igoqg: ',igoqg,'iendqstrg:',iendqstrg
      write(6,*) 'id & value : ',symparid,symparval
      write(6,*) 'qstrqg(1:50): ',qstrqg(1:50)
#endif
d714 1
d717 2
@


1.18
log
@native named registers
@
text
@d7 2
a8 2
C                 [] DEFAULT FOR VARIABLES OCT 2005  ARDEAN LEITH
C
d156 4
a159 2
         CALL ERRT(101,'GLOBAL SYMBOL ALREADY EXISTS',NE)
         RETURN
@


1.17
log
@named register support
@
text
@d96 10
d153 7
@


1.16
log
@GPL License fixed
@
text
@d7 1
d37 1
a37 1
C    PURPOSE:       RECORD SYMBOLIC PARAMETERS
d57 1
a57 1
C     FOR LOCAL SYMBOLIC PARAMETER HANDLING 
d62 2
a63 2
      INTEGER, DIMENSION (MAXPRC) :: IGOQSTR,IENDQSTR
      COMMON /QSTR_STUFF2/IGOQSTR,IENDQSTR
d68 1
a68 1
C     FOR GLOBAL SYMBOLIC PARAMETER HANDLING 
d73 1
a73 1
C        SET INITIAL LOCAL SYMBOLIC PARAMETER INFO 
d77 1
d84 1
a84 1
C        SET INITIAL GLOBAL SYMBOLIC PARAMETER INFO 
d91 1
a91 1
C        SET GLOBAL SYMBOLIC PARAMETER
d96 1
a96 1
C     PLACE ALPHABETIC SYMBOLIC PARAMETER STRING IN QSTRQA ARRAY
d107 1
a107 1
C     FIND START FOR NEW SYMBOLIC PARAMETER IN QSTRQ
d137 1
a137 1
C     FOR SYMBOLIC PARAMETER HANDLING 
d143 1
a143 1
C     PLACE ALPHABETIC SYMBOLIC PARAMETER STRING IN QSTRQG ARRAY
d155 1
a155 1
C     FIND START FOR NEW SYMBOLIC PARAMETER IN QSTRQ
@


1.15
log
@NLOG
@
text
@d2 1
a2 1
C++*************************************************************************
d9 23
a31 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.14
log
@iparnum
@
text
@d41 1
a41 1
      COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,NLOG,IPSTACK,
@


1.13
log
@*** empty log message ***
@
text
@d40 1
a40 1
      INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK
d42 1
a42 1
     &                     IPNUMSTACK
d58 1
@


1.12
log
@debug output removed
@
text
@d80 1
a80 1
      IF (IENDQAT .GE. MAXQSTRG) THEN
d127 2
a128 2
C     MAXQSTR IS IN CMLIMIT.INC
      IF (IENDQAT .GE. MAXQSTR) THEN
@


1.11
log
@rewritten
@
text
@d140 1
d145 1
@


1.10
log
@bad ip1 == ip2 fixed
@
text
@a1 1

d6 1
d17 1
a17 1
C    SETSYMPAR(FRPROMPT,RESPONSE,NCHAR,IRTFLG)
d19 1
a19 1
C    PURPOSE:       RUN-TIME SYMBOLIC SUBSTITUTION
d21 4
a24 5
C    PARAMETERS:    FRPROMPT  INPUT PROMPT                (SENT)
C                   RESPONSE  RESPONSE                    (RET.)
C                   NCHAR     LAST NON_BLANK CHAR IN      (RET.)
C                             RESPONSE BEFORE COMMENT
C                   IRTFLG    RETURN FLAG (0 IS NORMAL)   (RETURNED)
d29 1
a29 1
      SUBROUTINE SETSYMPAR(FRPROMPT,RESPONSE,NCHAR,IRTFLG)
d34 4
a37 3
      CHARACTER(LEN=*) ::   FRPROMPT,RESPONSE
      LOGICAL  ::           ISDIGI,LOCAL,USEBANKREG
      REAL, DIMENSION(7) :: FREGST(7)
d39 1
a39 1
C     FOR SYMBOLIC PARAMETER HANDLING 
d44 5
a48 16
      INTEGER, DIMENSION (NQSTRSIZ,MAXPRC) :: IGOQSTRSTK,IENDQSTRSTK
      INTEGER, DIMENSION (MAXPRC) ::          NQSTRNOWSTK,LENQSTRSTK
      COMMON /QSTR_STUFF2/IGOQSTRSTK,IENDQSTRSTK,
     &                    NQSTRNOWSTK,LENQSTRSTK

      CHARACTER(LEN=MAXQSTR), DIMENSION((MAXPRC)) :: QSTRQSTK
      COMMON /QSTR_STUFF3/ QSTRQSTK

      IF (FRPROMPT .EQ. CHAR(0)) THEN
C        SET INITIAL SYMBOLIC PARAMETER INFO 
	 LENQSTRSTK(ISTOP)  = 0
         NQSTRNOWSTK(ISTOP) = 0
         QSTRQSTK(ISTOP)    = ' '
         IRTFLG             = 0
         RETURN
      ENDIF
d50 2
a51 2
C     'FR L' IS FOR LOCAL SETTING OF PARAMETERS WITHIN A PROCEDURE
      LOCAL = (FCHAR .EQ. 'FR L') 
d53 9
a61 23
C     GET RESPONSE TO ?---? FRPROMPT
      IF ((.NOT. FROMBATCH .AND. .NOT. LOCAL) .OR.
     &    (LOCAL .AND. ISTOP .EQ. 1)) THEN
C        CAME FROM INTERACTIVE MODE, WRITE OUT ?---? AS FRPROMPT
         WRITE(ITI,2330)  FRPROMPT
2330     FORMAT('$',A)
         READ(ITIN,90) RESPONSE
90       FORMAT(A)

      ELSE
C        NOT FROM INTERACTIVE MODE
C        GET RESPONSE TO ?---? FRPROMPT, FROM PROCEDURE FILE

         IF (LOCAL) THEN
             WRITE(NOUT,91)  FRPROMPT
91           FORMAT(A)
             IBCNT = IBCNT + 1
             CALL PROC_GETPLINE(IBCNT,IPNUMSTACK(ISTOP),RESPONSE,
     &                         NCHAR,IRTFLG)
         ELSE
            IWHERE = IWHERE + 1
            CALL PROC_GETPLINE(IWHERE,IPNUMSTACK(ISTOP-1),RESPONSE,
     &                         NCHAR,IRTFLG)
d64 2
a65 2
C        SAVE IWHERE FOR FURTHER READS
         IPSTACK(ISTOP) = IWHERE
d67 2
a68 38
      ENDIF

C     FIND LAST NON-BLANK IN RESPONSE BEFORE COMMENT
      CALL DECOMMENT(RESPONSE,NCHAR,LOCSEMI)

C     STRIP COMMENT FROM RESPONSE          
      RESPONSE(NCHAR+1:) = ' '

C     RESPONSE MAY CONTAIN PARAMETER SUBSTITUTION FROM HIGHER PROCS.
      ILEVEL = ISTOP - 1
      DO 
        IF (ILEVEL .LE. 0) EXIT

C       FIND START AND END OF PARAMETER STRING IN RESPONSE 
        IP1 = INDEX(RESPONSE(1:NCHAR),'<')
      
        IF (IP1 .LE. 0 .OR. .NOT. ISDIGI(RESPONSE(IP1+1:IP1+1))) EXIT
C       '<' AND DIGIT => NEED RUN-TIME SYMBOLIC SUBSTITUTION E.G. <1>
        CALL SUBSYMPAR(RESPONSE(1:NCHAR),RESPONSE,NCHAR,ILEVEL,IRTFLG)

        ILEVEL = ILEVEL - 1

      ENDDO

      NSUB = 0
      IF (RESPONSE(:1) .EQ. 'X' .OR. RESPONSE(2:2) .EQ. 'X' .OR.
     &    RESPONSE(:1) .EQ. 'x' .OR. RESPONSE(2:2) .EQ. 'x') THEN
C         ADDED 11/8/79 FOR  QUESTION ANSWERED WITH A REGISTER

         CALL CHKSTR(RESPONSE,NCHAR,'RE',IDUM,FREGST,7,INUM,IRTFLG)
         IF (IRTFLG .NE. 0) CALL ERRT(101,'ERROR IN REGISTER SUB.',NE)

C        FIX PRECISION ERROR HERE!!!!!
         ITEMP = MIN(INUM,6)
         WRITE(RESPONSE(1:80),2621) (FREGST(I),I=1,ITEMP)
2621     FORMAT(6(1PG12.5,' '))
         NCHAR            = INUM * 13 + 1
         RESPONSE(NCHAR:) = ' '
d71 3
a73 54
C        MAY WANT TO SUBSTITUTE. FOR REGS, SEE IF NEW STYLE SUB.

         CALL CHARINSIDE(RESPONSE(1:NCHAR),'{','}',.TRUE.,.FALSE., 
     &                     IGOSUB,IENDSUB,NSUB)

C        ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REG

         IF ((NCHAR .GE. 2 .AND. ISDIGI(RESPONSE(NCHAR:NCHAR))).AND. 
     &       (RESPONSE(NCHAR-1:NCHAR-1) .EQ. 'X'  .OR. 
     &        RESPONSE(NCHAR-1:NCHAR-1) .EQ. 'x')) THEN
C           OLD STYLE X? REG. SUBSTITUTION AT END OF FILE NAME
            RESPONSE = RESPONSE(1:NCHAR-2) // '000{---' // 
     &                 RESPONSE(NCHAR-1:NCHAR) // '}'
            NCHAR  = NCHAR + 8
            NSUB   = 1

         ELSEIF((NCHAR .GE. 3 .AND. 
     &           ISDIGI(RESPONSE(NCHAR:NCHAR))).AND.
     &          (RESPONSE(NCHAR-2:NCHAR-2) .EQ. 'X'  .OR. 
     &           RESPONSE(NCHAR-2:NCHAR-2) .EQ. 'x') .AND.
     &           ISDIGI(RESPONSE(NCHAR-1:NCHAR-1))) THEN
C           OLD STYLE X?? REG. SUBSTITUTION AT END OF FILE NAME
            RESPONSE = RESPONSE(1:NCHAR-3) // '000{---' //
     &                 RESPONSE(NCHAR-2:NCHAR) // '}' 
            NCHAR = NCHAR + 8
            NSUB  = 1
         ENDIF
      ENDIF

      IF (NSUB .GT. 0) THEN
C        HAVE EITHER OLD OR NEW STYLE REGISTER SUBSTITUTION

C        PASS THE CURRENT REGISTER (PARAM) SET TO FILNAMSUB
C        SUBSTITUTE FOR {+++X??} OR {---X??} IN RESPONSE STRING
C        WILL STOP IN ERRT IN FILNAMSUB IF THERE IS AN ERROR
         USEBANKREG = .NOT. LOCAL
         CALL FILNAMSUB(RESPONSE,NCHAR,USEBANKREG,ISTOP,IRTFLG)
      ENDIF


C     FIND START AND END OF PARAMETER STRING IN INPUT (IF ANY)
      CALL CHARINSIDE(FRPROMPT,'<','>',.TRUE.,.TRUE.,IP1,IP2,NCM1)

      IF (IP1 .LE. 0 .OR. IP2 .LT. IP1) THEN  
C        NO <#> IN QUERY STRING, INVENT ONE FROM NQSTRNOW
         NQSTR = NQSTRNOWSTK(ISTOP) + 1
      ELSE
C        <#> IS AVAILABLE IN QUERY STRING
         READ(FRPROMPT(IP1:IP2),93,IOSTAT=IRTFLG) NQSTR
93       FORMAT(I10)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(101,'UNABLE TO READ PARAMETER NUMBER',NDUM)
            RETURN
         ENDIF
d76 5
a80 6
      IF ((LENQSTRSTK(ISTOP) + NCHAR) .GT. MAXQSTR) THEN
C        OVER-RUN OF QSTRQ ARRAY
         CALL ERRT(30,'SPIDER',NE)
         IRTFLG = 1
         RETURN
      ELSEIF (NQSTR .GE. NQSTRSIZ) THEN
d82 1
a82 2
         CALL ERRT(102,'NQSTRSIZ OVERFLOW OF SYMBOLIC PARAMETERS',
     &                NQSTR)
d86 6
d93 1
a93 8
C     PLACE SYMBOLIC PARAMETER STRING IN Q ARRAY
      IGOQSTRSTK(NQSTR,ISTOP)  = LENQSTRSTK(ISTOP) + 1
      LENQSTRSTK(ISTOP)        = LENQSTRSTK(ISTOP) + NCHAR 
      IENDQSTRSTK(NQSTR,ISTOP) = LENQSTRSTK(ISTOP)
      QSTRQSTK(ISTOP)
     &        (IGOQSTRSTK(NQSTR,ISTOP):IENDQSTRSTK(NQSTR,ISTOP)) =
     &        RESPONSE(1:NCHAR)
      IF (NQSTR .GT. NQSTRNOWSTK(ISTOP)) NQSTRNOWSTK(ISTOP) = NQSTR
a94 1
      IRTFLG = 0
d99 8
a106 1
C      *********************** DECOMMENT ********************************
a107 1
       SUBROUTINE DECOMMENT(CINPUT,NCHAROUT,LOCSEMI)
a108 1
C      FINDS LOCATION OF COMMENT AND ANY TRAILING BLANKS BEFORE COMMENT
d110 1
a110 1
       CHARACTER *(*) CINPUT
d112 2
a113 2
C      IGNORE SEMICOLON DENOTED COMMENT AT END OF CINPUT STRING
       LOCSEMI = INDEX(CINPUT,';')
d115 1
a115 2
       IF (LOCSEMI .LE. 0) THEN
          NCHAROUT = LNBLNKN(CINPUT)
d117 2
a118 2
       ELSEIF (LOCSEMI .EQ. 1) THEN
          NCHAROUT = 0
d120 2
a121 6
       ELSEIF (LOCSEMI .GT. 1) THEN
C         STRIP COMMENT & TRAILING BLANKS
          NCHAROUT = LNBLNKN(CINPUT(1:LOCSEMI-1))
       ENDIF
       RETURN
       END
d123 21
d145 3
a147 1

@


1.9
log
@< bug fixed
@
text
@d175 1
a175 1
      IF (IP1 .LE. 0 .OR. IP2 .LE. IP1) THEN  
@


1.8
log
@changed local register binding time
@
text
@d5 2
a6 1
C  SETSYMPAR.F -- CREATED 2/20/01 FROM SPIDER.F             ARDEAN LEITH 
d173 1
a173 2
      CALL CHARINSIDE(FRPROMPT,'<','>',.TRUE.,.FALSE.,
     &                IP1,IP2,NCM1)
d175 1
a175 1
      IF (IP1 .LE. 0) THEN  
@


1.7
log
@*** empty log message ***
@
text
@d115 1
d130 1
a130 1
      ELSE
@


1.6
log
@ comment handling improved
@
text
@d109 1
a109 1
        CALL SUBSYMPAR(RESPONSE,NCHAR,ILEVEL,IRTFLG)
@


1.5
log
@used banked reg on local bug fixed
@
text
@a71 3
C        FIND LAST NON-BLANK IN RESPONSE BEFORE COMMENT
         CALL DECOMMENT(RESPONSE,NCHAR,LOCSEMI)           
         
a90 2
C        FIND LAST NON-BLANK IN RESPONSE BEFORE COMMENT
         CALL DECOMMENT(RESPONSE(1:NCHAR),NCHAR,LOCSEMI)           
d92 5
d109 1
a109 1
        CALL SUBSYMPAR(RESPONSE,LOCSEMI,NCHAR,ILEVEL,IRTFLG)
d218 1
a218 1
C      REMOVES COMMENT AND ANY TRAILING BLANKS
a221 2
       NCHAROUT = LNBLNKN(CINPUT)

d225 4
a228 1
       IF (LOCSEMI .EQ. 1) THEN
@


1.4
log
@FROMBATCH, defined also in CMBLOCK
@
text
@d35 1
a35 1
      LOGICAL  ::           ISDIGI,LOCAL
d165 2
a166 1
         CALL FILNAMSUB(RESPONSE,NCHAR,.TRUE.,ISTOP,IRTFLG)
@


1.3
log
@'FR L' changes for local
@
text
@d35 1
a35 1
      LOGICAL  ::           ISDIGI,FROMBATCH,LOCAL
@


1.2
log
@comment added
@
text
@d35 1
a35 1
      LOGICAL  ::           ISDIGI,FROMBATCH
d60 2
d64 2
a65 1
      IF (.NOT. FROMBATCH) THEN
d78 12
a89 3
         IWHERE = IWHERE + 1
         CALL PROC_GETPLINE(IWHERE,IPNUMSTACK(ISTOP-1),RESPONSE,
     &                      NCHAR,IRTFLG)
@


1.1
log
@Initial revision
@
text
@d21 1
a21 1
C                   RESPONSE  RESPONSE                    (SENT)
@
