head	1.42;
access;
symbols
	pre_getangas:1.42
	GPL2010:1.42
	pre_GPL2010:1.41
	pre_var_equation:1.41
	pre_fftwrings:1.41
	pre_opfiles:1.34
	src:1.34
	best-code:1.34
	x-named-regs:1.34
	x:1.34
	v13-00:1.34
	pre_GPL:1.32
	prec_CA:1.24
	noindx:1.21
	Bproc:1.20
	oct21:1.3
	last77:1.3;
locks; strict;
comment	@c @;


1.42
date	2010.06.24.13.25.42;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2008.03.07.20.10.47;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2008.02.29.13.12.18;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2008.02.22.16.54.03;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2008.01.24.15.55.30;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2007.12.20.19.28.33;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2007.12.17.15.22.40;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.12.15.55.37;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2005.10.17.20.14.56;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.17.18.08.32;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.02.19.49.18;	author bimal;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.13.20.23.16;	author bimal;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.11.22.10.20;	author bimal;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.09.19.33.22;	author bimal;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.04.18.37.04;	author bimal;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.24.18.28.16;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.27.18.07.55;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.27.18.00.05;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.04.17.49.08;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.30.18.03.00;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.13.14.25.11;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2002.11.04.18.50.40;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.18.19.05.04;	author bimal;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.17.21.04.27;	author bimal;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.17.20.56.28;	author bimal;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.17.18.51.06;	author bimal;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.17.18.23.03;	author bimal;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.11.16.45.52;	author bimal;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.11.16.01.11;	author bimal;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.24.19.48.29;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.24.17.27.53;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.24.17.25.41;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.28.20.47.37;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.28.20.08.58;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.28.20.01.09;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.16.15.07.12;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	99.11.24.15.04.26;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	99.11.10.23.09.19;	author yuchen;	state Exp;
branches;
next	1.4;

1.4
date	99.11.05.15.01.28;	author bimal;	state Exp;
branches;
next	1.3;

1.3
date	98.02.20.16.10.10;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	97.07.24.20.01.12;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	96.08.27.13.49.25;	author pawel;	state Exp;
branches;
next	;


desc
@2D simple fft, calling program
@


1.42
log
@GPL_2010
@
text
@

C++*********************************************************************
C
C FMRS_2.F                       ADDED FFTW        FEB 2000 ARDEAN LEITH
C                                FFTW3 REACTIVATED DEC 2007 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  FMRS_2(X,NSAM,NROW,INV)
C
C  PARAMETERS:     X       ARRAY                              SENT/RET.
C                  INV     1=REG. FILE, -1= FOURIER FILE       SENT
C
C  D REAL MIXED RADIX FFT.
C  INPUT:  X(N) - REAL ARRAY
C  OUTPUT: N EVEN  X(N+2)
C  ORDER OF ELEMENTS:
C  R(0),0.0, R(1), I(1), R(2), I(2), ....., R(N/2-1), I(N/2-1), R(N/2),0.0
C
C         N ODD  X(N+1)
C  R(0),0.0, R(1), I(1), R(2), I(2), ....., R(N/2-1), I(N/2-1), R(N/2),I(N/2)
C 
C  HERE WE FOLLOW THE CONVENTION THAT INTEGER DIVISION 
C  IS ROUNDED DOWN, E.G. 5/2 =2)
C
C  INV: +1 FORWARD FFT
C       -1 INVERSE FFT
C
C  ON OUTPUT INV=0 MAY INDICATE ERROR (NOT GUARANTEED ANYMORE)!!!
C
C--*********************************************************************

	SUBROUTINE FMRS_2(X,NSAM,NROW,INV)

        INTEGER, INTENT(INOUT) :: INV
        REAL, INTENT(INOUT) :: X(*)

        CALL FMRS(X,NSAM,NROW,1, 0.0D0, .TRUE.,.TRUE.,INV,IRTFLG)

        IF (IRTFLG .NE. 0) INV = 0

        END


@


1.41
log
@removed docalc from fmrs call
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.40
log
@docalc parameter for fmrs
@
text
@d62 1
a62 1
        CALL FMRS(X,NSAM,NROW,1, 0.0D0, .TRUE.,.TRUE.,.TRUE.,INV,IRTFLG)
@


1.39
log
@added plan to fmrs call
@
text
@d62 1
a62 1
        CALL FMRS(X,NSAM,NROW,1,0.0D0, .TRUE.,.TRUE.,INV,IRTFLG)
@


1.38
log
@calls fmrs
@
text
@d62 1
a62 1
        CALL FMRS(X,NSAM,NROW,1,.TRUE.,.TRUE.,INV,IRTFLG)
@


1.37
log
@bad ifdef
@
text
@d9 1
a9 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d38 17
d57 8
a64 1
	SUBROUTINE  FMRS_2(X,NSAM,NROW,INV)
d66 1
a66 2
        INCLUDE 'CMBLOCK.INC'
	DIMENSION  X(*)
a67 44
#if defined (SP_LIBFFTW)
C       USING FFTW2 LIBRARY CALLS FOR FFT ----------------------- FFTW2
        CALL ERRT(101,'FFTW2 NO LONGER IN USE, DEFINE SP_LIBFFTW3',IER)
        RETURN
#endif

#ifdef SP_LIBFFT
C       USING SGI_COMPLIB FOR FFT --------------------------------- SGI

	INTEGER, SAVE :: NSAMO=0,NROWO=0
	REAL, DIMENSION(:), POINTER, SAVE :: COEFF

	IF (NSAM.NE.NSAMO .OR. NROW.NE.NROWO) THEN
C          SIZE CHANGED MUST REESTABLISH COEFFICIENTS
	   IF (ASSOCIATED(COEFF))  DEALLOCATE(COEFF)
	   ALLOCATE(COEFF(NSAM+15+2*(NROW+15)),STAT=IRTFLG)
	   IF (IRTFLG.NE.0) CALL ERRT(46,'FT 2, COEFF',IER)

	   CALL SCFFT2DUI(NSAM,NROW,COEFF)
	   NSAMO = NSAM
	   NROWO = NROW
	ENDIF
	LDA = NSAM+2-MOD(NSAM,2)
	IF (INV .GT. 0)  THEN
	   CALL  SCFFT2DU(INV,NSAM,NROW,X,LDA,COEFF)
	ELSE
	   CALL  CSFFT2DU(INV,NSAM,NROW,X,LDA,COEFF)
	   CALL  SSCAL2D(NSAM,NROW,(1.0/FLOAT(NSAM)/FLOAT(NROW)),X,LDA)
	ENDIF
#else

#if defined (SP_LIBFFTW3)
C       USING FFTW3 LIBRARY CALLS FOR FFT ----------------------- FFTW3
        CALL FMRS_FFTW3(X,NSAM,NROW,1,INV)
#else
C       NATIVE SPIDER FFT  (SUB-OPTIMAL) ----------------------- SPIDER

C       HAVE TO CHANGE NSAM
	LDA = NSAM+2-MOD(NSAM,2)

        CALL FMRS_2R(X,LDA,NSAM,NROW,INV)
#endif
#endif
	END
@


1.36
log
@removed fftw2
@
text
@d45 6
a79 5
C       USING FFTW2 LIBRARY CALLS FOR FFT ----------------------- FFTW2
        CALL ERRT(101,'FFTW2 NO LONGER IN USE, DEFINE SP_LIBFFTW3',IER)

#else

a87 1
#endif
@


1.35
log
@split out fmrs_fftw3
@
text
@d74 2
a75 141


#if defined(SP_LIBFFTW) || defined(SP_LIBFFTWMP)
C       USING FFTW LIBRARY CALLS FOR FFT ------------------------ FFTW

#include "FFTW.INC"

	INTEGER, SAVE :: NSAMO=0,  NROWO=0
	INTEGER, SAVE :: NSAMOR=0, NROWOR=0
	LOGICAL, SAVE :: INIT=.TRUE.

C       PLAN AND PLANR ARE ACTUALLY POINTERS TO A STRUCTURE 
#if defined (__osf__) || defined (ia64) || defined (__x86_64__)
        INTEGER*8, SAVE :: PLAN=0, PLANR=0
#else
        INTEGER, SAVE :: PLAN=0, PLANR=0
#endif

#ifdef SP_LIBFFTWMP

C       FOR OMP (MULTIPLE PROCESSORS) FFTW
        IF (INIT) THEN
C          MUST INITIALIZE THREADS ONCE
           CALL FFTW_F77_THREADS_INIT(IRTFLG);
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(101,'MULTIPLE THREADS FAILED',IER)
              RETURN
           ENDIF
           INIT = .FALSE.
        ENDIF
        CALL GETTHREADS(NUMTH)

#else
C       FOR SINGLE PROCESSOR WITH FFTW
        NUMTH = 1
#endif
C        WRITE(NOUT,90) NUMTH
C90      FORMAT('USING FFTW WITH THREADS: ',i4)

        IF (INV .GT. 0) THEN
C          FORWARD TRANSFORM

	   IF (NSAM.NE.NSAMO .OR. NROW.NE.NROWO) THEN
C             SIZE CHANGED, REESTABLISH PLAN

              IF (PLAN .GT. 0) CALL FFTWND_F77_DESTROY_PLAN(PLAN)

#ifdef SP_LIBFFTWMP
C             FOR OMP (MULTIPLE PROCESSORS)
              CALL RFFTW2D_F77_CREATE_PLAN(PLAN,NSAM,NROW,
     &              FFTW_FORWARD, FFTW_ESTIMATE + FFTW_IN_PLACE +
     &                    FFTW_THREADSAFE)
#else
C             FOR SINGLE PROCESSOR
              CALL RFFTW2D_F77_CREATE_PLAN(PLAN,NSAM,NROW,
     &              FFTW_FORWARD, FFTW_ESTIMATE + FFTW_IN_PLACE)
#endif
           ENDIF

#ifdef SP_LIBFFTWMP
C           FOR OMP (MULTIPLE PROCESSORS)
#if defined (sgi) || (defined (__linux__) && !defined (SP_IFC))
C           SGI & PGI DOES NOT LIKE OBJECT NAMES > 31 CHAR
            CALL RFFTWND_F77_THREADS_ONE_R_TO_C(NUMTH,PLAN,X,0)
#else
            CALL RFFTWND_F77_THREADS_ONE_REAL_TO_COMPLEX(NUMTH,PLAN,X,0)
#endif
#else
C          FOR SINGLE PROCESSOR
           CALL RFFTWND_F77_ONE_REAL_TO_COMPLEX(PLAN,X,0)
#endif

C          CHANGE FFTW FORMAT TO SPIDER FFT FORMAT 
C          SPIDER FORMAT IMAGINARY PARTS HAVE OPPOSITE SIGNS 
C          AS THAT OF FFTW 

	   LDA = NSAM+2-MOD(NSAM,2)
           JH  = LDA/2
	   	   
c$omp      parallel do private(i)
	   DO   I = 1,JH*NROW	
	      X(2*I) = -X(2*I)           
 	   ENDDO
	   	

	   NSAMO = NSAM
	   NROWO = NROW
        ELSE
C          REVERSE TRANSFORM

C          CHANGE SPIDER FFT FORMAT TO FFTW FORMAT
C          IMAGINARY PARTS HAVE OPPOSITE SIGNS AS THAT OF FFTW 


	   LDA = NSAM+2-MOD(NSAM,2)
           JH  = LDA/2
	   	   
c$omp      parallel do private(i)
	   DO   I = 1,JH*NROW	
	      X(2*I) = -X(2*I)           
 	   ENDDO

	   IF (NSAM.NE.NSAMOR .OR. NROW.NE.NROWOR) THEN
C             SIZE CHANGED, REESTABLISH PLAN

              IF (PLANR .GT. 0) CALL FFTWND_F77_DESTROY_PLAN(PLANR)

#ifdef SP_LIBFFTWMP
C              FOR OMP (MULTIPLE PROCESSORS)
               CALL RFFTW2D_F77_CREATE_PLAN(PLANR,NSAM,NROW,
     &              FFTW_BACKWARD, FFTW_ESTIMATE + FFTW_IN_PLACE +
     &                    FFTW_THREADSAFE)
#else
              CALL RFFTW2D_F77_CREATE_PLAN(PLANR,NSAM,NROW,
     &              FFTW_BACKWARD, FFTW_ESTIMATE + FFTW_IN_PLACE)
#endif
	      NSAMOR = NSAM
	      NROWOR = NROW
           ENDIF

#ifdef SP_LIBFFTWMP
C          FOR OMP (MULTIPLE PROCESSORS)
#if defined (sgi) || (defined (__linux__) && !defined (SP_IFC))
C          SGI & PGI DOES NOT LIKE OBJECT NAMES > 31 CHAR
           CALL RFFTWND_F77_THREADS_ONE_C_TO_R(NUMTH,PLANR,X,0)
#else
           CALL RFFTWND_F77_THREADS_ONE_COMPLEX_TO_REAL(NUMTH,PLANR,X,0)
#endif
#else
C          FOR SINGLE PROCESSOR
           CALL RFFTWND_F77_ONE_COMPLEX_TO_REAL(PLANR,X,0)
#endif

C          SCALING NEEDED
           PIX = 1.0 / (NSAM * NROW)
          
c$omp      parallel do private(i)
           DO I=1,LDA * NROW
              X(I) = X(I) * PIX
           ENDDO
        ENDIF
@


1.34
log
@GPL License fixed
@
text
@d5 2
a6 2
C FMRS_2.F                          ADDED FFTW FEB 2000 ARDEAN LEITH
C
d9 1
a9 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a37 2
C IMAGE_PROCESSING_ROUTINE
C
d46 2
a47 1
C       USING SGI_COMPLIB FOR FFT
d69 7
d77 1
a77 1
C       USING FFTW LIBRARY CALLS FOR FFT
a209 1

a213 1

d218 1
a218 91
#if defined(SP_LIBFFTW3) || defined(SP_LIBFFTW3MP)
C       USING FFTW3 LIBRARY CALLS FOR FFT
#include "FFTW3.INC"


C       USING FFTW3 LIBRARY CALLS FOR FFT

	INTEGER, SAVE :: NSAMO=0,  NROWO=0
	INTEGER, SAVE :: NSAMOR=0, NROWOR=0
	LOGICAL, SAVE :: INIT=.TRUE.

C       PLAN AND PLANR ARE ACTUALLY POINTERS TO A STRUCTURE 

        INTEGER*8, SAVE :: PLAN=0, PLANR=0
	REAL, ALLOCATABLE, DIMENSION(:) :: XY
	REAL, ALLOCATABLE, DIMENSION(:) :: AB	

#ifdef SP_LIBFFTW3MP


C       FOR OMP (MULTIPLE PROCESSORS) FFTW
        IF (INIT) THEN

C          MUST INITIALIZE THREADS ONCE
           CALL SFFTW_INIT_THREADS(IRTFLG)
	   IF (IRTFLG .EQ. 0) THEN
              CALL ERRT(101,'MULTIPLE THREADS FAILED',IER)
              RETURN
           ENDIF
	   
	   CALL GETTHREADS(NUMTH)
	   CALL SFFTW_PLAN_WITH_NTHREADS(NUMTH) 

           INIT = .FALSE.
        ENDIF

#else
C       FOR SINGLE PROCESSOR WITH FFTW
        NUMTH = 1
#endif

C         WRITE(NOUT,90) NUMTH
C90       FORMAT('USING FFTW WITH THREADS: ',i4)

        IF (INV .GT. 0) THEN
C          FORWARD TRANSFORM

	   LDA = NSAM+2-MOD(NSAM,2)

	   IF (NSAM.NE.NSAMO .OR. NROW.NE.NROWO) THEN
C             SIZE CHANGED, REESTABLISH XY AND THE PLAN

	      IF (ALLOCATED(XY))  DEALLOCATE(XY)
	   
	      ALLOCATE(XY(LDA*NROW),STAT=IRTFLG)
	      IF (IRTFLG.NE.0) THEN
	         CALL ERRT(46,'FMRS_2, XY',IER)
	         RETURN
              ENDIF
	   
C           COPYING IMAGE TO BUFFER SINCE IMAGE WILL BE OVERWRITTEN DURING
C           MAKING THE PLAN WITH FFTW_MEASURE FLAG
c$omp       parallel do private(i)
	      DO   I = 1,LDA*NROW	
	         XY(I) = X(I)           
 	      ENDDO	

              N1 = NSAM
	      N2 = NROW 
              IF (PLAN .GT. 0) CALL SFFTW_DESTROY_PLAN(PLAN)
              CALL SFFTW_PLAN_DFT_R2C_2D(PLAN,N1,N2,X,X,FFTW_MEASURE)

C           COPYING IMAGE FROM BUFFER SINCE IMAGE HAS BEEN OVERWRITTEN DURING
C           MAKING THE PLAN WITH FFTW_MEASURE FLAG
c$omp       parallel do private(i)
	      DO   I = 1,LDA*NROW	
	         X(I) = XY(I)           
 	      ENDDO	
	 
           ENDIF
 
	   
C         USE FFTW GURU INTERFACE
           CALL SFFTW_EXECUTE_DFT_R2C(PLAN,X,X) 

C         FREE MEMORY	   
	   IF (ALLOCATED(XY))  DEALLOCATE(XY)

C          CHANGE FFTW FORMAT TO SPIDER FFT FORMAT 
C          SPIDER FORMAT IMAGINARY PARTS HAVE OPPOSITE SIGNS 
C          AS THAT OF FFTW 
a219 81
	   LDA = NSAM+2-MOD(NSAM,2)
           JH  = LDA/2
	      	   
c$omp      parallel do private(i)
	   DO   I = 1,JH*NROW	
	      X(2*I) = -X(2*I)           
 	   ENDDO
	   	

	   NSAMO = NSAM
	   NROWO = NROW
        ELSE
C          REVERSE TRANSFORM
C          CHANGE SPIDER FFT FORMAT TO FFTW FORMAT
C          IMAGINARY PARTS HAVE OPPOSITE SIGNS AS THAT OF FFTW 


	   LDA = NSAM+2-MOD(NSAM,2)
           JH  = LDA/2
	   	   
c$omp      parallel do private(i)
	   DO   I = 1,JH*NROW	
	      X(2*I) = -X(2*I)           
 	   ENDDO

	   IF (NSAM.NE.NSAMOR .OR. NROW.NE.NROWOR) THEN
C             SIZE CHANGED, REESTABLISH AB AND THE PLAN

              IF (PLANR .GT. 0) CALL SFFTW_DESTROY_PLAN(PLANR)


	      IF (ALLOCATED(AB))  DEALLOCATE(AB)
	   
	      ALLOCATE(AB(LDA*NROW),STAT=IRTFLG)
	      IF (IRTFLG.NE.0) THEN
	         CALL ERRT(46,'FMRS_2, AB',IER)
	         RETURN
              ENDIF
	   
C           COPYING IMAGE TO BUFFER SINCE IMAGE WILL BE OVERWRITTEN DURING
C           MAKING THE PLAN WITH FFTW_MEASURE FLAG
c$omp       parallel do private(i)
	      DO   I = 1,LDA*NROW	
	         AB(I) = X(I)           
 	      ENDDO	
      
              N1 = NSAM
	      N2 = NROW 
              CALL SFFTW_PLAN_DFT_C2R_2D(PLANR,N1,N2,X,X,FFTW_MEASURE)
	      
C           COPYING IMAGE FROM BUFFER SINCE IMAGE HAS BEEN OVERWRITTEN DURING
C           MAKING THE PLAN WITH FFTW_MEASURE FLAG
c$omp       parallel do private(i)
	      DO   I = 1,LDA*NROW	
	         X(I) = AB(I)           
 	      ENDDO
	      	      
	      NSAMOR = NSAM
	      NROWOR = NROW
           ENDIF

C         USE FFTW GURU INTERFACE   
           CALL SFFTW_EXECUTE_DFT_C2R(PLANR,X,X) 
	   
C         FREE MEMORY	   
	   IF (ALLOCATED(AB))  DEALLOCATE(AB)

C          SCALING NEEDED
           PIX = 1.0 / (NSAM * NROW)
          

c$omp      parallel do private(i)
           DO I=1,LDA * NROW
              X(I) = X(I) * PIX
           ENDDO

        ENDIF


#else
C       USING SPIDER CODE FOR FFT
@


1.33
log
@HRI GPL License used
@
text
@a3 1
C++************************************************************************
a7 3
C **************************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
d11 1
a11 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a30 7

C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
a31 1
C **************************************************************************
a40 1
C--************************************************************************
@


1.32
log
@used FFTW_MEASURE, slightly faster than FFTW2 when doing a # of FTs of same size
@
text
@d3 1
d8 1
d10 1
d12 24
d42 1
d52 1
@


1.31
log
@cosmetic
@
text
@d202 1
d212 3
a214 2
	REAL, ALLOCATABLE, DIMENSION(:), SAVE :: XY
	REAL, ALLOCATABLE, DIMENSION(:), SAVE :: AB	
d216 1
a216 1
        
d221 2
a222 3
C         MUST INITIALIZE THREADS ONCE
	   IRTFLG = -4
           CALL SFFTW_INIT_THREADS(IRTFLG)	   
d239 2
a240 2
C      WRITE(NOUT,90) NUMTH
C90    FORMAT('USING FFTW WITH THREADS: ',i4)
d243 1
a243 1
C         FORWARD TRANSFORM
d245 1
a245 1
           LSD = NSAM+2-MOD(NSAM,2)
d248 2
a249 1
C            SIZE CHANGED MUST REESTABLISH XY
d252 1
a252 1
	      ALLOCATE(XY(NROW*LSD),STAT=IRTFLG)
d257 7
a263 6
	   ENDIF
C        COPYING IMAGE TO BUFFER 
c$omp    parallel do private(i)
	   DO   I = 1,LSD*NROW	
	      XY(I) = X(I)           
 	   ENDDO	
a264 2
	   IF (NSAM.NE.NSAMO .OR. NROW.NE.NROWO) THEN
C           SIZE CHANGED, REESTABLISH PLAN
d268 9
a276 1
              CALL SFFTW_PLAN_DFT_R2C_2D(PLAN,N1,N2,XY,XY,FFTW_ESTIMATE)
d278 7
d286 3
a288 1
           CALL SFFTW_EXECUTE(PLAN)
d290 2
a291 5
C         CHANGE FFTW FORMAT TO SPIDER FFT FORMAT 
C         SPIDER FORMAT IMAGINARY PARTS HAVE OPPOSITE SIGNS 
C         AS THAT OF FFTW 
	   
           JH  = LSD/2
d293 1
a293 1
c$omp     parallel do private(i)
d295 1
a295 6
	      XY(2*I) = -XY(2*I)           
 	   ENDDO
C         COPY FROM BUFFER    
c$omp     parallel do private(i)
	   DO   I = 1,LSD*NROW	
	      X(I) = XY(I)           
d297 1
d302 4
a305 2
C         REVERSE TRANSFORM
 
d309 6
d316 5
a320 1
C           SIZE CHANGED MUST REESTABLISH AB
d323 1
a323 1
	      ALLOCATE(AB(NROW*LDA),STAT=IRTFLG)
d326 2
a327 8
                 RETURN
	      ENDIF
	   ENDIF
C         COPY IMAGE TO BUFFER 	
c$omp     parallel do private(i)
	   DO   I = 1,LDA*NROW	
	      AB(I) = X(I)           
 	   ENDDO	
d329 7
a335 11
C         CHANGE SPIDER FFT FORMAT TO FFTW FORMAT
C         IMAGINARY PARTS HAVE OPPOSITE SIGNS AS THAT OF FFTW
	      	   
c$omp     parallel do private(i)
	   DO   I = 1,JH*NROW	
	      AB(2*I) = -AB(2*I)           
 	   ENDDO

	   IF (NSAM.NE.NSAMOR .OR. NROW.NE.NROWOR) THEN
C            SIZE CHANGED, REESTABLISH PLAN
              IF (PLANR .GT. 0) CALL SFFTW_DESTROY_PLAN(PLANR)
d338 9
a346 3

              CALL SFFTW_PLAN_DFT_C2R_2D(PLANR,N1,N2,AB,AB,
     &                                           FFTW_ESTIMATE)
d351 5
a355 1
           CALL SFFTW_EXECUTE(PLANR) 
d357 1
a357 1
C         SCALING NEEDED, WRITE FROM BUFFER
d361 1
a361 1
c$omp     parallel do private(i)
d363 1
a363 1
              X(I) = AB(I) * PIX
d368 1
@


1.30
log
@copied the image to a fixed buffer and didn't use FFTW GURU INTERFACE
@
text
@d292 1
a292 2
C         CHANGE SPIDER FFT FORMAT TO FFTW FORMAT
C         IMAGINARY PARTS HAVE OPPOSITE SIGNS AS THAT OF FFTW 
d310 5
a314 1
 	   ENDDO	   	   
@


1.29
log
@cosmetic
@
text
@a201 1

d211 2
a212 2
	

d214 1
a214 1

d219 3
a221 2
C          MUST INITIALIZE THREADS ONCE
           CALL SFFTW_INIT_THREADS(IRTFLG)
d238 2
a239 2
C         WRITE(NOUT,90) NUMTH
C90       FORMAT('USING FFTW WITH THREADS: ',i4)
d242 19
a260 1
C          FORWARD TRANSFORM
d263 1
a263 1
C             SIZE CHANGED, REESTABLISH PLAN
d267 1
a267 2
              CALL SFFTW_PLAN_DFT_R2C_2D(PLAN,N1,N2,X,X,FFTW_ESTIMATE)

a268 2
C         USE FFTW GURU INTERFACE
           CALL SFFTW_EXECUTE_DFT_R2C(PLAN,X,X) 
d270 1
a270 3
C          CHANGE FFTW FORMAT TO SPIDER FFT FORMAT 
C          SPIDER FORMAT IMAGINARY PARTS HAVE OPPOSITE SIGNS 
C          AS THAT OF FFTW 
d272 5
a276 2
	   LDA = NSAM+2-MOD(NSAM,2)
           JH  = LDA/2
d278 1
a278 1
c$omp      parallel do private(i)
d280 6
a285 1
	      X(2*I) = -X(2*I)           
a286 1
	   	
d291 3
a293 4
C          REVERSE TRANSFORM
C          CHANGE SPIDER FFT FORMAT TO FFTW FORMAT
C          IMAGINARY PARTS HAVE OPPOSITE SIGNS AS THAT OF FFTW 

d297 16
a312 2
	   	   
c$omp      parallel do private(i)
d314 1
a314 1
	      X(2*I) = -X(2*I)           
d318 1
a318 2
C             SIZE CHANGED, REESTABLISH PLAN

d322 3
a324 1
              CALL SFFTW_PLAN_DFT_C2R_2D(PLANR,N1,N2,X,X,FFTW_ESTIMATE)
d329 1
a329 2
C         USE FFTW GURU INTERFACE   
           CALL SFFTW_EXECUTE_DFT_C2R(PLANR,X,X) 
d331 1
a331 2

C          SCALING NEEDED
d335 1
a335 1
c$omp      parallel do private(i)
d337 1
a337 1
              X(I) = X(I) * PIX
a341 1

@


1.28
log
@added fftw3
@
text
@d221 1
a221 1
           CALL SFFTW_INIT_THREADS(IRTFLG);
@


1.27
log
@for __x86_64__
@
text
@d71 1
d196 114
d319 1
@


1.26
log
@save
@
text
@d64 1
a64 1
#if defined (__osf__) || defined (ia64)
@


1.25
log
@ia64
@
text
@a68 1
        LOGICAL, SAVE :: INIT=.TRUE.
@


1.24
log
@ && !defined (SP_IFC))
@
text
@d64 3
a66 4
#ifdef __osf__
        INTEGER*8 PLAN, PLANR
        DATA PLAN,PLANR/0,0/
#else        
d69 1
d114 1
a114 1
C           SGI DOES NOT LIKE OBJECT NAMES > 31 CHAR
d131 1
a131 1
c$omp parallel do private(i)
d149 1
a149 1
c$omp parallel do private(i)
d175 1
a175 1
C          SGI DOES NOT LIKE OBJECT NAMES > 31 CHAR
d189 1
a189 1
c$omp parallel do private(i)
@


1.23
log
@removed fftw thread msg output
@
text
@d113 1
a113 1
#if defined (sgi) || defined (__linux__)
d174 1
a174 1
#if defined (sgi) || defined (__linux__)
@


1.22
log
@linux fftw
@
text
@d88 2
a89 2
        WRITE(NOUT,90) NUMTH
90      FORMAT('USING FFTW WITH THREADS: ',i4)
@


1.21
log
@|| directives
@
text
@d113 1
a113 1
#ifdef sgi
d174 1
a174 1
#ifdef sgi
@


1.20
log
@*** empty log message ***
@
text
@d2 1
d131 1
d149 1
d189 1
d206 1
@


1.19
log
@*** empty log message ***
@
text
@d131 1
a131 1
	      X(I) = -X(I)           
d148 1
a148 1
	      X(I) = -X(I)           
@


1.18
log
@ .
@
text
@d130 1
a130 1
	   DO   I = JH*NROW	
d147 1
a147 1
	   DO   I = JH*NROW	
@


1.17
log
@corrected comments
@
text
@d128 6
a133 5
	   DO   J=1, NROW	   
	      DO   I=1, LDA/2	
	         X(2*I,J) = -  X(2*I,J)           
 	      ENDDO
	   ENDDO	
d145 5
a149 5
	   DO   J=1, NROW	   
	      DO   I=1, LDA/2	
	         X(2*I,J) = -  X(2*I,J)           
 	      ENDDO
	   ENDDO
@


1.16
log
@adapted fftw format to spider fft format
imaginary parts have opposite signs
@
text
@d19 1
a19 1
C                  INV     1=REG. FILE, 2= FOURIER FILE       SENT
@


1.15
log
@changed back to revision 1.13
@
text
@d123 11
d139 11
d184 1
a184 1
	   LDA = NSAM + 2 - MOD(NSAM,2)
@


1.14
log
@*** empty log message ***
@
text
@a45 1
	print *, 'libfft'
d82 1
a82 1
	print *, 'libfftwmp'
a85 1
	print *, 'libfftw'
d174 1
a174 1
	print *, 'spi'
@


1.13
log
@for dec
@
text
@d46 1
d83 1
a83 1

d87 1
d176 1
a176 1

@


1.12
log
@# removed
@
text
@d60 1
d63 6
a68 2
	INTEGER, SAVE :: PLAN=0, PLANR=0
	LOGICAL, SAVE :: INIT=.TRUE.
@


1.11
log
@sgi
@
text
@d130 1
a130 1
#              CALL RFFTW2D_F77_CREATE_PLAN(PLANR,NSAM,NROW,
@


1.10
log
@cmblock.inc
@
text
@d66 1
d79 1
d94 1
d99 1
d106 2
a107 3
#ifdef SP_IBMSP3
            CALL RFFTWND_F77_THREADS_ONE_REAL_TO_COMPLEX(NUMTH,PLAN,X,0)
#else
d110 2
d114 1
d129 2
a130 1
              CALL RFFTW2D_F77_CREATE_PLAN(PLANR,NSAM,NROW,
d142 2
a143 3
#ifdef SP_IBMSP3
           CALL RFFTWND_F77_THREADS_ONE_COMPLEX_TO_REAL(NUMTH,PLANR,X,0)
#else
d146 2
d150 1
@


1.9
log
@ibm
@
text
@d27 1
@


1.8
log
@added IBM long object name ifdef
@
text
@d134 4
a137 1
c          CALL RFFTWND_F77_THREADS_ONE_COMPLEX_TO_REAL(NUMTH,PLANR,X,0)
d139 1
@


1.7
log
@for fftw
@
text
@d101 6
a106 2
cc         CALL RFFTWND_F77_THREADS_ONE_REAL_TO_COMPLEX(NUMTH,PLAN,X,0)
           CALL RFFTWND_F77_THREADS_ONE_R_TO_C(NUMTH,PLAN,X,0)
@


1.6
log
@changed to allocate
@
text
@d1 1
d4 1
a4 1
C $$ FMRS_2.FOR
a14 1
C  Order of elements:
d16 1
d18 3
d22 1
d24 1
a24 3
C
C $$ FMRS_2.FOR
C
d26 1
d28 1
d30 1
d33 10
a42 7
	IF(NSAM.NE.NSAMO .OR. NROW.NE.NROWO) THEN
	  IF(ASSOCIATED(COEFF))  DEALLOCATE(COEFF)
	  ALLOCATE(COEFF(NSAM+15+2*(NROW+15)),STAT=IRTFLG)
	  IF(IRTFLG.NE.0) CALL ERRT(46,'FT 2, COEFF',IER)
	  CALL  SCFFT2DUI(NSAM,NROW,COEFF)
	  NSAMO=NSAM
	  NROWO=NROW
d44 3
a46 3
	LDA=NSAM+2-MOD(NSAM,2)
	IF(INV.GT.0)  THEN
	 CALL  SCFFT2DU(INV,NSAM,NROW,X,LDA,COEFF)
d48 2
a49 2
	 CALL  CSFFT2DU(INV,NSAM,NROW,X,LDA,COEFF)
	 CALL  SSCAL2D(NSAM,NROW,(1.0/FLOAT(NSAM)/FLOAT(NROW)),X,LDA)
d52 102
a153 3
C Have to change NSAM
	LDA=NSAM+2-MOD(NSAM,2)
        CALL  FMRS_2R(X,LDA,NSAM,NROW,INV)
@


1.5
log
@a
@
text
@d22 2
a23 3
         SUBROUTINE  FMRS_2(X,NSAM,NROW,INV)
         DIMENSION  X(*)
	
d25 9
a33 6
C The same common appears in FMRS_3
	PARAMETER  (LC=40000)
	COMMON /LIBFFT_D/  COEFF(LC)
	IF(NSAM+15+2*(NROW+15).GT.LC)  THEN
	CALL  ERRT(6,'FMRS_2 ',NE)
	RETURN
a35 1
	CALL  SCFFT2DUI(NSAM,NROW,COEFF)
d37 1
a37 1
	CALL  SCFFT2DU(INV,NSAM,NROW,X,LDA,COEFF)
d39 2
a40 2
	CALL  CSFFT2DU(INV,NSAM,NROW,X,LDA,COEFF)
	CALL  SSCAL2D(NSAM,NROW,(1.0/FLOAT(NSAM)/FLOAT(NROW)),X,LDA)
@


1.4
log
@added image_processing_routine string
@
text
@d24 1
a24 1
CNO_SAVE	
@


1.3
log
@buffer increased to 40000
@
text
@d17 1
@


1.2
log
@use libfft
@
text
@d26 1
a26 1
	PARAMETER  (LC=10000)
@


1.1
log
@Initial revision
@
text
@d24 17
d42 3
a44 1
        CALL  FMRS_2R(X,NSAM+2-MOD(NSAM,2),NSAM,NROW,INV)
@
