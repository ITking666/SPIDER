head	1.41;
access;
symbols
	pre_getangas:1.40
	GPL2010:1.40
	pre_GPL2010:1.39
	pre_var_equation:1.36
	pre_fftwrings:1.36
	pre_opfiles:1.33
	src:1.33
	best-code:1.30
	named-reg:1.18
	x-named-regs:1.17
	x:1.17
	v13-00:1.16
	pre_GPL:1.14
	prec_CA:1.14
	noindx:1.14
	Bproc:1.9;
locks; strict;
comment	@c @;


1.41
date	2014.05.21.16.30.05;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.24.13.26.44;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.06.19.11.53;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.30.20.05.57;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.26.13.18.34;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.01.12.39.18;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.19.18.12.43;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.26.15.59.49;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2006.04.04.17.17.38;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.04.16.55.11;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2006.03.31.16.00.48;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.16.20.18.26;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.27.16.52.27;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.27.14.25.22;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.26.16.55.48;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.25.19.22.35;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.25.17.03.07;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.25.15.27.32;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2006.01.24.15.09.31;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2006.01.23.15.57.52;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.29.18.07.09;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.14.16.48.31;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.12.16.25.16;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.12.15.29.10;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.15.21.51.11;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.17.20.31.06;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.17.18.22.09;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2001.07.31.18.19.30;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.31.14.52.56;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.27.17.24.42;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.20.19.32.18;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.06.17.34.33;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.18.16.13.52;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.14.14.25.51;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.10.18.14.40;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.10.14.28.28;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.09.19.18.37;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.08.20.40.41;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.08.20.26.43;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.08.19.41.05;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2000.08.08.18.21.43;	author leith;	state Exp;
branches;
next	;


desc
@@


1.41
log
@REG_GET_SEL FOR GLO VAR SEND, ==,  cosmetic
@
text
@
C++*********************************************************************
C
C REG_SET.F                                          AUTHOR: A. LEITH
C                    REMOVED FILNAMSUB CALL IN READPQ APR 01 A. Leith
C                    ADDED REGLPIPE                   JUL 01 A. Leith
C                    READPQ MOD                       NOV 05 A. Leith
C                    REG_SET_BANKED                   NOV 05 A. Leith
C                    REWRITE                          NOV 05 A. Leith
C                    CHANGED TO < TAGEND              JAN 06 A. Leith
C                    DECREASED MAXRSTRQ               JAN 06 A. Leith
C                    ERRT USAGE                       FEB 06 A. Leith
C                    REG_GET_NAME BUG                 MAR 06 A. Leith
C                    RECREATE OLD BUGGY BEHAVIOUR     APR 06 A. Leith
C                    REMOVED REDUNDANT ERROR MSG      JUN 09 A. Leith
C                    GLO VAR SET BUG                  DEC 09 A. Leith
C                    REG_FIND_IREG                    JAN 10 A. Leith
C                    REG_GET_SEL FOR GLO VAR SEND     MAY 14 A. Leith
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2014  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    CONTAINS SUBROUTINES FOR CREATING REGISTER BANKS,
C    QUERYING REGISTERS AND SETTING REGISTERS
C
C    REG_INIT(IBANK,IRTFLG)
C    PURPOSE: INITIALIZES A BANK OF REGISTERS   
C
C    REG_FIND(IBANKT,NAME,VALUE,IREG,IRTFLG)
C    PURPOSE: FINDS IF VARIABLE EXISTS, RETURNS VALUE & IREG  
C
C   REG_FIND_IREG(TYPE,STRING,ISGLOBAL,IREG,IRTFLG)
C    PURPOSE: FINDS IF VARIABLE EXISTS, RETURNS OR CREATES VARIABLE  
C
C    REG_NEW(IBANKT,NAME,VALUE,IREG,IRTFLG)
C    PURPOSE: CREATES A NEW REGISTER VAR & VALUE   
C
C    REG_SET_VAR(IBANK,STRING,CREATE,VALUE,IREG,IRTFLG)
C    PURPOSE: SETS FIRST VARIABLE FROM STRING
C
C    REG_SET_BYNUM(IREG,VALUE,IRTFLG)
C    PURPOSE: SETS REGISTER IREG=VALUE
C
C    REG_SET(IXREG,CXREG,VALUE,IRTFLG)
C    PURPOSE: SETS X REGISTER VALUE FOR: IXREG OR CXREG
C
C    REG_GET_BYNUM(IREG,VALUE,IRTFLG)
C    PURPOSE: GETS REGISTER VALUE FOR: IREG
C
C    REG_GET_VAR(IBANK,STRING,CREATE,VALUE,IREG,IEND,IRTFLG)
C    PURPOSE: GETS FIRST VARIABLE FROM STRING
C
C    REG_GET(IBANK,IXREG,CXREG,VALUE,IREGRET,IRTFLG)
C    PURPOSE: GETS A CURRENT REGISTER VALUE FROM IXREG OR CXREG INPUT   
C
C    REG_GET_SEL(IBANK,STRING,CREATE,WANTGLO,NREG,IRTFLG)
C    PURPOSE: PARSES REGISTER LIST INTO NSELREG
C
C    REG_GET_SELS(ISELS,NREG,IRTFLG)
C    PURPOSE: RETURNS REGISTER NUMBERS (NOT CONTENTS) FROM  NSELREG.
C
C    REG_LIST_COPY()
C    PURPOSE: COPIES LISTIN REGISTER VALUES TO LISTOUT REGISTERS
C
C    REG_SET_NSEL(IGO,VAL0,VAL1,VAL2,VAL3,VAL4,IRTFLG)
C    PURPOSE: SETS A REGISTER SPECIFIED IN NSELREG(NVAL) TO VALUE   
C
C    REG_SET_NSELA(NREG,VALUES,FILLALL,IRTFLG)
C    PURPOSE: SETS REGISTERS SPECIFIED IN NSEL TO VALUES   
C
C    REG_GET_NAME(IPOS,NAME,NLET,IRTFLG)
C    PURPOSE: REVERSE LOOKUP OF REGISTER(S) SPECIFIED BY REGVALUES  
C
C    REG_GET_NUMS(IREGS)
C    PURPOSE: GETS TOTAL CURRENT NUMBER OF REGISTERS 
C
C    REG_OPENPIPE(CXNUM,IRTFLG)
C    PURPOSE: OPENS PIPE FOR REGISTERS  
C
C    REG_PIPE(NAME,IRTFLG)
C    PURPOSE: SENDS REGISTER VALUE DOWN LUNREGPIPE   
C
C    REG_REINIT()
C    PURPOSE: RESIZES REGISTER SPACE   
C 
C     REGVALUES   CONTAINS CONTENTS OF REGISTERS X0.....
C     NSELREG     CONTAINS THE NUMBERS OF REGISTERS SELECTED IN THE 
C                 OPERATION LINE. PK X12,X20 WOULD RETURN 13,21 IN 
C                 NSELREG(1) AND NSELREG(2)
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

      MODULE REG_STUFF

         SAVE

         INTEGER, PARAMETER :: NUMREGLOOP = 26

         LOGICAL            :: REGPIPE  = .FALSE.
         INTEGER, PARAMETER :: LUNREGPIPE  = 302

C        DANGER NPARG=MAXNSEL IS ALSO SET IN spider.f (NPARG) AND readrq!! 
         INTEGER, PARAMETER          :: MAXNSEL = 24  ! REGISTER LIST 
         INTEGER, DIMENSION(MAXNSEL) :: NSELREG 
         INTEGER                     :: NSEL_USED = 0

C        DANGER MAXPRC IS ALSO SET IN spider.f!!
         INTEGER, PARAMETER :: MAXPRC = 20      ! NO. OF LEVELS

         INTEGER, DIMENSION(MAXPRC) :: IGORSTRQ,   IENDRSTRQ
         INTEGER, DIMENSION(MAXPRC) :: IGOREGNUM,  IENDREGNUM
         INTEGER                    :: IMAXREGNUM1,IMAXRSTRQ1

C        THIS SHOULD BE RE-DONE WITH ALLOCATABLE CHAR. ARRAY??
C        GLOBAL (BANK 1) AND OTHER NAMESPACES ARE CONCATENATED!
         INTEGER, PARAMETER      :: MAXRSTRQG = 1600
         INTEGER, PARAMETER      :: MAXRSTRQ  = 16000
         CHARACTER(LEN=MAXRSTRQ) :: RSTRQ = ' '

C        GLOBAL (BANK 1) AND OTHER REGISTERS ARE ALSO CONCATENATED!
         INTEGER, PARAMETER      :: NUMREGISG_ORIG = 1000

         INTEGER, PARAMETER      :: NUMREGIS_ORIG  = 16000
         INTEGER                 :: NUMREGIS       = 0

         DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: REGVALUES 

      END MODULE REG_STUFF


C++*********************************************************************
C
C REG_INIT                    NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_INIT(IBANK,IRTFLG)
C
C    PURPOSE:     INITIALIZES  BANK OF REGISTERS   
C
C    PARAMETERS:  IBANK     BANK OF REGISTERS                   (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_INIT(IBANK,IRTFLG)

      USE REG_STUFF

      IF (IBANK > MAXPRC) THEN
         IT     = MAXPRC
         CALL ERRT(102,'MAXPRC OVERFLOW',IT)
         IRTFLG = 1
         RETURN
      ENDIF

      IF (NUMREGIS <= 0) THEN
C        CREATE THE REGISTER STORAGE ARRAY (ONLY OCCURS ONCE)
         ALLOCATE (REGVALUES(NUMREGIS_ORIG), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'UNABLE TO ALLOCATE REGISTERS:',NUMREGIS_ORIG)
            RETURN
         ENDIF
         NUMREGIS  = NUMREGIS_ORIG

C        SET FLAG FOR MT BANKS (ARRAY OPS!)
         IGOREGNUM   = 0
         IENDREGNUM  = 0

      ENDIF

      IF (IBANK < 1) THEN
         CALL ERRT(102,'ILLEGAL VARIABLE BANK:',IBANK)
         IRTFLG = 1
         RETURN

       ELSEIF (IBANK == 1) THEN
C        INITIALIZE BANK ONE (WHICH IS ALSO THE GLOBAL BANK)
         IGORSTRQ(IBANK)   = 1
         IENDRSTRQ(IBANK)  = 0
         IGOREGNUM(IBANK)  = 1
         IENDREGNUM(IBANK) = 0

         IMAXREGNUM1       = NUMREGISG_ORIG 
         IMAXRSTRQ1        = MAXRSTRQG

      ELSEIF (IBANK == 2) THEN
C        SECOND  BANK
         IGORSTRQ(IBANK)   = IMAXRSTRQ1       + 1
         IENDRSTRQ(IBANK)  = IMAXRSTRQ1 
         IGOREGNUM(IBANK)  = IMAXREGNUM1      + 1
         IENDREGNUM(IBANK) = IMAXREGNUM1

      ELSE
C        THIRD, ..... BANK
         IGORSTRQ(IBANK)   = IENDRSTRQ(IBANK-1)  + 1
         IENDRSTRQ(IBANK)  = IGORSTRQ(IBANK)     - 1 
         IGOREGNUM(IBANK)  = IENDREGNUM(IBANK-1) + 1
         IENDREGNUM(IBANK) = IGOREGNUM(IBANK)    - 1
      ENDIF

C     INITIAL < IN RSTRQ
      RSTRQ(IGORSTRQ(IBANK):IGORSTRQ(IBANK)) = '<'  
      IENDRSTRQ(IBANK) = IGORSTRQ(IBANK) 

C     SET LOOP REG NONE IN BANK
      CALL REG_SET_VAR(IBANK,'[_0]',.TRUE.,0.0,IDUM,IRTFLG)

C     SET ERROR FLAG TO NONE IN BANK
      CALL REG_SET_VAR(IBANK,'[_9]',.TRUE.,0.0,IDUM,IRTFLG)

      IRTFLG = 0
 
      RETURN
      END

C++*********************************************************************
C
C REG_REINIT                    NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_REINIT()
C
C    PURPOSE:     RESIZES   REGISTER SPACE   
C
C    PARAMETERS:  IRTFLG    ERROR FLAG                          (RET.)
C
C    YES, I KNOW THAT IT SHOULD BE WRITTEN USING POINTERS BUT
C    I DOUBT ANYONE WILL EVER USE THIS!! al
C
C--*******************************************************************

      SUBROUTINE REG_REINIT(IRTFLG)

      USE REG_STUFF

      INCLUDE 'CMBLOCK.INC'
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: REGVALUEST

      CALL REG_GET_NUMS(NREG,NCHAR)
      WRITE(NOUT,90)NREG,NCHAR  
90    FORMAT(' CURRENT REGISTERS: ',I7,' NAME CHARACTERS: ',I8)
  
      CALL RDPRI1S(NREGN,NOT_USED,'NUMBER OF REGISTERS WANTED',IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

      IF (NREGN > NREG) THEN
         ALLOCATE (REGVALUEST(NREG), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'UNABLE TO INCREASE REGISTERS:',NREG)
            RETURN
         ENDIF
              
         REGVALUEST(1:NUMREGIS) = REGVALUES
         DEALLOCATE(REGVALUES)

         ALLOCATE (REGVALUES(NREGN), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'UNABLE TO INCREASE REGISTERS:',NREGN)
            RETURN
         ENDIF

         REGVALUES(1:NUMREGIS) = REGVALUEST
         DEALLOCATE(REGVALUEST)
         
         NUMREGIS = NREGN

      ENDIF

      IRTFLG = 0
 
      RETURN
      END


C++*********************************************************************
C
C REG_BANK_OK                    NEW            AUG 2005 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_BANK_OK(IBANKIN,IBANKOUT,IRTFLG)
C
C    PURPOSE:     FINDS IF REGISTER BANK EXISTS, RETURNS BANK  
C
C    PARAMETERS:  IBANKIN   STACK LEVEL (0 IS CURRENT ISTOP)    (SENT)
C                 IBANKOUT  STACK LEVEL                         (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_BANK_OK(IBANKIN,IBANKOUT,IRTFLG)

      USE REG_STUFF

      INCLUDE 'CMBLOCK.INC'
      COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

      IF (IBANKIN == -9999) THEN
         IBANKOUT = 1      ! UNUSED CAPABILITY FOR ALLBANK
      ELSEIF (IBANKIN < 0) THEN
         IBANKOUT = ISTOP + IBANKIN
      ELSEIF (IBANKIN == 0) THEN
         IBANKOUT = ISTOP
      ELSE
         IBANKOUT = IBANKIN
      ENDIF

      IF (IBANKOUT < 0 .OR. IBANKOUT > MAXPRC) THEN
         CALL ERRT(102,'ILLEGAL REGISTER VARIABLE BANK',IBANKOUT)
         IRTFLG = 1
         RETURN

      ELSEIF (IBANKOUT > ISTOP) THEN
         CALL ERRT(102,'BANK NOT IN CURRENT USE',IBANKOUT)
         IRTFLG = 1
         RETURN
      ENDIF

      IRTFLG   = 0
      END

     
C++*********************************************************************
C
C REG_FIND                       NEW            AUG 2005 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_FIND(IBANKT,NAME,VALUE,IREG,IRTFLG)
C
C    PURPOSE:     FINDS IF VARIABLE EXISTS, RETURNS VALUE & IREG  
C
C    PARAMETERS:  IBANK     STACK LEVEL () IS CURRENT TOP       (SENT)
C                 NAME      REGISTER NAME, WITH [...]           (SENT)
C                 VALUE     VALUE                               (RET.)
C                 IREG      REGISTER NUMBER                     (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_FIND(IBANKT,NAME,VALUE,IREG,IRTFLG)

      USE REG_STUFF

      INCLUDE 'CMBLOCK.INC'

C     COMMON NEEDED FOR: ISTOP
      COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

      CHARACTER(LEN=*)   :: NAME
      CHARACTER(LEN=160) :: NAMET

C     SEE IF REGISTER VARIABLE EXISTS YET

C     <> ARE USED AS VARIABLE ID DELIMITERS IN RSTRQ
      LENT             = LEN(NAME)
      NAMET            = '<' // NAME(2:LENT-1) // '>' 

C     FIND AND CHECK BANK NUMBER
      CALL REG_BANK_OK(IBANKT,IBANK,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

      IGOQ   = IGORSTRQ(IBANK)
      IENDQ  = IENDRSTRQ(IBANK)
      IRTFLG = 0
      IREG   = 0

      IF (IENDQ > IGOQ) THEN

C        SEARCH FOR THIS VARIABLE AT THIS LEVEL
         CALL GETREGVAR(RSTRQ(IGOQ:IENDQ),NAMET(1:LENT),'<',
     &                   IGO,IEND,IRTFLG)

         IF (IRTFLG == 0) THEN
C           VARIABLE EXISTS, FIND REGISTER NUMBER
            READ(RSTRQ(IGOQ+IGO-1:IGOQ+IEND-1),*) IREG
            VALUE = REGVALUES(IREG)
         ENDIF
      ENDIF

!     if (ireg > 0) then
!        write(6,90) namet(1:lent),ibank,ireg,value
!90       format('  regfind:',t15,a,t27,i8,i6,f9.3)
!      else
!        write(6,90),namet(1:lent),ibank,ireg
!      endif

      END



C++*********************************************************************
C
C REG_NEW                         NEW            AUG 2005 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_NEW(IBANK,NAME,VALUE,IREG,IRTFLG)
C
C    PURPOSE:     CREATES A NEW REGISTER VAR & VALUE   
C
C    PARAMETERS:  IBANK     STACK LEVEL                         (SENT)
C                 NAME      REGISTER NAME, WITH [...]           (SENT)
C                 VALUE     VALUE                               (SENT)
C                 IREG      REGISTER NUMBER                     (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C     NOTES: REGISTER VARIABLE SHOULD NOT ALREADY EXIST (NOT CHECKED)
C
C--*******************************************************************

      SUBROUTINE REG_NEW(IBANKT,NAME,VALUE,IREG,IRTFLG)

      USE REG_STUFF

      INCLUDE 'CMBLOCK.INC'

      CHARACTER(LEN=*)  :: NAME
      CHARACTER(LEN=80) :: CREG

C     IF REGISTER VARIABLE ALREADY EXISTS (ERROR)

C     CHECK BANK NUMBER
      CALL REG_BANK_OK(IBANKT,IBANK,IRTFLG)

C     VARIABLE DOES NOT EXIST, CREATE IT
C     WRITE(NDAT,*)' CREATING REGISTER VARIABLE: ',NAME

C     INCREMENT REGISTER NUMBER
      IREG = IENDREGNUM(IBANK) + 1
      CALL INTTOCHAR(IREG,CREG,LENR,1)

      IF (IBANK == 1 .AND. IREG > IMAXREGNUM1) THEN
C        OVER-RUN OF GLOBAL REGISTER VALUE ARRAY
         IT     = IMAXREGNUM1
         CALL ERRT(102,'TOO MANY GLOBAL REGISTERS REQUESTED, LIMIT',IT)
         IRTFLG = 1
         RETURN

      ELSEIF (IREG > NUMREGIS) THEN
C        OVER-RUN OF REGISTER VALUE ARRAY
         IT = NUMREGIS

         WRITE(nout,*) '  VARIABLE NAME: ',NAME
         write(nout,*) ' BANK:      ',IBANK
         write(nout,*) ' IGORSTRQ:  ',IGORSTRQ
         write(nout,*) ' IGOREGNUM: ',IGOREGNUM
         write(nout,*) ' IENDREGNUM: ',IENDREGNUM
         do i=2401,3900,60
            write(nout,*) I,' RSTRQ(I:I+60): ',RSTRQ(I:i+59)
         enddo
       write(nout,*)'RSTRQ: ',RSTRQ(IGORSTRQ(IBANK):IGORSTRQ(IBANK)+60)

         WRITE(NOUT,*) 'igo,iend,nchar: ',igo,iend,nchar
         CALL ERRT(102,'TOO MANY REGISTERS REQUESTED, LIMIT',IT)
         IRTFLG = 1
         RETURN
      ENDIF

C     PLACE VARIABLE STRING IN RSTRQ ARRAY
      LENT    = LEN(NAME)
      LENADD  = LENT + LENR 

      IENDQAT = IENDRSTRQ(IBANK) + LENADD 

      IF (LENT > 80) THEN
         WRITE(NOUT,*) '  VARIABLE NAME: ',NAME
         CALL ERRT(102, 'OVERLENGTH VARIABLE NAME',LENT)
         IRTFLG = 1
         RETURN
      ELSEIF (LENR > 80) THEN
         WRITE(NOUT,*) '  VARIABLE SELECTOR: ',CREG
         CALL ERRT(102, 'OVERLENGTH REGISTER SELECTOR',LENR)
         IRTFLG = 1
         RETURN
      ELSEIF (LENADD > 92) THEN
         WRITE(NOUT,*) '  VARIABLE NAME: ',NAME
         WRITE(NOUT,*) '  VARIABLE SELECTOR: ',CREG
         CALL ERRT(102, 'OVERLENGTH TOTAL REG. SELECTOR',LENADD)
         IRTFLG = 1
         RETURN
      ENDIF

      IF (IBANK == 1 .AND. IREG > IMAXRSTRQ1) THEN
C        OVER-RUN OF GLOBAL REGISTER VALUE ARRAY
         CALL ERRT(102,
     &         'RSTRQ OVERFLOW, GLOBAL VARIABLE NAMES ARRAY IS FULL',
     &         IMAXRSTRQ1)
         IRTFLG = 1
         RETURN

      ELSEIF (IENDQAT >= MAXRSTRQ) THEN
C        OVER-RUN OF RSTRQ NAMESPACE ARRAY

       write(nout,*) ' BANK:      ',IBANK
       write(nout,*) ' IGORSTRQ:  ',IGORSTRQ
       write(nout,*) ' IGOREGNUM: ',IGOREGNUM
       write(nout,*) ' IENDREGNUM: ',IENDREGNUM
       do i=2401,3900,60
          write(nout,*) I,' RSTRQ(I:I+60): ',RSTRQ(I:i+59)
       enddo
       write(nout,*) 'RSTRQ: ',RSTRQ(IGORSTRQ(IBANK):IGORSTRQ(IBANK)+60)

       WRITE(NOUT,*) 'igo,iend,nchar: ',igo,iend,nchar
       stop
   
         CALL ERRT(102,
     &         'RSTRQ OVERFLOW, VARIABLE NAMES ARRAY IS FULL',IENDQAT)
         IRTFLG = 1
         RETURN
      ENDIF

C     FIND START FOR VARIABLE DEFINITION SEQ.
      IGOQ = IENDRSTRQ(IBANK) 

      IGOQ = IENDRSTRQ(IBANK) + 1
      RSTRQ(IGOQ:IGOQ+LENADD-1) =  NAME(2:LENT-1) // '>' // 
     &                                CREG(1:LENR)   // '<' 
       
      IENDRSTRQ(IBANK)  = IENDQAT 

      REGVALUES(IREG)   = VALUE
      IENDREGNUM(IBANK) = IREG

      IRTFLG = 0

      RETURN
      END






C++*********************************************************************
C
C REG_SET_VAR.F   
C                 NATIVE []                       NOV 2005 ARDEAN LEITH
C **********************************************************************
C
C    REG_SET_VAR(IBANK,STRING,CREATE,VALUE,IREG,IRTFLG)
C
C    PURPOSE:          SET REGISTER VAR FROM STRING, RETURNS THE
C                      REGISTER NUMBER AND IT'S VALUE
C
C    PARAMETERS:       IBANK     STACK LEVEL                     (SENT)
C                      STRING    OPERATION STRING                  SENT
C                      CREATE    CREATE FLAG                       SENT
C                      VALUE     VALUE                             SENT
C                      IREG      NO. OF REGISTER VARIABLE          RET.
C                      IRTFLG    ERROR FLAG                        RET.
C
C--*******************************************************************

      SUBROUTINE REG_SET_VAR(IBANK,STRING,CREATE,VALUE,IREG,IRTFLG)

      USE REG_STUFF

C     COMMON NEEDED FOR NALPH
      INCLUDE 'CMBLOCK.INC'

      CHARACTER(LEN=*)   :: STRING
      LOGICAL :: CREATE
      LOGICAL :: ISDIGI

      NCHAR  = LEN(STRING)
      IFIRST = 1

c     GET REG. VAR. (CHAR. STRING DELIMITED BY [])  FROM STRING
      CALL GETNEXTVAR(STRING,IFIRST,IGO,IEND,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

C     VARIABLE STRING FOUND, FIND REG. NUMBER FOR LIST
      CALL REG_FIND(IBANK,STRING(IGO:IEND),VALDUM,IREG,IRTFLG)
      IF (IREG <= 0) THEN
C        REGISTER DOES NOT EXIST
         IF (CREATE) THEN
C           CREATE THE REGISTER
            CALL REG_NEW(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)
         ELSE
C           DO NOT WANT TO CREATE REG. IF DOES NOT ALREADY EXIST
            CALL ERRT(8,STRING(IGO:IEND),NE)

#ifdef NEVER
            IF ((STRING(IGO:IGO) == '_') .AND.
     &          ISDIGI(STRING(IGO+1:IGO+1))) THEN
                VALPREV = 0.0
                IF (IBANK > 1) THEN
C                  TRY TO COPY REGISTER FROM PREVIOUS BANK
                   CALL REG_FIND(IBANK-1,STRING(IGO:IEND),VALPREV,
     &                        IREG,IRTFLG)
                ENDIF
                CALL REG_NEW(IBANK,STRING(IGO:IEND),VALPREV,IREG,IRTFLG)

                WRITE(NOUT,*)' *** UNDEFINED REGISTER VARIABLE: X',
     &                   STRING(IGO+1:IEND-1)
                WRITE(NOUT,*)' *** PLEASE FIX THIS AS IT MAY NOT BE',
     &                       ' ACCEPTED IN FUTURE SPIDER RELEASES'
            ENDIF
#endif
         ENDIF
      ELSE
         REGVALUES(IREG) = VALUE 
      ENDIF

      RETURN
      END

C++*********************************************************************
C
C REG_SET_BYNUM.F   
C                 NATIVE []                       NOV 2005 ARDEAN LEITH
C **********************************************************************
C
C    REG_SET_BYNUM(IREG,VALUE,IRTFLG)
C
C    PURPOSE:          SET REGISTER VAR IREG = VALUE
C
C    PARAMETERS:       IREG      NO. OF REGISTER VARIABLE          RET.
C                      VALUE     VALUE                             SENT
C                      IRTFLG    ERROR FLAG                        RET.
C
C--*******************************************************************

      SUBROUTINE REG_SET_BYNUM(IREG,VALUE,IRTFLG)

      USE REG_STUFF

C     COMMON NEEDED FOR NALPH
      INCLUDE 'CMBLOCK.INC'
      COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

      IF (IREG <= 0) THEN
C        REGISTER CAN NOT EXIST
         CALL ERRT(102,'BAD REGISTER NUMBER',IREG)
         IRTFLG = 1

      ELSEIF (IREG > IENDREGNUM(ISTOP)) THEN
C        REGISTER DOES NOT EXIST (BEYOND END)
         CALL ERRT(102,'BAD REGISTER NUMBER',IREG)
         IRTFLG = 1

      ELSE
         REGVALUES(IREG) = VALUE 
         IRTFLG = 0
      ENDIF

      RETURN
      END


C++*********************************************************************
C
C REG_GET_BYNUM.F   
C                 NATIVE []                       NOV 2005 ARDEAN LEITH
C **********************************************************************
C
C    REG_GET_BYNUM(IREG,VALUE,IRTFLG)
C
C    PURPOSE:          SET REGISTER VAR IREG = VALUE
C
C    PARAMETERS:       IREG      NO. OF REGISTER VARIABLE          SENT
C                      VALUE     VALUE                             RET.
C                      IRTFLG    ERROR FLAG                        RET.
C
C--*******************************************************************

      SUBROUTINE REG_GET_BYNUM(IREG,VALUE,IRTFLG)

      USE REG_STUFF

C     COMMON NEEDED FOR NALPH
      INCLUDE 'CMBLOCK.INC'
      COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                       IPNUMSTACK,IPARNUM

      IF (IREG <= 0) THEN
C        REGISTER CAN NOT EXIST
         CALL ERRT(102,'BAD REGISTER NUMBER',IREG)
         IRTFLG = 1

      ELSEIF (IREG > IENDREGNUM(ISTOP)) THEN
C        REGISTER DOES NOT EXIST (BEYOND END)
         CALL ERRT(102,'REGISTER NUMBER NOT DEFINED',IREG)
         IRTFLG = 1

      ELSE
         VALUE  = REGVALUES(IREG)
         IRTFLG = 0
      ENDIF

      RETURN
      END

C++*********************************************************************
C
C REG_GET_VAR.F   
C                 NATIVE []                       NOV 2005 ARDEAN LEITH
C **********************************************************************
C
C    REG_GET_VAR(IBANK,STRING,CREATE,VALUE,IREG,IEND,IRTFLG)
C
C    PURPOSE:          EXTRACTS REGISTER VAR FROM STRING, RETURNS THE
C                      REGISTER NUMBER AND IT'S VALUE
C
C    PARAMETERS:       IBANK     STACK LEVEL                       SENT 
C                      STRING    OPERATION STRING                  SENT
C                      CREATE    CREATE FLAG                       SENT
C                      VALUE     VALUE                             RET.
C                      IREG      NUMBER FOR REGISTER VARIABLE      RET.
C                      IEND      LAST VARIABLE POSITION IN STRING  RET.
C                      IRTFLG    ERROR FLAG                        RET.
C
C--*******************************************************************

      SUBROUTINE REG_GET_VAR(IBANK,STRING,CREATE,VALUE,IREG,IEND,IRTFLG)

      USE REG_STUFF

C     COMMON NEEDED FOR: NOUT
      INCLUDE 'CMBLOCK.INC'

C     COMMON NEEDED FOR: ISTOP
      COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

      CHARACTER(LEN=*) :: STRING
      LOGICAL          :: CREATE,ISDIGI

      NCHAR  = LEN(STRING)
      IFIRST = 1

c     GET REG. VAR. (CHAR. STRING DELIMITED BY [])  FROM STRING
      CALL GETNEXTVAR(STRING,IFIRST,IGO,IEND,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

C     VARIABLE STRING FOUND, FIND REG. NUMBER FOR LIST
      CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)

!      if (ireg > 0) then
!         write(6,90) string(igo:iend),istop,ireg,value
!90       format('  get_var:',t15,a,t27,i8,i6,f9.3)
!      else
!         write(6,90) string(igo:iend),ibank,ireg
!      endif

      IF (IREG > 0) RETURN     ! REGISTER VARIABLE FOUND OK

C     SEE IF FOUND IN GLOBAL BANK  
      CALL REG_FIND(1,STRING(IGO:IEND),VALUE,IREG,IRTFLG)

!      ibankz = 1
!      if (ireg > 0) then
!         ibankz = 1
!         write(6,91) string(igo:iend),ibankz,ireg,value
!91       format('  get_var1:',t15,a,t27,i8,i6,f9.3)
!      else
!         write(6,91) string(igo:iend),ibankz,ireg
!      endif


      IF (IREG <= 0) THEN
C        NOT FOUND IN IBANK OR IN GLOBAL BANK

         IF (CREATE) THEN
C           CREATE THE VARIABLE
            CALL REG_NEW(IBANK,STRING(IGO:IEND),0.0,IREG,IRTFLG)

         ELSE
C           DO NOT CREATE, WANT EXISTING VARIABLE ONLY
            WRITE(NOUT,*)'  '

            IF ((STRING(IGO+1:IGO+1) == '_') .AND.
     &          ISDIGI(STRING(IGO+2:IGO+2))) THEN
                VALUE = 0.0
C               TRY TO COPY REGISTER FROM PREVIOUS BANK
                CALL REG_FIND(-1,STRING(IGO:IEND),VALUE,
     &                        IREG,IRTFLG)

                CALL REG_NEW(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)
                WRITE(NOUT,*)' ***  UNDEFINED REGISTER VARIABLE: X',
     &                       STRING(IGO+2:IEND-1)
                WRITE(NOUT,*)'      OK NOW, BUT USE OF UNDEFINED ',
     &                       'REGISTER VARIABLES '

                WRITE(NOUT,*)'      MAY NOT BE ACCEPTED IN FUTURE ',
     &                       'SPIDER RELEASES'
                IRTFLG = 0
            ELSE 
                CALL ERRT(8,STRING(IGO:IEND),NE)
            ENDIF
         ENDIF
      ENDIF

      RETURN
      END


C++*********************************************************************
C
C REG_FIND_IREG.F   
C                 FROM REG_GET_VAR                JAN 2010 ARDEAN LEITH
C **********************************************************************
C
C    REG_FIND_IREG(TYPE,STRING,ISGLOBAL,IREG,IRTFLG)
C
C    PURPOSE:  EXTRACTS REGISTER VAR, NAME FROM STRING, RETURNS THE
C              GLOBAL REGISTER NUMBER, IF NO GLOBAL REG. EXISTS AND
C             , CREATES SPECIFIED GLOBAL REG. OTHERWISE 
C              RETURNS LOCAL REG. IF EXISTS OR CREATES IT. 
C
C    PARAMETERS:       TYPET      GLOBAL STRING                    SENT 
C                      ISGLOBAL   GLOBAL FLAG                      RET. 
C                      STRING     OPERATION STRING                 SENT
C                      IREG       NUMBER FOR REGISTER VARIABLE     RET.
C                      IRTFLG     ERROR FLAG                       RET.
C
C--*******************************************************************

      SUBROUTINE REG_FIND_IREG(TYPET,STRING,ISGLOBAL,IREG,IRTFLG)

      USE REG_STUFF

C     COMMON NEEDED FOR: ISTOP
      COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

C     COMMON NEEDED FOR: FCHAR
      INCLUDE 'CMBLOCK.INC'

      CHARACTER(LEN=*) :: STRING
      CHARACTER(LEN=3) :: TYPE,TYPET
      INTEGER          :: IREG,IBANK,IRTFLG
      LOGICAL          :: ISGLOBAL

      NCHAR  = LEN(STRING)
      IFIRST = 1

c     GET REG. VAR. (CHAR. STRING DELIMITED BY [])  FROM STRING
      CALL GETNEXTVAR(STRING,IFIRST,IGO,IEND,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

      TYPE = TYPET
      IF (FCHAR(1:2) == 'UD') THEN
C        ALWAYS WANT A LOCAL VARIABLE CREATION
         TYPE = 'LOC'
      ENDIF

      ISGLOBAL = .FALSE.

      IF (TYPE == 'GLO') THEN
C        USE GLOBAL VARIABLE, CREATE IF IT DOES NOT EXIST

         IBANK = 1

C        SEE IF FOUND IN GLOBAL BANK (IREG WILL BE > 0)  
         CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)

         IF (IREG <= 0) THEN
            CALL REG_NEW(IBANK,STRING(IGO:IEND),0.0,IREG,IRTFLG)
         ENDIF
         ISGLOBAL = .TRUE.

      ELSEIF (TYPE == 'LOC') THEN
C        SEE IF NAMED REGISTER IS IN LOCAL BANK
         IBANK = 0
         CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)

         IF (IREG <= 0) THEN
C           NOT FOUND IN LOCAL BANK, CREATE LOCAL VARIABLE
            IBANK = 0
            CALL REG_NEW(IBANK,STRING(IGO:IEND),0.0,IREG,IRTFLG)
        ENDIF

      ELSEIF (TYPE == 'RED') THEN
C        SEE IF NAMED REGISTER IS IN LOCAL BANK
         IBANK = 0
         CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)

         !write(6,*) ' type:',type, ' ibank:',ibank,'string:',string,
         !' value:',value,' ireg:',ireg,' irtflg:',irtflg

         IF (IREG <= 0) THEN
C           NOT FOUND IN LOCAL BANK, USE GLOBAL VARIABLE IF EXISTS

C           SEE IF FOUND IN GLOBAL BANK (IREG WILL BE > 0) 
            IBANK = 1
            CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)
         
            IF (IREG <= 0) THEN
C              NOT FOUND IN GLOBAL BANK, CREATE LOCAL VARIABLE INSTEAD
               IBANK = 0
               CALL REG_NEW(IBANK,STRING(IGO:IEND),0.0,IREG,IRTFLG)            ISGLOBAL = .TRUE.
               ISGLOBAL = .FALSE.
            ELSE
               ISGLOBAL = .TRUE.
            ENDIF
         ENDIF
      ENDIF

!      if (isglobal) then
!         write(6,90) string(igo:iend),ibank,ireg,type
!90       format('  find_ireg:',t15,a,t27,i8,i6,'          :',a,':')
!      else
!         write(6,90) string(igo:iend),istop,ireg,type
!      endif

      RETURN
      END

C++*********************************************************************
C
C REG_GET_SEL.F   ADAPTED FROM READP.FOR FOR CHAR. AUG 1989 ARDEAN LEITH
C                 NATIVE []                        NOV 2005 ARDEAN LEITH
C                 REG_FIND_IREG                    JAN 2009 ARDEAN LEITH
C **********************************************************************
C
C    REG_GET_SEL(IBANK,STRING,CREATE,WANTGLO,NREG,IRTFLG)
C
C    PURPOSE:          PARSES REGISTER LIST FROM INPUT LINE.  PLACES
C                      REGISTER NUMBERS (UP TO MAXNSEL NUMBERS) IN 
C                      NSELREG.
C
C    PARAMETERS:       IBANK     STACK LEVEL                       SENT 
C                      STRING    OPERATION STRING                  SENT
C                      CREATE    FLAG TO CREATE VAR.               SENT
C                      WANTGLO   WANT EXISTIN GLOBAL REG           SENT
C                      NREG      NO. OF REGISTER VARIABLES         RET.
C                      IRTFLG    ERROR FLAG                        RET.
C
C--*******************************************************************

      SUBROUTINE REG_GET_SEL(IBANK,STRING,CREATE,WANTGLO,NREG,IRTFLG)

      USE REG_STUFF

C     COMMON NEEDED FOR: NOUT
      INCLUDE 'CMBLOCK.INC'

      CHARACTER(LEN=*)   :: STRING
      CHARACTER(LEN=10)  :: REGNAME
      LOGICAL            :: CREATE,WANTGLO,ISGLOBAL

      NCHAR = LEN(STRING)
      NREG   = 0
      IFIRST = 1
      IRTFLG = 1

      DO
c        GET NEXT VAR. (CHAR. STRING DELIMITED BY [] ) FROM STRING
         CALL GETNEXTVAR(STRING,IFIRST,IGO,IEND,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
         IF (IGO <= 0 .OR. IEND <= IGO) THEN
C           ALL TOKENS FROM STRING HAVE BEEN EVALUATED
            IRTFLG = 0
            EXIT
         ENDIF

         IF (IGO  > 0 .AND. IEND <= IGO) THEN
C           ERROR
            write(nout,*) ' IFIRST:     ',IFIRST,IGO,IEND
            write(nout,*) ' BANK:       ',IBANK
            write(nout,*) ' NCHAR:      ',NCHAR
            write(nout,*) ' STRING:     ',STRING
            write(nout,*) ' IGORSTRQ:   ',IGORSTRQ
            write(nout,*) ' IENDRSTRQ:  ',IENDRSTRQ
            write(nout,*) ' IGOREGNUM:  ',IGOREGNUM
            write(nout,*) ' IENDREGNUM: ',IENDREGNUM
            write(nout,*) ' NSEL_USED:  ',NSEL_USED
            write(nout,*) ' NSELREG:    ',NSELREG
            do i=2401,IENDRSTRQ(IBANK),60
               write(nout,*) I,' RSTRQ(I:I+60): ',RSTRQ(I:i+59)
            enddo
            CALL GETNEXTVARbug(STRING,IFIRST,IGO,IEND,IRTFLG)
            CALL ERRT(102,'TOO MAY REGISTERS ON THIS LINE',NREG)
            NSEL_USED = NREG -1
            IRTFLG = 1
         stop
            RETURN
         ENDIF

C        VARIABLE FOUND, FIND REG. NUMBER FOR LIST

         NREG = NREG + 1
         IF (NREG > MAXNSEL) THEN
C           ERROR
            write(nout,*) ' IFIRST:     ',IFIRST,IGO,IEND
            write(nout,*) ' BANK:       ',IBANK
            write(nout,*) ' NCHAR:      ',NCHAR
            write(nout,*) ' STRING:     ',STRING
            write(nout,*) ' IGORSTRQ:   ',IGORSTRQ
            write(nout,*) ' IENDRSTRQ:  ',IENDRSTRQ
            write(nout,*) ' IGOREGNUM:  ',IGOREGNUM
            write(nout,*) ' IENDREGNUM: ',IENDREGNUM
            write(nout,*) ' NSEL_USED:  ',NSEL_USED
            write(nout,*) ' NSELREG:    ',NSELREG
            do i=2401,IENDRSTRQ(IBANK),60
               write(nout,*) I,' RSTRQ(I:I+60): ',RSTRQ(I:i+59)
            enddo
            CALL GETNEXTVARbug(STRING,IFIRST,IGO,IEND,IRTFLG)
            CALL ERRT(102,'TOO MANY REGISTERS ON THIS LINE',NREG)
            NSEL_USED = NREG -1
            IRTFLG = 1
            STOP
            RETURN
         ENDIF

         IF (STRING(IGO:IGO) .NE. '[') THEN
C           JUST A NUMBER, NOT A REGISTER VARIABLE
            WRITE(NOUT,*) 'GETNEXVAR RETURNED:',STRING(IGO:IEND)
            WRITE(NOUT,*) 'SHOULD HAVE BEEN VARIABLE',IGO,IEND
            CALL ERRT(100,'REG_GET_SEL',NE)
            STOP
         ENDIF

         IF (IBANK == 1) THEN

C           ACCESS EXISTING GLOBAL REGISTER OR CREATE NEW GLOBAL ONE 
            CALL REG_FIND_IREG('GLO',STRING(IGO:IEND),
     &                         ISGLOBAL,IREG,IRTFLG)
         ELSEIF (WANTGLO) THEN

C           ACCESS EXISTING LOCAL/GLOBAL REGISTER OR CREATE NEW LOCAL ONE 
            CALL REG_FIND_IREG('RED',STRING(IGO:IEND),
     &                         ISGLOBAL,IREG,IRTFLG)
         ELSE

C           ACCESS EXISTING LOCAL REGISTER OR CREATE NEW LOCAL ONE 
            CALL REG_FIND_IREG('LOC',STRING(IGO:IEND),
     &                         ISGLOBAL,IREG,IRTFLG)
         ENDIF

         NSELREG(NREG) = IREG
         IFIRST        = IEND + 1
         IF (IFIRST > NCHAR) EXIT
          
      ENDDO

      NSEL_USED = NREG
      IRTFLG    = 0

      END

C++*********************************************************************
C
C REG_GET_SELS.F   NATIVE []                      NOV 2005 ARDEAN LEITH
C **********************************************************************
C
C    REG_GET_SELS(IREGSELS,NLEN,NREG,IRTFLG)
C
C    PURPOSE: RETRIEVES REGISTER NUMBERS FROM NSELREG.
C
C    PARAMETERS: IREGSELS     SELECTED REGISTER LIST.             RET.
C                NLEN         LENGTH OF SELECTED REGISTER LIST.   SENT
C                NREG         NO. OF REGISTER VARIABLES           RET.
C                IRTFLG       ERROR FLAG (UNUSED)                 RET.
C
C--*******************************************************************

      SUBROUTINE REG_GET_SELS(IREGSELS,NLEN,NREG,IRTFLG)

      USE REG_STUFF

C     COMMON NEEDED FOR NALPH
      INCLUDE 'CMBLOCK.INC'

      INTEGER, DIMENSION(*) :: IREGSELS

      IRTFLG = 0
      NREG   = NSEL_USED

      IF (NREG > NLEN) THEN
         CALL ERRT(102,'TOO MANY REGISTERS SPECIFIED',NREG)
         NREG   = NLEN
         IRTFLG = 1
      ENDIF

      DO I = 1,NREG
         IREGSELS(I) = NSELREG(I)
      ENDDO 

      END


C++*********************************************************************
C
C REG_LIST_COPY.F   NATIVE []                       NOV 2005 ARDEAN LEITH
C **********************************************************************
C
C    REG_LIST_COPY(NL,LISTIN,LISTOUT)
C
C    PURPOSE:  COPIES LISTIN REGISTER VALUES TO LISTOUT REGISTERS
C
C    PARAMETERS: NL        NUMBER OF VALUES IN LIST             SENT
C                LISTIN    LIST OF INPUT REG. NUMBERS           SENT
C                LISTOUT   LIST OF OUTPUT REGISTER NUMBERS      RET.
C
C--*******************************************************************

      SUBROUTINE REG_LIST_COPY(NL,LISTIN,LISTOUT)

      USE REG_STUFF

      INTEGER, DIMENSION(NL) :: LISTIN,LISTOUT

      DO I = 1,NL
         REGVALUES(LISTOUT(I)) =  REGVALUES(LISTIN(I)) 
      ENDDO

      RETURN
      END




C++*********************************************************************
C
C REG_SET_NSEL                     NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_SET_NSEL(IGO,VAL0,VAL1,VAL2,VAL3,VAL4,IRTFLG)
C
C    PURPOSE:     SETS A REGISTER SPECIFIED IN NSELREG(NVAL) TO VALUE   
C
C    PARAMETERS:  IGO       STARTING REGISTER NUMBER           (SENT)
C                 VAL...    VALUES                             (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_SET_NSEL(IGO,NVAL,VAL0,VAL1,VAL2,VAL3,VAL4,IRTFLG)

      USE REG_STUFF

C     NSELREG IS STILL CARRYING ADJUSTED REG NUMBER (+1)

      NVALS = MIN(NVAL+IGO-1, NSEL_USED)
      
      IF (NVALS >= IGO+0) THEN
         REGVALUES(NSELREG(IGO+0)) = VAL0
         IF (NVALS >= IGO+1) THEN
            REGVALUES(NSELREG(IGO+1)) = VAL1
            IF (NVALS >= IGO+2) THEN
               REGVALUES(NSELREG(IGO+2)) = VAL2
               IF (NVALS >= IGO+3) THEN
                  REGVALUES(NSELREG(IGO+3)) = VAL3
                  IF (NVALS >= IGO+4) THEN
                     REGVALUES(NSELREG(IGO+4)) = VAL4
                  ENDIF 
               ENDIF
            ENDIF
         ENDIF
      ENDIF

      RETURN
      END


C++*********************************************************************
C
C REG_SET_NSELA                    NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_SET_NSELA(NREG,VALUES,FILLALL,IRTFLG)
C
C    PURPOSE:     SETS REGISTERS SPECIFIED IN NSEL TO VALUES   
C
C    PARAMETERS:  NREGT     NUMBER OF VARIABLES TO SET          (SENT)
C                 VALUES    VALUES ARRAY                        (SENT)
C                 FILLALL   FLAG TO ZERO REST OF SEL. VAR.      (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_SET_NSELA(NREGT,VALUES,FILLALL,IRTFLG)

      USE REG_STUFF

      REAL,DIMENSION(*) :: VALUES
      LOGICAL           :: FILLALL

C     ONLY SET A MAX OF: NSEL_USED REGISTERS 
      NREG = MIN(NREGT,NSEL_USED)

      IF (NREG > 0) THEN
C        NSELREG CONTAINS: NSEL_USED REGISTER NUMBERS
         DO IREG=1,NREG
            REGVALUES(NSELREG(IREG)) = VALUES(IREG)
         ENDDO
 
         IF (NREG < NSEL_USED) THEN
            DO IREG=NREG,NSEL_USED
               REGVALUES(NSELREG(IREG)) = 0.0
            ENDDO
         ENDIF
      ENDIF

      
      RETURN
      END

C++*********************************************************************
C
C REG_GET_NSELA                    NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_GET_NSELA(NREG,VALUES,FILLALL,IRTFLG)
C
C    PURPOSE:     GETS VALUES FROM REGISTER(S) LISTED IN NSEL    
C
C    PARAMETERS:  NREGT     NUMBER OF VARIABLES TO GET          (SENT)
C                 VALUES    VALUES ARRAY                        (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_GET_NSELA(NREGT,VALUES,IRTFLG)

      USE REG_STUFF

      REAL,DIMENSION(*) :: VALUES

C     ONLY GET A MAX OF: NSEL_USED REGISTERS 
      NREG = MIN(NREGT,NSEL_USED)

      DO IREG = 1,NREG
         CALL REG_GET_BYNUM(NSELREG(IREG),VALUES(IREG),IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
      ENDDO
 
     
      RETURN
      END




C++*********************************************************************
C
C REG_GET                         NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_GET(IBANK,IXREG,CXREG,VALUE,IREGRET,IRTFLG)
C
C    PURPOSE:     GETS A CURRENT REGISTER VALUE FROM X OR CXREG INPUT   
C
C    PARAMETERS:  IBANK     IBANK NUMBER                        (SENT)
C                 IXREG     REGISTER NUMBER X#                  (SENT)
C                 CXREG     INDEX REGISTER                      (SENT.)
C                 VALUE     VALUE FOR REGISTER                  (RET.)
C                 IREGRET   REGISTER #                          (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_GET(IBANK,IXREG,CXREG,VALUE,IREGRET,IRTFLG)

      USE REG_STUFF

      CHARACTER(LEN=1)  :: CXREG
      CHARACTER(LEN=80) :: REGNAME

      REGNAME(1:2) = '[_'
      IF (IXREG >= 0) THEN
         CALL INTTOCHAR(IXREG,REGNAME(3:),NLET,1)
         NLET = NLET + 3
      ELSE
         REGNAME(3:3) = CXREG
         NLET         = 4
      ENDIF
      REGNAME(NLET:NLET) = ']'

      CALL REG_GET_VAR(IBANK,REGNAME,.FALSE.,VALUE,IREGRET,IEND,IRTFLG)
 
      RETURN
      END

C++*********************************************************************
C
C REG_SET                         NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_SET(IXREG,VALUE,CXREG,IRTFLG)
C
C    PURPOSE:     SETS A CURRENT REGISTER VALUE   
C
C    PARAMETERS:  IXREG      REGISTER NUMBER X#                  (SENT)
C                 VALUE     VALUE FOR REGISTER                  (SENT)
C                 CXREG      INDEX REGISTER                      (SENT.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_SET(IXREG,VALUE,CXREG,IRTFLG)

      USE REG_STUFF

      CHARACTER(LEN=1)  :: CXREG
      CHARACTER(LEN=80) :: REGNAME

      REGNAME(1:2) = '[_'
      IF (IXREG >= 0) THEN
         CALL INTTOCHAR(IXREG,REGNAME(3:),NLET,1)
         NLET = NLET + 3
      ELSE
         REGNAME(3:3) = CXREG
         NLET         = 4
      ENDIF
      REGNAME(NLET:NLET) = ']'

      CALL REG_SET_VAR(0,REGNAME(:NLET),.TRUE.,VALUE,IREGRET,IRTFLG)

      RETURN
      END


C++*********************************************************************
C
C REG_GET_USED               NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_GET_USED(NREG)
C
C    PURPOSE:     GETS NUMBER OF REGISTER USED IN NSELREG   
C
C    PARAMETERS:  NREG      REGISTER NUMBERS IN USE             (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_GET_USED(NREG)

      USE REG_STUFF

      NREG = NSEL_USED

      RETURN
      END

      SUBROUTINE REG_SET_USED(NREG)

      USE REG_STUFF

      NSEL_USED = NREG

      RETURN
      END


C     ------------------------- REG_DOC_PARSE -----------------------------
C
C    REG_DOC_PARSE(CCHAR,COMOUT,IKEY,NLIST,IRTFLG)
C
C    PURPOSE:    SUBROUTINE TO PARSE UD & SD  TYPE LINE WHERE
C                VALUES AFTER THE FIRST ARE ALL REFERENCES TO REGISTERS
C                AND ARE RETURNED IN ILIST AS RAW REGISTER NUMBERS 
C
C    PARAMETERS:   CCHAR   INPUT LINE                             (SENT)
C                  COMOUT  COMMENT INDICATOR                      (RET.)
C                  IKEY    NUMBER OF FIRST VALUE IN CCHAR         (RET.)
C                  ILIST   ARRAY REGISTER LIST                    (RET.)
C                  NMAX    MAX LENGTH OF ARRAY REGISTER LIST      (SENT)
C                  NLIST   NUMBER OF ELEMENTS IN ARRAY            (RET.)
C                  IRTFLG  ERROR FLAG                             (RET.)
C
C--*********************************************************************

      SUBROUTINE REG_DOC_PARSE(CCHAR,COMOUT,IKEY,NLIST,IRTFLG)

      USE REG_STUFF

      INCLUDE 'CMBLOCK.INC'

      CHARACTER(LEN=*) :: CCHAR
      CHARACTER(LEN=1) :: CTEMP
      LOGICAL          :: COMOUT,ISCHAR       

C       PARSE REGISTER LINE, CHECK FOR ',' OR '[' ---------------------
       
        IRTFLG = 1
        COMOUT = .FALSE.

C       CHECK IF FIRST ENTRY IS A REGISTER, INTEGER, OR COMMENT /
        ILEN = LNBLNKN(CCHAR)

C       FIND FIRST NON-BLANK, NON-COMMA CHAR IN CCHAR
        K = VERIFY(CCHAR(1:ILEN),', ')
        IF (K <= 0) THEN
           WRITE(NOUT,90) CCHAR(1:ILEN)
          IF (NDAT .NE. 6) WRITE(6,90) CCHAR(1:ILEN)
90         FORMAT('  *** UNABLE TO PARSE REGISTER VARIABLE LINE: ',A)
           CALL ERRT(100,'REG_DOC_PARSE',NE)
           RETURN
        ENDIF

        CTEMP  = CCHAR(K:K)

        IF (CTEMP == '/') THEN
C          JUST WANT TO PUT A COMMENT IN THE DOC FILE.
           COMOUT = .TRUE.
           IRTFLG = 0
           RETURN

        ELSEIF (CTEMP == '[') THEN
C         FIRST ENTRY IS A REGISTER VARIABLE. PUT VAR. CONTENTS IN IKEY
          
C         FIND THE REGISTER NUMBER
          CALL REG_GET_NSEL(1,FKEY,FDUM,FDUM,FDUM,FDUM,IRTFLG)
          IF (IRTFLG .NE. 0) THEN
             WRITE(NOUT,90) CCHAR(1:ILEN)
             IF (NDAT .NE. 6) WRITE(NOUT,90) CCHAR(1:ILEN)
             CALL ERRT(100,'REG_DOC_PARSE',NE)
             RETURN
          ENDIF
          IKEY = FKEY

C         REGISTER VARIABLE NUMBERS WERE RETRIEVED IN RDPR.F
C         BUT FIRST REGISTER IS INTERPRETED AS THE KEY!!
C         THROW AWAY FIRST REGISTER VARIABLE

          IF (NSEL_USED > 1) THEN
             DO I = 2,NSEL_USED
                NSELREG(I-1) = NSELREG(I)
             ENDDO
             NSEL_USED = NSEL_USED - 1
          ENDIF

        ELSEIF (ISCHAR(CTEMP)) THEN
C          FIRST ENTRY IS A OLD DO LOOP INDEX, PUT ITS VALUE INTO IKEY.

           CALL REG_GET(0,-1,CTEMP,FKEY,IREGRET,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
           IKEY = FKEY

        ELSE
C          FIRST ENTRY IS A ,NUMBER. SO PUT THE NUMBER IN IKEY.
           NCHAR = INDEX(CCHAR(K:),',') - 1
           READ(CCHAR(K:K+NCHAR-1),*,IOSTAT=IER) IKEY

           IF (IER .NE. 0) THEN
              WRITE(NOUT,90) CCHAR(1:ILEN)
              IF (NDAT .NE. 6) WRITE(6,90) CCHAR(1:ILEN)
              CALL ERRT(100,'REG_DOC_PARSE',NE)
              RETURN
           ENDIF
        ENDIF

        IF (IKEY == 0) THEN
           CALL ERRT(101,'*** INVALID KEY NUMBER: 0',NE)
           RETURN
        ENDIF

        NLIST = NSEL_USED
        IRTFLG = 0

        RETURN
        END



C++*********************************************************************
C
C REG_GET_NSEL                     NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_GET_NSEL(IGO,VAL0,VAL1,VAL2,VAL3,VAL4,IRTFLG)
C
C    PURPOSE:     GETS VALUES OF CONTENTS OF REGISTER(S) SPECIFIED 
C                 IN NSELREG 
C
C    PARAMETERS:  IGO       STARTING REGISTER NUMBER           (SENT)
C                 VAL...    VALUES                              (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_GET_NSEL(IGO,VAL0,VAL1,VAL2,VAL3,VAL4,IRTFLG)

      USE REG_STUFF

      IF (NSEL_USED >= IGO+0) THEN
C        NSEL IS STILL CARRYING ADJUSTED REG NUMBER (+1)
         CALL REG_GET_BYNUM(NSELREG(IGO+0),VAL0,IRTFLG)
         IF (NSEL_USED >= IGO+1) THEN
            CALL REG_GET_BYNUM(NSELREG(IGO+1),VAL1,IRTFLG)
            IF (NSEL_USED >= IGO+2) THEN
               CALL REG_GET_BYNUM(NSELREG(IGO+2),VAL2,IRTFLG)
               IF (NSEL_USED >= IGO+3) THEN
                  CALL REG_GET_BYNUM(NSELREG(IGO+3),VAL3,IRTFLG)
                  IF (NSEL_USED >= IGO+4) THEN
                     CALL REG_GET_BYNUM(NSELREG(IGO+4),VAL4,IRTFLG)
                  ENDIF 
               ENDIF
            ENDIF
         ENDIF
      ENDIF

      RETURN
      END


C++*********************************************************************
C
C REG_GET_NAME                 NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_GET_NAME(IREG,NAME,NLET,IRTFLG)
C
C    PURPOSE:     REVERSE LOOKUP OF REGISTER(S) SPECIFIED IN IREG 
C
C    PARAMETERS:  IREG      REGISTER POSITION IN REGVALUES     (SENT.)
C                 NAME      REGISTER NAME                      (RET.)
C                 NLET      CHARS IN REGISTER NAME             (RET.)
C                 IRTFLG    ERROR FLAG                         (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_GET_NAME(IREG,NAME,NLET,IRTFLG)

      USE REG_STUFF

      COMMON /QSTR_STUFF1/ ISTOP,NSTDOUTP,NSTDINP,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

      CHARACTER(LEN=*)  :: NAME
      CHARACTER(LEN=80) :: SEARCH
      LOGICAL           :: ISDIGI

      CALL INTTOCHAR(IREG,SEARCH(2:),NLET,1)
      SEARCH(1:1)           = '>' 
      SEARCH(NLET+2:NLET+2) = '<' 
      ILOC = INDEX(RSTRQ(IGORSTRQ(ISTOP):IENDRSTRQ(ISTOP)), 
     &                   SEARCH(1:NLET+2))

      IEND = IGORSTRQ(ISTOP) + ILOC - 2
      IGO  = INDEX(RSTRQ(1:IEND),'<',.TRUE.) + 1

      IF (RSTRQ(IGO:IGO) == '_') THEN
         IF (ISDIGI(RSTRQ(IGO+1:IGO+1))) THEN
C           OLD FASHIONED X REGISTER NAME
            NAME = 'X' // RSTRQ(IGO+1:IEND) // CHAR(0)
            NLET = IEND - (IGO + 1) + 2
         ELSE
C           INDEX LETTER
            NAME = RSTRQ(IGO+1:IGO+1) // CHAR(0)
            NLET = 1
         ENDIF
      ELSE
C        MODERN REGISTER VARIABLE NAME
         NAME = '[' // RSTRQ(IGO:IEND) // ']' // CHAR(0)
         NLET = IEND - (IGO + 1) + 4
      ENDIF

      IRTFLG = 0
      RETURN
      END

C++*********************************************************************
C
C REG_GET_NUMS                    NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_GET_NUMS(IREGS)
C
C    PURPOSE:     GETS TOTAL CURRENT NUMBER OF REGISTERS 
C
C    PARAMETERS:  IREGS     NUMBER OF REGISTER                  (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_GET_NUMS(IREGS,NCHAR)

      USE REG_STUFF

      IREGS = NUMREGIS
      NCHAR = MAXRSTRQ
      END


C++*********************************************************************
C
C REG_OPENPIPE                   NEW            JULY 2001 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_OPENPIPE(CXNUM,IRTFLG)
C
C    PURPOSE:     OPENS PIPE FOR REGISTERS   
C
C    PARAMETERS:  PIPENAME  PIPE NAME                           (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_OPENPIPE(PIPENAME,IRTFLG)

      USE REG_STUFF

      CHARACTER (LEN=80) ::    PIPENAME
      CHARACTER (LEN=80+24) :: MSG

      OPEN(UNIT=LUNREGPIPE, FILE=PIPENAME,
     &    FORM='UNFORMATTED',
     &    ACCESS='SEQUENTIAL',
     &    STATUS='OLD',
     &    ACTION='WRITE',
     &    IOSTAT=IRTFLG)

      IF (IRTFLG .NE. 0) THEN 
         MSG = 'FAILED TO OPEN PIPE: ' // PIPENAME
         CALL ERRT(101,MSG,IRTFLG)
         RETURN
      ENDIF

      REGPIPE = .TRUE.
      IRTFLG  = 0

      RETURN
      END

C++*********************************************************************
C
C REG_PIPE                         NEW           JULY 2001 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_PIPE(NAME,IRTFLG)
C
C    PURPOSE:    SENDS REGISTER VALUE DOWN LUNREGPIPE   
C
C    PARAMETERS:  NAME  REGISTER NAME                           (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*********************************************************************

      SUBROUTINE REG_PIPE(NAME,IRTFLG)

      USE REG_STUFF

      CHARACTER(LEN=*) :: NAME
      CHARACTER(LEN=8) :: CREG

      REAL           RVAL
      INTEGER * 1    I1VAL(4), I1TMP1,I1TMP2,I1TMP3,I1TMP4
      EQUIVALENCE    (RVAL,I1VAL(1))

      INOT = VERIFY(NAME,'0123456789')
      IF (INOT == 0) THEN
C        GOT AN OLD FASHIONED NUMBER
         CREG = '[_' // NAME // ']' // CHAR(0)
         CALL REG_GET_VAR(0,CREG,.FALSE.,
     &                    VALUE,IREG,IENDVAR,IERR)
      ELSE
         CALL REG_GET_VAR(0,NAME,.FALSE.,
     &                    VALUE,IREG,IENDVAR,IERR)
      ENDIF
      IF (IRTFLG .NE. 0) RETURN

      RVAL = VALUE

#ifdef __linux__
      I1TMP1   = I1VAL(1)     !THIS COULD BE SIMPLIFIED
      I1TMP2   = I1VAL(2)
      I1TMP3   = I1VAL(3)
      I1TMP4   = I1VAL(4)

      I1VAL(1) = I1TMP4
      I1VAL(2) = I1TMP3
      I1VAL(3) = I1TMP2
      I1VAL(4) = I1TMP1

C     write(0,*) ' VALUE: ',VALUE,'  --> ', RVAL
      VALUE    = RVAL
#endif

      IF (REGPIPE) THEN
C        WRITE REG NUMBER & VALUE TO NAMED PIPE
C        LINE_FEED IS NECESSARY (EVEN ON LINUX), DO NOT ASK ME WHY!

         WRITE(LUNREGPIPE,IOSTAT=IRTFLG) RVAL,CHAR(10)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'PIPING REGISTER',IREG)
            RETURN
         ENDIF

C        THIS LINE_FEED IS NECESSARY, DO NOT ASK ME WHY!
C        WRITE(LUNREGPIPE,IOSTAT=IRTFLG) CHAR(10)

#ifdef __linux__
         CALL FLUSHFILE(LUNREGPIPE)
#endif
      ELSE
         CALL ERRT(102,'NO PIPE OPEN ON LUNREGPIPE',LUNREGPIPE)
         IRTFLG = 1
      ENDIF
 
      RETURN
      END

C--*************************** GETNEXTVAR *****************************

      SUBROUTINE GETNEXTVAR(STRING,IFIRST,IGO,IEND,IRTFLG)

C     COMMON NEEDED FOR WRITE
      INCLUDE 'CMBLOCK.INC'

C     VAR DELIMITERS ARE []

      CHARACTER(LEN=*) :: STRING
      CHARACTER(LEN=1) :: CTEMP

C     SET DEFAULT RETURN VALUES
      IGO       = 0
      IEND      = 0
      IRTFLG    = 0

C     FIND LAST CHAR POSITION IN STRING
      ILAST = LEN(STRING)

      DO I = IFIRST,ILAST
         CTEMP = STRING(I:I)

         IF (IGO == 0 .AND. CTEMP == '[') THEN
C           ARE STARTING A VARIABLE, SET IGO 
            IGO  = I

         ELSEIF (CTEMP == ';' .AND. IGO > 0) THEN
C           START OF COMMENT BUT NO ENDING ] FOR VARIABLE
            WRITE(NOUT,*)'  *** NO ENDING ] FOR LAST VARIABLE IN: ',STRING
            CALL ERRT(101,'BAD VARIABLE SYNTAX',NE)
            IRTFLG = I
            EXIT

        ELSEIF (CTEMP ==  ']' .AND. IGO > 0) THEN
C           ARE ENDING A VAR.
            IEND = I
            EXIT

         ELSEIF (CTEMP == ';') THEN
C           START OF COMMENT, THIS IS LINE END
            EXIT

         ELSEIF (IGO > 0 .AND. CTEMP < CHAR(31)) THEN
C           ILLEGAL CHAR INSIDE A REG. VAR. NAME
            WRITE(NOUT,*)'  *** ILLEGAL CHAR.: ',CTEMP,' AT POSITION: ',
     &           I,' IN REGISTER VAR. STRING: ',STRING
            CALL ERRT(101,'BAD CHAR. IN REGISTER VAR. NAME',NE)
            IRTFLG = I

         ELSEIF (CTEMP < CHAR(31)) THEN
C           ILLEGAL CHAR OUTSIDE A REG. VAR. NAME
            WRITE(NOUT,*)'  *** ILLEGAL CHAR.: ',CTEMP,' AT POSITION: ',
     &           I,' IN STRING: ',STRING
         ENDIF
      ENDDO

C     VARIABLE FOUND OR RAN OFF END OF STRING

      RETURN
      END





      SUBROUTINE GETNEXTVARbug(STRING,IFIRST,IGO,IEND,IRTFLG)

C     COMMON NEEDED FOR WRITE
      INCLUDE 'CMBLOCK.INC'

C     VAR DELIMITERS ARE []

      CHARACTER(LEN=*) :: STRING
      CHARACTER(LEN=1) :: CTEMP

C     SET DEFAULT RETURN VALUES
      IGO       = 0
      IEND      = 0
      IRTFLG    = 0

       write(NOUT,*)'  STRING: ',STRING

C     FIND LAST CHAR POSITION IN STRING
      ILAST = LEN(STRING)
       write(NOUT,*)'  STRING: ',STRING
       write(NOUT,*)'  IFIRST,ILAST: ',IFIRST,ILAST

      DO I = IFIRST,ILAST
         CTEMP = STRING(I:I)
       write(NOUT,*)'  CTEMP: ',CTEMP,' AT: ',I,' IGO: ',IGO

         IF (IGO == 0 .AND. CTEMP == '[') THEN
C           ARE STARTING A VAR, SET IGO 
            IGO  = I

         ELSEIF (CTEMP == ';') THEN
C           START OF COMMENT, THIS IS LINE END
            EXIT

        ELSEIF (CTEMP ==  ']' .AND. IGO > 0) THEN
C           ARE ENDING A VAR.
            IEND = I
            EXIT

         ELSEIF (IGO > 0 .AND. CTEMP < CHAR(31)) THEN
C           ILLEGAL CHAR INSIDE A REG. VAR. NAME
            WRITE(NOUT,*)'  *** ILLEGAL CHAR.: ',CTEMP,' AT POSITION: ',
     &           I,' IN REGISTER VAR. STRING: ',STRING
            CALL ERRT(101,'BAD CHAR. IN REGISTER VAR. NAME',NE)
            IRTFLG = I

         ELSEIF (CTEMP < CHAR(31)) THEN
C           ILLEGAL CHAR OUTSIDE A REG. VAR. NAME
            WRITE(NOUT,*)'  *** ILLEGAL CHAR.: ',CTEMP,' AT POSITION: ',
     &           I,' IN STRING: ',STRING
         ENDIF
      ENDDO

C     VARIABLE FOUND OR RAN OFF END OF STRING

      RETURN
      END



C++*********************************************************************
C
C  GETREGVAR.F                NEW JUNE 2002 ARDEAN LEITH
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C  GETREGVAR(QSTRQ,QFIND,QEND,IGO,IEND,IRTFLG)
C
C  PARAMETERS:  
C               IRTFLG                                            (RET.)
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE GETREGVAR(QSTRQ,QFIND,QEND,IGO,IEND,IRTFLG)

      CHARACTER(LEN=*), INTENT(IN)  ::      QSTRQ,QFIND,QEND
      INTEGER, INTENT(OUT)  ::              IGO,IEND,IRTFLG

      IRTFLG = 1

C     FIND LENGTH OF SEARCH STRING
      LENFIND  = LEN(QFIND)
       
C     FIND STARTING LOCATION OF SEARCH STRING IN QSTRQ
      IGO = INDEX(QSTRQ,QFIND)

C     RETURN IF NO SEARCH STRING IN QSTRQ
      IF (IGO <= 0) THEN
C          THIS WAS DUE TO XLRF90 MAC OPTIMIZER BUG
           IRTFLG = 1
           RETURN
      ENDIF

C     FIND START OF ASSOCIATED VALUE 
      IGO    = IGO + LENFIND

C     FIND END OF ASSOCIATED VALUE
      IEND   = IGO + INDEX(QSTRQ(IGO:),QEND) - 2 

C     RETURN IF NO ASSOCIATED VALUE OR QEND
      IF (IEND < IGO) RETURN

      IRTFLG = 0

      RETURN
      END




@


1.40
log
@GPL_2010
@
text
@d18 1
d24 1
a24 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d75 1
a75 1
C    REG_GET_SEL(IBANK,STRING,CREATE,UNUSED,NREG,IRTFLG)
d170 1
a170 1
      IF (IBANK .GT. MAXPRC) THEN
d177 1
a177 1
      IF (NUMREGIS .LE. 0) THEN
d192 1
a192 1
      IF (IBANK .LT. 1) THEN
d197 1
a197 1
       ELSEIF (IBANK .EQ. 1) THEN
d207 1
a207 1
      ELSEIF (IBANK .EQ. 2) THEN
d268 1
a268 1
      IF (NREGN .GT. NREG) THEN
d321 1
a321 1
      IF (IBANKIN .EQ. -9999) THEN
d323 1
a323 1
      ELSEIF (IBANKIN .LT. 0) THEN
d325 1
a325 1
      ELSEIF (IBANKIN .EQ. 0) THEN
d331 1
a331 1
      IF (IBANKOUT .LT. 0 .OR. IBANKOUT .GT. MAXPRC) THEN
d336 1
a336 1
      ELSEIF (IBANKOUT .GT. ISTOP) THEN
d392 2
a393 1
      IF (IENDQ .GT. IGOQ) THEN
d398 1
a398 1
         IF (IRTFLG .EQ. 0) THEN
a411 1
      RETURN
d457 1
a457 1
      IF (IBANK .EQ. 1 .AND. IREG .GT. IMAXREGNUM1) THEN
d464 1
a464 1
      ELSEIF (IREG .GT. NUMREGIS) THEN
d469 8
a476 8
       write(nout,*) ' BANK:      ',IBANK
       write(nout,*) ' IGORSTRQ:  ',IGORSTRQ
       write(nout,*) ' IGOREGNUM: ',IGOREGNUM
       write(nout,*) ' IENDREGNUM: ',IENDREGNUM
       do i=2401,3900,60
          write(nout,*) I,' RSTRQ(I:I+60): ',RSTRQ(I:i+59)
       enddo
       write(nout,*) 'RSTRQ: ',RSTRQ(IGORSTRQ(IBANK):IGORSTRQ(IBANK)+60)
d478 2
a479 2
           WRITE(NOUT,*) 'igo,iend,nchar: ',igo,iend,nchar
           CALL ERRT(102,'TOO MANY REGISTERS REQUESTED, LIMIT',IT)
d490 1
a490 1
      IF (LENT .GT. 80) THEN
d495 1
a495 1
      ELSEIF (LENR .GT. 80) THEN
d500 1
a500 1
      ELSEIF (LENADD .GT. 92) THEN
d508 1
a508 1
      IF (IBANK .EQ. 1 .AND. IREG .GT. IMAXRSTRQ1) THEN
d516 1
a516 1
      ELSEIF (IENDQAT .GE. MAXRSTRQ) THEN
d599 1
a599 1
      IF (IREG .LE. 0) THEN
d609 1
a609 1
            IF ((STRING(IGO:IGO) .EQ. '_') .AND.
d612 1
a612 1
                IF (IBANK .GT. 1) THEN
d658 1
a658 1
      IF (IREG .LE. 0) THEN
d663 1
a663 1
      ELSEIF (IREG .GT. IENDREGNUM(ISTOP)) THEN
d702 1
a702 1
      IF (IREG .LE. 0) THEN
d707 1
a707 1
      ELSEIF (IREG .GT. IENDREGNUM(ISTOP)) THEN
d765 1
a765 1
!      if (ireg .gt. 0) then
d778 1
a778 1
!      if (ireg .gt. 0) then
d787 1
a787 1
      IF (IREG .LE. 0) THEN
d798 1
a798 1
            IF ((STRING(IGO+1:IGO+1) .EQ. '_') .AND.
d869 1
a869 1
      IF (FCHAR(1:2) .EQ. 'UD') THEN
d876 1
a876 1
      IF (TYPE .EQ. 'GLO') THEN
d884 1
a884 1
         IF (IREG .LE. 0) THEN
d889 1
a889 1
      ELSEIF (TYPE .EQ. 'LOC') THEN
d894 1
a894 1
         IF (IREG .LE. 0) THEN
d900 1
a900 1
      ELSEIF (TYPE .EQ. 'RED') THEN
d905 7
a911 2
         IF (IREG .LE. 0) THEN
C           NOT FOUND IN LOCAL BANK, USE GLOBAL VARIABLE
d913 10
a922 2
            CALL REG_NEW(IBANK,STRING(IGO:IEND),0.0,IREG,IRTFLG)
            ISGLOBAL = .TRUE.
d943 1
a943 1
C    REG_GET_SEL(IBANK,STRING,CREATE,UNUSED,NREG,IRTFLG)
d952 1
a952 1
C                      UNUSED    UNUSED                            SENT
d958 1
a958 1
      SUBROUTINE REG_GET_SEL(IBANK,STRING,CREATE,UNUSED,NREG,IRTFLG)
d967 1
a967 1
      LOGICAL            :: CREATE,UNUSED,ISGLOBAL
d978 1
a978 1
         IF (IGO .LE. 0 .OR. IEND .LE. IGO) THEN
d984 1
a984 1
         IF (IGO  .GT. 0 .AND. IEND .LE. IGO) THEN
d1010 1
a1010 1
         IF (NREG .GT. MAXNSEL) THEN
d1026 1
a1026 1
            CALL ERRT(102,'TOO MAY REGISTERS ON THIS LINE',NREG)
d1029 1
a1029 1
         stop
d1036 2
a1037 2
            WRITE(NOUT,*) 'SHOULD HAVE BEEN VARIABLE',igo,iend
	    CALL ERRT(100,'REG_GET_SEL',NE)
d1041 2
a1042 1
         IF (IBANK .EQ. 1) THEN
d1046 5
d1052 1
d1060 1
a1060 1
         IF (IFIRST .GT. NCHAR) EXIT
d1066 1
a1066 1
      RETURN
d1097 1
a1097 1
      IF (NREG .GT. NLEN) THEN
a1106 1
      RETURN
d1165 1
a1165 1
      IF (NVALS .GE. IGO+0) THEN
d1167 1
a1167 1
         IF (NVALS .GE. IGO+1) THEN
d1169 1
a1169 1
            IF (NVALS .GE. IGO+2) THEN
d1171 1
a1171 1
               IF (NVALS .GE. IGO+3) THEN
d1173 1
a1173 1
                  IF (NVALS .GE. IGO+4) THEN
d1212 1
a1212 1
      IF (NREG .GT. 0) THEN
d1218 1
a1218 1
         IF (NREG .LT. NSEL_USED) THEN
d1293 1
a1293 1
      IF (IXREG .GE. 0) THEN
d1332 1
a1332 1
      IF (IXREG .GE. 0) THEN
d1393 1
a1393 1
C	           NLIST   NUMBER OF ELEMENTS IN ARRAY            (RET.)
d1418 1
a1418 1
        IF (K .LE. 0) THEN
d1422 2
a1423 2
	   CALL ERRT(100,'REG_DOC_PARSE',NE)
	   RETURN
d1428 1
a1428 1
        IF (CTEMP .EQ. '/') THEN
d1434 1
a1434 1
	ELSEIF (CTEMP .EQ. '[') THEN
d1442 1
a1442 1
	     CALL ERRT(100,'REG_DOC_PARSE',NE)
d1451 1
a1451 1
          IF (NSEL_USED .GT. 1) THEN
d1458 1
a1458 1
	ELSEIF (ISCHAR(CTEMP)) THEN
d1471 1
a1471 1
	      WRITE(NOUT,90) CCHAR(1:ILEN)
d1473 1
a1473 1
	      CALL ERRT(100,'REG_DOC_PARSE',NE)
d1478 3
a1480 3
        IF (IKEY .EQ. 0) THEN
	   CALL ERRT(101,'*** INVALID KEY NUMBER: 0',NE)
	   RETURN
d1512 1
a1512 1
      IF (NSEL_USED .GE. IGO+0) THEN
d1515 1
a1515 1
         IF (NSEL_USED .GE. IGO+1) THEN
d1517 1
a1517 1
            IF (NSEL_USED .GE. IGO+2) THEN
d1519 1
a1519 1
               IF (NSEL_USED .GE. IGO+3) THEN
d1521 1
a1521 1
                  IF (NSEL_USED .GE. IGO+4) THEN
d1570 1
a1570 1
      IF (RSTRQ(IGO:IGO) .EQ. '_') THEN
a1634 16
#ifdef sgi
C     SETS NAME FOR ASSIGN OBJECT FILE
      CALL SETENV('FILENV','jnkASSIGN1',IRTFLG)

C     CLEAR ANY EXISTING ASSIGN OBJECT FILE
      CALL ASNRM(IRTFLG)

C     INITIALIZE THE ASSIGN OBJECT FILE FOR WRITING
      MSG = '-s u -a ' // PIPENAME

      CALL ASNUNIT(LUNREGPIPE,MSG,IRTFLG)
      IF (IRTFLG .NE. 0) THEN
         CALL ERRT(102,'ASNUNIT TO SET PIPE, RETURNS:',IER)
         RETURN
      ENDIF
#endif
d1681 1
a1681 1
      IF (INOT .EQ. 0) THEN
d1756 1
a1756 1
         IF (IGO .EQ. 0 .AND. CTEMP .EQ. '[') THEN
d1760 1
a1760 1
         ELSEIF (CTEMP .EQ. ';' .AND. IGO .GT. 0) THEN
d1767 1
a1767 1
        ELSEIF (CTEMP .EQ.  ']' .AND. IGO .GT. 0) THEN
d1772 1
a1772 1
         ELSEIF (CTEMP .EQ. ';') THEN
d1776 1
a1776 1
         ELSEIF (IGO .GT. 0 .AND. CTEMP .LT. CHAR(31)) THEN
d1783 1
a1783 1
         ELSEIF (CTEMP .LT. CHAR(31)) THEN
d1825 1
a1825 1
         IF (IGO .EQ. 0 .AND. CTEMP .EQ. '[') THEN
d1829 1
a1829 1
         ELSEIF (CTEMP .EQ. ';') THEN
d1833 1
a1833 1
        ELSEIF (CTEMP .EQ.  ']' .AND. IGO .GT. 0) THEN
d1838 1
a1838 1
         ELSEIF (IGO .GT. 0 .AND. CTEMP .LT. CHAR(31)) THEN
d1845 1
a1845 1
         ELSEIF (CTEMP .LT. CHAR(31)) THEN
d1894 1
a1894 1
      IF (IGO .LE. 0) THEN
d1907 1
a1907 1
      IF (IEND .LT. IGO) RETURN
@


1.39
log
@REG_FIND_IREG added,
@
text
@d20 4
a23 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
d34 1
a34 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a35 1
C=*                                                                    *
@


1.38
log
@GLO VAR SET BUG
@
text
@d17 1
d50 3
d369 4
d403 7
d744 1
a744 1
C     COMMON NEEDED FOR NOUT
d747 4
d754 1
a754 1
      NCHAR = LEN(STRING)
d764 7
d775 11
a785 1
      
d823 98
d924 3
a926 2
C REG_GET_SEL.F   ADAPTED FROM READP.FOR FOR CHAR. AUG 89 ARDEAN LEITH
C                 NATIVE []                       NOV 2005 ARDEAN LEITH
d935 1
a935 1
C    PARAMETERS:       IBANK     STACK LEVEL                     (SENT)
d948 1
a948 1
C     COMMON NEEDED FOR NALPH
d953 1
a953 2

      LOGICAL :: CREATE,UNUSED
d1027 8
a1034 8
         CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)

         IF (IREG .LE. 0) THEN
C           NOT AN EXISTING REGISTER VARIABLE, MAY NEED TO CREATE IT
            IF (.NOT. CREATE)  RETURN

            CALL REG_NEW(IBANK,STRING(IGO:IEND),0.0,IREG,IRTFLG)
            IF (IRTFLG .NE. 0) RETURN  ! NO SUCH REG???
@


1.37
log
@REMOVED REDUNDANT ERROR MSG
@
text
@d16 1
d19 5
a23 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
d25 1
a25 6
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d30 1
a30 1
C=* This program is distributed in the hope that it will be useful,    *
d36 1
a36 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d729 1
a729 1
C     COMMON NEEDED FOR NALPH
d732 2
a733 2
      CHARACTER(LEN=*)   :: STRING
      LOGICAL :: CREATE,ISDIGI
d744 6
d751 2
d756 1
@


1.36
log
@VALUE    = RVAL bug on sgi only
@
text
@d15 1
d19 1
a19 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a592 2
            WRITE(NOUT,*)' *** UNDEFINED REGISTER VARIABLE: ',
     &                   STRING(IGO:IEND)
a771 2
                WRITE(NOUT,*)' ***  UNDEFINED REGISTER VARIABLE: ',
     &                   STRING(IGO:IEND)
@


1.35
log
@register pipe fixed on linux with byteswap
@
text
@d1551 1
a1551 4
      ! 1-2-3-4 =  1.18124345803187e-38 f
      ! 2-1-4-3 = -2.42592790143912e-41 f
      ! 3-4-1-2 = -2.4259279E-41  --> -1.65173079075814e-19 Ff
      ! 4-3-2-1 =  1.1812435E-38  --> 321  f  CORRECT
a1553 2
      RVAL     = VALUE

a1564 1

@


1.34
log
@xlrf90 optimizer bug
@
text
@d93 3
a98 3
C    REG_PIPE(CXNUM,IRTFLG)
C    PURPOSE: OPENS PIPE FOR REGISTERS  
C
d1462 1
a1462 1
C    REG_PIPE(CXNUM,IRTFLG)
d1481 1
d1484 1
d1487 1
d1535 4
d1551 23
d1576 3
a1578 1
         WRITE(LUNREGPIPE,IOSTAT=IRTFLG) IREG,VALUE
d1583 7
a1589 2
C        THIS IS NECESSARY, DO NOT ASK ME WHY!
         WRITE(LUNREGPIPE,IOSTAT=IRTFLG) CHAR(10)
d1591 1
a1591 1
         CALL ERRT(101,'NO PIPE OPEN',NE)
a1597 1

@


1.33
log
@undefined registers change
@
text
@a1710 3
      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

d1723 5
a1727 1
      IF (IGO .LE. 0) RETURN
@


1.32
log
@accepts undefined registers, << in rstrq gone
@
text
@d594 1
d596 1
d606 4
a609 1
                WRITE(NOUT,*)' *** PLEASE FIX THIS AS IT WILL NOT BE',
a610 2
            ELSE 
                CALL ERRT(8,STRING(IGO:IEND),NE)
d612 1
a754 2
            WRITE(NOUT,*)' ***  UNDEFINED REGISTER VARIABLE: ',
     &                   STRING(IGO:IEND)
d764 3
a766 1
                WRITE(NOUT,*)'      OK NOW BUT USE OF UNDEFINED ',
d773 2
@


1.31
log
@get_name fixed
@
text
@d14 1
a218 1
#ifdef SP_NEWTEST
a221 1
#endif
a471 2
      LENADD  = LENT + LENR + 1
#ifdef SP_NEWTEST
a472 1
#endif
a525 1
#ifdef SP_NEWTEST
a528 4
#else
      RSTRQ(IGOQ:IGOQ+LENADD-1) = '<' // NAME(2:LENT-1) // '>' // 
     &                                   CREG(1:LENR)   // '<' 
#endif
d574 1
d592 1
a592 1
            WRITE(NOUT,*)'  UNDEFINED REGISTER VARIABLE: ',
d594 15
a608 1
            CALL ERRT(8,STRING(IGO:IEND),NE)
d733 1
a733 1
      LOGICAL :: CREATE
d750 2
a751 1
            WRITE(NOUT,*)'  UNDEFINED REGISTER VARIABLE: ',
d753 18
a770 2
c           CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)
            CALL ERRT(8,STRING(IGO:IEND),NE)
d1396 1
d1408 9
a1416 2
         NAME = 'X' // RSTRQ(IGO+1:IEND) // CHAR(0)
         NLET = IEND - (IGO + 1) + 2 
d1418 1
@


1.30
log
@new error msgs
@
text
@d13 1
d78 1
a78 1
C    PURPOSE:  COPIES LISTIN REGISTER VALUES TO LISTOUT REGISTERS
d81 1
a81 1
C    PURPOSE:     SETS A REGISTER SPECIFIED IN NSELREG(NVAL) TO VALUE   
d84 1
a84 1
C    PURPOSE:     SETS REGISTERS SPECIFIED IN NSEL TO VALUES   
d86 2
a87 2
C    REG_GET_NAME(NGOT,ILIST,IRTFLG)
C    PURPOSE:     REVERSE LOOKUP OF REGISTER(S) SPECIFIED IN NSELREG 
d90 1
a90 1
C    PURPOSE:     GETS TOTAL CURRENT NUMBER OF REGISTERS 
d93 1
a93 1
C    PURPOSE:    SENDS REGISTER VALUE DOWN LUNREGPIPE   
d96 1
a96 1
C    PURPOSE:     OPENS PIPE FOR REGISTERS  
d99 1
a99 1
C    PURPOSE:     RESIZES   REGISTER SPACE   
d195 4
a198 4
         IGORSTRQ(1)   = 1
         IENDRSTRQ(1)  = 0
         IGOREGNUM(1)  = 1
         IENDREGNUM(1) = 0
d200 2
a201 2
         IMAXREGNUM1   = NUMREGISG_ORIG 
         IMAXRSTRQ1    = MAXRSTRQG
d218 6
d226 1
d474 4
d530 5
d537 1
d1353 1
a1353 1
C    REG_GET_NAME(NGOT,ILIST,IRTFLG)
d1355 1
a1355 1
C    PURPOSE:     REVERSE LOOKUP OF REGISTER(S) SPECIFIED IN NSELREG 
d1357 3
a1359 2
C    PARAMETERS:  IPOS      REGISTER POSITION IN NSELREG       (SENT.)
C                 NAME      REGISTER NAME IN NSELREG           (RET.)
d1364 1
a1364 1
      SUBROUTINE REG_GET_NAME(IPOS,NAME,IRTFLG)
a1367 1
      INCLUDE 'CMBLOCK.INC'
d1374 1
a1374 3
      IREG = NSELREG(IPOS)

      CALL INTTOCHAR(IPOS,SEARCH(2:),NLET,1)
d1379 3
a1381 2
      IGO  = IGORSTRQ(ISTOP) + ILOC - 1 + NLET + 3
      IEND = INDEX(RSTRQ(IGO:),'>')
d1384 2
a1385 1
        NAME = 'X' // RSTRQ(IGO+1:IGO+IEND-2) // CHAR(0)
d1387 2
a1388 1
         NAME = '[' // RSTRQ(IGO:IGO+IEND-2) // ']'
d1391 1
@


1.29
log
@decreased rstq length and changed var. delimter
@
text
@d12 1
d102 2
a103 2
C                  OPERATION LINE. PK X12,X20 WOULD RETURN 13,21 IN 
C                  NSELREG(1) AND NSELREG(2)
d188 1
a188 1
         CALL ERRT(102,'ILLEGAL BANK:',IBANK)
d584 1
a584 1
            CALL ERRT(101,'BAD REGISTER VARIABLE',NE)
d728 2
a729 2
       CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)
            CALL ERRT(101,'BAD REGISTER VARIABLE',NE)
d1216 1
d1237 1
d1268 1
d1566 4
d1628 2
@


1.28
log
@debug
@
text
@d10 2
a11 2
C                    INCREASED MAXRSTRQ               JAN 06 A. Leith
C                    GETNEXTVAR BUG                   JAN 06 A. Leith
d130 2
a131 2
         INTEGER, PARAMETER      :: MAXRSTRQG = 2400
         INTEGER, PARAMETER      :: MAXRSTRQ  = 24000
d137 1
a137 1
         INTEGER, PARAMETER      :: NUMREGIS_ORIG  = 20000
d379 1
a379 1
         CALL ASSOCARRAY(RSTRQ(IGOQ:IENDQ),NAMET(1:LENT),
d464 2
a465 2
      LENADD  = 2 * LENT + LENR + 1
      IENDQAT = IENDRSTRQ(IBANK) + LENADD
d477 1
a477 1
      ELSEIF (LENADD .GT. 172) THEN
d515 1
a515 1
      IGOQ = IENDRSTRQ(IBANK) + 1
d517 2
a518 3
      RSTRQ(IGOQ:IGOQ+LENADD-1) = '<'  // NAME(2:LENT-1) // '>' // 
     &                                    CREG(1:LENR) // 
     &                            '</' // NAME(2:LENT-1)  // '>' 
d785 23
d1620 57
@


1.27
log
@maxseln trap
@
text
@d48 1
a48 1
C    REG_NEW(IBANKT,NAME,VALUE,NEEDERRT,IREG,IRTFLG)
d69 1
a69 1
C    REG_GET_SEL(IBANK,STRING,CREATE,ERROR_OK,NREG,IRTFLG)
d132 1
a132 1
         CHARACTER(LEN=MAXRSTRQ) :: RSTRQ
d263 1
a263 1

d292 1
a292 1
C    REG_BANK_OK(IBANKIN,IBANKOUT,ALLBANK,IRTFLG)
d297 1
a297 2
C                 IBANKOUT  STACK LEVEL (0 IS CURRENT ISTOP)    (SENT)
C                 ALLBANK   WANT TO CHECK ALL BANKS             (RET.)
d302 1
a302 1
      SUBROUTINE REG_BANK_OK(IBANKIN,IBANKOUT,ALLBANK,IRTFLG)
a309 3
      LOGICAL :: ALLBANK

      ALLBANK  = .FALSE.
a311 1
         ALLBANK  = .TRUE. ! UNUSED CAPABILITY FOR ALLBANK
a360 1
      LOGICAL            :: ALLBANK
d369 1
a369 1
      CALL REG_BANK_OK(IBANKT,IBANK,ALLBANK,IRTFLG)
a385 23

#ifdef NEVER
         ELSEIF (ALLBANK .AND. IBANK .GT. 1) THEN
C           SEARCH ALL BANKS DOWN TO ONE
            DO IBANK=IBANK-1,1,-1

               IGOQ   = IGORSTRQ(IBANK)
               IENDQ  = IENDRSTRQ(IBANK)
               IRTFLG = 0
               IREG   = 0
               IF (IENDQ .GT. IGOQ) THEN
C                 SEARCH FOR THIS VARIABLE AT THIS LEVEL
                  CALL ASSOCARRAY(RSTRQ(IGOQ:IENDQ),NAMET(1:LENT),
     &                   IGO,IEND,IRTFLG)
                  IF (IRTFLG .EQ. 0) THEN
C                    VARIABLE EXISTS, FIND REGISTER NUMBER
                     READ(RSTRQ(IGOQ+IGO-1:IGOQ+IEND-1),*) IREG
                     VALUE = REGVALUES(IREG)
                     EXIT
                  ENDIF
               ENDIF
            ENDDO
#endif
d400 1
a400 1
C    REG_NEW(IBANK,NAME,VALUE,NEEDERRT,IREG,IRTFLG)
a406 1
C                 NEEDERRT  ERRT CALL FLAG                      (SENT.)
d414 1
a414 1
      SUBROUTINE REG_NEW(IBANKT,NAME,VALUE,NEEDERRT,IREG,IRTFLG)
a419 1
      LOGICAL           :: NEEDERRT
a421 1
      LOGICAL           :: ALLBANK
d426 1
a426 1
      CALL REG_BANK_OK(IBANKT,IBANK,ALLBANK,IRTFLG)
d444 1
a444 1
         IT     = NUMREGIS
d579 1
a579 2
            CALL REG_NEW(IBANK,STRING(IGO:IEND),
     &                   VALUE,.TRUE.,IREG,IRTFLG)
d723 1
a723 1
            CALL REG_NEW(IBANK,STRING(IGO:IEND),0.0,.TRUE.,IREG,IRTFLG)
d744 1
a744 1
C    REG_GET_SEL(IBANK,STRING,CREATE,ERROR_OK,NREG,IRTFLG)
d753 1
a753 1
C                      ERROR_OK  FLAG TO RETURN UP TO ERROR        SENT
d759 1
a759 1
      SUBROUTINE REG_GET_SEL(IBANK,STRING,CREATE,ERROR_OK,NREG,IRTFLG)
d769 1
a769 1
      LOGICAL :: CREATE,ERROR_OK
d777 1
a777 1
c        GET VAR. (CHAR. STRING DELIMITED BY A ", ()") FROM STRING
d780 1
a780 1
         IF (IGO .LE. 0) THEN
a817 2
         ELSE
            CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)
d820 2
d826 1
a826 1
            CALL REG_NEW(IBANK,STRING(IGO:IEND),0.0,.TRUE.,IREG,IRTFLG)
d1502 1
a1502 1
C           ARE STARTING A VAR, SET IGO 
d1505 5
a1509 2
         ELSEIF (CTEMP .EQ. ';') THEN
C           START OF COMMENT, THIS IS LINE END
d1517 4
@


1.26
log
@more debug output
@
text
@d116 2
a117 2
C        DANGER MAXNSEL IS ALSO SET IN spider.f!! 
         INTEGER, PARAMETER          :: MAXNSEL = 20  ! REGISTER LIST 
d131 1
a131 1
         INTEGER, PARAMETER      :: MAXRSTRQ  = 44000
d822 23
a854 17
         if (nreg.gt.10000) then
C            probable error
       write(nout,*) ' BANK:      ',IBANK
       write(nout,*) ' IGORSTRQ:  ',IGORSTRQ
       write(nout,*) ' IGOREGNUM: ',IGOREGNUM
       write(nout,*) ' IENDREGNUM: ',IENDREGNUM
       do i=2401,3900,60
          write(nout,*) I,' RSTRQ(I:I+60): ',RSTRQ(I:i+59)
       enddo
       write(nout,*) 'RSTRQ: ',RSTRQ(IGORSTRQ(IBANK):IGORSTRQ(IBANK)+60)

       WRITE(NOUT,*) 'have >10000 registers in nselreg:'
       WRITE(NOUT,*) 'GETNEXVAR RETURNED:',STRING(IGO:IEND)
       WRITE(NOUT,*) 'igo,iend,nchar: ',igo,iend,nchar
       stop
         endif

a944 50
C--*************************** GETNEXTVAR *****************************

      SUBROUTINE GETNEXTVAR(STRING,IFIRST,IGO,IEND,IRTFLG)

C     COMMON NEEDED FOR WRITE
      INCLUDE 'CMBLOCK.INC'

C     VAR DELIMITERS ARE []

      CHARACTER(LEN=*) :: STRING
      CHARACTER(LEN=1) :: CTEMP

C     SET DEFAULT RETURN VALUES
      IGO       = 0
      IEND      = 0
      IRTFLG    = 0

C     FIND LAST CHAR POSITION IN STRING
      ILAST = LEN(STRING)

      DO I = IFIRST,ILAST
         CTEMP = STRING(I:I)

         IF (IGO .EQ. 0 .AND. CTEMP .EQ. '[') THEN
C           ARE STARTING A VAR, SET IGO 
            IGO  = I

         ELSEIF (CTEMP .EQ. ';') THEN
C           START OF COMMENT, THIS IS LINE END
            EXIT

        ELSEIF (CTEMP .EQ.  ']' .AND. IGO .GT. 0) THEN
C           ARE ENDING A VAR.
            IEND = I
            EXIT

         ELSEIF (IGO .GT. 0 .AND. CTEMP .LT. CHAR(31)) THEN
C           ILLEGAL CHAR INSIDE A REG. VAR. NAME
            WRITE(NOUT,*)'  *** ILLEGAL CHAR.: ',CTEMP,' AT POSITION: ',
     &           I,' IN REGISTER VAR. STRING: ',STRING
            CALL ERRT(101,'BAD CHAR. IN REGISTER VAR. NAME',NE)
            IRTFLG = I
         ENDIF
      ENDDO

C     VARIABLE FOUND OR RAN OFF END OF STRING

      RETURN
      END

d1511 113
@


1.25
log
@more debug output
@
text
@d477 13
a489 1
         CALL ERRT(102,'TOO MANY REGISTERS REQUESTED, LIMIT',IT)
a526 7
       write(6,*) 'BANK:      ',IBANK
       write(6,*) 'IGORSTRQ:  ',IGORSTRQ
       write(6,*) 'IENDRSTRQ: ',IENDRSTRQ
       write(6,*) 'IENDRSTRQ: ',IENDRSTRQ
       write(6,*) 'RSTRQ(1:6): ',RSTRQ(1:60)
       write(6,*) 'RSTRQ(1000:1060): ',RSTRQ(1000:1060)
       write(6,*) 'RSTRQ: ',RSTRQ(IGORSTRQ(IBANK):IGORSTRQ(IBANK)+60)
d528 12
d832 1
a832 1
         if(nreg.gt.3000) then
d834 13
a846 4
            WRITE(NOUT,*) 'have >1000 registers in nselreg:'
            WRITE(NOUT,*) 'GETNEXVAR RETURNED:',STRING(IGO:IEND)
           WRITE(NOUT,*) 'igo,iend,nchar: ',igo,iend,nchar
           stop
@


1.24
log
@added more error output
@
text
@d519 2
a520 2
       write(6,*) 'RSTRQ: ',RSTRQ(1:60)
       write(6,*) 'RSTRQ: ',RSTRQ(1000:1060)
d807 4
a810 4
            REGNAME(1:2) = '[_'
            CALL INTTOCHAR(IXREG,REGNAME(3:),NLET,1)
            REGNAME(NLET+1:NLET+1) = ']'
            CALL REG_FIND(IBANK,REGNAME(1:NLET+1),VALUE,IREG,IRTFLG)
d814 9
@


1.23
log
@debug
@
text
@d11 1
d487 18
d585 2
a586 6
      CALL GETNEXTVAR(STRING,IFIRST,.FALSE.,IGO,IEND,IRTFLG)
      IF (IRTFLG .NE. 0) THEN
          WRITE(NOUT,*) '  STRING: ',STRING
          CALL ERRT(101,'BAD CHAR. IN REGISTER VAR. STRING',NE)
          RETURN
      ENDIF
d731 2
a732 6
      CALL GETNEXTVAR(STRING,IFIRST,.FALSE.,IGO,IEND,IRTFLG)
      IF (IRTFLG .NE. 0) THEN
          WRITE(NOUT,*) '  STRING: ',STRING
          CALL ERRT(101,'BAD CHAR. IN REGISTER VAR. STRING',NE)
          RETURN
      ENDIF
a734 1

d744 1
a744 1
      CALL REG_FIND(IBANK,STRING(IGO:IEND),VALUE,IREG,IRTFLG)
d794 3
a796 12
         CALL GETNEXTVAR(STRING,IFIRST,.FALSE.,IGO,IEND,IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            IF (ERROR_OK) THEN
C              ENOUGH VARIABLES FROM STRING HAVE BEEN EVALUATED
               IRTFLG = 0
               EXIT
            ELSE
               WRITE(NOUT,*) 'REGISTER VAR. STRING: ',STRING
               CALL ERRT(101,'BAD CHAR. IN REGISTER VAR. STRING',NE)
            ENDIF
            RETURN
         ELSEIF (IGO .LE. 0) THEN
d906 4
a909 1
      SUBROUTINE GETNEXTVAR(STRING,IFIRST,NOBRAKOK,IGO,IEND,IRTFLG)
d911 1
a911 1
C     VAR DELIMITERS ARE [], IF (NOBRAKOK) VAR. DELIMITER IS DIGIT
a914 1
      LOGICAL          :: NOBRAKOK,ISDIGI,ISNUMONLY
a919 1
      ISNUMONLY = .FALSE.
a925 1
         INOT  = VERIFY(CTEMP,' 	,()')
a930 5
         ELSEIF (IGO .EQ. 0 .AND. ISDIGI(CTEMP) .AND. NOBRAKOK) THEN
C           ARE STARTING A NUMBER STRING, SET IGO 
            IGO  = I
            ISNUMONLY = .TRUE.

d935 1
a935 6
         ELSEIF (IGO .EQ. 0 .AND. INOT .GT.  0) THEN
C           BAD CHAR BEFORE VARIABLE
C            IRTFLG = -1
             CONTINUE

         ELSEIF (CTEMP .EQ.  ']' .AND. IGO .GT. 0) THEN
d940 6
a945 9
         ELSEIF (ISNUMONLY .AND. .NOT. ISDIGI(CTEMP))THEN
C           ARE ENDING A NUMBER STRING, SET IGO 
            IEND = I

         ELSEIF (CTEMP .LT. CHAR(31)) THEN
C           BAD CHAR INSIDE A VAR.
            IRTFLG = 1
            EXIT

@


1.22
log
@MAXSTRQ increased
@
text
@d496 8
@


1.21
log
@global
@
text
@d10 1
d130 1
a130 1
         INTEGER, PARAMETER      :: MAXRSTRQ  = 24000
@


1.20
log
@ALLBANK added
@
text
@d115 3
a117 3
         INTEGER, PARAMETER            :: MAXNSEL = 20  ! REGISTER LIST 
         INTEGER,   DIMENSION(MAXNSEL) :: NSELREG 
         INTEGER                       :: NSEL_USED = 0
d122 3
a124 2
         INTEGER, DIMENSION(MAXPRC) :: IGORSTRQ, IENDRSTRQ
         INTEGER, DIMENSION(MAXPRC) :: IGOREGNUM,IENDREGNUM
d127 3
a129 1
         INTEGER, PARAMETER      :: MAXRSTRQ = 24000
d132 6
a137 2
         INTEGER, PARAMETER      :: NUMREGIS_ORIG = 20000
         INTEGER                 :: NUMREGIS   = 0
a161 4
      CHARACTER :: NULL

      NULL = CHAR(0)

d176 1
a176 1
         NUMREGIS = NUMREGIS_ORIG
d179 3
a181 2
         IGOREGNUM  = 0
         IENDREGNUM = 0
d190 1
a190 1
C        INITIALIZE MAIN BANK
d196 10
d207 1
a207 1
C        SECOND,..... BANK
d224 59
d313 2
a314 2
         IBANKOUT = ISTOP
         ALLBANK  = .TRUE.
d391 1
d412 1
d465 8
a472 1
      IF (IREG .GT. NUMREGIS) THEN
d485 10
a494 2
      IF (IENDQAT .GE. MAXRSTRQ) THEN
C        OVER-RUN OF RSTRQ ARRAY
a1416 53

C++*********************************************************************
C
C REG_PIPE                         NEW           JULY 2001 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_PIPE(NAME,IRTFLG)
C
C    PURPOSE:    SENDS REGISTER VALUE DOWN LUNREGPIPE   
C
C    PARAMETERS:  NAME  REGISTER NAME                           (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*********************************************************************

      SUBROUTINE REG_PIPE(NAME,IRTFLG)

      USE REG_STUFF

      CHARACTER(LEN=*) :: NAME
      CHARACTER(LEN=8) :: CREG

      INOT = VERIFY(NAME,'0123456789')
      IF (INOT .EQ. 0) THEN
C        GOT AN OLD FASHIONED NUMBER
         CREG = '[_' // NAME // ']' // CHAR(0)
         CALL REG_GET_VAR(0,CREG,.FALSE.,
     &                    VALUE,IREG,IENDVAR,IERR)
      ELSE
         CALL REG_GET_VAR(0,NAME,.FALSE.,
     &                    VALUE,IREG,IENDVAR,IERR)
      ENDIF
      IF (IRTFLG .NE. 0) RETURN

      IF (REGPIPE) THEN
C        WRITE REG NUMBER & VALUE TO NAMED PIPE
         WRITE(LUNREGPIPE,IOSTAT=IRTFLG) IREG,VALUE
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'PIPING REGISTER',IREG)
            RETURN
         ENDIF
C        THIS IS NECESSARY, DO NOT ASK ME WHY!
         WRITE(LUNREGPIPE,IOSTAT=IRTFLG) CHAR(10)
      ELSE
         CALL ERRT(101,'NO PIPE OPEN',NE)
         IRTFLG = 1
      ENDIF
 
      RETURN
      END


a1470 1

d1473 1
a1473 1
C REG_REINIT                    NEW            AUG 2000 ARDEAN LEITH
d1477 1
a1477 1
C    REG_REINIT()
d1479 1
a1479 1
C    PURPOSE:     RESIZES   REGISTER SPACE   
d1481 2
a1482 1
C    PARAMETERS:  IRTFLG    ERROR FLAG                          (RET.)
d1484 1
a1484 4
C    YES, I KNOW THAT IT SHOULD BE WRITTEN USING POINTERS BUT
C    I DOUBT ANYONE WILL EVER USE THIS!! al
C
C--*******************************************************************
d1486 1
a1486 1
      SUBROUTINE REG_REINIT(IRTFLG)
d1490 2
a1491 2
      INCLUDE 'CMBLOCK.INC'
      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: REGVALUEST
d1493 10
a1502 5
      CALL REG_GET_NUMS(NREG,NCHAR)
      WRITE(NOUT,90)NREG,NCHAR  
90    FORMAT(' CURRENT REGISTERS: ',I7,' NAME CHARACTERS: ',I8)
  
      CALL RDPRI1S(NREGN,NOT_USED,'NUMBER OF REGISTERS WANTED',IRTFLG)
d1505 3
a1507 2
      IF (NREGN .GT. NREG) THEN
         ALLOCATE (REGVALUEST(NREG), STAT=IRTFLG)
d1509 1
a1509 1
            CALL ERRT(102,'UNABLE TO INCREASE REGISTERS:',NREG)
d1512 5
a1516 15

         REGVALUEST(1:NUMREGIS) = REGVALUES
         DEALLOCATE(REGVALUES)

         ALLOCATE (REGVALUES(NREGN), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'UNABLE TO INCREASE REGISTERS:',NREGN)
            RETURN
         ENDIF

         REGVALUES(1:NUMREGIS) = REGVALUEST
         DEALLOCATE(REGVALUEST)
         
         NUMREGIS = NREGN

a1517 2

      IRTFLG = 0
d1521 2
@


1.19
log
@REG_LIST_COPYbug
@
text
@d217 1
a217 1
C    REG_BANK_OK(IBANKIN,IBANKOUT,IRTFLG)
d223 1
a223 1
C                 VALUE     VALUE                               (RET.)
d228 1
a228 1
      SUBROUTINE REG_BANK_OK(IBANKIN,IBANKOUT,IRTFLG)
d236 7
a242 1
      IF (IBANKIN .LT. 0) THEN
d291 1
d300 1
a300 1
      CALL REG_BANK_OK(IBANKT,IBANK,IRTFLG)
d317 21
d376 1
d381 1
a381 1
      CALL REG_BANK_OK(IBANKT,IBANK,IRTFLG)
@


1.18
log
@native named registers
@
text
@d767 1
a767 1
      DO I = I,NL
@


1.17
log
@named register support
@
text
@d4 1
a4 1
C REG_SET.F                                           AUTHOR: A. LEITH
d9 1
d40 2
a41 2
C    REG_BUILD
C    PURPOSE:       TO BUILD A SET OF SPIDER REGISTERS
d43 2
a44 2
C    REG_CHK(IREG,NEEDERRT,IRTFLG)
C    PURPOSE:       CHECK IREG FOR VALIDITY
d46 5
a50 2
C    REG_PIPE(CXNUM,IRTFLG)
C    PURPOSE:       OPENS PIPE FOR REGISTERS   
d52 2
a53 1
C    REG_GET_NUMS(IREGS)
d55 2
a56 2
C    REG_SET(IREG,VALUE,NEEDERRT,IRTFLG)
C    PURPOSE:       TO SET A VALUE IN A SPIDER REGISTER.
d58 2
a59 1
C    REG_SET_NSEL(IGO,VAL0,VAL1,VAL2,VAL3,VAL4,IRTFLG)
d61 2
a62 1
C    REG_SET_NSELA(NREG,VALUES,IRTFLG)
d64 2
a65 2
C    REG_SET_BANK(IBANK,IRTFLG)
C    PURPOSE:     COPIES CURRENT REGISTERS INTO BANK --> IBANK   
d67 2
a68 2
C    REG_SET_BANKED(IBANK,IREGBANK,RVAL,IRTFLG)
C    PURPOSE:     COPIES A SINGLE RVAL INTO A BANKED REGISTER. 
d70 2
a71 1
C    REG_GET_USED(NREG)
d73 2
a74 2
C    REG_GET(IREG,VALUE,NEEDERRT,IRTFLG)
C    PURPOSE:       TO GET A VALUE FROM A SPIDER REGISTER.
d76 2
a77 2
C    REG_GET_BANK(IBANK,IRTFLG)
C    PURPOSE:     COPIES A WHOLE BANK OF REGISTERS INTO ACTIVE BANK 
d79 2
a80 2
C    REG_GET_BANKED(IBANK,IREGBANK,RVAL,IRTFLG)
C    PURPOSE:     COPIES A SINGLE BANKED REGISTER INTO RVAL. 
d82 2
a83 1
C    REG_GET_NSEL(IGO,VAL0,VAL1,VAL2,VAL3,VAL4,IRTFLG)
d85 2
a86 1
C    REG_SAVE(IRTFLG)
d88 2
a89 1
C    REG_UNSAVE(IRTFLG)
d91 2
a92 1
C    REG_READPQ(STRING)
d94 3
d105 1
a105 1
      MODULE REG_INFO
d109 1
a109 5
         INTEGER :: NUMREGIS  = 0
         INTEGER :: NUMREGIST = 0
         INTEGER :: NSEL_USED = 0
         INTEGER, PARAMETER :: MAXNSEL = 20
         INTEGER, PARAMETER :: NUMREGLOOP  = 26
d111 1
a111 1
         LOGICAL :: REGPIPE  = .FALSE.
d114 2
a115 4
C        DANGER MAXPRC IS ALSO SET IN spider.f!!
         INTEGER, PARAMETER :: MAXPRC = 20

         DOUBLE PRECISION,    ALLOCATABLE, DIMENSION(:) :: REGVALUES 
d117 1
d119 2
a120 4
         TYPE DOUBLE_POINTER
            DOUBLE PRECISION, DIMENSION(:), POINTER :: RPT 
         END TYPE DOUBLE_POINTER
         TYPE(DOUBLE_POINTER), DIMENSION(MAXPRC+1) :: PRAMSV
d122 2
a123 1
      END MODULE REG_INFO
d125 3
d129 3
d133 1
d138 1
a138 1
C REG_BUILD                    NEW            AUG 2000 ARDEAN LEITH
d142 1
a142 1
C    REG_BUILD(IREGS,IRTFLG)
d144 1
a144 1
C    PURPOSE:     BUILDS CURRENT BANK OF REGISTERS   
d146 1
a146 1
C    PARAMETERS:  IREG      NUMBER OF REGISTERS                 (SENT)
d151 7
a157 1
      SUBROUTINE REG_BUILD(IREGS,IRTFLG)
d159 6
a164 1
      USE REG_INFO
d166 5
a170 4
      IF (IREGS .NE. NUMREGIS) THEN
         IF (IREGS .LT. 103) THEN
            IRTFLG = 1
            CALL ERRT(102,'MUST REQUEST MORE REGISTERS THAN',102)
d173 33
d207 28
a234 2
         IF (ALLOCATED(REGVALUES)) DEALLOCATE(REGVALUES)
         ALLOCATE(REGVALUES(IREGS+NUMREGLOOP),STAT=IRTFLG)
d236 74
a309 5
         IF (IRTFLG .NE. 0) THEN 
            NUMREGIS  = 0
            NUMREGIST = 0
            CALL ERRT(46,'REG_BUILD',IER)
            RETURN
a312 3
      NUMREGIS  = IREGS
      NUMREGIST = IREGS + NUMREGLOOP
 
d320 1
a320 1
C REG_CHK                    NEW            AUG 2000 ARDEAN LEITH
d324 1
a324 1
C    REG_CHK(IREG,NEEDERRT,IRTFLG)
d326 1
a326 1
C    PURPOSE:     CHECKS IREG TO SEE IF IT IS VALID   
d328 3
a330 1
C    PARAMETERS:  IREG      NUMBER OF REGISTER                  (SENT)
d332 1
d335 2
d339 1
a339 1
      SUBROUTINE REG_CHK(IREG,NEEDERRT,IRTFLG)
d341 1
a341 1
      USE REG_INFO
a342 1
C     COMMON NEEDED FOR NOUT
d345 23
a367 1
      LOGICAL :: NEEDERRT
d369 9
a377 5
      IF (IREG .LT. 0 .OR. IREG .GE. NUMREGIST) THEN
         WRITE(NOUT,90) NUMREGIS-1
90       FORMAT(' *** CURRENT REGISTER RANGE: 0...',I6)

         IF (NEEDERRT) CALL ERRT(102,'ILLEGAL REGISTER',IREG)
d382 12
d395 1
d399 5
d406 61
a466 1
C REG_GET_NUMS                    NEW            AUG 2000 ARDEAN LEITH
d468 2
d472 1
a472 1
C    REG_GET_NUMS(IREGS)
d474 1
a474 2
C    PURPOSE:     GETS CURRENT NUMBER OF REGISTERS IN A WHOLE SET OR
C                 BANK   
d476 3
a478 1
C    PARAMETERS:  IREGS     NUMBER OF REGISTER                  (RET.)
d482 3
a484 1
      SUBROUTINE REG_GET_NUMS(IREGS)
d486 4
a489 1
      USE REG_INFO
d491 14
a504 1
      IREGS = NUMREGIST
d510 42
d555 62
a616 1
C REG_SET                         NEW            AUG 2000 ARDEAN LEITH
d618 2
d622 1
a622 1
C    REG_SET(IREGT,VALUE,NEEDERRT,IRTFLG)
d624 3
a626 1
C    PURPOSE:     SETS A CURRENT REGISTER VALUE   
d628 6
a633 4
C    PARAMETERS:  IREGT     REGISTER NUMBER                     (SENT)
C                 VALUE     VALUE FOR REGVALUES                 (SENT)
C                 NEEDERRT  ERRT CALL FLAG                      (SENT.)
C                 IRTFLG    ERROR FLAG                          (RET.)
d637 1
a637 1
      SUBROUTINE REG_SET(IREGT,VALUE,NEEDERRT,IRTFLG)
d639 1
a639 1
      USE REG_INFO
d641 2
a642 1
      LOGICAL :: NEEDERRT
d644 44
a687 1
      IREG = ABS(IREGT)
d689 3
a691 2
      CALL REG_CHK(IREG,NEEDERRT,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN
d693 5
a697 1
      REGVALUES(IREG+1) = VALUE
d699 2
d706 6
a711 1
C REG_SET_BANKED                   NEW            NOV 2005 ARDEAN LEITH
d713 36
d751 1
a751 1
C    REG_SET_BANKED(IBANK,IREG,RVAL,IRTFLG)
d753 1
a753 1
C    PURPOSE:     COPIES A SINGLE RVAL INTO A BANKED REGISTER. 
d755 3
a757 4
C    PARAMETERS:  IBANK   BANK                                  (SENT)
C                 IREG    REGISTER NUMBER IN BANK               (SENT)
C                 RVAL    VALUE FOR IREG                        (SENT)
C                 IRTFLG  ERROR FLAG                            (RET.)
d761 23
a783 1
      SUBROUTINE REG_SET_BANKED(IBANK,IREG,RVAL,IRTFLG)
d785 39
a823 1
      USE REG_INFO
d825 4
a828 7
      DOUBLE PRECISION, DIMENSION(:), POINTER :: RPOINTER
      
      IRTFLG = 1        
      IF (.NOT. ASSOCIATED(PRAMSV(IBANK)%RPT)) THEN
         CALL ERRT(102,'REGISTER BANK DOES NOT EXIST',IBANK)
         RETURN
      ENDIF
d830 2
a831 1
      RPOINTER => PRAMSV(IBANK)%RPT 
d833 1
a833 1
      RPOINTER(IREG+1) = RVAL
d858 1
a858 1
      USE REG_INFO
d865 1
a865 1
         CALL REG_SET(NSELREG(IGO+0)-1,VAL0,.FALSE.,IRTFLG)
d867 1
a867 1
            CALL REG_SET(NSELREG(IGO+1)-1,VAL1,.FALSE.,IRTFLG)
d869 1
a869 1
               CALL REG_SET(NSELREG(IGO+2)-1,VAL2,.FALSE.,IRTFLG)
d871 1
a871 1
                  CALL REG_SET(NSELREG(IGO+3)-1,VAL3,.FALSE.,IRTFLG)
d873 1
a873 1
                     CALL REG_SET(NSELREG(IGO+4)-1,VAL4,.FALSE.,IRTFLG)
d890 1
a890 1
C    REG_SET_NSELA(NREG,VALUES,IRTFLG)
d894 1
a894 1
C    PARAMETERS:  NREG      REGISTER NUMBERS IN USE            (SENT/RET.)
d896 1
d901 1
a901 1
      SUBROUTINE REG_SET_NSELA(NREG,VALUES,IRTFLG)
d903 1
a903 1
      USE REG_INFO
d905 2
a906 1
      DIMENSION VALUES(*)
d908 2
a909 1
      NREG = MIN(NREG,NSEL_USED)
d912 1
d914 1
a914 3
C           NSELREG IS STILL CARRYING ADJUSTED REG NUMBER (+1)
         
            CALL REG_SET(NSELREG(IREG)-1, VALUES(IREG),.FALSE.,IRTFLG)
d916 6
d924 1
a927 1

d930 1
a930 1
C REG_SET_NSELB                    NEW            AUG 200% ARDEAN LEITH
d934 1
a934 1
C    REG_SET_NSELB(IBANK,NREG,VALUES,IRTFLG)
d936 1
a936 1
C    PURPOSE:     SETS REGISTERS SPECIFIED IN NSEL TO VALUES IN A BANK  
d938 2
a939 3
C    PARAMETERS:  IBANK     REGISTER BANK NUMBER                (SENT)
C                 NREG      REGISTER NUMBERS IN USE          (SENT/RET.)
C                 VALUES    VALUES ARRAY                        (SENT)
d944 1
a944 1
      SUBROUTINE REG_SET_NSELB(IBANK,NREG,VALUES,IRTFLG)
d946 1
a946 1
      USE REG_INFO
d948 1
a948 1
      DIMENSION VALUES(*)
d950 2
a951 9
      NREG = MIN(NREG,NSEL_USED)

      IF (NREG .GT. 0) THEN
         DO IREG=1,NREG
C           NSELREG IS STILL CARRYING ADJUSTED REG NUMBER (+1)
            CALL REG_SET_BANKED(IBANK,NSELREG(IREG)-1, VALUES(IREG),
     &                         IRTFLG)
         ENDDO
      ENDIF
d953 6
d967 1
a967 1
C REG_GET_USED               NEW            AUG 2000 ARDEAN LEITH
d971 1
a971 1
C    REG_GET_USED(NREG)
d973 1
a973 1
C    PURPOSE:     GETS NUMBER OF REGISTER USED IN NSELREG   
d975 5
a979 2
C    PARAMETERS:  NREG      REGISTER NUMBERS IN USE             (SENT)
C                 VALUES    VALUES ARRAY                        (SENT)
d984 3
a986 1
      SUBROUTINE REG_GET_USED(NREG)
d988 2
a989 1
      USE REG_INFO
d991 9
a999 1
      NREG = NSEL_USED
d1001 2
a1005 1

d1008 1
a1008 1
C SET_BANK               NEW            AUG 2000 ARDEAN LEITH
d1012 1
a1012 1
C    REG_SET_BANK(IBANK,IRTFLG)
d1014 1
a1014 1
C    PURPOSE:     COPIES CURRENT REGISTERS INTO BANK --> IBANK   
d1016 3
a1018 1
C    PARAMETERS:  IBANK     DESTINATION BANK                  (SENT)
d1023 3
a1025 1
      SUBROUTINE REG_SET_BANK(IBANK,IRTFLG)
d1027 2
a1028 1
      USE REG_INFO
d1030 7
a1036 15
      DOUBLE PRECISION, DIMENSION(:), POINTER :: RPOINTER
      
      IRTFLG = 0
          
      IF (ASSOCIATED(PRAMSV(IBANK)%RPT)) THEN
C        REGISTER BANK ALREADY EXISTS, BUT MAY BE DIFFERENT SIZE
         RPOINTER => PRAMSV(IBANK)%RPT
 
         IF (SIZE(RPOINTER) .NE. NUMREGIST) THEN 
C           FREE EXISTING SPACE ALLOCATION FOR THIS REGISTER BANK
            DEALLOCATE(RPOINTER,STAT=IRTFLGT)
            IF (IRTFLGT .NE. 0) RETURN

            NULLIFY(PRAMSV(IBANK)%RPT)
         ENDIF 
d1038 1
d1040 1
a1040 7
      IF ( .NOT. ASSOCIATED(PRAMSV(IBANK)%RPT)) THEN
C        MUST ALLOCATE SPACE FOR THIS REGISTER BANK
         ALLOCATE(RPOINTER(NUMREGIST),STAT=IRTFLGT)
         IF (IRTFLGT .NE. 0) THEN
            CALL ERRT(45,'OPENINLN',NE)
            RETURN
         ENDIF
a1041 10
         PRAMSV(IBANK)%RPT => RPOINTER
      ENDIF

      RPOINTER => PRAMSV(IBANK)%RPT
     
      DO IREG = 1,NUMREGIST
         RPOINTER(IREG) = REGVALUES(IREG)
      ENDDO
 
      IRTFLG = 0
d1048 1
a1048 1
C REG_GET                         NEW            AUG 2000 ARDEAN LEITH
d1052 1
a1052 1
C    REG_GET(IREG,VALUE,NEEDERRT,IRTFLG)
d1054 1
a1054 1
C    PURPOSE:     GETS A REGISTER VALUE FROM CURRENT BANK  
d1056 1
a1056 4
C    PARAMETERS:  IREG      REGISTER NUMBER                     (SENT)
C                 VALUE     VALUE FROM IREGBANK                 (RET.)
C                 NEEDERRT  ERRT CALL FLAG                      (SENT.)
C                 IRTFLG    ERROR FLAG                          (RET.)
d1060 1
a1060 1
      SUBROUTINE REG_GET(IREG,VALUE,NEEDERRT,IRTFLG)
d1062 1
a1062 1
      USE REG_INFO
d1064 1
a1064 6
      LOGICAL :: NEEDERRT

      CALL REG_CHK(IREG,NEEDERRT,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

      VALUE = REGVALUES(IREG+1)
d1069 1
d1071 1
a1071 19
C++*********************************************************************
C
C REG_GET_BANK                     NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_GET_BANK(IBANK,IRTFLG)
C
C    PURPOSE:     COPIES A WHOLE BANK OF REGISTERS INTO CURRENT
C                 ACTIVE BANK 
C
C    PARAMETERS:  IBANK   BANK                                  (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************

      SUBROUTINE REG_GET_BANK(IBANK,IRTFLG)

      USE REG_INFO
d1073 1
a1073 14
      DOUBLE PRECISION, DIMENSION(:), POINTER :: RPOINTER
      
      IRTFLG = 1        
      IF (.NOT. ASSOCIATED(PRAMSV(IBANK)%RPT)) THEN
C        REGISTER BANK DOES NOT EXIST!!
         CALL ERRT(102,'REGISTER BANK DOES NOT EXIST',IBANK)
         RETURN
      ENDIF

      RPOINTER => PRAMSV(IBANK)%RPT 

      DO IREG = 1,NUMREGIST
         REGVALUES(IREG) = RPOINTER(IREG) 
      ENDDO
d1079 1
a1079 1
C++*********************************************************************
d1081 1
a1081 1
C REG_GET_BANKED                   NEW            AUG 2000 ARDEAN LEITH
d1083 11
a1093 1
C **********************************************************************
d1095 1
a1095 10
C    REG_GET_BANKED(IBANK,IREGBANK,RVAL,IRTFLG)
C
C    PURPOSE:     COPIES A SINGLE BANKED REGISTER INTO RVAL. 
C
C    PARAMETERS:  IBANK   BANK                                  (SENT)
C                 IREG    REGISTER NUMBER IN BANK               (SENT)
C                 RVAL    VALUE FROM IREG                       (RET.)
C                 IRTFLG  ERROR FLAG                            (RET.)
C
C--*******************************************************************
d1097 1
a1097 1
      SUBROUTINE REG_GET_BANKED(IBANK,IREG,RVAL,IRTFLG)
d1099 1
a1099 1
      USE REG_INFO
d1101 1
a1101 7
      DOUBLE PRECISION, DIMENSION(:), POINTER :: RPOINTER
      
      IRTFLG = 1        
      IF (.NOT. ASSOCIATED(PRAMSV(IBANK)%RPT)) THEN
         CALL ERRT(102,'REGISTER BANK DOES NOT EXIST',IBANK)
         RETURN
      ENDIF
d1103 28
a1130 1
      RPOINTER => PRAMSV(IBANK)%RPT 
d1132 46
a1177 3
C     CHECK REGISTER VALIDITY
      CALL REG_CHK(IREG,.TRUE.,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN
d1179 2
a1180 1
      RVAL = RPOINTER(IREG+1)
d1182 2
a1183 2
      RETURN
      END
a1185 1
 
d1206 1
a1206 1
      USE REG_INFO
d1210 1
a1210 1
         CALL REG_GET(NSELREG(IGO+0)-1,VAL0,.FALSE.,IRTFLG)
d1212 1
a1212 1
            CALL REG_GET(NSELREG(IGO+1)-1,VAL1,.FALSE.,IRTFLG)
d1214 1
a1214 1
               CALL REG_GET(NSELREG(IGO+2)-1,VAL2,.FALSE.,IRTFLG)
d1216 1
a1216 1
                  CALL REG_GET(NSELREG(IGO+3)-1,VAL3,.FALSE.,IRTFLG)
d1218 1
a1218 1
                     CALL REG_GET(NSELREG(IGO+4)-1,VAL4,.FALSE.,IRTFLG)
d1231 1
a1231 1
C REG_GET_LIST                 NEW            AUG 2000 ARDEAN LEITH
d1235 1
a1235 1
C    REG_GET_LIST(NGOT,ILIST,IRTFLG)
d1237 1
a1237 1
C    PURPOSE:     GETS LIST OF REGISTER(S) SPECIFIED IN NSELREG 
d1239 3
a1241 3
C    PARAMETERS:  NGOT      NSEL_USED                           (RET.)
C                 ILIST     REGISTER NUMBERS IN NSELREG         (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
d1245 1
a1245 1
      SUBROUTINE REG_GET_LIST(NGOT,ILIST,IRTFLG)
d1247 1
a1247 1
      USE REG_INFO
d1249 3
a1251 1
      INTEGER ILIST(*)
d1253 2
a1254 1
      NGOT = NSEL_USED
d1256 15
a1270 3
      DO I = 1,NGOT
         ILIST(I) = NSELREG(I)
      ENDDO
a1274 1

d1277 1
a1277 1
C REG_SAVE                       NEW            AUG 2000 ARDEAN LEITH
d1281 1
a1281 1
C    REG_SAVE(IRTFLG)
d1283 1
a1283 1
C    PURPOSE:     SAVES CURRENT REGISTER SET IN A SPECIAL BANK  
d1285 1
a1285 1
C    PARAMETERS:  IRTFLG    ERROR FLAG                          (RET.)
d1289 1
a1289 3
      SUBROUTINE REG_SAVE(IRTFLG)

      USE REG_INFO
d1291 1
a1291 1
      CALL REG_SET_BANK(MAXPRC+1,IRTFLG)
d1293 2
a1294 1
      RETURN
a1296 14
C++*********************************************************************
C
C REG_UNSAVE                       NEW            AUG 2000 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_UNSAVE(IRTFLG)
C
C    PURPOSE:     RETRIEVES SPECIAL BANK OF REGISTERS INTO CURRENT 
C                 REGISTER BANK  
C
C    PARAMETERS:  IRTFLG    ERROR FLAG                          (RET.)
C
C--*******************************************************************
a1297 9
 
      SUBROUTINE REG_UNSAVE(IRTFLG)

      USE REG_INFO

      CALL REG_GET_BANK(MAXPRC+1,IRTFLG)

      RETURN
      END
d1305 1
a1305 1
C    REG_PIPE(IREG,IRTFLG)
d1309 1
a1309 1
C    PARAMETERS:  IREG      REGISTER NUMBER                     (SENT)
d1314 1
a1314 1
      SUBROUTINE REG_PIPE(IREG,IRTFLG)
d1316 1
a1316 1
      USE REG_INFO
d1318 14
a1331 1
      CALL REG_GET(IREG,VALUE,.TRUE.,IRTFLG)
d1343 2
a1344 1
         CALL ERRT(101,'NO PIPE OPEN',IRTFLG)
d1368 1
a1368 1
      USE REG_INFO
d1405 1
d1408 1
a1408 6
C REG_READPQ.F    ADAPTED FROM READP.FOR FOR CHAR. AUG 89 ARDEAN LEITH
C                 INCREASED NSEL DIMENSION        JULY 99 ARDEAN LEITH
C                 USED CHKSTR INSTEAD OF CHKSTRQ   NOV 99 ARDEAN LEITH
C                 ADDED FILNAMSUB                 JAN 2000 ARDEAN LEITH
C                 TAKEN FROM READPQ.f             AUG 2000 ARDEAN LEITH
C                 REMOVED FILNAMSUB               APR 2001 ARDEAN LEITH
d1412 3
a1414 1
C    REG_READPQ(STRING)
d1416 1
a1416 4
C    PURPOSE:          PARSES REGISTER LIST FROM OPERATION LINE.  PLACES
C                      REGISTER NUMBERS (UP TO MAXNSEL NUMBERS) IN 
C                      NSELREG. CALLED BY TSWITCH.F AFTER CALL TO SSUPCAS
C                      HAS OCCURRED. 
d1418 2
a1419 1
C    PARAMETERS:       STRING    OPERATION STRING                  SENT
d1423 1
a1423 1
      SUBROUTINE REG_READPQ(STRING)
d1425 1
a1425 1
      USE REG_INFO
a1426 1
C     COMMON NEEDED FOR NALPH
d1428 1
d1430 6
a1435 2
      CHARACTER *(*) STRING
      CHARACTER *77  STRING1
d1437 6
a1442 1
      LOGICAL        ISDIGI
d1444 2
a1445 2
C     ZERO THE REGISTER LIST IN NSELREG
      NSEL_USED = 0
d1447 4
a1450 8
C     NALPH CONTAINS TOTAL LENGTH OF OPERATION STRING.
C     FIND END OF STRING
      IEND = NALPH

      DO I=NALPH,1,-1
         IF (STRING(I:I) .EQ. ';' .OR. STRING(I:I) .EQ. ']') THEN
            IEND = I-1
            GOTO 12
a1451 1
      ENDDO
d1453 4
a1456 10
C     FIND START OF POSSIBLE REGISTERS IN STRING
      IX = 0
12    DO I= 1,IEND-1
         IF ((STRING(I:I) .EQ. 'X' .OR. STRING(I:I) .EQ. 'x') .AND.
     &      ISDIGI(STRING(I+1:I+1))) THEN
           IX = I
           EXIT
         ENDIF
      ENDDO
      IF (IX .LE. 0) RETURN
d1458 1
a1458 9
      CALL SHRINKQ(STRING(IX:IEND),IEND-IX+1,STRING1,NSTRING)

C     RETURNS REGISTER NUMBERS (NOT ADJUSTED BY +1) IN NSELREG
      CALL CHKSTR(STRING1(1:NSTRING),NSTRING,'IT',NSELREG,DUM,
     &            MAXNSEL,NSEL_USED,IER)

      DO I=1,NSEL_USED
        NSELREG(I) = NSELREG(I) + 1
      ENDDO
d1460 2
a1463 38

C++*********************************************************************
C
C REG_STR_TO_NUM
C                 REMOVED FILNAMSUB               APR 2001 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_STR_TO_VAL(STRING,IBANK,RVAL,IBANK,IRTFLG)
C
C    PURPOSE:          PARSES REGISTER FROM STRING.  
C                      RETURNS  REGISTER VALUE 
C
C    PARAMETERS:       STRING    OPERATION STRING                  SENT
C                      STRING    OPERATION STRING                  SENT
C
C--*******************************************************************

      SUBROUTINE REG_STR_TO_VAL(STRING,IBANK,RVAL,IRTFLG)

      CHARACTER(LEN=*) :: STRING

C     REGPARSE RETURNS IREG 
      CALL REGPARSE(STRING,IREG,IGOR,IENDR,.TRUE.,IRTFLG)

      CALL REG_CHK(IREG,.FALSE.,IRTFLG)
            
      IF (IRTFLG .NE. 0) THEN
         CALL ERRT(102,'SUBSTITUTING INVALID REGISTER',IREG)
         RETURN
      ENDIF

       IF (IBANK .GT. 0) THEN
          CALL REG_GET_BANKED(IBANK,IREG,RVAL,IRTFLG)
       ELSE 
          CALL REG_GET(IREG,RVAL,.FALSE.,IRTFLG)
       ENDIF
       END
@


1.16
log
@GPL License fixed
@
text
@d4 1
a4 1
C REG_SET.F                                            AUTHOR: A. LEITH
d7 2
d57 6
a64 2
C    REG_SET_BANK(IBANK,IRTFLG)
C
d69 1
d72 1
d106 1
a106 1
         REAL,     ALLOCATABLE, DIMENSION(:) :: REGVALUES 
d109 4
a112 4
         TYPE REAL_POINTER
            REAL, DIMENSION(:), POINTER :: RPT 
         END TYPE REAL_POINTER
         TYPE(REAL_POINTER), DIMENSION(MAXPRC+1) :: PRAMSV
d235 1
a235 1
C    REG_SET(IREG,VALUE,NEEDERRT,IRTFLG)
d239 2
a240 2
C    PARAMETERS:  IREG      REGISTER NUMBER                     (SENT)
C                 VALUE     VALUE FROM IREGBANK                 (SENT)
d246 1
a246 1
      SUBROUTINE REG_SET(IREG,VALUE,NEEDERRT,IRTFLG)
d252 2
a257 20
 
      RETURN
      END

C++*********************************************************************
C
C REG_PIPE                         NEW           JULY 2001 ARDEAN LEITH
C
C **********************************************************************
C
C    REG_PIPE(IREG,IRTFLG)
C
C    PURPOSE:    SENDS REGISTER VALUE DOWN LUNREGPIPE   
C
C    PARAMETERS:  IREG      REGISTER NUMBER                     (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
C
C--*********************************************************************

      SUBROUTINE REG_PIPE(IREG,IRTFLG)
a258 17
      USE REG_INFO

      CALL REG_GET(IREG,VALUE,.TRUE.,IRTFLG)

      IF (REGPIPE) THEN
C        WRITE REG NUMBER & VALUE TO NAMED PIPE
         WRITE(LUNREGPIPE,IOSTAT=IRTFLG) IREG,VALUE
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(102,'PIPING REGISTER',IREG)
            RETURN
         ENDIF
C        THIS IS NECESSARY, DO NOT ASK ME WHY!
         WRITE(LUNREGPIPE,IOSTAT=IRTFLG) CHAR(10)
      ELSE
         CALL ERRT(101,'NO PIPE OPEN',IRTFLG)
      ENDIF
 
a261 1

d264 1
a264 1
C REG_OPENPIPE                   NEW            JULY 2001 ARDEAN LEITH
d268 1
a268 1
C    REG_PIPE(CXNUM,IRTFLG)
d270 1
a270 1
C    PURPOSE:     OPENS PIPE FOR REGISTERS   
d272 4
a275 2
C    PARAMETERS:  PIPENAME  PIPE NAME                           (SENT)
C                 IRTFLG    ERROR FLAG                          (RET.)
d279 1
a279 1
      SUBROUTINE REG_OPENPIPE(PIPENAME,IRTFLG)
d283 5
a287 13
      CHARACTER (LEN=80) ::    PIPENAME
      CHARACTER (LEN=80+24) :: MSG

#ifdef sgi
C     SETS NAME FOR ASSIGN OBJECT FILE
      CALL SETENV('FILENV','jnkASSIGN1',IRTFLG)
C     CLEAR ANY EXISTING ASSIGN OBJECT FILE
      CALL ASNRM(IRTFLG)
C     INITIALIZE THE ASSIGN OBJECT FILE FOR WRITING
      MSG = '-s u -a ' // PIPENAME
      CALL ASNUNIT(LUNREGPIPE,MSG,IRTFLG)
      IF (IRTFLG .NE. 0) THEN
         CALL ERRT(102,'ASNUNIT TO SET PIPE, RETURNS:',IER)
a289 7
#endif
      OPEN(UNIT=LUNREGPIPE, FILE=PIPENAME,
     &    FORM='UNFORMATTED',
     &    ACCESS='SEQUENTIAL',
     &    STATUS='OLD',
     &    ACTION='WRITE',
     &    IOSTAT=IRTFLG)
d291 1
a291 5
      IF (IRTFLG .NE. 0) THEN 
         MSG = 'FAILED TO OPEN PIPE: ' // PIPENAME
         CALL ERRT(101,MSG,IRTFLG)
         RETURN
      ENDIF
d293 1
a293 2
      REGPIPE = .TRUE.
      IRTFLG  = 0
d298 2
d354 1
a354 1
C    PARAMETERS:  NREG      REGISTER NUMBERS IN USE             (SENT)
d382 39
d451 1
a451 1
C    SET_BANK(IBANK,IRTFLG)
d464 1
a464 1
      REAL, DIMENSION(:), POINTER :: RPOINTER
d555 1
a555 1
      REAL, DIMENSION(:), POINTER :: RPOINTER
d585 3
a587 3
C                 IREGBANK  REGISTER NUMBER IN BANK             (SENT)
C                 RVAL      VALUE FROM IREGBANK                 (RET.)
C                 IRTFLG    ERROR FLAG                          (RET.)
d591 1
a591 1
      SUBROUTINE REG_GET_BANKED(IBANK,IREGBANK,RVAL,IRTFLG)
d595 1
a595 1
      REAL, DIMENSION(:), POINTER :: RPOINTER
d606 1
a606 1
      CALL REG_CHK(IREGBANK,.TRUE.,IRTFLG)
d609 1
a609 1
      RVAL = RPOINTER(IREGBANK+1)
d614 3
d670 1
a670 1
C                 ILIST     REGISTER NUMBERS IN NSELREG            (RET.)
d739 91
d880 9
a888 3
12    IX = INDEX(STRING(1:IEND),'X')
      IF (IX .LE. 0 .OR. IX .GE. IEND .OR. .NOT.
     &    ISDIGI(STRING(IX+1:IX+1)))  RETURN
d892 2
a893 2
C     RETURNS REGISTER NUMBERS ADJUSTED BY +1 IN NSELREG
      CALL CHKSTR(STRING1(1:NSTRING),NSTRING,'IR',NSELREG,DUM,
d896 4
d903 30
d934 6
@


1.15
log
@HRI GPL License used
@
text
@a8 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d12 1
a12 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a31 6

C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
a112 1
C++************************************************************************
a157 1
C++************************************************************************
a195 1
C++************************************************************************
a221 1
C++************************************************************************
a252 1
C++************************************************************************
a290 1
C++************************************************************************
a344 1
C++************************************************************************
a388 1
C++***********************************************************************
a424 1
C++************************************************************************
a450 1
C++************************************************************************
a508 1
C++************************************************************************
a540 1
C++************************************************************************
a579 1
C++************************************************************************
a619 1
C++************************************************************************
a661 1
C++************************************************************************
a693 1
C++************************************************************************
a716 1
C++************************************************************************
a742 1
C++************************************************************************
@


1.14
log
@*** empty log message ***
@
text
@d10 24
d119 1
d165 1
d204 1
d231 1
d263 1
d302 1
d357 1
d402 1
d439 1
d466 1
d525 1
d558 1
d598 1
d639 1
d682 1
d715 1
d739 1
d766 1
@


1.13
log
@changed pipe lun
@
text
@d295 1
a295 1
#ifdef NEVER
@


1.12
log
@reg_pipe added
@
text
@d76 1
a76 1
         INTEGER, PARAMETER :: LUNREGPIPE  = 197
@


1.11
log
@nout was undefined  in one subroutine
@
text
@d6 1
d26 3
d75 3
d139 1
d142 1
a142 1
C REG_GET_NUMS                    NEW            AUG 2000 ARDEAN LEITH
d231 92
@


1.10
log
@removed filnamsub call from parse
@
text
@d152 3
@


1.9
log
@bug fixed
@
text
@d5 2
a6 1
C                                           
d629 1
a675 7

      ILEFBRAK = INDEX(STRING1(1:NSTRING),'{')
      IF (ILEFBRAK .GT. 0) THEN
C        SUBSTITUTE FOR {***X??) OR {---X??} IN STRING1
         CALL FILNAMSUB(STRING1(1:NSTRING),NSTRING,.FALSE.,FDUM,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
      ENDIF
@


1.8
log
@changed variable names
@
text
@a211 1
      INCLUDE 'CMBLOCK.INC'
d239 1
a239 1
      SUBROUTINE REG_SET_NSEL(IGO,VAL0,VAL1,VAL2,VAL3,VAL4,IRTFLG)
d242 2
a243 1
      INCLUDE 'CMBLOCK.INC'
d245 3
a247 2
      IF (NSEL_USED .GE. IGO+0) THEN
C        NSELREG IS STILL CARRYING ADJUSTED REG NUMBER (+1)
d249 1
a249 1
         IF (NSEL_USED .GE. IGO+1) THEN
d251 1
a251 1
            IF (NSEL_USED .GE. IGO+2) THEN
d253 1
a253 1
               IF (NSEL_USED .GE. IGO+3) THEN
d255 1
a255 1
                  IF (NSEL_USED .GE. IGO+4) THEN
a285 1
      INCLUDE 'CMBLOCK.INC'
a346 1
      INCLUDE 'CMBLOCK.INC'
a406 1
      INCLUDE 'CMBLOCK.INC'
a437 1
      INCLUDE 'CMBLOCK.INC'
a477 1
      INCLUDE 'CMBLOCK.INC'
d506 1
a506 1
C    PURPOSE:     SETS VALUES TO CONTENTS OF REGISTER(S) SPECIFIED 
d510 1
a510 1
C                 VAL...    VALUES                             (RET.)
a517 1
      INCLUDE 'CMBLOCK.INC'
a558 1
      INCLUDE 'CMBLOCK.INC'
d646 1
d652 1
a652 1
      LOGICAL ISDIGI
@


1.7
log
@removed old register param
@
text
@d52 4
d64 2
a65 2
         INTEGER :: NUMREGIS = 103
         INTEGER :: NUMREGIST = 129
d67 2
d73 2
a74 1
         REAL,  ALLOCATABLE, DIMENSION(:) :: REGVALUES 
d107 1
a107 1
         IF (IREGS .LE. 103) THEN
d114 1
a114 1
         ALLOCATE(REGVALUES(IREGS+26),STAT=IRTFLG)
d125 1
a125 1
      NUMREGIST = IREGS + 26
d232 1
a232 1
C    PURPOSE:     SETS A REGISTER SPECIFIED IN NSEL(NVAL) TO VALUE   
d246 2
a247 2
C        NSEL IS STILL CARRYING ADJUSTED REG NUMBER (+1)
         CALL REG_SET(NSEL(IGO+0)-1,VAL0,.FALSE.,IRTFLG)
d249 1
a249 1
            CALL REG_SET(NSEL(IGO+1)-1,VAL1,.FALSE.,IRTFLG)
d251 1
a251 1
               CALL REG_SET(NSEL(IGO+2)-1,VAL2,.FALSE.,IRTFLG)
d253 1
a253 1
                  CALL REG_SET(NSEL(IGO+3)-1,VAL3,.FALSE.,IRTFLG)
d255 1
a255 1
                     CALL REG_SET(NSEL(IGO+4)-1,VAL4,.FALSE.,IRTFLG)
d293 1
a293 1
C           NSEL IS STILL CARRYING ADJUSTED REG NUMBER (+1)
d295 1
a295 1
            CALL REG_SET(NSEL(IREG)-1, VALUES(IREG),.FALSE.,IRTFLG)
d311 1
a311 1
C    PURPOSE:     GETS NUMBER OF REGISTER USED IN NSEL   
d511 1
a511 1
C                 IN NSEL 
d526 1
a526 1
         CALL REG_GET(NSEL(IGO+0)-1,VAL0,.FALSE.,IRTFLG)
d528 1
a528 1
            CALL REG_GET(NSEL(IGO+1)-1,VAL1,.FALSE.,IRTFLG)
d530 1
a530 1
               CALL REG_GET(NSEL(IGO+2)-1,VAL2,.FALSE.,IRTFLG)
d532 1
a532 1
                  CALL REG_GET(NSEL(IGO+3)-1,VAL3,.FALSE.,IRTFLG)
d534 1
a534 1
                     CALL REG_GET(NSEL(IGO+4)-1,VAL4,.FALSE.,IRTFLG)
d553 1
a553 1
C    PURPOSE:     GETS LIST OF REGISTER(S) SPECIFIED IN NSEL 
d556 1
a556 1
C                 ILIST     REGISTER NUMBERS IN NSEL            (RET.)
d571 1
a571 1
         ILIST(I) = NSEL(I)
d640 2
a641 2
C                      REGISTER NUMBERS (UP TO MAXPARAMSEL NUMBERS) IN 
C                      NSEL. CALLED BY TSWITCH.F AFTER CALL TO SSUPCAS
d659 1
a659 1
C     ZERO THE REGISTER LIST IN NSEL
d687 3
a689 3
C     RETURNS REGISTER NUMBERS ADJUSTED BY +1 IN NSEL
      CALL CHKSTR(STRING1(1:NSTRING),NSTRING,'IR',NSEL,DUM,
     &            MAXPARAMSEL,NSEL_USED,IER)
@


1.6
log
@added new subroutine
@
text
@a212 1
      if (ireg .lt. maxparam) param(ireg+1) = value
d280 2
a373 3

c        remove next line when complete
         if (ireg .lt. maxparam) rpointer(ireg) = param(ireg)
a409 3
c     remove next line when complete
      if (ireg .lt. maxparam) value = param(ireg+1)

a447 3

C        REMOVE NEXT LINE WHEN COMPLETE
         IF (IREG .LT. MAXPARAM) PARAM(IREG) = REGVALUES(IREG)
a653 4
C     can be removed when complete
      do i = 1,MAXPARAMSEL
         nsel(i) = 0
      enddo
@


1.5
log
@*** empty log message ***
@
text
@d260 1
a260 1
C++************************************************************************
d544 34
@


1.4
log
@added reg_get_nsel
@
text
@d7 6
a12 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND      *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.   *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR  *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR*
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 		       *
d18 16
a33 7
C     ---------------- REG_BUILD -----------------------------
C     ---------------- REG_CHK -----------------------------
C     ---------------- REG_SET -----------------------------
C     ---------------- REG_GET -----------------------------
C     ---------------- REG_GET_BANK ------------------------
C     ---------------- REG_SET_BANK -------------------------
C     ---------------- REG_REMOVE_BANK -------------------------
d35 1
d37 1
d39 12
a50 2
C    PURPOSE:       TO BUILD A SET OF SPIDER REGISTERS
C    PURPOSE:       TO SET A VALUE IN A SPIDER REGISTER.
a51 3
C    PARAMETERS:    IREG     REGISTER NUMBER                   (SENT)
C                   VALUE    VALUE TO BE SET                   (SENT)
C                   IRTFLG   ERROR FLAG                        (RETURNED)
a313 1
      INCLUDE 'CMBLOCK.INC'
d321 14
a334 2

C     ---------------- REG_SET_BANK ----------------------------------
a664 54
C++************************************************************ 10/11/79
C
C    REG_READQ.F     FCHAR AUG 89 ARDEAN LEITH
C                   USED ERRT SEPT 97 ARDEAN LEITH
C                   HANDLES 20 REGISTERS JULY 99  ARDEAN LEITH
C                   USED REG_ AUG 00 ARDEAN LEITH
C                   ADAPTED FROM READRQ.F AUG. 2000 ARDEAN LEITH
C
C **********************************************************************
C
C REG_READ(FCHAR)
C
C PURPOSE:  SUBROUTINE TO READ VALUES INTO REGISTERS IN PROCEDURES AT
C           EXECUTION TIME
C
C PARAMETERS:	  FCHAR         INPUT STRING
C
C--*******************************************************************

      SUBROUTINE REG_READRQ(FCHART)

      USE REG_INFO

      INCLUDE 'CMBLOCK.INC'

      COMMON VALUES(MAXPARAMSEL)

      CHARACTER *(*) FCHART

C     COUNT NUMBER OF REGISTERS USED IN NSEL ARRAY
      IF (NSEL_USED .LE. 0) RETURN 

      FBIG    = HUGE(FBIG)
      FLITTLE = -FBIG
      IGOT    = NSEL_USED
      CALL RDPRAF(VALUES,NSEL_USED,IGOT,FLITTLE,FBIG,'VALUE(S)',
     &            'T',IRTFLG)

      IF (IGOT .GT. 0) THEN
         DO I = 1,IGOT
C           REG_SET EXPECTS UNADJUSTED REG NUMBERS, NSEL HAS ADJUSTED
            CALL REG_SET(NSEL(I)-1,VALUES(I),.FALSE.,IRTFLG)
         ENDDO
      ENDIF

      IF (IGOT .NE. NSEL_USED) THEN
C         OVER/UNDER FLOW
          WRITE(NOUT,91) IGOT
91        FORMAT(' WARNING: ONLY SET: ',I6,'  REGISTER(S)')
          NSEL_USED = IGO
      ENDIF

      RETURN
      END
@


1.3
log
@reg_set_nsela wrong
@
text
@d242 1
d278 27
d471 42
@


1.2
log
@added reg_set_nsela
@
text
@d244 1
a244 1
C REG_SET_NSEL                     NEW            AUG 2000 ARDEAN LEITH
d248 1
a248 1
C    REG_SET_NSELA(VALUES,IRTFLG)
d250 1
a250 1
C    PURPOSE:     SETS REGISTER SPECIFIED IN NSEL TO VALUES   
d258 1
a258 1
      SUBROUTINE REG_SET_NSEL(NREG,VALUES,IRTFLG)
@


1.1
log
@Initial revision
@
text
@d203 1
a203 1
C REG_SET                         NEW            AUG 2000 ARDEAN LEITH
d237 34
@
