head	1.21;
access;
symbols
	pre_getangas:1.13
	GPL2010:1.13
	pre_GPL2010:1.12
	pre_var_equation:1.12
	pre_fftwrings:1.11
	pre_opfiles:1.7
	src:1.7
	best-code:1.7
	x-named-regs:1.7
	x:1.7
	v13-00:1.7
	pre_GPL:1.6;
locks; strict;
comment	@c @;


1.21
date	2011.10.12.18.13.54;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2011.09.12.18.04.18;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2011.09.08.14.53.22;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2011.08.29.17.45.24;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2011.08.29.16.13.34;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2011.08.11.13.00.23;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.08.19.22.27;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2011.03.28.13.48.20;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.24.13.25.05;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.25.15.47.38;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2008.03.14.18.52.50;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2008.03.13.18.15.04;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.13.18.10.49;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.19.16.33.48;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.17.21.08.11;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.23.15.34.38;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.18.18.41.52;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.02.15.24.23;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.18.14.45.20;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.18.14.43.02;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.11.14.57.14;	author leith;	state Exp;
branches;
next	;


desc
@@


1.21
log
@quadri int bug
@
text
@
C++*********************************************************************
C
C APSHIFT.F         NEW                           NOV 03 ARDEAN LEITH
C                   AVI ERROR IF NOT NORM3        JUN 04 ARDEAN LEITH
C                   GETDATS HAD UNDEFINED NUMTH   FEB 05 ARDEAN LEITH
C                   USED APCC                     FEB 08 ARDEAN LEITH
C                   REWRITE                       NOV 08 ARDEAN LEITH
C                   MIRRORED SHIFT BUG            MAR 11 ARDEAN LEITH
C                   APCC DOES FFTW SCALIING NOW   AUG 11 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2011  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  APSHIFT(LUNIN, REFPAT,IMGREF,  NSAM,NROW, NSAMP,NROWP, 
C          EXPBUF,AVI,SIGI, ISHRANGE,
C          RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,PEAKV,IRTFLG)
C                                  
C  PURPOSE:  MASTER SHIFT DETERMINATION ROUTINE FOR MANY 'AP ..' 
C            OPERATIONS
C
C            ROTATE EXPBUF IMAGE BY RANGNEW, MIRROR IF NECESSARY, PAD 
C            TO 2X SIZE, CROSS-CORRELATE WITH REFERENCE IMAGE, FIND
C            CC PEAK.
C
C  PARAMETERS: LUNIN       IO UNIT                                SENT
C              EXPPAT      EXP. IMAGE TEMPLATE                    SENT
C              IMGEXP      EXP. IMAGE NUMBER                      SENT
C              REFPAT      REF. IMAGE TEMPLATE                    SENT
C              IMGREF      REF. IMAGE NUMBER                      SENT
C              NSAM,NROW   ACTUAL INPUT IMAGE DIMENSIONS          SENT
C              NSAMP,NROWP NSAMP=2*NSAM+2,NROWP=2*NSAM            SENT
C              EXPBUF      EXP. IMAGE BUFFER                      SENT  
C              AVI,SIGI    EXP. IMAGE STATISTICS                  SENT
C              ISHRANGE    POSSIBLE IMAGE SHIFT                   SENT
C              RANGNEW     INPLANE ROTATION ANGLE                 SENT
C              XSHNEW..    SHIFT                                  RET.
C              MIRRORNEW   LOGICAL FLAG THAT REF. NEEDS MIRROR    SENT
C              PEAKV       PEAK HEIGHT                            RET. 
C              IRTFLG      ERROR FLAG                             RET.  
C
C  NOTE:   NSAMP INCLUDES THE EXTRA SPACE FOR FOURIER XFORM
C
C--*********************************************************************

        SUBROUTINE APSHIFT(LUNIN, REFPAT,IMGREF,
     &                     NSAM,NROW, NSAMP,NROWP, 
     &                     EXPBUF,AVI,SIGI, ISHRANGE,
     &                     RANGNEW,XSHNEW,YSHNEW,
     &                     MIRRORNEW,PEAKV,IRTFLG)

        IMPLICIT NONE

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

         
        INTEGER,INTENT(IN)    :: LUNIN
        CHARACTER(LEN=*)      :: REFPAT
        INTEGER,INTENT(IN)    :: IMGREF
        INTEGER,INTENT(IN)    :: NSAM,NROW,NSAMP,NROWP
        REAL,INTENT(IN)       :: EXPBUF(NSAM,NROW)
        REAL,INTENT(INOUT)    :: AVI,SIGI
        INTEGER,INTENT(IN)    :: ISHRANGE
        REAL,INTENT(OUT)      :: RANGNEW,XSHNEW,YSHNEW
        LOGICAL,INTENT(IN)    :: MIRRORNEW
        REAL,INTENT(OUT)      :: PEAKV
        INTEGER,INTENT(OUT)   :: IRTFLG

        LOGICAL               :: SKIP_PEAK,NORMIT,SPIDER_SIGN
        CHARACTER(LEN=MAXNAM) :: FILNAM

C       AUTOMATIC ARRAYS
        REAL                  :: BUFPADI(NSAMP,NROWP)   ! NSAMP=2*NSAM+2
        REAL                  :: BUFPADR(NSAMP,NROWP)   ! NROWP=2*NROW

        INTEGER               :: ISAM,ICENT,KCENT,NSAMP1,IROW
        INTEGER               :: IGO,NLET,ITYPE,NSLICE,MAXIM
        INTEGER               :: NE,IODD

        REAL                  :: XI,XOLD,YOLD,RN2,SN2,RW2,RS2
        REAL                  :: COD,SID,SIGR,PADVAL,YI,YCOD
        REAL                  :: YSID,ZDUM

        REAL                  :: quadri

        REAL, PARAMETER       :: PI = 3.1415926535897932384626
        REAL, PARAMETER       :: DGR_TO_RAD = PI/180

#ifdef DEBUG
         write(6,*) '----- in apshift ---'
         write(6,*) 'IMGREF,RANGNEW, MIRRORNEW'
         write(6,*)  IMGREF,RANGNEW, MIRRORNEW 
#endif

C        ROTATE IMAGE BY RANGNEW & PAD TO 2X SIZE

         ICENT = NROW/2+1
         KCENT = NSAM/2+1
         RN2   = -NROW/2
         SN2   = -NSAM/2
         RW2   = -RN2
         RS2   = -SN2

         IF (MOD(NSAM,2) .EQ. 0) RW2 = RW2 - 1.0
         IF (MOD(NROW,2) .EQ. 0) RS2 = RS2 - 1.0

         NSAMP1 = NSAM + 1

C        ROTATE THE IMAGE ------------------------------------- ROTATE

         COD = COS(RANGNEW * DGR_TO_RAD)
         SID = SIN(RANGNEW * DGR_TO_RAD)

         DO IROW=1,NROW
           YI = IROW - ICENT
           IF (YI .LT. RN2)  YI = MIN(RW2+YI-RN2+1.0, RW2)
           IF (YI .GT. RW2)  YI = MAX(RN2+YI-RW2-1.0, RN2)
           YCOD   =  YI * COD + ICENT
           YSID   = -YI * SID + KCENT
           IGO    = (IROW - 1) * NSAM

c$omp      parallel do private(isam,xi,xold,yold)
           DO ISAM=1,NSAM
              XI = ISAM - KCENT 
              IF (XI .LT. SN2) XI = MIN(RS2+XI-SN2+1.0,RS2)
              IF (XI .GT. RS2) XI = MAX(SN2+XI-RS2-1.0,SN2)
              YOLD = XI * SID  + YCOD
              XOLD = XI * COD  + YSID

              IF (.NOT. MIRRORNEW) THEN
C                NO MIRROR 
                 BUFPADI(ISAM,IROW) = 
     &                   QUADRI(XOLD,YOLD,NSAM,NROW,EXPBUF)
              ELSE
C                MIRROR THE IMAGE IN PLACE  
                 BUFPADI(NSAMP1-ISAM,IROW) = 
     &                   QUADRI(XOLD,YOLD,NSAM,NROW,EXPBUF)
              ENDIF
	   ENDDO

C          FILL REMAINING EMPTY COLS IN PADDED IMAGE
           BUFPADI(NSAMP1:NSAMP, IROW) = AVI
	 ENDDO

C        FILL REMAINING EMPTY ROWS IN PADDED IMAGE
         BUFPADI(1:NSAMP, NROW+1:NROWP) = AVI

C        OPEN REFERENCE IMAGE INPUT FILE
         NLET = 0
         CALL FILGET(REFPAT,FILNAM,NLET,IMGREF,IRTFLG)
         IF (IRTFLG .NE. 0)  RETURN

         CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',ITYPE,
     &                NSAM,NROW,NSLICE,MAXIM,'INPUT',.FALSE.,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
         IF (IMAMI .NE. 1) 
     &       CALL NORM3(LUNIN,NSAM,NROW,NSLICE,FMAX,FMIN,AV)
         SIGR = SIG

C        LOAD & PAD REFERENCE IMAGE TO DOUBLE SIZE (WITH ZEROS!)
         PADVAL = 0.0
         CALL REDNPADVOL(LUNIN,PADVAL, 
     &                   NSAM,NROW,1,  2*NSAM+2,2*NROW,1,
     &                   BUFPADR, IRTFLG)
         IF (IRTFLG .NE. 0) RETURN

         CLOSE(LUNIN)

#ifdef DEBUGNEVER
c-----------------debug
         write(6,*) ' nsamp,nrowp: ', nsamp,nrowp

         call opfilec(0,.false.,'jnkpadi',lunin,'U',itype,
     &                nsamp,nrowp,1,maxim,' ',.false.,irtflg)
         call wrtvol(lunin,nsamp,nrowp,1,1,bufpadi,irtflg)
         close(lunin)
         call opfilec(0,.false.,'jnkpadr',lunin,'U',itype,
     &                nsamp,nrowp,1,maxim,' ',.false.,irtflg)
         call wrtvol(lunin,nsamp,nrowp,1,1,bufpadr,irtflg)
         close(lunin)
c---------------------------
#endif


C        CROSS CORRELATION BUFPADI vs BUFPADR ------------------- CC
         SKIP_PEAK   = .FALSE.
         NORMIT      = .TRUE.
         SPIDER_SIGN = .FALSE.

         CALL APCC(NSAMP, 2*NSAM,2*NROW,1, BUFPADI,BUFPADR,
     &             SKIP_PEAK,NORMIT,SPIDER_SIGN, 
     &             ISHRANGE,ISHRANGE,0,
     &             XSHNEW,YSHNEW,ZDUM, PEAKV,IRTFLG)

        IF (IRTFLG .NE. 0)  THEN
           CALL ERRT(101,'APSHIFT CC ERROR',NE)
           RETURN
        ENDIF

C       NORMALIZATION (PROPERLY WOULD NEED SIG AFTER PADDING!) al

        PEAKV = PEAKV / FLOAT(NSAMP*NROWP-1) / SIGI / SIGR

C       ADJUST FOR MIRROR OF IMAGE NOT MIRROR OF REF. IMAGE
        IF (MIRRORNEW) THEN              ! BUG FIX MAR 2011
           IODD = MOD(NSAM,2)
           IF (IODD == 0) THEN
              XSHNEW = 1 - XSHNEW
           ELSE
              XSHNEW = -XSHNEW
           ENDIF
        ENDIF            
        
        END

#ifdef NEVER
        write(6,*) 'peakv0:',peakv,NSAMP*NROWP,sigi,sigr
        write(6,*) 'peakv1:',peakv
        write(6,*) 'peakv1/npixm1:',peakv/FLOAT(NSAMP*NROWP-1)
        write(6,*) 'peakv2:',peakv
        write(6,*) '1/peakv2:',1.0/peakv
#endif

@


1.20
log
@removed apshift_fou.f
@
text
@d10 2
d54 1
a54 2
C              SIGR        REF. IMAGE STATISTICS                  SENT
C              ISHRANGE..  POSSIBLE IMAGE SHIFTS                  SENT
d68 2
a69 1
     &                     RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,PEAKV,IRTFLG)
d76 12
a87 11
        INTEGER,INTENT(IN)             :: LUNIN
        CHARACTER(LEN=*)               :: REFPAT
        INTEGER,INTENT(IN)             :: IMGREF
        INTEGER,INTENT(IN)             :: NSAM,NROW,NSAMP,NROWP
        REAL,INTENT(IN)                :: EXPBUF(NSAM,NROW)
        REAL,INTENT(INOUT)             :: AVI,SIGI
        INTEGER,INTENT(IN)             :: ISHRANGE
        REAL,INTENT(OUT)               :: RANGNEW,XSHNEW,YSHNEW
        LOGICAL,INTENT(IN)             :: MIRRORNEW
        REAL,INTENT(OUT)               :: PEAKV
        INTEGER,INTENT(OUT)            :: IRTFLG
d89 2
a90 2
        LOGICAL                        :: SKIP_PEAK,NORMIT,SPIDER_SIGN
        CHARACTER(LEN=MAXNAM)          :: FILNAM
d93 2
a94 2
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADI   ! NSAMP=2*NSAM+2
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADR   ! NROWP=2*NROW
d96 18
a113 8
        INTEGER                        :: ISAM,ICENT,KCENT,NSAMP1,IROW
        INTEGER                        :: IGO,NLET,ITYPE,NSLICE,MAXIM
        INTEGER                        :: NE,IODD
        INTEGER                        :: QUADRI

        REAL                           :: XI,XOLD,YOLD,RN2,SN2,RW2,RS2
        REAL                           :: COD,SID,SIGR,PADVAL,YI,YCOD
        REAL                           :: YSID,ZDUM
d124 2
a125 2
         IF (MOD(NSAM,2) .EQ. 0)  RW2 = RW2 - 1.0
         IF (MOD(NROW,2) .EQ. 0)  RS2 = RS2 - 1.0
d131 2
a132 2
         COD = COSD(RANGNEW)
         SID = SIND(RANGNEW)
d135 1
a135 1
           YI  = IROW - ICENT
d138 3
a140 3
           YCOD =  YI * COD + ICENT
           YSID = -YI * SID + KCENT
           IGO  = (IROW - 1) * NSAM
d204 1
d214 1
a219 1
C       FFTW3 SCALING DONE ALREADY
d221 1
d236 8
a243 6
        !write(6,*) 'peakv0:',peakv,NSAMP*NROWP,sigi,sigr
        !PEAKV = PEAKV / (NSAM*NROW)              ! FFTW3 SCALING
        !write(6,*) 'peakv1:',peakv
        !write(6,*) 'peakv1/npixm1:',peakv/FLOAT(NSAMP*NROWP-1)
        !write(6,*) 'peakv2:',peakv
        !write(6,*) '1/peakv2:',1.0/peakv
@


1.19
log
@apshift_fou changes
@
text
@a9 1
C                   FOU                           AUG 11 ARDEAN LEITH
a62 216


C***************************** APSHIFT_FOU *****************************

        SUBROUTINE APSHIFT_FOU(LUNIN,  IMGREF,
     &                     NSAM,NROW,  NXLD, 
     &                     EXPBUF,     AVI,SIGI, AVR,SIGR,
     &                     BUFPADI,    BUFPADR,
     &                     F0,         X1,Y1,XY2, 
     &                     ISHRANGEX,  ISHRANGEY,
     &                     RANGNEW,    XSHNEW,YSHNEW,
     &                     MIRRORNEW,PEAKV,IRTFLG)

        IMPLICIT NONE

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER,INTENT(IN)     :: LUNIN
        INTEGER,INTENT(IN)     :: IMGREF
        INTEGER,INTENT(IN)     :: NSAM,NROW, NXLD
        REAL,   INTENT(IN)     :: EXPBUF(NSAM,NROW)
        REAL,   INTENT(IN)     :: AVI,SIGI
        REAL,   INTENT(IN)     :: AVR,SIGR
        INTEGER,INTENT(IN)     :: ISHRANGEX,ISHRANGEY
        REAL,INTENT(OUT)       :: BUFPADI(NXLD,NROW)  
        REAL,INTENT(IN)        :: BUFPADR(NXLD,NROW)    
        REAL                   :: F0(NXLD,NROW)
        REAL                   :: X1(NXLD,NROW),Y1(NXLD,NROW)
        REAL                   :: XY2(NXLD,NROW)

        REAL,   INTENT(INOUT)  :: RANGNEW
        REAL,   INTENT(OUT)    :: XSHNEW,YSHNEW
        LOGICAL,INTENT(IN)     :: MIRRORNEW
        REAL,   INTENT(OUT)    :: PEAKV
        INTEGER,INTENT(OUT)    :: IRTFLG


        CHARACTER(LEN=1)       :: NULL = CHAR(0)
        CHARACTER(LEN=MAXNAM)  :: FILNAM
        INTEGER * 8            :: IPLAN = 0     !STRUCTURE POINTER 

        INTEGER                :: NLET,NSLICE,MAXIM,ICENT,KCENT
        INTEGER                :: IREP,IROW,IGO,ISAM,ITYPE,NSAMP1
        INTEGER                :: NE,IBEST,IODD,MWANT,INV
        integer                :: nsamt,nrowt,nslicet,itypet
                   
        REAL                   :: PADVAL,RN2,SN2,RW2,RS2
        REAL                   :: COD,SID,YI,YCOD,YSID,XOLD,YOLD
        REAL                   :: XI,ZDUM
        REAL                   :: fbs_fast,quadri

        INTEGER                :: ILOCS(2)
        LOGICAL                :: SPIDER_SCALE = .FALSE.
        LOGICAL                :: SPIDER_SIGN  = .FALSE.
        LOGICAL                :: NORMIT       = .TRUE.
        LOGICAL                :: DO_FFT_I     = .TRUE.
        LOGICAL                :: DO_FFT_R     = .FALSE.
        LOGICAL                :: SKIP_PEAK    = .FALSE.

        REAL                   :: PEAKVT(2), RANGNEWT(2)
        REAL                   :: XSHNEWT(2),YSHNEWT(2)
        REAL                   :: MIRRORNEWT(2)
 
         IF (USE_FBS_INTERP) THEN
C           PREPARE DATA FOR FSBI
            F0(1:NSAM, 1:NROW) = EXPBUF(1:NSAM, 1:NROW)  ! PADDED
            CALL FBS_PREP(F0, X1,Y1, XY2, NXLD, NSAM,NROW, IRTFLG)
            IF (IRTFLG .NE. 0) GOTO 9999
         ENDIF

         NSAMP1      = NSAM + 1
         ICENT       = NROW/2+1
         KCENT       = NSAM/2+1
         RN2         = -NROW/2
         SN2         = -NSAM/2

         RW2         = -RN2
         RS2         = -SN2
         IF (MOD(NSAM,2) .EQ. 0) RW2 = RW2 - 1.0
         IF (MOD(NROW,2) .EQ. 0) RS2 = RS2 - 1.0

         RANGNEWT(1) = RANGNEW
         RANGNEWT(2) = RANGNEW + 180.0

         DO IREP = 1,2

            !call chkcmplx('rings',bufpadr,nxld*nrow, nxld,4,nrow*nxld)

C           ROTATE EXP IMAGE BY RANGNEW & PAD FOR FFT  ------ ROTATE

            RANGNEW = RANGNEWT(IREP)
            COD     = COSD(RANGNEW)
            SID     = SIND(RANGNEW)

            DO IROW=1,NROW
               YI = IROW - ICENT
               IF (YI .LT. RN2)  YI = MIN(RW2+YI-RN2+1.0, RW2)
               IF (YI .GT. RW2)  YI = MAX(RN2+YI-RW2-1.0, RN2)

               YCOD =  YI * COD + ICENT
               YSID = -YI * SID + KCENT
               IGO  = (IROW - 1) * NSAM

               IF (USE_FBS_INTERP) THEN

c$omp            parallel do private(isam,xi,xold,yold)
                 DO ISAM=1,NSAM
                    XI = ISAM - KCENT 

                    IF (XI .LT. SN2) XI = MIN(RS2+XI-SN2+1.0,RS2)
                    IF (XI .GT. RS2) XI = MAX(SN2+XI-RS2-1.0,SN2)

                    YOLD = XI * SID  + YCOD
                    XOLD = XI * COD  + YSID

                    IF (.NOT. MIRRORNEW) THEN
C                      NO MIRROR 
                       BUFPADI(ISAM,IROW) = FBS_FAST(XOLD,YOLD,
     &                                 NSAM,NROW,EXPBUF,X1,Y1,XY2)
                    ELSE
C                      MIRROR THE IMAGE IN PLACE  
                       BUFPADI(NSAMP1-ISAM,IROW) = FBS_FAST(XOLD,YOLD,
     &                                 NSAM,NROW,EXPBUF,X1,Y1,XY2)
                    ENDIF
	         ENDDO

              ELSE
c$omp            parallel do private(isam,xi,xold,yold)
                 DO ISAM=1,NSAM
                    XI = ISAM - KCENT
 
                    IF (XI .LT. SN2) XI = MIN(RS2+XI-SN2+1.0,RS2)
                    IF (XI .GT. RS2) XI = MAX(SN2+XI-RS2-1.0,SN2)

                    YOLD = XI * SID  + YCOD
                    XOLD = XI * COD  + YSID

                    IF (.NOT. MIRRORNEW) THEN
C                      NO MIRROR 
                       BUFPADI(ISAM,IROW) = 
     &                         QUADRI(XOLD,YOLD,NSAM,NROW,EXPBUF)
                    ELSE
C                      MIRROR THE IMAGE IN PLACE  
                       BUFPADI(NSAMP1-ISAM,IROW) = 
     &                         QUADRI(XOLD,YOLD,NSAM,NROW,EXPBUF)
                    ENDIF
	         ENDDO

              ENDIF
	    ENDDO

#ifdef DEBUGNEVER
c-----------------debug
         bufpadi(NSAM+1:NXLD, 1:NROW) = AVI !not needed for fft

         !write(6,*) ' nxld,nsam: ', nxld,nsam
         maxim = 0
         itype = 1
         if (irep ==1) then
         call opfilec(0,.false.,'jnkpadi',lunin,'U',itype,
     &                nxld,nrow,1,maxim,' ',.false.,irtflg)
         call wrtvol(lunin,nxld,nrow,1,1,bufpadi,irtflg)
         close(lunin)
         endif
c---------------------------
#endif

C           FFT CROSS CORRELATION BUFPADI vs BUFPADR --------------- CC
            CALL APCC_NEW(NXLD, NSAM,NROW,1, 
     &                BUFPADI, BUFPADR,
     &                DO_FFT_I, DO_FFT_R,
     &                SKIP_PEAK,NORMIT,SPIDER_SIGN, 
     &                ISHRANGEX,ISHRANGEY,0,
     &                XSHNEWT(IREP),YSHNEWT(IREP),
     &                ZDUM, PEAKVT(IREP),IRTFLG)
            IF (IRTFLG .NE. 0)  THEN
               CALL ERRT(101,'APSHIFT_FOU CC ERROR',NE)
               RETURN
            ENDIF
        ENDDO

        !write(6,*)' 1:',rangnewt(1),xshnewt(1),yshnewt(1),peakvt(1)
        !write(6,*)' 2:',rangnewt(2),xshnewt(2),yshnewt(2),peakvt(2)

C       NORMALIZATION 
C       NO SCALING IN FMRS OR IN CCRS, IS SCALED BY 1/NSAM*NROW in APCC
 
        IBEST = 1
        IF (PEAKVT(2) > PEAKVT(1)) IBEST = 2

        RANGNEW = RANGNEWT(IBEST)
        XSHNEW  = XSHNEWT (IBEST)
        YSHNEW  = YSHNEWT (IBEST)
      
        PEAKV   = PEAKVT(IBEST)            ! FFTW3 SCALING DONE ALREADY
        PEAKV   = PEAKV / FLOAT(NSAM*NROW-1) / SIGI / SIGR

C       ADJUST FOR MIRROR OF IMAGE NOT MIRROR OF REF. IMAGE
        IF (MIRRORNEW) THEN              ! BUG FIX MAR 2011
           IODD = MOD(NSAM,2)
           IF (IODD == 0) THEN
              XSHNEW = 1 - XSHNEW
           ELSE
              XSHNEW = -XSHNEW
           ENDIF
        ENDIF            
    
    
9999    CONTINUE

        END



C***************************** APSHIFT *********************************
@


1.18
log
@added FOU routine
@
text
@d5 1
a5 1
C                   AVS ERROR IF NOT NORM3        JUN 04 ARDEAN LEITH
d34 1
a34 1
C          EXPBUF,AVS,SIGI, ISHRANGE,
d52 3
a54 2
C              AVS,SIGI    EXP. IMAGE STATISTICS                  SENT
C              ISHRANGE    POSSIBLE IMAGE SHIFT                   SENT
a64 125
        SUBROUTINE APSHIFT(LUNIN, REFPAT,IMGREF,
     &                     NSAM,NROW, NSAMP,NROWP, 
     &                     EXPBUF,AVS,SIGI, ISHRANGE,
     &                     RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,PEAKV,IRTFLG)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER,INTENT(IN)                    :: LUNIN
        CHARACTER(LEN=*)                      :: REFPAT
        INTEGER,INTENT(IN)                    :: IMGREF
        INTEGER,INTENT(IN)                    :: NSAM,NROW,NSAMP,NROWP
        REAL,INTENT(IN)                       :: EXPBUF(NSAM,NROW)
        REAL,INTENT(INOUT)                    :: AVS,SIGI
        INTEGER,INTENT(IN)                    :: ISHRANGE
        REAL,INTENT(OUT)                      :: RANGNEW,XSHNEW,YSHNEW
        LOGICAL,INTENT(IN)                    :: MIRRORNEW
        REAL,INTENT(OUT)                      :: PEAKV
        INTEGER,INTENT(OUT)                   :: IRTFLG

        DOUBLE PRECISION                      :: DSIGI,DSIGR,DAVR,DAVI

        LOGICAL                        :: SKIP_PEAK,NORMIT,SPIDER_SIGN
        CHARACTER(LEN=MAXNAM)          :: FILNAM

C       AUTOMATIC ARRAYS
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADI   ! NSAMP=2*NSAM+2
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADR   ! NROWP=2*NROW

        PARAMETER (QUADPI = 3.1415926535897932384626)
        PARAMETER (DGR_TO_RAD = (QUADPI/180))

#ifdef DEBUG
         write(6,*) '----- in apshift ---'
         write(6,*) 'IMGREF,RANGNEW, MIRRORNEW'
         write(6,*)  IMGREF,RANGNEW, MIRRORNEW 
#endif

C        ROTATE IMAGE BY RANGNEW & PAD TO 2X SIZE

         ICENT = NROW/2+1
         KCENT = NSAM/2+1
         RN2   = -NROW/2
         SN2   = -NSAM/2
         RW2   = -RN2
         RS2   = -SN2

         IF (MOD(NSAM,2) .EQ. 0)  RW2 = RW2 - 1.0
         IF (MOD(NROW,2) .EQ. 0)  RS2 = RS2 - 1.0

         NSAMP1 = NSAM + 1

C        ROTATE THE IMAGE ------------------------------------- ROTATE

         COD = COS(RANGNEW * DGR_TO_RAD)
         SID = SIN(RANGNEW * DGR_TO_RAD)
         DO IROW=1,NROW
           YI = IROW - ICENT
           IF (YI .LT. RN2)  YI = MIN(RW2+YI-RN2+1.0, RW2)
           IF (YI .GT. RW2)  YI = MAX(RN2+YI-RW2-1.0, RN2)
           YCOD   =  YI * COD + ICENT
           YSID   = -YI * SID + KCENT
           IGO    = (IROW - 1) * NSAM

c$omp      parallel do private(isam,xi,xold,yold)
           DO ISAM=1,NSAM
              XI = ISAM - KCENT 
              IF (XI .LT. SN2)  XI = MIN(RS2+XI-SN2+1.0,RS2)
              IF (XI .GT. RS2)  XI = MAX(SN2+XI-RS2-1.0,SN2)
              YOLD = XI * SID  + YCOD
              XOLD = XI * COD  + YSID

              IF (.NOT. MIRRORNEW) THEN
C                NO MIRROR 
                 BUFPADI(ISAM,IROW) = 
     &                   QUADRI(XOLD,YOLD,NSAM,NROW,EXPBUF)
              ELSE
C                MIRROR THE IMAGE IN PLACE  
                 BUFPADI(NSAMP1-ISAM,IROW) = 
     &                   QUADRI(XOLD,YOLD,NSAM,NROW,EXPBUF)
              ENDIF
	   ENDDO

C          FILL REMAINING EMPTY COLS IN PADDED IMAGE
           BUFPADI(NSAMP1:NSAMP, IROW) = AVS
	 ENDDO

C        FILL REMAINING EMPTY ROWS IN PADDED IMAGE
         BUFPADI(1:NSAMP, NROW+1:NROWP) = AVS

C        OPEN REFERENCE IMAGE INPUT FILE
         NLET = 0
         CALL FILGET(REFPAT,FILNAM,NLET,IMGREF,IRTFLG)
         IF (IRTFLG .NE. 0)  RETURN

         CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',ITYPE,
     &                NSAM,NROW,NSLICE,MAXIM,'INPUT',.FALSE.,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
         IF (IMAMI .NE. 1) 
     &       CALL NORM3(LUNIN,NSAM,NROW,NSLICE,FMAX,FMIN,AV)
         SIGR = SIG

C        LOAD & PAD REFERENCE IMAGE TO DOUBLE SIZE (WITH ZEROS!)
         PADVAL = 0.0
         CALL REDNPADVOL(LUNIN,PADVAL, 
     &                   NSAM,NROW,1,  2*NSAM+2,2*NROW,1,
     &                   BUFPADR, IRTFLG)
         IF (IRTFLG .NE. 0) RETURN

         CLOSE(LUNIN)

#ifdef DEBUGNEVER
c-----------------debug
         write(6,*) ' nsamp,nrowp: ', nsamp,nrowp

         call opfilec(0,.false.,'jnkpadi',lunin,'U',itype,
     &                nsamp,nrowp,1,maxim,' ',.false.,irtflg)
         call wrtvol(lunin,nsamp,nrowp,1,1,bufpadi,irtflg)
         close(lunin)
         call opfilec(0,.false.,'jnkpadr',lunin,'U',itype,
     &                nsamp,nrowp,1,maxim,' ',.false.,irtflg)
         call wrtvol(lunin,nsamp,nrowp,1,1,bufpadr,irtflg)
         close(lunin)
c---------------------------
#endif
d66 1
d68 7
a74 44
C        CROSS CORRELATION BUFPADI vs BUFPADR ------------------- CC
         SKIP_PEAK   = .FALSE.
         NORMIT      = .TRUE.
         SPIDER_SIGN = .FALSE.

         CALL APCC(NSAMP, 2*NSAM,2*NROW,1, BUFPADI,BUFPADR,
     &             SKIP_PEAK,NORMIT,SPIDER_SIGN, 
     &             ISHRANGE,ISHRANGE,0,
     &             XSHNEW,YSHNEW,ZDUM, PEAKV,IRTFLG)

        IF (IRTFLG .NE. 0)  THEN
           CALL ERRT(101,'APSHIFT CC ERROR',NE)
           RETURN
        ENDIF

C       NORMALIZATION (PROPERLY WOULD NEED SIG AFTER PADDING!) al
        !write(6,*) 'peakv0:',peakv,NSAMP*NROWP,sigi,sigr
        !PEAKV = PEAKV / (NSAM*NROW)              ! FFTW3 SCALING
        !write(6,*) 'peakv1:',peakv
        !write(6,*) 'peakv1/npixm1:',peakv/FLOAT(NSAMP*NROWP-1)

        PEAKV = PEAKV / FLOAT(NSAMP*NROWP-1) / SIGI / SIGR
        !write(6,*) 'peakv2:',peakv
        !write(6,*) '1/peakv2:',1.0/peakv

C       ADJUST FOR MIRROR OF IMAGE NOT MIRROR OF REF. IMAGE
        IF (MIRRORNEW) THEN              ! BUG FIX MAR 2011
           IODD = MOD(NSAM,2)
           IF (IODD == 0) THEN
              XSHNEW = 1 - XSHNEW
           ELSE
              XSHNEW = -XSHNEW
           ENDIF
        ENDIF            
        
        END


C***************************** APSHIFT_FOU ****************************

        SUBROUTINE APSHIFT_FOU(LUNIN, REFPAT,IMGREF,
     &                     NSAM,NROW, NSAMP,NROWP, 
     &                     EXPBUF,AVS,SIGI, ISHRANGEX,ISHRANGEY,
     &                     RANGNEW,  XSHNEW,YSHNEW,
a82 1
        CHARACTER(LEN=*)       :: REFPAT
d84 1
a84 1
        INTEGER,INTENT(IN)     :: NSAM,NROW,NSAMP,NROWP
d86 2
a87 1
        REAL,INTENT(INOUT)     :: AVS,SIGI
d89 8
a96 2
        REAL,INTENT(INOUT)     :: RANGNEW
        REAL,INTENT(OUT)       :: XSHNEW,YSHNEW
d98 1
a98 1
        REAL,INTENT(OUT)       :: PEAKV
d101 2
a102 1
        LOGICAL                :: SKIP_PEAK,NORMIT,SPIDER_SIGN
d104 1
a104 5

C       AUTOMATIC ARRAYS
        REAL                   :: BUFPADI (NSAMP,NROWP)  ! NSAMP=2*NSAM+2
        REAL                   :: BUFPADR1(NSAMP,NROWP)    
        REAL                   :: BUFPADR2(NSAMP,NROWP)    
d108 4
a111 5
        INTEGER                :: NE,IBEST,IODD,NXLD,MWANT
        integer                :: npixm1,isxm1,isym1 
        real                   :: fnpix
                           
        REAL                   :: SIGR,PADVAL,RN2,SN2,RW2,RS2
d113 10
a122 2
        REAL                   :: XI,QUADRI,ZDUM
        REAL                   :: FBS_FAST
a126 1
        DOUBLE PRECISION       :: DSIGI(2),DSIGR,DAVR,DAVI
d128 5
a132 25
        REAL, ALLOCATABLE      :: F0(:,:),X1(:,:),Y1(:,:),XY2(:,:)

        REAL, PARAMETER        :: QUADPI = 3.1415926535897932384626
        REAL, PARAMETER        :: DGR_TO_RAD = (QUADPI/180)

#ifdef DEBUG
        write(6,*) '----- in apshift ---'
        write(6,*)'IMGREF,RANGNEW,MIRRORNEW',IMGREF,RANGNEW,MIRRORNEW 
#endif

        IF (USE_FBS_INTERP) THEN
           NXLD   = NSAM + 2 - MOD(NSAM,2)

           ALLOCATE (F0 (NXLD,  NROW),
     &               X1 (NXLD,  NROW),
     &               Y1 (NXLD,  NROW),
     &               XY2(NXLD,  NROW),
     &               STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN 
              MWANT = 4*NXLD*NROW 
              CALL ERRT(46,'APSHIF_FOU; F0...',MWANT)
              GOTO 9999
           ENDIF  
           CALL FBS_PREP(F0, X1,Y1, XY2, NXLD, NSAM,NROW, IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
a134 36
C        OPEN REFERENCE IMAGE INPUT FILE
         NLET = 0
         CALL FILGET(REFPAT,FILNAM,NLET,IMGREF,IRTFLG)
         IF (IRTFLG .NE. 0)  RETURN

         CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',ITYPE,
     &                NSAM,NROW,NSLICE,MAXIM,'INPUT',.FALSE.,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
         IF (IMAMI .NE. 1) 
     &       CALL NORM3(LUNIN,NSAM,NROW,NSLICE,FMAX,FMIN,AV)
         SIGR = SIG

C        LOAD & PAD REFERENCE IMAGE TO DOUBLE SIZE (WITH ZEROS!)
         PADVAL = 0.0
         CALL REDNPADVOL(LUNIN,PADVAL, 
     &                   NSAM,NROW,1,  2*NSAM+2,2*NROW,1,
     &                   BUFPADR1, IRTFLG)
         IF (IRTFLG .NE. 0) RETURN

         CLOSE(LUNIN)
         BUFPADR2 = BUFPADR1  ! WHOLE ARRAY 

C        FIND CC NORM VALUES
         !CALL NORMVALSP(BUFPADR1,2*NSAM,2*NROW,NSAMP,NROWP,DAVR,DSIGR,.TRUE.)
         !SIGR = DSIGR

#ifdef DEBUGNEVER
c-----------------debug
         write(6,*) ' nsamp,nrowp: ', nsamp,nrowp
         call opfilec(0,.false.,'jnkpadr',lunin,'U',itype,
     &             nsamp,nrowp,1,maxim,' ',.false.,irtflg)
         call wrtvol(lunin,nsamp,nrowp,1,1,bufpadr1,irtflg)
         close(lunin)
c---------------------------
#endif

d140 1
d143 2
d149 1
a149 2
         IF (MOD(NSAM,2) .EQ. 0) RW2 = RW2 - 1.0
         IF (MOD(NROW,2) .EQ. 0) RS2 = RS2 - 1.0
d151 1
a151 1
         DO IREP = 1,2
d153 1
a153 1
C           ROTATE EXP IMAGE BY RANGNEW & PAD TO 2X SIZE ------ ROTATE
d156 2
a157 2
            COD     = COS(RANGNEW * DGR_TO_RAD)
            SID     = SIN(RANGNEW * DGR_TO_RAD)
d164 3
a166 3
               YCOD   =  YI * COD + ICENT
               YSID   = -YI * SID + KCENT
               IGO    = (IROW - 1) * NSAM
a215 10
C           DETERMINE UNPADDED STATISTICS
            !!CALL NORMVALSP(BUFPADI,NSAM,NROW, 2*NSAM+2,2*NROW,
            !!&                     DAVI,DSIGI(IREP),.TRUE.)

C           FILL REMAINING EMPTY COLS IN PADDED IMAGE
            BUFPADI(NSAMP1:NSAMP, 1:NROW) = AVS !DAVI

C           FILL REMAINING EMPTY ROWS IN PADDED IMAGE
            BUFPADI(1:NSAMP, NROW+1:NROWP) = AVS !DAVI

d218 1
a218 8
            write(6,*) ' nsamp,nrowp: ', nsamp,nrowp
            if (irep > 1) THEN
               call opfilec(0,.false.,'jnkpadi2',lunin,'U',itype,
     &                nsamp,nrowp,1,maxim,' ',.false.,irtflg)
            else
               call opfilec(0,.false.,'jnkpadi1',lunin,'U',itype,
     &                nsamp,nrowp,1,maxim,' ',.false.,irtflg)
            endif
d220 9
a228 2
            call wrtvol(lunin,nsamp,nrowp,1,1,bufpadi,irtflg)
            close(lunin)
d232 4
a235 12
C           DETERMINE PADDED STATISTICS
            !!CALL NORMVALSP(BUFPADI,2*NSAM,2*NROW, 2*NSAM+2,2*NROW,
     &      !!               DAVI,DSIGI(IREP),.TRUE.)

C           CROSS CORRELATION BUFPADI vs BUFPADR ------------------- CC
            SKIP_PEAK   = .FALSE.
            NORMIT      = .TRUE.
            SPIDER_SIGN = .FALSE.

            IF (IREP ==  1) THEN
              CALL APCC(NSAMP, 2*NSAM,2*NROW,1, 
     &                BUFPADI,BUFPADR1,
a239 9
            ELSE
               CALL APCC(NSAMP, 2*NSAM,2*NROW,1, 
     &                BUFPADI,BUFPADR2,
     &                SKIP_PEAK,NORMIT,SPIDER_SIGN, 
     &                ISHRANGEX,ISHRANGEY,0,
     &                XSHNEWT(IREP),YSHNEWT(IREP),
     &                ZDUM, PEAKVT(IREP),IRTFLG)
            ENDIF

d242 1
a242 1
               GOTO 9999
a243 1

d246 2
a247 1
        !write(6,*)' Peaks:',PEAKVT(1),PEAKVT(2)
d249 3
a254 6
        !write(6,*) ' peakvt:', peakvt(1),peakvt(2)
        !write(6,*) ' xshnewt:',xshnewt(1),xshnewt(2)

C       NO SCALING IN FMRS OR IN CCRS, IS SCALED BY 1/NSAM*NROW in APCC
C       NORMALIZATION (PROPERLY WOULD NEED SIG AFTER PADDING!) al
 
d258 2
a259 14

        !sigi   = dsigi   (ibest)
        !peakv  = peakvt(ibest)
        !npixm1 = (nsam*2) * (nrow*2) -1
        !fnpix  = (nsam*2) * (nrow*2)
        !write(6,*) ' peakv:',peakv
        !write(6,*) ' peakv / npix:',  peakv / fnpix
        !write(6,*) ' peakv / npix  / sigi / sigr:', 
        !&               peakv / fnpix / sigi / sigr
        !write(6,*) ' peakv / npix  / sigi / sigr:', 
        !&               peakv / fnpix / sigi / sigr / fnpix
        !write(6,*) ' peakvyz(ibest):',PEAKVT(IBEST)
       
        PEAKV   = PEAKVT(IBEST)                         ! FFTW3 SCALING DONE ALREADY
d271 149
a419 6
        
9999    IF (USE_FBS_INTERP) THEN
           IF (ALLOCATED(F0))  DEALLOCATE (F0)
           IF (ALLOCATED(X1))  DEALLOCATE (X1)
           IF (ALLOCATED(Y1))  DEALLOCATE (Y1)
           IF (ALLOCATED(XY2)) DEALLOCATE (XY2)
d422 14
d437 7
@


1.17
log
@APCC DOES FFTW SCALIING NOW always
@
text
@d10 1
a10 2
C                   APCC DOES FFTW SCALIING NOW   AUG 11 ARDEAN LEITH
C
d72 13
a84 11
        INTEGER,INTENT(IN)           :: LUNIN
        CHARACTER(LEN=*)             :: REFPAT
        INTEGER,INTENT(IN)           :: IMGREF
        INTEGER,INTENT(IN)           :: NSAM,NROW,NSAMP,NROWP
        REAL,INTENT(IN)              :: EXPBUF(NSAM,NROW)
        REAL,INTENT(INOUT)           :: AVS,SIGI
        INTEGER,INTENT(IN)           :: ISHRANGE
        REAL,INTENT(OUT)             :: RANGNEW,XSHNEW,YSHNEW
        LOGICAL,INTENT(IN)           :: MIRRORNEW
        REAL,INTENT(OUT)             :: PEAKV
        INTEGER,INTENT(OUT)          :: IRTFLG
d86 2
a87 2
        LOGICAL                      :: SKIP_PEAK,NORMIT,SPIDER_SIGN
        CHARACTER(LEN=MAXNAM)        :: FILNAM
d90 2
a91 2
        REAL, DIMENSION(NSAMP,NROWP) :: BUFPADI   ! NSAMP=2*NSAM+2
        REAL, DIMENSION(NSAMP,NROWP) :: BUFPADR   ! NROWP=2*NROW
d207 4
d213 2
d228 59
a286 6
#ifdef NEVER
        write(6,*) 'peakv0:',peakv,NSAMP*NROWP,sigi,sigr
        write(6,*) 'peakv1:',peakv
        write(6,*) 'peakv1/npixm1:',peakv/FLOAT(NSAMP*NROWP-1)
        write(6,*) 'peakv2:',peakv
        write(6,*) '1/peakv2:',1.0/peakv
d289 238
@


1.16
log
@mirrornew is sent not ret.
@
text
@d10 2
d34 4
a37 2
C  APSHIFT()                                  
C
d73 11
a83 11
        INTEGER,INTENT(IN)                    :: LUNIN
        CHARACTER(LEN=*)                      :: REFPAT
        INTEGER,INTENT(IN)                    :: IMGREF
        INTEGER,INTENT(IN)                    :: NSAM,NROW,NSAMP,NROWP
        REAL, DIMENSION(NSAM,NROW),INTENT(IN) :: EXPBUF
        REAL,INTENT(IN)                       :: AVS,SIGI
        INTEGER,INTENT(IN)                    :: ISHRANGE
        REAL,INTENT(OUT)                      :: RANGNEW,XSHNEW,YSHNEW
        LOGICAL,INTENT(OUT)                   :: MIRRORNEW
        REAL,INTENT(OUT)                      :: PEAKV
        INTEGER,INTENT(OUT)                   :: IRTFLG
d85 2
a86 2
        LOGICAL                        :: SKIP_PEAK,NORMIT,SPIDER_SIGN
        CHARACTER(LEN=MAXNAM)          :: FILNAM
d89 2
a90 2
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADI   ! NSAMP=2*NSAM+2
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADR   ! NROWP=2*NROW
d100 1
a100 1
  
d165 1
a165 1
C        LOAD & PAD REFERENCE IMAGE TO DOUBLE SIZE
d172 1
a172 1
          CLOSE(LUNIN)
d189 1
d201 6
a206 8
            CALL ERRT(101,'APSHIFT CC ERROR',NE)
            RETURN
         ENDIF

C       NORMALIZATION (PROPERLY WOULD NEED SIG AFTER PADDING!)al
#ifdef SP_LIBFFTW3
        PEAKV = PEAKV / (NSAMP*NROWP)  ! FFTW3 SCALING
#endif
d221 7
@


1.15
log
@cosmetic
@
text
@d53 1
a53 1
C              MIRRORNEW   LOGICAL FLAG THAT REF. NEEDS MIRROR    RET.
@


1.14
log
@mirrored xshift bug!
@
text
@d48 1
a48 1
C              EXPBUF      EXP. IMAGE BUFFER                      SENT                             RET.  
d54 1
a54 1
C              PEAKV       PEAK HEIGHT                            RET.                             RET.  
@


1.13
log
@GPL_2010
@
text
@d9 1
d14 1
a14 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d207 9
a215 3
        IF (MIRRORNEW) XSHNEW = -XSHNEW

        RETURN
@


1.12
log
@ refactored
@
text
@a9 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d11 5
a15 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d17 1
a17 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d22 1
a22 1
C=* This program is distributed in the hope that it will be useful,    *
d24 1
a24 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a25 1
C=*                                                                    *
d27 1
a27 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.11
log
@cc for shift multipled for fftw3
@
text
@d8 1
d40 1
a40 1
C            ROTATE BUFIN IMAGE BY RANGNEW, MIRROR IF NECESSARY, PAD 
d45 4
a48 2
C              EXPPAT      REF. IMAGE NAME                        SENT
C              BUFIN       EXP. IMAGE BUFFER                      SENT
d50 3
a52 3
C              IMGREF      REF. IMAGE NUMBER                      SENT
C              REFPAT      REF. IMAGE NAME                        SENT
C              BUFIN       WORK BUFFER                            SENT                             RET.  
a53 1
C              NSAMP,NROWP NSAMP=2*NSAM+2,NROWP=2*NSAM            SENT
d64 3
a66 3
        SUBROUTINE APSHIFT(LUNIN,EXPPAT,NSAM,NROW,IMGEXP,IMGREF,
     &                     REFPAT,BUFIN,ISHRANGE,
     &                     NSAMP,NROWP,
d72 11
a82 3
C       AUTOMATIC ARRAYS
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADI   ! NSAMP=2*NSAM+2
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADR
a83 5
        REAL, DIMENSION(NSAM,NROW)     :: BUFIN
        INTEGER, DIMENSION(2)          :: ILOCS
        INTEGER, DIMENSION(1)          :: IMGEXP

        LOGICAL                        :: MIRRORNEW
a84 1
        CHARACTER (LEN=*)              :: EXPPAT,REFPAT
d87 4
d94 2
a95 2
#ifdef DEBUGD
         write(6,*) '----- in apshift ---', IMGEXP
a99 10
C        LOAD EXP. IMAGE INTO ARRAY BUFIN (CALLS NORM3 IF NEEDED)
         NIMA = 1
	 CALL AP_GETDATS(IMGEXP,NIMA,NSAM,NROW,
     &                  1,EXPPAT,LUNIN, 1,1, BUFIN, IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
         SIGI   = SIG

C        SET PADDING VALUE  TO AV (PASSED BY COMMON)
         AVS = AV

d116 2
a117 2
         COD = COS(RANGNEW*DGR_TO_RAD)
         SID = SIN(RANGNEW*DGR_TO_RAD)
d137 1
a137 1
     &                   QUADRI(XOLD,YOLD,NSAM,NROW,BUFIN)
d141 1
a141 1
     &                   QUADRI(XOLD,YOLD,NSAM,NROW,BUFIN)
d165 5
a169 2
         DO IROW = 1,NROW
            CALL REDLIN(LUNIN,BUFPADR(1,IROW),NSAM,IROW)
d171 1
a171 4
C           FILL REMAINING EMPTY COLS IN PADDED REFERENCE IMAGE
            BUFPADR(NSAMP1:NSAMP, IROW) = 0.0
         ENDDO
         CLOSE(LUNIN)
d173 14
a186 2
C        FILL REMAINING EMPTY ROWS IN PADDED REFERENCE IMAGE
         BUFPADR(1:NSAMP, NROW+1:NROWP) = 0.0
@


1.10
log
@*** empty log message ***
@
text
@d86 2
a87 2
#ifdef NEVER
         write(6,*) '----- in apshift ---'
d194 3
a205 26

C       -------------------- UNUSED BELOW ---------------------------

#ifdef DEBUGNEVER
c----------------------
        maxim = 0
        call opfilec(0,.false.,'jnknewexppad',98,'U',itype,
     &                nsamp,nrowp,1,maxim,' ',.false.,irtflg)
        call wrtvol(98,nsamp,nrowp,1,1,bufpadi,irtflg)
        close(98)
        maxim = 0
        call opfilec(0,.false.,'jnknewrefpad',98,'U',itype,
     &                nsamp,nrowp,1,maxim,' ',.false.,irtflg)
        call wrtvol(98,nsamp,nrowp,1,1,bufpadr,irtflg)
        close(98)
c-----------------------
#endif


#ifdef NEVER
        write(6,*) ' In: apshift.f ------------- '
        write(6,*) 'IX,IY, SCALED-PEAKV'
        write(6,*)  IX,IY, PEAKV
#endif


@


1.9
log
@ split out apcc
@
text
@d194 1
a194 1
        PEAKV = PEAKV / FLOAT(NSAMP*NROWP-1.0) / SIGI / SIGR
@


1.8
log
@ccrs_ added parameter
@
text
@d7 1
d10 1
a10 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d43 16
a58 11
C  PARAMETERS: LUNIN      IO UNIT                                SENT
C              EXPPAT     REF. IMAGE NAME                        SENT
C              BUFIN      EXP. IMAGE BUFFER                      SENT
C              NSAM,NROW  INPUT IMAGE DIMENSIONS                 SENT
C              ISHRANGE   POSSIBLE IMAGE SHIFT                   SENT
C              RANGNEW    INPLANE ROTATION ANGLE                 SENT
C              MIRRORNEW  LOGICAL FLAG THAT REF. NEEDS MIRROR    SENT
C              IMGREF     REF. IMAGE NUMBER                      SENT
C              REFPAT     REF. IMAGE NAME                        SENT
C              BUFIN      WORK BUFFER                            SENT                             RET.  
C              IRTFLG     ERROR FLAG                             RET.  
a66 1

d71 1
a71 1
        REAL, DIMENSION(NSAMP,NROWP)   :: BUFPADI
a73 1
C       REAL, DIMENSION(NSAM)          :: BUFLINE
d79 1
d86 2
a87 4
C       IRTFLG = 1

#ifdef DEBUG
         write(6,*) '--------', IMGEXP
d95 1
a95 2
     &                  1,EXPPAT,LUNIN, 1,1,
     &                  BUFIN, IRTFLG)
d133 2
a134 2
              YOLD         = XI * SID  + YCOD
              XOLD         = XI * COD  + YSID
d168 1
a168 8
c            IF (.NOT. MIRRORNEW) THEN
               CALL REDLIN(LUNIN,BUFPADR(1,IROW),NSAM,IROW)
c            ELSE
c              CALL REDLIN(LUNIN,BUFLINE,NSAM,IROW)
c              DO I = 1,NSAM
c                 BUFPADR(I,IROW) = BUFLINE(NSAM-I+1)
c              ENDDO
c           ENDIF
d177 30
a206 1
#ifdef DEBUG
d209 1
a209 1
        call opfilec(0,.false.,'jnkexppad',98,'U',itype,
d214 1
a214 1
        call opfilec(0,.false.,'jnkrefpad',98,'U',itype,
a220 56
         IF (IRTFLG .NE. 0) RETURN
  
C        CROSS CORRELATION --------------------------------------- CC
              
2        INV = +1
         CALL FMRS_2(BUFPADI, 2*NSAM,2*NROW,INV)
         IF (INV .EQ. 0) THEN
            CALL ERRT(101,'APSHIFT FFT ERROR',NE)
            RETURN
         ENDIF

         INV = +1
         CALL FMRS_2(BUFPADR, 2*NSAM,2*NROW,INV)
         IF (INV .EQ. 0)  THEN
            CALL ERRT(101,'APSHIFT FFT ERROR',NE)
            RETURN
         ENDIF

         BUFPADR(1,1) = (0.0)
         BUFPADR(2,1) = (0.0)

        LSC = 2*NSAM+2-MOD(2*NSAM,2)
        CALL CCRS_2(BUFPADI,BUFPADR,BUFPADI, LSC,2*NSAM,2*NROW)

#ifdef DEBUG
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,'jnkpkpad',98,'U',ITYPE,
     &                NSAMP,NROWP,1,MAXIM,' ',.FALSE.,IRTFLG)
        CALL WRTVOL(98,NSAMP,NROWP,1,1,BUFPADI,IRTFLG)
        CLOSE(98)
#endif

C       PEAK SEARCH ON THE WINDOWED CC IMAGE -------------------- PEAK

C       WINDOW SIZE
        IWSIZ  = 2 * ISHRANGE + 1
 
C       WINDOW CORNER
        IWCORX = NSAM - ISHRANGE + 1  
        IWCORY = NROW - ISHRANGE + 1  

C       PEAK SEARCH 
        ILOCS  = MAXLOC(BUFPADI(IWCORX:IWCORX+IWSIZ-1,
     &                          IWCORY:IWCORY+IWSIZ-1))

        IX     = ILOCS(1) + IWCORX - 1
        IY     = ILOCS(2) + IWCORY - 1

        IXSH   = ILOCS(1) - ISHRANGE - 1
        IYSH   = ILOCS(2) - ISHRANGE - 1

C       PARABOLIC FIT TO THE 3X3 NEIGHBORHOOD OF PEAK
        CALL PARABL(BUFPADI(IX-1:IX+1, IY-1:IY+1),XSHNEW,YSHNEW,PEAKV)

        XSHNEW = -(IXSH + XSHNEW)
        YSHNEW = -(IYSH + YSHNEW)
d222 4
a225 11
C       ADJUST FOR MIRROR OF IMAGE NOT MIRROR OF REF. IMAGE
        IF (MIRRORNEW) XSHNEW = -XSHNEW
 
C       NORMALIZATION
        FAN    = 1.0 / (NSAMP*NROWP-1.0) / SIGI / SIGR
        CCPEAK = BUFPADI(IX,IY) * FAN
        PEAKV  = PEAKV * FAN

#ifdef DEBUG
        write(6,*) 'IX,IY,IXSH,IYSH,CCPEAK,XSHNEW,YSHNEW'
        write(6,*)  IX,IY,IXSH,IYSH,CCPEAK,XSHNEW,YSHNEW
a226 3
 
        RETURN
        END
@


1.7
log
@GPL License fixed
@
text
@d218 2
a219 1
        CALL CCRS_2(BUFPADI,BUFPADR,BUFPADI,2*NSAM,2*NROW)
@


1.6
log
@removed windowing in getdats call
@
text
@d2 1
a2 1
C++************************************************************************
d8 23
a30 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
d54 1
a54 1
C--************************************************************************
@


1.5
log
@GETDATS CALL HAD UNDEFINED NUMTH
@
text
@d74 1
a74 1
	 CALL AP_GETDATS(IMGEXP,NIMA,NSAM,NROW,NSAM,NROW,
@


1.4
log
@cosmetic & pad value
@
text
@d6 1
a6 1
C
d75 1
a75 1
     &                  NUMTH,EXPPAT,LUNIN, 1,1,
@


1.3
log
@ifdef
@
text
@d52 1
d80 2
a81 7
         IF (MIRRORNEW) THEN
C           SET PADDING VALUE  TO AV
            AVS = AV
         ELSE
C           SET PADDING VALUE  TO AV
            AVS = AV
         ENDIF
d83 1
a83 1
C        ROTATE IMAGE BY RANGNEW, MIRROR, & PAD TO 2X SIZE
d95 2
d105 3
a107 3
           YCOD =  YI * COD + ICENT
           YSID = -YI * SID + KCENT
           IGO  = (IROW - 1) * NSAM
d118 1
d123 1
a123 1
                 BUFPADI(NSAM-ISAM+1,IROW) = 
d129 1
a129 1
           BUFPADI(NSAM+1:NSAMP, IROW) = AVS
d149 8
a156 1
            CALL REDLIN(LUNIN,BUFPADR(1,IROW),NSAM,IROW)
d159 1
a159 1
            BUFPADR(NSAM+1:NSAMP, IROW) = 0.0
d185 1
a185 1
         CALL FMRS_2(BUFPADI,2*NSAM,2*NROW,INV)
d192 1
a192 1
         CALL FMRS_2(BUFPADR,2*NSAM,2*NROW,INV)
d235 2
@


1.2
log
@pad value error if img does not have fmin.. yet
@
text
@d159 1
a159 1
#ifdev DEBUG
@


1.1
log
@Initial revision
@
text
@d5 2
d60 1
a60 1
        PARAMETER (QUADPI = 3.141592653589793238462643383)
d71 3
a73 2
C        LOAD EXP. IMAGE INTO ARRAY BUFIN
	 CALL AP_GETDAT(IMGEXP,NIMA,NSAM,NROW,NSAM,NROW,
d75 1
a75 1
     &                  1,NROW,1,NSAM, BUFIN, IRTFLG)
d77 1
a77 2
         IMAMII = IMAMI
         SIGI = SIG
d80 2
a81 2
C           SET PADDING VALUE  TO ZERO
            AVS = 0.0
d83 2
a84 2
C           SET PADDING VALUE  TO BORDER
            AVS = 0.0
d145 2
a146 2
     &              CALL NORM3(LUNIN,NSAM,NROW,NSLICE,FMAX,FMIN,AV)
         SIGR   = SIG
d159 14
d174 2
a176 1
2        IF (IMAMII .NE. 1)CALL NRMS(BUFPADI,NSAMP,2*NSAM,2*NROW,1,SIGI)
d178 1
a178 1
         INV = +1
d197 8
a242 1

@
