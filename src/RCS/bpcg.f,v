head	1.70;
access;
symbols
	pre_mrcs:1.70
	healthdept_2018:1.70
	pre_getangas:1.38
	GPL2010:1.33
	pre_GPL2010:1.32
	pre_var_equation:1.32
	pre_fftwrings:1.29
	pre_opfiles:1.29
	src:1.29
	best-code:1.29
	x-named-regs:1.27
	x:1.27
	v13-00:1.27
	pre_GPL:1.25
	prec_CA:1.22
	noindx:1.19
	Bproc:1.16
	oct21:1.6
	last77:1.4;
locks; strict;
comment	@c @;


1.70
date	2018.10.03.14.33.56;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2016.01.05.18.15.35;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2013.05.01.15.35.22;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.04.15.12.00;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2012.12.28.16.53.59;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2012.07.19.15.53.49;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2012.04.18.13.35.28;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2012.04.16.14.47.25;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2012.04.11.16.32.25;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2012.04.09.16.10.20;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2012.02.28.17.36.46;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2012.01.26.15.49.52;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2012.01.11.13.11.56;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2012.01.05.16.18.22;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2012.01.04.17.17.31;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2012.01.03.13.51.53;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2011.12.22.15.07.45;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2011.12.21.17.31.19;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2011.12.20.13.49.53;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2011.12.15.18.55.19;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2011.12.14.17.11.55;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2011.12.09.14.27.13;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2011.12.09.14.05.48;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2011.12.09.13.21.11;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2011.12.08.19.14.45;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2011.12.08.17.48.14;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2011.12.08.17.31.16;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2011.11.09.17.06.00;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2011.11.08.14.56.14;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2011.10.27.16.36.11;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.16.17.56.24;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.07.13.06.31;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.12.18.25.50;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.10.14.17.33;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2011.01.07.18.27.56;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2011.01.04.16.43.22;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2011.01.04.16.32.20;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.24.13.26.45;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.24.14.02.59;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2008.11.15.15.39.55;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.21.17.24.01;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.22.17.47.10;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.22.15.49.51;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.17.19.52.49;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.17.17.50.02;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.03.18.38.24;	author cyang;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.19.22.20.18;	author cyang;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.30.16.21.18;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2003.09.16.15.31.07;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.18.16.30.30;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.19.20.51.56;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.11.14.07.39;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.14.16.59.52;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.14.18.46.31;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.24.15.05.05;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.27.15.57.01;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.25.15.39.26;	author bimal;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.24.21.24.09;	author bimal;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.18.19.51.27;	author bimal;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.18.19.42.43;	author bimal;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.12.18.35.09;	author bimal;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.06.18.57.52;	author bimal;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.06.18.35.26;	author bimal;	state Exp;
branches;
next	1.7;

1.7
date	99.11.10.23.11.18;	author yuchen;	state Exp;
branches;
next	1.6;

1.6
date	99.07.30.15.24.24;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	99.06.03.20.50.56;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	99.03.25.20.22.45;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	98.12.03.16.54.32;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	98.11.30.19.19.49;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.11.09.20.40.47;	author pawel;	state Exp;
branches;
next	;


desc
@BP CG code
@


1.70
log
@email_health_dept
@
text
@
C **********************************************************************
C                                                                      *
C  BPCG.F    CORRECTIONS APPLIED ON VOLUME SIDE  11/09/98              *
C            COMPRESSION OF ANGLES               08/14/96              *
C            USED PROJT FOR BCKPJ CALL           FEB 2000 ARDEAN LEITH *
C            OPFILEC                             FEB 2003 ARDEAN LEITH *
C            VERBOSE                             FEB 2006 ARDEAN LEITH *
C            MPI BUG FIXED                       OCT 2008 ARDEAN LEITH *
C            REFACTORED                          OCT 2008 ARDEAN LEITH *
C            REFACTORED                          DEC 2010 ARDEAN LEITH *
C            COMMON PAR REMOVED,                 DEC 2010 ARDEAN LEITH * 
C            THREE OUTPUTS                       JAN 2011 ARDEAN LEITH *
C            REPCG --> BPCG                      JAN 2011 ARDEAN LEITH *
C            MPI_RECV BUG                        APR 2011 ARDEAN LEITH *
C            FBS ADDED                           OCT 2011 G KISHCHENKO *
C            FBS2                                DEC 2011 ARDEAN LEITH *
C            RENAMED SUBROUTINES                 DEC 2011 ARDEAN LEITH *
C            FBS2 FOR ALL THREE                  JAN 2012 ARDEAN LEITH *
C            LIN RI TRAP BUG                     APR 2012 ARDEAN LEITH *
C            KLP_8                               APR 2012 ARDEAN LEITH *
C            D_KLP,D_KLS                         JAN 2013 ARDEAN LEITH *
C            gfort COMPILER BUG?                 MAY 2013 ARDEAN LEITH *                                                            *
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  BPCG()
C
C  PURPOSE:  CALCULATES 3D RECONSTRUCTION USING CONJUGATE GRADIENTS 
C            WITH REGULARIZATION.
C            RECONSTRUCTION IS CALCULATED INSIDE A SPHERE OF
C            SPECIFIED RADIUS
C            RECONSTRUCTION KEPT IN SQUARE TO INTRODUCE OTHER 
C            CONSTRAINTS. AVERAGE OUTSIDE WINDOW IS SUBTRACTED.
C            SYMMETRIES NOT IMPLEMENTED
C            CAN CALCULATE 2 SAMPLED VOLUMES ALSO
C
C  MEMORY DEMAND:  NON-MPI KEEPS 4 VOLUMES
C
C  CALLS:    BPCG  --->     PREPCUB-S
C                  --->     BPCG2      ---> ATASQ
C                  --->                -->  RPRQ
C                  --->                -->  BCKPJ_LIN or BCKPJ_FBS
C                  --->     HIANG
C                  --->     BPCG_3_LIN --> BCKPJ_LIN
C                  --->     BPCG_3_FBS --> BCKPJ_FBS
C          
C23456789012345678901234567890123456789012345678901234567890123456789012
C **********************************************************************

        SUBROUTINE BPCG

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

        REAL, POINTER         :: PANG(:,:)
        REAL, ALLOCATABLE     :: CB(:,:,:)
        REAL, ALLOCATABLE     :: ANG(:,:), DM(:,:)
        REAL, ALLOCATABLE     :: BCKN(:)

        INTEGER, ALLOCATABLE  :: ICUBE(:,:)
        INTEGER, ALLOCATABLE  :: LB(:) 

        INTEGER, ALLOCATABLE  :: ILIST(:),ILIST1(:),ILIST2(:)
 
        LOGICAL               :: WANT3,USELISTS,FBS_WANTED
        CHARACTER(LEN=MAXNAM) :: ANGDOC,FILPAT    ! MAXNAM FROM CMLIMIT
        CHARACTER(LEN=MAXNAM) :: FILVOL 
        CHARACTER(LEN=1)      :: ANSW
        CHARACTER(LEN=1)      :: NULL = CHAR(0)
        LOGICAL               :: ASKNAM = .TRUE.
        LOGICAL               :: FOUROK = .FALSE.

        !INTEGER, PARAMETER    :: ISTAR8 = selected_int_kind(16)
        !INTEGER(ISTAR8)       :: MWANT

        INTEGER, PARAMETER    :: LUNPROJ = 20 
        INTEGER, PARAMETER    :: LUNDOC  = 80 
        INTEGER, PARAMETER    :: LUNXM   = 0    ! SELFILE NOT ALLOWED
        INTEGER, PARAMETER    :: LUNANG  = 81 
        INTEGER, PARAMETER    :: LUNVOL  = 21
        INTEGER, PARAMETER    :: LUNVOL1 = 22
        INTEGER, PARAMETER    :: LUNVOL2 = 23

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID
     
C       OPEN FIRST INPUT FILE
C       RETURNS: NANG = NUMBER OF ANGLES = NUMBER OF PROJECTIONS
        NILMAX  = NIMAXPLUS      ! FROM CMLIMIT
        ALLOCATE(ILIST1(NILMAX),
     &           ILIST2(NILMAX),
     &           ILIST(NILMAX),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'BPCG; ILIST....',3*NILMAX)
           RETURN
        ENDIF 

C       OPEN FIRST OVERALL INPUT FILE
        CALL OPFILES(0,LUNPROJ,LUNDOC,LUNXM,  
     &             ASKNAM,FILPAT,NLET, 'O',
     &             IFORM ,NSAM,NROW,NSLICE,NSTACK,
     &             'TEMPLATE FOR IMAGE FILES~',
     &             FOUROK, ILIST,NILMAX, 
     &             NDUM,NANG,IMG1, IRTFLG) 
        IF (IRTFLG .NE. 0) RETURN
        
        IF (FILPAT(NLET:NLET) == '@@') THEN
           CALL ERRT(101,'OPERATION DOES NOT WORK ON WHOLE STACKS',NE)
           GOTO 9999
        ENDIF  

        MAXNUM = MAXVAL(ILIST(1:NANG))

C       NANG - TOTAL NUMBER OF IMAGES
        IF (MYPID <= 0) WRITE(NOUT,90) NANG
90      FORMAT('  NUMBER OF IMAGES:',I8)
        
        WANT3    = (FCHAR(4:7) == 'CG 3')   ! WANT THREE VOLUMES
        USELISTS = (FCHAR(4:8) == 'CG 3L')  ! WANT THREE LISTS

        !write(6,*)want3,uselists,fchar(4:8)
        IF (WANT3 .AND. USELISTS) THEN 
           CALL FILELIST(.FALSE.,LUNDOC,NULL,NLETP,
     &                   ILIST1,NILMAX,NANG1,
     &                   'IMAGES FOR FIRST SAMPLE VOLUME',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           CALL FILELIST(.FALSE.,LUNDOC,NULL,NLETP,
     &                   ILIST2,NILMAX,NANG2,
     &                   'IMAGES FOR SECOND SAMPLE VOLUME',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

        ELSEIF (WANT3) THEN
C          RANDOMLY DIVIDE ILIST INTO 2 LISTS: ILIST1,ILIST2 
           CALL MAKETWOLISTS(ILIST,NANG,ILIST1,NANG1,ILIST2,NANG2)

           WRITE(NOUT,*) ' Random lists:',NANG1, NANG2
        ENDIF

        RI = (NSAM / 2) - 2    ! DEFAULT VALUE
        CALL RDPRM1S(RI,NDUM,'RADIUS OF RECONSTRUCTED OBJECT',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        MAXXT = 4
        MAXYT = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,
     &                  LUNANG,.FALSE.,MAXXT,
     &                  MAXYT,PANG,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(101,'CAN NOT OPEN ANGLES FILE',NE)
           GOTO 9999
        ENDIF  

        CALL RDPRMC (ANSW, NLETI, .TRUE.,
     &     'LINEAR OR FBS INTERPOLATION (L,F)', NULL,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        FBS_WANTED = (ANSW(1:1) == 'F')  

        N     = NSAM   ! LINEAR DIMENSION OF PROJECTIONS & RESTORATION

C       IDUM IS A DUMMY VARIABLE, VALUE OF NN IS DETERMINED
        LDP   = N / 2 + 1
        LDPNM = LDP

        CALL PREPCUB_S(N,NN,IDUM,RI,.FALSE.,LDP)     ! RETURNS: NN

C       USE NN TO ALLOCATE: ICUBE 
C       TOTAL MEMORY IS VOLUMES: CB, BCKN, BCKE...
C       PLUS TWO 2D PROJECTIONS.
C       CB   - BACK-PROJECTED ORIGINAL PROJECTIONS, READ FROM FILE
C       BCKE - WORKING VOLUME
C       BCKN - CURRENT RECONSTRUCTION
        ALLOCATE (ICUBE(5,NN), 
     &            CB(N,N,N), 
     &            BCKN(N*N*N), 
     &            ANG(3,NANG),
     &            DM(9,NANG),
     &            LB(NANG), 
     &            STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           MWANT = 5*NN + 2*N*N*N + 12*NANG_ISTAR8 
           CALL ERRT(46,'BPCG, ICUBE...',MWANT)
           GOTO 9999
        ENDIF

C       MAKES LIST OF VOXEL LOCS ON EACH LINE VOLUME WITHIN RADIUS          *
        CALL PREPCUB_S(N,NN,ICUBE,RI,.TRUE.,LDP)   ! RETURNS: IPCUBE

C       OPEN OUTPUT VOLUME
        MAXIM = 0
        IFORM = 3
        CALL OPFILEC(0,.TRUE.,FILVOL,LUNVOL,'U',IFORM,N,N,N,
     &             MAXIM,'RECONSTRUCTED VOLUME',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (WANT3) THEN
           MAXIM = 0
           IFORM = 3
           CALL OPFILEC(0,.TRUE.,FILVOL,LUNVOL1,'U',IFORM,N,N,N,
     &             MAXIM,'FIRST SAMPLE VOLUME',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           MAXIM = 0
           CALL OPFILEC(0,.TRUE.,FILVOL,LUNVOL2,'U',IFORM,N,N,N,
     &             MAXIM,'SECOND SAMPLE VOLUME',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF

        ERRM = 0.00005
        CHIM = 0.0
        CALL RDPRM2S(ERRM,CHIM,NDUM,'ERROR LIMIT & CHI^2 LIMIT',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        MAXIT = 20
        MODE  = 1
        CALL RDPRIS(MAXIT,MODE,NOT_USED,'ITERATION LIMIT, MODE',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        ANOISE = 2000
        CALL RDPRM1S(ANOISE,NOT_USED,'LAMBDA',IRTFLG)  ! NOISE SUPRESSOR
        IF (IRTFLG .NE. 0) GOTO 9999

C       FIND NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)

        NXLD = N + 2 - MOD(N,2)

        WRITE(NOUT,92)'  CREATING VOLUME ------------------------------'
92      FORMAT(/,A)
        CALL FLUSHRESULTS()

C       BACK-PROJECTION AND BACKGROUND CORRECTION, RETURNS: CHI2
        CALL BPCG_2(N,NANG,CB,ANG,ILIST,ICUBE,NN,DM,RI,PANG,
     &               FILPAT,MAXIM,BNORM,CHI2, 
     &               LUNPROJ,LDP,LDPNM, FBS_WANTED,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       COMPRESS ANGLES, CONVERTS ANGLES TO 'DM' FORMAT
        CALL HIANG(ANG,NANG,DM,LB,LO)     ! ALTERS ANG,DM,LB,& LO !!
        NANG = LO
        IF (MYPID <= 0) WRITE(NOUT,91) NANG
91      FORMAT('  EFFECTIVE NUMBER OF ANGLES:    ',I6)

        DI      = N / 2
        IRADIUS = INT(RI)

        IF (FBS_WANTED) THEN
           IF (MYPID <= 0) WRITE(NOUT,*) ' USING FBS INTERPOLATION'

           IF (MODE == 1 .AND. (RI+1.0) > DI  .OR. 
     &         MODE == 2 .AND. (RI+2.0) > DI  .OR.
     &         MODE == 3 .AND. (RI+3.0) > DI)  THEN
              CALL ERRT(102,'RADIUS TOO LARGE',IRADIUS)
              GOTO 9999
           ENDIF   

           CALL BPCG_3_FBS(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG,RI,
     &                 NUMTH,BNORM,CHI2,
     &                 ERRM,CHIM,MAXIT,MODE,ANOISE, LDP,LDPNM,IRTLFG)

        ELSE
           IF (MYPID <= 0) WRITE(NOUT,*) ' USING LINEAR INTERPOLATION'

           IF (MODE == 1 .AND. (RI+1.0+1.0) > DI  .OR. 
     &         MODE == 2 .AND. (RI+2.0+1.0) > DI .OR.
     &         MODE == 3 .AND. (RI+3.0+1.0) > DI)  THEN
              CALL ERRT(102,'RADIUS TOO LARGE',IRADIUS)
              GOTO 9999
           ENDIF   

           CALL BPCG_3_LIN(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG,RI,
     &                 NUMTH,BNORM,CHI2,
     &                 ERRM,CHIM,MAXIT,MODE,ANOISE, LDP,LDPNM,IRTLFG)
        ENDIF
        IF (IRTFLG .NE. 0) GOTO 9999

C       SAVE OVERALL OUTPUT VOLUME
        CALL WRTVOL(LUNVOL,N,N,1,N,BCKN,IRTFLG)

        IF (WANT3) THEN

           WRITE(NOUT,*) 
     &          ' CREATING FIRST SAMPLED VOLUME ------------------'
           WRITE(NOUT,*) ' '
           !write(6,*) 'Creating  first output sampled volume -----'
           CALL FLUSHRESULTS()

C          OPEN NEXT INPUT PROJECTION
           K = 1
           CALL NEXTFILE(K,       ILIST1, 
     &                   FOUROK,  0,
     &                   NANG1,   MAXIM,   
     &                   LUNPROJ, 0, 
     &                   FILPAT,  'O',
     &                   IMGNUM,  IRTFLG)

C          BACK-PROJECTION AND BACKGROUND CORRECTION, RETURNS: CHI2
           CALL BPCG_2(N,NANG1,CB,ANG,ILIST1,ICUBE,NN,DM,RI,PANG,
     &               FILPAT,MAXIM,BNORM,CHI2, 
     &               LUNPROJ,LDP,LDPNM, FBS_WANTED,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          COMPRESS ANGLES, CONVERTS ANGLES TO 'DM' FORMAT
           CALL HIANG(ANG,NANG1,DM,LB,LO)     ! ALTERS NANG1!!
           NANG1 = LO
           IF (MYPID <= 0) WRITE(NOUT,91) NANG1

           IF (FBS_WANTED) THEN
              IF (MYPID <= 0) WRITE(NOUT,*) ' USING FBS INTERPOLATION'
              CALL BPCG_3_FBS(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG1,RI,
     &                    NUMTH,BNORM,CHI2,
     &                    ERRM,CHIM,MAXIT,MODE,ANOISE, LDP,LDPNM,IRTLFG)

           ELSE
              IF (MYPID <= 0) WRITE(NOUT,*)' USING LINEAR INTERPOLATION'
              CALL BPCG_3_LIN(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG1,RI,
     &                 NUMTH,BNORM,CHI2,
     &                 ERRM,CHIM,MAXIT,MODE,ANOISE, LDP,LDPNM,IRTLFG)
           ENDIF
           IF (IRTFLG .NE. 0) GOTO 9999

C          SAVE FIRST OUTPUT SAMPLED VOLUME
           CALL WRTVOL(LUNVOL1,N,N,1,N,BCKN,IRTFLG)



           WRITE(NOUT,*) 
     &         ' CREATING SECOND SAMPLED VOLUME ------------------'
           WRITE(NOUT,*) ' '
           !write(6,*) 'Creating second output sampled volume -----'
           CALL FLUSHRESULTS()

C          OPEN NEXT INPUT PROJECTION
           K = 1
           CALL NEXTFILE(K,       ILIST2, 
     &                   FOUROK,  0,
     &                   NANG2,   MAXIM,   
     &                   LUNPROJ, 0, 
     &                   FILPAT,  'O',
     &                   IMGNUM,  IRTFLG)

C          BACK-PROJECTION AND BACKGROUND CORRECTION. RETURNS: CHI2
           CALL BPCG_2(N,NANG2,CB,ANG,ILIST2,ICUBE,NN,DM,RI,PANG,
     &                  FILPAT,MAXIM,BNORM,CHI2, 
     &                  LUNPROJ,LDP,LDPNM, FBS_WANTED,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          COMPRESS ANGLES, CONVERTS ANGLES TO 'DM' FORMAT
           CALL HIANG(ANG,NANG2,DM,LB,LO)     
           NANG2 = LO
           IF (MYPID <= 0) WRITE(NOUT,91) NANG2 

           IF (FBS_WANTED) THEN
              IF (MYPID <= 0) WRITE(NOUT,*) ' USING FBS INTERPOLATION'
              CALL BPCG_3_FBS(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG2,RI,
     &                    NUMTH,BNORM,CHI2,
     &                    ERRM,CHIM,MAXIT,MODE,ANOISE, LDP,LDPNM,IRTLFG)

           ELSE
              IF (MYPID <= 0)WRITE(NOUT,*)' USING LINEAR INTERPOLATION'
              CALL BPCG_3_LIN(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG2,RI,
     &                 NUMTH,BNORM,CHI2,
     &                 ERRM,CHIM,MAXIT,MODE,ANOISE, LDP,LDPNM,IRTLFG)
           ENDIF
           IF (IRTFLG .NE. 0) GOTO 9999

C          SAVE SECOND OUTPUT SAMPLED VOLUME2
           CALL WRTVOL(LUNVOL2,N,N,1,N, BCKN,IRTFLG)

        ENDIF

9999    IF (ALLOCATED(BCKN))  DEALLOCATE(BCKN)
        IF (ALLOCATED(LB))    DEALLOCATE(LB)
        IF (ALLOCATED(DM))    DEALLOCATE(DM)
        IF (ALLOCATED(ANG))   DEALLOCATE(ANG)
        IF (ALLOCATED(CB))    DEALLOCATE(CB)
        IF (ALLOCATED(ICUBE)) DEALLOCATE(ICUBE)
        IF (ASSOCIATED(PANG)) DEALLOCATE(PANG)
        IF (ALLOCATED(ILIST)) DEALLOCATE(ILIST)
        IF (ALLOCATED(ILIST1))DEALLOCATE(ILIST1)
        IF (ALLOCATED(ILIST2))DEALLOCATE(ILIST2)
                
        CLOSE(LUNVOL) 
        CLOSE(LUNVOL1) 
        CLOSE(LUNVOL2) 
        CLOSE(LUNPROJ) 
  
        END


C ***************************** BPCG_2 *********************************
C
C  BPCG_2
C
C  PURPOSE:  LOADS PROJECTIONS AND ANGLES. FINDS BACKGROUND OUTSIDE
C            OF PROJECTED CIRCLE.  BACK-PROJECTS IMAGES INTO VOLUME.
C            DETERMINES AVERAGE OUTSIDE OF CIRCLE WHICH WILL LATER BE
C            SUBTRACTED FROM FINAL VOLUME.
C
C  *********************************************************************

        SUBROUTINE BPCG_2(N,NANG,CUBE,ANG,ILIST,IPCUBE,NN,DM,
     &                    RI,ANGBUF,FINPAT,MAXIM, BNORM,CHI2,
     &                    LUNPROJ,LDP,LDPNM,FBS_WANTED, IRTFLG)

        USE TYPE_KINDS
 
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        INTEGER               :: N,NANG
        REAL                  :: CUBE(N,N,N),ANG(3,NANG)
        INTEGER               :: ILIST(NANG),IPCUBE(5,NN)
        INTEGER               :: NN
        REAL                  :: DM(9,NANG)
        REAL                  :: RI
        REAL                  :: ANGBUF(4,NANG)
        CHARACTER(LEN=MAXNAM) :: FINPAT
        INTEGER               :: MAXIM
        REAL                  :: BNORM,CHI2
        INTEGER               :: LUNPROJ,LDP,LDPNM,IRTFLG
        LOGICAL               :: FBS_WANTED

        !INTEGER, PARAMETER    :: ISTAR8 = selected_int_kind(16)
        !INTEGER(ISTAR8)       :: MWANT

        REAL                  :: PROJ(N*N)
        DOUBLE PRECISION      :: D_ABA,D_SUS,D_SSQ
        CHARACTER(LEN=MAXNAM) :: FILNAM

        LOGICAL               :: FOUROK = .FALSE.
        REAL                  :: ADUM
        INTEGER(KIND=I_8)     :: KLP_8
        DOUBLE PRECISION      :: D_KLP,D_KLP_LOC, D_KLS,D_KLS_LOC

#ifdef USE_MPI

        include 'mpif.h'
        REAL,    ALLOCATABLE  :: CUBE_LOC(:,:,:)
        REAL,    ALLOCATABLE  :: PRJBUF(:,:,:),PRJLOC(:,:,:)
        REAL,    ALLOCATABLE  :: ANG_LOC(:,:)
        INTEGER, ALLOCATABLE  :: PSIZE(:)
        INTEGER, ALLOCATABLE  :: NBASE(:)
        DOUBLE PRECISION      :: D_ABA_LOC,D_SUS_LOC,D_SSQ_LOC

        INTEGER               :: MPISTAT(MPI_STATUS_SIZE)

        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID , MPIERR)
        CALL MPI_COMM_SIZE(ICOMM, NPROCS, MPIERR)

        ALLOCATE(PSIZE(NPROCS),
     &           NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,' BPCG_2; PSIZE & NBASE.',2*NPROCS)
           STOP
        ENDIF
#else
C       AUTOMATIC ARRAY
        REAL               :: PROJT(4,N*N)

        REAL, ALLOCATABLE  :: PROJPAD(:,:)  ! PADDED 2D PROJ ARRAY
        REAL, ALLOCATABLE  :: XDER   (:,:)  ! X  DERIVATIVE OF PROJ
        REAL, ALLOCATABLE  :: YDER   (:,:)  ! Y  DERIVATIVE OF PROJ
        REAL, ALLOCATABLE  :: XYDER  (:,:)  ! XY DERIVATIVE OF PROJ

        MYPID = -1
        IF (FBS_WANTED) THEN
           NXLD = N + 2 - MOD(N,2)
           ALLOCATE(PROJPAD(NXLD, N),
     &              XDER   (NXLD, N),
     &              YDER   (NXLD, N),
     &              XYDER  (NXLD, N),
     &              STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              MWANT = 4*NXLD*N
              CALL ERRT(46,'BPCG_2; PROJPAD,...',MWANT)
              GOTO 9999
           ENDIF
        ENDIF
#endif

        D_ABA  = 0.0D0
        D_SUS  = 0.0D0
        D_SSQ  = 0.0D0

        D_KLP  = 0.0D0
        D_KLS  = 0.0D0
        
c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=1,N
                 CUBE(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

#ifdef USE_MPI
C ------------------------- MPI ONLY CODE -----------------------------
        D_KLP_LOC = 0.0D0
        D_KLS_LOC = 0.0D0
        D_ABA_LOC = 0.0D0 
        D_SUS_LOC = 0.0D0
        D_SSQ_LOC = 0.0D0

        CALL SETPART(NANG, PSIZE, NBASE)
        NANGLOC = PSIZE(MYPID+1)

        ALLOCATE(PRJBUF  (N,N,PSIZE(1)),
     &           PRJLOC  (N,N,NANGLOC),
     &           ANG_LOC (3,NANGLOC),
     &           CUBE_LOC(N,N,N), 
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MWANT = N*N*PSIZE(1) + N*N*NANGLOC + 3*NANGLOC + N*N*N
           CALL ERRT(46,'BPCG_2; PRJBUF, PRJLOC..',MWANT)
           STOP
        ENDIF

C       ZERO LOCAL ARRAYS
        CUBE_LOC = 0.0
        ANG_LOC  = 0.0

        DO IPROC = 1, NPROCS
           NLOC = PSIZE(IPROC)

C          READ A SUBSET OF IMAGES (ONLY ONE PROCESSOR READS)

           DO K=1,NLOC
              KGLB = K + NBASE(IPROC)
              NLET = 0
              CALL  FILGET(FINPAT,FILNAM,NLET,ILIST(KGLB),IRTFLG)
              IF (IRTFLG .NE. 0) RETURN

              MAXIM = 0
              CALL OPFILEC(0,.FALSE.,FILNAM,LUNPROJ,'O',IFORM,
     &                     LSAM,LROW,NSL,
     &                     MAXIM,'DUMMY',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0) RETURN
C
              IF (MYPID <= 0) THEN
C                ONLY PROCESS WITH MYPID = 0 NEEDS TO READ
                 DO K2=1,N
                   CALL REDLIN1P(LUNPROJ,PRJBUF(1,K2,K),N,K2)
                 ENDDO
              ENDIF
              CLOSE(LUNPROJ)
           ENDDO

C          DISTRIBUTE IMAGES
           IF (IPROC > 1) THEN
              IF (MYPID == 0) THEN
                !write(6,*) ' send_mpi; iproc,mypid:',iproc,mypid,nloc

                 CALL SEND_MPI('BPCG_2','PRJBUF', PRJBUF, N*N*NLOC, 
     &                         'R',IPROC-1,IPROC-1, ICOMM)

              ELSE IF (MYPID == IPROC-1) THEN

                 !write(6,*) ' recv_mpi; iproc,mypid:',iproc,mypid,nloc
                 CALL RECV_MPI('BPCG_2','PRJLOC', PRJLOC, N*N*NLOC, 
     &                          'R', 0,MPI_ANY_TAG, ICOMM)              

c                call mpi_recv(prjloc,  n*n*nloc,    mpi_real,
c     &                         0,       mpi_any_tag, icomm,
c     &                         mpistat, mpierr)
                 !write(6,*) ' recv_mpi; ok:         ',iproc,mypid,nloc
              ENDIF

           ELSE IF (MYPID == 0) THEN
              CALL SCOPY(N*N*NLOC,PRJBUF,1,PRJLOC,1)
           ENDIF
        ENDDO

        DO K = 1, NANGLOC
           KGLB = K + NBASE(MYPID+1)

C          ORDER IN DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES ARE IN
C          DEGREES!
C          IN ANG ARRAY IT IS OTHER WAY AROUND

           ITMP         = ILIST(KGLB)
           ANG_LOC(3,K) = ANGBUF(2,ITMP)
           ANG_LOC(2,K) = ANGBUF(3,ITMP)
           ANG_LOC(1,K) = ANGBUF(4,ITMP)

c          write(6,91) kglb,itmp,(ang_loc(j,k),j=3,1,-1)
 91        format('  kglb:',i5,'  proj:',i6,
     &               '; psi:',f6.1,' theta:',f6.1,' phi:',f6.1)

C          ESTIMATE AVERAGE OUTSIDE THE CIRCLE?
           CALL ASTASQ(PRJLOC(1,1,K), N, RI, D_ABA_LOC, D_KLP_LOC, 
     &                 D_SUS_LOC, D_SSQ_LOC, D_KLS_LOC)
 
C          CREATE ROTATION MATRIX: DM
           CALL CANG(ANG_LOC(1,K),ANG_LOC(2,K),ANG_LOC(3,K),
     &              .FALSE.,ADUM,DM(1,KGLB))

C          BACKPROJECT: PRJLOC  INTO: CUBE_LOC
           CALL RPRQ(N,PRJLOC(1,1,K),CUBE_LOC,IPCUBE,NN,
     &               DM(1,KGLB), LDP,LDPNM,IRTFLG)
        ENDDO

        IF (ALLOCATED(PRJBUF)) DEALLOCATE(PRJBUF) 
        IF (ALLOCATED(PRJLOC)) DEALLOCATE(PRJLOC) 

C       GATHER ANG_LOC INTO ANG

        DO J = 1, NPROCS
           NBASE(J) = 3 * NBASE(J)
           PSIZE(J) = 3 * PSIZE(J)
        ENDDO
        CALL MPI_ALLGATHERV(ANG_LOC,  3*NANGLOC, MPI_REAL,
     &                      ANG,      PSIZE,     NBASE,
     &                      MPI_REAL, ICOMM,     IERR)    

        DO K = 1, NANG
           IF (VERBOSE) THEN
              IF (MYPID == 0) WRITE(NOUT,3331) K,(ANG(J,K),J=3,1,-1)
3331          FORMAT('  IMAGE #:',I7,
     &               '  PSI:', F6.1,
     &               ' THETA:',F6.1,
     &               ' PHI:',  F6.1)
           ENDIF
        ENDDO

        NNN  = N*N*N
        IERR = 0
        CALL ALLREDUCE_MPI('REPRCG','CUBE', CUBE_LOC,CUBE,
     &                         NNN, 'R','S',ICOMM)
        CALL ALLREDUCE_MPI('REPRCG','D_ABA', D_ABA_LOC,D_ABA,
     &                           1, 'D','S',ICOMM)
        CALL ALLREDUCE_MPI('REPRCG','D_KLP', D_KLP_LOC,D_KLP,
     &                           1, 'D','S',ICOMM)
        CALL ALLREDUCE_MPI('REPRCG','D_SSQ', D_SSQ_LOC,D_SSQ,
     &                           1, 'D','S',ICOMM)
        CALL ALLREDUCE_MPI('REPRCG','D_SUS', D_SUS_LOC,D_SUS,
     &                           1, 'D','S',ICOMM)
        CALL ALLREDUCE_MPI('REPRCG','D_KLS', D_KLS_LOC,D_KLS,
     &                           1, 'D','S',ICOMM)

        IF (ALLOCATED(CUBE_LOC)) DEALLOCATE(CUBE_LOC)
        IF (ALLOCATED(ANG_LOC))  DEALLOCATE(ANG_LOC)
        IF (ALLOCATED(PSIZE))    DEALLOCATE(PSIZE)
        IF (ALLOCATED(NBASE))    DEALLOCATE(NBASE)


C       --------------- END OF MPI CODE -----------------------------
#else
C       --------------- START NON-MPI CODE --------------------------

        K   = 1
        NNN = N*N*N

        DO      ! LOOP OVER ALL INPUT IMAGES

           ! LOAD NEXT IMAGE (SQUARE)
           CALL REDVOL(LUNPROJ,N,N,1,1,PROJ,IRTFLG)

C          LOAD ANGLES FOR THIS IMAGE
C          ORDER IN DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES ARE IN 
C          DEGREES! IN ANG ARRAY IT IS OTHER WAY AROUND

           ITMP     = ILIST(K)
           ICOUNT   = ANGBUF(1,ITMP)

           IF (ICOUNT <= 0) THEN
C             MISSING KEY
              CALL ERRT(102,'MISSING ANGLES FOR IMAGE',ITMP)
              IRTFLG = 1
              GOTO 9999
           ENDIF

           ANG(3,K) = ANGBUF(2,ITMP)  ! NOTE ORDER REVERSAL!
           ANG(2,K) = ANGBUF(3,ITMP)
           ANG(1,K) = ANGBUF(4,ITMP)
           IF (VERBOSE .AND. K == 1 ) THEN
              WRITE(NOUT,3331) K,(ANG(J,K),J=3,1,-1)
3331          FORMAT('  IMAGE #:',I7,
     &               '  PSI:',    F6.1,
     &               '  THETA:',  F6.1,
     &               '  PHI:',    F6.1)
           ENDIF

C          CREATE ROTATION MATRIX: DM
           CALL CANG(ANG(1,K),ANG(2,K),ANG(3,K),.FALSE.,ADUM,DM(1,K))

C          ESTIMATE AVERAGE OUTSIDE THE CIRCLE?
           CALL ASTASQ(PROJ,N,RI,D_ABA,D_KLP,D_SUS,D_SSQ,D_KLS)

           IF (FBS_WANTED) THEN

C             PAD PROJECTION TO: PROJPAD
c$omp         parallel do private(iy,iloc,ix)
              DO IY = 1,N
                 ILOC = (IY-1)*N + 1 
                 DO IX = 1,N 
                    PROJPAD(IX,IY) = PROJ(ILOC)
                    ILOC           = ILOC + 1
                 ENDDO
              ENDDO

C             CALCULATE PROJECTION DERIVATIVES USING FFT
C             IN FBS2_PREP PROJPAD DOES NOT RETURN USEFULL VALUE!
              CALL FBS2_PREP(PROJPAD, XDER,YDER,XYDER, 
     &                       NXLD,N,N, IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
   
C             BACKPROJECT FROM PLANE: PROJ TO VOLUME: CUBE
              CALL BCKPJ_FBS(CUBE,NNN,DM(1,K),
     &                  PROJ, XDER,YDER,XYDER,
     &                  NXLD,N,IPCUBE,NN, LDP,LDPNM)
 
           ELSE
C             COMPUTE IMAGE DIFFERENCES FOR INTERP. PIXELS
c$omp         parallel do private(i,pt)
              DO I = 1,N*N - N - 1
                 PT         = PROJ(I)
                 PROJT(1,I) = PT
                 PROJT(2,I) = PROJ(I+N)   - PT
                 PROJT(3,I) = PROJ(I+1)   - PT
 
C                may 2013 unfathom-able gfort bug requires -fwrapv
                 PROJT(4,I) = PROJ(I+N+1) - PROJ(I+1) - PROJT(2,I)
 
              ENDDO

C             BACKPROJECTION FROM PROJT INTO: CUBE
              CALL BCKPJ_LIN(CUBE,NNN,DM(1,K),
     &                     PROJT,N,IPCUBE,NN,LDP,LDPNM)
           ENDIF
  
C          OPEN NEXT INPUT PROJECTION
           CALL NEXTFILE(K,       ILIST, 
     &                   FOUROK,  0,
     &                   NANG,    MAXIM,   
     &                   LUNPROJ, 0, 
     &                   FINPAT,  'O',
     &                   IMGNUM,  IRTFLG) 
           IF (IRTFLG ==  -1) EXIT      !  END OF INPUT STACK
           IF (IRTFLG .NE. 0) RETURN
 
        ENDDO
        IRTFLG = 0

9999    IF (ALLOCATED(PROJPAD)) DEALLOCATE (PROJPAD)
        IF (ALLOCATED(XDER))    DEALLOCATE (XDER)
        IF (ALLOCATED(YDER))    DEALLOCATE (YDER)
        IF (ALLOCATED(XYDER))   DEALLOCATE (XYDER)


C       --------------- END OF NON-MPI CODE -------------------------
#endif


C       BACKGROUND AVERAGE CORRECTION FOR VOLUME
        D_ABA = D_ABA / D_KLP
        BNORM = 0.0
        QT    = D_ABA * NANG

c$omp   parallel do private(kn,j,k,i),reduction(+:bnorm)
        DO KN=1,NN
           J = IPCUBE(4,KN)
           K = IPCUBE(5,KN)
           DO I=IPCUBE(3,KN), IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
              CUBE(I,J,K) = CUBE(I,J,K) - QT
              BNORM     = BNORM + CUBE(I,J,K) * CUBE(I,J,K)
           ENDDO
        ENDDO

C       CALCULATE SUM OF SQUARES OF PROJECTIONS WITHIN CIRCLES AFTER
C       SUBTRACTION OF THE AVERAGE
        D_SSQ = D_SSQ - D_ABA * (2 * D_SUS - D_ABA * D_KLS)
        CHI2  = D_SSQ

C       PRINT STATISTICS

        KLP_8 = D_KLP

        IF (MYPID <= 0) THEN
           WRITE(NOUT,2044) KLP_8,D_ABA,BNORM,CHI2
2044       FORMAT(/,'  TOTAL POINTS IN PROJECTIONS:',I10,/,
     &              '  AVERAGE OUTSIDE THE WINDOW: ',1PE10.3,/,
     &              '  SQUARED BP:                 ',1PE10.3,/,
     &              '  CHI2:                       ',1PE10.3)
        ENDIF

        !write(6,*) ' k,sum-cube:',k,sum(cube)

        END

C**************************** BPCG_3_LIN ******************************

        SUBROUTINE BPCG_3_LIN(CB,BCKN,NXLD,N,IPCUBE,NN,DM,LB,NANG,RI,
     &                      NUMTH,BNORM,CHI2,
     &                      ERRM,CHIM,MAXIT,MODE,ANOISE, 
     &                      LDP,LDPNM,IRTFLG)

C       NUMTH = NUMTHREADS() FOR MP, OTHERWISE=1.

        INCLUDE 'CMBLOCK.INC'

        REAL                :: CB(N,N,N),BCKN(N,N,N)
        INTEGER             :: NXLD,N,NN
        INTEGER             :: IPCUBE(5,NN),LB(NANG)
        INTEGER             :: NANG
        REAL                :: RI
        INTEGER             :: NUMTH
        REAL                :: CHI2,ERRM,CHIM
        INTEGER             :: MAXIT,MODE
        REAL                :: ANOISE, DELSQ
        INTEGER             :: LDP,LDPNM,IRTFLG

        REAL                :: DM(9,NANG),PROJ(N*N,NUMTH)
        REAL                :: PROJT(4,N*N)
        REAL,ALLOCATABLE    :: BCKE(:,:,:), BCKP(:,:,:)

#ifdef USE_MPI
        include 'mpif.h'
        INTEGER             :: MPISTAT(MPI_STATUS_SIZE)
        INTEGER,ALLOCATABLE :: PSIZE(:), NBASE(:)
        INTEGER,ALLOCATABLE :: LBLOC(:)
        REAL,   ALLOCATABLE :: DMLOC(:,:)
        REAL,   ALLOCATABLE :: BCKE_SUM(:,:,:)
        REAL,   ALLOCATABLE :: RESID(:,:,:)

        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID , MPIERR)
        CALL MPI_COMM_SIZE(ICOMM, NPROCS, MPIERR)

        ALLOCATE(PSIZE(NPROCS), 
     &           BCKE_SUM(N,N,N), 
     &           NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MWANT = 2 * NPROCS + N*N*N
           CALL ERRT(46,'BPCG_3_LIN; NBASE,...',MWANT)
           RETURN
        ENDIF
        CALL SETPART(NANG, PSIZE, NBASE)
        NANGLOC = PSIZE(MYPID+1)

#else
        MYPID = -1
#endif
        
        NNN = N*N*N
        ALLOCATE (BCKE(N,N,N), 
     &            BCKP(N,N,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           MWANT = 2 * NNN
           CALL ERRT(46,'BPCG_3_LIN; BCKE,BCKP',MWANT)
           GOTO 9999
        ENDIF

c$omp   parallel do private(k,j,i)
        DO K=1,N
           DO J=1,N
              DO I=1,N
                 BCKN(I,J,K)     = 0.0
                 BCKP(I,J,K)     = 0.0
#ifdef USE_MPI
                 BCKE_SUM(I,J,K) = 0.0
#endif
              ENDDO
           ENDDO
        ENDDO

        ERR  = 1.0
        ITER = 0
        Q    = 0.0

C       ------------------ START OF:  MPI CODE ------------------------
#ifdef USE_MPI

C       DISTRIBUTE LB AND DM

        ALLOCATE(LBLOC(NANGLOC),
     &           DMLOC(9, NANGLOC), 
     &           STAT = IRTFLAG)
        IF (IRTFLG .NE. 0) THEN
           MWANT = 10 * NANGLOC
           CALL ERRT(46,'BPCG_3_LIN; DMLOC',MWANT)
           STOP
        ENDIF

        IDMTAG  = 1
        LBTAG   = 2
        MASTER  = 0

        IF (MYPID == 0) THEN
C          PROCESS 0 DISTRIBUTES DM() AND LB() TO OTHER PROCESSORS

           DO IP = 2, NPROCS
              IBEGIN = NBASE(IP) + 1
              NLOC   = PSIZE(IP) 

              CALL SEND_MPI('BPCG_3_LIN','DM', DM(1,IBEGIN), 9*NLOC, 
     &                      'R',IP-1,IDMTAG,ICOMM)

              CALL SEND_MPI('BPCG_3_LIN','LB', LB(IBEGIN), NLOC, 
     &                      'I',IP-1,LBTAG,ICOMM)

           ENDDO

C          COPY DATA INTO LOCAL ARRAYS: DMLOC & LBLOC
           CALL SCOPY(9*NANGLOC, DM, 1, DMLOC, 1)
           CALL SCOPY(NANGLOC  , LB, 1, LBLOC, 1)
        ELSE

C          === SLAVES RECEIVE DATA FROM THE MASTER ===

 
           CALL RECV_MPI('BPCG_3_LIN','DMLOC', DMLOC, 9*NANGLOC, 'R',
     &                   MASTER,IDMTAG, ICOMM)
 
           CALL RECV_MPI('BPCG_3_LIN','LBLOC', LBLOC, NANGLOC, 'I',
     &                   MASTER,LBTAG, ICOMM)


        ENDIF

#ifdef MPI_DEBUG
        write(6,*)' BPCG_3_LIN: data distributed, mypid:',mypid
#endif

        DO ITER=1,MAXIT

           DELSQ = 0.0
c$omp      parallel do private(kn,j,k,i),reduction(+:delsq)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 DELSQ = DELSQ + CB(I,J,K) * CB(I,J,K)
              ENDDO
           ENDDO
           Q = Q * DELSQ

c$omp      parallel do private(kn,j,k,i)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 BCKP(I,J,K) = CB(I,J,K) - Q * BCKP(I,J,K)
              ENDDO
           ENDDO
           Q = -1.0 / DELSQ

c$omp      parallel do private(k,j,i)
           DO K=1,N
              DO J=1,N
                 DO I=1,N
                    BCKE(I,J,K)     = 0.0
                    BCKE_SUM(I,J,K) = 0.0
                 ENDDO
              ENDDO
           ENDDO

C          BCKP -> PROJ -> BCKE

C          LOOP OVER PROJECTIONS

           DO K=1,NANGLOC
              L_EN  = MIN(NANGLOC,K+NUMTH-1)
              L_NUM = MIN(NUMTH,NANGLOC-K+1)

c$omp         parallel do private(i,j)
              DO J=1,L_NUM
                 DO I=1,N*N
                    PROJ(I,J) = 0.0
                 ENDDO
              ENDDO

C             PROJECT
              CALL PRJCQ_N(BCKP,NNN,DMLOC(1,K),
     &                     PROJ,N,IPCUBE,NN, LDP,LDPNM)

C             HERE BCKPJ ITSELF IS MP  
              DO  L_TH=1,L_NUM
C                MULTIPLY PROJECTIONS BY THEIR WEIGHTS
                 IF (LBLOC(K+L_TH-1) > 1)  THEN
c$omp               parallel do private(i)
                    DO  I=1,N*N
                       PROJ(I,L_TH) = PROJ(I,L_TH) * LBLOC(K+L_TH-1)
                    ENDDO
                 ENDIF

c$omp            parallel do private(i,pt)
                 DO I = 1,N*N - N - 1
                    PT         = PROJ(I, L_TH)
                    PROJT(1,I) = PT
                    PROJT(2,I) = PROJ(I+N,  L_TH) - PT
                    PROJT(3,I) = PROJ(I+1,  L_TH) - PT 

C                   may 2013 unfathom-able gfort bug requires -fwrapv
                    PROJT(4,I) = PROJ(I+N+1,L_TH) - PROJ(I+1,L_TH) - 
     &                           PROJT(2,I)

                 ENDDO

C                BACKPROJECT
                 CALL BCKPJ_LIN(BCKE,NNN,DMLOC(1,K+L_TH-1),
     &                        PROJT,N,IPCUBE,NN, LDP,LDPNM)
              ENDDO
           ENDDO
C
           CALL ALLREDUCE_MPI('BPCG_3_LIN','BCKE_SUM',BCKE,BCKE_SUM,
     &                           NNN, 'R','S',ICOMM)


C          === IGNORE MODE > 0 FOR THE TIME BEING ===

           IF (MODE == 1)  THEN
              CALL FIXEDGE1(BCKP,NNN,BCKP,N,IPCUBE,NN)      
c             CALL BFIRSTS(BCKE,BCKP,N,ANOISE,IPCUBE,NN,RI) sep 01 al
              CALL BFIRSTS(BCKE_SUM,BCKP,N,ANOISE,IPCUBE,NN)

           ELSEIF(MODE==2)  THEN
              CALL FIXEDGE2(BCKP,NNN,BCKP,N,IPCUBE,NN)      
              CALL BSECOND(BCKE_SUM,BCKP,N,ANOISE,IPCUBE,NN)

           ELSEIF(MODE==3)  THEN
              CALL FIXEDGE3(BCKP,NNN,BCKP,N,IPCUBE,NN)      
              CALL BTHIRD(BCKE_SUM,BCKP,N,ANOISE,IPCUBE,NN)
           ENDIF

           AKDEN = 0.0

c$omp      parallel do private(kn,j,k,i),reduction(+:akden)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),
     &             IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 AKDEN = AKDEN+BCKP(I,J,K) * BCKE_SUM(I,J,K)
              ENDDO
           ENDDO

           P=DELSQ / AKDEN

c$omp      parallel do private(kn,j,k,i)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),
     &           IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 BCKN(I,J,K) = BCKN(I,J,K)+P*BCKP(I,J,K)
                 CB(I,J,K)   = CB(I,J,K)-P*BCKE_sum(I,J,K)
              ENDDO
           ENDDO
 
           ERR  = DELSQ / BNORM
           CHI2 = CHI2 - P * DELSQ
           IF (MYPID == 0) WRITE(NOUT,2041) ITER,ERR,CHI2
2041       FORMAT('  ITERATION:', I3,
     &            '  DIFFERENCE:',1PE12.4,
     &            '  CHISQ:',1PE12.4)
              CALL FLUSHRESULTS()

C          CHECK STOPPING CRITERIA
           IF (ABS(ERR) <= ERRM .OR. ABS(CHI2) <= CHIM) GOTO 9999            
        ENDDO


C       END OF: -------------- USE_MPI ------------------------------

#else

        DO  ITER=1,MAXIT

           DELSQ = 0.0
c$omp      parallel do private(kn,j,k,i),reduction(+:delsq)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 DELSQ = DELSQ+CB(I,J,K)*CB(I,J,K)
              ENDDO
           ENDDO
           Q = Q * DELSQ

c$omp      parallel do private(kn,j,k,i)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 BCKP(I,J,K) = CB(I,J,K) - Q * BCKP(I,J,K)
              ENDDO
           ENDDO
           Q = -1.0 / DELSQ

c$omp      parallel do private(k,j,i)
           DO K=1,N
              DO J=1,N
                 DO I=1,N
                    BCKE(I,J,K) = 0.0
                 ENDDO
              ENDDO
           ENDDO

C          BCKP -> PROJ -> BCKE
C          LOOP OVER PROJECTIONS
           DO K=1,NANG,NUMTH
              L_EN  = MIN(NANG,K+NUMTH-1)
              L_NUM = MIN(NUMTH,NANG-K+1)

c$omp         parallel do private(i,j)
              DO J=1,L_NUM
                 DO I=1,N*N
                    PROJ(I,J) = 0.0
                 ENDDO
              ENDDO

c$omp      parallel do private(l_th),shared(nnn,n,nn),schedule(static)
              DO  L_TH=1,L_NUM
C                PROJECTS BCKP INTO PROJ  
                 CALL PRJCQ_N(BCKP,NNN,DM(1,K+L_TH-1),
     &                       PROJ(1,L_TH),N,IPCUBE,NN, LDP,LDPNM)
              ENDDO

C             HERE BCKPJ ITSELF IS MP  
              DO  L_TH=1,L_NUM
C                MULTIPLY PROJECTIONS BY THEIR WEIGHTS
                 IF (LB(K+L_TH-1) > 1)  THEN
c$omp               parallel do private(i)
                    DO  I=1,N*N
                       PROJ(I,L_TH) = PROJ(I,L_TH)*LB(K+L_TH-1)
                    ENDDO
                 ENDIF

c$omp            parallel do private(i,pt)
                 DO I = 1,N*N - N - 1
                    PT         = PROJ(I, L_TH)
                    PROJT(1,I) = PT
                    PROJT(2,I) = PROJ(I+N,  L_TH) - PT
                    PROJT(3,I) = PROJ(I+1,  L_TH) - PT 

C                   may 2013 unfathom-able gfort bug requires -fwrapv
                    PROJT(4,I) = PROJ(I+N+1,L_TH) - PROJ(I+1,L_TH) - 
     &                           PROJT(2,I)
                 ENDDO

C                BACKPROJECT FROM PLANE: PROJT TO VOLUME: BCKE
                 CALL BCKPJ_LIN(BCKE,NNN,DM(1,K+L_TH-1),PROJT,N,
     &                          IPCUBE,NN, LDP,LDPNM)
              ENDDO
           ENDDO

           IF (MODE == 1) THEN
              CALL FIXEDGE1(BCKP,NNN,BCKP,N,IPCUBE,NN)      
              CALL BFIRSTS(BCKE,BCKP,N,ANOISE,IPCUBE,NN)

           ELSEIF(MODE == 2) THEN
              CALL FIXEDGE2(BCKP,NNN,BCKP,N,IPCUBE,NN)      
              CALL BSECOND(BCKE,BCKP,N,ANOISE,IPCUBE,NN)

           ELSEIF (MODE == 3) THEN
              CALL FIXEDGE3(BCKP,NNN,BCKP,N,IPCUBE,NN)      
              CALL BTHIRD(BCKE,BCKP,N,ANOISE,IPCUBE,NN)
           ENDIF

           AKDEN = 0.0

c$omp      parallel do private(kn,j,k,i),reduction(+:akden)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),
     &             IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 AKDEN = AKDEN + BCKP(I,J,K) * BCKE(I,J,K)
              ENDDO
           ENDDO
           P = DELSQ / AKDEN

c$omp      parallel do private(kn,j,k,i)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),
     &           IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 BCKN(I,J,K) = BCKN(I,J,K)+P*BCKP(I,J,K)
                 CB(I,J,K)   = CB(I,J,K)-P*BCKE(I,J,K)
              ENDDO
           ENDDO

           ERR  = DELSQ / BNORM
           CHI2 = CHI2 - P * DELSQ

           WRITE(NOUT,2041) ITER,ERR,CHI2
2041       FORMAT('  ITERATION: 'I3,
     &            '  DIFFERENCE:',1PE12.4,
     &            '  CHISQ:',1PE12.4)
           CALL FLUSHRESULTS()

C          CHECK STOPPING CRITERIA
           IF (ABS(ERR) <= ERRM .OR. ABS(CHI2) <= CHIM) THEN  
              WRITE(NOUT,*) '  '  
              GOTO 9999            
           ENDIF
       ENDDO


C      END OF: -------------- NON-MPI ----------------------------
#endif

C      NUMBER OF ITERATIONS EXCEEDED
 
9999   IF (ALLOCATED(BCKE))     DEALLOCATE (BCKE)
       IF (ALLOCATED(BCKP))     DEALLOCATE (BCKP)
#ifdef USE_MPI
       IF (ALLOCATED(BCKE_SUM)) DEALLOCATE(BCKE_SUM)
#endif

       END



C*************************  ASTASQ  ********************************

        SUBROUTINE  ASTASQ(X,N,RI,D_ABA,D_KLP,D_SUS,D_SSQ,D_KLS)

        REAL              :: X(N,N)
        DOUBLE PRECISION  :: D_ABA,D_SUS,D_SSQ
        DOUBLE PRECISION  :: D_KLP,D_KLS

C       ESTIMATE AVERAGE OUTSIDE THE CIRCLE. 
C       RETURNS: D_ABA, D_KLP, D_SUS, D_SSQ, D_KLS

        R  = RI * RI
        NC = N / 2+1

        DO J=1,N
           T  = J - NC
           XX = T*T

           DO I=1,N
              T=I - NC
              IF ( (XX + T*T) > R)    THEN
C                OUTSIDE THE CIRCLE MASK. 
                 D_ABA  = D_ABA  + DBLE(X(I,J))
                 D_KLP = D_KLP + 1
              ELSE
C                INSIDE THE CIRCLE MASK. 
                 D_SSQ  = D_SSQ + X(I,J) * DBLE(X(I,J))
                 D_SUS  = D_SUS + X(I,J)
                 D_KLS = D_KLS + 1
              ENDIF
           ENDDO
        ENDDO
        END

C*************************  FIXEDGE1  ********************************

        SUBROUTINE  FIXEDGE1(BCKP,NNN,BCK3,N,IPCUBE,NN)

        REAL    :: BCKP(NNN),BCK3(N,N,N) 
        INTEGER :: IPCUBE(5,NN)

C       PUT ZEROS OUTSIDE
        NT = 1
        DO I=1,NNN
           IF (NT > NN)  THEN
              BCKP(I) = 0.0
           ELSEIF (I < IPCUBE(1,NT))  THEN
              BCKP(I)= 0.0
           ELSEIF(I == IPCUBE(2,NT))  THEN
              NT = NT+1
           ENDIF
        ENDDO

C       ADD PIXELS ON THE EDGE
C       FIX THE EDGES IN BCKP
        DO  K=1,N
           DO J=1,N
              DO  I=1,N-1
                 IF (BCK3(I+1,J,K) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I+1,J,K)
                    EXIT
                 ENDIF
              ENDDO

              DO  I=N,2,-1
                 IF (BCK3(I-1,J,K) .NE. 0.0) THEN
                    BCK3(I,J,K) =BCK3(I-1,J,K)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        DO  K=1,N
           DO I=1,N
              DO  J=1,N-1
                 IF (BCK3(I,J+1,K) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I,J+1,K)
                    EXIT
                 ENDIF
              ENDDO

              DO  J=N,2,-1
                 IF (BCK3(I,J-1,K) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I,J-1,K)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        DO  J=1,N
           DO I=1,N
              DO  K=1,N-1
                 IF (BCK3(I,J,K+1) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I,J,K+1)
                    EXIT
                 ENDIF
              ENDDO

              DO  K=N,2,-1
                 IF (BCK3(I,J,K-1) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I,J,K-1)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        END

C************************  FIXEDGE2 *********************************

        SUBROUTINE  FIXEDGE2(BCKP,NNN,BCK3,N,IPCUBE,NN)

        REAL    :: BCKP(NNN),BCK3(N,N,N)
        INTEGER :: IPCUBE(5,NN)

C       PUT ZEROS OUTSIDE

        NT = 1
        DO    I=1,NNN
           IF (NT > NN)  THEN
              BCKP(I) = 0.0
           ELSEIF (I < IPCUBE(1,NT))  THEN
              BCKP(I) = 0.0
           ELSEIF (I == IPCUBE(2,NT))  THEN
              NT = NT+1
           ENDIF
        ENDDO

C       ADD PIXELS ON THE EDGE
C       FIX THE EDGES IN BCKP
        DO  K=1,N
           DO J=1,N
              DO  I=2,N-1
                 IF (BCK3(I+1,J,K) .NE. 0.0) THEN
                     BCK3(I,J,K)   = BCK3(I+1,J,K)
                     BCK3(I-1,J,K) = BCK3(I+1,J,K)
                     EXIT
                 ENDIF
              ENDDO

              DO  I=N-1,2,-1
                 IF (BCK3(I-1,J,K) .NE. 0.0) THEN
                     BCK3(I,J,K)   = BCK3(I-1,J,K)
                     BCK3(I+1,J,K) = BCK3(I-1,J,K)
                     EXIT
                 ENDIF
             ENDDO
           ENDDO
        ENDDO
        DO  K=1,N
           DO I=1,N
              DO  J=2,N-1
                 IF(BCK3(I,J+1,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J+1,K)
                    BCK3(I,J-1,K)=BCK3(I,J+1,K)
                    EXIT
                 ENDIF
              ENDDO

              DO  J=N-1,2,-1
                 IF(BCK3(I,J-1,K).NE.0.0) THEN
                    BCK3(I,J,K)   = BCK3(I,J-1,K)
                    BCK3(I,J+1,K) = BCK3(I,J-1,K)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        DO  J=1,N
           DO I=1,N
              DO  K=2,N-1
                 IF(BCK3(I,J,K+1).NE.0.0) THEN
                    BCK3(I,J,K)   = BCK3(I,J,K+1)
                    BCK3(I,J,K-1) = BCK3(I,J,K+1)
                    EXIT
                 ENDIF
              ENDDO

              DO  K=N-1,2,-1
                 IF(BCK3(I,J,K-1).NE.0.0) THEN
                    BCK3(I,J,K)   = BCK3(I,J,K-1)
                    BCK3(I,J,K+1) = BCK3(I,J,K-1)
                   EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        END

C************************  FIXEDGE3 ********************************

        SUBROUTINE  FIXEDGE3(BCKP,NNN,BCK3,N,IPCUBE,NN)

        REAL    :: BCKP(NNN),BCK3(N,N,N)
        INTEGER :: IPCUBE(5,NN)

C       PUT ZEROS OUTSIDE

        NT = 1
        DO I=1,NNN
           IF (NT>NN)  THEN
              BCKP(I) = 0.0
           ELSEIF (I < IPCUBE(1,NT))  THEN
              BCKP(I) = 0.0
           ELSEIF (I == IPCUBE(2,NT))  THEN
              N T= NT+1
           ENDIF
        ENDDO

C       ADD PIXELS ON THE EDGE
C       FIX THE EDGES IN BCKP
        DO  K=1,N
           DO J=1,N
              DO  I=3,N-1
                 IF(BCK3(I+1,J,K) .NE. 0.0) THEN
                    BCK3(I,J,K)   = BCK3(I+1,J,K)
                    BCK3(I-1,J,K) = BCK3(I+1,J,K)
                    BCK3(I-2,J,K) = BCK3(I+1,J,K)
                    EXIT
                 ENDIF
              ENDDO

              DO  I=N-2,2,-1
                 IF(BCK3(I-1,J,K) .NE. 0.0) THEN
                    BCK3(I,J,K)   = BCK3(I-1,J,K)
                    BCK3(I+1,J,K) = BCK3(I-1,J,K)
                    BCK3(I+2,J,K) = BCK3(I-1,J,K)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        DO  K=1,N
           DO I=1,N
              DO  J=3,N-1
                 IF(BCK3(I,J+1,K) .NE. 0.0) THEN
                    BCK3(I,J,K)   = BCK3(I,J+1,K)
                    BCK3(I,J-1,K) = BCK3(I,J+1,K)
                    BCK3(I,J-2,K) = BCK3(I,J+1,K)
                    EXIT
                 ENDIF
              ENDDO

              DO  J=N-2,2,-1
                 IF(BCK3(I,J-1,K) .NE. 0.0) THEN
                    BCK3(I,J,K)   = BCK3(I,J-1,K)
                    BCK3(I,J+1,K) = BCK3(I,J-1,K)
                    BCK3(I,J+2,K) = BCK3(I,J-1,K)
                   EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        DO  J=1,N
           DO I=1,N
              DO  K=3,N-1
                 IF(BCK3(I,J,K+1) .NE. 0.0) THEN
                    BCK3(I,J,K)   = BCK3(I,J,K+1)
                    BCK3(I,J,K-1) = BCK3(I,J,K+1)
                    BCK3(I,J,K-2) = BCK3(I,J,K+1)
                    EXIT
                 ENDIF
              ENDDO

              DO  K=N-2,2,-1
                 IF(BCK3(I,J,K-1) .NE. 0.0) THEN
                    BCK3(I,J,K)   = BCK3(I,J,K-1)
                    BCK3(I,J,K+1) = BCK3(I,J,K-1)
                    BCK3(I,J,K+2) = BCK3(I,J,K-1)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        END

C       ********************  BFIRSTS   ******************************

        SUBROUTINE  BFIRSTS(BCKE,BCKP,N,ANOISE,IPCUBE,NN)

        REAL      ::  BCKE(N,N,N),BCKP(N,N,N)
        INTEGER   ::  IPCUBE(5,NN)

c$omp   parallel do private(kn,j,k,i)
        DO KN=1,NN
           J = IPCUBE(4,KN)
           K = IPCUBE(5,KN)

           DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)

              BCKE(I,J,K) = BCKE(I,J,K) + ANOISE*(6*BCKP(I,J,K)-(
     &           + BCKP(I+1,J,K) + BCKP(I,J+1,K) + BCKP(I,J,K+1)
     &           + BCKP(I-1,J,K) + BCKP(I,J-1,K) + BCKP(I,J,K-1)))
           ENDDO
        ENDDO
        END

C****************************  BSECOND ******************************

        SUBROUTINE  BSECOND(BCKE,BCKP,N,ANOISE,IPCUBE,NN)

        REAL      ::  BCKE(N,N,N),BCKP(N,N,N)
        INTEGER   ::  IPCUBE(5,NN)

c$omp   parallel do private(kn,j,k,i)
        DO KN=1,NN
           J = IPCUBE(4,KN)
           K = IPCUBE(5,KN)
           DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)

               BCKE(I,J,K) = BCKE(I,J,K) + ANOISE*(18*BCKP(I,J,K)
     &          - 4.0*BCKP(I+1,J,K)+BCKP(I+2,J,K)
     &          - 4.0*BCKP(I-1,J,K)+BCKP(I-2,J,K)
     &          - 4.0*BCKP(I,J+1,K)+BCKP(I,J+2,K)
     &          - 4.0*BCKP(I,J-1,K)+BCKP(I,J-2,K)
     &          - 4.0*BCKP(I,J,K+1)+BCKP(I,J,K+2)
     &          - 4.0*BCKP(I,J,K-1)+BCKP(I,J,K-2)
     &          )
           ENDDO
        ENDDO
        END

C       ********************** BTHIRD *******************************

        SUBROUTINE  BTHIRD(BCKE,BCKP,N,ANOISE,IPCUBE,NN)

        REAL      :: BCKE(N,N,N),BCKP(N,N,N)
        INTEGER   :: IPCUBE(5,NN)

c$omp   parallel do private(kn,j,k,i)
        DO KN=1,NN
           J = IPCUBE(4,KN)
           K = IPCUBE(5,KN)
           DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)

                 BCKE(I,J,K) = BCKE(I,J,K) + ANOISE*(60*BCKP(I,J,K)
     &          - 15.0*BCKP(I+1,J,K)+6.0*BCKP(I+2,J,K)-BCKP(I+3,J,K)
     &          - 15.0*BCKP(I-1,J,K)+6.0*BCKP(I-2,J,K)-BCKP(I-3,J,K)
     &          - 15.0*BCKP(I,J+1,K)+6.0*BCKP(I,J+2,K)-BCKP(I,J+3,K)
     &          - 15.0*BCKP(I,J-1,K)+6.0*BCKP(I,J-2,K)-BCKP(I,J-3,K)
     &          - 15.0*BCKP(I,J,K+1)+6.0*BCKP(I,J,K+2)-BCKP(I,J,K+3)
     &          - 15.0*BCKP(I,J,K-1)+6.0*BCKP(I,J,K-2)-BCKP(I,J,K-3)
     &          )
           ENDDO
        ENDDO
        END


C       *************************** MAKETWOLISTS xxxxxxxxxxxxxxxxxxxxx

        SUBROUTINE MAKETWOLISTS(ILIST,N,ILIST1,N1,ILIST2,N2)

        IMPLICIT NONE

        INTEGER :: N,N1,N2
        INTEGER :: ILIST(N),ILIST1(N),ILIST2(N)

        LOGICAL :: RANDLIST(N)
        INTEGER :: IORD,K
        LOGICAL :: LTMP
        REAL    :: X

C       PURPOSE: CREATE 2 LIST OF IMAGES FOR EACH RECONSTRUCTION
C                FROM ONE LIST BY RANDOM SELECTION OF HALF OF THE
C                NUMBERS IN THE ORIGINAL LIST

	RANDLIST(1:N/2)   = .TRUE.
	RANDLIST(N/2+1:N) = .FALSE.

	DO  K=1,N
           CALL RANDOM_NUMBER(HARVEST=X)
           IORD           = MIN(N,MAX(1,INT(X*N+0.5)))
	   LTMP           = RANDLIST(IORD)
	   RANDLIST(IORD) = RANDLIST(K)
	   RANDLIST(K)    = LTMP
	ENDDO

        N1 = 0
        N2 = 0

        DO K=1,N
           IF (RANDLIST(K)) THEN
              N1         = N1 + 1
              ILIST1(N1) = ILIST(K)
           ELSE
              N2         = N2 + 1
              ILIST2(N2) = ILIST(K)
           ENDIF
        ENDDO

        END

C       *********************** BPCG_3_FBS ***************************

        SUBROUTINE BPCG_3_FBS(CB,BCKN,NXLD,N,IPCUBE,NN,DM,LB,NANG,RI,
     &                        NUMTH,BNORM,CHI2,
     &                        ERRM,CHIM,MAXIT,MODE,ANOISE, 
     &                        LDP,LDPNM,IRTFLG)

C       NUMTH = NUMTHREADS() FOR MP, OTHERWISE=1.
C          ( MP - MULTIPLE PROCESSING )

        IMPLICIT NONE
        INCLUDE 'CMBLOCK.INC'

        REAL               :: CB(N,N,N),BCKN(N,N,N)
        INTEGER            :: NXLD,N,NN
        INTEGER            :: IPCUBE(5,NN)
        REAL               :: DM(9,NANG)           
        INTEGER            :: LB(NANG)
        INTEGER            :: NANG
        REAL               :: RI
        INTEGER            :: NUMTH
        REAL               :: BNORM,CHI2,ERRM,CHIM
        INTEGER            :: MAXIT,MODE
        REAL               :: ANOISE
        INTEGER            :: LDP,LDPNM,IRTFLG

        INTEGER, PARAMETER :: ISTAR8 = selected_int_kind(16)
        INTEGER(ISTAR8)    :: MWANT

        INTEGER            :: KN, ICYCLE
        REAL               :: DELSQ
        REAL               :: PROJ(N*N,NUMTH)
        INTEGER            :: K,J,I,L_TH,IY,ILOC,IX,MYPID,NE
        REAL               :: AKDEN,ERR,Q,P
        INTEGER            :: NNN,ITER,L_EN,L_NUM

        REAL, ALLOCATABLE  :: BCKE (:,:,:)
        REAL, ALLOCATABLE  :: BCKP (:,:,:)

        REAL, ALLOCATABLE  :: XYZ  (:,:,:)
        REAL, ALLOCATABLE  :: X1   (:,:,:)
        REAL, ALLOCATABLE  :: Y1   (:,:,:)
        REAL, ALLOCATABLE  :: Z1   (:,:,:)
        REAL, ALLOCATABLE  :: XY2  (:,:,:)
        REAL, ALLOCATABLE  :: XZ2  (:,:,:)
        REAL, ALLOCATABLE  :: YZ2  (:,:,:)

        REAL, ALLOCATABLE  :: PROJPAD(:,:)   ! PADDED 2D PROJ ARRAY
        REAL, ALLOCATABLE  :: XDER   (:,:)   ! X  DERIVATIVE OF PROJ
        REAL, ALLOCATABLE  :: YDER   (:,:)   ! Y  DERIVATIVE OF PROJ
        REAL, ALLOCATABLE  :: XYDER  (:,:)   ! XY DERIVATIVE OF PROJ

        ICYCLE = 1

        MYPID  = -1

        NXLD   = N + 2 - MOD(N,2)

        ALLOCATE( PROJPAD(NXLD, N),
     &            XDER   (NXLD, N),
     &            YDER   (NXLD, N),
     &            XYDER  (NXLD, N),
     &            BCKE   (N,    N, N), 
     &            BCKP   (N,    N, N),
     &            XYZ    (NXLD, N, N),
     &            X1     (NXLD, N, N),
     &            Y1     (NXLD, N, N),
     &            Z1     (NXLD, N, N),
     &            XY2    (NXLD, N, N),
     &            XZ2    (NXLD, N, N),
     &            YZ2    (NXLD, N, N),
     &            STAT=IRTFLG)

        IF (IRTFLG .NE. 0) THEN
           MWANT = 4*NXLD*N + 2*N*N*N + 7*NXLD*N*N / 1000
           CALL ERRT(46,'BPCG_3_FBS; PROJPAD,./1000.',MWANT)
           GOTO 9999
        ENDIF
        IF (VERBOSE) THEN
            WRITE(NOUT,*)'  BPCG_3_FBS ALLOCATED:',MWANT
            CALL FLUSHRESULTS()
        ENDIF


        NNN = N*N*N
c$omp   parallel do private(k,j,i)
        DO K=1,N
           DO J=1,N
              DO I=1,N
                 BCKN(I,J,K)     = 0.0
                 BCKP(I,J,K)     = 0.0
              ENDDO
           ENDDO
        ENDDO

        ERR  = 1.0
        ITER = 0
        Q    = 0.0

        DO  ITER=1,MAXIT

           DELSQ = 0.0
c$omp      parallel do private(kn,j,k,i),reduction(+:delsq)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 DELSQ = DELSQ + CB(I,J,K)*CB(I,J,K)
              ENDDO
           ENDDO
           Q = Q * DELSQ

c$omp      parallel do private(kn,j,k,i)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 BCKP(I,J,K) = CB(I,J,K) - Q * BCKP(I,J,K)
              ENDDO
           ENDDO
           Q = -1.0 / DELSQ

C          BCKP -> PROJ -> BCKE
C          LOOP OVER PROJECTIONS

c$omp      parallel do private(k,j,i)
           DO K=1,N
              DO J=1,N
                 DO I=1,N
                    BCKE(I,J,K) = 0.0
                    XYZ(I,J,K)  = BCKP(I,J,K)
                 ENDDO
                 DO I = N+1,NXLD
                    XYZ(I,J,K) = 0
                 ENDDO
               ENDDO
           ENDDO

C          CALCULATION OF PROJECTIONS DERIVATIVES USING 3D FFT
           CALL FBS3_PREP(XYZ, NXLD,N,N,N,
     &                    X1,Y1,Z1,XY2,XZ2, YZ2)

           !IF (VERBOSE) THEN
           !   WRITE(NOUT,*)'  FBS3_PREP completed, cycle:',ICYCLE
           !   CALL FLUSHRESULTS()
           !ENDIF

           DO K=1,NANG,NUMTH
              L_EN  = MIN(NANG,K+NUMTH-1)
              L_NUM = MIN(NUMTH,NANG-K+1)

c$omp         parallel do private(i,j)
              DO J=1,L_NUM
                 DO I=1,N*N
                    PROJ(I,J) = 0.0
                 ENDDO
              ENDDO

c$omp         parallel do private(l_th),schedule(static)
              DO  L_TH=1,L_NUM

C                PROJECTS BCKP INTO PROJ  (FROM VOLUME TO PLANE)
                 CALL PRJCQ_FBS3(BCKP,DM(1,K+L_TH-1),
     &                PROJ(1,L_TH),N,NXLD,  XYZ,
     &                X1, Y1, Z1,
     &                XY2,XZ2,YZ2)
              ENDDO
              !IF (VERBOSE) THEN
              !WRITE(NOUT,*)'  PRJCQ_FBS3 completed, cycle,k:',icycle,k
              !CALL FLUSHRESULTS()
              !ENDIF

C             HERE BCKPJ ITSELF IS MP  (MULTIPLE PROCESSING)

              DO  L_TH=1,L_NUM
C                MULTIPLY PROJECTIONS BY THEIR WEIGHTS
                 IF (LB(K+L_TH-1) > 1)  THEN
c$omp               parallel do private(i)
                    DO  I=1,N*N
                       PROJ(I,L_TH) = PROJ(I,L_TH) * LB(K+L_TH-1)
                    ENDDO
                 ENDIF

C                PAD PROJECTION TO: PROJPAD
c$omp            parallel do private(iy,iloc,ix)
                 DO IY = 1,N
                    ILOC = (IY-1)*N + 1 
                    DO IX = 1,N 
                       PROJPAD(IX,IY) = PROJ(ILOC, L_TH)
                       ILOC           = ILOC + 1
                    ENDDO
                 ENDDO

C                CALCULATE PROJECTION DERIVATIVES USING FFT
C                IN FBS2_PREP PROJPAD DOES NOT RETURN USEFULL VALUE!
                 CALL FBS2_PREP(PROJPAD, XDER,YDER,XYDER, 
     &                          NXLD,N,N, IRTFLG)
   
C                BACKPROJECT FROM PLANE: PROJ TO VOLUME: BCKE
                 CALL BCKPJ_FBS(BCKE,NNN,DM(1,K+L_TH-1),
     &                  PROJ(1, L_TH), XDER,YDER,XYDER,
     &                  NXLD,N,IPCUBE,NN, LDP,LDPNM)
              ENDDO
           ENDDO

           IF (MODE == 1) THEN
              CALL FIXEDGE1(BCKP,NNN,BCKP,N,IPCUBE,NN)      
              CALL BFIRSTS(BCKE,BCKP,N,ANOISE,IPCUBE,NN)

           ELSEIF(MODE == 2) THEN
              CALL FIXEDGE2(BCKP,NNN,BCKP,N,IPCUBE,NN)      
              CALL BSECOND(BCKE,BCKP,N,ANOISE,IPCUBE,NN)

           ELSEIF (MODE == 3) THEN
              CALL FIXEDGE3(BCKP,NNN,BCKP,N,IPCUBE,NN)      
              CALL BTHIRD(BCKE,BCKP,N,ANOISE,IPCUBE,NN)
           ENDIF

           AKDEN = 0.0

c$omp      parallel do private(kn,j,k,i),reduction(+:akden)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),
     &             IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 AKDEN = AKDEN + BCKP(I,J,K) * BCKE(I,J,K)
              ENDDO
           ENDDO
           P = DELSQ / AKDEN

c$omp      parallel do private(kn,j,k,i)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),
     &           IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)

                 BCKN(I,J,K) = BCKN(I,J,K)+P*BCKP(I,J,K)
                 CB(I,J,K)   = CB(I,J,K)-P*BCKE(I,J,K)
              ENDDO
           ENDDO

           ERR  = DELSQ / BNORM
           CHI2 = CHI2 - P * DELSQ

           IF (VERBOSE) THEN
C             SKIP THIS IF NOT VERBOSE
              WRITE(NOUT,2041) ITER,ERR,CHI2
2041          FORMAT('  ITERATION: 'I3,
     &               '   DIFFERENCE:',1PE12.4,
     &               '   CHISQ:',1PE12.4)
              CALL FLUSHRESULTS()
           ENDIF

C          CHECK STOPPING CRITERIA
           IF (ABS(ERR)  <= ERRM .OR. ABS(CHI2) <= CHIM) THEN  
C             WRITE FINAL ERROR ALWAYS
              IF (.NOT. VERBOSE) WRITE(NOUT,2041) ITER,ERR,CHI2
              WRITE(NOUT,*) '  '  
              CALL FLUSHRESULTS()
              GOTO 9999            
           ENDIF

           ICYCLE = ICYCLE + 1

       ENDDO

9999   IF (ALLOCATED(BCKE))    DEALLOCATE (BCKE)
       IF (ALLOCATED(BCKP))    DEALLOCATE (BCKP)
       IF (ALLOCATED(XYZ))     DEALLOCATE (XYZ)
       IF (ALLOCATED(X1))      DEALLOCATE (X1)
       IF (ALLOCATED(Y1))      DEALLOCATE (Y1)
       IF (ALLOCATED(Z1))      DEALLOCATE (Z1)
       IF (ALLOCATED(XY2))     DEALLOCATE (XY2)
       IF (ALLOCATED(XZ2))     DEALLOCATE (XZ2)
       IF (ALLOCATED(YZ2))     DEALLOCATE (YZ2)
       IF (ALLOCATED(PROJPAD)) DEALLOCATE (PROJPAD)
       IF (ALLOCATED(XDER))    DEALLOCATE (XDER)
       IF (ALLOCATED(YDER))    DEALLOCATE (YDER)
       IF (ALLOCATED(XYDER))   DEALLOCATE (XYDER)

       END
@


1.69
log
@verbose output tracing, ==
@
text
@d30 1
a30 1
C=* Email: spider@@wadsworth.org                                        *
@


1.68
log
@gfort bug requires -fwrapv,  D_ double prec. names, cosmetic
@
text
@d2 1
a2 1
C++*********************************************************************
d22 1
a22 1
C            D_KLP,D_KLS                           JAN 2013 ARDEAN LEITH *
d28 1
a28 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d68 1
a68 1
C--*********************************************************************
d94 3
d128 1
a128 1
        IF (FILPAT(NLET:NLET) .EQ. '@@') THEN
d139 2
a140 2
        WANT3    = (FCHAR(4:7) .EQ. 'CG 3')   ! WANT THREE VOLUMES
        USELISTS = (FCHAR(4:8) .EQ. 'CG 3L')  ! WANT THREE LISTS
d198 1
a201 1
     &            BCKN(N*N*N), 
d204 1
a204 1
           MWANT = 5*NN + N*N*N + 3*NANG + 9*NANG + NANG + N*N*N 
d253 1
d309 1
d354 1
d447 3
d582 1
a582 1
              ELSE IF (MYPID .EQ. IPROC-1) THEN
d594 1
a594 1
           ELSE IF (MYPID .EQ. 0) THEN
d649 1
a649 1
        END DO
d701 1
a701 1
           IF (VERBOSE) THEN
d914 1
a914 1
        IF (MYPID .EQ. 0) THEN
d1005 1
a1005 1
                 IF (LBLOC(K+L_TH-1) .GT. 1)  THEN
d1037 1
a1037 1
           IF (MODE .EQ. 1)  THEN
d1042 1
a1042 1
           ELSEIF(MODE.EQ.2)  THEN
d1046 1
a1046 1
           ELSEIF(MODE.EQ.3)  THEN
d1078 1
a1078 1
           IF (MYPID .EQ. 0) WRITE(NOUT,2041) ITER,ERR,CHI2
d1082 1
d1217 1
d1361 1
a1361 1
           IF (NT .GT. NN)  THEN
d1363 1
a1363 1
           ELSEIF (I .LT. IPCUBE(1,NT))  THEN
d1365 1
a1365 1
           ELSEIF (I .EQ. IPCUBE(2,NT))  THEN
d1442 1
a1442 1
           IF (NT.GT.NN)  THEN
d1444 1
a1444 1
           ELSEIF (I .LT. IPCUBE(1,NT))  THEN
d1446 1
a1446 1
           ELSEIF (I .EQ. IPCUBE(2,NT))  THEN
d1661 3
d1667 1
a1667 1
        INTEGER            :: K,J,I,L_TH,IY,ILOC,IX,MYPID,NE,MWANT
d1671 2
a1672 3
        REAL, ALLOCATABLE  :: BCKE_SUM(:,:,:)
        REAL, ALLOCATABLE  :: BCKE    (:,:,:)
        REAL, ALLOCATABLE  :: BCKP    (:,:,:)
d1709 2
a1710 2
           MWANT = 4 * NXLD*N + 2 * N*N*N + 7*NXLD*N*N
           CALL ERRT(46,'BPCG_3_FBS; PROJPAD,...',MWANT)
d1713 4
a1725 3
#ifdef USE_MPI
                 BCKE_SUM(I,J,K) = 0.0
#endif
d1777 4
a1780 2
           !WRITE(6,*), 'Iteration cycle:', ICYCLE
           ICYCLE = ICYCLE + 1
d1802 4
d1811 1
a1811 1
                 IF (LB(K+L_TH-1) .GT. 1)  THEN
d1840 1
a1840 1
           IF (MODE .EQ. 1) THEN
d1844 1
a1844 1
           ELSEIF(MODE .EQ. 2) THEN
d1848 1
a1848 1
           ELSEIF (MODE .EQ. 3) THEN
d1881 8
a1888 5
C         SKIP THIS IF NOT VERBOSE
          WRITE(NOUT,2041) ITER,ERR,CHI2
2041      FORMAT('  ITERATION: 'I3,
     &           '   DIFFERENCE:',1PE12.4,
     &           '   CHISQ:',1PE12.4)
d1891 3
a1893 4
           IF (ABS(ERR)  .LE. ERRM .OR. 
     &         ABS(CHI2) .LE. CHIM) THEN  
C             WRITE FINAL ERROR 
              IF (.NOT. VERBOSE)  WRITE(NOUT,2041) ITER,ERR,CHI2
d1895 1
d1898 3
@


1.67
log
@DKLP replaces KLP_8, astasq call
@
text
@d21 3
a23 3
C            KLP_8,KLS_8                         APR 2012 ARDEAN LEITH *
C            DKLP,DKLS                           JAN 2013 ARDEAN LEITH *
C                                                                      *
d120 1
a120 1
     &             'ENTER TEMPLATE FOR IMAGE FILES~',
d442 1
a442 1
        DOUBLE PRECISION      :: ABA,SUS,SSQ
d447 2
a448 2
        INTEGER(KIND=I_8)     :: KLP_8, KLS_8
        DOUBLE PRECISION      :: DKLP,DKLP_LOC, DKLS,DKLS_LOC
d458 1
a458 1
        DOUBLE PRECISION      :: ABA_LOC,SUS_LOC,SSQ_LOC
d497 3
a499 3
        ABA     = 0.0D0
        SUS     = 0.0D0
        SSQ     = 0.0D0
d501 2
a502 2
        DKLP    = 0
        DKLS    = 0
d515 5
a519 5
        DKLP_LOC = 0
        DKLS_LOC = 0
        ABA_LOC  = 0.0D0 
        SUS_LOC  = 0.0D0
        SSQ_LOC  = 0.0D0
d556 1
a556 1
              IF (MYPID .LE. 0) THEN
d566 2
a567 2
           IF (IPROC .GT. 1) THEN
              IF (MYPID .EQ. 0) THEN
d607 2
a608 2
           CALL ASTASQ(PRJLOC(1,1,K), N, RI, ABA_LOC, DKLP_LOC, 
     &                 SUS_LOC, SSQ_LOC, DKLS_LOC)
d646 1
a646 1
        CALL ALLREDUCE_MPI('REPRCG','ABA', ABA_LOC,ABA,
d648 1
a648 1
        CALL ALLREDUCE_MPI('REPRCG','DKLP', DKLP_LOC,DKLP,
d650 1
a650 1
        CALL ALLREDUCE_MPI('REPRCG','SSQ', SSQ_LOC,SSQ,
d652 1
a652 1
        CALL ALLREDUCE_MPI('REPRCG','SUS', SUS_LOC,SUS,
d654 1
a654 1
        CALL ALLREDUCE_MPI('REPRCG','DKLS', DKLS_LOC,DKLS,
d667 4
a670 2
        K = 1
        DO                ! LOOP OVER ALL INPUT IMAGES
d681 2
a682 1
           IF (ICOUNT .LE. 0) THEN
d704 1
a704 3
           CALL ASTASQ(PROJ,N,RI,ABA,DKLP,SUS,SSQ,DKLS)

           NNN = N*N*N
a705 1
C          BACKPROJECTION INTO: CUBE
d736 3
a738 1
                 PROJT(3,I) = PROJ(I+1)   - PT 
d740 1
d757 1
d772 1
a772 1
        ABA   = ABA / DKLP
d774 1
a774 1
        QT    = ABA * NANG
d788 2
a789 2
        SSQ  = SSQ - ABA * (2 * SUS - ABA * DKLS)
        CHI2 = SSQ
d793 1
a793 1
        KLP_8 = DKLP
d796 1
a796 1
           WRITE(NOUT,2044) KLP_8,ABA,BNORM,CHI2
d803 2
d826 1
a826 1
        REAL                :: ANOISE,SQ, DELSQ
d1009 2
d1013 1
d1151 2
d1159 1
a1159 1
     &                      IPCUBE,NN, LDP,LDPNM)
d1209 1
a1209 1
           IF (ABS(ERR) .LE. ERRM .OR. ABS(CHI2) .LE. CHIM) THEN  
d1233 1
a1233 3
        SUBROUTINE  ASTASQ(X,N,RI,ABA,DKLP,SUS,SSQ,DKLS)

        USE TYPE_KINDS
d1236 2
a1237 2
        DOUBLE PRECISION  :: ABA,SUS,SSQ
        DOUBLE PRECISION  :: DKLP,DKLS
d1240 1
a1240 1
C       RETURNS: ABA, DKLP, SUS, SSQ, DKLS
d1243 1
a1243 1
        NC = N/2+1
d1251 1
a1251 1
              IF (XX + T*T > R)    THEN
d1253 2
a1254 2
                 ABA = ABA + DBLE(X(I,J))
                 DKLP = DKLP + 1
d1257 3
a1259 3
                 SSQ = SSQ + X(I,J) * DBLE(X(I,J))
                 SUS = SUS + X(I,J)
                 DKLS = DKLS + 1
d1590 2
a1591 1
        INTEGER :: IORD,ITMP,K,I
d1604 1
a1604 1
	   ITMP           = RANDLIST(IORD)
d1606 1
a1606 1
	   RANDLIST(K)    = ITMP
d1611 1
@


1.66
log
@KLS_8 KLP_8 ASTASQ 8
@
text
@d22 1
d28 1
a28 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d50 1
a50 1
C            THE RECONSTRUCTION IS CALCULATED INSIDE A SPHERE OF
d447 2
a448 1
        INTEGER(KIND=I_8)     :: KLP_8,KLP_LOC_8, KLS_8,KLS_LOC_8
a496 2
        KLP_8   = 0
        KLS_8   = 0
d500 3
d515 5
a519 5
        KLP_LOC_8 = 0
        KLS_LOC_8 = 0
        ABA_LOC   = 0.0D0 
        SUS_LOC   = 0.0D0
        SSQ_LOC   = 0.0D0
d607 2
a608 2
           CALL ASTASQ(PRJLOC(1,1,K), N, RI, ABA_LOC, KLP_LOC_8, 
     &                 SUS_LOC, SSQ_LOC, KLS_LOC_8)
d648 2
a649 2
        CALL ALLREDUCE_MPI('REPRCG','KLP_8', KLP_LOC_8,KLP_8,
     &                           1, '8','S',ICOMM)
d654 2
a655 2
        CALL ALLREDUCE_MPI('REPRCG','KLS_8', KLS_LOC_8,KLS_8,
     &                           1, '8','S',ICOMM)
d701 1
a701 1
           CALL ASTASQ(PROJ,N,RI,ABA,KLP_8,SUS,SSQ,KLS_8)
d768 1
a768 1
        ABA   = ABA / KLP_8
d784 1
a784 1
        SSQ  = SSQ - ABA * (2 * SUS - ABA * KLS_8)
d788 3
d793 4
a796 4
2044       FORMAT(/,'  TOTAL # OF POINTS IN PROJECTIONS:',I10,/,
     &              '  AVERAGE OUTSIDE THE WINDOW:      ',1PE10.3,/,
     &              '  SQUARED BP:                      ',1PE10.3,/,
     &              '  CHI2:                            ',1PE10.3)
d1222 1
a1222 1
        SUBROUTINE  ASTASQ(X,N,RI,ABA,KLP_8,SUS,SSQ,KLS_8)
d1228 1
a1228 1
        INTEGER(KIND=I_8) :: KLP_8,KLS_8
d1231 1
a1231 1
C       RETURNS: ABA, KLP_8, SUS, SSQ, KLS_8
d1245 1
a1245 1
                 KLP_8 = KLP_8 + 1
d1250 1
a1250 1
                 KLS_8 = KLS_8 + 1
d1266 1
a1266 1
           IF (NT .GT. NN)  THEN
d1268 1
a1268 1
           ELSEIF (I .LT. IPCUBE(1,NT))  THEN
d1270 1
a1270 1
           ELSEIF(I .EQ. IPCUBE(2,NT))  THEN
@


1.65
log
@replaced CALL PRJCQ_FBS3  for FBS
@
text
@d1 1
d21 1
d446 1
a446 1
        INTEGER(KIND=I_8)     :: KLP,KLS
d495 2
a496 2
        KLP     = 0
        KLS     = 0
d512 5
a516 5
        KLP_LOC = 0
        KLS_LOC = 0
        ABA_LOC = 0.0D0 
        SUS_LOC = 0.0D0
        SSQ_LOC = 0.0D0
d604 2
a605 2
           CALL ASTASQ(PRJLOC(1,1,K), N, RI, ABA_LOC, KLP_LOC, 
     &                 SUS_LOC, SSQ_LOC, KLS_LOC)
d645 2
a646 2
        CALL ALLREDUCE_MPI('REPRCG','KLP', KLP_LOC,KLP,
     &                           1, 'I','S',ICOMM)
d651 2
a652 2
        CALL ALLREDUCE_MPI('REPRCG','KLS', KLS_LOC,KLS,
     &                           1, 'I','S',ICOMM)
d698 1
a698 1
           CALL ASTASQ(PROJ,N,RI,ABA,KLP,SUS,SSQ,KLS)
d765 1
a765 1
        ABA   = ABA / KLP
d781 1
a781 1
        SSQ  = SSQ - ABA * (2 * SUS - ABA * KLS)
d786 1
a786 1
           WRITE(NOUT,2044) KLP,ABA,BNORM,CHI2
d1216 1
a1216 1
        SUBROUTINE  ASTASQ(X,N,RI,ABA,KLP,SUS,SSQ,KLS)
d1222 1
a1222 1
        INTEGER(KIND=I_8) :: KLP,KLS
d1225 1
a1225 1
C       RETURNS: ABA,KLP,SUS,SSQ,KLS
d1239 1
a1239 1
                 KLP = KLP + 1
d1244 1
a1244 1
                 KLS = KLS + 1
@


1.64
log
@bad d in first col: d           IF (IRTFLG .NE. 0) GOTO 9999
@
text
@d260 3
d265 8
d279 8
a846 9
        DI = N / 2
        IF (MODE == 1 .AND. (RI+1.0+1.0) > DI  .OR. 
     &      MODE == 2 .AND. (RI+2.0+1.0) > DI .OR.
     &      MODE == 3 .AND. (RI+3.0+1.0) > DI)  THEN
           IRADIUS = INT(RI)
           CALL ERRT(102,'RADIUS TOO LARGE',IRADIUS)
           GOTO 9999
        ENDIF   

d1631 1
a1631 1
        INTEGER            :: KN, ICYCLE,IRADIUS
d1635 1
a1635 1
        REAL               :: AKDEN,DI,ERR,Q,P
d1642 8
d1659 1
a1659 10
        DI = N / 2
        IF (MODE == 1 .AND. (RI+1.0) > DI  .OR. 
     &      MODE == 2 .AND. (RI+2.0) > DI  .OR.
     &      MODE == 3 .AND. (RI+3.0) > DI)  THEN
           IRADIUS = INT(RI)
           CALL ERRT(102,'RADIUS TOO LARGE',IRADIUS)
           GOTO 9999
        ENDIF   

        NXLD = N + 2 - MOD(N,2)
d1661 14
a1674 7
        ALLOCATE(PROJPAD(NXLD, N),
     &           XDER   (NXLD, N),
     &           YDER   (NXLD, N),
     &           XYDER  (NXLD, N),
     &           BCKE   (N,N,N), 
     &           BCKP   (N,N,N),
     &           STAT=IRTFLG)
d1677 1
a1677 1
           MWANT = 4* NXLD*N + 2 * N*N*N
d1682 1
d1731 2
a1732 1
                    BCKE(I,J,K)  = 0.0
d1734 4
a1737 1
              ENDDO
d1740 6
a1745 2
           !WRITE(6,*), 'Iteration cycle #', ICYCLE
           ICYCLE= ICYCLE + 1
d1762 4
a1765 2
                 CALL PRJCQ_N(BCKP,NNN,DM(1,K+L_TH-1),
     &                       PROJ(1,L_TH),N,IPCUBE,NN, LDP,LDPNM)
d1860 7
@


1.63
log
@LIN RI TRAP BUG,  radius too big
@
text
@d146 1
a146 1
d           IF (IRTFLG .NE. 0) GOTO 9999
@


1.62
log
@removed fbs3 projection
@
text
@d19 1
d829 5
a833 4
        IF (MODE == 1 .AND. (RI+1.0) > DI  .OR. 
     &      MODE == 2 .AND. (RI+2.0) > DI .OR.
     &      MODE == 3 .AND. (RI+3.0) > DI)  THEN
           CALL ERRT(101,'RADIUS TOO LARGE',NE)
d1492 1
d1495 3
a1497 3
              BCKE(I,J,K) = BCKE(I,J,K)+ANOISE*(6*BCKP(I,J,K)-(
     &           + BCKP(I+1,J,K)+BCKP(I,J+1,K)+BCKP(I,J,K+1)
     &           + BCKP(I-1,J,K)+BCKP(I,J-1,K)+BCKP(I,J,K-1)))
d1621 1
a1621 1
        INTEGER            :: KN, ICYCLE
d1645 2
a1646 1
           CALL ERRT(101,'RADIUS TOO LARGE',NE)
@


1.61
log
@CALL NEXTFILE before each sampled volume
@
text
@a1628 8
        REAL, ALLOCATABLE  :: XYZ  (:,:,:)
        REAL, ALLOCATABLE  :: X1   (:,:,:)
        REAL, ALLOCATABLE  :: Y1   (:,:,:)
        REAL, ALLOCATABLE  :: Z1   (:,:,:)
        REAL, ALLOCATABLE  :: XY2  (:,:,:)
        REAL, ALLOCATABLE  :: XZ2  (:,:,:)
        REAL, ALLOCATABLE  :: YZ2  (:,:,:)

d1652 2
d1657 1
a1657 1
           MWANT = 4* NXLD*N
a1661 17
        ALLOCATE (BCKE (N,N,N), 
     &            BCKP (N, N, N),
     &            XYZ  (NXLD, N, N),
     &            X1   (NXLD, N, N),
     &            Y1   (NXLD, N, N),
     &            Z1   (NXLD, N, N),
     &            XY2  (NXLD, N, N),
     &            XZ2  (NXLD, N, N),
     &            YZ2  (NXLD, N, N),
     &            STAT=IRTFLG)

        IF (IRTFLG.NE.0) THEN 
           MWANT = 2 * N*N*N + 7*NXLD*N*N
           CALL ERRT(46,'BPCG_3_FBS; BCKE,BCKP',MWANT)
           GOTO 9999
        ENDIF

a1710 4
                    XYZ(I,J,K) = BCKP(I,J,K)
                 ENDDO
                 DO I = N+1,NXLD
                    XYZ(I,J,K) = 0
a1714 4
C          CALCULATION OF PROJECTIONS DERIVATIVES USING 3D FFT
           CALL FBS3_PREP(XYZ, NXLD,N,N,N,
     &                    X1,Y1,Z1,XY2,XZ2, YZ2)

d1733 2
a1734 4
                 CALL PRJCQ_FBS3(BCKP,DM(1,K+L_TH-1),
     &                PROJ(1,L_TH),N,NXLD,  XYZ,
     &                X1, Y1, Z1,
     &                XY2,XZ2,YZ2)
a1828 7
       IF (ALLOCATED(XYZ))     DEALLOCATE (XYZ)
       IF (ALLOCATED(X1))      DEALLOCATE (X1)
       IF (ALLOCATED(Y1))      DEALLOCATE (Y1)
       IF (ALLOCATED(Z1))      DEALLOCATE (Z1)
       IF (ALLOCATED(XY2))     DEALLOCATE (XY2)
       IF (ALLOCATED(XZ2))     DEALLOCATE (XZ2)
       IF (ALLOCATED(YZ2))     DEALLOCATE (YZ2)
@


1.60
log
@rprq paramete
output formats
@
text
@d82 1
a82 1
        LOGICAL               :: ASKNAM,FOUROK,WANT3,USELISTS,FBS_WANTED
d87 2
a99 2
C       NANG - NUMBER OF ANGLES = PROJECTIONS

d101 1
a101 2
        ASKNAM  = .TRUE.
        FOUROK  = .FALSE.
d112 1
d145 1
a145 1
           IF (IRTFLG .NE. 0) GOTO 9999
d161 2
a162 1
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,LUNANG,.FALSE.,MAXXT,
d283 9
d299 1
a299 1
           CALL HIANG(ANG,NANG1,DM,LB,LO)     ! ALTERS NANG!!
d320 2
d327 9
d396 3
a398 3
        SUBROUTINE BPCG_2(N,NANG,CUBE,ANG,ILIST,IPCUBE,NN,DM,RI,ANGBUF,
     &                     FINPAT,MAXIM,BNORM,CHI2,
     &                     LUNPROJ,LDP,LDPNM,FBS_WANTED, IRTFLG)
d466 1
a466 1
              MWANT = 4* NXLD*N
d511 2
a512 2
        CUBE_LOC  = 0.0
        ANG_LOC = 0.0
d534 1
a534 1
                   CALL  REDLIN1P(LUNPROJ,PRJBUF(1,K2,K),N,K2)
d609 5
a613 3
              IF (MYPID .EQ. 0) WRITE(NOUT,3331) K,(ANG(J,K),J=3,1,-1)
3331          FORMAT('  PROJECTION #',I7,
     &               '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
d641 1
d643 1
a643 1
        DO                ! LOOP OVER ALL INPUT PROJECTIONS
d645 1
a645 1
           ! LOAD NEXT PROJECTION (SQUARE)
d648 1
a648 1
C          LOAD ANGLES FOR THIS PROJECTION
d666 4
a669 4
3331          FORMAT('  PROJECTION: ',I6,
     &               '  PSI=',F6.1,
     &               '  THETA=',F6.1,
     &               '  PHI=',F6.1)
d727 1
a727 1
           IF (IRTFLG .EQ. -1) EXIT      !  END OF INPUT STACK
@


1.59
log
@LINEAR OR FBS INTERPOLATIO question instead of: SPACE FOR FUTURE QUESTION
@
text
@d116 1
a116 1
     &             'ENTER TEMPLATE FOR IMAGE',
d130 1
a130 1
90      FORMAT('  NUMBER OF IMAGES=',I6)
d570 1
a570 2
     &           ANG_LOC(1,K),ANG_LOC(2,K),ANG_LOC(3,K),
     &           DM(1,KGLB), LDP,LDPNM,IRTFLG)
d589 1
a589 1
3331          FORMAT('  PROJECTION #',I6,
d1827 1
a1827 1
           IF (ABS(ERR) .LE. ERRM .OR. 
@


1.58
log
@use_fbs_interp  instead of prompt
@
text
@d169 1
a169 1
     &     'SPACE FOR FUTURE QUESTION (ANY RESPONSE OK)', NULL,IRTFLG)
d172 1
d241 1
a241 2
        NXLD       = N + 2 - MOD(N,2)
        FBS_WANTED = USE_FBS_INTERP  
@


1.57
log
@added fbs question instead of: USE_FBS_INTERP,   activated fbs for all 3
@
text
@d169 1
a169 1
     &     'LINEAR OR FBS INTERPOLATION (L,F)', NULL,IRTFLG)
a171 1
        FBS_WANTED = (ANSW(1:1) == 'F')  
d240 2
a241 1
        NXLD = N + 2 - MOD(N,2)
@


1.56
log
@WRITE(NOUT,*) ' USING FBS
@
text
@d11 4
a14 4
C            COMMON PAR REMOVED,                 DEC 2010 ARDEAN LEITH *                                                                  *
C            THREE OUTPUTS                       JAN 2011 ARDEAN LEITH *                                                                  *
C            REPCG --> BPCG                      JAN 2011 ARDEAN LEITH *                                                                  *
C            MPI_RECV BUG                        APR 2011 ARDEAN LEITH *                                                                  *
d18 1
d24 1
a24 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d82 1
a82 1
        LOGICAL               :: ASKNAM,FOUROK,WANT3,USELISTS
d169 4
a172 6
     &     'DOES YOUR VOLUME HAVE SYMMETRIES? (NOT IMPLEMENTED) (Y/N)',
     &      NULL,IRT)
        IF (ANSW .EQ. 'Y')  THEN
              CALL ERRT(101,'*** SYMMETRIES OPTION NOT IMPLEMENTED',NE)
              GOTO 9999
        ENDIF
d201 1
d249 1
a249 1
     &               LUNPROJ,LDP,LDPNM, IRTFLG)
d258 1
a258 1
        IF (USE_FBS_INTERP) THEN
d285 1
a285 1
     &               LUNPROJ,LDP,LDPNM, IRTFLG)
d293 9
a301 1
           CALL BPCG_3_LIN(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG1,RI,
d304 2
d318 1
a318 1
     &                  LUNPROJ,LDP,LDPNM, IRTFLG)
d326 3
a328 1
           CALL BPCG_3_LIN(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG2,RI,
d331 7
d341 1
a341 1
           CALL WRTVOL(LUNVOL2,N,N,1,N,BCKN,IRTFLG)
d377 1
a377 1
     &                     LUNPROJ,LDP,LDPNM,IRTFLG)
d395 1
d437 1
a437 1
        IF (USE_FBS_INTERP) THEN
d658 1
a658 1
           IF (USE_FBS_INTERP) THEN
d676 1
a676 1
C             BACKPROJECT FROM PLANE: PROJ TO VOLUME: BCKE
d1657 1
a1657 1
           MWANT = 2 * N*N*N + NXLD*N*N
@


1.55
log
@renamed: bckcq_ to: bckpj_,
@
text
@d259 1
d265 1
@


1.54
log
@klp to integer*8, many cosmetic, vars renamed[D[D[D[D[D[D[D[D[D[D[D[D
@
text
@d5 1
a5 1
C            USED PROJT FOR BCKCQ CALL           FEB 2000 ARDEAN LEITH *
d55 3
a57 3
C                  --->     BPCG2     ---> ATASQ
C                  --->               -->  RPRQ
C                  --->               -->  BCKCQ_N or BCKCQ_FBS
d59 2
a60 2
C                  --->     BPCG_3_Q   --> BCKCQ_N
C                  --->     BPCG_3_FBS --> BCKCQ_FBS
d264 1
a264 1
           CALL BPCG_3_Q(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG,RI,
d291 1
a291 1
           CALL BPCG_3_Q(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG1,RI,
d314 1
a314 1
           CALL BPCG_3_Q(CB,BCKN,NXLD,N,ICUBE,NN,DM,LB,NANG2,RI,
d655 1
a655 1
              CALL BCKCQ_FBS(CUBE,NNN,DM(1,K),
d671 1
a671 1
              CALL BCKCQ_N(CUBE,NNN,DM(1,K),
d728 1
a728 1
C**************************** BPCG_3_Q ******************************
d730 1
a730 1
        SUBROUTINE BPCG_3_Q(CB,BCKN,NXLD,N,IPCUBE,NN,DM,LB,NANG,RI,
d772 1
a772 1
           CALL ERRT(46,'BPCG_3_Q; NBASE,...',MWANT)
d795 1
a795 1
           CALL ERRT(46,'BPCG_3_Q; BCKE,BCKP',MWANT)
d826 1
a826 1
           CALL ERRT(46,'BPCG_3_Q; DMLOC',MWANT)
d841 1
a841 1
              CALL SEND_MPI('BPCG_3_Q','DM', DM(1,IBEGIN), 9*NLOC, 
d844 1
a844 1
              CALL SEND_MPI('BPCG_3_Q','LB', LB(IBEGIN), NLOC, 
d857 1
a857 1
           CALL RECV_MPI('BPCG_3_Q','DMLOC', DMLOC, 9*NANGLOC, 'R',
d860 1
a860 1
           CALL RECV_MPI('BPCG_3_Q','LBLOC', LBLOC, NANGLOC, 'I',
d867 1
a867 1
        write(6,*)' BPCG_3_Q: data distributed, mypid:',mypid
d922 1
a922 1
C             HERE BCKCQ ITSELF IS MP  
d943 1
a943 1
                 CALL BCKCQ_N(BCKE,NNN,DMLOC(1,K+L_TH-1),
d948 1
a948 1
           CALL ALLREDUCE_MPI('BPCG_3_Q','BCKE_SUM',BCKE,BCKE_SUM,
d1054 1
a1054 1
c$omp      parallel do private(l_th),shared(NNN,n,nn),schedule(static)
d1061 1
a1061 1
C             HERE BCKCQ ITSELF IS MP  
d1082 1
a1082 1
                 CALL BCKCQ_N(BCKE,NNN,DM(1,K+L_TH-1),PROJT,N,
d1725 1
a1725 1
C             HERE BCKCQ ITSELF IS MP  (MULTIPLE PROCESSING)
d1752 1
a1752 1
                 CALL BCKCQ_FBS(BCKE,NNN,DM(1,K+L_TH-1),
@


1.53
log
@rewrote using bckcq instead of rprq
@
text
@d81 1
a81 1
        LOGICAL               :: ASKNAM,FOUROK, MD,WANT3,USELISTS
a177 1
        MD    = .FALSE.
d181 1
a181 1
        CALL PREPCUB_S(N,NN,IDUM,RI,MD,LDP)     ! RETURNS: NN
d202 1
a202 2
        MD = .TRUE.
        CALL PREPCUB_S(N,NN,ICUBE,RI,MD,LDP)   ! RETURNS: NN
a221 3

           !CALL FILERD(FILVOL2,NLET,NULL,'SECOND SAMPLE VOLUME,IRTFLG)           MAXIM = 0
           !IF (IRTFLG .NE. 0)  GOTO 9999
d224 2
d229 2
d234 2
a235 1
        CALL RDPRM1S(ALA,NOT_USED,'LAMBDA',IRTFLG)  ! NOISE SUPRESSOR
d241 1
a241 1
        LSD = N + 2 - MOD(N,2)
d259 1
a259 1
           CALL BPCG_3_FBS(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG,RI,
d261 1
a261 1
     &                 ERRM,CHIM,MAXIT,MODE,ALA, LDP,LDPNM,IRTLFG)
d264 1
a264 1
           CALL BPCG_3_Q(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG,RI,
d266 1
a266 1
     &                 ERRM,CHIM,MAXIT,MODE,ALA, LDP,LDPNM,IRTLFG)
d291 1
a291 1
           CALL BPCG_3_Q(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG1,RI,
d293 1
a293 1
     &                 ERRM,CHIM,MAXIT,MODE,ALA, LDP,LDPNM,IRTLFG)
d314 1
a314 1
           CALL BPCG_3_Q(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG2,RI,
d316 1
a316 1
     &                    ERRM,CHIM,MAXIT,MODE,ALA, LDP,LDPNM,IRTLFG)
d349 2
a350 1
C            SUBTRACTS AVERAGE OUTSIDE OF CIRCLE FROM FINAL VOLUME.
d357 2
d381 1
d416 5
a420 5
           NXLD   = N + 2 - MOD(N,2)
           ALLOCATE(PROJPAD(NXLD,       N),
     &              XDER   (0:NXLD-1, 0:N-1),
     &              YDER   (0:NXLD-1, 0:N-1),
     &              XYDER  (0:NXLD-1, 0:N-1),
d430 2
a432 1
        KLP     = 0
a434 1
        KLS     = 0
a446 1
        ABA_LOC = 0.0D0 
d449 1
d456 3
a458 3
        ALLOCATE(PRJBUF(N,N,PSIZE(1)),
     &           PRJLOC(N,N,NANGLOC),
     &           ANG_LOC(3,NANGLOC),
d730 4
a733 3
        SUBROUTINE BPCG_3_Q(CB,BCKN,LSD,N,IPCUBE,NN,DM,LB,NANG,RI,
     &                       NUMTH,BNORM,CHI2,
     &                       ERRM,CHIM,MAXIT,MODE,ALA, LDP,LDPNM,IRTFLG)
d740 1
a740 1
        INTEGER             :: LSD,N,NN
d747 1
a747 1
        REAL                :: ALA,SQ, DELSQ
d783 3
a785 3
        IF (MODE .EQ. 1 .AND. RI+1.0 .GT. DI
     &          .OR. MODE .EQ. 2 .AND. RI+2.0 .GT. DI
     &          .OR. MODE .EQ. 3 .AND. RI+3.0 .GT. DI)  THEN
d790 1
d794 1
a794 1
           MWANT = 2 * N*N*N
a798 1
        NNN = N*N*N
d956 2
a957 2
c             CALL BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN,RI) sep 01 al
              CALL BFIRSTS(BCKE_SUM,BCKP,N,ALA,IPCUBE,NN)
d961 1
a961 1
              CALL BSECOND(BCKE_SUM,BCKP,N,ALA,IPCUBE,NN)
d965 1
a965 1
              CALL BTHIRD(BCKE_SUM,BCKP,N,ALA,IPCUBE,NN)
d1089 1
a1089 1
              CALL BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN)
d1093 1
a1093 1
              CALL BSECOND(BCKE,BCKP,N,ALA,IPCUBE,NN)
d1097 1
a1097 1
              CALL BTHIRD(BCKE,BCKP,N,ALA,IPCUBE,NN)
d1159 2
d1163 1
d1168 1
a1168 1
        R  = RI*RI
d1172 1
a1172 1
           T  = J-NC
d1174 1
d1176 3
a1178 2
              T=I-NC
              IF (XX + T * T .GT. R)    THEN
d1182 1
d1436 1
a1436 1
        SUBROUTINE  BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN)
d1447 1
a1447 1
              BCKE(I,J,K) = BCKE(I,J,K)+ALA*(6*BCKP(I,J,K)-(
d1456 1
a1456 1
        SUBROUTINE  BSECOND(BCKE,BCKP,N,ALA,IPCUBE,NN)
d1467 1
a1467 1
               BCKE(I,J,K) = BCKE(I,J,K) + ALA*(18*BCKP(I,J,K)
d1481 1
a1481 1
        SUBROUTINE  BTHIRD(BCKE,BCKP,N,ALA,IPCUBE,NN)
d1492 1
a1492 1
                 BCKE(I,J,K) = BCKE(I,J,K) + ALA*(60*BCKP(I,J,K)
d1549 4
a1552 3
        SUBROUTINE BPCG_3_FBS(CB,BCKN,LSD,N,IPCUBE,NN,DM,LB,NANG,RI,
     &                       NUMTH,BNORM,CHI2,
     &                       ERRM,CHIM,MAXIT,MODE,ALA, LDP,LDPNM,IRTFLG)
d1561 1
a1561 1
        INTEGER            :: LSD,N,NN
d1570 1
a1570 1
        REAL               :: ALA
d1576 1
a1576 1
        INTEGER            :: K,J,I,L_TH,IY,ILOC,IX,MYPID,NE,NXLD,MWANT
d1609 1
a1609 1
        NXLD   = N + 2 - MOD(N,2)
d1611 4
a1614 4
        ALLOCATE(PROJPAD(NXLD,       N),
     &           XDER   (0:NXLD-1, 0:N-1),
     &           YDER   (0:NXLD-1, 0:N-1),
     &           XYDER  (0:NXLD-1, 0:N-1),
d1623 2
a1624 2
        ALLOCATE (BCKE  (N,N,N), 
     &            BCKP  (N, N, N),
d1760 1
a1760 1
              CALL BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN)
d1764 1
a1764 1
              CALL BSECOND(BCKE,BCKP,N,ALA,IPCUBE,NN)
d1768 1
a1768 1
              CALL BTHIRD(BCKE,BCKP,N,ALA,IPCUBE,NN)
@


1.52
log
@comments added
@
text
@d56 2
a57 1
C                  --->               --> RPRQ_N
d59 2
a60 2
C                  --->     BPCG_3_Q
C                  --->     BPCG_3_FBS
d343 1
a343 1
C ***************************** BPCG_2 *******************************
d347 3
a349 3
C  PURPOSE:  LOADS PROJECTIONS AND ANGELS. FINDS BACGROUND OUTSIDE
C            OF PROJECTED CIRCLE.  CARRIES OUT BACK-PROJECTION USING
C            RPRQ_N.  SUBTRACTS AVERAGE OUTSIDE OF CIRCLE FROM VOLUME.
d353 1
a353 1
        SUBROUTINE BPCG_2(N,NANG,CB,ANG,ILIST,IPCUBE,NN,DM,RI,ANGBUF,
d360 2
a361 1
        REAL                  :: CB(N,N,N),PROJ(N,N),ANG(3,NANG)
d363 1
d365 1
d367 6
d374 1
a374 1
        CHARACTER(LEN=MAXNAM) :: FILNAM,FINPAT
d377 1
d379 1
a380 1
#ifdef USE_MPI
d382 3
a384 2
        REAL, ALLOCATABLE   :: CB_LOC(:,:,:),PRJBUF(:,:,:),PRJLOC(:,:,:)
        REAL, ALLOCATABLE     :: ANG_LOC(:,:)
d402 8
d411 13
d436 1
a436 1
                 CB(I,J,K) = 0.0
a448 1

d455 1
a455 1
     &           CB_LOC(N,N,N), 
d464 1
a464 1
        CB_LOC  = 0.0
a503 1

a514 8

c              do jloc = 1, nloc
c                 do jsam = 1, n
c                     do jrow = 1, n
c                        prjloc(jsam,jrow,jloc) = prjbuf(jsam,jrow,jloc)
c                     enddo
c                  enddo
c               enddo
d530 1
a530 1
c           write(6,91) kglb,itmp,(ang_loc(j,k),j=3,1,-1)
d538 6
a543 2
C          BACKPROJECTION?
           CALL RPRQ_N(N,PRJLOC(1,1,K),CB_LOC,IPCUBE,NN,
d545 1
a545 1
     &           DM(1,KGLB),RI,LDP,LDPNM,IRTFLG)
d569 1
a569 1
        N3   = N*N*N
d571 2
a572 2
        CALL ALLREDUCE_MPI('REPRCG','CB', CB_LOC,CB,
     &                           N3, 'R','S',ICOMM)
d584 4
a587 4
        IF (ALLOCATED(CB_LOC))  DEALLOCATE(CB_LOC)
        IF (ALLOCATED(ANG_LOC)) DEALLOCATE(ANG_LOC)
        IF (ALLOCATED(PSIZE))   DEALLOCATE(PSIZE)
        IF (ALLOCATED(NBASE))   DEALLOCATE(NBASE)
d595 3
a597 3
           DO K2=1,N      ! LOAD PROJECTION
              CALL REDLIN(LUNPROJ,PROJ(1,K2),N,K2)
           ENDDO
d607 1
a607 1
              CALL ERRT(102,'MISSING ANGLE FOR IMAGE',ITMP)
d609 1
a609 1
              RETURN
d612 1
a612 1
           ANG(3,K) = ANGBUF(2,ITMP)
d616 1
a616 1
              WRITE(NOUT,3331)  K,(ANG(J,K),J=3,1,-1)
d623 3
d629 36
a664 4
C          BACKPROJECTION FROM PROJ INTO: CB
           CALL RPRQ_N(N,PROJ,CB,IPCUBE,NN,
     &                 ANG(1,K),ANG(2,K),ANG(3,K),DM(1,K),RI,
     &                 LDP,LDPNM,IRTFLG)
d666 5
d683 6
d692 1
d703 2
a704 2
              CB(I,J,K) = CB(I,J,K) - QT
              BNORM     = BNORM + CB(I,J,K) * CB(I,J,K)
d735 10
a746 1
        INTEGER             :: IPCUBE(5,NN),LB(NANG)
a751 1
        REAL                :: ALA, SQ, DELSQ
d793 1
a793 3

        NMAT = N*N*N
        LTB  = N*N
d862 1
a862 1
        write(6,*)' BPCG_3_q: data distributed, mypid:',mypid
d908 1
a908 1
                 DO I=1,LTB
d914 1
a914 1
              CALL PRJCQ_N(BCKP,NMAT,DMLOC(1,K),
d938 1
a938 1
                 CALL BCKCQ_N(BCKE,NMAT,DMLOC(1,K+L_TH-1),
d944 1
a944 1
     &                           NMAT, 'R','S',ICOMM)
d950 1
a950 1
              CALL FIXEDGE1(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
d955 1
a955 1
              CALL FIXEDGE2(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
d959 1
a959 1
              CALL FIXEDGE3(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
d996 1
a996 1
           IF (ABS(ERR) .LE. ERRM .OR. ABS(CHI2) .LE. CHIM) GOTO 9999            
d1007 1
a1007 1
c$omp      parallel do private(kn,j,k,i),reduction(+:DELSQ)
a1036 1

d1044 1
a1044 1
                 DO I=1,LTB
d1049 1
a1049 1
c$omp      parallel do private(l_th),shared(nmat,n,nn),schedule(static)
d1052 1
a1052 1
                 CALL PRJCQ_N(BCKP,NMAT,DM(1,K+L_TH-1),
d1059 1
a1059 1
                 IF (LB(K+L_TH-1) .GT. 1)  THEN
d1077 1
a1077 1
                 CALL BCKCQ_N(BCKE,NMAT,DM(1,K+L_TH-1),PROJT,N,
d1082 2
a1083 3
           IF (MODE .EQ. 1) THEN
              CALL FIXEDGE1(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
c             CALL BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN,RI) sep 01 al
d1086 2
a1087 2
           ELSEIF(MODE .EQ. 2) THEN
              CALL FIXEDGE2(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
d1090 2
a1091 2
           ELSEIF (MODE .EQ. 3) THEN
              CALL FIXEDGE3(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
d1182 1
a1182 1
        SUBROUTINE  FIXEDGE1(BCKP,NMAT,BCK3,N,IPCUBE,NN)
d1184 1
a1184 1
        REAL    :: BCKP(NMAT),BCK3(N,N,N) 
d1189 1
a1189 1
        DO I=1,NMAT
d1256 1
a1256 1
        SUBROUTINE  FIXEDGE2(BCKP,NMAT,BCK3,N,IPCUBE,NN)
d1258 1
a1258 1
        REAL    :: BCKP(NMAT),BCK3(N,N,N)
d1261 1
a1261 1
C      PUT ZEROS OUTSIDE
d1264 1
a1264 1
        DO    I=1,NMAT
d1337 1
a1337 1
        SUBROUTINE  FIXEDGE3(BCKP,NMAT,BCK3,N,IPCUBE,NN)
d1339 1
a1339 1
        REAL    :: BCKP(NMAT),BCK3(N,N,N)
a1341 1

d1345 1
a1345 1
        DO I=1,NMAT
d1435 1
d1455 1
d1480 1
a1535 1

d1545 1
d1564 3
d1569 3
a1571 2
        REAL, ALLOCATABLE  :: BCKE   (:,:,:)
        REAL, ALLOCATABLE  :: BCKP   (:,:,:)
d1573 6
a1578 6
        REAL, ALLOCATABLE  :: X1  (:,:,:)
        REAL, ALLOCATABLE  :: Y1  (:,:,:)
        REAL, ALLOCATABLE  :: Z1  (:,:,:)
        REAL, ALLOCATABLE  :: XY2 (:,:,:)
        REAL, ALLOCATABLE  :: XZ2 (:,:,:)
        REAL, ALLOCATABLE  :: YZ2 (:,:,:)
d1611 3
a1613 3
        ALLOCATE (BCKE(N,N,N), 
     &            BCKP(N, N, N),
     &            XYZ(NXLD, N, N),
d1623 1
a1623 1
           MWANT = 2 * N*N*N
d1628 1
a1628 2
        NMAT = N*N*N
        LTB  = N*N
d1649 1
a1649 1
c$omp      parallel do private(kn,j,k,i),reduction(+:DELSQ)
d1654 1
a1654 1
                 DELSQ = DELSQ+CB(I,J,K)*CB(I,J,K)
d1698 1
a1698 1
                 DO I=1,LTB
d1740 1
a1740 1
                 CALL BCKCQ_FBS(BCKE,NMAT,DM(1,K+L_TH-1),
d1747 1
a1747 1
              CALL FIXEDGE1(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
d1751 1
a1751 1
              CALL FIXEDGE2(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
d1755 1
a1755 1
              CALL FIXEDGE3(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
@


1.51
log
@BCKP0 --> XYZ, comments, simplifed one loop
@
text
@d41 1
a41 1
C  BPCG
d54 7
@


1.50
log
@var renamed,
@
text
@d1481 1
a1481 1
        REAL, ALLOCATABLE  :: BCKP0  (:,:,:)
d1522 1
a1522 1
     &            BCKP0(NXLD, N, N),
a1578 9
c$omp      parallel do private(k,j,i)
           DO K=1,N
              DO J=1,N
                 DO I=1,N
                    BCKE(I,J,K) = 0.0
                 ENDDO
              ENDDO
           ENDDO

d1585 4
d1590 1
a1590 10
                    BCKP0(I,J,K) = 0
                 ENDDO
              ENDDO
           ENDDO

c$omp      parallel do private(k,j,i)
           DO K=1,N
              DO J=1,N
                 DO I=1,N
                    BCKP0(I,J,K) = BCKP(I,J,K)
d1596 1
a1596 1
           CALL FBS3_PREP(BCKP0, NXLD,N,N,N,
a1616 1

d1618 1
a1618 1
     &                PROJ(1,L_TH),N,NXLD,  BCKP0,
a1624 1

d1640 1
a1640 1
                       ILOC = ILOC + 1
d1645 1
d1713 9
a1721 9
9999   IF (ALLOCATED(BCKE))   DEALLOCATE (BCKE)
       IF (ALLOCATED(BCKP))   DEALLOCATE (BCKP)
       IF (ALLOCATED(BCKP0))  DEALLOCATE (BCKP0)
       IF (ALLOCATED(X1))     DEALLOCATE (X1)
       IF (ALLOCATED(Y1))     DEALLOCATE (Y1)
       IF (ALLOCATED(Z1))     DEALLOCATE (Z1)
       IF (ALLOCATED(XY2))    DEALLOCATE (XY2)
       IF (ALLOCATED(XZ2))    DEALLOCATE (XZ2)
       IF (ALLOCATED(YZ2))    DEALLOCATE (YZ2)
@


1.49
log
@renamed subroutines inside it, verbose in fbs, cosmetic
@
text
@d990 1
a990 1
C                BACKPROJECT
d1489 4
a1492 5
        REAL, ALLOCATABLE  :: PROJT0(:,:)        ! 2D DATA ARRAY
        REAL, ALLOCATABLE  :: PROJT1(:,:)        ! 2D DATA ARRAY
        REAL, ALLOCATABLE  :: PROJT2(:,:)        ! X-DERIVATIVE OF DATA
        REAL, ALLOCATABLE  :: PROJT3(:,:)        ! Y-DERIVATIVE OF DATA
        REAL, ALLOCATABLE  :: PROJT4(:,:)        ! XY-DERIVATIVE OF DATA
d1497 9
d1508 5
a1512 6
        ALLOCATE(PROJT0  (0:N-1,    0:N-1),
     &           PROJT1  (0:NXLD-1, 0:N-1),
     &           PROJT2  (0:NXLD-1, 0:N-1),
     &           PROJT3  (0:NXLD-1, 0:N-1),
     &           PROJT4  (0:NXLD-1, 0:N-1),
     &                  STAT=IRTFLG)
d1515 2
a1516 2
           MWANT = N*N + 4* NXLD*N
           CALL ERRT(46,'BPCG_3_FBS; PROJT0,...',MWANT)
a1519 8
        DI = N / 2
        IF (MODE .EQ. 1 .AND. RI+1.0 .GT. DI  .OR. 
     &      MODE .EQ. 2 .AND. RI+2.0 .GT. DI  .OR.
     &      MODE .EQ. 3 .AND. RI+3.0 .GT. DI)  THEN
           CALL ERRT(101,'RADIUS TOO LARGE',NE)
           GOTO 9999
        ENDIF   

d1522 7
a1528 7
     &            BCKP0 (NXLD, N, N),
     &            X1  (NXLD, N, N),
     &            Y1  (NXLD, N, N),
     &            Z1  (NXLD, N, N),
     &            XY2 (NXLD, N, N),
     &            XZ2 (NXLD, N, N),
     &            YZ2 (NXLD, N, N),
d1604 1
a1604 1
              BCKP0(I,J,K) = BCKP(I,J,K)
d1610 2
a1611 2
           CALL FBS3_PREP(BCKP0, NXLD, N, N, N,
     &                  X1, Y1, Z1, XY2, XZ2, YZ2)
d1639 2
d1646 1
a1646 1
                       PROJ(I,L_TH) = PROJ(I,L_TH)*LB(K+L_TH-1)
d1650 7
a1656 10
c$omp            parallel do private(i,i2,j2)
                 DO I = 1,N*N
                    I2 = MOD(I-1,N)
                    J2 = INT((I-1)/N)
                    PROJT0(I2, J2) = PROJ(I, L_TH)
                 ENDDO

                 DO J = 0,N-1
                    DO I = N,NXLD-1
                       PROJT1(I,J) = 0
d1660 5
a1664 12
                 DO J = 0,N-1
                    DO I = 0,N-1
                       PROJT1(I,J) = PROJT0(I,J)
                    ENDDO
                 ENDDO

C                CALCULATION OF PROJECTIONS DERIVATIVES USING 2D FFT

                 CALL FBS2_PREP(PROJT1, PROJT2,PROJT3, PROJT4, 
     &                NXLD, N,N, IRTFLG)

C                BACKPROJECTION  (FROM PLANE TO VOLUME)
d1666 2
a1667 2
     &                  PROJT0,PROJT2,PROJT3,PROJT4,
     &                  N,IPCUBE,NN, LDP,LDPNM)
d1737 4
a1740 5
       IF (ALLOCATED(PROJT0)) DEALLOCATE (PROJT0)
       IF (ALLOCATED(PROJT1)) DEALLOCATE (PROJT1)
       IF (ALLOCATED(PROJT2)) DEALLOCATE (PROJT2)
       IF (ALLOCATED(PROJT3)) DEALLOCATE (PROJT3)
       IF (ALLOCATED(PROJT4)) DEALLOCATE (PROJT4)
@


1.48
log
@fbs2 rename
@
text
@d17 1
d239 1
a239 1
        CALL REDPRCG(N,NANG,CB,ANG,ILIST,ICUBE,NN,DM,RI,PANG,
d251 1
a251 1
           CALL REPRCG3_FBS(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG,RI,
d256 1
a256 1
           CALL REPRCG3_Q(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG,RI,
d273 1
a273 1
           CALL REDPRCG(N,NANG1,CB,ANG,ILIST1,ICUBE,NN,DM,RI,PANG,
d283 1
a283 1
           CALL REPRCG3_Q(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG1,RI,
d296 1
a296 1
           CALL REDPRCG(N,NANG2,CB,ANG,ILIST2,ICUBE,NN,DM,RI,PANG,
d306 1
a306 1
           CALL REPRCG3_Q(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG2,RI,
d335 1
a335 1
C **********************************************************************
d337 1
a337 1
C  REDPRCG
d343 1
a343 2
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************
d345 1
a345 1
        SUBROUTINE REDPRCG(N,NANG,CB,ANG,ILIST,IPCUBE,NN,DM,RI,ANGBUF,
d379 1
a379 1
           CALL ERRT(46,' REDPRCG; PSIZE & NBASE.',2*NPROCS)
d420 1
a420 1
           CALL ERRT(46,'REDPRCG; PRJBUF, PRJLOC..',MWANT)
d459 1
a459 1
                 CALL SEND_MPI('REDPRCG','PRJBUF', PRJBUF, N*N*NLOC, 
d466 1
a466 1
                 CALL RECV_MPI('REDPRCG','PRJLOC', PRJLOC, N*N*NLOC, 
d643 1
a643 2
C++*********************************************************************
C--*********************************************************************
d645 1
a645 1
        SUBROUTINE REPRCG3_Q(CB,BCKN,LSD,N,IPCUBE,NN,DM,LB,NANG,RI,
d678 1
a678 1
           CALL ERRT(46,'REPRCG3_Q; NBASE,...',MWANT)
d700 1
a700 1
           CALL ERRT(46,'REPRCG3_Q; BCKE,BCKP',MWANT)
d734 1
a734 1
           CALL ERRT(46,'REPRCG3_Q; DMLOC',MWANT)
d749 1
a749 1
              CALL SEND_MPI('REPRCG3_Q','DM', DM(1,IBEGIN), 9*NLOC, 
d752 1
a752 1
              CALL SEND_MPI('REPRCG3_Q','LB', LB(IBEGIN), NLOC, 
d765 1
a765 1
           CALL RECV_MPI('REPRCG3_Q','DMLOC', DMLOC, 9*NANGLOC, 'R',
d768 1
a768 1
           CALL RECV_MPI('REPRCG3_Q','LBLOC', LBLOC, NANGLOC, 'I',
d775 1
a775 1
        write(6,*)' reprcg3_q: data distributed, mypid:',mypid
d856 1
a856 1
           CALL ALLREDUCE_MPI('REPRCG3_Q','BCKE_SUM',BCKE,BCKE_SUM,
d1065 1
a1065 1
C       --------------------- ASTASQ -------------------------------
d1095 1
a1095 2
C++*********************************************************************
C--*********************************************************************
d1169 1
a1169 2
C++*********************************************************************
C--*********************************************************************
d1250 1
a1250 2
C++*********************************************************************
C--*********************************************************************
d1339 1
a1339 2
C++*********************************************************************
C--*********************************************************************
d1358 1
a1358 2
C++*********************************************************************
C--*********************************************************************
d1365 1
a1365 1
c$omp parallel do private(kn,j,k,i)
d1382 1
a1382 2
C++*********************************************************************
C--*********************************************************************
a1448 1
C++*********************************************************************
d1450 3
a1452 1
        SUBROUTINE REPRCG3_FBS(CB,BCKN,LSD,N,IPCUBE,NN,DM,LB,NANG,RI,
d1509 1
a1509 1
           CALL ERRT(46,'REPRCG3_FBS; PROJT0,...',MWANT)
d1534 1
a1534 1
           CALL ERRT(46,'REPRCG3_FBS; BCKE,BCKP',MWANT)
d1721 5
a1725 7
           IF (VERBOSE) THEN
C            SKIP THIS IF NOT VERBOSE
             WRITE(NOUT,2041) ITER,ERR,CHI2
2041         FORMAT('  ITERATION: 'I3,
     &              '   DIFFERENCE:',1PE12.4,
     &              '   CHISQ:',1PE12.4)
           ENDIF
@


1.47
log
@FBS_PREP now FBS2_PREP
@
text
@d39 1
a39 1
C                                                                      *
d41 1
a41 1
C                                                                      *
d50 1
a50 1
C                                                                      *
d52 1
a52 1
C                                                                      *
d173 1
a173 1
        CALL PREPCUB_S_N(N,NN,IDUM,RI,MD,LDP)  ! RETURNS: NN
d195 1
a195 1
        CALL PREPCUB_S_N(N,NN,ICUBE,RI,MD,LDP)   ! RETURNS ICUBE
a260 1

d1038 4
a1041 7
           IF (VERBOSE) THEN
C            SKIP THIS IF NOT VERBOSE
             WRITE(NOUT,2041) ITER,ERR,CHI2
2041         FORMAT('  ITERATION: 'I3,
     &              '   DIFFERENCE:',1PE12.4,
     &              '   CHISQ:',1PE12.4)
           ENDIF
a1044 2
C             WRITE FINAL ERROR 
              IF (.NOT. VERBOSE)  WRITE(NOUT,2041) ITER,ERR,CHI2
a1063 1
C++*********************************************************************
a1064 3
        SUBROUTINE REPRCG3_FBS(CB,BCKN,LSD,N,IPCUBE,NN,DM,LB,NANG,RI,
     &                       NUMTH,BNORM,CHI2,
     &                       ERRM,CHIM,MAXIT,MODE,ALA, LDP,LDPNM,IRTFLG)
d1066 1
a1066 2
C       NUMTH = NUMTHREADS() FOR MP, OTHERWISE=1.
C          ( MP - MULTIPLE PROCESSING )
d1068 1
a1068 1
        INCLUDE 'CMBLOCK.INC'
d1070 2
a1071 12
        REAL               :: CB(N,N,N),BCKN(N,N,N)
        INTEGER            :: LSD,N,NN
        INTEGER            :: IPCUBE(5,NN)
        REAL               :: DM(9,NANG)           
        INTEGER            :: LB(NANG)
        INTEGER            :: NANG
        REAL               :: RI
        INTEGER            :: NUMTH
        REAL               :: BNORM,CHI2,ERRM,CHIM
        INTEGER            :: MAXIT,MODE
        REAL               :: ALA
        INTEGER            :: LDP,LDPNM,IRTFLG
d1073 2
a1074 3
        INTEGER            :: KN, ICYCLE
        REAL               :: DELSQ
        REAL               :: PROJ(N*N,NUMTH)
d1076 2
a1077 10
        REAL, ALLOCATABLE  :: BCKE_SUM(:,:,:)
        REAL, ALLOCATABLE  :: BCKE   (:,:,:)
        REAL, ALLOCATABLE  :: BCKP   (:,:,:)
        REAL, ALLOCATABLE  :: BCKP0  (:,:,:)
        REAL, ALLOCATABLE  :: X1  (:,:,:)
        REAL, ALLOCATABLE  :: Y1  (:,:,:)
        REAL, ALLOCATABLE  :: Z1  (:,:,:)
        REAL, ALLOCATABLE  :: XY2 (:,:,:)
        REAL, ALLOCATABLE  :: XZ2 (:,:,:)
        REAL, ALLOCATABLE  :: YZ2 (:,:,:)
d1079 16
a1094 5
        REAL, ALLOCATABLE  :: PROJT0(:,:)        ! 2D DATA ARRAY
        REAL, ALLOCATABLE  :: PROJT1(:,:)        ! 2D DATA ARRAY
        REAL, ALLOCATABLE  :: PROJT2(:,:)        ! X-DERIVATIVE OF DATA
        REAL, ALLOCATABLE  :: PROJT3(:,:)        ! Y-DERIVATIVE OF DATA
        REAL, ALLOCATABLE  :: PROJT4(:,:)        ! XY-DERIVATIVE OF DATA
d1096 2
a1097 1
        ICYCLE = 1
d1099 1
a1099 2
        MYPID  = -1
        NXLD   = N + 2 - MOD(N,2)
d1101 2
a1102 6
        ALLOCATE(PROJT0  (0:N-1,    0:N-1),
     &           PROJT1  (0:NXLD-1, 0:N-1),
     &           PROJT2  (0:NXLD-1, 0:N-1),
     &           PROJT3  (0:NXLD-1, 0:N-1),
     &           PROJT4  (0:NXLD-1, 0:N-1),
     &                  STAT=IRTFLG)
d1104 11
a1114 5
        IF (IRTFLG .NE. 0) THEN
           MWANT = N*N + 4* NXLD*N
           CALL ERRT(46,'REPRCG3_FBS; PROJT0,...',MWANT)
           GOTO 9999
        ENDIF
d1116 3
a1118 29
        DI = N / 2
        IF (MODE .EQ. 1 .AND. RI+1.0 .GT. DI  .OR. 
     &      MODE .EQ. 2 .AND. RI+2.0 .GT. DI  .OR.
     &      MODE .EQ. 3 .AND. RI+3.0 .GT. DI)  THEN
           CALL ERRT(101,'RADIUS TOO LARGE',NE)
           GOTO 9999
        ENDIF   

        ALLOCATE (BCKE(N,N,N), 
     &            BCKP(N, N, N),
     &            BCKP0 (NXLD, N, N),
     &            X1  (NXLD, N, N),
     &            Y1  (NXLD, N, N),
     &            Z1  (NXLD, N, N),
     &            XY2 (NXLD, N, N),
     &            XZ2 (NXLD, N, N),
     &            YZ2 (NXLD, N, N),
     &            STAT=IRTFLG)

        IF (IRTFLG.NE.0) THEN 
           MWANT = 2 * N*N*N
           CALL ERRT(46,'REPRCG3_FBS; BCKE,BCKP',MWANT)
           GOTO 9999
        ENDIF

        NMAT = N*N*N
        LTB  = N*N
c$omp   parallel do private(k,j,i)
        DO K=1,N
d1120 5
a1124 6
              DO I=1,N
                 BCKN(I,J,K)     = 0.0
                 BCKP(I,J,K)     = 0.0
#ifdef USE_MPI
                 BCKE_SUM(I,J,K) = 0.0
#endif
a1125 2
           ENDDO
        ENDDO
d1127 5
a1131 13
        ERR  = 1.0
        ITER = 0
        Q    = 0.0

        DO  ITER=1,MAXIT

           DELSQ = 0.0
c$omp      parallel do private(kn,j,k,i),reduction(+:DELSQ)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 DELSQ = DELSQ+CB(I,J,K)*CB(I,J,K)
d1134 8
a1141 8
           Q = Q * DELSQ

c$omp      parallel do private(kn,j,k,i)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 BCKP(I,J,K) = CB(I,J,K) - Q * BCKP(I,J,K)
a1142 2
           ENDDO
           Q = -1.0 / DELSQ
d1144 5
a1148 6
c$omp      parallel do private(k,j,i)
           DO K=1,N
              DO J=1,N
                 DO I=1,N
                    BCKE(I,J,K) = 0.0
                 ENDDO
d1151 8
a1158 10

C          BCKP -> PROJ -> BCKE
C          LOOP OVER PROJECTIONS

c$omp      parallel do private(k,j,i)
           DO K=1,N
              DO J=1,N
                 DO I = N+1,NXLD
                    BCKP0(I,J,K) = 0
                 ENDDO
a1159 1
           ENDDO
d1161 5
a1165 6
c$omp      parallel do private(k,j,i)
           DO K=1,N
              DO J=1,N
                 DO I=1,N
              BCKP0(I,J,K) = BCKP(I,J,K)
                 ENDDO
d1168 2
d1171 2
a1172 3
C          CALCULATION OF PROJECTIONS DERIVATIVES USING 3D FFT
           CALL FBS3_PREP(BCKP0, NXLD, N, N, N,
     &                  X1, Y1, Z1, XY2, XZ2, YZ2)
d1174 1
a1174 2
           !WRITE(6,*), 'Iteration cycle #', ICYCLE
           ICYCLE= ICYCLE + 1
d1176 2
a1177 3
           DO K=1,NANG,NUMTH
              L_EN  = MIN(NANG,K+NUMTH-1)
              L_NUM = MIN(NUMTH,NANG-K+1)
d1179 1
a1179 6
c$omp         parallel do private(i,j)
              DO J=1,L_NUM
                 DO I=1,LTB
                    PROJ(I,J) = 0.0
                 ENDDO
              ENDDO
d1181 5
a1185 250
c$omp         parallel do private(l_th),schedule(static)
              DO  L_TH=1,L_NUM

C                PROJECTS BCKP INTO PROJ  (FROM VOLUME TO PLANE)

                 CALL PRJCQ_FBS3(BCKP,DM(1,K+L_TH-1),
     &                PROJ(1,L_TH),N,NXLD,  BCKP0,
     &                X1, Y1, Z1,
     &                XY2,XZ2,YZ2)
              ENDDO

C             HERE BCKCQ ITSELF IS MP  (MULTIPLE PROCESSING)
              DO  L_TH=1,L_NUM
C                MULTIPLY PROJECTIONS BY THEIR WEIGHTS
                 IF (LB(K+L_TH-1) .GT. 1)  THEN
c$omp               parallel do private(i)
                    DO  I=1,N*N
                       PROJ(I,L_TH) = PROJ(I,L_TH)*LB(K+L_TH-1)
                    ENDDO
                 ENDIF

c$omp            parallel do private(i,i2,j2)
                 DO I = 1,N*N
                    I2 = MOD(I-1,N)
                    J2 = INT((I-1)/N)
                    PROJT0(I2, J2) = PROJ(I, L_TH)
                 ENDDO

                 DO J = 0,N-1
                    DO I = N,NXLD-1
                       PROJT1(I,J) = 0
                    ENDDO
                 ENDDO

                 DO J = 0,N-1
                    DO I = 0,N-1
                       PROJT1(I,J) = PROJT0(I,J)
                    ENDDO
                 ENDDO

C                CALCULATION OF PROJECTIONS DERIVATIVES USING 2D FFT

                 CALL FBS2_PREP(PROJT1, PROJT2,PROJT3, PROJT4, 
     &                NXLD, N,N, IRTFLG)

C                BACKPROJECTION  (FROM PLANE TO VOLUME)
                 CALL BCKCQ_FBS(BCKE,NMAT,DM(1,K+L_TH-1),
     &                  PROJT0,PROJT2,PROJT3,PROJT4,
     &                  N,IPCUBE,NN, LDP,LDPNM)
              ENDDO
           ENDDO

           IF (MODE .EQ. 1) THEN
              CALL FIXEDGE1(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
              CALL BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN)

           ELSEIF(MODE .EQ. 2) THEN
              CALL FIXEDGE2(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
              CALL BSECOND(BCKE,BCKP,N,ALA,IPCUBE,NN)

           ELSEIF (MODE .EQ. 3) THEN
              CALL FIXEDGE3(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
              CALL BTHIRD(BCKE,BCKP,N,ALA,IPCUBE,NN)
           ENDIF

           AKDEN = 0.0

c$omp      parallel do private(kn,j,k,i),reduction(+:akden)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),
     &             IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 AKDEN = AKDEN + BCKP(I,J,K) * BCKE(I,J,K)
              ENDDO
           ENDDO
           P = DELSQ / AKDEN

c$omp      parallel do private(kn,j,k,i)
           DO KN=1,NN
              J = IPCUBE(4,KN)
              K = IPCUBE(5,KN)
              DO I=IPCUBE(3,KN),
     &           IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)

                 BCKN(I,J,K) = BCKN(I,J,K)+P*BCKP(I,J,K)
                 CB(I,J,K)   = CB(I,J,K)-P*BCKE(I,J,K)
              ENDDO
           ENDDO

           ERR  = DELSQ / BNORM
           CHI2 = CHI2 - P * DELSQ

           IF (VERBOSE) THEN
C            SKIP THIS IF NOT VERBOSE
             WRITE(NOUT,2041) ITER,ERR,CHI2
2041         FORMAT('  ITERATION: 'I3,
     &              '   DIFFERENCE:',1PE12.4,
     &              '   CHISQ:',1PE12.4)
           ENDIF

C          CHECK STOPPING CRITERIA
           IF (ABS(ERR) .LE. ERRM .OR. 
     &         ABS(CHI2) .LE. CHIM) THEN  
C             WRITE FINAL ERROR 
              IF (.NOT. VERBOSE)  WRITE(NOUT,2041) ITER,ERR,CHI2
              WRITE(NOUT,*) '  '  
              GOTO 9999            
           ENDIF
       ENDDO

9999   IF (ALLOCATED(BCKE))   DEALLOCATE (BCKE)
       IF (ALLOCATED(BCKP))   DEALLOCATE (BCKP)
       IF (ALLOCATED(BCKP0))  DEALLOCATE (BCKP0)
       IF (ALLOCATED(X1))     DEALLOCATE (X1)
       IF (ALLOCATED(Y1))     DEALLOCATE (Y1)
       IF (ALLOCATED(Z1))     DEALLOCATE (Z1)
       IF (ALLOCATED(XY2))    DEALLOCATE (XY2)
       IF (ALLOCATED(XZ2))    DEALLOCATE (XZ2)
       IF (ALLOCATED(YZ2))    DEALLOCATE (YZ2)
       IF (ALLOCATED(PROJT0)) DEALLOCATE (PROJT0)
       IF (ALLOCATED(PROJT1)) DEALLOCATE (PROJT1)
       IF (ALLOCATED(PROJT2)) DEALLOCATE (PROJT2)
       IF (ALLOCATED(PROJT3)) DEALLOCATE (PROJT3)
       IF (ALLOCATED(PROJT4)) DEALLOCATE (PROJT4)

       END

C++*********************************************************************

C       --------------------- ASTASQ -------------------------------

        SUBROUTINE  ASTASQ(X,N,RI,ABA,KLP,SUS,SSQ,KLS)

        REAL              :: X(N,N)
        DOUBLE PRECISION  :: ABA,SUS,SSQ

C       ESTIMATE AVERAGE OUTSIDE THE CIRCLE. 
C       RETURNS: ABA,KLP,SUS,SSQ,KLS

        R  = RI*RI
        NC = N/2+1

        DO J=1,N
           T  = J-NC
           XX = T*T
           DO I=1,N
              T=I-NC
              IF (XX + T * T .GT. R)    THEN
                 ABA = ABA + DBLE(X(I,J))
                 KLP = KLP + 1
              ELSE
                 SSQ = SSQ + X(I,J) * DBLE(X(I,J))
                 SUS = SUS + X(I,J)
                 KLS = KLS + 1
              ENDIF
           ENDDO
        ENDDO
        END

C++*********************************************************************
C--*********************************************************************

        SUBROUTINE  FIXEDGE1(BCKP,NMAT,BCK3,N,IPCUBE,NN)

        REAL    :: BCKP(NMAT),BCK3(N,N,N) 
        INTEGER :: IPCUBE(5,NN)

C       PUT ZEROS OUTSIDE
        NT = 1
        DO I=1,NMAT
           IF (NT .GT. NN)  THEN
              BCKP(I) = 0.0
           ELSEIF (I .LT. IPCUBE(1,NT))  THEN
              BCKP(I)= 0.0
           ELSEIF(I .EQ. IPCUBE(2,NT))  THEN
              NT = NT+1
           ENDIF
        ENDDO

C       ADD PIXELS ON THE EDGE
C       FIX THE EDGES IN BCKP
        DO  K=1,N
           DO J=1,N
              DO  I=1,N-1
                 IF (BCK3(I+1,J,K) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I+1,J,K)
                    EXIT
                 ENDIF
              ENDDO

              DO  I=N,2,-1
                 IF (BCK3(I-1,J,K) .NE. 0.0) THEN
                    BCK3(I,J,K) =BCK3(I-1,J,K)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        DO  K=1,N
           DO I=1,N
              DO  J=1,N-1
                 IF (BCK3(I,J+1,K) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I,J+1,K)
                    EXIT
                 ENDIF
              ENDDO

              DO  J=N,2,-1
                 IF (BCK3(I,J-1,K) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I,J-1,K)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        DO  J=1,N
           DO I=1,N
              DO  K=1,N-1
                 IF (BCK3(I,J,K+1) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I,J,K+1)
                    EXIT
                 ENDIF
              ENDDO

              DO  K=N,2,-1
                 IF (BCK3(I,J,K-1) .NE. 0.0) THEN
                    BCK3(I,J,K) = BCK3(I,J,K-1)
                    EXIT
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        END

C++*********************************************************************
C--*********************************************************************

        SUBROUTINE  FIXEDGE2(BCKP,NMAT,BCK3,N,IPCUBE,NN)

        REAL    :: BCKP(NMAT),BCK3(N,N,N)
        INTEGER :: IPCUBE(5,NN)

C      PUT ZEROS OUTSIDE

        NT = 1
        DO    I=1,NMAT
           IF (NT .GT. NN)  THEN
              BCKP(I) = 0.0
           ELSEIF (I .LT. IPCUBE(1,NT))  THEN
d1455 306
@


1.46
log
@added nxld to: PRJCQ_FBS3 parameters
@
text
@d2 16
a17 15
C
C  BPCG.F      CORRECTIONS APPLIED ON VOLUME SIDE 11/09/98
C              COMPRESSION OF ANGLES              08/14/96
C              USED PROJT FOR BCKCQ CALL          FEB 2000 ARDEAN LEITH
C              OPFILEC                            FEB 2003 ARDEAN LEITH
C              VERBOSE                            FEB 2006 ARDEAN LEITH
C              MPI BUG FIXED                      OCT 2008 ARDEAN LEITH
C              REFACTORED                         OCT 2008 ARDEAN LEITH
C              REFACTORED                         DEC 2010 ARDEAN LEITH
C              COMMON PAR REMOVED,                DEC 2010 ARDEAN LEITH *                                                                  *
C              THREE OUTPUTS                      JAN 2011 ARDEAN LEITH *                                                                  *
C              REPCG --> BPCG                     JAN 2011 ARDEAN LEITH *                                                                  *
C              MPI_RECV BUG                       APR 2011 ARDEAN LEITH *                                                                  *
C              FBS ADDED                          OCT 2011 G KISHCHENKO
C                                                                  *
d39 1
a39 1
C
d41 1
a41 1
C
d50 1
a50 1
C
d52 1
a52 1
C
d1288 1
a1288 1
C                CALCULATION OF PROJECTIONS DERIVATIVES SING 2D FFT
d1290 1
a1290 1
                 CALL FBS_PREP(PROJT1, PROJT2,PROJT3, PROJT4, 
@


1.45
log
@cosmetic
@
text
@d1253 3
a1255 4
     &              PROJ(1,L_TH),N,
     &              BCKP0,
     &              X1, Y1, Z1,
     &              XY2,XZ2,YZ2)
@


1.44
log
@gpk's additions
@
text
@a260 4




d1080 16
a1095 2
        INTEGER             :: IPCUBE(5,NN),LB(NANG)
        INTEGER             :: KN, ICYCLE
d1097 1
a1097 5
        REAL                :: ALA, DELSQ
        REAL                :: CB(N,N,N),BCKN(N,N,N)
        REAL                :: DM(9,NANG),PROJ(N*N,NUMTH)

        REAL,   ALLOCATABLE :: BCKE_SUM(:,:,:)
d1108 5
a1112 5
        REAL, ALLOCATABLE   :: PROJT0(:,:)          ! 2D DATA ARRAY
        REAL, ALLOCATABLE   :: PROJT1(:,:)          ! 2D DATA ARRAY
        REAL, ALLOCATABLE   :: PROJT2(:,:)          ! X-DERIVATIVE OF DATA
        REAL, ALLOCATABLE   :: PROJT3(:,:)          ! Y-DERIVATIVE OF DATA
        REAL, ALLOCATABLE   :: PROJT4(:,:)          ! XY-DERIVATIVE OF DATA
d1114 1
a1114 1
        ICYCLE=1
d1116 1
a1116 1
        MYPID = -1
d1142 8
a1149 8
     &             BCKP0 (NXLD, N, N),
     &             X1  (NXLD, N, N),
     &             Y1  (NXLD, N, N),
     &             Z1  (NXLD, N, N),
     &             XY2 (NXLD, N, N),
     &             XZ2 (NXLD, N, N),
     &             YZ2 (NXLD, N, N),
     &                    STAT=IRTFLG)
d1211 1
d1220 1
d1229 2
a1230 3
C                CALCULATION OF PROJECTIONS DERIVATIVES
C                       USING 3D FOURIER TRANSFORM
         CALL FBS3_PREP(BCKP0, NXLD, N, N, N,
d1233 2
a1234 2
        WRITE(6,*), 'Iteration cycle #', ICYCLE
        ICYCLE= ICYCLE + 1
d1247 1
a1247 1
c$omp      parallel do private(l_th),shared(nmat,n,nn),schedule(static)
a1256 1

d1269 1
a1269 1
c$omp            parallel do private(i,pt)
d1288 1
a1288 2
C                CALCULATION OF PROJECTIONS DERIVATIVES
C                       USING 2D FOURIER TRANSFORM
d1290 2
a1291 1
      CALL FBS_PREP(PROJT1, PROJT2,PROJT3, PROJT4, NXLD, N,N, IRTFLG)
a1296 1

d1332 1
d1359 9
a1367 9
9999       IF (ALLOCATED(BCKE))   DEALLOCATE (BCKE)
       IF (ALLOCATED(BCKP))       DEALLOCATE (BCKP)
       IF (ALLOCATED(BCKP0))      DEALLOCATE (BCKP0)
       IF (ALLOCATED(X1))         DEALLOCATE (X1)
       IF (ALLOCATED(Y1))         DEALLOCATE (Y1)
       IF (ALLOCATED(Z1))         DEALLOCATE (Z1)
       IF (ALLOCATED(XY2))        DEALLOCATE (XY2)
       IF (ALLOCATED(XZ2))        DEALLOCATE (XZ2)
       IF (ALLOCATED(YZ2))        DEALLOCATE (YZ2)
@


1.43
log
@PREPCUB_S(N,NN,ICUBE,RI,MD,LDP)
@
text
@d15 2
d172 1
a172 1
        CALL PREPCUB_S(N,NN,IDUM,RI,MD,LDP)     ! RETURNS: NN
d194 1
a194 1
        CALL PREPCUB_S(N,NN,ICUBE,RI,MD,LDP)   ! RETURNS: NN
d248 2
a249 1
        CALL REPRCG3_Q(CB,BCKN,LSD,N,ICUBE,NN,DM,LB,NANG,RI,
d252 6
d260 5
d1042 7
a1048 4
           WRITE(NOUT,2041) ITER,ERR,CHI2
2041       FORMAT('  ITERATION: 'I3,
     &            '  DIFFERENCE:',1PE12.4,
     &            '  CHISQ:',1PE12.4)
d1052 2
d1073 52
d1126 245
@


1.42
log
@PREPCUB_S_N --> PREPCUB
@
text
@d170 1
a170 2
        CALL PREPCUB(N,N,N,NN,IDUM,RI,MD,LDP,LDP,LDP) ! RETURNS: NN
        !CALL PREPCUB_S_N(N,NN,IDUM,RI,MD,LDP)  ! RETURNS: NN
d192 1
a192 2
        !CALL PREPCUB_S_N(N,NN,ICUBE,RI,MD,LDP)   ! RETURNS ICUBE
        CALL PREPCUB(N,N,N,NN,IDUM,RI,MD,LDP,LDP,LDP) ! RETURNS: NN
@


1.41
log
@says difference on each iter now (like old)
@
text
@d170 2
a171 1
        CALL PREPCUB_S_N(N,NN,IDUM,RI,MD,LDP)  ! RETURNS: NN
d193 2
a194 1
        CALL PREPCUB_S_N(N,NN,ICUBE,RI,MD,LDP)   ! RETURNS ICUBE
@


1.40
log
@NILMAX  = NIMAXPLUS
@
text
@d1028 4
a1031 7
           IF (VERBOSE) THEN
C            SKIP THIS IF NOT VERBOSE
             WRITE(NOUT,2041) ITER,ERR,CHI2
2041         FORMAT('  ITERATION: 'I3,
     &              '   DIFFERENCE:',1PE12.4,
     &              '   CHISQ:',1PE12.4)
           ENDIF
a1034 2
C             WRITE FINAL ERROR 
              IF (.NOT. VERBOSE)  WRITE(NOUT,2041) ITER,ERR,CHI2
@


1.39
log
@mpi recv bug
@
text
@d61 1
a61 1
        REAL, ALLOCATABLE     :: ANG(:,:),DM(:,:)
d90 4
a93 4
        NILMAX  = NIMAX         ! FROM CMLIMIT
        ALLOCATE(ILIST1(NIMAX),
     &           ILIST2(NIMAX),
     &           ILIST(NIMAX),
d96 1
a96 1
           CALL ERRT(46,'BPCG; ILIST....',3*NIMAX)
@


1.38
log
@renamed from: repcg.f
@
text
@d14 1
d399 1
d435 7
a441 4
              DO K2=1,N
                 CALL  REDLIN1P(LUNPROJ,PRJBUF(1,K2,K),N,K2)
              ENDDO
              IF (MYPID .EQ. 0) CLOSE(LUNPROJ)
d447 2
d450 1
a450 1
     &                        'R',IPROC-1,IPROC-1, ICOMM)
d453 10
a462 7
                 CALL MPI_RECV(PRJLOC,  N*N*NLOC,    MPI_REAL,
     &                         0,       MPI_ANY_TAG, ICOMM,
     &                         MPISTAT, MPIERR)
                 IF (MPIERR .NE. 0) THEN
                    WRITE(6,*) 'REDPRCG: RECV FAILED'
                    STOP
                 ENDIF
d467 9
a475 1
           ENDIF 
d527 1
a527 1
        CALL ALLREDUCE_MPI('REPRCG3_Q','CB', CB_LOC,CB,
d529 1
a529 1
        CALL ALLREDUCE_MPI('REPRCG3_Q','ABA', ABA_LOC,ABA,
d531 1
a531 1
        CALL ALLREDUCE_MPI('REPRCG3_Q','KLP', KLP_LOC,KLP,
d533 1
a533 1
        CALL ALLREDUCE_MPI('REPRCG3_Q','SSQ', SSQ_LOC,SSQ,
d535 1
a535 1
        CALL ALLREDUCE_MPI('REPRCG3_Q','SUS', SUS_LOC,SUS,
d537 1
a537 1
        CALL ALLREDUCE_MPI('REPRCG3_Q','KLS', KLS_LOC,KLS,
d545 1
d674 1
d738 1
d740 5
a744 4
              CALL SEND_MPI('REPRCG3_Q','DM', DM(1,IBEGIN), 9*NANGLOC, 
     &                        'R',IP-1,IDMTAG,ICOMM)
              CALL SEND_MPI('REPRCG3_Q','LB', LB(IBEGIN), NANGLOC, 
     &                        'I',IP-1,LBTAG,ICOMM)
d747 2
d755 8
a762 4
           CALL MPI_RECV(DMLOC,  9*NANGLOC, MPI_REAL,    MASTER,
     &                   IDMTAG, ICOMM,     MPISTAT,     IERR)
           CALL MPI_RECV(LBLOC,  NANGLOC,   MPI_INTEGER, MASTER,
     &                   LBTAG,  ICOMM,     MPISTAT,     IERR)
d766 1
a766 1
c        write(6,*)' reprcg3_q: data distributed, mypid:',mypid
@


1.37
log
@allocate nimax arrays
@
text
@d3 1
a3 1
C  REPCG.F     CORRECTIONS APPLIED ON VOLUME SIDE 11/09/98
d13 1
d36 1
a36 1
C  REPCG
d52 1
a52 1
        SUBROUTINE REPCG
d95 1
a95 1
           CALL ERRT(46,'REPCG; ILIST....',3*NIMAX)
d186 1
a186 1
           CALL ERRT(46,'REPCG, ICUBE...',MWANT)
@


1.36
log
@cosmetic output
@
text
@d65 2
a66 3
        INTEGER               :: ILIST(NIMAX)
        INTEGER               :: ILIST1(NIMAX),ILIST2(NIMAX)

d89 9
d310 3
@


1.35
log
@OPERATION DOES NOT WORK ON WHOLE STACKS.
@
text
@d221 2
a222 2
        WRITE(NOUT,92)' CREATING VOLUME -------------------------------'
92      FORMAT(/,A,/)
a245 1
           WRITE(NOUT,*) ' '
a268 1
           WRITE(NOUT,*) ' '
a272 1

@


1.34
log
@refactored, rewritten, added 'BP CG 3'
@
text
@d98 5
@


1.33
log
@GPL_2010
@
text
@d6 7
a12 4
C              OPFILEC                            FEB   03 ARDEAN LEITH
C              VERBOSE                            FEB   06 ARDEAN LEITH
C              MPI BUG FIXED                      OCT   08 ARDEAN LEITH
C              REFACTORED                         OCT   08 ARDEAN LEITH
d17 1
a17 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d42 1
a42 1
C            CONSTRAINTS. AVERAGE OUTSIDE WINDOW IS SUBTRACTED
d44 3
d57 24
a80 16
        REAL, DIMENSION(:,:), POINTER        :: PANG
        REAL, ALLOCATABLE, DIMENSION(:,:,:)  :: CB
        REAL, ALLOCATABLE, DIMENSION(:,:)    :: ANG,DM
        REAL, ALLOCATABLE, DIMENSION(:)      :: BCKN

        INTEGER, ALLOCATABLE, DIMENSION(:,:) :: QM
        INTEGER, ALLOCATABLE, DIMENSION(:)   :: ILIST,LB

        LOGICAL                              :: MD 
        CHARACTER(LEN=MAXNAM)                :: ANGDOC,FILNAM,FINPAT
        CHARACTER(LEN=1)                     :: NULL,ANS

        COMMON /PAR/      LDP,NM,LDPNM

        DATA  INPIC/99/
        DATA  INPROJ/98/,LUNUNK/77/
d82 1
a82 9
#ifdef USE_MPI
        include 'mpif.h'
        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
        MYPID = -1
#endif
        NULL   = CHAR(0)
        NILMAX = NIMAX
d84 1
a84 2
C       N - LINEAR DIMENSION OF PROJECTIONS AND RESTORED CUBE
C       NANG - NUMBER OF ANGLES (PROJECTIONS)
d86 11
a96 12
        ALLOCATE (ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'REPCG, ILIST',NILMAX)
           RETURN
        ENDIF

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(27,'REPCG ',NE)
           GOTO 9999
        ENDIF  
d101 21
a121 2
        IF (MYPID .LE. 0) WRITE(NOUT,2001) NANG
2001    FORMAT('  NUMBER OF IMAGES=',I6)
d123 6
a128 1
        CALL  RDPRM(RI,NOT_USED,'RADIUS OF RECONSTRUCTED OBJECT')
d133 2
a134 2
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,LUNUNK,.FALSE.,MAXXT,
     &                       MAXYT,PANG,IRTFLG)
d136 1
a136 1
           CALL ERRT(4,'REPCG ',NE)
d138 1
a138 1
        ENDIF       
d140 33
a172 4
C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FILNAM,NLET,ILIST(1),IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'REPCG ',NE)
d176 4
d181 11
a191 17
        CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &               MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999

        N     = NSAM
        M     = N
        NM    = (N-M) / 2
        LDP   = M / 2 + 1
        LDPNM = LDP + NM

        CALL RDPRMC (ANS, NLETI, .TRUE.,
     &    'DOES YOUR VOLUME HAVE SYMMETRIES? (NOT IMPLEMENTED) (Y/N)',
     &    NULL,IRT)
        IF (ANS .EQ. 'Y')  THEN
           CALL ERRT(101,'*** SYMMETRIES OPTION NOT IMPLEMENTED',NE)
           GOTO 9999
        ENDIF
d193 4
a196 4
C       DUM IS A DUMMY VARIABLE, VALUE OF NN IS DETERMINED
        
        MD = .FALSE.
        CALL  PREPCUB_S(N,NN,DUM,RI,MD)
d198 2
a199 5
C       USE NN TO ALLOCATE (QM) 
        ALLOCATE (QM(5,NN), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'REPS, QM',5*NN)
           GOTO 9999
d202 2
a203 2
        MD = .TRUE.
        CALL  PREPCUB_S(N,NN,QM,RI,MD)
d205 2
a206 4
        NMAT = N*N*N
        LSD  = N+2-MOD(N,2)
C       IN THIS VERSION TOTAL MEMORY IS THREE VOLUMES BCKN, BCKE AND CUBE
C       PLUS 2 2D PROJECTIONS.
d208 2
a209 3
C       CUBE - KEEPS BACK-PROJECTED ORIGINAL PROJECTIONS, READ FROM THE DISK
C       BCKE - WORKING VOLUME
C       BCKN - CURRENT RECONSTRUCTION
d214 9
a222 4
        MAXIM = 0
        IFORM = 3
        CALL OPFILEC(0,.TRUE.,FILNAM,INPIC,'U',IFORM,M,M,M,
     &             MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
d225 10
a234 8
        ALLOCATE(CB(N,N,N), 
     &           ANG(3,NANG),
     &           DM(9,NANG),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'REPCG, CB, ANG & DM',IER)
           GOTO 9999
        ENDIF
d236 2
a237 2
        CALL REDPRCG(N,NANG,CB,ANG,ILIST,QM,NN,DM,RI,PANG,
     &               FINPAT,BNORM,CHI2)
d239 1
a239 1
C       COMPRESS ANGLES - IT CHANGES NANG !!
d241 46
a286 5
        ALLOCATE (LB(NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'REPCG, LB',IER)
           GOTO 9999
        ENDIF
d288 2
a289 5
C       CONVERTS ANGLES TO 'DM' FORMAT?
        CALL HIANG(ANG,NANG,DM,LB,LO)
        NANG = LO
        IF (MYPID .LE. 0) WRITE(NOUT,2027) NANG
2027    FORMAT('  EFFECTIVE NUMBER OF ANGLES: ',I6)
a290 4
        ALLOCATE(BCKN(N*N*N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'REPCG, BCKN',N*N*N)
           GOTO 9999
d293 6
a298 14
        CALL REPRCG3_Q(CB,BCKN,LSD,N,QM,NN,DM,LB,NANG,RI,
     &                 NUMTH,BNORM,CHI2)

        DO K=1,M*M
           MI = (K-1)*M
           CALL WRTLIN(INPIC,BCKN(1+MI),M,K)
        ENDDO

9999    IF (ALLOCATED(BCKN)) DEALLOCATE(BCKN)
        IF (ALLOCATED(LB))   DEALLOCATE(LB)
        IF (ALLOCATED(DM))   DEALLOCATE(DM)
        IF (ALLOCATED(ANG))  DEALLOCATE(ANG)
        IF (ALLOCATED(CB))   DEALLOCATE(CB)
        IF (ALLOCATED(QM))   DEALLOCATE(QM)
a299 1
        IF (ALLOCATED(ILIST))DEALLOCATE(ILIST)
d301 4
a304 1
        CLOSE(INPIC) 
d308 10
a317 1
C++*********************************************************************
d321 2
a322 1
     &                     FINPAT,BNORM,CHI2)
d334 1
a335 1
        DATA  INPROJ/98/
d339 7
a345 5
        REAL, ALLOCATABLE, DIMENSION(:,:,:) :: CB_LOC, PRJBUF, PRJLOC
        REAL, ALLOCATABLE, DIMENSION(:,:)   :: ANG_LOC
        INTEGER, ALLOCATABLE, DIMENSION(:)  :: PSIZE
        INTEGER, ALLOCATABLE, DIMENSION(:)  :: NBASE
        DOUBLE PRECISION                    :: ABA_LOC,SUS_LOC,SSQ_LOC
a346 1
        INTEGER                             :: MPISTAT(MPI_STATUS_SIZE)
d351 2
a352 1
        ALLOCATE(PSIZE(NPROCS),NBASE(NPROCS), STAT=IRTFLG)
d354 1
a354 1
           CALL ERRT(46,' REPRCG3_Q, PSIZE & NBASE.',2*NPROCS)
d377 1
a377 1

d394 2
a395 2
           CALL ERRT(46,'REPRCG3_Q, PRJBUF, PRJLOC..',MWANT)
           RETURN
d414 1
a414 1
              CALL OPFILEC(0,.FALSE.,FILNAM,INPROJ,'O',IFORM,
d420 1
a420 1
                 CALL  REDLIN1P(INPROJ,PRJBUF(1,K2,K),N,K2)
d422 1
a422 1
              IF (MYPID .EQ. 0) CLOSE(INPROJ)
d467 3
a469 2
           CALL RPRQ(N,PRJLOC(1,1,K),CB_LOC,IPCUBE,NN,
     &           ANG_LOC(1,K),ANG_LOC(2,K),ANG_LOC(3,K),DM(1,KGLB),RI)
d513 1
a513 1
C       --------------- END OF MPI CODE ------------------------------
d515 5
a519 13
        DO K=1,NANG
           NLET = 0
           CALL FILGET(FINPAT,FILNAM,NLET,ILIST(K),IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FILNAM,INPROJ,'O',IFORM,
     &                  LSAM,LROW,NSL,
     &                  MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           DO K2=1,N
              CALL REDLIN(INPROJ,PROJ(1,K2),N,K2)
a520 1
           CLOSE(INPROJ)
d522 1
d531 1
d540 4
a543 2
3331          FORMAT(' PROJECTION #',I6,
     &            '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
d549 14
a562 3
C          BACKPROJECTION?
           CALL RPRQ(N,PROJ,CB,IPCUBE,NN,
     &           ANG(1,K),ANG(2,K),ANG(3,K),DM(1,K),RI)
d564 3
a567 11
C       --------------- END OF NON-MPI CODE -------------------------

        ABA = ABA / KLP

C       PRINT STATISTICS
        IF (MYPID .LE. 0) WRITE(NOUT,2044) KLP,ABA
2044    FORMAT
     &      ('   TOTAL NUMBER OF POINTS IN PROJECTIONS =',I10,
     &     /,'   AVERAGE OUTSIDE THE WINDOW            =',1PE10.3,/)

C       SUBTRACT AVERAGE AND WRITE TO THE FILE
d569 2
d578 1
a578 1
           DO I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
d580 1
a580 1
              BNORM = BNORM + CB(I,J,K) * CB(I,J,K)
d589 8
a596 3
        IF (MYPID .LE. 0) WRITE(NOUT,2045) BNORM,CHI2
2045    FORMAT ('  SQUARED BP =',1PE10.3,
     &        /,'  CHI2       =',1PE10.3,/)
d604 2
a605 1
     &                        NUMTH,BNORM,CHI2)
d607 1
a607 1
C       NUMTH - NUMTHREDS FOR MP; =NUMTHREADS() FOR MP, OTHERWISE=1.
d611 5
a615 7
        REAL                               :: CB(N,N,N),BCKN(N,N,N)
        REAL                               :: DM(9,NANG),PROJ(N*N,NUMTH)
        REAL                               :: PROJT(4,N*N)
        INTEGER                            :: IPCUBE(5,NN),LB(NANG)
        REAL,ALLOCATABLE, DIMENSION(:,:,:) :: BCKE,BCKP

        COMMON /PAR/  LDP,NM,LDPNM
d619 7
a625 7
        INTEGER                              :: MPISTAT(MPI_STATUS_SIZE)
        REAL                                 :: ALA, SQ, DELSQ
        INTEGER,ALLOCATABLE, DIMENSION(:)    :: PSIZE, NBASE
        INTEGER,ALLOCATABLE, DIMENSION(:)    :: LBLOC
        REAL,   ALLOCATABLE, DIMENSION(:,:)  :: DMLOC
        REAL,   ALLOCATABLE, DIMENSION(:,:,:):: BCKE_SUM
        REAL,   ALLOCATABLE, DIMENSION(:,:,:):: RESID
d631 3
a633 1
        ALLOCATE(PSIZE(NPROCS), NBASE(NPROCS), STAT=IRTFLG)
d635 2
a636 2
           MWANT = 2 * NPROCS
           CALL ERRT(46,'REPRCG3_Q, NBASE',MWANT)
a644 6
        CALL RDPRM2(ERRM,CHIM,NOT_USED,'ERROR LIMIT, CHI^2 LIMIT')

        CALL RDPRMI(MAXIT,MODE,NOT_USED,'ITERATION LIMIT, MODE')

        CALL RDPRM(ALA,NOT_USED,'LAMBDA')

d653 2
a654 1
        ALLOCATE (BCKE(N,N,N),BCKP(N,N,N), STAT=IRTFLG)
d656 2
a657 2
           MWANT = 2*N*N*N
           CALL ERRT(46,'REPRCG3_Q, BCKE,BCKP',MWANT)
a660 8
#ifdef USE_MPI
        ALLOCATE(BCKE_SUM(N,N,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           MWANT = N*N*N
           CALL ERRT(46,'REPRCG3_Q, BCKE_SUM',MWANT)
           GOTO 9999
        ENDIF
#endif
d691 2
a692 2
           CALL ERRT(46,'REPRCG3_Q, DMLOC',MWANT)
           GOTO 9999
d728 1
d776 2
a777 2
              CALL PRJCQ(BCKP,NMAT,DMLOC(1,K),
     &                   PROJ,N,IPCUBE,NN)
d800 2
a801 2
                 CALL BCKCQ(BCKE,NMAT,DMLOC(1,K+L_TH-1),
     &                       PROJT,N,IPCUBE,NN)
d853 2
a854 1
2041       FORMAT('  ITERATION:', I3,'  ERROR:',1PE12.4,
d865 1
d867 1
d874 1
a874 1
                 DELSQ=DELSQ+CB(I,J,K)*CB(I,J,K)
d912 1
a912 1
c$omp       parallel do private(l_th),shared(nmat,n,nn),schedule(static)
d914 3
a916 2
                 CALL PRJCQ(BCKP,NMAT,DM(1,K+L_TH-1),
     &                       PROJ(1,L_TH),N,IPCUBE,NN)
d940 2
a941 1
                 CALL BCKCQ(BCKE,NMAT,DM(1,K+L_TH-1),PROJT,N,IPCUBE,NN)
d989 3
a991 2
2041         FORMAT('  ITERATION: 'I3,' ERROR:',1PE12.4,'
     &                 CHISQ: ',1PE12.4)
d998 1
d1002 3
a1004 1
C       END OF: -------------- NON-MPI ----------------------------
d1023 5
a1027 2
        DIMENSION   X(N,N)
        DOUBLE PRECISION  ABA,SUS,SSQ
a1028 1
C       ESTIMATE AVERAGE OUTSIDE THE CIRCLE
d1031 1
d1054 2
a1055 1
        DIMENSION    BCKP(NMAT),BCK3(N,N,N),IPCUBE(5,NN)
a1056 1
C-------------------------------------------------------
a1057 1
C-------------------------------------------------------
d1129 2
a1130 1
        DIMENSION    BCKP(NMAT),BCK3(N,N,N),IPCUBE(5,NN)
a1131 1
C-------------------------------------------------------
d1133 1
a1133 1
C-------------------------------------------------------
d1211 3
a1213 1
        DIMENSION    BCKP(NMAT),BCK3(N,N,N),IPCUBE(5,NN)
a1214 1
C-------------------------------------------------------
d1216 1
a1216 1
C-------------------------------------------------------
d1233 4
a1236 4
                 IF(BCK3(I+1,J,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I+1,J,K)
                    BCK3(I-1,J,K)=BCK3(I+1,J,K)
                    BCK3(I-2,J,K)=BCK3(I+1,J,K)
d1242 4
a1245 4
                 IF(BCK3(I-1,J,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I-1,J,K)
                    BCK3(I+1,J,K)=BCK3(I-1,J,K)
                    BCK3(I+2,J,K)=BCK3(I-1,J,K)
d1255 4
a1258 4
                 IF(BCK3(I,J+1,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J+1,K)
                    BCK3(I,J-1,K)=BCK3(I,J+1,K)
                    BCK3(I,J-2,K)=BCK3(I,J+1,K)
d1264 4
a1267 4
                 IF(BCK3(I,J-1,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J-1,K)
                    BCK3(I,J+1,K)=BCK3(I,J-1,K)
                    BCK3(I,J+2,K)=BCK3(I,J-1,K)
d1276 4
a1279 4
                 IF(BCK3(I,J,K+1).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J,K+1)
                    BCK3(I,J,K-1)=BCK3(I,J,K+1)
                    BCK3(I,J,K-2)=BCK3(I,J,K+1)
d1285 4
a1288 4
                 IF(BCK3(I,J,K-1).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J,K-1)
                    BCK3(I,J,K+1)=BCK3(I,J,K-1)
                    BCK3(I,J,K+2)=BCK3(I,J,K-1)
d1301 2
a1302 1
        DIMENSION  BCKE(N,N,N),BCKP(N,N,N),IPCUBE(5,NN)
d1310 2
a1311 2
     &           +BCKP(I+1,J,K)+BCKP(I,J+1,K)+BCKP(I,J,K+1)
     &           +BCKP(I-1,J,K)+BCKP(I,J-1,K)+BCKP(I,J,K-1)))
d1321 2
a1322 1
        DIMENSION  BCKE(N,N,N),BCKP(N,N,N),ipcube(5,nn)
d1330 6
a1335 6
     &          -4.0*BCKP(I+1,J,K)+BCKP(I+2,J,K)
     &          -4.0*BCKP(I-1,J,K)+BCKP(I-2,J,K)
     &          -4.0*BCKP(I,J+1,K)+BCKP(I,J+2,K)
     &          -4.0*BCKP(I,J-1,K)+BCKP(I,J-2,K)
     &          -4.0*BCKP(I,J,K+1)+BCKP(I,J,K+2)
     &          -4.0*BCKP(I,J,K-1)+BCKP(I,J,K-2)
d1346 2
a1347 1
        DIMENSION  BCKE(N,N,N),BCKP(N,N,N),ipcube(5,nn)
d1355 6
a1360 6
     &          -15.0*BCKP(I+1,J,K)+6.0*BCKP(I+2,J,K)-BCKP(I+3,J,K)
     &          -15.0*BCKP(I-1,J,K)+6.0*BCKP(I-2,J,K)-BCKP(I-3,J,K)
     &          -15.0*BCKP(I,J+1,K)+6.0*BCKP(I,J+2,K)-BCKP(I,J+3,K)
     &          -15.0*BCKP(I,J-1,K)+6.0*BCKP(I,J-2,K)-BCKP(I,J-3,K)
     &          -15.0*BCKP(I,J,K+1)+6.0*BCKP(I,J,K+2)-BCKP(I,J,K+3)
     &          -15.0*BCKP(I,J,K-1)+6.0*BCKP(I,J,K-2)-BCKP(I,J,K-3)
d1364 43
@


1.32
log
@*** empty log message ***
@
text
@a10 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d12 5
a16 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d18 1
a18 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d23 1
a23 1
C=* This program is distributed in the hope that it will be useful,    *
d25 1
a25 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a26 1
C=*                                                                    *
d28 1
a28 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.31
log
@lununk not defined
@
text
@d221 1
a221 1
        IF (ALLOCATED(PANG)) DEALLOCATE(PANG)
@


1.30
log
@mpi bug fixed, refactored
@
text
@d70 1
d245 1
a245 1
        DATA  INPROJ/98/,LUNUNK/77/
a467 2
C       CLOSE DOCUMENT FILE
        IF (MYPID .LE. 0) CLOSE(LUNUNK)
@


1.29
log
@output cosmetics
@
text
@d3 7
a9 3
C  REPCG.F         USED PROJT FOR BCKCQ CALL      FEB 2000 ARDEAN LEITH
C                  OPFILEC                        FEB   03 ARDEAN LEITH
C                  VERBOSE                        FEB   06 ARDEAN LEITH
d12 1
a12 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d36 1
a36 6
C  REPROJECTIONS 3D, CONJUGATE GRADIENTS METHOD, 
C  RECONSTRUCTION KEPT IN THE SQUARE TO INTRODUCE OTHER CONSTRAINTS.
C  AVERAGE OUTSIDE THE WINDOW IS SUBTRACTED
C  SYMMETRIES IMPOSED ... - NOT YET!  INTERPOLATION CHANGED !
C  CORRECTIONS APPLIED ON THE VOLUME SIDE.      11/09/98
C  COMPRESSION OF ANGLES - 08/14/96
d38 7
a44 7
C  REPCG(MAXMEM)
C  REDPRCG
C  RPRQ(N,B,CUBE,IPCUBE,NN,PHI,THETA,PSI,DM,RI)
C  ASTASQ(X,N,RI,ABA,KLP)
C  PREPCUB_S(N,NN,IPCUBE,RI)
C  BCKCQ(CUBE,LTC,DM,B,N,IPCUBE,NN)
C  PRJCQ(CUBE,LTC,DM,B,N,IPCUBE,NN)
d55 4
a58 4
        REAL, DIMENSION(:,:), POINTER ::        PANG,PSYM
        REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  CB
        REAL, ALLOCATABLE, DIMENSION(:,:) ::    ANG,DM
        REAL, ALLOCATABLE, DIMENSION(:) ::      BCKN
d61 1
a61 1
        INTEGER, ALLOCATABLE, DIMENSION(:) ::   ILIST,LB
d63 3
a65 4
        LOGICAL           MD 
        COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
        CHARACTER*80      FINPIC,FINFO,FINPAT
        CHARACTER(LEN=MAXNAM)   ::  ANGDOC
a66 1
        CHARACTER*1       NULL,ANS
d68 1
d73 2
a74 4
        INTEGER  MYPID, COMM, MPIERR, J
C
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d78 1
a78 1
        NULL = CHAR(0)
d86 1
a86 1
           CALL ERRT(46,'REPCG, ILIST',IER)
d94 1
a94 2
           DEALLOCATE(ILIST)          
           RETURN
d99 1
d101 1
a101 2
2001    FORMAT('  NUMBER OF IMAGES =',I5)
C       NANG - TOTAL NUMBER OF IMAGES
d108 1
a108 1
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
a109 1
 
d112 1
a112 2
           DEALLOCATE (ILIST)
           RETURN
d116 1
a116 1
        CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),IRTFLG)
d119 1
a119 2
           DEALLOCATE (ILIST)
           RETURN
d123 1
a123 1
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
d125 1
a125 11
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ILIST)
           RETURN
        ENDIF

        N=NSAM
        M=N

        NM=(N-M)/2
        LDP=M/2+1
        LDPNM=LDP+NM
d127 5
d134 5
a138 26
     &     'DOES YOUR VOLUME HAVE SYMMETRIES? (Y/N)',NULL,IRT)
        IF (ANS.EQ.'Y')  THEN
           WRITE(NOUT,*)  '*** OPTION NOT IMPLEMENTED YET'
           DEALLOCATE(PANG)
           DEALLOCATE(ILIST)
           CLOSE(INPIC) 
           RETURN
        ENDIF

       NSYM = 0
       IF (ANS .EQ. 'Y')  THEN
           MAXXT = 0
           MAXYT = 0
           CALL GETDOCDAT('SYMMETRIES ANGLES DOC',.TRUE.,FINPIC,INPIC,
     &         .TRUE.,MAXXT,MAXYT,PSYM,IRTFLG)
           IF (IRTFLG.NE.0) THEN
              CALL ERRT(4,'REPCG ',NE)
              GOTO 9120
           ENDIF
           NSYM = MAXYT
           
           WRITE(NOUT,2021) NSYM
2021       FORMAT(/,' NUMBER OF SYMMETRIES:',I5,/)
        ELSE 
C          PSYM IS NOW A DUMMY POINTER
           PSYM => PANG
d149 2
a150 2
           CALL ERRT(46,'REPS, QM',IER)
           GOTO 9118
d155 3
a157 3
c       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        NMAT=N*N*N
        LSD=N+2-MOD(N,2)
d160 1
a160 1
C
d170 1
a170 1
        CALL OPFILEC(0,.TRUE.,FINPIC,INPIC,'U',IFORM,M,M,M,
d172 1
a172 1
        IF (IRTFLG .NE. 0) GOTO 9116
d174 5
a178 2
        ALLOCATE (CB(N,N,N), ANG(3,NANG),DM(9,NANG),STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
d180 1
a180 1
           GOTO 9116
d183 2
a184 1
        CALL REDPRCG(N,NANG,CB,ANG,ILIST,QM,NN,DM,RI,PANG)
d191 1
a191 1
           GOTO 9110
d194 3
a196 2
        CALL  HIANG(ANG,NANG,DM,LB,LO)
        NANG=LO
d200 1
a200 3
        NSYMT=MAX0(1,NSYM)

        ALLOCATE (BCKN(N*N*N), STAT=IRTFLG)
d202 2
a203 2
           CALL ERRT(46,'REPCG, BCKN',IER)
           GOTO 9108
d206 2
a207 2
        CALL  REPRCG3_Q(CB,BCKN,LSD,N,QM,NN,DM,LB,NANG,RI,
     &                  PSYM,NSYMT,NSYM,NUMTH)
d209 2
a210 2
        DO  K=1,M*M
           MI=(K-1)*M
d214 11
a224 10
        DEALLOCATE(BCKN)
9108    DEALLOCATE(LB)
9110    DEALLOCATE(DM)
9112    DEALLOCATE(ANG)
9114    DEALLOCATE(CB)
9116    DEALLOCATE(QM)
9118    IF (ANS.EQ.'Y') DEALLOCATE(PSYM) 
9120    DEALLOCATE(PANG)
        DEALLOCATE(ILIST)                
        CLOSE(INPIC)   
d230 278
a507 2
        SUBROUTINE  REPRCG3_Q(CB,BCKN,LSD,N,IPCUBE,NN,DM,LB,NANG,RI,
     &          SYM,NSYMT,NSYM,NUMTH)
d510 1
d513 5
a517 5
        DIMENSION   CB(N,N,N),BCKN(N,N,N)
        DIMENSION   SYM(3,NSYMT),DM(9,NANG),PROJ(N*N,NUMTH)
        DIMENSION   projt(4,n*n)
        DIMENSION   IPCUBE(5,NN),LB(NANG)
        REAL, ALLOCATABLE, DIMENSION(:,:,:) :: BCKE,BCKP
a518 1
        COMMON /NORMB/ BNORM,CHI2
d523 13
a535 14
        INTEGER MYPID, COMM, NPROCS, MPIERR, MPISTAT(MPI_STATUS_SIZE)
        INTEGER NANGLOC, IP, DMTAG, LBTAG, MASTER, N2, IZ, JZ
        REAL     ALA, SQ, DELSQ
        INTEGER, ALLOCATABLE, DIMENSION(:)    :: PSIZE, NBASE
        INTEGER, ALLOCATABLE, DIMENSION(:)    :: LBLOC
        REAL,    ALLOCATABLE, DIMENSION(:,:)  :: DMLOC
        REAL,    ALLOCATABLE, DIMENSION(:,:,:):: BCKE_SUM
        REAL,    ALLOCATABLE, DIMENSION(:,:,:):: RESID
C
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID , MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
C
        ALLOCATE(PSIZE(NPROCS), STAT=IRTFLG)
d537 4
a540 8
           WRITE(0,*) 'REPRCG3_Q: FAILED TO ALLOCATE PSIZE.'
           STOP
        END IF
        ALLOCATE(NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           WRITE(0,*) 'REPRCG3_Q: FAILED TO ALLOCATE NBASE.'
           STOP
        END IF
d543 2
d547 10
a556 7
        CALL  RDPRM2(ERRM,CHIM,NOT_USED,'ERROR LIMIT, CHI^2 LIMIT')
        CALL  RDPRMI(MAXIT,MODE,NOT_USED,'ITERATION LIMIT, MODE')
        CALL  RDPRM(ALA,NOT_USED,'LAMBDA')
        DI=N/2
        IF (MODE.EQ.1.AND.RI+1.0.GT.DI
     &          .OR. MODE.EQ.2.AND.RI+2.0.GT.DI
     &          .OR. MODE.EQ.3.AND.RI+3.0.GT.DI)  THEN
d558 1
a558 1
           RETURN
d561 1
a561 7
        ALLOCATE (BCKE(N,N,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'REPRCG3_Q, BCKE',IER)
           RETURN
        ENDIF

        ALLOCATE (BCKP(N,N,N), STAT=IRTFLG)
d563 3
a565 3
           CALL ERRT(46,'REPRCG3_Q, BCKP',IER)
           DEALLOCATE (BCKE)
           RETURN
d569 1
a569 1
        ALLOCATE (BCKE_SUM(N,N,N), STAT=IRTFLG)
d571 3
a573 2
           CALL ERRT(46,'REPRCG3_Q, BCKE_SUM',IER)
           RETURN
d577 2
a578 2
        NMAT=N*N*N
        LTB=N*N
d583 2
a584 4
C                X=0
                 BCKN(I,J,K)=0.0
C                CDEL=0
                 BCKP(I,J,K)=0.0
d586 1
a586 1
                 BCKE_sum(i,j,k) = 0.0
d592 3
a594 3
        ERR=1.0
        ITER=0
        Q=0.0
d596 1
d601 7
a607 9
        ALLOCATE(LBLOC(NANGLOC), STAT = IRTFLAG)
        IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'REPRCG3_Q, LBLOC',IER)
           RETURN
        ENDIF
        ALLOCATE(DMLOC(9, NANGLOC), STAT = IRTFLAG)
        IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'REPRCG3_Q, DMLOC',IER)
           RETURN
d610 4
a613 3
        DMTAG  = 1
        LBTAG  = 2
        MASTER = 0
a614 1

d619 7
a625 7
              CALL MPI_SEND(DM(1,IBEGIN), 9*PSIZE(IP), MPI_REAL,
     &                      IP-1        , DMTAG      , COMM    ,
     &                      IERR)
              CALL MPI_SEND(LB(IBEGIN)  , PSIZE(IP)  , MPI_INTEGER,
     &                      IP-1        , LBTAG      , COMM       ,
     &                      IERR)
           END DO
d632 6
a637 5
           CALL MPI_RECV(DMLOC, 9*NANGLOC, MPI_REAL, MASTER,
     &                   DMTAG, COMM     , MPISTAT , IERR)
           CALL MPI_RECV(LBLOC, NANGLOC  , MPI_INTEGER, MASTER,
     &                   LBTAG, COMM     , MPISTAT , IERR)
        END IF
d639 1
a639 2
        WRITE(6,*) 'REPRCG3_Q: DATA DISTRIBUTION COMPLETED, MYPID = ',
     &              MYPID
d642 3
a644 3
        DO  ITER=1,MAXIT
           DELSQ=0.0
c$omp      parallel do private(kn,j,k,i),reduction(+:DELSQ)
d646 2
a647 2
              J=IPCUBE(4,KN)
              K=IPCUBE(5,KN)
d649 1
a649 1
                 DELSQ=DELSQ+CB(I,J,K)*CB(I,J,K)
d652 1
a652 1
           Q=Q*DELSQ
d655 3
a657 3
           DO    KN=1,NN
              J=IPCUBE(4,KN)
              K=IPCUBE(5,KN)
d659 1
a659 1
                 BCKP(I,J,K)=CB(I,J,K)-Q*BCKP(I,J,K)
d662 1
a662 1
           Q=-1.0/DELSQ
d665 5
a669 6
           DO    K=1,N
              DO    J=1,N
                 DO    I=1,N
C                   TEMP=0
                    BCKE(I,J,K)=0.0
                    bcke_sum(I,J,K) = 0.0
d678 4
a681 3
           DO K=1,nangloc
              L_EN=MIN0(NANGloc,K+NUMTH-1)
              L_NUM=MIN0(NUMTH,NANGloc-K+1)
d685 1
a685 1
                    PROJ(I,J)=0.0
d689 2
a690 1
              CALL PRJCQ(BCKP,NMAT,dmloc(1,K),
d696 1
a696 1
                 IF (lbloc(K+L_TH-1).GT.1)  THEN
d699 1
a699 1
                       PROJ(I,L_TH)=PROJ(I,L_TH)*lbloc(K+L_TH-1)
d704 8
a711 8
                 do i = 1,n*n - n - 1
                    pt         = proj(i, L_TH)
                    projt(1,i) = pt
                    projt(2,i) = proj(i+n,  L_TH) - pt
                    projt(3,i) = proj(i+1,  L_TH) - pt 
                    projt(4,i) = proj(i+n+1,L_TH) - proj(i+1,L_TH) - 
     &                           projt(2,i)
                 enddo
d714 2
a715 2
                 CALL  BCKCQ(BCKE,NMAT,DMloc(1,K+L_TH-1),
     &                       projt,N,IPCUBE,NN)
d719 3
a721 8
           CALL MPI_ALLREDUCE(BCKE   , BCKE_SUM,
     &                        NMAT   , MPI_REAL,
     &                        MPI_SUM, COMM    ,
     &                        IERR)
           IF (IERR .NE. 0) THEN
              WRITE(0,*) 'REPRCG3_Q: FAILED AT ALLREDUCE BCKE_SUM'
              STOP
           END IF
d726 3
a728 3
              CALL  FIXEDGE1(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
c              CALL  BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN,RI) sep 01 al
              CALL  BFIRSTS(BCKE_sum,BCKP,N,ALA,IPCUBE,NN)
d731 2
a732 2
              CALL  FIXEDGE2(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
              CALL  BSECOND(BCKE_sum,BCKP,N,ALA,IPCUBE,NN)
d735 2
a736 2
              CALL  FIXEDGE3(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
              CALL  BTHIRD(BCKE_sum,BCKP,N,ALA,IPCUBE,NN)
d739 1
a739 1
           AKDEN=0.0
d741 1
a741 1
c$omp      parallel do private(kn,j,k,i),reduction(+:AKDEN)
d743 2
a744 2
              J=IPCUBE(4,KN)
              K=IPCUBE(5,KN)
d746 2
a747 2
     &              IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 AKDEN=AKDEN+BCKP(I,J,K)*BCKE_sum(I,J,K)
d751 1
a751 1
           P=DELSQ/AKDEN
d755 2
a756 2
              J=IPCUBE(4,KN)
              K=IPCUBE(5,KN)
d764 2
a765 2
           ERR  = DELSQ/BNORM
           CHI2 = CHI2-P*DELSQ
d770 2
a771 7
C          STOPPING CRITERIA
           IF (ABS(ERR).LE.ERRM .OR. ABS(CHI2).LE.CHIM) THEN  
              DEALLOCATE (BCKE)
              DEALLOCATE (BCKP)
              DEALLOCATE (BCKE_SUM)
              RETURN
           ENDIF
d773 4
d779 1
a779 1
           DELSQ=0.0
d782 2
a783 2
              J=IPCUBE(4,KN)
              K=IPCUBE(5,KN)
d788 1
a788 1
           Q=Q*DELSQ
d791 3
a793 3
           DO    KN=1,NN
              J=IPCUBE(4,KN)
              K=IPCUBE(5,KN)
d795 1
a795 1
                 BCKP(I,J,K)=CB(I,J,K)-Q*BCKP(I,J,K)
d798 1
a798 1
           Q=-1.0/DELSQ
d804 1
a804 1
                    BCKE(I,J,K)=0.0
d813 2
a814 2
              L_EN=MIN0(NANG,K+NUMTH-1)
              L_NUM=MIN0(NUMTH,NANG-K+1)
d819 1
a819 1
                    PROJ(I,J)=0.0
d825 1
a825 1
                 CALL  PRJCQ(BCKP,NMAT,DM(1,K+L_TH-1),
d832 1
a832 1
                 IF (LB(K+L_TH-1).GT.1)  THEN
d835 1
a835 1
                       PROJ(I,L_TH)=PROJ(I,L_TH)*LB(K+L_TH-1)
d850 1
a850 2
                 CALL  BCKCQ(BCKE,NMAT,DM(1,K+L_TH-1),
     &                       PROJT,N,IPCUBE,NN)
d854 4
a857 4
           IF (MODE .EQ. 1)  THEN
              CALL  FIXEDGE1(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
c             CALL  BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN,RI) sep 01 al
              CALL  BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN)
d859 3
a861 3
           ELSEIF(MODE.EQ.2)  THEN
              CALL  FIXEDGE2(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
              CALL  BSECOND(BCKE,BCKP,N,ALA,IPCUBE,NN)
d863 3
a865 3
           ELSEIF(MODE.EQ.3)  THEN
              CALL  FIXEDGE3(BCKP,NMAT,BCKP,N,IPCUBE,NN)      
              CALL  BTHIRD(BCKE,BCKP,N,ALA,IPCUBE,NN)
d868 1
a868 1
           AKDEN=0.0
d870 1
a870 1
c$omp      parallel do private(kn,j,k,i),reduction(+:AKDEN)
d872 2
a873 2
              J=IPCUBE(4,KN)
              K=IPCUBE(5,KN)
d875 2
a876 2
     &              IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 AKDEN=AKDEN+BCKP(I,J,K)*BCKE(I,J,K)
d879 1
a879 1
           P=DELSQ/AKDEN
d883 2
a884 2
              J=IPCUBE(4,KN)
              K=IPCUBE(5,KN)
d892 2
a893 2
           ERR=DELSQ/BNORM
           CHI2=CHI2-P*DELSQ
d902 5
a906 9
C          STOPPING CRITERIA
           IF (ABS(ERR).LE.ERRM .OR. ABS(CHI2).LE.CHIM) THEN  
              DEALLOCATE (BCKE)
              DEALLOCATE (BCKP)            
              IF (.NOT. VERBOSE) THEN
C                WRITE FINAL ERROR 
                 WRITE(NOUT,2041) ITER,ERR,CHI2
              ENDIF
              RETURN
d909 1
d911 1
d914 2
a915 2
       DEALLOCATE (BCKE)
       DEALLOCATE (BCKP)
a921 93
C++*********************************************************************
C--*********************************************************************

        SUBROUTINE REDPRCG(N,NANG,CB,ANG,ILIST,IPCUBE,NN,DM,RI,ANGBUF)
 
        INCLUDE 'CMBLOCK.INC'

        DIMENSION     CB(N,N,N),PROJ(N,N),ANG(3,NANG)
        DIMENSION     ILIST(NANG),IPCUBE(5,NN),DM(9,NANG)
        DIMENSION     ANGBUF(4,NANG)
        CHARACTER*80  FINPIC
        CHARACTER*80  FINPAT

        COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
        COMMON /NORMB/    BNORM,CHI2
        DOUBLE PRECISION  ABA,SUS,SSQ

        DATA  INPROJ/98/

#ifdef USE_MPI
        include 'mpif.h'
        INTEGER MYPID, COMM, MPIERR, NPROCS
        INTEGER NANGLOC, NREM, IP, KGLB, NLOC, IPROC
        REAL, ALLOCATABLE, DIMENSION(:,:,:) :: CB_LOC, PRJBUF, PRJLOC
        REAL, ALLOCATABLE, DIMENSION(:,:)   :: ANG_LOC
        INTEGER, ALLOCATABLE, DIMENSION(:)  :: PSIZE
        INTEGER, ALLOCATABLE, DIMENSION(:)  :: NBASE
        DOUBLE PRECISION      ABA_LOC, SUS_LOC, SSQ_LOC
        INTEGER               KLP_LOC, KLS_LOC
C
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID , MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
        ALLOCATE(PSIZE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           WRITE(0,*) ' REPRCG3_Q: FAILED TO ALLOCATE PSIZE.'
           STOP
        ENDIF
        ALLOCATE(NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           WRITE(0,*) ' REPRCG3_Q: FAILED TO ALLOCATE NBASE.'
           STOP
        ENDIF
#endif
        ABA=0.0D0
        KLP=0
        SUS=0.0D0
        SSQ=0.0D0
        KLS=0
        
        ABA_LOC = 0.0D0 
        KLP_LOC = 0
        KLS_LOC = 0
        SUS_LOC = 0.0D0
        SSQ_LOC = 0.0D0

c$omp   parallel do private(i,j,k)
        DO    K=1,N
           DO    J=1,N
              DO    I=1,N
                 CB(I,J,K)=0.0
              ENDDO
           ENDDO
        ENDDO

#ifdef USE_MPI
        ALLOCATE (CB_LOC(N,N,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'REPRCG3_Q, CB_LOC',IER)
           RETURN
        ENDIF
        CB_LOC = 0.0
        CALL SETPART(NANG, PSIZE, NBASE)
        NANGLOC = PSIZE(MYPID+1)
C
        ALLOCATE (ANG_LOC(3,NANGLOC), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'REPRCG3_Q, ANG_LOC',IER)
           RETURN
        ENDIF
        ANG_LOC = 0.0
C
        ALLOCATE (PRJBUF(N,N,PSIZE(1)),PRJLOC(N,N,NANGLOC),
     &            STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'REPRCG3_Q, PRJBUF, PRJLOC',IER)
           RETURN
        ENDIF
C
        DO IPROC = 1, NPROCS
           NLOC = PSIZE(IPROC)

C          READ A SUBSET OF IMAGES (ONLY ONE PROCESSOR READS)
a922 201
           DO K=1,NLOC
              KGLB = K + NBASE(IPROC)
              CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(KGLB),IRTFLG)
              IF (IRTFLG .NE. 0) RETURN
              MAXIM = 0
              CALL OPFILEC(0,.FALSE.,FINPIC,INPROJ,'O',IFORM,
     &                     LSAM,LROW,NSL,
     &                     MAXIM,'DUMMY',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0) RETURN
C
              DO K2=1,N
                 CALL  REDLIN1P(INPROJ,PRJBUF(1,K2,K),N,K2)
              ENDDO
              IF (MYPID .EQ. 0) CLOSE(INPROJ)
           ENDDO

C          DISTRIBUTE IMAGES

           IF (IPROC .GT. 1) THEN
              IF (MYPID .EQ. 0) THEN
                 CALL MPI_SEND(PRJBUF , N*N*NLOC, MPI_REAL,
     &                         IPROC-1, IPROC-1 , COMM    ,
     &                         MPIERR)
                 IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) 'REDPRS: SEND FAILED'
                     STOP
                 ENDIF
              ELSE IF (MYPID .EQ. IPROC-1) THEN
                 CALL MPI_RECV(PRJLOC, N*N*NLOC   , MPI_REAL,
     &                         0     , MPI_ANY_TAG, COMM    ,
     &                         ISTAT , MPIERR)
                 IF (MPIERR .NE. 0) THEN
                    WRITE(6,*) 'REDPRS: RECV FAILED'
                    STOP
                 ENDIF
              ENDIF
           ELSE IF (MYPID .EQ. 0) THEN
              CALL  SCOPY(N*N*NLOC,PRJBUF,1,PRJLOC,1)
           ENDIF 
        ENDDO

        DO K = 1, NANGLOC
           KGLB = K + NBASE(MYPID+1)

C          ORDER IN DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES ARE IN
C          DEGREES!
C          IN ANG ARRAY IT IS OTHER WAY AROUND

           ITMP     = ILIST(KGLB)
           ICOUNT   = ANGBUF(1,ITMP)
           ANG_LOC(3,K) = ANGBUF(2,ITMP)
           ANG_LOC(2,K) = ANGBUF(3,ITMP)
           ANG_LOC(1,K) = ANGBUF(4,ITMP)

           CALL  ASTASQ(PRJLOC(1,1,K), N, RI, ABA_LOC, KLP_LOC, 
     &                  SUS_LOC, SSQ_LOC, KLS_LOC)
 
           CALL  RPRQ(N,PRJLOC(1,1,K),CB_LOC,IPCUBE,NN,
     &     ANG_LOC(1,K),ANG_LOC(2,K),ANG_LOC(3,K),DM(1,KGLB),RI)
        ENDDO
        IF (ALLOCATED(PRJBUF)) DEALLOCATE(PRJBUF) 
        IF (ALLOCATED(PRJLOC)) DEALLOCATE(PRJLOC) 

C       GATHER ANG_LOC INTO ANG

        DO J = 1, NPROCS
           NBASE(J) = 3*NBASE(J)
           PSIZE(J) = 3*PSIZE(J)
        END DO
        CALL MPI_ALLGATHERV(ANG_LOC,  3*NANGLOC, MPI_REAL,
     &                      ANG    ,  PSIZE    , NBASE   ,
     &                      MPI_REAL, COMM     , IERR)    

        DO K = 1, NANG
           IF (VERBOSE) THEN
              IF (MYPID .EQ. 0) THEN
                 WRITE(NOUT,3331)  K,(ANG(J,K),J=3,1,-1)
              ENDIF
3331          FORMAT(' PROJECTION #',I6,
     &            '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
           ENDIF
        END DO

        N3 = N*N*N
        IERR = 0
        CALL MPI_ALLREDUCE(CB_LOC , CB  , N3,  MPI_REAL,
     &                     MPI_SUM, COMM, IERR)
        IF (IERR .NE. 0) THEN
           WRITE(0,*) 'REPRCG3_Q: FAILED AT ALLREDUCE CB'
           STOP
        END IF
        CALL MPI_ALLREDUCE(ABA_LOC, ABA , 1,   MPI_DOUBLE_PRECISION,
     &                     MPI_SUM, COMM, IERR)
        IF (IERR .NE. 0) THEN
           WRITE(0,*) 'REPRCG3_Q: FAILED AT ALLREDUCE ABA'
           STOP
        END IF
        CALL MPI_ALLREDUCE(KLP_LOC, KLP , 1,   MPI_INTEGER,
     &                     MPI_SUM, COMM, IERR)
        IF (IERR .NE. 0) THEN
           WRITE(0,*) 'REPRCG3_Q: FAILED AT ALLREDUCE KLP'
           STOP
        END IF
        CALL MPI_ALLREDUCE(SSQ_LOC, SSQ , 1,   MPI_DOUBLE_PRECISION,
     &                     MPI_SUM, COMM, IERR)
        IF (IERR .NE. 0) THEN
           WRITE(0,*) 'REPRCG3_Q: FAILED AT ALLREDUCE ABA'
           STOP
        END IF
        CALL MPI_ALLREDUCE(SUS_LOC, SUS , 1,   MPI_DOUBLE_PRECISION,
     &                     MPI_SUM, COMM, IERR)
        IF (IERR .NE. 0) THEN
           WRITE(0,*) 'REPRCG3_Q: FAILED AT ALLREDUCE ABA'
           STOP
        END IF
        CALL MPI_ALLREDUCE(KLS_LOC, KLS , 1,   MPI_INTEGER,
     &                     MPI_SUM, COMM, IERR)
        IF (IERR .NE. 0) THEN
           WRITE(0,*) 'REPRCG3_Q: FAILED AT ALLREDUCE KLP'
           STOP
        END IF
        IF (ALLOCATED(CB_LOC))  DEALLOCATE(CB_LOC)
        IF (ALLOCATED(ANG_LOC)) DEALLOCATE(ANG_LOC)
        IF (ALLOCATED(PSIZE))   DEALLOCATE(PSIZE)
        IF (ALLOCATED(NBASE))   DEALLOCATE(NBASE)
#else
        DO    K=1,NANG
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K),IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPROJ,'O',IFORM,
     &                  LSAM,LROW,NSL,
     &                  MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           DO K2=1,N
              CALL  REDLIN(INPROJ,PROJ(1,K2),N,K2)
           ENDDO
           CLOSE(INPROJ)

C          ORDER IN DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES ARE IN 
C          DEGREES! IN ANG ARRAY IT IS OTHER WAY AROUND

           ITMP     = ILIST(K)
           ICOUNT   = ANGBUF(1,ITMP)
           IF (ICOUNT .LE. 0) THEN
C             MISSING KEY
              CALL ERRT(102,'MISSING ANGLE FOR IMAGE',ITMP)
              RETURN
           ENDIF

           ANG(3,K) = ANGBUF(2,ITMP)
           ANG(2,K) = ANGBUF(3,ITMP)
           ANG(1,K) = ANGBUF(4,ITMP)
           IF (VERBOSE) THEN
              WRITE(NOUT,3331)  K,(ANG(J,K),J=3,1,-1)
3331          FORMAT(' PROJECTION #',I6,
     &            '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
           ENDIF

           CALL  ASTASQ(PROJ,N,RI,ABA,KLP,SUS,SSQ,KLS)

           CALL  RPRQ(N,PROJ,CB,IPCUBE,NN,
     &     ANG(1,K),ANG(2,K),ANG(3,K),DM(1,K),RI)
        ENDDO
#endif

C       CLOSE DOCUMENT FILE
        IF (MYPID .LE. 0) CLOSE(77)
        ABA=ABA/KLP
C       PRINT STATISTICS
        IF (MYPID .LE. 0) WRITE(NOUT,2044)   KLP,ABA
2044    FORMAT
     &      ('  TOTAL NUMBER OF POINTS IN PROJECTIONS =',I10,
     &     /,'  AVERAGE OUTSIDE THE WINDOW            =',1PE10.3,/)

C       SUBTRACT THE AVERAGE AND WRITE TO THE FILE

        BNORM=0.0
        QT=ABA*NANG

c$omp   parallel do private(kn,j,k,i),reduction(+:BNORM)
        DO KN=1,NN
           J=IPCUBE(4,KN)
           K=IPCUBE(5,KN)
           DO    I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
              CB(I,J,K)=CB(I,J,K)-QT
              BNORM=BNORM+CB(I,J,K)*CB(I,J,K)
           ENDDO
        ENDDO

C       CALCULATE SUM OF SQUARES OF PROJECTIONS WITHIN CIRCLES AFTER
C       SUBTRACTION OF THE AVERAGE
        SSQ=SSQ-ABA*(2*SUS-ABA*KLS)
        CHI2=SSQ
        IF (MYPID .LE. 0) WRITE(NOUT,2045)   BNORM,CHI2
2045    FORMAT ('  SQUARED BP          =',1PE10.3,
     &        /,'  CHI2 =',1PE10.3,/)

        END
d932 6
a937 6
        R=RI*RI
        NC=N/2+1
        DO   J=1,N
           T=J-NC
           XX=T*T
           DO   I=1,N
d939 3
a941 3
              IF(XX+T*T.GT.R)    THEN
                 ABA=ABA+DBLE(X(I,J))
                 KLP=KLP+1
d943 3
a945 3
                 SSQ=SSQ+X(I,J)*DBLE(X(I,J))
                 SUS=SUS+X(I,J)
                 KLS=KLS+1
d959 1
a959 1
C   PUT ZEROS OUTSIDE
d961 8
a968 8
        NT=1
        DO    I=1,NMAT
           IF(NT.GT.NN)  THEN
              BCKP(I)=0.0
           ELSEIF(I.LT.IPCUBE(1,NT))  THEN
              BCKP(I)=0.0
           ELSEIF(I.EQ.IPCUBE(2,NT))  THEN
              NT=NT+1
d971 3
a973 2
C  ADD PIXELS ON THE EDGE
C FIX THE EDGES IN BCKP
d977 3
a979 3
                 IF(BCK3(I+1,J,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I+1,J,K)
                    GOTO  101
d982 1
a982 1
101     CONTINUE
d984 3
a986 3
                 IF(BCK3(I-1,J,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I-1,J,K)
                    GOTO  102
a988 1
102     CONTINUE
d994 3
a996 3
                 IF(BCK3(I,J+1,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J+1,K)
                    GOTO  201
d999 1
a999 1
201     CONTINUE
d1001 3
a1003 3
                 IF(BCK3(I,J-1,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J-1,K)
                    GOTO  202
a1005 1
202     CONTINUE
d1011 3
a1013 3
                 IF(BCK3(I,J,K+1).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J,K+1)
                    GOTO  301
d1016 1
a1016 1
301     CONTINUE
d1018 3
a1020 3
                 IF(BCK3(I,J,K-1).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I,J,K-1)
                    GOTO  302
a1022 1
302     CONTINUE
d1031 1
d1035 1
a1035 1
C   PUT ZEROS OUTSIDE
d1037 1
a1037 1
        NT=1
d1039 6
a1044 6
           IF(NT.GT.NN)  THEN
              BCKP(I)=0.0
           ELSEIF(I.LT.IPCUBE(1,NT))  THEN
              BCKP(I)=0.0
           ELSEIF(I.EQ.IPCUBE(2,NT))  THEN
              NT=NT+1
d1047 3
a1049 2
C  ADD PIXELS ON THE EDGE
C FIX THE EDGES IN BCKP
d1053 4
a1056 4
                 IF(BCK3(I+1,J,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I+1,J,K)
                    BCK3(I-1,J,K)=BCK3(I+1,J,K)
                    GOTO  101
d1059 1
a1059 1
101     CONTINUE
d1061 4
a1064 4
                 IF(BCK3(I-1,J,K).NE.0.0) THEN
                    BCK3(I,J,K)=BCK3(I-1,J,K)
                    BCK3(I+1,J,K)=BCK3(I-1,J,K)
                    GOTO  102
a1066 1
102     CONTINUE
d1075 1
a1075 1
                    GOTO  201
d1078 1
a1078 1
201           CONTINUE
d1081 3
a1083 3
                    BCK3(I,J,K)=BCK3(I,J-1,K)
                    BCK3(I,J+1,K)=BCK3(I,J-1,K)
                    GOTO  202
a1085 1
202           CONTINUE
d1092 3
a1094 3
                    BCK3(I,J,K)=BCK3(I,J,K+1)
                    BCK3(I,J,K-1)=BCK3(I,J,K+1)
                    GOTO  301
d1097 1
a1097 1
301           CONTINUE
d1100 3
a1102 3
                    BCK3(I,J,K)=BCK3(I,J,K-1)
                    BCK3(I,J,K+1)=BCK3(I,J,K-1)
                    GOTO  302
a1104 1
302           CONTINUE
d1117 1
a1117 1
C   PUT ZEROS OUTSIDE
d1119 8
a1126 8
        NT=1
        DO    I=1,NMAT
           IF(NT.GT.NN)  THEN
              BCKP(I)=0.0
           ELSEIF(I.LT.IPCUBE(1,NT))  THEN
              BCKP(I)=0.0
           ELSEIF(I.EQ.IPCUBE(2,NT))  THEN
              NT=NT+1
d1129 3
a1131 2
C  ADD PIXELS ON THE EDGE
C FIX THE EDGES IN BCKP
d1139 1
a1139 1
                    GOTO  101
d1142 1
a1142 1
101           CONTINUE
d1148 1
a1148 1
                    GOTO  102
a1150 1
102           CONTINUE
d1153 1
d1161 1
a1161 1
                    GOTO  201
d1164 1
a1164 1
201           CONTINUE
d1170 1
a1170 1
                    GOTO  202
a1172 1
202           CONTINUE
d1182 1
a1182 1
                    GOTO  301
d1185 1
a1185 1
301           CONTINUE
d1191 1
a1191 1
                    GOTO  302
a1193 1
302           CONTINUE
d1203 2
a1204 1
        DIMENSION  BCKE(N,N,N),BCKP(N,N,N),ipcube(5,nn)
d1206 7
a1212 7
        DO    KN=1,NN
           J=IPCUBE(4,KN)
           K=IPCUBE(5,KN)
           DO    I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
              BCKE(I,J,K)=BCKE(I,J,K)+ALA*(6*BCKP(I,J,K)-(
     &        +BCKP(I+1,J,K)+BCKP(I,J+1,K)+BCKP(I,J,K+1)
     &        +BCKP(I-1,J,K)+BCKP(I,J-1,K)+BCKP(I,J,K-1)))
d1225 5
a1229 5
        DO    KN=1,NN
           J=IPCUBE(4,KN)
           K=IPCUBE(5,KN)
           DO    I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 BCKE(I,J,K)=BCKE(I,J,K)+ALA*(18*BCKP(I,J,K)
d1248 6
a1253 6
c$omp parallel do private(kn,j,k,i)
        DO    KN=1,NN
           J=IPCUBE(4,KN)
           K=IPCUBE(5,KN)
           DO    I=IPCUBE(3,KN),IPCUBE(3,KN)+IPCUBE(2,KN)-IPCUBE(1,KN)
                 BCKE(I,J,K)=BCKE(I,J,K)+ALA*(60*BCKP(I,J,K)
@


1.28
log
@verbose
@
text
@d227 1
a227 1
2027    FORMAT(' EFFECTIVE NUMBER OF ANGLES: ',I6)
d533 2
a534 1
2041       FORMAT(' ITERATION=', I3,' ERROR=',1PE12.4,' CHI^2=',1PE12.4)
d666 2
a667 1
2041         FORMAT(' ITERATION='I3,' ERROR=',1PE12.4,' CHI^2=',1PE12.4)
@


1.27
log
@GPL License fixed
@
text
@d5 1
a5 1
C
d35 2
a36 4
C  SYMMETRIES IMPOSED ... - NOT YET!
C                             INTERPOLATION CHANGED !
C  CORRECTIONS APPLIED ON THE VOLUME SIDE.
C                                                     11/09/98
a46 2
C IMAGE_PROCESSING_ROUTINE
C
d269 1
a269 1
        DIMENSION  IPCUBE(5,NN),LB(NANG)
a354 1
C       WRITE(NOUT,2041) ITER,ERR,CHI2
d358 1
a358 1
C
d360 1
a360 1
C
d371 1
a371 1
C
d376 1
a376 1
C
d378 1
a378 1
C
d391 1
a391 1
C
d393 1
a393 1
C
d445 2
a446 2
              DO    J=1,L_NUM
                 DO    I=1,LTB
d488 1
a488 1
C
d490 1
a490 1
C
d530 3
a532 5
           ERR=DELSQ/BNORM
           CHI2=CHI2-P*DELSQ
           IF (MYPID .EQ. 0) THEN
              WRITE(NOUT,2041) ITER,ERR,CHI2
           ENDIF
d534 1
d567 3
a569 4
           DO    K=1,N
              DO    J=1,N
                 DO    I=1,N
C                   TEMP=0
d583 2
a584 2
              DO    J=1,L_NUM
                 DO    I=1,LTB
d606 8
a613 8
                 do i = 1,n*n - n - 1
                    pt         = proj(i, L_TH)
                    projt(1,i) = pt
                    projt(2,i) = proj(i+n,  L_TH) - pt
                    projt(3,i) = proj(i+1,  L_TH) - pt 
                    projt(4,i) = proj(i+n+1,L_TH) - proj(i+1,L_TH) - 
     &                           projt(2,i)
                 enddo
d617 1
a617 1
     &                       projt,N,IPCUBE,NN)
d623 1
a623 1
c              CALL  BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN,RI) sep 01 al
d661 7
a667 2
           WRITE(NOUT,2041) ITER,ERR,CHI2
2041       FORMAT(' ITERATION='I3,' ERROR=',1PE12.4,' CHI^2=',1PE12.4)
d672 4
d685 1
a685 1
       IF ( ALLOCATED(BCKE_SUM) ) DEALLOCATE(BCKE_SUM)
d725 1
a725 1
           WRITE(0,*) 'REPRCG3_Q: FAILED TO ALLOCATE PSIZE.'
d727 1
a727 1
        END IF
d730 1
a730 1
           WRITE(0,*) 'REPRCG3_Q: FAILED TO ALLOCATE NBASE.'
d831 1
a831 1
C
d846 1
a846 1
C
d848 1
a848 1
C
d856 1
a856 1
C
d926 1
a926 2
C          DEGREES!
C         IN ANG ARRAY IT IS OTHER WAY AROUND
d983 1
@


1.26
log
@HRI GPL License used
@
text
@a1 1
C++************************************************************************
a6 3
C **************************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
d10 1
a10 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a29 7

C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
a30 1
C **************************************************************************
a52 1
C--************************************************************************
a261 1
C++************************************************************************
a262 1
C--************************************************************************
a688 1
C++************************************************************************
a689 1
C--************************************************************************
a1011 1
C++************************************************************************
a1012 1
C--************************************************************************
a1089 1
C++************************************************************************
a1090 1
C--************************************************************************
a1172 1
C++************************************************************************
a1173 1
C--************************************************************************
a1262 1
C++************************************************************************
a1263 1
C--************************************************************************
a1280 1
C++************************************************************************
a1281 1
C--************************************************************************
a1304 1
C++************************************************************************
a1305 1
C--************************************************************************
@


1.25
log
@removed MPI_BARRIER to reduce comm overhead
@
text
@d1 1
d7 1
d9 1
d11 24
d41 1
d64 1
d274 1
d276 1
d703 1
d705 1
d1028 1
d1030 1
d1108 1
d1110 1
d1193 1
d1195 1
d1285 1
d1287 1
d1305 1
d1307 1
d1331 1
d1333 1
@


1.24
log
@Update the MPI part to conform with the changes made in the sequential and OMP code
@
text
@a276 1
        CALL MPI_BARRIER(COMM,MPIERR)
a387 1
        CALL MPI_BARRIER(COMM,IERR)
a745 1
        CALL MPI_BARRIER(COMM,MPIERR)
a805 1
        CALL MPI_BARRIER(COMM, MPIERR)
@


1.23
log
@format
@
text
@d63 6
a68 4
        integer  mypid, comm, ierr, j
c
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid, ierr)
d92 1
a92 7
#ifdef USE_MPI
        if (mypid .eq. 0) then
           WRITE(NOUT,2001) NANG
        endif
#else
        WRITE(NOUT,2001) NANG
#endif
a191 9
#ifdef USE_MPI
        if (mypid .eq. 0) then
           CALL OPFILEC(0,.TRUE.,FINPIC,INPIC,'U',IFORM,M,M,M,
     &                  MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9116
        else
           ibcnt = ibcnt + 1
        endif
#else
a194 1
#endif
d214 2
a215 8
#ifdef USE_MPI
        if (mypid .eq. 0) then
           WRITE(NOUT,2027) NANG
        endif
#else
        WRITE(NOUT,2027) NANG
#endif
2027    FORMAT('  EFFECTIVE NUMBER OF ANGLES: ',I6)
d265 26
a290 26
        integer mypid, comm, nprocs, ierr, mpistat(MPI_STATUS_SIZE)
        integer nangloc, ip, dmtag, lbtag, master, n2, iz, jz
        real     ALA, SQ, DELSQ
        integer, allocatable, dimension(:)    :: psize, nbase
        integer, allocatable, dimension(:)    :: lbloc
        real,    allocatable, dimension(:,:)  :: dmloc
        real,    allocatable, dimension(:,:,:):: bcke_sum
        real,    allocatable, dimension(:,:,:):: resid
c
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid , ierr)
        call MPI_COMM_SIZE(comm, nprocs, ierr)
        call MPI_BARRIER(comm,ierr)
c
        allocate(psize(nprocs), stat=irtflg)
        if (irtflg .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed to allocate psize.'
           stop
        end if
        allocate(nbase(nprocs), stat=irtflg)
        if (irtflg .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed to allocate nbase.'
           stop
        end if
        call setpart(nang, psize, nbase)
        nangloc = psize(mypid+1)
d318 1
a318 1
        ALLOCATE (bcke_sum(N,N,N), STAT=IRTFLG)
d320 1
a320 1
           CALL ERRT(46,'REPRCG3_Q, bcke_sum',IER)
d351 1
a351 1
        allocate(lbloc(nangloc), stat = irtflag)
d353 1
a353 1
           CALL ERRT(46,'REPRCG3_Q, lbloc',IER)
d356 1
a356 1
        allocate(dmloc(9, nangloc), stat = irtflag)
d358 1
a358 1
           CALL ERRT(46,'REPRCG3_Q, dmloc',IER)
d361 29
a389 29
c
        dmtag  = 1
        lbtag  = 2
        master = 0
        if (mypid .eq. 0) then
c
c          Process 0 distributes DM() and LB() to other processors
c
           do ip = 2, nprocs
              ibegin = nbase(ip) + 1
              call MPI_SEND(DM(1,ibegin), 9*psize(ip), MPI_REAL,
     &                      ip-1        , dmtag      , comm    ,
     &                      ierr)
              call MPI_SEND(lb(ibegin)  , psize(ip)  , MPI_INTEGER,
     &                      ip-1        , lbtag      , comm       ,
     &                      ierr)
           end do
           call scopy(9*nangloc, dm, 1, dmloc, 1)
           call scopy(nangloc  , lb, 1, lbloc, 1)
        else
c
c          === slaves receive data from the master ===
c
           call MPI_RECV(dmloc, 9*nangloc, MPI_REAL, master,
     &                   dmtag, comm     , mpistat , ierr)
           call MPI_RECV(lbloc, nangloc  , MPI_INTEGER, master,
     &                   lbtag, comm     , mpistat , ierr)
        end if
        call MPI_BARRIER(comm,ierr)
d391 2
a392 2
        write(6,*) 'REPRCG3_Q: Data distribution completed, mypid = ',
     &              mypid
d471 1
a471 1
           call MPI_ALLREDUCE(BCKE   , BCKE_sum,
d473 6
a478 6
     &                        MPI_SUM, comm    ,
     &                        ierr)
           if (ierr .ne. 0) then
              write(0,*) 'REPRCG3_Q: failed at ALLREDUCE bcke_sum'
              stop
           end if
d480 1
a480 1
C          === ignore mode > 0 for the time being ===
d523 1
a523 1
           if (mypid .eq. 0) then
d525 2
a526 3
           endif
2041       FORMAT('  ITERATION=', I3,' ERROR=',1PE12.4,
     &            ' CHI^2=',1PE12.4)
d531 1
a531 1
              DEALLOCATE (BCKE_sum)
d669 1
a669 1
       if ( allocated(bcke_sum) ) deallocate(bcke_sum)
d695 22
a716 22
        integer mypid, comm, ierr, nprocs
        integer nangloc, nrem, ip, kglb
        real, ALLOCATABLE, DIMENSION(:,:,:) :: cb_loc
        real, ALLOCATABLE, DIMENSION(:,:)   :: ANG_loc
        integer, allocatable, dimension(:)  :: psize
        integer, allocatable, dimension(:)  :: nbase
        double precision      ABA_loc, SUS_loc, SSQ_loc
        integer               KLP_loc, KLS_loc
c
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid , ierr)
        call MPI_COMM_SIZE(comm, nprocs, ierr)
        allocate(psize(nprocs), stat=irtflg)
        if (irtflg .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed to allocate psize.'
           stop
        end if
        allocate(nbase(nprocs), stat=irtflg)
        if (irtflg .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed to allocate nbase.'
           stop
        end if
d724 5
a728 5
        ABA_loc = 0.0D0 
        KLP_loc = 0
        KLS_loc = 0
        SUS_loc = 0.0D0
        SSQ_loc = 0.0D0
d740 11
a750 1
        ALLOCATE (cb_loc(N,N,N), STAT=IRTFLG)
d752 1
a752 1
           CALL ERRT(46,'REPRCG3_Q, cb_loc',IER)
d755 4
a758 6
        cb_loc = 0.0
        call setpart(nang, psize, nbase)
        nangloc = psize(mypid+1)
        call MPI_BARRIER(comm,ierr)
c
        ALLOCATE (ANG_loc(3,nangloc), STAT=IRTFLG)
d760 1
a760 1
           CALL ERRT(46,'REPRCG3_Q, ANG_loc',IER)
d763 20
a782 14
        ANG_loc = 0.0
c
        do k = 1, nangloc
           kglb = k + nbase(mypid+1)
           CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(kglb),IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPROJ,'O',IFORM,
     &                  LSAM,LROW,NSL,
     &                  MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
c
           DO K2=1,N
              CALL  REDLIN(INPROJ,PROJ(1,K2),N,K2)
d784 30
a813 1
           CLOSE(INPROJ)
d817 2
a818 2
c
           ITMP     = ILIST(kglb)
d820 3
a822 3
           ANG_loc(3,k) = ANGBUF(2,ITMP)
           ANG_loc(2,k) = ANGBUF(3,ITMP)
           ANG_loc(1,k) = ANGBUF(4,ITMP)
d824 2
a825 2
           CALL  ASTASQ(PROJ, N, RI, ABA_loc, KLP_loc, SUS_loc,
     &                  SSQ_loc, KLS_loc)
d827 17
a843 15
           CALL  RPRQ(N,PROJ,cb_loc,IPCUBE,NN,
     &     ANG_loc(1,k),ANG_loc(2,k),ANG_loc(3,k),DM(1,kglb),RI)
        end do
c
c       Gather ANG_loc into ANG
c
        do j = 1, nprocs
           nbase(j) = 3*nbase(j)
           psize(j) = 3*psize(j)
        end do
        call MPI_ALLGATHERV(ANG_loc,  3*nangloc, MPI_REAL,
     &                      ANG    ,  psize    , nbase   ,
     &                      MPI_REAL, comm     , ierr)    
c
        do k = 1, NANG
d845 3
a847 3
              if (mypid .eq. 0) then
                 WRITE(NOUT,3331)  k,(ANG(J,k),J=3,1,-1)
              endif
d851 1
a851 1
        end do
d854 41
a894 41
        ierr = 0
        call MPI_ALLREDUCE(cb_loc , CB  , N3,  MPI_REAL,
     &                     MPI_SUM, comm, ierr)
        if (ierr .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed at ALLREDUCE cb'
           stop
        end if
        call MPI_ALLREDUCE(ABA_loc, ABA , 1,   MPI_DOUBLE_PRECISION,
     &                     MPI_SUM, comm, ierr)
        if (ierr .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed at ALLREDUCE ABA'
           stop
        end if
        call MPI_ALLREDUCE(KLP_loc, KLP , 1,   MPI_INTEGER,
     &                     MPI_SUM, comm, ierr)
        if (ierr .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed at ALLREDUCE KLP'
           stop
        end if
        call MPI_ALLREDUCE(SSQ_loc, SSQ , 1,   MPI_DOUBLE_PRECISION,
     &                     MPI_SUM, comm, ierr)
        if (ierr .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed at ALLREDUCE ABA'
           stop
        end if
        call MPI_ALLREDUCE(SUS_loc, SUS , 1,   MPI_DOUBLE_PRECISION,
     &                     MPI_SUM, comm, ierr)
        if (ierr .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed at ALLREDUCE ABA'
           stop
        end if
        call MPI_ALLREDUCE(KLS_loc, KLS , 1,   MPI_INTEGER,
     &                     MPI_SUM, comm, ierr)
        if (ierr .ne. 0) then
           write(0,*) 'REPRCG3_Q: failed at ALLREDUCE KLP'
           stop
        end if
        if (allocated(cb_loc))  deallocate(cb_loc)
        if (allocated(ANG_loc)) deallocate(ANG_loc)
        if (allocated(psize))   deallocate(psize)
        if (allocated(nbase))   deallocate(nbase)
d940 1
a940 1
        CLOSE(77)
d943 1
a943 7
#ifdef USE_MPI
        if (mypid .eq. 0) then
           WRITE(NOUT,2044)   KLP,ABA
        endif
#else
        WRITE(NOUT,2044)   KLP,ABA
#endif
d967 1
a967 7
#ifdef USE_MPI
        if (mypid .eq. 0) then
           WRITE(NOUT,2045)   BNORM,CHI2
        endif
#else
        WRITE(NOUT,2045)   BNORM,CHI2
#endif
@


1.22
log
@mpi
@
text
@d235 1
a235 1
2027    FORMAT(' EFFECTIVE NUMBER OF ANGLES: ',I6)
d546 2
a547 1
2041       FORMAT(' ITERATION=', I3,' ERROR=',1PE12.4,' CHI^2=',1PE12.4)
@


1.21
log
@icount in getdocdat return
@
text
@d61 7
d90 5
d96 1
d196 9
d208 1
a209 1

d217 1
a217 1
     
d228 5
d234 1
d282 30
d337 8
d355 3
d366 190
d683 1
d688 3
d713 25
d743 7
d759 112
d912 1
d918 5
d924 1
d948 5
d954 1
@


1.20
log
@opfilec
@
text
@d434 1
a434 2
        SUBROUTINE REDPRCG
     &       (N,NANG,CB,ANG,ILIST,IPCUBE,NN,DM,RI,ANGBUF)
d484 7
a490 1
           IKEY     = ANGBUF(1,ITMP)
a493 6
           IF (IKEY .NE. ITMP) THEN
C             MISSING KEY
              WRITE(NOUT,*) '*** MISSING ANGLE FOR IMAGE: ',ITMP
              CALL ERRT(100,'  ',NE)
              RETURN
           ENDIF
@


1.19
log
@nloop,iloop_removed
@
text
@d3 2
a4 1
C  REPCG.F   USED PROJT FOR BCKCQ CALL, FEB 2000 ARDEAN LEITH
a34 1
C        1         2         3         4         5         6         7
d50 1
a50 1
       INTEGER, ALLOCATABLE, DIMENSION(:) ::    ILIST,LB
d54 3
a56 1
        CHARACTER*80      FINPIC,FINFO,FINPAT,ANGDOC
d108 1
d110 2
a111 2
        CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
a112 1
           CALL ERRT(4,'REPCG ',NE)
d183 1
a183 1
        CALL OPFIL(.TRUE.,FINPIC,INPIC,'U',M,M,M,
d185 1
a185 4
        IF (IRTFLG .NE. 0) THEN         
           CALL ERRT(4,'REPCG ',IER)
           GOTO 9116
        ENDIF
d188 1
a188 1
        ALLOCATE (CB(N,N,N), STAT=IRTFLG)
d190 1
a190 1
           CALL ERRT(46,'REPCG, CB',IER)
a193 12
        ALLOCATE (ANG(3,NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'REPCG, ANG',IER)
            GOTO 9114
        ENDIF
        
        ALLOCATE (DM(9,NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'REPCG, DM',IER)
           GOTO 9112
        ENDIF

d206 2
a207 2
        WRITE(NOUT,2027)  NANG
2027    FORMAT('     EFFECTIVE NUMBER OF ANGLES: ',I6)
d224 1
d470 2
a471 1
           CALL OPFIL (.FALSE.,FINPIC,INPROJ,'O',LSAM,LROW,NSL,
@


1.18
log
@bad definitions fixed for lb & qm
@
text
@d85 1
a85 1
        CALL  RDPRM(RI,NLOOP,ILOOP,'RADIUS OF RECONSTRUCTED OBJECT')
d267 3
a269 3
        CALL  RDPRM2(ERRM,CHIM,NLOOP,ILOOP,'ERROR LIMIT, CHI^2 LIMIT')
        CALL  RDPRMI(MAXIT,MODE,NLOOP,ILOOP,'ITERATION LIMIT, MODE')
        CALL  RDPRM(ALA,NLOOP,ILOOP,'LAMBDA')
@


1.17
log
@verbose on output
@
text
@d44 4
a47 5
        REAL, DIMENSION(:,:), POINTER :: PANG,PSYM
        REAL, ALLOCATABLE, DIMENSION(:,:,:) :: CB
        REAL, ALLOCATABLE, DIMENSION(:,:) :: QM,ANG,DM
        REAL, ALLOCATABLE, DIMENSION(:) :: BCKN,LB
        INTEGER, ALLOCATABLE, DIMENSION(:) :: ILIST
d49 3
d389 2
a390 1
              CALL  BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN,RI)
@


1.16
log
@tuned & used allocate
@
text
@d136 1
a136 1
     &     .TRUE.,MAXXT,MAXYT,PSYM,IRTFLG)
d205 1
a205 1
        CALL  REDPRCG(N,NANG,CB,ANG,ILIST,QM,NN,DM,RI,NOUT,PANG)
d250 1
a250 2
        SUBROUTINE  REPRCG3_Q
     &  (CB,BCKN,LSD,N,IPCUBE,NN,DM,LB,NANG,RI,
d255 1
d443 2
a444 2
        SUBROUTINE  REDPRCG
     &       (N,NANG,CB,ANG,ILIST,IPCUBE,NN,DM,RI,NOUT,ANGBUF)
d446 2
d503 5
a507 4

           WRITE(NOUT,3331)  K,(ANG(J,K),J=3,1,-1)
3331       FORMAT(' PROJECTION #',I6,
     &         '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
d548 1
@


1.15
log
@Used getthreads & cosmetic
@
text
@d3 1
a3 1
C  REPCG.FOR
d15 6
a20 6
C  Reprojections 3D, conjugate gradients method, 
C  reconstruction kept in the square to introduce other constraints.
C  Average outside the window is subtracted
C  Symmetries imposed ... - not yet!
C                             Interpolation changed !
C  corrections applied on the volume side.
d22 1
a22 1
C  Compression of angles - 08/14/96
d24 7
a30 1
C         REPCG(MAXMEM)
a31 7
C         REDPRCG
C         RPRQ(N,B,CUBE,IPCUBE,NN,PHI,THETA,PSI,DM,RI)
C         astasq(x,n,ri,aba,klp)
C         PREPCUB_s(N,NN,IPCUBE,RI)
C         BCKCQ(CUBE,LTC,DM,B,N,IPCUBE,NN)
C         PRJCQ(CUBE,LTC,DM,B,N,IPCUBE,NN)
C
a59 1

a61 1
 
a84 1

a96 1

d122 1
a122 1
     $     'DOES YOUR VOLUME HAVE SYMMETRIES? (Y/N)',NULL,IRT)
d124 1
a124 1
           write(nout,*)  'Option not implemented yet'
a149 1

d164 1
a164 1
c!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
a214 1

a227 1

d229 1
a229 1
     1     PSYM,NSYMT,NSYM,NUMTH)
d233 1
a233 1
           CALL  WRTLIN(INPIC,BCKN(1+MI),M,K)
d253 2
a254 1
C NUMTH - numthreds for mp; =numthreads() for mp, otherwise=1.
d257 2
a258 1
        DIMENSION   SYM(3,NSYMT),dm(9,nang),PROJ(N*N,NUMTH)
d265 1
a265 2
C
        CALL  RDPRM2(ERRM,CHIM,NLOOP,ILOOP,'Error limit, Chi^2 limit')
d267 1
a267 1
        CALL  RDPRM(ALA,NLOOP,ILOOP,'Lambda')
d269 1
a269 1
        IF(MODE.EQ.1.AND.RI+1.0.GT.DI
d272 2
a273 2
        CALL ERRT(101,'Radius too large',NE)
        RETURN
a274 1
c
d289 13
a302 14
        nmat=n*n*n
        ltb=n*n
c$omp parallel do private(k,j,i)
        do    k=1,n
           do    j=1,n
              do    i=1,n
C X=0
                 bckn(i,j,k)=0.0
C cdel=0
                 bckp(i,j,k)=0.0
              enddo
           enddo
        enddo
C
d309 8
a316 8
c$omp parallel do private(kn,j,k,i),reduction(+:DELSQ)
           do    kn=1,nn
              j=ipcube(4,kn)
              k=ipcube(5,kn)
           do i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
                 DELSQ=DELSQ+cb(i,j,k)*cb(i,j,k)
           enddo
           enddo
d318 9
a326 9
C
c$omp parallel do private(kn,j,k,i)
           do    kn=1,nn
              j=ipcube(4,kn)
              k=ipcube(5,kn)
           do i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
              bckp(i,j,k)=cb(i,j,k)-Q*bckp(i,j,k)
           enddo
           enddo
d329 48
a376 6
c$omp parallel do private(k,j,i)
           do    k=1,n
              do    j=1,n
                 do    i=1,n
C TEMP=0
                    bcke(i,j,k)=0.0
d378 8
a385 35
              enddo
           enddo
c
c   bckp -> proj -> bcke
c
c loop over projections
           do    k=1,nang,numth
              l_en=min0(nang,k+numth-1)
              l_num=min0(numth,nang-k+1)
c$omp parallel do private(i,j)
              do    j=1,l_num
                 do    i=1,ltb
                    proj(i,j)=0.0
                 enddo
              enddo
c$omp parallel do private(l_th),shared(nmat,n,nn),schedule(static)
              do  l_th=1,l_num
       call  prjcq(bckp,nmat,dm(1,k+l_th-1),proj(1,l_th),n,ipcube,nn)
              enddo
c
c here bckcq itself is mp  
              do  l_th=1,l_num
c multiply projections by their weights
                 if(lb(k+l_th-1).gt.1)  then
c$omp parallel do private(i)
                    do  i=1,n*n
                       proj(i,l_th)=proj(i,l_th)*lb(k+l_th-1)
                    enddo
                 endif
c backproject
        call  bckcq(bcke,nmat,dm(1,k+l_th-1),proj(1,l_th),n,ipcube,nn)
              enddo
           enddo
C
           IF(MODE.EQ.1)  THEN
d388 1
d392 1
d397 1
a397 1
C
d399 10
a408 8
c$omp parallel do private(kn,j,k,i),reduction(+:AKDEN)
           do    kn=1,nn
              j=ipcube(4,kn)
              k=ipcube(5,kn)
        do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
           AKDEN=AKDEN+bckp(i,j,k)*bcke(i,j,k)
        enddo
           enddo
d410 12
a421 9
c$omp parallel do private(kn,j,k,i)
           do    kn=1,nn
              j=ipcube(4,kn)
              k=ipcube(5,kn)
        do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
           bckn(i,j,k)=bckn(i,j,k)+P*bckp(i,j,k)
           cb(i,j,k)=cb(i,j,k)-P*bcke(i,j,k)
        enddo
           enddo
d425 9
a433 9
2041    format(' Iteration='I3,' Error=',1PE12.4,' Chi^2=',1PE12.4)
C stopping criteria
             IF(ABS(ERR).LE.ERRM .OR. ABS(CHI2).LE.CHIM) THEN  
                DEALLOCATE (BCKE)
                DEALLOCATE (BCKP)            
                RETURN
             ENDIF
        ENDDO
C Number of iterations exceeded
d444 1
a444 1
     &  (N,NANG,CB,ANG,ILIST,IPCUBE,NN,DM,RI,NOUT,ANGBUF)
d446 3
a448 3
        DIMENSION  CB(N,N,N),PROJ(N,N),ANG(3,NANG)
        DIMENSION  ILIST(NANG),IPCUBE(5,NN),DM(9,NANG)
        DIMENSION  ANGBUF(4,NANG)
d453 3
a455 3
        COMMON /NORMB/ BNORM,CHI2
        double precision  aba,sus,ssq
C
d458 14
a471 15
C
        aba=0.0d0
        klp=0
        sus=0.0d0
        ssq=0.0d0
        kls=0
c$omp parallel do private(i,j,k)
        do    k=1,n
           do    j=1,n
              do    i=1,n
                 cb(i,j,k)=0.0
              enddo
           enddo
        enddo
c
d481 1
a481 3


           DO    K2=1,N
d486 3
a488 2
C ORDER IN THE DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES ARE IN DEGREES!
C IN ANG ARRAY IT IS OTHER WAY AROUND
a501 2
	

a504 2
  

d506 1
a507 3

           call  astasq(proj,n,ri,aba,klp,sus,ssq,kls)
c
d511 6
a516 6
c
c  close document file
        close(77)
        aba=aba/klp
C  PRINT STATISTICS
        write(nout,2044)   KLP,aba
d518 5
a522 5
     &   ('  Total number of points in projections =',I10,
     &  /,'  Average outside the window            =',1PE10.3,/)
c
c subtract the average and write to the file
c
d524 45
a568 18
        qt=aba*nang
c$omp parallel do private(kn,j,k,i),reduction(+:BNORM)
        do    kn=1,nn
           j=ipcube(4,kn)
           k=ipcube(5,kn)
        do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
           cb(i,j,k)=cb(i,j,k)-qt
           BNORM=BNORM+cb(i,j,k)*cb(i,j,k)
        enddo
        enddo
C Calculate sum of squares of projections within circles after
C subtraction of the average
        ssq=ssq-aba*(2*sus-aba*kls)
        CHI2=ssq
        write(nout,2045)   BNORM,CHI2
2045    FORMAT
     &   ('  Squared BP          =',1PE10.3,
     &  /,'  Chi2 =',1PE10.3,/)
a569 24
C
        subroutine  astasq(x,n,ri,aba,klp,sus,ssq,kls)
        dimension   x(n,n)
        double precision  aba,sus,ssq

c  estimate average outside the circle
        r=ri*ri
        nc=n/2+1
        do   j=1,n
           t=j-nc
           xx=t*t
           do   i=1,n
              t=i-nc
              if(xx+t*t.gt.r)    then
                 aba=aba+dble(x(i,j))
                 klp=klp+1
              else
                 ssq=ssq+x(i,j)*dble(x(i,j))
                 sus=sus+x(i,j)
                 kls=kls+1
              endif
           enddo
        enddo
        end
d578 3
a580 3
c-------------------------------------------------------
c   put zeros outside
c-------------------------------------------------------
d582 6
a587 6
        do    i=1,NMAT
           if(nt.gt.nn)  then
              BCKP(i)=0.0
           elseif(i.lt.IPCUBE(1,NT))  then
              BCKP(i)=0.0
           elseif(i.eq.IPCUBE(2,NT))  then
d589 58
a646 58
           endif
        enddo
C  Add pixels on the edge
C Fix the edges in bckp
        do  k=1,n
           do j=1,n
              do  i=1,n-1
                 if(bck3(i+1,j,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i+1,j,k)
                    goto  101
                 endif
              enddo
101     continue
              do  i=n,2,-1
                 if(bck3(i-1,j,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i-1,j,k)
                    goto  102
                 endif
              enddo
102     continue
           enddo
        enddo
        do  k=1,n
           do i=1,n
              do  j=1,n-1
                 if(bck3(i,j+1,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j+1,k)
                    goto  201
                 endif
              enddo
201     continue
              do  j=n,2,-1
                 if(bck3(i,j-1,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j-1,k)
                    goto  202
                 endif
              enddo
202     continue
           enddo
        enddo
        do  j=1,n
           do i=1,n
              do  k=1,n-1
                 if(bck3(i,j,k+1).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j,k+1)
                    goto  301
                 endif
              enddo
301     continue
              do  k=n,2,-1
                 if(bck3(i,j,k-1).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j,k-1)
                    goto  302
                 endif
              enddo
302     continue
           enddo
        enddo
d655 3
a657 3
c-------------------------------------------------------
c   put zeros outside
c-------------------------------------------------------
d659 6
a664 6
        do    i=1,NMAT
           if(nt.gt.nn)  then
              BCKP(i)=0.0
           elseif(i.lt.IPCUBE(1,NT))  then
              BCKP(i)=0.0
           elseif(i.eq.IPCUBE(2,NT))  then
d666 64
a729 64
           endif
        enddo
C  Add pixels on the edge
C Fix the edges in bckp
        do  k=1,n
           do j=1,n
              do  i=2,n-1
                 if(bck3(i+1,j,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i+1,j,k)
                    bck3(i-1,j,k)=bck3(i+1,j,k)
                    goto  101
                 endif
              enddo
101     continue
              do  i=n-1,2,-1
                 if(bck3(i-1,j,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i-1,j,k)
                    bck3(i+1,j,k)=bck3(i-1,j,k)
                    goto  102
                 endif
             enddo
102     continue
           enddo
        enddo
        do  k=1,n
           do i=1,n
              do  j=2,n-1
                 if(bck3(i,j+1,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j+1,k)
                    bck3(i,j-1,k)=bck3(i,j+1,k)
                    goto  201
                 endif
              enddo
201           continue
              do  j=n-1,2,-1
                 if(bck3(i,j-1,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j-1,k)
                    bck3(i,j+1,k)=bck3(i,j-1,k)
                    goto  202
                 endif
              enddo
202           continue
           enddo
        enddo
        do  j=1,n
           do i=1,n
              do  k=2,n-1
                 if(bck3(i,j,k+1).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j,k+1)
                    bck3(i,j,k-1)=bck3(i,j,k+1)
                    goto  301
                 endif
              enddo
301           continue
              do  k=n-1,2,-1
                 if(bck3(i,j,k-1).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j,k-1)
                    bck3(i,j,k+1)=bck3(i,j,k-1)
                    goto  302
                 endif
              enddo
302           continue
           enddo
        enddo
d739 3
a741 3
c-------------------------------------------------------
c   put zeros outside
c-------------------------------------------------------
d743 6
a748 6
        do    i=1,NMAT
           if(nt.gt.nn)  then
              BCKP(i)=0.0
           elseif(i.lt.IPCUBE(1,NT))  then
              BCKP(i)=0.0
           elseif(i.eq.IPCUBE(2,NT))  then
d750 70
a819 70
           endif
        enddo
C  Add pixels on the edge
C Fix the edges in bckp
        do  k=1,n
           do j=1,n
              do  i=3,n-1
                 if(bck3(i+1,j,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i+1,j,k)
                    bck3(i-1,j,k)=bck3(i+1,j,k)
                    bck3(i-2,j,k)=bck3(i+1,j,k)
                    goto  101
                 endif
              enddo
101           continue
              do  i=n-2,2,-1
                 if(bck3(i-1,j,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i-1,j,k)
                    bck3(i+1,j,k)=bck3(i-1,j,k)
                    bck3(i+2,j,k)=bck3(i-1,j,k)
                    goto  102
                 endif
              enddo
102           continue
           enddo
        enddo
        do  k=1,n
           do i=1,n
              do  j=3,n-1
                 if(bck3(i,j+1,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j+1,k)
                    bck3(i,j-1,k)=bck3(i,j+1,k)
                    bck3(i,j-2,k)=bck3(i,j+1,k)
                    goto  201
                 endif
              enddo
201           continue
              do  j=n-2,2,-1
                 If(bck3(i,j-1,k).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j-1,k)
                    bck3(i,j+1,k)=bck3(i,j-1,k)
                    bck3(i,j+2,k)=bck3(i,j-1,k)
                    goto  202
                 endif
              enddo
202           continue
           enddo
        enddo
        do  j=1,n
           do i=1,n
              do  k=3,n-1
                 if(bck3(i,j,k+1).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j,k+1)
                    bck3(i,j,k-1)=bck3(i,j,k+1)
                    bck3(i,j,k-2)=bck3(i,j,k+1)
                    goto  301
                 endif
              enddo
301           continue
              do  k=n-2,2,-1
                 if(bck3(i,j,k-1).ne.0.0) then
                    bck3(i,j,k)=bck3(i,j,k-1)
                    bck3(i,j,k+1)=bck3(i,j,k-1)
                    bck3(i,j,k+2)=bck3(i,j,k-1)
                    goto  302
                 endif
              enddo
302           continue
           enddo
        enddo
d828 10
a837 10
c$omp parallel do private(kn,j,k,i)
        do    kn=1,nn
           j=ipcube(4,kn)
           k=ipcube(5,kn)
           do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
              BCKE(i,j,k)=BCKE(i,j,k)+ALA*(6*BCKP(i,j,k)-(
     &        +BCKP(i+1,j,k)+BCKP(i,j+1,k)+BCKP(i,j,k+1)
     &        +BCKP(i-1,j,k)+BCKP(i,j-1,k)+BCKP(i,j,k-1)))
           enddo
        enddo
d848 11
a858 11
        do    kn=1,nn
           j=ipcube(4,kn)
           k=ipcube(5,kn)
           do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
                 BCKE(i,j,k)=BCKE(i,j,k)+ALA*(18*BCKP(i,j,k)
     &          -4.0*BCKP(i+1,j,k)+BCKP(i+2,j,k)
     &          -4.0*BCKP(i-1,j,k)+BCKP(i-2,j,k)
     &          -4.0*BCKP(i,j+1,k)+BCKP(i,j+2,k)
     &          -4.0*BCKP(i,j-1,k)+BCKP(i,j-2,k)
     &          -4.0*BCKP(i,j,k+1)+BCKP(i,j,k+2)
     &          -4.0*BCKP(i,j,k-1)+BCKP(i,j,k-2)
d860 2
a861 2
           enddo
        enddo
d872 11
a882 11
        do    kn=1,nn
           j=ipcube(4,kn)
           k=ipcube(5,kn)
           do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
                 BCKE(i,j,k)=BCKE(i,j,k)+ALA*(60*BCKP(i,j,k)
     &          -15.0*BCKP(i+1,j,k)+6.0*BCKP(i+2,j,k)-BCKP(i+3,j,k)
     &          -15.0*BCKP(i-1,j,k)+6.0*BCKP(i-2,j,k)-BCKP(i-3,j,k)
     &          -15.0*BCKP(i,j+1,k)+6.0*BCKP(i,j+2,k)-BCKP(i,j+3,k)
     &          -15.0*BCKP(i,j-1,k)+6.0*BCKP(i,j-2,k)-BCKP(i,j-3,k)
     &          -15.0*BCKP(i,j,k+1)+6.0*BCKP(i,j,k+2)-BCKP(i,j,k+3)
     &          -15.0*BCKP(i,j,k-1)+6.0*BCKP(i,j,k-2)-BCKP(i,j,k-3)
d884 2
a885 2
           enddo
        enddo
@


1.14
log
@*** empty log message ***
@
text
@d180 2
a181 10
#ifdef SP_MP
c$omp parallel private(np)
        np = OMP_GET_NUM_THREADS()
c$omp single
        NUMTH=np
c$omp end single
c$omp end parallel
#else
        NUMTH=1
#endif
@


1.13
log
@fixed maxnum
@
text
@a78 1

d80 1
a80 4
 	MAXNUM = 0
        DO I = 1,NANG
           IF (ILIST(I) .GT. MAXNUM) MAXNUM = ILIST(I)
        ENDDO
@


1.12
log
@cosmetic
@
text
@d80 6
a85 1
        MAXNUM = ILIST(NANG)
@


1.11
log
@cosmetic
@
text
@d41 3
a43 3
        INCLUDE CMBLOCK.INC
        INCLUDE CMLIMIT.INC
        INCLUDE F90ALLOC.INC
d269 1
a269 1
        INCLUDE CMBLOCK.INC
@


1.10
log
@adapted for dynamical memory allocation
@
text
@d41 3
a43 3
        INCLUDE '/net/ithaca/usr1/spider/src/CMBLOCK.INC' 
        INCLUDE '/net/ithaca/usr1/spider/src/CMLIMIT.INC' 
        INCLUDE '/net/ithaca/usr1/spider/src/F90ALLOC.INC'
d269 1
a269 1
        INCLUDE '/net/ithaca/usr1/spider/src/CMBLOCK.INC' 
@


1.9
log
@*** empty log message ***
@
text
@d12 1
a12 1
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
d24 8
a31 1
C	  REPCG(MAXMEM)
d33 1
a33 6
C	  REDPRCG
C	  RPRQ(N,B,CUBE,IPCUBE,NN,PHI,THETA,PSI,DM,RI)
C	  astasq(x,n,ri,aba,klp)
C	  PREPCUB_s(N,NN,IPCUBE,RI)
C	  BCKCQ(CUBE,LTC,DM,B,N,IPCUBE,NN)
C	  PRJCQ(CUBE,LTC,DM,B,N,IPCUBE,NN)
d35 1
d39 1
a39 1
	SUBROUTINE REPCG(MAXMEM)
d41 16
a56 2
	PARAMETER  (NILMAX=99998)
	COMMON     DUMMY(80),BUF(1024),ILIST(NILMAX),Q(3)
d58 3
a60 16
        INCLUDE 'CMBLOCK.INC' 
	 
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: QB
#else
        DIMENSION QB(1)
        POINTER           (IPQ,QB) 
#endif
        LOGICAL           RUNTIME, MD 
	COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
	CHARACTER*80      FINPIC,FINFO,FINPAT
	CHARACTER*1       NULL,ANS
	COMMON /PAR/      LDP,NM,LDPNM
	DATA  INPIC/99/
a61 2
	NULL = CHAR(0)
 
d65 18
a82 23
	IUNIT=NOUT
 	CALL  FILERD(FINPAT,NLET,NULL,
     &	  'ENTER TEMPLATE FOR 2-D IMAGE',IRTFLG)
 	CALL  FILERD(FINPIC,NLETI,NULL,'SELECTION DOC',IRTFLG)
	K=0
	K2=1
	NANG=0
778	LERR=-1
	IF (NANG.EQ.NILMAX)  THEN
	    WRITE(NOUT,*) '  TOO MANY IMAGES, LIST TRUNCATED'
	    GOTO  779
	ENDIF
	KP1=K+1
	CALL  UNSAV(FINPIC,K,INPIC,KP1,BUF,1,LERR,K2)
	IF (LERR.EQ.0)  THEN
	   NANG=NANG+1
	   ILIST(NANG)=BUF(1)
	   K=K+1
	   GOTO  778
	ENDIF
779	CLOSE(INPIC)
	WRITE(NOUT,2001) NANG
2001	FORMAT('  NUMBER OF IMAGES =',I5)
d84 1
d86 7
a92 13
	CALL  FILERD(FINFO,NLET1,NULL,'ANGLES DOC',ITRFLG)
	FINFO=FINFO(1:NLET1)//'.'//DATEXC(1:3)
	OPEN(77,FILE=FINFO,STATUS='OLD')
	READ(77,*)

 	CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
 	CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
 	IF (NF .NE. 2)  THEN
           CALL ERRT(4,'BP CG ',NE)
 	   RETURN
	ENDIF
	CLOSE(INPIC)
	N=NSAM
d94 24
a117 2
	IN=N
	INANG=NANG
a123 2
 	K_ANG=1
	K_SYM=K_ANG+3*NANG
d125 1
a125 1
	CALL RDPRMC (ANS, NLETI, .TRUE.,
d127 39
a165 29
	IF (ANS.EQ.'Y')  THEN
	write(nout,*)  'Option not implemented yet'
	return
 	   CALL  FILERD(FINPIC,NLETI,NULL,
     &         'SYMMETRIES ANGLES DOC',IRTFLG)
	   K=0
	   K2=1
	   NSYM=0
758	   LERR=-1
	   KP1=K+1
	   CALL  UNSAV(FINPIC,K,INPIC,KP1,Q(1),3,LERR,K2)
	   IF (LERR.EQ.0)  THEN
	      Q(K_SYM+3*NSYM)=Q(1)
	      Q(K_SYM+3*NSYM+1)=Q(2)
	      Q(K_SYM+3*NSYM+2)=Q(3)
	      NSYM=NSYM+1
	      K=K+1
	      GOTO  758
	   ENDIF
	   CLOSE(INPIC)
	   WRITE(NOUT,2021) NSYM
2021	   FORMAT(/,'  NUMBER OF SYMMETRIES:',I5,/)
	ELSE
	   NSYM=0
	ENDIF

 	K_DM=K_SYM+3*NSYM
	K_LB=K_DM+9*NANG
	K_MAP=K_LB+NANG
a166 3
c	K_IPCUBE=K_MAP+(N*N*NANG+1)/2
	K_IPCUBE=K_MAP

d168 1
a168 1
	CALL  PREPCUB_S(N,NN,Q(K_IPCUBE),RI,MD)
d170 2
a171 2
	NMAT=N*N*N
	LSD=N+2-MOD(N,2)
a178 3
	K_PROJ=K_IPCUBE+5*NN
 
	K_X=1 
d187 1
a187 1
	NUMTH=1
d189 28
a216 32
C       IN THIS VERSION SIGMA IS ASSUMED TO BE PROPORTIONAL TO PROJ
C       AND THE CORRESPONDING ARRAY IS NOT USED ANYWHERE.
C	K_SIGMA=K_PRJE
	K_CB=K_X+N*N*NUMTH 
        K_BCKE=K_CB+NMAT
	K_BCKN=K_BCKE+NMAT
	K_BCKP=K_BCKN+NMAT
	K_BFFT=K_BCKP+NMAT
	MEMTOT=K_BFFT+LSD*N*N
	WRITE(NOUT,1001)  MEMTOT
1001	FORMAT(//'  REPRCGOJECTION PROGRAM FOR 3-D BACK-PROJECTION',/,
     &     '           MEMORY NEEDED - ',I8,/)
     
        CALL CHKMEM(MEMTOT, Q, MAXMEM-(NILMAX+1024+80), 
     &	            RUNTIME,IPQ,IRTFLG)
	IF(IRTFLG.NE.0) THEN 
	   WRITE(NOUT,1002)  MAXMEM
1002	   FORMAT(' *** SORRY, YOUR BUFFER LENGTH IS ONLY',I9,/,
     1        '  PROGRAM CANNOT BE RUN')
           CALL ERRT(100,'BP CG',NERR)
	   RETURN
	ELSE
	   IF(.NOT. RUNTIME)  THEN
              K_X=K_PROJ 
	      K_CB=K_X+N*N*NUMTH 
              K_BCKE=K_CB+NMAT
	      K_BCKN=K_BCKE+NMAT
	      K_BCKP=K_BCKN+NMAT
	      K_BFFT=K_BCKP+NMAT
	      MEMTOT=K_BFFT+LSD*N*N
	   END IF
	ENDIF
d218 1
a218 12
#ifdef SP_F90
         QB = >IPQ
#endif
	CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',ITRFLG)
	IF  (IRTFLG .EQ. -1)  GOTO 9999
	IFORM = 3
 	CALL  OPENFB(BUF,FINPIC,INPIC,M,M,'UNKNOWN',NF,M)
	IF  (NF.NE.2)  GOTO 9999
C
	CALL  REDPRCG(N,NANG,QB(K_CB),
     1	   Q(K_PROJ),Q(K_ANG),ILIST,Q(K_IPCUBE),NN,Q(K_DM),
     2	   RI,NOUT)
d221 28
a248 15
	CALL  HIANG(Q(K_ANG),NANG,Q(K_DM),Q(K_LB),LO)
	NANG=LO
	WRITE(NOUT,2027)  NANG
2027	FORMAT('     EFFECTIVE NUMBER OF ANGLES: ',I6)
C
	NSYMT=MAX0(1,NSYM)
	CALL  REPRCG3_Q
     1	  (QB(K_CB),QB(K_BCKE),QB(K_BCKN),QB(K_BCKP),QB(K_BFFT),LSD,
     1     N,Q(K_IPCUBE),NN,
     2     Q(K_PROJ),Q(K_DM),Q(K_LB),NANG,RI,
     3     Q(K_SYM),NSYMT,NSYM,NUMTH)
C
	DO  K=1,M*M
	   MI=(K-1)*M
   	   CALL  WRTLIN(INPIC,QB(K_BCKN+MI),M,K)
d250 12
a261 4
	CLOSE(INPIC)
9999    CONTINUE
        IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'GALI',IRTFLG) 
	END
a262 16
C
C REPRCG3_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d265 3
a267 3
	SUBROUTINE  REPRCG3_Q
     &	(CB,BCKE,BCKN,BCKP,BUFF,LSD,N,IPCUBE,NN,PROJ,DM,LB,NANG,RI,
     &		SYM,NSYMT,NSYM,NUMTH)
d269 17
a285 15
        INCLUDE 'CMBLOCK.INC' 
	DIMENSION   CB(N,N,N),BCKE(N,N,N),BCKN(N,N,N),BCKP(N,N,N)
	DIMENSION   SYM(3,NSYMT),dm(9,nang),PROJ(N*N,NUMTH)
	DIMENSION  IPCUBE(5,NN),LB(NANG),BUFF(LSD,N,N)
	COMMON /NORMB/ BNORM,CHI2
	COMMON /PAR/  LDP,NM,LDPNM

C
	CALL  RDPRM2(ERRM,CHIM,NLOOP,ILOOP,'Error limit, Chi^2 limit')
	CALL  RDPRMI(MAXIT,MODE,NLOOP,ILOOP,'ITERATION LIMIT, MODE')
	CALL  RDPRM(ALA,NLOOP,ILOOP,'Lambda')
	DI=N/2
	IF(MODE.EQ.1.AND.RI+1.0.GT.DI
     &		.OR. MODE.EQ.2.AND.RI+2.0.GT.DI
     &		.OR. MODE.EQ.3.AND.RI+3.0.GT.DI)  THEN
d288 1
a288 1
 	ENDIF	
d290 17
a306 2
	nmat=n*n*n
	ltb=n*n
d308 3
a310 3
	do    k=1,n
	do    j=1,n
	do    i=1,n
d312 1
a312 1
	bckn(i,j,k)=0.0
d314 11
a324 11
	bckp(i,j,k)=0.0
	enddo
	enddo
	enddo
C
	ERR=1.0
	ITER=0
C	WRITE(NOUT,2041) ITER,ERR,CHI2
	Q=0.0
	DO  ITER=1,MAXIT
	DELSQ=0.0
d326 8
a333 8
	do    kn=1,nn
	 j=ipcube(4,kn)
	 k=ipcube(5,kn)
	  do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
	   DELSQ=DELSQ+cb(i,j,k)*cb(i,j,k)
	  enddo
	enddo
	Q=Q*DELSQ
d336 9
a344 8
	do    kn=1,nn
	 j=ipcube(4,kn)
	 k=ipcube(5,kn)
	  do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
	   bckp(i,j,k)=cb(i,j,k)-Q*bckp(i,j,k)
	  enddo
	enddo
	Q=-1.0/DELSQ
d346 3
a348 3
	do    k=1,n
	do    j=1,n
	do    i=1,n
d350 4
a353 4
	bcke(i,j,k)=0.0
	enddo
	enddo
	enddo
d358 3
a360 3
	do    k=1,nang,numth
	l_en=min0(nang,k+numth-1)
	l_num=min0(numth,nang-k+1)
d362 5
a366 5
	do    j=1,l_num
	do    i=1,ltb
	  proj(i,j)=0.0
	enddo
	enddo
d368 3
a370 3
	do  l_th=1,l_num
	call  prjcq(bckp,nmat,dm(1,k+l_th-1),proj(1,l_th),n,ipcube,nn)
	enddo
d373 1
a373 1
	do  l_th=1,l_num
d375 1
a375 1
	if(lb(k+l_th-1).gt.1)  then
d377 4
a380 4
	do  i=1,n*n
	proj(i,l_th)=proj(i,l_th)*lb(k+l_th-1)
	enddo
	endif
d382 14
a395 14
	call  bckcq(bcke,nmat,dm(1,k+l_th-1),proj(1,l_th),n,ipcube,nn)
	enddo
	enddo
C
	IF(MODE.EQ.1)  THEN
	CALL  FIXEDGE1(BCKP,NMAT,BCKP,N,IPCUBE,NN)	
	CALL  BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN,RI)
	ELSEIF(MODE.EQ.2)  THEN
	CALL  FIXEDGE2(BCKP,NMAT,BCKP,N,IPCUBE,NN)	
	CALL  BSECOND(BCKE,BCKP,N,ALA,IPCUBE,NN)
	ELSEIF(MODE.EQ.3)  THEN
	CALL  FIXEDGE3(BCKP,NMAT,BCKP,N,IPCUBE,NN)	
	CALL  BTHIRD(BCKE,BCKP,N,ALA,IPCUBE,NN)
	ENDIF
d397 1
a397 1
	AKDEN=0.0
d399 8
a406 8
	do    kn=1,nn
	 j=ipcube(4,kn)
	 k=ipcube(5,kn)
	  do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
	   AKDEN=AKDEN+bckp(i,j,k)*bcke(i,j,k)
	  enddo
	enddo
	P=DELSQ/AKDEN
d408 12
a419 12
	do    kn=1,nn
	 j=ipcube(4,kn)
	 k=ipcube(5,kn)
	  do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
	   bckn(i,j,k)=bckn(i,j,k)+P*bckp(i,j,k)
	   cb(i,j,k)=cb(i,j,k)-P*bcke(i,j,k)
	  enddo
	enddo
	ERR=DELSQ/BNORM
	CHI2=CHI2-P*DELSQ
	WRITE(NOUT,2041) ITER,ERR,CHI2
2041	format(' Iteration='I3,' Error=',1PE12.4,' Chi^2=',1PE12.4)
d421 6
a426 2
	IF(ABS(ERR).LE.ERRM .OR. ABS(CHI2).LE.CHIM)  RETURN
	ENDDO
d428 30
a457 21
        END
C
	SUBROUTINE  REDPRCG
     &	(N,NANG,CB,PROJ,ANG,ILIST,IPCUBE,NN,DM,RI,NOUT)
	DIMENSION  CB(N,N,N),PROJ(N,N),ANG(3,NANG)
	DIMENSION  ILIST(NANG),IPCUBE(5,NN),DM(9,NANG)
	COMMON     DUMMY(80),BUF(1024)
	CHARACTER*80  FINPIC
	CHARACTER*80  FINPAT
	COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
	COMMON /NORMB/ BNORM,CHI2
	double precision  aba,sus,ssq
C
	DATA  INPROJ/98/

C
	aba=0.0d0
	klp=0
	sus=0.0d0
	ssq=0.0d0
	kls=0
d459 7
a465 7
	do    k=1,n
	do    j=1,n
	do    i=1,n
	cb(i,j,k)=0.0
	enddo
	enddo
	enddo
d467 42
a508 12
	DO    K=1,NANG
	CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K),INTFLAG)
	CALL  OPENFB(BUF,FINPIC,INPROJ,LSAM,LROW,'O',NF,NSL)
	IF(NF.NE.2)  THEN
	write(nout,2032)   FINPIC
2032	FORMAT(' File not found ',A80,/,' Operation abandoned')
	RETURN
	ENDIF
	DO    K2=1,N
 	CALL  REDLIN(INPROJ,PROJ(1,K2),N,K2)
	ENDDO
	CLOSE(INPROJ)
d510 3
a512 27
c  Read angles from the document file.
c  Order in the document file is psi, theta, phi and angles are in degrees!
c  In ANG array it is other way around
c
	mim=0
797	read(77,777,end=787)  mam,ANG(3,K),ANG(2,K),ANG(1,K)
	if(mam.ne.ilist(k))  goto  797
	goto  767
777	format(i5,2x,3f12.1)
787	rewind 77
	mim=mim+1
	if(mim.eq.2)  then
	write(nout,*) ' Something wrong in angles doc file !'
	stop
	endif
	read(77,*)
	goto  797
767	continue
C
	call  astasq(proj,n,ri,aba,klp,sus,ssq,kls)
c
	CALL  RPRQ(N,PROJ,CB,IPCUBE,NN,
     &	ANG(1,K),ANG(2,K),ANG(3,K),DM(1,K),RI)
	WRITE(NOUT,333)  K,(ANG(J,K),J=3,1,-1)
333	FORMAT(' Projection #',I5,
     &	'; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
	ENDDO
d515 2
a516 2
	close(77)
	aba=aba/klp
d518 3
a520 3
	write(nout,2044)   KLP,aba
2044	FORMAT
     &	 ('  Total number of points in projections =',I10,
d525 2
a526 2
	BNORM=0.0
	qt=aba*nang
d528 8
a535 8
	do    kn=1,nn
	j=ipcube(4,kn)
	k=ipcube(5,kn)
	 do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
	  cb(i,j,k)=cb(i,j,k)-qt
	  BNORM=BNORM+cb(i,j,k)*cb(i,j,k)
	 enddo
	enddo
d539 4
a542 4
	CHI2=ssq
	write(nout,2045)   BNORM,CHI2
2045	FORMAT
     &	 ('  Squared BP          =',1PE10.3,
d544 1
a544 1
	END
d546 3
a548 3
	subroutine  astasq(x,n,ri,aba,klp,sus,ssq,kls)
	dimension   x(n,n)
	double precision  aba,sus,ssq
d551 24
a574 20
	r=ri*ri
	nc=n/2+1
	do   j=1,n
	t=j-nc
	xx=t*t
	do   i=1,n
	t=i-nc
	if(xx+t*t.gt.r)    then
	aba=aba+dble(x(i,j))
	klp=klp+1
	else
	ssq=ssq+x(i,j)*dble(x(i,j))
	sus=sus+x(i,j)
	kls=kls+1
	endif
	enddo
	enddo
	end
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
	SUBROUTINE  FIXEDGE1(BCKP,NMAT,BCK3,N,IPCUBE,NN)
d580 10
a589 10
	NT=1
	do    i=1,NMAT
	if(nt.gt.nn)  then
	BCKP(i)=0.0
	elseif(i.lt.IPCUBE(1,NT))  then
	BCKP(i)=0.0
	elseif(i.eq.IPCUBE(2,NT))  then
	NT=NT+1
	endif
	enddo
d592 55
a646 55
	do  k=1,n
	 do j=1,n
	  do  i=1,n-1
	  if(bck3(i+1,j,k).ne.0.0) then
		bck3(i,j,k)=bck3(i+1,j,k)
		goto  101
	  endif
	  enddo
101	continue
	  do  i=n,2,-1
	  if(bck3(i-1,j,k).ne.0.0) then
		bck3(i,j,k)=bck3(i-1,j,k)
		goto  102
	  endif
	  enddo
102	continue
	 enddo
	enddo
	do  k=1,n
	 do i=1,n
	  do  j=1,n-1
	  if(bck3(i,j+1,k).ne.0.0) then
		bck3(i,j,k)=bck3(i,j+1,k)
		goto  201
	  endif
	  enddo
201	continue
	  do  j=n,2,-1
	  if(bck3(i,j-1,k).ne.0.0) then
		bck3(i,j,k)=bck3(i,j-1,k)
		goto  202
	  endif
	  enddo
202	continue
	 enddo
	enddo
	do  j=1,n
	 do i=1,n
	  do  k=1,n-1
	  if(bck3(i,j,k+1).ne.0.0) then
		bck3(i,j,k)=bck3(i,j,k+1)
		goto  301
	  endif
	  enddo
301	continue
	  do  k=n,2,-1
	  if(bck3(i,j,k-1).ne.0.0) then
		bck3(i,j,k)=bck3(i,j,k-1)
		goto  302
	  endif
	  enddo
302	continue
	 enddo
	enddo
	END
d648 4
a651 2
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
	SUBROUTINE  FIXEDGE2(BCKP,NMAT,BCK3,N,IPCUBE,NN)
d657 10
a666 10
	NT=1
	do    i=1,NMAT
	if(nt.gt.nn)  then
	BCKP(i)=0.0
	elseif(i.lt.IPCUBE(1,NT))  then
	BCKP(i)=0.0
	elseif(i.eq.IPCUBE(2,NT))  then
	NT=NT+1
	endif
	enddo
d669 66
a734 61
	do  k=1,n
	 do j=1,n
	  do  i=2,n-1
	  if(bck3(i+1,j,k).ne.0.0) then
		bck3(i,j,k)=bck3(i+1,j,k)
		bck3(i-1,j,k)=bck3(i+1,j,k)
		goto  101
	  endif
	  enddo
101	continue
	  do  i=n-1,2,-1
	  if(bck3(i-1,j,k).ne.0.0) then
		bck3(i,j,k)=bck3(i-1,j,k)
		bck3(i+1,j,k)=bck3(i-1,j,k)
		goto  102
	  endif
	  enddo
102	continue
	 enddo
	enddo
	do  k=1,n
	 do i=1,n
	  do  j=2,n-1
	  if(bck3(i,j+1,k).ne.0.0) then
		bck3(i,j,k)=bck3(i,j+1,k)
		bck3(i,j-1,k)=bck3(i,j+1,k)
		goto  201
	  endif
	  enddo
201	continue
	  do  j=n-1,2,-1
	  if(bck3(i,j-1,k).ne.0.0) then
		bck3(i,j,k)=bck3(i,j-1,k)
		bck3(i,j+1,k)=bck3(i,j-1,k)
		goto  202
	  endif
	  enddo
202	continue
	 enddo
	enddo
	do  j=1,n
	 do i=1,n
	  do  k=2,n-1
	  if(bck3(i,j,k+1).ne.0.0) then
		bck3(i,j,k)=bck3(i,j,k+1)
		bck3(i,j,k-1)=bck3(i,j,k+1)
		goto  301
	  endif
	  enddo
301	continue
	  do  k=n-1,2,-1
	  if(bck3(i,j,k-1).ne.0.0) then
		bck3(i,j,k)=bck3(i,j,k-1)
		bck3(i,j,k+1)=bck3(i,j,k-1)
		goto  302
	  endif
	  enddo
302	continue
	 enddo
	enddo
	END
a735 2
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
	SUBROUTINE  FIXEDGE3(BCKP,NMAT,BCK3,N,IPCUBE,NN)
d741 10
a750 10
	NT=1
	do    i=1,NMAT
	if(nt.gt.nn)  then
	BCKP(i)=0.0
	elseif(i.lt.IPCUBE(1,NT))  then
	BCKP(i)=0.0
	elseif(i.eq.IPCUBE(2,NT))  then
	NT=NT+1
	endif
	enddo
d753 74
a826 70
	do  k=1,n
	 do j=1,n
	  do  i=3,n-1
	  if(bck3(i+1,j,k).ne.0.0) then
		bck3(i,j,k)=bck3(i+1,j,k)
		bck3(i-1,j,k)=bck3(i+1,j,k)
		bck3(i-2,j,k)=bck3(i+1,j,k)
		goto  101
	  endif
	  enddo
101	continue
	  do  i=n-2,2,-1
	  if(bck3(i-1,j,k).ne.0.0) then
		bck3(i,j,k)=bck3(i-1,j,k)
		bck3(i+1,j,k)=bck3(i-1,j,k)
		bck3(i+2,j,k)=bck3(i-1,j,k)
		goto  102
	  endif
	  enddo
102	continue
	 enddo
	enddo
	do  k=1,n
	 do i=1,n
	  do  j=3,n-1
	  if(bck3(i,j+1,k).ne.0.0) then
		bck3(i,j,k)=bck3(i,j+1,k)
		bck3(i,j-1,k)=bck3(i,j+1,k)
		bck3(i,j-2,k)=bck3(i,j+1,k)
		goto  201
	  endif
	  enddo
201	continue
	  do  j=n-2,2,-1
	  if(bck3(i,j-1,k).ne.0.0) then
		bck3(i,j,k)=bck3(i,j-1,k)
		bck3(i,j+1,k)=bck3(i,j-1,k)
		bck3(i,j+2,k)=bck3(i,j-1,k)
		goto  202
	  endif
	  enddo
202	continue
	 enddo
	enddo
	do  j=1,n
	 do i=1,n
	  do  k=3,n-1
	  if(bck3(i,j,k+1).ne.0.0) then
		bck3(i,j,k)=bck3(i,j,k+1)
		bck3(i,j,k-1)=bck3(i,j,k+1)
		bck3(i,j,k-2)=bck3(i,j,k+1)
		goto  301
	  endif
	  enddo
301	continue
	  do  k=n-2,2,-1
	  if(bck3(i,j,k-1).ne.0.0) then
		bck3(i,j,k)=bck3(i,j,k-1)
		bck3(i,j,k+1)=bck3(i,j,k-1)
		bck3(i,j,k+2)=bck3(i,j,k-1)
		goto  302
	  endif
	  enddo
302	continue
	 enddo
	enddo
	END
C
	SUBROUTINE  BFIRSTS(BCKE,BCKP,N,ALA,IPCUBE,NN)
	DIMENSION  BCKE(N,N,N),BCKP(N,N,N),ipcube(5,nn)
d828 18
a845 13
	do    kn=1,nn
	 j=ipcube(4,kn)
	 k=ipcube(5,kn)
	  do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
	BCKE(i,j,k)=BCKE(i,j,k)+ALA*(6*BCKP(i,j,k)-(
     &		+BCKP(i+1,j,k)+BCKP(i,j+1,k)+BCKP(i,j,k+1)
     &		+BCKP(i-1,j,k)+BCKP(i,j-1,k)+BCKP(i,j,k-1)))
	  enddo
	enddo
	END
C
	SUBROUTINE  BSECOND(BCKE,BCKP,N,ALA,IPCUBE,NN)
	DIMENSION  BCKE(N,N,N),BCKP(N,N,N),ipcube(5,nn)
d847 23
a869 18
	do    kn=1,nn
	 j=ipcube(4,kn)
	 k=ipcube(5,kn)
	  do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
	BCKE(i,j,k)=BCKE(i,j,k)+ALA*(18*BCKP(i,j,k)
     &		-4.0*BCKP(i+1,j,k)+BCKP(i+2,j,k)
     &		-4.0*BCKP(i-1,j,k)+BCKP(i-2,j,k)
     &		-4.0*BCKP(i,j+1,k)+BCKP(i,j+2,k)
     &		-4.0*BCKP(i,j-1,k)+BCKP(i,j-2,k)
     &		-4.0*BCKP(i,j,k+1)+BCKP(i,j,k+2)
     &		-4.0*BCKP(i,j,k-1)+BCKP(i,j,k-2)
     &		)
	  enddo
	enddo
	END
C
	SUBROUTINE  BTHIRD(BCKE,BCKP,N,ALA,IPCUBE,NN)
	DIMENSION  BCKE(N,N,N),BCKP(N,N,N),ipcube(5,nn)
d871 15
a885 15
	do    kn=1,nn
	 j=ipcube(4,kn)
	 k=ipcube(5,kn)
	  do    i=ipcube(3,kn),ipcube(3,kn)+ipcube(2,kn)-ipcube(1,kn)
	BCKE(i,j,k)=BCKE(i,j,k)+ALA*(60*BCKP(i,j,k)
     &		-15.0*BCKP(i+1,j,k)+6.0*BCKP(i+2,j,k)-BCKP(i+3,j,k)
     &		-15.0*BCKP(i-1,j,k)+6.0*BCKP(i-2,j,k)-BCKP(i-3,j,k)
     &		-15.0*BCKP(i,j+1,k)+6.0*BCKP(i,j+2,k)-BCKP(i,j+3,k)
     &		-15.0*BCKP(i,j-1,k)+6.0*BCKP(i,j-2,k)-BCKP(i,j-3,k)
     &		-15.0*BCKP(i,j,k+1)+6.0*BCKP(i,j,k+2)-BCKP(i,j,k+3)
     &		-15.0*BCKP(i,j,k-1)+6.0*BCKP(i,j,k-2)-BCKP(i,j,k-3)
     &		)
	  enddo
	enddo
	END
@


1.8
log
@adapted for subroutine prepcub.f
@
text
@d51 1
a51 1
        LOGICAL           RUNTIME 
@


1.7
log
@a
@
text
@d148 2
a149 1
	CALL  PREPCUB_S(N,NN,Q(K_IPCUBE),RI)
@


1.6
log
@*** empty log message ***
@
text
@d268 1
a268 1
CNO_SAVE
d413 1
a413 1
CNO_SAVE
d505 1
a505 1
CNO_SAVE
d528 1
a528 1
CNO_SAVE
d603 1
a603 1
CNO_SAVE
d684 1
a684 1
CNO_SAVE
@


1.5
log
@OpenMP
@
text
@d163 6
a168 1
	NUMTH=mp_numthreads()
@


1.4
log
@*** empty log message ***
@
text
@d278 1
a278 1
c$doacross local(k,j,i)
d296 1
a296 1
c$doacross local(kn,j,k,i),reduction(DELSQ)
d306 1
a306 1
c$doacross local(kn,j,k,i)
d315 1
a315 1
c$doacross local(k,j,i)
d331 1
a331 1
c$doacross local(i,j)
d337 1
a337 1
c$doacross local(l_th),shared(nmat,n,nn),mp_schedtype=simple
d346 1
a346 1
c$doacross local(i)
d368 1
a368 1
c$doacross local(kn,j,k,i),reduction(AKDEN)
d377 1
a377 1
c$doacross local(kn,j,k,i)
d415 1
a415 1
c$doacross local(i,j,k)
d478 1
a478 1
c$doacross local(kn,j,k,i),reduction(BNORM)
d765 1
a765 1
c$doacross local(kn,j,k,i)
d779 1
a779 1
c$doacross local(kn,j,k,i)
d798 1
a798 1
c$doacross local(kn,j,k,i)
@


1.3
log
@99998
@
text
@a55 2
CNO_SAVE

d125 1
a125 1
	   CALL  UNSAV(FINPIC,K,INPIC,KP1,Q,3,LERR,K2)
d148 1
a148 1
	CALL  PREPCUB_s(N,NN,Q(K_IPCUBE),RI)
@


1.2
log
@buffer 99999
@
text
@d38 1
a38 1
	PARAMETER  (NILMAX=99999)
@


1.1
log
@Initial revision
@
text
@d38 1
a38 1
	PARAMETER  (NILMAX=20000)
@
