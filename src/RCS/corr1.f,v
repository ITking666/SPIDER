head	1.52;
access;
symbols
	pre_mrcs:1.52
	healthdept_2018:1.52
	pre_getangas:1.46
	GPL2010:1.46
	pre_GPL2010:1.45
	pre_var_equation:1.45
	pre_fftwrings:1.44
	pre_opfiles:1.40
	src:1.40
	best-code:1.40
	x-named-regs:1.40
	x:1.40
	v13-00:1.40
	pre_GPL:1.38
	prec_CA:1.36
	noindx:1.34
	Bproc:1.25
	oct21:1.13
	last77:1.13;
locks; strict;
comment	@c @;


1.52
date	2018.10.03.14.34.03;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2015.02.20.15.17.40;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2011.12.06.17.19.23;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2011.08.04.14.37.31;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2011.08.03.20.05.19;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2011.07.29.15.19.42;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.24.13.25.20;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2009.04.28.13.15.35;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2008.03.19.13.19.29;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2008.03.12.15.24.41;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2008.02.19.16.56.28;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2008.02.19.15.24.31;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.17.20.12.10;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.17.18.06.14;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.29.20.26.24;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.24.19.47.50;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.26.16.20.59;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.18.21.49.40;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.30.20.10.28;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.19.14.14.37;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.18.20.28.45;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.29.18.23.09;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.02.21.41.20;	author bimal;	state Exp;
branches;
next	1.29;

1.29
date	2000.10.08.21.16.16;	author pawel;	state Exp;
branches;
next	1.28;

1.28
date	2000.09.19.15.58.14;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.19.13.23.08;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2000.09.18.22.24.33;	author pawel;	state Exp;
branches;
next	1.25;

1.25
date	2000.09.12.22.20.20;	author pawel;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.15.17.37.49;	author bimal;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.14.17.26.06;	author bimal;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.14.12.34.00;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.13.20.38.45;	author bimal;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.13.19.05.23;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.16.20.10.44;	author bimal;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.27.19.38.32;	author bimal;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.14.19.33.23;	author bimal;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.14.19.29.18;	author bimal;	state Exp;
branches;
next	1.15;

1.15
date	99.11.10.23.09.12;	author yuchen;	state Exp;
branches;
next	1.14;

1.14
date	99.11.05.22.54.29;	author bimal;	state Exp;
branches;
next	1.13;

1.13
date	98.04.06.18.53.40;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	97.10.03.21.08.05;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	96.10.01.16.11.45;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	96.08.30.13.32.54;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	96.08.29.14.13.19;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	96.08.28.21.55.16;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	96.08.28.19.36.07;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	96.08.27.20.34.01;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	96.08.27.19.42.49;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	95.07.26.18.42.44;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	95.03.01.12.46.58;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.03.41;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.47.56;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.52
log
@email_health_dept
@
text
@C++*********************************************************************
C
C CORR1.F       REWRITTEN                          AUG 96 PP
C               ADDED 'CC H'                       MAR 02 ARDEAN LEITH
C               OPFILEC                            FEB 03 ARDEAN LEITH
C               'CC MS' bug                        OCT 03 ARDEAN LEITH
C               FMRS USED, UNUSED ALLOCS REMOVED   FEB 08 ARDEAN LEITH
C               PHASE REMOVED                      FEB 08 ARDEAN LEITH
C               MOD PGI COMPILER BUG               FEB 08 ARDEAN LEITH
C               INPLACE PARAMETERS                 APR 09 ARDEAN LEITH
C               RECOVERED 'CC H'                   JUL 11 ARDEAN LEITH
C               NRMS --> NORMVALSP                 DEC 11 ARDEAN LEITH
C               NPROMPTS, ==                       MAR 15 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  CORR1
C
C  'CC N' CALL TREE:
C  CORR1 ---> READV
C        ---> NORMVALSP
C        ---> FMRS 
C                                        
C        ---> READV
C        ---> NORMVALSP
C        ---> FMRS 
C
C        ---> CCRS
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE CORR1

        USE TYPE_KINDS
        INTEGER(KIND=I_8)    :: IPLAN = 0     !STRUCTURE POINTER 

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        CHARACTER(LEN=MAXNAM) :: FILNAM1,FILNAM2,FILNAMM

        COMPLEX, ALLOCATABLE  :: QK1(:,:,:)
        COMPLEX, ALLOCATABLE  :: QK2(:,:,:)
        COMPLEX, ALLOCATABLE  :: QKB(:)

        CHARACTER(LEN=1)      :: NULL = CHAR(0)

        PARAMETER (NFUNC=3)
        CHARACTER(LEN=2)      :: FUNC(NFUNC)

        LOGICAL               :: ACASE, BOTH_INC
        LOGICAL               :: SPIDER_SIGN
        LOGICAL               :: SPIDER_SCALE
	DOUBLE PRECISION      :: DAV,DSIG

        INTEGER, PARAMETER    :: LUN1 = 21
        INTEGER, PARAMETER    :: LUN2 = 22
        INTEGER, PARAMETER    :: LUN3 = 23

        DATA            FUNC/'AC',  'CC',  'CN'/

        IRTFLG = 0
 
C       DETERMINE IFUNC
        DO  IFUNC = 1,NFUNC
          IF (FCHAR(1:2) == FUNC(IFUNC)(1:2)) THEN
            GOTO 1111
          ENDIF
        ENDDO
C       OPERATION NOT HERE, RETURN TO CALLER
        RETURN 

1111    CONTINUE
C       CATCH EXCEPTIONS
C       ---------------------------------------------------------- CC C
        IF (FCHAR(1:4) == 'CC C')  THEN
           MAXIM = 0
           CALL OPFILEC(0,.TRUE.,FILNAM1,LUN1,'O',IFORM,
     &                NX1,NY1,NZ1,MAXIM,'FIRST INPUT',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           MAXIM = 0
           CALL OPFILEC(0,.TRUE.,FILNAM2,LUN2,'O',IFORM,
     &                NX2,NY2,NZ2,MAXIM,'SECOND INPUT',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              GOTO 998

           ELSEIF (NX1 .NE. NX2 .OR.
     &             NY1 .NE. NY2 .OR.
     &             NZ1 .NE. NZ2) THEN
              CALL ERRT(1,'CORR1',NE)
              GOTO 998
           ENDIF
           
           MAXIM = 0
           CALL OPFILEC(0,.TRUE.,FILNAMM,LUN3,'O',IFORM,
     &                NXM,NYM,NZM,MAXIM,'MASK',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 998

           IF (NX1 .NE. NXM .OR. 
     &         NY1 .NE. NYM .OR.
     &         NZ1 .NE. NZM) THEN
               CALL ERRT(1,'CCC',NE)
               GOTO 998
           ENDIF
        
           CALL CCC(LUN1,FILNAM1,NX1,NY1,NZ1,
     &              LUN2,FILNAM2,NX2,NY2,NZ2,
     &              LUN3,FILNAMM)
          
           GOTO 998

C           ----------------------------------------------------- CC MS
        ELSEIF (FCHAR(1:5) == 'CC MS') THEN
C          CROSS CORRELATION - MASKED AND NORMALIZED 
           CALL MCCF
           RETURN

C          ------------------------------------------------------ AC MS
        ELSEIF (FCHAR(1:5) == 'AC MS')  THEN
          IF (FCHAR(6:6) == 'S')  THEN
C            AUTO CORRELATION - MASKED AND NORMALIZED 
              CALL MACF('S')
           ELSE
C             AUTO CORRELATION - MASKED AND NORMALIZED 
              CALL MACF(' ')
           ENDIF
           RETURN

C          ------------------------------------------------------ CC P
        ELSEIF (FCHAR(1:4) == 'CC P')  THEN
C          THIS APPEARS TO BE UNUSED ELSEWHERE IN SPIDER??
           CALL POLAR_CC 
           RETURN
        ENDIF


C       --------------------------------------------------------- CC H
C       --------------------------------------------------------- CC N 
C       --------------------------------------------------------- CC 
C       --------------------------------------------------------- AC 
C       OPEN FIRST INPUT FILE, FOURIER INPUT ALLOWED
        MAXIM = 0 
        CALL OPFILEC(0,.TRUE.,FILNAM1,LUN1,'O',IFORM,
     &               NX1,NY1,NZ1,MAXIM,'INPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        IF (FCHAR(4:4) == 'N' .AND. IFORM < 0) THEN
C          NO STATISTICS IN FILE, CAN NOT NORMALIZE OUTPUT
           CALL ERRT(101, 
     &        'CAN NOT NORMALIZE OUTPUT - FILE LACKS STATISTICS.',NE)
           GOTO 998

        ELSEIF (FCHAR(4:4) == 'N')  THEN
C          FOR 'CC N'
           IMAMI1 = IMAMI
           SIG1   = SIG
        ENDIF
        IFORM1 = IFORM

C       CALCULATE DIMENSIONS
        IF (IFORM1 > 0)  THEN
C          REAL SPACE INPUT
           LS1    = NX1 + 2 - MOD(NX1,2)
           LREC1  = NX1
           IFORM3 = IFORM1
           NX3  = NX1
        ELSE
C          FOURIER SPACE INPUT
           LS1   = NX1
           LREC1 = NX1
           NX1 = NX1 - MOD(-IFORM1,10)
           IF (IFORM1 > -20)  THEN
              IFORM3 = 1
           ELSE
              IFORM3 = 3
           ENDIF
           NX3 = NX1
        ENDIF

        IF (FCHAR(1:2) == 'AC') THEN
C          AUTO CORRELATION WANTED, NO SECOND FILE
           ACASE  = .TRUE.
           IFORM2 = IFORM1
        ELSE 
C          GET NAME FOR SECOND INPUT FILE
           CALL FILERD(FILNAM2,NLET,NULL,'REFERENCE',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 998

           IF (FILNAM1 == FILNAM2) THEN
C             FILENAMES ARE SAME, AUTOCORRELATION WANTED
              ACASE  = .TRUE.
              IFORM2 = IFORM1
           ELSE
C             OPEN SECOND INPUT FILE, FOURIER INPUT ALLOWED 
              MAXIM = 0
              CALL OPFILEC(0,.FALSE.,FILNAM2,LUN2,'O',IFORM,
     &                NX2,NY2,NZ2,MAXIM,NULL,.TRUE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 998

              IFORM2 = IFORM
              ACASE  = .FALSE.

              IF (FCHAR(4:4) == 'N' .AND. IFORM < 0) THEN
C                NO STATISTICS IN FILE, CAN NOT NORMALIZE OUTPUT
                 CALL ERRT(101, 
     &           'CAN NOT NORMALIZE OUTPUT - FILE LACKS STATISTICS.',I)
                 GOTO 998

              ELSEIF (FCHAR(4:4) == 'N')  THEN
C                FOR 'CC N'
                 IMAMI2 = IMAMI
                 SIG2   = SIG
              ENDIF
C             CALCULATE DIMENSIONS
              IF (IFORM2 > 0)  THEN
C                REAL SPACE INPUT
                 LS2   = NX2 + 2 - MOD(NX2,2)
              ELSE
C                FOURIER SPACE INPUT
                 LS2   = NX2
                 NX2 = NX2 - MOD(-IFORM2,10)
              ENDIF

C             CHECK THAT DIMENSIONS ARE THE SAME FOR BOTH FILES
              IF (NX1 .NE. NX2 .OR. 
     &            NY1 .NE. NY2 .OR.
     &            NZ1 .NE. NZ2) THEN
C                 ERROR. IMAGES DO NOT HAVE SAME DIMENSIONS
                  CALL ERRT(1,'CORR1',NE)
                  GOTO 998
              ENDIF
           ENDIF
        ENDIF

C       -------------------------------------------------- FIRST INPUT
        ALLOCATE(QK1(LS1/2,NY1,NZ1), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           MWANT = LS1 / 2 * NY1 * NZ1 
           CALL ERRT(46,'CORR1, QK1',MWANT)
           GOTO 996
        ENDIF

        CALL READV(LUN1,QK1,LS1,NY1,LREC1,NY1,NZ1)

        IF (FCHAR(4:4) == 'N' .AND. IMAMI1 .NE. 1) THEN
           !CALL NRMS(QK1,LS1,NX1,NY1,NZ1,SIG1)
           CALL NORMVALSP(QK1,NX1,NY1,NZ1,
     &                        LS1,  NY1,NZ1, 
     &                        DAV,DSIG, .TRUE.)
           SIG1 = DSIG
        ENDIF

        IF (IFORM1 > 0)  THEN
C          REAL SPACE INPUT, TRANSFORM IT TO FOURIER
           INV          = +1
           SPIDER_SIGN  = .TRUE.
           SPIDER_SCALE = .TRUE.
           CALL FMRS(QK1, NX1,NY1,NZ1,IPLAN, 
     &               SPIDER_SIGN,SPIDER_SCALE, INV,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(101,'FOURIER TRANSFORM FAILED',NE)
              GOTO 996
           ENDIF
        ENDIF

        IF (FCHAR(4:4) == 'N')  THEN
           QK1(1,1,1) = (0.0,0.0)
        ENDIF

C       ------------------------------------------------- SECOND INPUT
        IF (.NOT. ACASE .AND. IFORM2 > 0)  THEN
C          CROSS-CORRELATION WITH REAL IMAGES, USE IN-CORE
           BOTH_INC = .TRUE.

           ALLOCATE(QK2(LS2/2,NY2,NZ2), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              MWANT = LS2 / 2 * NY2 * NZ2 
              CALL ERRT(46,'CORR1, QK2',MWANT)
              GOTO 998
           ENDIF

           CALL READV(LUN2,QK2,LS2,NY2,NX2,NY2,NZ2)

           IF (FCHAR(4:4) == 'N' .AND. IMAMI2 .NE. 1) THEN
              !CALL NRMS(QK2,LS2,NX2,NY2,NZ2,SIG2)
              CALL NORMVALSP(QK2,NX2,NY2,NZ2,
     &                           LS2,  NY2,NZ2, 
     &                           DAV,DSIG, .TRUE.)
              SIG2 = DSIG
           ENDIF
              
C          REAL SPACE INPUT, TRANSFORM IT TO FOURIER
           INV          = +1
           SPIDER_SIGN  = .TRUE.
           SPIDER_SCALE = .TRUE.
           CALL FMRS(QK2, NX2,NY2,NZ2, IPLAN, 
     &               SPIDER_SIGN,SPIDER_SCALE, INV,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(101,FOURIER TRANSFORM FAILED,NE)
              GOTO 996
           ENDIF
        ELSE
           BOTH_INC = .FALSE.

           MWANT = NX1 + 2 - MOD(NX1,2) / 2 
           ALLOCATE (QKB(MWANT), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN 
              CALL ERRT(46,'CORR1, QKB',MWANT)
              GOTO 996
           ENDIF
        ENDIF

C       OPEN OUTPUT FILE
        IFORM = IFORM3
        MAXIM = 0
        CALL OPFILEC(LUN1,.TRUE.,FILNAM1,LUN3,'U',IFORM3,
     &               NX3,NY1,NZ1,MAXIM,'OUTPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 996

C       -------------------------------------------------- CORRELATION

        LS = NX1 + 2 - MOD(NX1,2)

        IF (ACASE)  THEN
C          'AC' AUTO CORRELATION ------------------------------- 'AC'
           IF (NZ1 .LE. 1)  THEN
C            IMAGE INPUT
             IF (FCHAR(4:4) == 'S' .OR. FCHAR(4:5)== 'NS')  THEN
                CALL ACRS_2S(QK1, LS,NX1,NY1)
             ELSE            
                CALL ACRS_2(QK1,  LS,NX1,NY1)
             ENDIF
           ELSE
C            VOLUME INPUT
             IF (FCHAR(4:4) == 'S' .OR. FCHAR(4:5) == 'NS')  THEN
                CALL ACRS_3S(QK1, LS,NX1,NY1,NZ1)
             ELSE            
                CALL ACRS_3(QK1,  LS,NX1,NY1,NZ1)
             ENDIF
           ENDIF
           SIG2 = SIG1

        ELSEIF (FCHAR(4:4) == 'H')  THEN
C          'CC' PHASE CROSS CORRELATION --------------------- 'CC H'

           IF (BOTH_INC)  THEN
C             BOTH FILES ARE AVAILABLE IN BUFFERS

              IF (NZ1 > 1) THEN
                 CALL CCRS_PH_3(QK1,QK2, LS,NX1,NY1,NZ1,IRTFLG)
              ELSE
                 CALL CCRS_PH_2(QK1,QK2, LS,NX1,NY1,IRTFLG)
              ENDIF
              IF (IRTFLG .NE. 0) GOTO 996

           ELSE 
C             MUST READ SECOND FILE
              IF (NZ1 > 1) THEN
                 CALL CCRD_PH_3(LUN2,QK1,QKB, LS,NX1,NY1,NZ1)
              ELSE
                 CALL CCRD_PH_2(LUN2,QK1,QKB, LS,NX1,NY1)
              ENDIF
           ENDIF

        ELSEIF (FCHAR(1:2) == 'CC')  THEN
C          'CC' CROSS CORRELATION ------------------------------ 'CC'

           IF (BOTH_INC)  THEN
C             BOTH FILES ARE AVAILABLE IN BUFFERS
              SPIDER_SIGN  = .TRUE.
              SPIDER_SCALE = .TRUE.
              CALL CCRS(QK1,QK2, LS,NX1,NY1,NZ1,
     &                  SPIDER_SIGN,SPIDER_SCALE, IRTFLG)
              IF (IRTFLG .NE. 0) THEN
                 CALL ERRT(101,'CCRS FAILED',NE)
                 GOTO 996
              ENDIF

           ELSE 
C             MUST READ SECOND FILE
              IF (NZ1 > 1) THEN
                 CALL CCRD_3(LUN2,QK1,QKB, LS,NX1,NY1,NZ1)
              ELSE
                 CALL CCRD_2(LUN2,QK1,QKB, LS,NX1,NY1)
              ENDIF
           ENDIF

        ELSEIF (FCHAR(1:2) == 'CN')  THEN
C          'CN' CONVOLUTION, (NOT CORRELATION)
           IF (BOTH_INC)  THEN
C             BOTH FILES ARE AVAILABLE IN BUFFERS
              IF (NZ1 > 1) THEN
                 CALL CNRS_3(QK1,QK2, LS,NX1,NY1,NZ1)
              ELSE
                 CALL CNRS_2(QK1,QK2, LS,NX1,NY1)
              ENDIF
           ELSE
C             MUST READ SECOND FILE
              IF (NZ1 > 1) THEN
                 CALL CNRD_3(LUN2,QK1,QKB, LS,NX1,NY1,NZ1)
              ELSE
                 CALL CNRD_2(LUN2,QK1,QKB, LS,NX1,NY1)
              ENDIF
           ENDIF
        ENDIF

C       ------------------------------------------------------ OUTPUT
        IF (FCHAR(4:4) == 'N') THEN
C          NORMALIZE  HERE
           FAN = 1.0 / (NX1*NY1*FLOAT(NZ1)-1.0) / SIG1 / SIG2
           QK1 = QK1 * FAN
        ENDIF

C       THIS ONLY WRITES FIRST LS1 VALUES FROM EACH ROW
        CALL WRITEV(LUN3,QK1,LS1,NY1,NX1,NY1,NZ1)

996     IF (ALLOCATED(QKB)) DEALLOCATE (QKB)
        IF (ALLOCATED(QK1)) DEALLOCATE(QK1)
        IF (ALLOCATED(QK2)) DEALLOCATE(QK2)       

998     CLOSE(LUN3)
        CLOSE(LUN2)
        CLOSE(LUN1)

        RETURN
        END
@


1.51
log
@==,  input1
@
text
@d20 1
a20 1
C=* Email: spider@@wadsworth.org                                        *
@


1.50
log
@nrms --> normvalsp, cosmetic
@
text
@d13 1
d18 1
a18 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d76 3
a78 3
        INTEGER, PARAMETER    :: LUN1   = 21
        INTEGER, PARAMETER    :: LUN2   = 22
        INTEGER, PARAMETER    :: LUN3   = 23
d86 1
a86 1
          IF (FCHAR(1:2) .EQ. FUNC(IFUNC)(1:2)) THEN
d96 1
a96 1
        IF (FCHAR(1:4) .EQ. 'CC C')  THEN
d99 1
a99 1
     &                NSAM1,NROW1,NSLICE1,MAXIM,'INPUT1',.TRUE.,IRTFLG)
d104 1
a104 1
     &                NSAM2,NROW2,NSLICE2,MAXIM,'INPUT2',.TRUE.,IRTFLG)
d108 3
a110 3
           ELSEIF (NSAM1   .NE. NSAM2 .OR.
     &             NROW1   .NE. NROW2 .OR.
     &             NSLICE1 .NE. NSLICE2) THEN
d117 1
a117 1
     &                NSAMM,NROWM,NSLICEM,MAXIM,'MASK',.FALSE.,IRTFLG)
d120 3
a122 3
           IF (NSAM1   .NE. NSAMM .OR. 
     &         NROW1   .NE. NROWM .OR.
     &         NSLICE1 .NE. NSLICEM) THEN
d127 2
a128 2
           CALL CCC(LUN1,FILNAM1,NSAM1,NROW1,NSLICE1,
     &              LUN2,FILNAM2,NSAM2,NROW2,NSLICE2,
d134 1
a134 1
        ELSEIF (FCHAR(1:5) .EQ. 'CC MS') THEN
d140 2
a141 2
        ELSEIF (FCHAR(1:5) .EQ. 'AC MS')  THEN
          IF (FCHAR(6:6) .EQ. 'S')  THEN
d151 1
a151 1
        ELSEIF (FCHAR(1:4).EQ.'CC P')  THEN
d165 1
a165 1
     &               NSAM1,NROW1,NSLICE1,MAXIM,'INPUT',.TRUE.,IRTFLG)
d168 1
a168 1
        IF (FCHAR(4:4) .EQ. 'N' .AND. IFORM .LT. 0) THEN
d174 1
a174 1
        ELSEIF (FCHAR(4:4) .EQ. 'N')  THEN
d182 1
a182 1
        IF (IFORM1 .GT. 0)  THEN
d184 2
a185 2
           LS1    = NSAM1 + 2 - MOD(NSAM1,2)
           LREC1  = NSAM1
d187 1
a187 1
           NSAM3  = NSAM1
d190 4
a193 4
           LS1   = NSAM1
           LREC1 = NSAM1
           NSAM1 = NSAM1 - MOD(-IFORM1,10)
           IF (IFORM1 .GT. -20)  THEN
d198 1
a198 1
           NSAM3 = NSAM1
d201 1
a201 1
        IF (FCHAR(1:2) .EQ. 'AC') THEN
d210 1
a210 1
           IF (FILNAM1 .EQ. FILNAM2) THEN
d218 1
a218 1
     &                NSAM2,NROW2,NSLICE2,MAXIM,NULL,.TRUE.,IRTFLG)
d224 1
a224 1
              IF (FCHAR(4:4) .EQ. 'N' .AND. IFORM .LT. 0) THEN
d230 1
a230 1
              ELSEIF (FCHAR(4:4) .EQ. 'N')  THEN
d236 1
a236 1
              IF (IFORM2 .GT. 0)  THEN
d238 1
a238 1
                 LS2   = NSAM2 + 2 - MOD(NSAM2,2)
d241 2
a242 2
                 LS2   = NSAM2
                 NSAM2 = NSAM2 - MOD(-IFORM2,10)
d246 3
a248 2
              IF (NSAM1   .NE. NSAM2 .OR. NROW1 .NE. NROW2 .OR.
     &            NSLICE1 .NE. NSLICE2) THEN
d257 1
a257 1
        ALLOCATE(QK1(LS1/2,NROW1,NSLICE1), STAT=IRTFLG)
d259 1
a259 1
           MWANT = LS1 / 2 * NROW1 * NSLICE1 
d264 1
a264 1
        CALL READV(LUN1,QK1,LS1,NROW1,LREC1,NROW1,NSLICE1)
d266 4
a269 4
        IF (FCHAR(4:4) .EQ. 'N' .AND. IMAMI1 .NE. 1) THEN
           !CALL NRMS(QK1,LS1,NSAM1,NROW1,NSLICE1,SIG1)
           CALL NORMVALSP(QK1,NSAM1,NROW1,NSLICE1,
     &                        LS1,  NROW1,NSLICE1, 
d274 1
a274 1
        IF (IFORM1 .GT. 0)  THEN
d279 1
a279 1
           CALL FMRS(QK1, NSAM1,NROW1,NSLICE1,IPLAN, 
d287 1
a287 1
        IF (FCHAR(4:4) .EQ. 'N')  THEN
d292 1
a292 1
        IF (.NOT. ACASE .AND. IFORM2 .GT. 0)  THEN
d296 1
a296 1
           ALLOCATE(QK2(LS2/2,NROW2,NSLICE2), STAT=IRTFLG)
d298 1
a298 1
              MWANT = LS2 / 2 * NROW2 * NSLICE2 
d303 1
a303 1
           CALL READV(LUN2,QK2,LS2,NROW2,NSAM2,NROW2,NSLICE2)
d306 3
a308 3
              !CALL NRMS(QK2,LS2,NSAM2,NROW2,NSLICE2,SIG2)
              CALL NORMVALSP(QK2,NSAM2,NROW2,NSLICE2,
     &                           LS2,  NROW2,NSLICE2, 
d317 1
a317 1
           CALL FMRS(QK2, NSAM2,NROW2,NSLICE2, IPLAN, 
d326 1
a326 1
           MWANT = NSAM1 + 2 - MOD(NSAM1,2) / 2 
d338 1
a338 1
     &               NSAM3,NROW1,NSLICE1,MAXIM,'OUTPUT',.TRUE.,IRTFLG)
d343 1
a343 1
        LS = NSAM1 + 2 - MOD(NSAM1,2)
d347 1
a347 1
           IF (NSLICE1 .LE. 1)  THEN
d349 2
a350 2
             IF (FCHAR(4:4) .EQ. 'S' .OR. FCHAR(4:5).EQ. 'NS')  THEN
                CALL ACRS_2S(QK1, LS,NSAM1,NROW1)
d352 1
a352 1
                CALL ACRS_2(QK1,  LS,NSAM1,NROW1)
d356 2
a357 2
             IF (FCHAR(4:4) .EQ. 'S' .OR. FCHAR(4:5) .EQ. 'NS')  THEN
                CALL ACRS_3S(QK1, LS,NSAM1,NROW1,NSLICE1)
d359 1
a359 1
                CALL ACRS_3(QK1,  LS,NSAM1,NROW1,NSLICE1)
d364 1
a364 1
        ELSEIF (FCHAR(4:4) .EQ. 'H')  THEN
d370 2
a371 2
              IF (NSLICE1 .GT. 1) THEN
                 CALL CCRS_PH_3(QK1,QK2, LS,NSAM1,NROW1,NSLICE1,IRTFLG)
d373 1
a373 1
                 CALL CCRS_PH_2(QK1,QK2, LS,NSAM1,NROW1,IRTFLG)
d379 2
a380 2
              IF (NSLICE1 .GT. 1) THEN
                 CALL CCRD_PH_3(LUN2,QK1,QKB, LS,NSAM1,NROW1,NSLICE1)
d382 1
a382 1
                 CALL CCRD_PH_2(LUN2,QK1,QKB, LS,NSAM1,NROW1)
d386 1
a386 1
        ELSEIF (FCHAR(1:2) .EQ. 'CC')  THEN
d393 1
a393 1
              CALL CCRS(QK1,QK2, LS,NSAM1,NROW1,NSLICE1,
d402 2
a403 2
              IF (NSLICE1 .GT. 1) THEN
                 CALL CCRD_3(LUN2,QK1,QKB, LS,NSAM1,NROW1,NSLICE1)
d405 1
a405 1
                 CALL CCRD_2(LUN2,QK1,QKB, LS,NSAM1,NROW1)
d409 1
a409 1
        ELSEIF (FCHAR(1:2) .EQ. 'CN')  THEN
d413 2
a414 2
              IF (NSLICE1 .GT. 1) THEN
                 CALL CNRS_3(QK1,QK2, LS,NSAM1,NROW1,NSLICE1)
d416 1
a416 1
                 CALL CNRS_2(QK1,QK2, LS,NSAM1,NROW1)
d420 2
a421 2
              IF (NSLICE1 .GT. 1) THEN
                 CALL CNRD_3(LUN2,QK1,QKB, LS,NSAM1,NROW1,NSLICE1)
d423 1
a423 1
                 CALL CNRD_2(LUN2,QK1,QKB, LS,NSAM1,NROW1)
d429 1
a429 1
        IF (FCHAR(4:4) .EQ. 'N') THEN
d431 1
a431 1
           FAN = 1.0 / (NSAM1*NROW1*FLOAT(NSLICE1)-1.0) / SIG1 / SIG2
d436 1
a436 1
        CALL WRITEV(LUN3,QK1,LS1,NROW1,NSAM1,NROW1,NSLICE1)
@


1.49
log
@irtflg on phase correl returns
@
text
@d12 1
d39 1
a39 1
C        ---> NRMS
d43 1
a43 1
C        ---> NRMS
a52 1
#ifdef SP_LIBFFTW3
a54 1
#endif
d61 3
a63 3
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: QK1
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: QK2
        COMPLEX, ALLOCATABLE, DIMENSION(:)     :: QKB
d65 1
a65 1
        CHARACTER(LEN=1)                       :: NULL
d68 1
a68 1
        CHARACTER(LEN=2),DIMENSION(NFUNC)      :: FUNC
d70 8
a77 3
        LOGICAL                                :: ACASE, BOTH_INC
        LOGICAL                                :: SPIDER_SIGN
        LOGICAL                                :: SPIDER_SCALE
a79 1
        DATA            LUN1,LUN2,LUN3/21,22,23/
a80 1
        NULL   = CHAR(0)
d264 7
a270 2
        IF (FCHAR(4:4) .EQ. 'N' .AND. IMAMI1 .NE. 1)
     &     CALL NRMS(QK1,LS1,NSAM1,NROW1,NSLICE1,SIG1)
d303 7
a309 2
           IF (FCHAR(4:4) .EQ. 'N' .AND. IMAMI2 .NE. 1)
     &        CALL NRMS(QK2,LS2,NSAM2,NROW2,NSLICE2,SIG2)
@


1.48
log
@NSLICE --> NSLICE1 bug, ccrd_ph bug
@
text
@d357 1
a357 1
                 CALL CCRS_PH_3(QK1,QK2, LS,NSAM1,NROW1,NSLICE1)
d359 1
a359 1
                 CALL CCRS_PH_2(QK1,QK2, LS,NSAM1,NROW1)
d361 2
@


1.47
log
@cc h
@
text
@d267 1
a267 1
           INV = +1
d356 1
a356 1
              IF (NSLICE .GT. 1) THEN
d363 2
a364 2
              IF (NSLICE .GT. 1) THEN
                 CALL CCRD_3(LUN2,QK1,QKB, LS,NSAM1,NROW1,NSLICE1)
d366 1
a366 1
                 CALL CCRD_2(LUN2,QK1,QKB, LS,NSAM1,NROW1)
d386 1
a386 1
              IF (NSLICE .GT. 1) THEN
d397 1
a397 1
              IF (NSLICE .GT. 1) THEN
d404 1
a404 1
              IF (NSLICE .GT. 1) THEN
@


1.46
log
@GPL_2010
@
text
@d9 3
a11 2
C               MOD PGI COMPILER BUG               FEB 08 ArDean Leith
C               INPLACE PARAMETERS                 APR 09 ArDean Leith
d16 1
a16 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d101 1
a101 1
     &                NSAM2,NROW2,NSLICE2,MAXIM,'INPUT1',.TRUE.,IRTFLG)
a151 4
C          ------------------------------------------------------ CC H
        ELSEIF (FCHAR(4:4) .EQ. 'H') THEN
           CALL ERRT(46,'OPERATION -CC H- NO LONGER SUPPORTED',IER)
           RETURN
d155 4
a158 1
C       -------------------------------------------------------- OTHER 
d332 1
a332 1
C          'AC' AUTO CORRELATION
d350 20
d371 1
a371 1
C          'CC' CROSS CORRELATION
@


1.45
log
@*** empty log message ***
@
text
@a11 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
d13 5
a17 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d19 1
a19 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d24 1
a24 1
C=* This program is distributed in the hope that it will be useful,    *
d26 1
a26 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a27 1
C=*                                                                    *
d29 1
a29 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.44
log
@iplan
@
text
@d10 1
d13 1
a13 1
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
a92 1

d134 1
a134 1
        ELSEIF(FCHAR(1:5) .EQ. 'CC MS') THEN
d151 1
a151 1
        ELSEIF(FCHAR(1:4).EQ.'CC P')  THEN
d157 2
a158 2
            CALL ERRT(46,'OPERATION -CC H- NO LONGER SUPPORTED',IER)
            RETURN
d185 1
a185 1
           LS1    = NSAM1+2-MOD(NSAM1,2)
d193 1
a193 1
           NSAM1 = NSAM1-MOD(-IFORM1,10)
d231 1
a231 1
              ELSEIF(FCHAR(4:4) .EQ. 'N')  THEN
d239 1
a239 1
                 LS2   = NSAM2+2-MOD(NSAM2,2)
d243 1
a243 1
                 NSAM2 = NSAM2-MOD(-IFORM2,10)
d259 1
a259 1
           MWANT = LS1/2*NROW1*NSLICE1 
d277 1
a277 1
              CALL ERRT(101,FOURIER TRANSFORM FAILED,NE)
d316 2
a317 1
           ALLOCATE (QKB((NSAM1+2-MOD(NSAM1,2))/2), STAT=IRTFLG)
a318 1
              MWANT = NSAM1+2-MOD(NSAM1,2)/2 
d324 7
d333 2
a334 1
        LS = NSAM1+2-MOD(NSAM1,2)
d337 2
a338 1
           IF (NSLICE1.LE.1)  THEN
d340 1
a340 1
                CALL ACRS_2S(QK1,QK1, LS,NSAM1,NROW1)
d342 1
a342 1
                CALL ACRS_2(QK1,QK1, LS,NSAM1,NROW1)
d345 1
d347 1
a347 1
                CALL ACRS_3S(QK1,QK1, LS,NSAM1,NROW1,NSLICE1)
d349 1
a349 1
                CALL ACRS_3(QK1,QK1, LS,NSAM1,NROW1,NSLICE1)
d352 1
d358 1
d361 1
a361 1
              CALL CCRS(QK1,QK2,QK1, LS,NSAM1,NROW1,NSLICE1,
d368 7
a374 4
           ELSEIF (NSLICE1 .LE. 1)  THEN
              CALL CCRD_2(LUN2,QK1,QKB,QK1, LS,NSAM1,NROW1)
           ELSE
              CALL CCRD_3(LUN2,QK1,QKB,QK1, LS,NSAM1,NROW1,NSLICE1)
d378 5
a382 4
C          'CN' CONVOLUTION, NOT CORRELATION
           IF (NSLICE1.LE.1)  THEN
              IF (BOTH_INC)  THEN
                 CALL CNRS_2(QK1,QK2,QK1, LS,NSAM1,NROW1)
d384 1
a384 1
                 CALL CNRD_2(LUN2,QK1,QKB,QK1, LS,NSAM1,NROW1)
d387 3
a389 2
              IF (BOTH_INC)  THEN
                 CALL CNRS_3(QK1,QK2,QK1, LS,NSAM1,NROW1,NSLICE1)
d391 1
a391 1
                 CALL CNRD_3(LUN2,QK1,QKB,QK1, LS,NSAM1,NROW1,NSLICE1)
a396 1
        IF (ACASE)  SIG2 = SIG1
d398 1
a398 1
C          NORMALIZATION ROUTINE HERE
a402 7
C       SAVE RESULTS IN OUTPUT FILE
        IFORM = IFORM3
        MAXIM = 0
        CALL OPFILEC(LUN1,.TRUE.,FILNAM1,LUN3,'U',IFORM3,
     &               NSAM3,NROW1,NSLICE1,MAXIM,'OUTPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 996

@


1.43
log
@ used ccrs
@
text
@d54 5
d274 1
a274 1
           CALL FMRS(QK1, NSAM1,NROW1,NSLICE1,0.0D0, 
d307 1
a307 1
           CALL FMRS(QK2, NSAM2,NROW2,NSLICE2, 0.0D0, 
@


1.42
log
@parameters on ccrs... calls
@
text
@d3 7
a9 7
C CORR1.F               REWRITTEN              AUG 96 PP
C                       ADDED 'CC H'           MAR 02 ARDEAN LEITH
C                       OPFILEC                FEB 03 ARDEAN LEITH
C                       'CC MS' bug            OCT 03 ARDEAN LEITH
C                       MOD PGI COMPILER BUG   FEB 19 2008 ArDean Leith
C                       REMOVED PHASE          FEB 19 2008 ArDean Leith
C
d36 2
d41 1
a41 1
C        ---> FMRS_2  
d45 3
a47 3
C        ---> FMRS_2  
C                                        
C        ---> CCRS_2
d57 1
a57 1
        CHARACTER(LEN=MAXNAM) ::  FILNAM1,FILNAM2,FILNAMM
d63 1
a63 1
        CHARACTER(LEN=1) :: NULL
d66 1
a66 1
        CHARACTER(LEN=2),DIMENSION(NFUNC) :: FUNC
d68 3
a70 1
        LOGICAL ::      ACASE, BOTH_INC
d103 3
a105 2
           ELSEIF (NSAM1.NE.NSAM2.OR.NROW1.NE.NROW2 .OR.
     &             NSLICE1.NE.NSLICE2) THEN
d115 3
a117 2
           IF (NSAM1.NE.NSAMM.OR.NROW1.NE.NROWM.OR.NSLICE1.NE.NSLICEM)
     &         THEN
d130 1
d136 2
a137 1
           IF (FCHAR(6:6) .EQ. 'S')  THEN
d140 1
d147 1
a149 1

d152 1
a152 1
            CALL ERRT(46,'CC H NO LONGER SUPPORTED',IER)
d156 1
d171 2
a172 1
           IMAMI1=IMAMI
d178 2
a179 1
        IF (IFORM1.GT.0)  THEN
d185 1
d198 1
a198 1
C          AUTO CORRELATION WANTED
d227 1
d233 1
d236 1
d251 2
a252 35
 
        IF (.NOT. ACASE .AND. IFORM2 .GT. 0)  THEN
           BOTH_INC = .TRUE.
        ELSE
           BOTH_INC=.FALSE.
        ENDIF
        
        IF (.NOT. ACASE ) THEN
           ALLOCATE (QK2(LS2/2,NROW2,NSLICE2), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN 
              CALL ERRT(46,'CORR1, QK2',IER)
              GOTO 998
           ENDIF
        ENDIF

        IF (.NOT.ACASE .AND. IFORM2 .GT. 0)  THEN
C          NOT AUTOCORRELATION, REAL INPUT DATA
           CALL READV(LUN2,QK2,LS2,NROW2,NSAM2,NROW2,NSLICE2)

           IF (FCHAR(4:4).EQ.'N' .AND. IMAMI2.NE.1)
     &        CALL NRMS(QK2,LS2,NSAM2,NROW2,NSLICE2,SIG2)
              
           INV = +1
           IF (IFORM2 .EQ. 1)  THEN
              CALL FMRS_2(QK2,NSAM2,NROW2,INV)
           ELSE
              CALL FMRS_3(QK2,NSAM2,NROW2,NSLICE2,INV)
           ENDIF
           IF (INV .EQ. 0)  THEN
              CALL ERRT(38,FCHAR(1:2),NE)
              GOTO 996
           ENDIF
        ENDIF

        ALLOCATE (QK1(LS1/2,NROW1,NSLICE1), STAT=IRTFLG)
d254 2
a255 1
           CALL ERRT(46,'CORR1, QK1',IER)
d259 1
a259 1
        CALL READV (LUN1,QK1,LS1,NROW1,LREC1,NROW1,NSLICE1)
d261 1
a261 1
        IF (FCHAR(4:4).EQ.'N' .AND. IMAMI1.NE.1)
d265 1
a265 1
C          NON-FOURIER INPUT
d267 6
a272 7
           IF (IFORM1 .EQ. 1)  THEN
              CALL FMRS_2(QK1,NSAM1,NROW1,INV)
           ELSE
              CALL FMRS_3(QK1,NSAM1,NROW1,NSLICE1,INV)
           ENDIF
           IF (INV .EQ. 0)  THEN
              CALL ERRT(38,FCHAR(1:2),NE)
d281 36
a316 4
        ALLOCATE (QKB((NSAM1+2-MOD(NSAM1,2))/2), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'CORR1, QKB',IER)
           GOTO 996
d319 2
d323 1
d339 1
d341 8
a348 5
           IF (NSLICE1 .LE. 1)  THEN
              IF (BOTH_INC)  THEN
                 CALL CCRS_2(QK1,QK2,QK1, LS,NSAM1,NROW1)
              ELSE
                 CALL CCRD_2(LUN2,QK1,QKB, LS,QK1,NSAM1,NROW1)
d350 3
d354 1
a354 5
              IF (BOTH_INC)  THEN
                 CALL CCRS_3(QK1,QK2,QK1, LS,NSAM1,NROW1,NSLICE1)
              ELSE
                 CALL CCRD_3(LUN2,QK1,QKB,QK1, LS,NSAM1,NROW1,NSLICE1)
              ENDIF
d358 1
d367 1
a367 1
                 CALL CNRS_3(QK1,QK2,QK1,NSAM1, LS,NROW1,NSLICE1)
d374 1
a374 1
        IF (.NOT. ACASE)  CLOSE(LUN2)
d377 3
a379 3
C           NORMALIZATION ROUTINE HERE
            FAN = 1.0 / (NSAM1*NROW1*FLOAT(NSLICE1)-1.0) / SIG1 / SIG2
            QK1 = QK1 * FAN
d382 1
d389 1
@


1.41
log
@PGI MOD in declare bug on 7.1
@
text
@d308 1
a308 1
                CALL ACRS_2S(QK1,QK1,LS,NSAM1,NROW1)
d310 1
a310 1
                CALL ACRS_2(QK1,QK1,LS,NSAM1,NROW1)
d314 1
a314 1
                CALL ACRS_3S(QK1,QK1,LS,NSAM1,NROW1,NSLICE1)
d316 1
a316 1
                CALL ACRS_3(QK1,QK1,LS,NSAM1,NROW1,NSLICE1)
d324 1
a324 2
                 CALL CCRS_2(QK1,QK2,QK1,LS,NSAM1,NROW1)

d326 1
a326 2
                 CALL CCRD_2(LUN2,QK1,QKB,LS,QK1,NSAM1,NROW1)

d330 1
a330 1
                 CALL CCRS_3(QK1,QK2,QK1,LS,NSAM1,NROW1,NSLICE1)
d332 1
a332 1
                 CALL CCRD_3(LUN2,QK1,QKB,QK1,LS,NSAM1,NROW1,NSLICE1)
d339 1
a339 1
                 CALL CNRS_2(QK1,QK2,QK1,LS,NSAM1,NROW1)
d341 1
a341 1
                 CALL CNRD_2(LUN2,QK1,QKB,QK1,LS,NSAM1,NROW1)
d345 1
a345 1
                 CALL CNRS_3(QK1,QK2,QK1,NSAM1,LS,NROW1,NSLICE1)
d347 1
a347 1
                 CALL CNRD_3(LUN2,QK1,QKB,QK1,LS,NSAM1,NROW1,NSLICE1)
@


1.40
log
@GPL License fixed
@
text
@d3 6
a8 4
C CORR1.F                       REWRITTEN     AUG 96 PP
C                               ADDED 'CC H'  MAR 02 ARDEAN LEITH
C                               OPFILEC       FEB 03 ARDEAN LEITH
C                               'CC MS' bug   OCT 03 ARDEAN LEITH
d12 1
a12 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a35 2
C IMAGE_PROCESSING_ROUTINE
C
d39 2
a40 2
C        ---> FMRS_2 ---> FMRS_2R ----> FMRS_1 --> FFTMCF
C                                       FFTMCF
d43 2
a44 2
C        ---> FMRS_2 ---> FMRS_2R ----> FMRS_1 --> FFTMCF
C                                       FFTMCF
d66 1
a66 1
        LOGICAL ::      ACASE, BOTH_INC,PHASE
d140 5
a234 1
        PHASE = (FCHAR(4:4) .EQ. 'H')
a277 1

d304 1
d308 1
a308 1
                CALL ACRS_2S(QK1,QK1,NSAM1,NROW1)
d310 1
a310 1
                CALL ACRS_2(QK1,QK1,NSAM1,NROW1)
d314 1
a314 1
                CALL ACRS_3S(QK1,QK1,NSAM1,NROW1,NSLICE1)
d316 1
a316 1
                CALL ACRS_3(QK1,QK1,NSAM1,NROW1,NSLICE1)
d323 2
a324 8
              IF (PHASE .AND. BOTH_INC)  THEN
                 CALL CCRS_PH_2(QK1,QK2,QK1,NSAM1,NROW1)

              ELSEIF (PHASE) THEN
                 CALL CCRD_PH_2(LUN2,QK1,QKB,QK1,NSAM1,NROW1)

              ELSEIF (BOTH_INC)  THEN
                 CALL CCRS_2(QK1,QK2,QK1,NSAM1,NROW1)
d327 1
a327 1
                 CALL CCRD_2(LUN2,QK1,QKB,QK1,NSAM1,NROW1)
d331 2
a332 9
              IF (PHASE .AND. BOTH_INC)  THEN
                 CALL CCRS_PH_3(QK1,QK2,QK1,NSAM1,NROW1,NSLICE1)

              ELSEIF (PHASE)  THEN
                 CALL CCRD_PH_3(LUN2,QK1,QKB,QK1,NSAM1,NROW1,NSLICE1)

              ELSEIF (BOTH_INC)  THEN
                 CALL CCRS_3(QK1,QK2,QK1,NSAM1,NROW1,NSLICE1)

d334 1
a334 2
                 CALL CCRD_3(LUN2,QK1,QKB,QK1,NSAM1,NROW1,NSLICE1)

d341 1
a341 1
                 CALL  CNRS_2(QK1,QK2,QK1,NSAM1,NROW1)
d343 1
a343 1
                 CALL CNRD_2(LUN2,QK1,QKB,QK1,NSAM1,NROW1)
d347 1
a347 1
                 CALL CNRS_3(QK1,QK2,QK1,NSAM1,NROW1,NSLICE1)
d349 1
a349 1
                 CALL CNRD_3(LUN2,QK1,QKB,QK1,NSAM1,NROW1,NSLICE1)
@


1.39
log
@HRI GPL License used
@
text
@a8 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d12 1
a12 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a31 6

C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.38
log
@cc ms not working (never calls)
@
text
@d10 24
@


1.37
log
@irtflg set to 0
@
text
@d6 1
d9 6
a14 6
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK        *
C *  COPYRIGHT (C)1981, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY  * 
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH         *
C *    RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS             *
C *    OR USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN        *
C *    APPROVAL OF HEALTH RESEARCH INC.                                *
d62 1
a62 1
        END DO
d99 3
a101 3
           CALL  CCC(LUN1,FILNAM1,NSAM1,NROW1,NSLICE1,
     &               LUN2,FILNAM2,NSAM2,NROW2,NSLICE2,
     &               LUN3,FILNAMM)
d106 1
a106 1
        ELSEIF(FCHAR(1:4).EQ.'CC MS')  THEN
d132 1
a132 1
        IF (FCHAR(4:4).EQ.'N' .AND. IFORM.LT.0) THEN
d134 1
a134 1
          CALL ERRT(101, 
d138 1
a138 1
        ELSEIF (FCHAR(4:4).EQ.'N')  THEN
d191 1
a191 1
              ELSEIF(FCHAR(4:4).EQ.'N')  THEN
d233 1
a233 1
           IF (FCHAR(4:4).EQ.'N'.AND.IMAMI2.NE.1)
d237 1
a237 1
           IF (IFORM2.EQ.1)  THEN
d286 1
a286 1
             IF (FCHAR(4:4).EQ.'S'.OR.FCHAR(4:5).EQ.'NS')  THEN
d292 1
a292 1
             IF (FCHAR(4:4).EQ.'S'.OR.FCHAR(4:5).EQ.'NS')  THEN
d304 1
d307 1
d310 1
d313 1
d318 1
d321 1
d324 1
d327 1
@


1.36
log
@header source wrong in opfilec
@
text
@d54 1
@


1.35
log
@opfilec
@
text
@d347 1
a347 1
        CALL OPFILEC(0,.TRUE.,FILNAM1,LUN3,'U',IFORM3,
d349 1
a349 1
        IF (IRTFLG .EQ. -1) RETURN
@


1.34
log
@new ccrs & ccrd phase cc routines added.
@
text
@d5 1
d35 1
d37 2
d41 7
a47 5
        COMPLEX, ALLOCATABLE, DIMENSION(:) :: QKB
        CHARACTER *81   FILNAM1,FILNAM2
        CHARACTER *1    NULL
        PARAMETER       (NFUNC=3)
        CHARACTER *2    FUNC(NFUNC)
d49 1
d68 4
a71 4
        IF (FCHAR(1:4).EQ.'CC C')  THEN
           MAXIM1 = 0
           CALL OPFIL(.TRUE.,FILNAM1,LUN1,'O',NSAM1,NROW1,NSLICE1,
     &                   MAXIM1,'INPUT1',.TRUE.,IRTFLG)
d74 3
a76 3
           MAXIM2 = 0
           CALL OPFIL(.TRUE.,FILNAM2,LUN2,'O',NSAM2,NROW2,NSLICE2,
     &                   MAXIM2,'INPUT2',.TRUE.,IRTFLG)
d78 1
a78 3
              CLOSE(LUN1)
              RETURN
           ENDIF
d80 4
a83 6
           IF (NSAM1.NE.NSAM2.OR.NROW1.NE.NROW2
     &                              .OR.NSLICE1.NE.NSLICE2) THEN
              CALL ERRT(1,'CORR1.F',NE)
              CLOSE(LUN1)
              CLOSE(LUN2)
              RETURN
d86 10
d98 6
a103 3
     &                           LUN2,FILNAM2,NSAM2,NROW2,NSLICE2)
           RETURN
C       --------------------------------------------------------- CC MS
d107 4
a110 3
C       --------------------------------------------------------- AC MS
        ELSEIF(FCHAR(1:5).EQ.'AC MS')  THEN
           IF(FCHAR(6:6).EQ.'S')  THEN
d116 2
a117 1
C       --------------------------------------------------------- CC P
d124 5
a128 4
C       OPEN FIRST INPUT FILE, FOURIER INPUT ALLOWED 
        CALL OPFIL(.TRUE.,FILNAM1,LUN1,'O',NSAM1,NROW1,NSLICE1,
     &             IDUM,'INPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .EQ. -1) RETURN
d132 3
a134 5
           WRITE(NOUT,*) 
     &        '*** CAN NOT NORMALIZE OUTPUT - FILE LACKS STATISTICS.'
           CALL ERRT(2,'CORR1',NE)
           CLOSE(LUN1)
           RETURN
d167 2
a168 4
           IF (IRTFLG .EQ. -1) THEN
              CLOSE(LUN1)
              GOTO 1111
           ENDIF
d175 5
a179 2
              CALL OPFIL(.FALSE.,FILNAM2,LUN2,'O',NSAM2,NROW2,NSLICE2,
     &                IDUM,NULL,.TRUE.,IRTFLG)
d182 1
d185 4
a188 6
                 WRITE(NOUT,*) 
     &          '*** CAN NOT NORMALIZE OUTPUT - FILE LACKS STATISTICS.'
                 CALL ERRT(2,'CORR1',NE)
                 CLOSE(LUN1)
                 CLOSE(LUN2)
                 RETURN
d200 1
d206 1
a206 3
                  CLOSE(LUN1)
                  CLOSE(LUN2)
                  RETURN
d223 1
a223 1
              RETURN
d229 1
a229 1
           CALL READV (LUN2,QK2,LS2,NROW2,NSAM2,NROW2,NSLICE2)
a233 1

d242 1
a242 1
             RETURN
d249 1
a249 1
           RETURN
a253 1
        CLOSE(LUN1)
d268 1
a268 3
              IF (.NOT.ACASE)  CLOSE(LUN2)
              CLOSE(LUN1)
              RETURN
d272 2
a273 2
        IF (FCHAR(4:4).EQ.'N')  THEN
           QK1(1,1,1)=(0.0,0.0)
d279 1
a279 1
           RETURN
d326 1
a326 1
                 CALL  CNRD_2(LUN2,QK1,QKB,QK1,NSAM1,NROW1)
d330 1
a330 1
                 CALL  CNRS_3(QK1,QK2,QK1,NSAM1,NROW1,NSLICE1)
d332 1
a332 1
                 CALL  CNRD_3(LUN2,QK1,QKB,QK1,NSAM1,NROW1,NSLICE1)
d344 1
d346 3
a348 2
        CALL OPFIL(.TRUE.,FILNAM1,LUN3,'U',NSAM3,NROW1,NSLICE1,
     &             IDUM,'OUTPUT',.TRUE.,IRTFLG)
d351 5
a355 2
        CALL WRITEV (LUN3,QK1,LS1,NROW1,NSAM1,NROW1,NSLICE1)
        CLOSE(LUN3)
d357 3
a359 3
        DEALLOCATE (QK1)
        IF (.NOT. ACASE ) DEALLOCATE (QK2)       
        DEALLOCATE (QKB)
@


1.33
log
@'cc m' --> 'cc h'
@
text
@d288 6
a293 2
              IF (BOTH_INC)  THEN
                 CALL CCRS_2(QK1,QK2,QK1,NSAM1,NROW1,PHASE)
d295 1
a295 1
                 CALL CCRD_2(LUN2,QK1,QKB,QK1,NSAM1,NROW1,PHASE)
d298 6
a303 2
              IF (BOTH_INC)  THEN
                 CALL CCRS_3(QK1,QK2,QK1,NSAM1,NROW1,NSLICE1,PHASE)
d305 1
a305 1
                 CALL CCRD_3(LUN2,QK1,QKB,QK1,NSAM1,NROW1,NSLICE1,PHASE)
@


1.32
log
@phase correl.
@
text
@d3 2
a4 2
C CORR1.F                                       REWRITTEN AUG 96 PP
C                         ADDED 'CC M'  MAR 02 ARDEAN LEITH
d127 4
a130 4
           LS1=NSAM1+2-MOD(NSAM1,2)
           LREC1=NSAM1
           IFORM3=IFORM1
           NSAM3=NSAM1
d132 5
a136 5
           LS1=NSAM1
           LREC1=NSAM1
           NSAM1=NSAM1-MOD(-IFORM1,10)
           IF (IFORM1.GT.-20)  THEN
              IFORM3=1
d138 1
a138 1
              IFORM3=3
d140 1
a140 1
           NSAM3=NSAM1
d173 2
a174 2
                 IMAMI2=IMAMI
                 SIG2=SIG
d177 2
a178 2
              IF (IFORM2.GT.0)  THEN
                 LS2=NSAM2+2-MOD(NSAM2,2)
d180 2
a181 2
                 LS2=NSAM2
                 NSAM2=NSAM2-MOD(-IFORM2,10)
d195 1
a195 1
        PHASE = (FCHAR(4:4) .EQ. 'M')
d205 1
a205 1
           IF (IRTFLG.NE.0) THEN 
d212 1
a212 1

d219 1
a219 1
           INV=+1
d225 1
a225 1
           IF (INV.EQ.0)  THEN
d232 1
a232 1
        IF (IRTFLG.NE.0) THEN 
d240 1
a240 1
        IF (FCHAR(4:4).EQ.'N'.AND.IMAMI1.NE.1)
d244 1
a244 1
        IF (IFORM1.GT.0)  THEN
d246 2
a247 2
           INV=+1
           IF (IFORM1.EQ.1)  THEN
d265 1
a265 1
        IF (IRTFLG.NE.0) THEN 
d272 2
a273 2
             IF(FCHAR(4:4).EQ.'S'.OR.FCHAR(4:5).EQ.'NS')  THEN
              CALL ACRS_2S(QK1,QK1,NSAM1,NROW1)
d275 1
a275 1
              CALL ACRS_2(QK1,QK1,NSAM1,NROW1)
d278 2
a279 2
             IF(FCHAR(4:4).EQ.'S'.OR.FCHAR(4:5).EQ.'NS')  THEN
              CALL ACRS_3S(QK1,QK1,NSAM1,NROW1,NSLICE1)
d281 1
a281 1
              CALL ACRS_3(QK1,QK1,NSAM1,NROW1,NSLICE1)
d287 1
a287 1
           IF (NSLICE1.LE.1)  THEN
d301 1
a301 1
        ELSEIF(FCHAR(1:2) .EQ. 'CN')  THEN
d309 1
a309 1
              IF(BOTH_INC)  THEN
d317 2
a318 2
        IF (.NOT.ACASE)  CLOSE(LUN2)
        IF (ACASE)  SIG2=SIG1
@


1.31
log
@comments
@
text
@d4 1
d42 1
a42 1
        LOGICAL         ACASE, BOTH_INC
d61 1
a61 1
        IF(FCHAR(1:4).EQ.'CC C')  THEN
d195 2
a196 1

a212 1
 
d286 1
d289 1
a289 1
                 CALL CCRS_2(QK1,QK2,QK1,NSAM1,NROW1)
d291 1
a291 1
                 CALL CCRD_2(LUN2,QK1,QKB,QK1,NSAM1,NROW1)
d295 1
a295 1
                 CALL CCRS_3(QK1,QK2,QK1,NSAM1,NROW1,NSLICE1)
d297 1
a297 1
                 CALL CCRD_3(LUN2,QK1,QKB,QK1,NSAM1,NROW1,NSLICE1)
@


1.30
log
@adapted to changes in cc c
@
text
@d16 11
a26 1
C        1         2         3         4         5         6         7
d333 1
@


1.29
log
@CC MS added
@
text
@d51 24
a74 1
           CALL  CCC
@


1.28
log
@added polar_cc
@
text
@d53 4
d59 1
a59 1
	   IF(FCHAR(6:6).EQ.'S')  THEN
d61 1
a61 1
	   ELSE
d240 1
a240 1
	     ELSE            
d246 1
a246 1
	     ELSE            
a301 2

 
@


1.27
log
@removed call to polar_cc
@
text
@d55 5
a59 5
	  IF(FCHAR(6:6).EQ.'S')  THEN
           CALL  MACF('S')
	  ELSE
           CALL  MACF(' ')
          ENDIF
d63 1
a63 1
ccccc           CALL  POLAR_CC (can not find AL 9/19/00
@


1.26
log
@ac mss
@
text
@d63 1
a63 1
           CALL  POLAR_CC
@


1.25
log
@ac s, ac ns
@
text
@d55 9
a63 1
           CALL  MACF
@


1.24
log
@readv parameter
@
text
@d226 3
d230 1
d232 5
a236 1
             CALL ACRS_3(QK1,QK1,NSAM1,NROW1,NSLICE1)
@


1.23
log
@normalization
@
text
@d191 1
a191 1
        CALL READV (LUN1,QK1,LS1,NROW1,NSAM1,NROW1,NSLICE1)
@


1.22
log
@bad normalization fixed
@
text
@d267 1
a267 1
            QK1(1:LS1/2-1,:,:) = QK1(1:LS1/2-1,:,:) * FAN
@


1.21
log
@allocation
@
text
@d266 2
a267 2
            FAN = 1.0/(NSAM1*NROW1*FLOAT(NSLICE1)-1.0)/SIG1/SIG2
            QK1 = QK1*FAN
@


1.20
log
@normalization changed
@
text
@d157 1
a157 1
           ALLOCATE (QK2(LS2,NROW2,NSLICE2), STAT=IRTFLG)
d185 1
a185 1
        ALLOCATE (QK1(LS1,NROW1,NSLICE1), STAT=IRTFLG)
d264 5
d274 1
a274 10
        IF (FCHAR(4:4) .EQ. 'N') THEN
C           NORMALIZATION ROUTINE HERE
            FAN = 1.0/(NSAM1*NROW1*FLOAT(NSLICE1)-1.0)/SIG1/SIG2
C           GIVES BAD FLOAT ERROR ON DEC AS ACCESSES OUTSIDE OUTPUT IMAGE
c           QK1 = QK1*FAN
            CALL WRITEVN(LUN3,QK1,LS1,NROW1,NSAM1,NROW1,NSLICE1,FAN)
        ELSE
            CALL WRITEV (LUN3,QK1,LS1,NROW1,NSAM1,NROW1,NSLICE1)
        ENDIF

a282 15
C       ------------------------------------------
        SUBROUTINE WRITEVN(LUN,BUF,NSAM1,NROW1,NSAM,NROW,NSLICE,FAN)

        REAL    BUF(NSAM1,NROW1,1) 
           
        DO    K=1,NSLICE
           DO    J=1,NROW
             DO I=1,NSAM
                BUF(I,J,K) = BUF(I,J,K) * FAN
             ENDDO
             CALL  WRTLIN(LUN,BUF(1,J,K),NSAM,J+(K-1)*NROW)
           ENDDO
        ENDDO
        RETURN
        END
@


1.19
log
@deallocation
@
text
@d264 5
d272 5
a276 1
            QK1=QK1*FAN
a277 4
        IFORM = IFORM3
        CALL OPFIL(.TRUE.,FILNAM1,LUN3,'U',NSAM3,NROW1,NSLICE1,
     &             IDUM,'OUTPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .EQ. -1) RETURN
a278 1
        CALL WRITEV (LUN3,QK1,LS1,NROW1,NSAM1,NROW1,NSLICE1)
d286 17
@


1.18
log
@no memory allocation for QK2 in auto correlation
@
text
@d278 1
a278 1
        IF (FCHAR(1:2) .NE. 'AC') DEALLOCATE (QK2)
@


1.17
log
@cosmetic
@
text
@d155 7
a161 5

        ALLOCATE (QK2(LS2,NROW2,NSLICE2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'FCHAR(1:2), QK2',IER)
           RETURN
d187 1
a187 1
           CALL ERRT(46,'FCHAR(1:2), QK1',IER)
d220 1
a220 1
           CALL ERRT(46,'FCHAR(1:2), QKB',IER)
@


1.16
log
@adapted for dynamical memory allocation
@
text
@d22 1
a22 1
        INCLUDE '/net/ithaca/usr1/spider/src/CMBLOCK.INC'
@


1.15
log
@a
@
text
@d14 4
d20 1
a20 3
        SUBROUTINE CORR1(MAXDIM)

	INCLUDE 'CMBLOCK.INC'
d22 1
d24 8
a31 17
	PARAMETER       (LENBUF=8000)
        COMMON          OPENBUF(LENBUF),BUF(1)
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q

#else
        DIMENSION       Q(1)
        POINTER         (IPQ,Q) 
#endif
        CHARACTER *81	FILNAM1,FILNAM2
        CHARACTER *1	NULL
	PARAMETER       (NFUNC=3)
        CHARACTER *2	FUNC(NFUNC)
        LOGICAL		ACASE, RUNTIME, BOTH_INC

d47 1
a47 1
1111	CONTINUE
d50 3
a52 3
	IF(FCHAR(1:4).EQ.'CC C')  THEN
	   CALL  CCC(MAXDIM)
	   RETURN
d54 4
a57 4
	ELSEIF(FCHAR(1:5).EQ.'AC MS')  THEN
	   CALL  MACF
	   RETURN
	ENDIF
d61 1
a61 1
	CALL OPFIL(.TRUE.,FILNAM1,LUN1,'O',NSAM1,NROW1,NSLICE1,
d70 2
a71 2
	   CLOSE(LUN1)
	   RETURN
d74 2
a75 2
	   IMAMI1=IMAMI
	   SIG1   = SIG
d77 1
a77 1
	IFORM1 = IFORM
d80 16
a95 16
	IF (IFORM1.GT.0)  THEN
	   LS1=NSAM1+2-MOD(NSAM1,2)
	   LREC1=NSAM1
	   IFORM3=IFORM1
	   NSAM3=NSAM1
	ELSE
	   LS1=NSAM1
	   LREC1=NSAM1
	   NSAM1=NSAM1-MOD(-IFORM1,10)
	   IF (IFORM1.GT.-20)  THEN
	      IFORM3=1
	   ELSE
	      IFORM3=3
	   ENDIF
	   NSAM3=NSAM1
	ENDIF
d97 1
a97 1
	IF (FCHAR(1:2) .EQ. 'AC') THEN
d100 1
a100 1
	   IFORM2 = IFORM1
d111 1
a111 1
	      IFORM2 = IFORM1
d116 1
a116 1
	      IFORM2 = IFORM
d123 2
a124 2
		 CLOSE(LUN1)
		 CLOSE(LUN2)
d127 1
a127 1
	         IMAMI2=IMAMI
d131 6
a136 6
	      IF (IFORM2.GT.0)  THEN
		 LS2=NSAM2+2-MOD(NSAM2,2)
	      ELSE
		 LS2=NSAM2
		 NSAM2=NSAM2-MOD(-IFORM2,10)
	      ENDIF
d142 2
a143 2
		  CLOSE(LUN1)
		  CLOSE(LUN2)
d149 28
a176 46
C       MEMORY
	IF (.NOT. ACASE .AND. IFORM2 .GT. 0)  THEN
	   MEMWANT=2*(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
           CALL CHKMEM(MEMWANT,BUF,MAXDIM-LENBUF,RUNTIME,IPQ,IRTFLG)
	   IF (IRTFLG .EQ. 0 .OR. LS1 .LT. LENBUF)  THEN
	      BOTH_INC = .TRUE.
	      K1=1
	      K2=K1+(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
	      GOTO  1001
	   ENDIF
	ELSE
	   MEMWANT=(NSAM1+2-MOD(NSAM1,2))*(NROW1*NSLICE1+1)
           CALL CHKMEM(MEMWANT,BUF,MAXDIM-LENBUF,RUNTIME,IPQ,IRTFLG)
	   IF (IRTFLG.EQ.0 .OR. LS1 .LT. LENBUF)  THEN
	      BOTH_INC=.FALSE.
	      K1=1
	      K2=1
	      KB=K1+(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
	      GOTO  1001
	   ENDIF
	ENDIF

C       NO MEMORY
	CALL ERRT(6,FCHAR(1:4),NE)
	CLOSE(LUN1)
    	CLOSE(LUN2)
	RETURN

1001	CONTINUE
#ifdef SP_F90
         Q = >IPQ
#endif

	IF (.NOT.ACASE .AND. IFORM2 .GT. 0)  THEN
C          PROCESS LUN2
	   DO   J=1,NROW2*NSLICE2
	   CALL  REDLIN(LUN2,Q(K2+(J-1)*LS2),NSAM2,J)
	   ENDDO
	   IF (FCHAR(4:4).EQ.'N'.AND.IMAMI2.NE.1)
     &	      CALL NRMS(Q(K2),LS2,NSAM2,NROW2,NSLICE2,SIG2)
	   INV=+1
	   IF (IFORM2.EQ.1)  THEN
	      CALL FMRS_2(Q(K2),NSAM2,NROW2,INV)
	   ELSE
	      CALL FMRS_3(Q(K2),NSAM2,NROW2,NSLICE2,INV)
	   ENDIF
d183 14
a196 8
C       READ IN  LUN1
	DO   J=1,NROW1*NSLICE1
	CALL  REDLIN(LUN1,Q(K1+(J-1)*LS1),LREC1,J)
	ENDDO
	CLOSE(LUN1)
	IF (FCHAR(4:4).EQ.'N'.AND.IMAMI1.NE.1)
     &	   CALL NRMS(Q(K1),LS1,NSAM1,NROW1,NSLICE1,SIG1)
	IF (IFORM1.GT.0)  THEN
d199 5
a203 5
	   IF (IFORM1.EQ.1)  THEN
	      CALL FMRS_2(Q(K1),NSAM1,NROW1,INV)
	   ELSE
	      CALL FMRS_3(Q(K1),NSAM1,NROW1,NSLICE1,INV)
	   ENDIF
d206 2
a207 2
	      IF (.NOT.ACASE)  CLOSE(LUN2)
	      CLOSE(LUN1)
d211 51
a261 43
C
	IF (FCHAR(4:4).EQ.'N')  THEN
	   Q(K1)=0.0
	   Q(K1+1)=0.0
	ENDIF
C
	IF (ACASE)  THEN
	  IF (NSLICE1.LE.1)  THEN
	    CALL ACRS_2(Q(K1),Q(K1),NSAM1,NROW1)
	  ELSE
	    CALL ACRS_3(Q(K1),Q(K1),NSAM1,NROW1,NSLICE1)
	  ENDIF
	ELSEIF (FCHAR(1:2) .EQ. 'CC')  THEN
	  IF (NSLICE1.LE.1)  THEN
	    IF (BOTH_INC)  THEN
	    CALL CCRS_2(Q(K1),Q(K2),Q(K1),NSAM1,NROW1)
	    ELSE
	    CALL CCRD_2(LUN2,Q(K1),Q(KB),Q(K1),NSAM1,NROW1)
	    ENDIF
	  ELSE
	    IF (BOTH_INC)  THEN
	       CALL CCRS_3(Q(K1),Q(K2),Q(K1),NSAM1,NROW1,NSLICE1)
	    ELSE
	       CALL CCRD_3(LUN2,Q(K1),Q(KB),Q(K1),NSAM1,NROW1,NSLICE1)
	    ENDIF
	  ENDIF
	ELSEIF(FCHAR(1:2) .EQ. 'CN')  THEN
	  IF (NSLICE1.LE.1)  THEN
	    IF (BOTH_INC)  THEN
	    CALL  CNRS_2(Q(K1),Q(K2),Q(K1),NSAM1,NROW1)
	    ELSE
	    CALL  CNRD_2(LUN2,Q(K1),Q(KB),Q(K1),NSAM1,NROW1)
	    ENDIF
	  ELSE
	    IF(BOTH_INC)  THEN
	    CALL  CNRS_3(Q(K1),Q(K2),Q(K1),NSAM1,NROW1,NSLICE1)
	    ELSE
	    CALL  CNRD_3(LUN2,Q(K1),Q(KB),Q(K1),NSAM1,NROW1,NSLICE1)
	    ENDIF
	  ENDIF
	ENDIF
	IF (.NOT.ACASE)  CLOSE(LUN2)
	IF (ACASE)  SIG2=SIG1
d264 2
a265 4
	    FAN = 1.0/(NSAM1*NROW1*FLOAT(NSLICE1)-1.0)/SIG1/SIG2
	    DO  I=0,LS1*NROW1*NSLICE1-1
	    Q(K1+I)=Q(K1+I)*FAN
	    ENDDO
d267 2
a268 2
	IFORM = IFORM3
	CALL OPFIL(.TRUE.,FILNAM1,LUN3,'U',NSAM3,NROW1,NSLICE1,
a270 3
	DO   J=1,NROW1*NSLICE1
	CALL  WRTLIN(LUN3,Q(K1+(J-1)*LS1),NSAM1,J)
	ENDDO
d272 2
a273 2
	CLOSE(LUN3)
        IF (RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'CORR1',IRTFLG)
d275 3
d279 1
a279 1
	END
@


1.14
log
@adapted for "ac ms"
@
text
@d19 1
a19 1
CNO_SAVE
@


1.13
log
@f90 alloc
@
text
@d61 1
a61 1
	   CALL  MACF(MAXDIM)
@


1.12
log
@*** empty log message ***
@
text
@d23 6
d31 1
d184 3
@


1.11
log
@exten should not be used for filerd call here
@
text
@d180 3
a182 2
	   DO  101 J=1,NROW2*NSLICE2
101	   CALL  REDLIN(LUN2,Q(K2+(J-1)*LS2),NSAM2,J)
d198 3
a200 2
	DO  1 J=1,NROW1*NSLICE1
1	CALL  REDLIN(LUN1,Q(K1+(J-1)*LS1),LREC1,J)
d265 3
a267 2
	    DO 5 I=0,LS1*NROW1*NSLICE1-1
5	    Q(K1+I)=Q(K1+I)*FAN
d273 3
a275 2
	DO  2 J=1,NROW1*NSLICE1
2	CALL  WRTLIN(LUN3,Q(K1+(J-1)*LS1),NSAM1,J)
@


1.10
log
@separate output
@
text
@d3 1
a3 1
C CORR1.FOR
d17 1
a17 2
	PARAMETER (NFUNC=3)
	PARAMETER (LENBUF=4097)
d19 6
a24 4
        COMMON       OPENBUF(LENBUF),BUF(1)
        DIMENSION    Q(1)
        POINTER      (IPQ,Q) 
        DIMENSION	VALUES(1)
a25 1
	CHARACTER *3	EXTEN
d27 1
d30 6
a35 4
        DATA FUNC/'AC',  'CC',  'CN'/
        DATA LUN1,LUN2,LUN3/21,22,23/
CNO_SAVE
        NULL   = CHAR(0) 
d42 1
a42 1
C       OPERATION NOT HERE, RETURN TO DRIVER
d47 2
a48 2
C Catch exceptions
C                                                           CC C
d50 3
a52 3
	CALL  CCC(MAXDIM)
	RETURN
C                                                           AC MS
d54 2
a55 2
	CALL  MACF(MAXDIM)
	RETURN
d57 2
a58 2
C
C
d63 2
a64 1
         IF(FCHAR(4:4).EQ.'N' .AND. IFORM.LT.0) THEN
d71 5
a75 4
         ELSEIF(FCHAR(4:4).EQ.'N')  THEN
	 IMAMI1=IMAMI
	 SIG1   = SIG
         ENDIF
d77 7
a83 6
C CALCULATE DIMENSIONS
	IF(IFORM1.GT.0)  THEN
	 LS1=NSAM1+2-MOD(NSAM1,2)
	 LREC1=NSAM1
	 IFORM3=IFORM1
	 NSAM3=NSAM1
d85 9
a93 9
	 LS1=NSAM1
	 LREC1=NSAM1
	 NSAM1=NSAM1-MOD(-IFORM1,10)
	  IF(IFORM1.GT.-20)  THEN
	  IFORM3=1
	  ELSE
	  IFORM3=3
	  ENDIF
	 NSAM3=NSAM1
d95 1
a95 1
C
d98 2
a99 2
           ACASE = .TRUE.
	      IFORM2 = IFORM1
d102 1
a102 1
           CALL FILERD(FILNAM2,NLET,EXTEN,'REFERENCE',IRTFLG)
d109 1
a109 1
              ACASE = .TRUE.
d117 1
a117 1
              IF(FCHAR(4:4).EQ.'N' .AND.IFORM .LT. 0) THEN
d126 2
a127 2
	       IMAMI2=IMAMI
               SIG2=SIG
d129 7
a135 7
C CALCULATE DIMENSIONS
		IF(IFORM2.GT.0)  THEN
		LS2=NSAM2+2-MOD(NSAM2,2)
		ELSE
		LS2=NSAM2
		NSAM2=NSAM2-MOD(-IFORM2,10)
		ENDIF
d147 11
a157 10
C  MEMORY
	IF(.NOT.ACASE.AND.IFORM2.GT.0)  THEN
	 MEMWANT=2*(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
         CALL CHKMEM(MEMWANT,BUF,MAXDIM-LENBUF,RUNTIME,IPQ,IRTFLG)
	  IF(IRTFLG.EQ.0.OR.LS1.LT.LENBUF)  THEN
	   BOTH_INC=.TRUE.
	   K1=1
	   K2=K1+(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
	   GOTO  1001
	  ENDIF
d159 9
a167 9
	 MEMWANT=(NSAM1+2-MOD(NSAM1,2))*(NROW1*NSLICE1+1)
         CALL CHKMEM(MEMWANT,BUF,MAXDIM-LENBUF,RUNTIME,IPQ,IRTFLG)
	  IF(IRTFLG.EQ.0.OR.LS1.LT.LENBUF)  THEN
	   BOTH_INC=.FALSE.
	   K1=1
	   K2=1
	   KB=K1+(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
	   GOTO  1001
	  ENDIF
d169 7
a175 6
C NO MEMORY
	  CALL ERRT(6,FCHAR(1:4),NE)
	  CLOSE(LUN1)
    	  CLOSE(LUN2)
	  RETURN
C
d177 17
a193 17
C
	IF(.NOT.ACASE.AND.IFORM2.GT.0)  THEN
C  PROCESS LUN2
	DO  101 J=1,NROW2*NSLICE2
101	CALL  REDLIN(LUN2,Q(K2+(J-1)*LS2),NSAM2,J)
	IF(FCHAR(4:4).EQ.'N'.AND.IMAMI2.NE.1)
     &	  CALL NRMS(Q(K2),LS2,NSAM2,NROW2,NSLICE2,SIG2)
	  INV=+1
	  IF(IFORM2.EQ.1)  THEN
	  CALL FMRS_2(Q(K2),NSAM2,NROW2,INV)
	  ELSE
	  CALL FMRS_3(Q(K2),NSAM2,NROW2,NSLICE2,INV)
	  ENDIF
          IF(INV.EQ.0)  THEN
            CALL ERRT(38,FCHAR(1:2),NE)
            RETURN
         ENDIF
d195 2
a196 2
C
C  READ IN  LUN1
d200 16
a215 16
	IF(FCHAR(4:4).EQ.'N'.AND.IMAMI1.NE.1)
     &	  CALL NRMS(Q(K1),LS1,NSAM1,NROW1,NSLICE1,SIG1)
	IF(IFORM1.GT.0)  THEN
C        NON-FOURIER INPUT
          INV=+1
	  IF(IFORM1.EQ.1)  THEN
	   CALL FMRS_2(Q(K1),NSAM1,NROW1,INV)
	  ELSE
	   CALL FMRS_3(Q(K1),NSAM1,NROW1,NSLICE1,INV)
	  ENDIF
            IF (INV.EQ.0)  THEN
            CALL ERRT(38,FCHAR(1:2),NE)
	    IF(.NOT.ACASE)  CLOSE(LUN2)
	    CLOSE(LUN1)
            RETURN
            ENDIF
d218 3
a220 3
	IF(FCHAR(4:4).EQ.'N')  THEN
	Q(K1)=0.0
	Q(K1+1)=0.0
d223 3
a225 3
	IF(ACASE)  THEN
	  IF(NSLICE1.LE.1)  THEN
	    CALL  ACRS_2(Q(K1),Q(K1),NSAM1,NROW1)
d227 1
a227 1
	    CALL  ACRS_3(Q(K1),Q(K1),NSAM1,NROW1,NSLICE1)
d229 4
a232 4
	ELSEIF(FCHAR(1:2).EQ.'CC')  THEN
	  IF(NSLICE1.LE.1)  THEN
	    IF(BOTH_INC)  THEN
	    CALL  CCRS_2(Q(K1),Q(K2),Q(K1),NSAM1,NROW1)
d234 1
a234 1
	    CALL  CCRD_2(LUN2,Q(K1),Q(KB),Q(K1),NSAM1,NROW1)
d237 2
a238 2
	    IF(BOTH_INC)  THEN
	    CALL  CCRS_3(Q(K1),Q(K2),Q(K1),NSAM1,NROW1,NSLICE1)
d240 1
a240 1
	    CALL  CCRD_3(LUN2,Q(K1),Q(KB),Q(K1),NSAM1,NROW1,NSLICE1)
d243 3
a245 3
	ELSEIF(FCHAR(1:2).EQ.'CN')  THEN
	  IF(NSLICE1.LE.1)  THEN
	    IF(BOTH_INC)  THEN
d258 2
a259 2
	IF(.NOT.ACASE)  CLOSE(LUN2)
	IF(ACASE)  SIG2=SIG1
d261 4
a264 4
C           normalization routine here
		FAN=1.0/(NSAM1*NROW1*FLOAT(NSLICE1)-1.0)/SIG1/SIG2
		DO  5  I=0,LS1*NROW1*NSLICE1-1
5		Q(K1+I)=Q(K1+I)*FAN
d266 1
a266 1
	IFORM=IFORM3
d272 1
d274 3
a276 1
        IF(RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'CORR1',IRTFLG)
@


1.9
log
@AC MS call macf
@
text
@a168 8
	IFORM=IFORM3
	CALL OPFIL(.TRUE.,FILNAM1,LUN3,'U',NSAM3,NROW1,NSLICE1,
     &             IDUM,'OUTPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .EQ. -1) THEN
	CLOSE(LUN1)
	CLOSE(LUN2)
	RETURN
	ENDIF
d258 4
@


1.8
log
@OK ?
@
text
@d49 4
@


1.7
log
@Probably correct but overwrites input.
@
text
@d30 1
a30 1
        DATA LUN1,LUN2/21,22/
d47 1
a47 1
	CALL  CCC(MAXIDM)
d56 1
a56 1
         IF (FCHAR(4:4) .EQ. 'N' .AND. IMAMI .NE. 1) THEN
d60 1
a60 1
           CALL ERRT(100,'CORR1',NE)
d63 4
a66 1
        ENDIF
a67 2
	SIG1   = SIG
	AV1    = AV
d70 4
a73 2
	LS1=NSAM1+2-MOD(NSAM1,2)
	LREC1=NSAM1
d75 9
a83 3
	LS1=NSAM1
	LREC1=NSAM1
	NSAM1=NSAM1-MOD(-IFORM1,10)
a89 2
              SIG2   = SIG1
              AV2    = AV1
a100 2
              SIG2   = SIG1
              AV2    = AV1
a105 2
              SIG2   = SIG
              AV2    = AV
d107 1
a107 1
              IF (FCHAR(4:4) .EQ. 'N' .AND. IMAMI .NE. 1) THEN
d111 1
a111 1
                 CALL ERRT(100,'CORR1',NE)
d115 3
d139 11
a149 2
	MEMWANT=2*(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
        CALL CHKMEM(MEMWANT,BUF,MAXDIM-LENBUF,RUNTIME,IPQ,IRTFLG)
d151 5
a155 4
	  BOTH_INC=.TRUE.
	  K1=1
	  K2=K1+(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
	  GOTO  1001
d158 1
a158 8
	MEMWANT=(NSAM1+2-MOD(NSAM1,2))*(NROW1*NSLICE1+1)
        CALL CHKMEM(MEMWANT,BUF,MAXDIM-LENBUF,RUNTIME,IPQ,IRTFLG)
	  IF(IRTFLG.EQ.0.OR.LS1.LT.LENBUF)  THEN
	  BOTH_INC=.FALSE.
	  K1=1
	  K2=1
	  KB=K1+(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
	  ELSE
a162 1
	  ENDIF
d165 8
d178 2
d186 1
a186 2
	CLOSE(LUN2)
         IF (INV.EQ.0)  THEN
d190 1
a190 14
C        WAS REAL, REPLACE BY THE FOURIER FILE
		IF(MOD(NSAM2,2).EQ.0)  THEN
		IFORM=-12-(IFORM2/2)*10
		ELSE
		IFORM =-11-(IFORM2/2)*10
		ENDIF
      CALL OPENFB(Q,FILNAM2,LUN2,LS2,NROW2,'UNKNOWN',NF,NSLICE2)
		IF (NF .EQ. 1)  THEN
		CALL ERRT(4,FCHAR(1:4),NE)
		RETURN
		ENDIF
	DO  102 J=1,NROW2*NSLICE2
102	CALL  WRTLIN(LUN2,Q(K2+(J-1)*LS2),LS2,J)
	ENDIF
d195 3
d202 1
a202 1
	  CALL FMRS_2(Q(K1),NSAM1,NROW1,INV)
d204 1
a204 1
	  CALL FMRS_3(Q(K1),NSAM1,NROW1,NSLICE1,INV)
d212 1
a212 7
	ELSE
C  LUN1 WAS FOURIER INPUT, REPLACE BY REAL
	CLOSE(LUN1)
	IFORM=MOD(-IFORM1,10)
	IFORM=IFORM+IFORM/2
      CALL OPENFB(Q,FILNAM1,LUN1,NSAM1,NROW1,'UNKNOWN',NF,NSLICE1)
	ENDIF
d220 1
a220 1
	  IF(NSLICE.LE.1)  THEN
d226 1
a226 1
	  IF(NSLICE.LE.1)  THEN
d240 1
a240 1
	  IF(NSLICE.LE.1)  THEN
d255 1
d263 2
a264 13
2	CALL  WRTLIN(LUN1,Q(K1+(J-1)*LS1),NSAM1,J)
      IF (IFORM1.GT.0)  THEN
C        REAL SPACE INPUT FILE
C        CLEAR LABEL, SET SCALE
         VALUES(1) = 0.0     
         IRTFLG    = -1       
         CALL SETLAB(LUN1,NSAM1,Q,21,1,VALUES,'U',IRTFLG)
C        FILE NOT SEARCHED FOR MIN-MAX
         VALUES(1) = 0.0      
         IRTFLG    = -1      
         CALL SETLAB(LUN1,NSAM1,Q, 6,1,VALUES,'U',IRTFLG)
      ENDIF
	CLOSE(LUN1)
d266 1
a266 1
        END
@


1.6
log
@*** empty log message ***
@
text
@d25 1
d28 1
a28 1
        LOGICAL		ACASE, RUNTIME
d67 10
d80 3
d93 3
d100 4
d113 1
a113 9
C CALCULATE ALL THE DIMENSIONS
		IF(IFORM1.GT.0)  THEN
		LS1=NSAM1+2-MOD(NSAM1,2)
		LREC1=NSAM1
		ELSE
		LS1=NSAM1
		LREC1=NSAM1
		NSAM1=NSAM1-2+MOD(NSAM1,2)
		ENDIF
d118 1
a118 1
		NSAM2=NSAM2-2+MOD(NSAM2,2)
a128 4
	      IFORM2 = IFORM
              SIG2   = SIG
              AV2    = AV
              ACASE  = .FALSE.
d132 9
a140 7
	MEMWANT=LENBUF+(NSAM1+2-MOD(NSAM1,2))*(NROW1*NSLICE1+1)
        CALL CHKMEM(MEMWANT,BUF,MAXDIM,RUNTIME,IPQ,IRTFLG)
	IF(IRTFLG.EQ.0.OR.LS1.GT.LENBUF)  THEN
	CALL ERRT(6,FCHAR(1:4),NE)
	CLOSE(LUN1)
	CLOSE(LUN2)
	RETURN
d142 15
a156 3
C  POINTERS
	K1=LENBUF+1
	K2=K1+(NSAM1+2-MOD(NSAM1,2))*NROW1*NSLICE1
d161 7
a167 6
101	CALL  REDLIN(LUN2,Q(K1+(J-1)*LS2),NSAM2,J)
	IF(IFORM2.EQ.1)  THEN
	CALL FMRS_2(Q(K1),NSAM2,NROW2)
	ELSE
	CALL FMRS_3(Q(K1),NSAM,NROW,NSLICE)
	ENDIF
d174 1
a174 1
		IF(MOD(NSAM,2).EQ.0)  THEN
d185 1
a185 1
102	CALL  REDLIN(LUN2,Q(K1+(J-1)*LS2),LS2,J)
d191 1
a191 1
	IF(IFORM1.GT.1)  THEN
d193 7
a199 7
         INV = 1
	IF(IFORM1.EQ.1)  THEN
	CALL FMRS_2(Q(K1),NSAM1,NROW1)
	ELSE
	CALL FMRS_3(Q(K1),NSAM1,NROW1,NSLICE1)
	ENDIF
         IF (INV.EQ.0)  THEN
d204 1
a204 1
         ENDIF
d212 6
d220 1
a220 1
	  CALL  ACRS_2(Q(K1),Q(K2),NSAM1,NROW1)
d222 1
a222 1
	  CALL  ACRS_3(Q(K1),Q(K2),NSAM1,NROW1,NSLICE1)
d226 5
a230 1
	  CALL  CCRD_2(LUN2,Q(K1),Q(K2),Q(K1),NSAM1,NROW1)
d232 5
a236 1
	  CALL  CCRD_3(LUN2,Q(K1),Q(K2),Q(K1),NSAM1,NROW1,NSLICE1)
d240 5
a244 1
	  CALL  CNRD_2(LUN2,Q(K1),Q(K2),Q(K1),NSAM1,NROW1)
d246 5
a250 1
	  CALL  CNRD_3(LUN2,Q(K1),Q(K2),Q(K1),NSAM1,NROW1,NSLICE1)
d253 1
a253 1
	CLOSE(LUN2)
d256 1
a256 1
		FAN=1.0/SIG1/SIG2
d262 1
a262 1
      IF (IFORM1.EQ.1)  THEN
@


1.5
log
@new version
@
text
@d228 1
a228 1
        IF(RUNTIEM)  CALL ALLOCIT(0,RUNTIME,IPQ,'CORR1',IRTFLG)
@


1.4
log
@removed warning for iris 5.*
@
text
@d1 1
a1 2

C++*************************************************************************
d5 8
a12 12
C	CHANGED BY MAHIEDDINE LADJADJ 4/28/93
C       CHANGED BY JING SU            9/9/93
C       LONG FILE NAMES JAN 89 al
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987 WADSWORTH CENTER FOR LABORATORIES AND          *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH                            *
C **************************************************************************
d14 1
a14 1
C--*************************************************************************
d17 11
a27 23
                                                    
        PARAMETER (NFUNC=3)
#ifdef SP_UNIX
        INCLUDE 'CMBLOCK.INC'
#else
        INCLUDE 'COMMON1:CMBLOCK.INC'
#endif

        COMMON C0(1)
        COMMON /COMMUN/ FIL,FILN,FILNAM
        CHARACTER *81 FILNAM(2),FIL(2),FILN
        CHARACTER *5  SPEC(2)
        CHARACTER *2  FUNC(NFUNC)
        CHARACTER *1  NULL,FC,ANS,FC2
        COMPLEX       C0,CM
        DIMENSION     MA(2),MAF(2),IFORMA(2),LUNL(2)
        INTEGER       H
        INTEGER       I4,I1,IFULL,I4S
        LOGICAL       RIPPLE,FILTER,BB,ACFNORM
        REAL          BUF(1)
        EQUIVALENCE   (C0(1),BUF(1))
        DOUBLE PRECISION  DAV

d29 7
a35 7
        DATA SPEC(1)/'INPUT'/,SPEC(2)/'REFER'/
        DATA LUN1/8/,LUN2/9/,LUN3/10/,LUN4/11/

        NULL=CHAR(0)
        DO IFUNC = 1, NFUNC
          IF (FCHAR(1:2) .EQ. FUNC(IFUNC)) THEN
            GOTO (1,2,3), IFUNC
d37 3
a39 2
        ENDDO
        RETURN
d42 187
a228 17
C	OPERATION ------------------------------------------------------'AC'
1       CONTINUE
        CALL CORR1A(IFUNC,MAXDIM)
        GOTO 999         


C	OPERATION ------------------------------------------------------- 'CC'
2       CALL CORR1B(IFUNC,MAXDIM)
        GOTO 999

C	OPERATION --------------------------------------------------------'CN'
3       CALL CORR1C(IFUNC,MAXDIM)
        GOTO 999

999     CONTINUE

        RETURN
@


1.3
log
@added warning about ac use on irix 5.0
@
text
@a59 8
#ifdef SP_UNIX
        IF (FCHAR(3:6) .EQ. '    ') THEN
        WRITE(NOUT,*) " WARNING IF YOUR ARE RUNNING IRIX 5.* ON SGI, "
        WRITE(NOUT,*) " AC GIVES IMPROPER RESULTS, USE AC IC INSTEAD."
        WRITE(NOUT,*) " "
        ENDIF 
#endif

@


1.2
log
@cpp_lines_added
@
text
@d59 10
a68 1
1       CALL CORR1A(IFUNC,MAXDIM)
@


1.1
log
@Initial revision
@
text
@d24 3
d28 1
@
