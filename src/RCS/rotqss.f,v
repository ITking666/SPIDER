head	1.41;
access;
symbols
	healthdept_2018:1.41
	pre_getangas:1.12
	GPL2010:1.5
	pre_GPL2010:1.4
	pre_var_equation:1.4
	pre_fftwrings:1.4
	pre_opfiles:1.2
	src:1.2;
locks; strict;
comment	@c @;


1.41
date	2018.10.03.14.34.15;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2012.12.10.17.17.28;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2012.12.07.14.43.21;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2012.06.11.14.03.11;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2012.05.16.13.20.40;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.10.18.31.28;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2012.04.05.15.38.56;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2012.04.04.00.34.42;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2012.04.04.00.30.52;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.20.13.59.09;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2012.03.09.20.49.13;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2012.03.09.15.27.03;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2012.03.06.15.32.18;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2012.03.06.15.16.48;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2012.01.24.14.26.02;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.18.19.03.16;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.17.20.13.31;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.11.13.06.32;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2012.01.04.15.15.09;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.29.18.44.40;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2011.12.19.17.04.34;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2011.09.21.18.55.38;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.03.14.44.47;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2011.06.02.15.39.34;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2011.06.02.15.27.11;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2011.05.25.19.21.39;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2011.05.24.17.30.12;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.24.12.54.41;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2011.05.13.14.40.41;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2011.02.14.16.12.58;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2011.02.10.15.39.59;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.12.18.53.02;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.12.18.46.52;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.12.18.41.50;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.03.16.21.35;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.22.16.52.39;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.24.13.26.49;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.09.18.37.40;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.25.16.34.17;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2006.12.27.16.06.16;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2006.12.18.18.57.00;	author leith;	state Exp;
branches;
next	;


desc
@@


1.41
log
@email_health_dept
@
text
@
C++*********************************************************************
C
C  ROTQSS.F   ADDED STACK OPERATION                    98 ARDEAN LEITH 
C             USED AUTO. ARRAYS                   5/02/00 ARDEAN LEITH
C             SELECTION FILE ADDED               12/15/06 ARDEAN LEITH
C             MULTIFILE SUPPORT ADDED            12/17/10 ARDEAN LEITH
C             MERGED WITH ROTQSS_DL               1/10/11 ARDEAN LEITH
C             ADDED RTKSQ                         5/20/11 ARDEAN LEITH
C             RENAMED RTKSQ --> RTFS              6/02/11 ARDEAN LEITH
C             RENAMED ROT2QS --> RTSQ            12/28/11 ARDEAN LEITH
C             NSAM --> NX, RTSQ CALL PARAM        1/04/12 ARDEAN LEITH
C             INSUFFICIENT OUTPUT FILE NAMES      1/18/12 ARDEAN LEITH
C             CHKMIRROR                           3/08/12 ARDEAN LEITH
C             NANG == 1 .AND. ILIST1(1) BUG       4/05/12 ARDEAN LEITH
C             MIRROR BUG                          5/16/12 ARDEAN LEITH
C             MIRROR = (FMIRROR <  0.0)           6/11/12 ARDEAN LEITH
C             NULLIFY(PBUF)                      12/07/12 ARDEAN LEITH
C             
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C   ROTQSS(LUNIN,LUNOUT,LUNDOC,LUNXM1,LUNXM2,OLDRTSQ,USERTSF, IRTFLG)
C
C   PURPOSE:  ROTATE, SCALE, AND SHIFT IMAGES.
C             CAN USE A SELECTION DOC FILE
C             CAN TAKE TRANSFORMATION PARAMETERS FROM A DOC FILE
C
C--*********************************************************************

      SUBROUTINE ROTQSS(LUNIN,LUNOUT,LUNDOC,LUNXM1,LUNXM2, 
     &                  OLDRTSQ,USERTSF,CHKMIRROR,IRTFLG)

      IMPLICIT NONE
      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      INTEGER                :: LUNIN,LUNOUT,LUNDOC,LUNXM1,LUNXM2
      LOGICAL                :: OLDRTSQ, USERTSF,CHKMIRROR
      INTEGER                :: IRTFLG

C     DOC FILE POINTER
      INCLUDE 'F90ALLOC.INC'
      REAL, POINTER          :: PBUF(:,:)

      REAL,    ALLOCATABLE   :: XIMG(:,:),BUF2(:,:),BUFM(:,:)
      INTEGER, ALLOCATABLE   :: ILIST1(:),ILIST2(:)

      INTEGER                :: ILIST(5)
      CHARACTER (LEN=MAXNAM) :: FILPATIN,FILPATOUT,FILNAM
      CHARACTER (LEN=MAXNAM) :: DOCNAM
      CHARACTER (LEN=1)      :: ANS

      CHARACTER (LEN=1)      :: NULL = CHAR(0)
      CHARACTER (LEN=83)     :: PROMPT

      REAL                   :: THETA,SCLI,SHXI,SHYI,SCALE,FMIRROR
      INTEGER                :: NILMAX,MAXIMOUT,ITYPE,NX,NY,NZ
      INTEGER                :: NUMB,MAXX,MAXY,NLET,NDUM,NANGOUT
      INTEGER                :: NANG,IMGNUM,IMGNUMOUT,MWANT
      INTEGER                :: NINDX1,NINDX2,ICOUNT,ISLICE
      INTEGER                :: MAXIMIN,NOT_USED
      INTEGER                :: LOCAT,LOCAST,NANGT
      INTEGER                :: NXLD,NC,I,J,NXP1
      LOGICAL                :: ISBAREIN,ISBAREOUT,MIRROR,EVEN

      NULLIFY(PBUF)

      NILMAX  = NIMAXPLUS      ! FROM CMLIMIT
      ALLOCATE(ILIST1(NILMAX),
     &         ILIST2(NILMAX),
     &         STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN
          CALL ERRT(46,'ROTQSS; ILIST1....',2*NILMAX)
          RETURN
      ENDIF

C     OPEN INPUT IMAGE(S)
      CALL OPFILES(0,LUNIN,LUNDOC,LUNXM1,  .TRUE.,FILPATIN,NLET, 'O',
     &              ITYPE,NX,NY,NZ,MAXIMIN,
     &              NULL,
     &              .FALSE.,ILIST1,NILMAX, 
     &              NDUM,NANG,IMGNUM, IRTFLG) 
      IF (IRTFLG .NE. 0) RETURN
      LOCAT  = INDEX(FILPATIN,'@@')
      LOCAST = INDEX(FILPATIN,'*')
      IF (NANG > 0) ILIST2 = ILIST1

      !write(6,*)' Input image #: ',IMGNUM,nang,maximin,locast
      !writewrite(6,*)' Input image #: ',IMGNUM,nang,ilist1(1),maximin,locast
  
      IF (OLDRTSQ .AND. LOCAST <= 0) THEN
C        OLD 'RT SQ' & NO '*' PROMPT ORDER. OPEN OUTPUT IMAGE(S) NOW
         MAXIMOUT = -1            ! ALLOW BARE STACK
         IMGNUMOUT = 1            ! IMAGE # WANTED
         NANGT     = NANG
         !write(6,*)  'old input Image #: ',IMGNUM,nang,maximin,locast
         CALL OPFILES(LUNIN,LUNOUT,LUNDOC,LUNXM2,
     &            .TRUE.,FILPATOUT,NLET, 'U',
     &            ITYPE,NX,NY,NZ,MAXIMOUT,
     &            'OUTPUT FILE NAME OR TEMPLATE (E.G. ROT@@****)~',
     &            .FALSE., ILIST2,NANGT, 
     &            NDUM,NANGOUT, IMGNUMOUT, IRTFLG) 
         IF (IRTFLG .NE. 0) GOTO 9999
      ENDIF

      IF (NANG <= 0  .OR. 
     &    NANG == 1 .AND. ILIST1(1) == 0) THEN

C        SINGLE IMAGE OPERATION, READ IN THE ANGLES...
         THETA  = 0.0
         SCLI   = 1.0
         MIRROR = .FALSE.
         IF (CHKMIRROR) THEN
            FMIRROR = 0.0
            CALL RDPRM3S(THETA,SCLI,FMIRROR,NOT_USED,
     &          'ROTATION ANGLE, SCALE FACTOR, MIRROR (IF < 0)',
     &          IRTFLG)
            MIRROR = (FMIRROR <  0.0)
         ELSE
            CALL RDPRM2S(THETA,SCLI,NOT_USED,
     &                'ROTATION ANGLE, SCALE FACTOR',IRTFLG)
         ENDIF
	 IF (SCLI <= 0.0) SCLI = 1.0

         SHXI = 0.0
         SHYI = 0.0
	 CALL RDPRM2S(SHXI,SHYI,NOT_USED,
     &               'SHIFTS IN X AND Y',IRTFLG)
         IMGNUM = 0

      ELSE
C        HAVE MULTIPLE ANGLES, READ ANGLES... FROM A DOC. FILE
         IF (CHKMIRROR) THEN
             NUMB = 5
             NC   = 79
C                      123456789 123456789 123456789 123456789 12345 
             PROMPT = "ENTER REG. #'S FOR ANGLE, SCALE, X & Y " //
     &                "SHIFT, AND MIRROR (OR * FOR: 6,0,7,8,15)"
         ELSE
             NUMB = 4
             NC   = 64
C                      123456789 123456789 123456789 123456789 12345
             PROMPT = "ENTER REG. #'S FOR ANGLE, SCALE, X & Y " //
     &                "SHIFT (OR * FOR: 6,0,7,8)"
         ENDIF
         CALL RDPRAI(ILIST,5,NUMB,1,15,PROMPT(1:NC),'T',IRTFLG)
         IF (IRTFLG == -1) THEN
            ILIST(1) = 6  ! Usual  Reg. #s for angle, scale, & shift
            ILIST(2) = 0
            ILIST(3) = 7
            ILIST(4) = 8
            ILIST(5) = 15
            NUMB     = 5
            IRTFLG   = 0
         ENDIF

         IF (IRTFLG .NE. 0) GOTO 9999

C        MAXX IS 1 + NUM OF REGISTERS SINCE PBUF CONTAINS COUNT ALSO
         MAXX  = MAXVAL(ILIST) + 1
         MAXY  = 0
         CALL GETDOCDAT('ANGLE/SHIFT DOCUMENT',.TRUE.,DOCNAM,LUNDOC,
     &             .TRUE.,MAXX, MAXY,PBUF,IRTFLG)
         IF (IRTFLG .NE. 0) GOTO 9999
      ENDIF
      
       
      IF (.NOT. OLDRTSQ .OR. LOCAST > 0 .OR. 
     &   (.NOT. OLDRTSQ .AND. USERTSF)) THEN
C        'RT SQ'   WITH SET OF STACKED IMAGES, OPEN OUTPUT IMAGE(S) NOW
C        'RTD SQ'  OPEN OUTPUT IMAGE(S)
C        'RT  SF'  OPEN OUTPUT IMAGE(S)
         MAXIMOUT = -1            ! ALLOW BARE STACK
         IMGNUMOUT = IMGNUM       ! IMAGE # WANTED
         NANGT     = NANG

         IF (OLDRTSQ .AND. LOCAST > 0) THEN
C           'RT SQ' WITH IMG@@***, USE ILIST2, KLUDGE FOR BACKWARD COMPAT.
             NANGT = -NANGT
         ENDIF

         !write(6,*)'output Image #:',IMGNUMOUT,nang,maximout,filpatout(:11)

         CALL OPFILES(LUNIN,LUNOUT,LUNDOC,LUNXM2,
     &            .TRUE.,FILPATOUT,NLET, 'U',
     &            ITYPE,NX,NY,NZ,MAXIMOUT,
     &            'OUTPUT FILE NAME OR TEMPLATE (E.G. ROT@@****)~',
     &            .FALSE., ILIST2,NANGT, 
     &            NDUM,NANGOUT, IMGNUMOUT, IRTFLG) 

         IF (IRTFLG .NE. 0) GOTO 9999
      ENDIF
 
      EVEN = (MOD(NX,2) == 0)
      NXLD = NX 
      IF (USERTSF) NXLD = NX + 2 - MOD(NX,2)

      ALLOCATE (XIMG(NXLD,NY),
     &          BUF2(NX,NY), 
     &          STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN 
         MWANT = NXLD*NY + NX*NY 
         CALL ERRT(46,'ROTQSS; XIMG..',MWANT)
         GOTO 9999
      ENDIF  

      IF (CHKMIRROR) THEN
         ALLOCATE (BUFM(NX,NY), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN 
            CALL ERRT(46,'ROTQSS; BUFM..',NX*NY)
            GOTO 9999
         ENDIF  
      ENDIF

      NINDX1 = 1
      NINDX2 = 1
      DO 
         !write(6,*)  'Image #,nang:',IMGNUM,NANG

         IF (NANG > 1 .OR. (NANG == 1 .AND. ILIST1(1) > 0) ) THEN
C           MUST READ ANGLES FROM DOC FILE
            ICOUNT = PBUF(1,IMGNUM)
c                                 0      9    21   1              0
            !write(6,*)' ICOUNT: ',icount,maxx,maxy,imgnum,pbuf(:,imgnum)
            IF (ICOUNT .LT. (MAXX-1)) THEN
            write(6,*)' ICOUNT: ',icount,maxx,maxy,imgnum,pbuf(:,imgnum)
         write(nout,*)' ICOUNT: ',icount,maxx,maxy,imgnum,pbuf(:,imgnum)
               CALL ERRT(102,
     &           'LACK ROTATE/SHIFT PARAMETERS FOR IMAGE',IMGNUM)
               GOTO 9999
            ENDIF

            THETA = 0.0 
            IF (ILIST(1) > 0) THEN
               THETA = PBUF(ILIST(1)+1, IMGNUM)
            ENDIF

            SCLI  = 1.0
            IF (ILIST(2) > 0) THEN
               SCLI  = PBUF(ILIST(2)+1, IMGNUM)
	       IF (SCLI .EQ. 0.0) SCLI = 1.0
            ENDIF

            SHXI  = 0.0
            IF (ILIST(3) > 0) THEN
               SHXI  = PBUF(ILIST(3)+1, IMGNUM)
            ENDIF

            SHYI  = 0.0
            IF (ILIST(4) > 0) THEN
               SHYI  = PBUF(ILIST(4)+1, IMGNUM)
            ENDIF

            IF (CHKMIRROR) MIRROR = (PBUF(ILIST(5)+1, IMGNUM) < 0) 
         ENDIF

C        LOAD AND ROTATE VOLUME, SLICE BY SLICE
         DO ISLICE=1,NZ

C           READ INPUT IMAGE
            CALL READV(LUNIN,XIMG, NXLD,NY, NX,NY,ISLICE)

            IF (USERTSF) THEN
               !write(6,*)' Calling rtsf:',theta,scli,shxi,shyi
               CALL RTSF(XIMG, BUF2, 
     &                   NXLD, NX, NY,
     &                   THETA,SCLI,SHXI,SHYI,  IRTFLG)
               IF (IRTFLG .NE. 0) GOTO 9999
            ELSE
               !write(6,*)' Calling rtsq:',theta,scli,shxi,shyi
    	       CALL RTSQ(XIMG, BUF2, 
     &                   NX,NY, NX,NY,
     &                   THETA,SCLI,SHXI,SHYI, IRTFLG)
            ENDIF

C           WRITE OUTPUT IMAGE
            IF (.NOT. CHKMIRROR .OR. .NOT. MIRROR) THEN
               CALL WRITEV(LUNOUT,BUF2, NX,NY,NX,NY, ISLICE)
            ELSE
               NXP1 = NX+1
               DO J = 1,NY
                  IF (EVEN) THEN
C                    EVEN LINE LENGTH
                     DO I = 1,NX
 	                BUFM(MOD(NXP1-I,NX)+1,J) = BUF2(I,J) ! 1-->1,60-->2
                     ENDDO
                  ELSE
C                    ODD LINE LENGTH
                     DO I = 1,NX
                        BUFM(I,J) = BUF2(NXP1-I,J)  ! 1-->60,2-->59
                     ENDDO
                  ENDIF
               ENDDO
              
               CALL WRITEV(LUNOUT,BUFM, NX,NY,NX,NY, ISLICE)
            ENDIF

         ENDDO
         CALL SETPRMB(LUNOUT, 0,0, 0,0)

        IF (VERBOSE .AND. IMGNUM > 0) THEN
            IF (.NOT. CHKMIRROR) THEN 
               WRITE(NOUT,90)IMGNUM,THETA,SCLI,SHXI,SHYI 
          
90             FORMAT('  IMAGE:',I6,
     &                '  ANGLE:',F8.3,
     &                '  SCALE:',F7.3,
     &                '  SHIFT:(',F9.3,',',F9.3,')')
            ELSE          

               WRITE(NOUT,91)IMGNUM,THETA,SCLI,SHXI,SHYI,MIRROR 
91             FORMAT('  IMAGE:',I6,
     &                '  ANGLE:',F8.3,
     &                '  SCALE:',F7.3,
     &                '  SHIFT:(',F9.3,',',F9.3,')',
     &                '  MIRROR:  ',L)
            ENDIF
 
        ELSEIF (VERBOSE) THEN
            IF (.NOT. CHKMIRROR) THEN 
               WRITE(NOUT,92) THETA,SCLI,SHXI,SHYI 
          
92             FORMAT('  ANGLE:',F8.3,
     &                '  SCALE:',F7.3,
     &                '  SHIFT:(',F9.3,',',F9.3,')')
            ELSE          
               WRITE(NOUT,93)THETA,SCLI,SHXI,SHYI,MIRROR 
93             FORMAT('  ANGLE:',F8.3,
     &                '  SCALE:',F7.3,
     &                '  SHIFT:(',F9.3,',',F9.3,')',
     &                '  MIRROR:  ',L)
            ENDIF
         ENDIF

         IF (NINDX1 >= NANG) EXIT      ! END OF INPUT LIST
             
C        OPEN NEXT SET OF I/O FILES 
         CALL NEXTFILES(NINDX1, NINDX2, ILIST1,ILIST2, 
     &                  .FALSE.,LUNDOC,LUNXM2,
     &                  NANG,NANGOUT,   
     &                  MAXIMIN,MAXIMOUT,   
     &                  LUNIN,LUNIN,LUNOUT, FILPATIN,FILPATOUT,
     &                  IMGNUM,IMGNUMOUT, IRTFLG) 

c          write(6,'(A,5i6)')
c     &       ' Nextfiles imgnum,imgnumout,nindx1,nindx2,irtflg:',
c     &                   imgnum,imgnumout,nindx1,nindx2,irtflg

         IF (IRTFLG == -99) THEN
             CALL ERRT(102,'INSUFFICIENT OUTPUT FILE NAMES',NINDX2)
             EXIT         
         ELSEIF (IRTFLG < 0) THEN
             EXIT         ! END OF INPUT FILES
         ENDIF
         IF (IRTFLG .NE. 0) GOTO 9999    ! ERROR
      ENDDO

9999  IF (ALLOCATED(XIMG))      DEALLOCATE(XIMG)
      IF (ALLOCATED(BUF2))      DEALLOCATE(BUF2)
      IF (ALLOCATED(BUFM))      DEALLOCATE(BUFM)
      IF (ALLOCATED(ILIST1))    DEALLOCATE(ILIST1)
      IF (ALLOCATED(ILIST2))    DEALLOCATE(ILIST2)

C     DEALLOCATE DOC. FILE MEMORY
      IF (NANG > 1 .AND. ASSOCIATED(PBUF)) THEN
         DEALLOCATE(PBUF)
         NULLIFY(PBUF)
      ENDIF
      IF (VERBOSE) WRITE(NOUT,*) ' '

      CLOSE(LUNIN)
      CLOSE(LUNOUT)
      CLOSE(LUNXM1)
      CLOSE(LUNXM2)
      
      END

@


1.40
log
@NILMAX not = nimax,   bufm not deallocated bug
@
text
@d26 1
a26 1
C=* Email: spider@@wadsworth.org                                        *
@


1.39
log
@nullify pbuf always
@
text
@d101 1
a101 1
     &              .FALSE.,ILIST1,NIMAX, 
d109 1
a109 1
      !write(6,*)' Input image #: ',IMGNUM,nang,ilist1(1),maximin,locast
d380 1
@


1.38
log
@MIRROR = (FMIRROR <  0.0)
@
text
@d18 2
a19 1
C                    
d85 2
@


1.37
log
@MIRROR BUG
@
text
@d17 1
d133 3
a135 2
     &          'ROTATION ANGLE, SCALE FACTOR, MIRROR (YES=1)',IRTFLG)
            MIRROR = (FMIRROR == 1.0)
d164 1
a164 1
         IF (IRTFLG .EQ. -1) THEN
@


1.36
log
@IF (NANG <= 0 for _1@@1 bug
@
text
@d16 1
d81 2
a82 2
      INTEGER                :: NXLD,NC,I,J
      LOGICAL                :: ISBAREIN,ISBAREOUT,MIRROR
a145 1
         MIRROR = (CHKMIRROR) 
d209 2
a210 1
      NXLD   = NX 
d295 1
d297 11
a307 3
                  DO I = 1,NX
                     BUFM(I,J) = BUF2(NX-I+1,J)
                  ENDDO
d309 1
@


1.35
log
@(NANG == 1 .AND. ILIST1(1) > 0.
@
text
@d103 2
a104 2
      !write(6,*)  ' Input image #: ',IMGNUM,nang,maximin,locast
      !write(6,*)  ' Input image #: ',IMGNUM,nang,ilist1(1)
d121 3
a123 1
      IF (NANG <= 1 .AND. ILIST1(1) == 0) THEN
@


1.34
log
@*** empty log message ***
@
text
@d15 2
a16 1
C
d230 1
a230 1
         !write(6,*)  'Image #:',IMGNUM
d232 2
a233 1
         IF (NANG > 1) THEN
d276 1
a276 1
               ! write(6,*)' Calling rtsf:',theta,scli,shxi,shyi
@


1.33
log
@ilist1(1) is zero if only a single input
@
text
@d103 1
a103 1
     ! write(6,*)  ' Input image #: ',IMGNUM,nang,ilist1(1)
@


1.32
log
@mirror if only one image
@
text
@d103 1
d120 1
a120 1
      IF (NANG <= 1) THEN
@


1.31
log
@ILIST(3) > 0 for non-shift in doc file
@
text
@d72 1
a72 1
      REAL                   :: THETA,SCLI,SHXI,SHYI,SCALE
d121 12
a132 4
         THETA = 0.0
         SCLI  = 1.0
         CALL RDPRM2S(THETA,SCLI,NOT_USED,
     &                'ROTATION ANGLE, SCALE',IRTFLG)
@


1.30
log
@IF (.NOT. CHKMIRROR bug fixed
@
text
@d233 6
a238 2
 
            THETA = PBUF(ILIST(1)+1, IMGNUM)
d245 10
a254 2
            SHXI  = PBUF(ILIST(3)+1, IMGNUM)
            SHYI  = PBUF(ILIST(4)+1, IMGNUM)
@


1.29
log
@prompt for regs, mirror if single image
@
text
@d266 1
a266 1
            IF (.NOT. MIRROR) THEN
@


1.28
log
@added chkmirror
@
text
@d133 1
a133 5
         IF (CHKMIRROR) THEN
            CALL RDPRMC(ANS,NC,.TRUE.,
     &                  'MIRROR (Y/N)?',NULL,IRTFLG)
            MIRROR = (ANS == 'M')
         ENDIF
d138 1
a138 1
             NC   = 80
d140 1
a140 1
             PROMPT = "ENTER REG. #'S FOR ANGLE, SCALE, X, & Y " //
d144 1
a144 1
             NC   = 65
d146 1
a146 1
             PROMPT = "ENTER REG. #'S FOR ANGLE, SCALE, X, & Y " //
@


1.27
log
@removed debug output
@
text
@d14 1
d47 1
a47 1
     &                  OLDRTSQ,USERTSF,IRTFLG)
d54 1
a54 1
      LOGICAL                :: OLDRTSQ, USERTSF
d61 1
a61 1
      REAL,    ALLOCATABLE   :: XIMG(:,:),BUF2(:,:)
d64 1
a64 1
      INTEGER                :: ILIST(4)
d67 1
d79 2
a80 2
      INTEGER                :: NXLD
      LOGICAL                :: ISBAREIN,ISBAREOUT
d119 1
a119 1
      IF (NANG .LE. 1) THEN
d121 10
a130 4
         CALL RDPRM2(THETA,SCLI,NOT_USED,'ROTATION ANGLE, SCALE')
	 IF (SCLI .LE. 0.0) SCLI = 1.0

	 CALL RDPRM2(SHXI,SHYI,NOT_USED,'SHIFTS IN X AND Y')
d133 5
d140 14
a153 5
         NUMB = 4
C                  123456789 123456789 123456789 123456789 123456789 
         PROMPT = "ENTER REG. #'S FOR ANGLE, SCALE, X, & Y " //
     &            "SHIFT (OR * FOR: 6,0,7,8)"
         CALL RDPRAI(ILIST,4,NUMB,1,6,PROMPT(1:65),'T',IRTFLG)
d159 2
a160 1
            NUMB     = 4
d213 8
d247 1
d270 10
a279 1
            CALL WRITEV(LUNOUT,BUF2, NX,NY,NX,NY, ISLICE)
d284 3
a286 2
         IF (VERBOSE .AND. IMGNUM > 0) THEN
            WRITE(NOUT,90)IMGNUM,THETA,SCLI,SHXI,SHYI 
d288 17
a304 6
90          FORMAT('  IMAGE:',I6,
     &             '  ANGLE:',F8.3,
     &             '  SCALE:',F7.3,
     &             '  SHIFT:(',F9.3,',',F9.3,')')
         ELSEIF (VERBOSE) THEN
            WRITE(NOUT,91)THETA,SCLI,SHXI,SHYI 
d306 10
a315 3
91          FORMAT('  ANGLE:',F8.3,
     &             '  SCALE:',F7.3,
     &             '  SHIFT:(',F9.3,',',F9.3,')')
@


1.26
log
@INSUFFICIENT OUTPUT FILE NAMES trap added
@
text
@d225 1
a225 1
               write(6,*)' Calling rtsf:',theta,scli,shxi,shyi
@


1.25
log
@PROMPT length
@
text
@d13 2
a14 1
C               
d222 1
a222 1
            CALL READV(LUNIN,XIMG, NXLD,NY,NX,NY,ISLICE)
d225 1
a225 1
               !write(6,*)' Calling rtsf:',theta,scli,shxi,shyi
d268 10
a277 4
!         write(6,'(A,5i6)')' Nxtfiles img?,nindx?,eflg:',
!     &       imgnum,imgnumout,nindx1,nindx2,irtflg

         IF (IRTFLG .LT. 0) EXIT         ! END OF INPUT STACK
d287 3
a289 5
      IF (NANG > 1) THEN
         IF (ASSOCIATED(PBUF)) THEN
            DEALLOCATE(PBUF)
            NULLIFY(PBUF)
         ENDIF
@


1.24
log
@verbose on WRITE(NOUT,91)THETA,SCLI,.....
@
text
@d130 1
a130 1
         CALL RDPRAI(ILIST,4,NUMB,1,6,PROMPT,'T',IRTFLG)
@


1.23
log
@NSAM --> NX, RTSQ CALL PARAM
@
text
@d249 1
a249 1
         ELSE
@


1.22
log
@RENAMED ROT2QS --> RTSQ
@
text
@d4 9
a12 8
C  ROTQSS.F      ADDED STACK OPERATION                  98 ARDEAN LEITH 
C                USED AUTO. ARRAYS                 5/02/00 ARDEAN LEITH
C                SELECTION FILE ADDED             12/15/06 ARDEAN LEITH
C                MULTIFILE SUPPORT ADDED          12/17/10 ARDEAN LEITH
C                MERGED WITH ROTQSS_DL             1/10/11 ARDEAN LEITH
C                ADDED RTKSQ                       5/20/11 ARDEAN LEITH
C                RENAMED RTKSQ --> RTFS            6/02/11 ARDEAN LEITH
C                RENAMED ROT2QS --> RTSQ          12/28/11 ARDEAN LEITH
d18 1
a18 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d59 1
a59 1
      REAL,    ALLOCATABLE   :: XIMG(:),XIMGF(:,:),BUF2(:,:),BUFLIN(:)
d70 1
a70 1
      INTEGER                :: NILMAX,MAXIMOUT,ITYPE,NSAM,NROW,NSLICE
d73 1
a73 1
      INTEGER                :: NINDX1,NINDX2,ICOUNT,ISLICE,IREC1
a76 1

d90 1
a90 1
     &              ITYPE,NSAM,NROW,NSLICE,MAXIMIN,
d109 1
a109 1
     &            ITYPE,NSAM,NROW,NSLICE,MAXIMOUT,
d169 1
a169 1
     &            ITYPE,NSAM,NROW,NSLICE,MAXIMOUT,
d177 2
a178 9
      IF (USERTSF) THEN
         NXLD   = NSAM + 2 - MOD(NSAM,2)
         ALLOCATE (XIMGF(NXLD,NROW),BUF2(NSAM,NROW), 
     &             STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN 
            MWANT = NXLD*NROW + NSAM*NROW 
            CALL ERRT(46,'ROTQSS; XIMGF',MWANT)
            GOTO 9999
         ENDIF  
d180 8
a187 8
      ELSE
         ALLOCATE (XIMG(NSAM*NROW), BUFLIN(NSAM), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN 
            MWANT = NSAM*NROW + NSAM
            CALL ERRT(46,'ROTQSS; XIMG',MWANT)
            GOTO 9999
         ENDIF  
      ENDIF
d194 1
a194 1
         IF (NANG .GT. 1) THEN
d208 1
a208 1
            IF (ILIST(2) .GT. 0) THEN
d218 4
a221 1
         DO ISLICE=1,NSLICE
d224 4
a227 8
C              READ INPUT IMAGE
               CALL READV(LUNIN,XIMGF,NXLD,NROW,NSAM,NROW,ISLICE)

               !write(6,*)' calling rtsf:',THETA,SCLI,SHXI,SHYI
               CALL RTSF(XIMGF,BUF2, 
     &                   NXLD, NSAM, NROW,
     &                   THETA,SCLI,SHXI,SHYI, 
     &                   IRTFLG)
d229 6
d236 2
a237 6
C              WRITE OUTPUT IMAGE
               CALL WRITEV(LUNOUT,BUF2,NSAM,NROW,NSAM,NROW,ISLICE)

            ELSE
               CALL REDVOL(LUNIN,NSAM,NROW, ISLICE,ISLICE, XIMG,IRTFLG)
               IREC1 = (ISLICE-1) * NROW
a238 4
               !write(6,*)' calling rtsq:',THETA,SCLI,SHXI,SHYI
    	       CALL RTSQ(XIMG,BUFLIN, NSAM,NROW,
     &                  THETA,SCLI,SHXI,SHYI, IREC1,LUNOUT)
           ENDIF
d268 1
a268 1
!     &      imgnum,imgnumout,nindx1,nindx2,irtflg
a274 1
      IF (ALLOCATED(XIMGF))     DEALLOCATE(XIMGF)
a275 1
      IF (ALLOCATED(BUFLIN))    DEALLOCATE(BUFLIN)
@


1.21
log
@eror message output
@
text
@d11 1
d245 2
a246 2
               !write(6,*)' calling rot2qs:',THETA,SCLI,SHXI,SHYI
    	       CALL ROT2QS(XIMG,BUFLIN, NSAM,NROW,
@


1.20
log
@reverted to rt sq question order for 'RT SF', added 'RTD SF' support
@
text
@d178 1
a178 1
         ALLOCATE (XIMGF(NXLD, NROW),BUF2(NSAM,NROW), 
d205 2
d230 2
a231 2
              !write(6,*)' calling rtsf:',THETA,SCLI,SHXI,SHYI
              CALL RTSF(XIMGF,BUF2, 
@


1.19
log
@ILIST1, ILIST2, USERTSF checks
@
text
@d98 1
a98 1
      !write(6,*)  'input Image #: ',IMGNUM,nang,maximin,locast
d148 1
d150 2
a151 1
      IF (.NOT. OLDRTSQ .OR. LOCAST > 0 .OR. USERTSF) THEN
d163 1
d165 1
d172 1
d228 2
a229 1
               CALL RTSF(XIMGF,BUF2, 
d242 1
@


1.18
log
@renamed rtksq j--> rtsf
@
text
@d58 2
a59 1
      INTEGER, ALLOCATABLE   :: INUMBROUT(:)
d78 8
a85 1
      ! INUMBR(NIMAX)   FROM CMLIMIT
d91 1
a91 1
     &              .FALSE.,INUMBR,NIMAX, 
d96 1
d101 1
a101 1
C        OLD 'RT SQ' PROMPT ORDER. OPEN OUTPUT IMAGE(S)
d104 1
a104 1

d110 1
a110 1
     &            .FALSE., INUMBROUT,NANG, 
a146 6

         ALLOCATE(INUMBROUT(NANG), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'ROTQSS; INUMBROUT', NANG)
            GOTO 9999
         ENDIF
d149 4
a152 2
      IF (.NOT. OLDRTSQ .OR. LOCAST > 0) THEN
C        NEW 'RT SQ' PROMPT ORDER. OPEN OUTPUT IMAGE(S)
d156 1
d158 2
a159 3
C           'RT SQ' WITH IMG@@***, USE INUMBERT, KLUDGE FOR BACKWARD COMPAT.
             INUMBROUT = INUMBR
             NANGT     = -NANGT
d166 1
a166 1
     &            .FALSE., INUMBROUT,NANGT, 
d260 1
a260 1
         CALL NEXTFILES(NINDX1, NINDX2, INUMBR,INUMBROUT, 
d278 2
a279 1
      IF (ALLOCATED(INUMBROUT)) DEALLOCATE(INUMBROUT)
@


1.17
log
@removed debug output
@
text
@d9 2
a10 1
C                added RTKSQ                       1/10/11 ARDEAN LEITH
d34 1
a34 1
C   ROTQSS(LUNIN,LUNOUT,LUNDOC,LUNXM1,LUNXM2,OLDRTSQ, IRTFLG)
d43 1
a43 1
     &                  OLDRTSQ,USERTKSQ,IRTFLG)
d50 1
a50 1
      LOGICAL                :: OLDRTSQ, USERTKSQ
d166 1
a166 1
      IF (USERTKSQ) THEN
d214 1
a214 1
            IF (USERTKSQ) THEN
d218 4
a221 4
               CALL RTKSQ(XIMGF,BUF2, 
     &                    NXLD, NSAM, NROW,
     &                    THETA,SCLI,SHXI,SHYI, 
     &                    IRTFLG)
@


1.16
log
@rtksq
@
text
@a237 1
            write(6,90)imgnum,theta,scli,shxi,shyi 
@


1.15
log
@'RTK' fbs
@
text
@d217 1
a217 1
               CALL RTSQK(XIMGF,BUF2, 
@


1.14
log
@rtksq calls
@
text
@d9 2
a10 1
C
d42 1
a42 1
     &                  OLDRTSQ,RTKSQ,IRTFLG)
d48 3
a50 1
      INTEGER                :: LUNIN,LUNOUT,LUNDOC,LUNXM,IRTFLG
d70 1
a70 1
      INTEGER                :: LUNXM1,LUNXM2,MAXIMIN,NOT_USED
d72 1
d74 1
a74 2
      LOGICAL                :: ISBAREIN,ISBAREOUT,OLDRTSQ
      LOGICAL                :: RTKSQ
d165 1
a165 1
      IF (RTKSQ) THEN
d213 1
a213 1
            IF (RTSQK) THEN
d215 1
a215 1
               CALL READV(LUN1,XIMGF,NXLD,NROW,NSAM,NROW,ISLICE)
d221 1
a221 1
               IF (IRFLG .NE. 0) GOTO 9999
@


1.13
log
@IF (NANG > 1) osx mpi compiler bug?
@
text
@d41 1
a41 1
     &                     OLDRTSQ,IRTFLG)
d53 1
a53 1
      REAL,    ALLOCATABLE   :: XIMG(:),BUFLIN(:)
d71 1
d162 19
a180 7
      ALLOCATE (XIMG(NSAM*NROW), BUFLIN(NSAM), STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN 
         MWANT = NSAM*NROW + NSAM
         CALL ERRT(46,'ROTQSS; XIMG',MWANT)
         GOTO 9999
      ENDIF  
   
a208 2
            CALL REDVOL(LUNIN,NSAM,NROW, ISLICE,ISLICE, XIMG,IRTFLG)
            IREC1 = (ISLICE-1) * NROW
d210 18
a227 1
    	    CALL ROT2QS(XIMG,BUFLIN, NSAM,NROW,
d229 1
d267 2
@


1.12
log
@comments
@
text
@d106 1
a106 1
	 CALL  RDPRM2(SHXI,SHYI,NOT_USED,'SHIFTS IN X AND Y')
d136 1
a136 1
            CALL ERRT(46,'INUMBROUT', NANG)
d164 1
a164 1
         CALL ERRT(46,'ROTQSS, XIMG',MWANT)
d242 5
a246 3
      IF (ASSOCIATED(PBUF)) THEN
          DEALLOCATE(PBUF)
          NULLIFY(PBUF)
@


1.11
log
@'RT SQ' WITH IMG@@***, USE INUMBERT, KLUDGE
@
text
@d229 4
a234 3

         !write(6,'(a,3i6)')' Imgnum,nindxs:',imgnum,nindx1,nindx2
         !write(6,'(a,3i6)')' Imgnumout:',imgnumout,inumbr(nindx2)
@


1.10
log
@rot2qs_dl --> rot2qs
@
text
@d68 1
a68 1
      INTEGER                :: LOCAT,LOCAST
d83 1
d90 2
d130 1
a130 1
         CALL GETDOCDAT('ANGLE/SCALE DOCUMENT',.TRUE.,DOCNAM,LUNDOC,
d145 7
d156 1
a156 1
     &            .FALSE., INUMBROUT,NANG, 
d171 1
a171 1
         !write(6,*)  'Image #: ',IMGNUM
d176 1
a176 1
           !write(6,*)' ICOUNT: ',icount,maxx,maxy,imgnum,pbuf(:,imgnum)
a188 1
c           write(6,*) 'scli:',scli, ilist
d206 1
d232 2
a233 1
         !write(6,*) ' imgnumout: ',imgnumout,nindx1,inumbr(nindx1)
@


1.9
log
@removed commented out routine: rot2qs
@
text
@d190 1
a190 1
    	    CALL ROT2QS_DL(XIMG,BUFLIN, NSAM,NROW,
@


1.8
log
@merged rotqss & rotqss_dl
refactored.
@
text
@a191 3

c	    CALL ROT2QS(XIMG,BUFLIN,NSAM,NROW,
c     &                 THETA,SCLI,SHXI,SHYI, LUNOUT,IREC1)
@


1.7
log
@opfiles parameters
@
text
@d1 1
a4 1
C                USED GETOLDSTACK                  1/11/99 ARDEAN LEITH
d6 4
a9 5
C                GETNEWSTACK PARAM.                2/24/03 ARDEAN LEITH
C                IMGNUM IN STACK OUTPUT            6/24/05 ARDEAN LEITH
C                'RT SQS'                         12/15/06 ARDEAN LEITH
C                'RTD'                            12/30/06 ARDEAN LEITH
C                GETNEWSTACK PARAM                OCT 2010 ARDEAN LEITH
d14 1
a14 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d32 1
a32 175
C   ROTQSS(LUN1,LUN2,LUNDOC,IRTFLG)
C
C   PURPOSE:  ROTATE, SCALE, AND SHIFT IMAGES INSIDE A STACK FILE.
C             USES A SELECTION DOC FILE
C             TAKE TRANSFORMATION PARAMETERS FROM A DOC FILE
C
C--*********************************************************************

      SUBROUTINE ROTQSS(FILPAT,LUN1,LUN2,LUNDOC,IRTFLG)

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      INTEGER                  :: ILIST(4)
      CHARACTER (LEN=*)        :: FILPAT
      CHARACTER (LEN=MAXNAM)   :: DOCNAM,BAREFILE,FILOUT
      CHARACTER (LEN=1)        :: NULL

      REAL, ALLOCATABLE        :: QBUF1(:),QBUF2(:)

C     DOC FILE POINTER
      INCLUDE 'F90ALLOC.INC'
      REAL, POINTER            :: PBUF(:,:)

      NULL = CHAR(0)

      CALL FILELIST(.FALSE.,LUNDOC,CDUM,NDUM,INUMBR,NIMAX,
     &              NUMT,' ',IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

C     FIND LOCATION OF FIRST * IN FILPAT
      NLETP  = lnblnkn(FILPAT)
      LOCAST = INDEX(FILPAT,'*')
      IF (LOCAST .EQ. 0)  LOCAST = NLETP+1
      BAREFILE = FILPAT(1:LOCAST-1)
       
      MAXIM = 1
      CALL OPFILEC(0,.FALSE.,BAREFILE,LUN1,'O',IFORM,NSAM,NROW,NSLICE,
     &               MAXIM,' ',.TRUE.,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

      IF (MAXIM .EQ. 0) THEN
C        INPUT IS NOT STACK
         CALL ERRT(46,'OPERATION ONLY WORKS ON STACKS',NDUM)
      ENDIF  

      ALLOCATE (QBUF1(NSAM*NROW),QBUF2(NSAM), STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN 
         MWANT = NSAM*NROW + NSAM
         CALL ERRT(46,'ROTQS, QBUF1',MWANT)
         RETURN
      ENDIF  
   
      NUMB = 4
      CALL RDPRAI(ILIST,4,NUMB,1,6,
     &      'ENTER REG. NUMBERS FOR ANGLE, SCALE, X, & Y SHIFT',
     &      'T',IRTFLG)
      IF (IRTFLG .NE. 0) GOTO 999

C     MAXX IS 1 + NUM OF REGISTERS SINCE PBUF CONTAINS COUNT ALSO
      MAXX  = MAXVAL(ILIST) + 1
      MAXY  = 0
      CALL GETDOCDAT('ANGLE/SCALE DOCUMENT',.TRUE.,DOCNAM,LUNDOC,
     &             .TRUE.,MAXX, MAXY,PBUF,IRTFLG)
      IF (IRTFLG .NE. 0) GOTO 999

C     OPEN OUTPUT STACK
      CALL FILERD(FILOUT,NLET,NULL,'OUTPUT STACK',IRTFLG)
c      write(6,*)' got filout:',filout

      LOCAT = INDEX(FILOUT(1:NLET),'@@')
      IF (LOCAT .EQ. 0) THEN
C        NO '@@' IN OUTPUT FILE NAME, ADD IT
         IF (NLET .GE. MAXNAM) THEN
            CALL ERRT(102,'FILE NAME LENGTH OVERFLOW',MAXNAM-1)
            IRTFLG = 1
            GOTO 999
         ENDIF
         FILOUT(NLET+1:NLET+2) = '@@' // NULL
      ENDIF
c      write(6,*)' opening filout:',filout

      MAXIMOUT = 1
      CALL OPFILEC(0,.FALSE.,FILOUT,LUN2,'U',IFORM,NSAM,NROW,NSLICE,
     &               MAXIMOUT,'OUTPUT STACK',.FALSE.,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN
C     write(6,*)' opened filout:',filout

      IF (MAXIM .EQ. 0) THEN
C        INPUT IS NOT STACK,  UNFINISHED!!!!!
         CALL ERRT(101,'OPERATION ONLY WORKS ON STACKS',NDUM)
         GOTO 999

      ELSEIF (MAXIM .GT. 0) THEN
C        INPUT IS STACK
         DO  I=1, NUMT
            IMGNUM = INUMBR(I)

C           GET INPUT IMAGE FROM STACK            
            CALL GETOLDSTACK(LUN1,NSAM,IMGNUM,
     &                       .FALSE.,.TRUE.,.TRUE.,IRTFLG)
            IF (IRTFLG .NE. 0) THEN
              CALL ERRT(102,'NO SUCH STACKED IMAGE',IMGNUM)
              GOTO 999
            ENDIF
           
C           CREATE OUTPUT IMAGE IN OUTPUT STACK
            CALL GETNEWSTACK(LUN1,LUN2,.FALSE.,NSAM,IMGNUM,IRTFLG)
            IF (IRTFLG .NE. 0) THEN
               CALL ERRT(102,'UNABLE TO CREATE STACKED IMAGE',IMGNUM)
               GOTO 999
            ENDIF

C           OUTPUT IMAGE CREATED OK
            ICOUNT = PBUF(1,IMGNUM)
c           write(6,*)' ICOUNT: ',ICOUNT,maxx,maxy
            IF (ICOUNT .LT. (MAXX-1)) THEN
               CALL ERRT(102,'INSUFFICIENT PARAMETERS FOR IMAGE',IMGNUM)
               GOTO 999
            ENDIF
 
            THETA = PBUF(ILIST(1)+1, IMGNUM)
            SCLI  = 1.0
            IF (ILIST(2) .GT. 0) THEN
               SCLI  = PBUF(ILIST(2)+1, IMGNUM)
	       IF (SCLI .EQ. 0.0) SCLI = 1.0
            ENDIF
c           write(6,*) 'scli:',scli, ilist


            SHXI  = PBUF(ILIST(3)+1, IMGNUM)
            SHYI  = PBUF(ILIST(4)+1, IMGNUM)

C           LOAD AND ROTATE SLICE BY SLICE
            DO L=1,NSLICE
               CALL REDVOL(LUN1,NSAM,NROW,L,L,QBUF1,IRTFLG)
               LB = (L-1)*NROW
	       CALL ROT2QS(QBUF1,QBUF2,NSAM,NROW,
     &                     THETA,SCLI,SHXI,SHYI, LUN2,LB)
            ENDDO

            IF (VERBOSE) WRITE(NOUT,90)IMGNUM,THETA,SCLI,SHXI,SHYI 
90          FORMAT(' IMAGE: ',I6,
     &             '  ANGLE: ',G10.3,
     &             '  SCALE: ',G8.3,
     &             '  SHIFT: (',G10.3,',',G10.3,')')

         ENDDO

C        DEALLOCATE DOC. FILE MEMORY
         IF (ASSOCIATED(PBUF)) THEN
            DEALLOCATE(PBUF)
            NULLIFY(PBUF)
         ENDIF
      ENDIF

999   IF (ALLOCATED(QBUF1)) DEALLOCATE(QBUF1)
      IF (ALLOCATED(QBUF2)) DEALLOCATE(QBUF2)

      RETURN
      END



C CALLed IN UTIL3  jan07 al

C++*********************************************************************
C
C  ROTQSS_DL.F           ADDED STACK OPERATION          98 ARDEAN LEITH 
C                        USED AUTO. ARRAYS         5/02/00 ARDEAN LEITH
C                        SELECTION FILE ADDED     12/15/06 ARDEAN LEITH
C                        MULTIFILE SUPPORT ADDED  12/17/10 ARDEAN LEITH
C **********************************************************************
C
C   ROTQSS_DL(LUNIN,LUNOUT,LUNDOC,IRTFLG)
d40 2
a41 1
      SUBROUTINE ROTQSS_DL(LUNIN,LUNOUT,LUNDOC,LUNXM1,LUNXM2, IRTFLG)
d43 1
d49 6
a54 1
      LOGICAL                :: ISBAREIN,ISBAREOUT
d59 2
a60 2
      REAL,    ALLOCATABLE   :: XIMG(:),BUFLIN(:)
      INTEGER, ALLOCATABLE   :: INUMBROUT(:)
d62 7
a68 3
C     DOC FILE POINTER
      INCLUDE 'F90ALLOC.INC'
      REAL, POINTER          :: PBUF(:,:)
d70 1
a70 1
      CHARACTER (LEN=1)      :: NULL = CHAR(0)
d72 1
a72 1
      NILMAX = NIMAX            ! FROM CMLIMIT
a74 1
      MAXIMIN = -1              ! ALLOW BARE STACK
d78 1
a78 1
     &              .FALSE.,INUMBR,NILMAX, 
d81 3
d85 13
a98 7
C        SINGLE IMAGE OPERATION, OPEN OUTPUT FILE NOW 
         MAXIMOUT = 0 
         CALL OPFILEC(LUNIN,.TRUE.,FILNAM,LUNOUT,'U',
     &                ITYPE,NSAM,NROW,NSLICE, 
     &                MAXIMOUT,'OUTPUT',.FALSE.,IRTFLG) 
        IF (IRTFLG .NE. 0) GOTO 9999 

d105 1
d108 13
a121 4
         NUMB = 4
         CALL RDPRAI(ILIST,4,NUMB,1,6,
     &      'ENTER REG. NUMBERS FOR ANGLE, SCALE, X, & Y SHIFT',
     &      'T',IRTFLG)
d136 4
a139 2

C        OPEN OUTPUT IMAGE(S)
d141 1
d145 1
a145 1
     &            'OUTPUT IMAGE FILE NAME OR TEMPLATE (E.G. ROT@@****)~',
d150 1
a150 10
      CALL LUNGETISBARE(LUNIN,ISBAREIN,IRTFLG)
      CALL LUNGETISBARE(LUNIN,ISBAREOUT,IRTFLG)
      IF ((ISBAREIN  .AND. .NOT. ISBAREOUT ) .OR. 
     &    (.NOT. ISBAREIN  .AND. ISBAREOUT)) THEN
         WRITE(6,*) 
     &   ' WARNING, OUTPUT IMAGE NUMBER MAY DIFFER FROM INPUT?'
         WRITE(NOUT,*) 
     &   ' WARNING, OUTPUT IMAGE NUMBER MAY DIFFER FROM INPUT?',CHAR(7)
      ENDIF

d161 1
a161 1
c         write(6,*)  'Image #: ',IMGNUM
d165 2
a166 1
c           write(6,*)' ICOUNT: ',icount,maxx,maxy
d168 2
a169 1
               CALL ERRT(102,'INSUFFICIENT PARAMETERS FOR IMAGE',IMGNUM)
d189 2
a190 1
   	    CALL ROT2QS_DL(XIMG,BUFLIN, NSAM,NROW,
d192 3
d196 1
d198 14
a211 5
         IF (VERBOSE) WRITE(NOUT,90)IMGNUM,THETA,SCLI,SHXI,SHYI 
90       FORMAT(' IMAGE: ',I6,
     &          '  ANGLE: ',G10.3,
     &          '  SCALE: ',G8.3,
     &          '  SHIFT: (',G10.3,',',G10.3,')')
d224 2
d237 1
d243 1
a243 1
      RETURN
@


1.6
log
@GETNEWSTACK PARAM
@
text
@d46 4
a49 4
      INTEGER                         :: ILIST(4)
      CHARACTER (LEN=*)               :: FILPAT
      CHARACTER (LEN=MAXNAM)          :: DOCNAM,BAREFILE,FILOUT
      CHARACTER (LEN=1)               :: NULL
d51 1
a51 1
      REAL, ALLOCATABLE, DIMENSION(:) :: QBUF1,QBUF2
d55 1
a55 1
      REAL, DIMENSION(:,:), POINTER   :: PBUF
d195 2
d204 1
d210 1
a210 1
C             CAN USES A SELECTION DOC FILE
d215 1
a215 1
      SUBROUTINE ROTQSS_DL(LUNIN,LUNOUT,LUNDOC,IRTFLG)
d220 6
a225 4
      LOGICAL                            :: ISBAREIN,ISBAREOUT
      INTEGER                            :: ILIST(4)
      CHARACTER (LEN=MAXNAM)             :: FILPATIN,FILPATOUT,FILNAM
      CHARACTER (LEN=MAXNAM)             :: DOCNAM
d227 2
a228 2
      REAL,    ALLOCATABLE, DIMENSION(:) :: XIMG,BUFLIN
      INTEGER, ALLOCATABLE, DIMENSION(:) :: INUMBROUT
d232 1
a232 1
      REAL, DIMENSION(:,:), POINTER      :: PBUF
d234 1
a234 1
      NILMAX = NIMAX                    ! FROM CMLIMIT
d236 9
a244 4
      CALL OPFILES(0,LUNIN,LUNDOC, FILPATIN,NLET, 'O',
     &             ITYPE,NSAM,NROW,NSLICE,MAXIM,
     &             'IMAGE FILE NAME OR TEMPLATE (E.G. STK@@****)~',
     &             .FALSE., INUMBR,NILMAX, NANG,IMGNUM, IRTFLG) 
d246 1
a246 1

d249 1
a249 1
         MAXIM = 0 
d252 1
a252 1
     &                MAXIM,'OUTPUT',.FALSE.,IRTFLG) 
d284 4
a287 2
         CALL OPFILES(LUNIN,LUNOUT,LUNDOC, FILPATOUT,NLET, 'U',
     &             ITYPE,NSAM,NROW,NSLICE,MAXIM,
d289 2
a290 1
     &            .FALSE., INUMBROUT,NANG, NANGT, IMGNUMOUT, IRTFLG) 
d310 2
a311 1
      NWANT = 1
d349 1
a349 1
         IF (NWANT .GE. NANG) EXIT      ! END OF INPUT LIST
d352 6
a357 4
         CALL NEXTFILES(NWANT, INUMBR,INUMBROUT,   
     &                  LUNIN,LUNIN,LUNOUT,
     &                  FILPATIN,FILPATOUT,
     &                  IMGNUM,IMGNUMOUT,IRTFLG) 
d374 2
a375 1

@


1.5
log
@GPL_2010
@
text
@d3 8
a10 7
C  ROTQSS.F               ADDED STACK OPERATION          98 ARDEAN LEITH 
C                         USED GETOLDSTACK          1/11/99 ARDEAN LEITH
C                         USED AUTO. ARRAYS         5/02/00 ARDEAN LEITH
C                         GETNEWSTACK PARAM.        2/24/03 ARDEAN LEITH
C                         IMGNUM IN STACK OUTPUT    6/24/05 ARDEAN LEITH
C                         'RT SQS'                 12/15/06 ARDEAN LEITH
C                         'RTD'                    12/30/06 ARDEAN LEITH
d140 1
a140 1
            CALL GETNEWSTACK(LUN1,LUN2,NSAM,IMGNUM,IRTFLG)
a199 1
C                        USED GETOLDSTACK          1/11/99 ARDEAN LEITH
a200 2
C                        GETNEWSTACK PARAM.        2/24/03 ARDEAN LEITH
C                        IMGNUM IN STACK OUTPUT    6/24/05 ARDEAN LEITH
a201 1
C **********************************************************************
@


1.4
log
@OUTPUT IMAGE NUMBER MAY DIFFER FROM INPUT
@
text
@a10 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d12 5
a16 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d18 1
a18 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d23 1
a23 1
C=* This program is distributed in the hope that it will be useful,    *
d25 1
a25 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a26 1
C=*                                                                    *
d28 1
a28 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
a204 23
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
@


1.3
log
@RTD SQ
@
text
@d9 1
d12 1
a12 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a199 1

d202 1
a202 1
C  ROTQSS_DL.F              ADDED STACK OPERATION          98 ARDEAN LEITH 
d210 1
a210 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d247 1
d310 9
@


1.2
log
@bug fixed
@
text
@d196 186
@


1.1
log
@RT SQ for use with selection files
@
text
@d103 5
a107 1
      IF (FILOUT(NLET:NLET) .NE. '@@') THEN
d115 1
a115 1
C     write(6,*)' filout:',filout
d119 1
a119 1
     &               MAXIMOUT,'OUTPUT STACK',.TRUE.,IRTFLG)
d121 1
a147 2
c           write(6,*) pbuf(:,IMGNUM)

a181 2
C           RESET HEADER FOR ALTERATIONS IN STATISTICS
            CALL SETPRMB(QBUF2,LUN2,NSAM,IDUM,0.0,0.0,0.0,'U')
a195 1

@

