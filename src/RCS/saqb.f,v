head	1.29;
access;
symbols
	healthdept_2018:1.29
	pre_getangas:1.26
	GPL2010:1.26
	pre_GPL2010:1.25
	pre_var_equation:1.25
	pre_fftwrings:1.25
	pre_opfiles:1.24
	src:1.24
	best-code:1.24
	x-named-regs:1.24
	x:1.24
	v13-00:1.24
	pre_GPL:1.22
	prec_CA:1.22
	noindx:1.21
	Bproc:1.19
	oct21:1.13
	last77:1.12;
locks; strict;
comment	@c @;


1.29
date	2018.10.03.14.34.16;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2012.09.10.15.35.23;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2012.03.21.18.46.56;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.24.13.26.51;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.19.16.33.52;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2005.10.17.20.06.20;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.17.18.01.16;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.19.20.52.02;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2002.04.30.20.10.00;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.21.16.14.55;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.12.19.21.51;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.12.16.35.41;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.21.19.46.51;	author bimal;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.06.19.50.00;	author bimal;	state Exp;
branches;
next	1.15;

1.15
date	99.12.06.20.59.25;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	99.11.10.23.11.19;	author yuchen;	state Exp;
branches;
next	1.13;

1.13
date	99.06.03.20.50.57;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	97.10.31.19.29.11;	author hedget;	state Exp;
branches;
next	1.11;

1.11
date	97.10.17.15.19.29;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	97.10.15.14.28.55;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	97.09.30.22.05.50;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	97.08.19.19.08.38;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	97.08.19.18.47.03;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	96.04.04.15.11.22;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	95.07.28.18.19.29;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	95.07.28.15.18.38;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	94.09.28.19.49.31;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.10.45;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.52.35;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.29
log
@email_health_dept
@
text
@C++*********************************************************************
C
C  SAQB   NON-POWER-OF-TWO DIMENSIONS             JUL 91
C         OPFILEC                                 FEB 03  ARDEAN LEITH
C         SALB_P INSERTED                         MAR 12  ARDEAN LEITH
C         RDPRI1S BUG,COMMON REMOVED,COSMETIC     SEP 12  ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  SAQB
C
C  PURPOSE:
C     SHIFT ALIGNMENT, NON-POWER-OF-TWO DIMENSIONS
C     SUBTRACTION OF AN IMAGE FROM THE AVERAGE.
C     QUADRATIC INTERPOLATION AS AN OPTION.
C     SCRATCH FILE ON THE DISK
C
C  PROCEDURES/FUNCTIONS CALLED:
C       SAQB
C       SAQB_P
C       SAQB_F
C       UPDTF(C,A,N,IMI)
C       COP(A,B,N)
C       CRSM_2(X,Y,O,NSAM,NROW,WRK)
C       MLC(X,Y,O,N)
C       SHFC_2(X,Y,NSAM,NROW,WRK,SX,SY)
C       SH180_2(X,Y,NSAM,NROW,WRK,SX,SY)
C       SHFM_2(X,NSAM,NROW,WRK,SX,SY)
C       CR180_2(X,Y,O,NSAM,NROW,WRK)
C       MJC(X,Y,O,N)
C       FMR_2(X,NSAM,NROW,WORK,INV)
C       FMR_1(X,N,WORK,INV)
C       FFTMCF (A,B,NTOT,N,NSPAN,ISN)
C       FINDMX(D,NSAM,NROW,CMX,SX,SY,JACUP)
C       ENFR_2(A,NSAM,NROW)
C       RTQ(X,OUT,NSAM,NROW,THETA)
C       QUADRI(XX, YY, NXDATA, NYDATA, FDATA)
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE SAQB

        INCLUDE 'CMLIMIT.INC'   
        INCLUDE 'CMBLOCK.INC' 
 
        COMMON /IOBUF/ BUF(NBUFSIZ)

        CHARACTER (LEN=MAXNAM) :: FINPAT,DOCFIL,FINPIC

        REAL, ALLOCATABLE      :: CNEW(:,:)
        CHARACTER(LEN=1)       :: FLIP 
        CHARACTER(LEN=1)       :: NULL = CHAR(0) 

        INTEGER, PARAMETER     :: INPIC = 77
        INTEGER, PARAMETER     :: NDOC  = 55 

        CALL FILERD(FINPAT,NLET,NULL,
     &           'INPUT FILE TEMPLATE (E.G. PIC****)~',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

         CALL FILERD(DOCFIL,NLETI,NULL,
     &        'DOCUMENT FILE CONTAINING GROUP ASSIGNMENT~',IRTFLG)
        IF (IRTFLG .NE. 0)  RETURN

        CALL RDPRI1S(NGRP,NOT_USED,'GROUP NUMBER',IRTFLG)
        IF (IRTFLG .NE. 0)  RETURN

        CALL RDPRMC(FLIP,NA,.TRUE.,'CHECK 180 DEGREE ROTATION (Y/N)',
     &      NULL,IRTFLG)
        IF (IRTFLG .NE. 0)  RETURN

C       CALL RDPRI1S(JACUP,NOT_USED,PRECISION OF PEAK LOCATION (0..100)')
        JACUP = 0

        K     = 0
        K2    = 1
        NIMA  = 0
778     LERR  = -1
        KP1   = K+1
        CALL  UNSAV(DOCFIL,K,NDOC,KP1,BUF,4,LERR,K2)
        IF (LERR == 0)  THEN
           IF (IFIX(BUF(4)) == NGRP)  NIMA = NIMA + 1
           K = K + 1

C          PICK UP ONE OF THE IMAGES
           IMAGE = IFIX(BUF(1))
           GOTO  778
        ENDIF

        IF (NIMA == 0)  THEN
           WRITE(NOUT,*) ' *** DESIRED GROUP NOT FOUND !'
           CLOSE(NDOC)
           RETURN
        ENDIF

        write(nout,*) ' after unsav -------------------------------'
C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL

        CALL FILGET(FINPAT,FINPIC,NLET,IMAGE,INTFLG)

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)

        LSD = NSAM + 2 - MOD(NSAM,2)

        ALLOCATE (CNEW(LSD,NROW), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'SAQB; CNEW',LSD*NROW)
           GOTO 9999
        ENDIF

        IF (FLIP .EQ. 'Y')  THEN
           CALL SAQB_P(BUF,LSD,NSAM,NROW,NIMA,NGRP,JACUP,
     &                 CNEW,FINPAT,NLET,DOCFIL,FINPIC)           
        ELSE
           CALL SAQB_F(BUF,LSD,NSAM,NROW,NIMA,NGRP,JACUP,
     &                 CNEW,FINPAT,NLET,DOCFIL,FINPIC)     
        ENDIF

        MAXIM  = 0
        NSLICE = 1
        IFORM  = 1
        CALL OPFILEC(0,.TRUE.,FINPAT,INPIC,'U',IFORM,NSAM,NROW,NSLICE,
     &              MAXIM,'OUTPUT AVERAGE ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999

C       INVERSE FOURIER
        INS = -1
        CALL  FMRS_2(CNEW,NSAM,NROW,INS)

        CALL WRITEV(INPIC,CNEW,LSD,NROW, NSAM,NROW,NSLICE)

5       CLOSE(INPIC)
        CLOSE(NDOC)

9999    IF (ALLOCATED(CNEW)) DEALLOCATE(CNEW)

        END

C++*********************************************************************
C
C SAQB_P.F
C                  OPFILEC                         FEB  03 ARDEAN LEITH
C
C **********************************************************************
C
C--*********************************************************************

         SUBROUTINE  SAQB_P(BUF,LSD,NSAM,NROW,NIMA,NGRP,JACUP,
     &                      CNEW,FINPAT,NLET,DOCFIL,FINPIC)

         INCLUDE 'CMBLOCK.INC'

         CHARACTER (LEN=*) :: FINPAT,DOCFIL,FINPIC

         REAL, ALLOCATABLE :: A(:,:),B(:,:),C(:,:),D(:,:)
         REAL, ALLOCATABLE :: X(:,:,:)
         REAL              :: CNEW(LSD,NROW)
         DOUBLE PRECISION  :: SOLD,SNEW,EAV,ENE(NIMA),ENFR_2
         REAL              :: DLIST(7),BUF(1024)
         REAL              :: DIST(NIMA),SHIFT(2,NIMA)
         LOGICAL           :: CKOT(NIMA)
         LOGICAL*1         :: CH_ANG

         DATA              INPIC/77/,NDOC/55/,NDOUT/56/

         ALLOCATE (A(LSD,NROW),
     &             B(LSD,NROW),
     &             C(LSD,NROW), 
     &             D(LSD,NROW), 
     &             X(LSD,NROW,NIMA), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            MWANT =  4*LSD*NROW + LSD*NROW*NIMA 
            CALL ERRT(46,'SAQB_P; A,...',MWANT)
            RETURN
         ENDIF

         NSNR = LSD * NROW
         SOLD = 8.0D0 * DATAN(1.0D0) / 360.0D0
         REWIND NDOC

         K1  = 1
         KT1 = 1
         KT2 = 1
         IMI = 0

778      LERR = -1
         CALL  UNSAV(DOCFIL,KT1,NDOC,K1,DLIST,4,LERR,KT2)
         IF (LERR .NE. 0)  GOTO  788

         K1 = K1+1
         IF (IFIX(DLIST(4)) .NE. NGRP)  GOTO  778
         IMI = IMI+1

C        AN(IMI)=DLIST(2)
         L = DLIST(1)

         CALL FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)

         MAXIM = 0
         CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAMT,NROWT,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
          
         IF (IRTFLG .NE. 0)  THEN
            DEALLOCATE (A,B,C,D,X)
            RETURN
         ENDIF

         DO K2=1,NROW
            CALL  REDLIN(INPIC,A(1,K2),NSAM,K2)
         ENDDO
         CLOSE(INPIC)
         CALL  RTQ_Q(A,X(1,1,IMI),LSD,NSAM,NROW,DLIST(2))
         INS = 1

         CALL  FMRS_2(X(1,1,IMI),NSAM,NROW,INS)
         IF (INS .EQ. 0)  THEN
            CALL  ERRT(38,'AP SA',NE)
            DEALLOCATE (A,B,C,D,X)
            RETURN
         ENDIF
         GOTO  778
788      CONTINUE

c$omp parallel do private(imi)
         DO    IMI=1,NIMA
            ENE(IMI)=ENFR_2(X(1,1,IMI),LSD,NSAM,NROW)
         ENDDO

C        BUILD FIRST AVERAGE

C        TWO ESTIMATION OF INITIAL AVERAGE ARE USED
C        ONLY ONE !!  11/06/91

         DO    ICR=1,1

C           DIST  IS USED HERE FOR THE RANDOM CHOOSING OF IMAGES

c$omp       parallel do private(imi)
            DO    IMI=1,NIMA
                DIST(IMI) = 0.0
            ENDDO

            CALL RANDOM_NUMBER(CIID)
            IMI = MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))

            DIST(IMI)    = 1.0
            CKOT(IMI)    = .FALSE.
            SHIFT(1,IMI) = 0.0
            SHIFT(2,IMI) = 0.0
            CALL  COP(X(1,1,IMI),C,NSNR)

            DO    KTN=2,NIMA

804            CALL RANDOM_NUMBER(CIID) 

               M = MIN0(NIMA,MAX0(1,INT(CIID*(NIMA-KTN+1)+0.5)))

               IMI = 0
               DO  I=1,NIMA
                  IF (DIST(I) .NE. 1.0)  THEN
                     IMI = IMI+1
                     IF (IMI .EQ. M)  GOTO  810
                  ENDIF
               ENDDO 
               GOTO  804

810            IMI       = I
               DIST(IMI) = 1.0

               LSC = NSAM+2-MOD(NSAM,2)
               CALL CCRS_2(C,X(1,1,IMI),D, LSC,NSAM,NROW)

               CALL FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)

               CALL CR180_2(C,X(1,1,IMI),D,LSD/2,NSAM,NROW)
               CALL FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)

               SX2 = -SX2
               SY2 = -SY2

               IF(CMX1.GE.CMX2)  THEN
                  CKOT(IMI)    = .FALSE.
                  SHIFT(1,IMI) = SX1
                  SHIFT(2,IMI) = SY1
                  CALL SHFC_2(X(1,1,IMI),A,LSD/2,NSAM,NROW,SX1,SY1)
                  CALL UPDTF(C,A,NSNR,KTN)
               ELSE
                  CKOT(IMI)    = .TRUE.
                  SHIFT(1,IMI) = SX2
                  SHIFT(2,IMI) = SY2
                  CALL  SH180_2(X(1,1,IMI),A,LSD/2,NSAM,NROW,SX2,SY2)
                  CALL  UPDTF(C,A,NSNR,KTN)
               ENDIF
            ENDDO
            SOLD=ENFR_2(C,LSD,NSAM,NROW)
            WRITE(NOUT,2055)  ICR,SOLD
2055        FORMAT('  Initial estimation #',I1,
     &             '   Squared sum=',1PE12.5)

C           WRITE(NOUT,2001) (CKOT(J),SHIFT(1,J),SHIFT(2,J),J=1,NIMA)
2001        FORMAT(4(1X,L1,2(1X,F8.3)))

            IF (ICR.EQ.1)  THEN
               CALL COP(C,CNEW,NSNR)
            ELSE
               LSC = NSAM+2-MOD(NSAM,2)
               CALL CCRS_2(C,CNEW,D, LSC,NSAM,NROW)

               CALL FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)

               CALL CR180_2(C,CNEW,D,LSD/2,NSAM,NROW)

               CALL FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)

               SX2 = -SX2
               SY2 = -SY2

               IF (CMX1 .GE. CMX2)  THEN
                  CALL SHFM_2(CNEW,LSD/2,NSAM,NROW,SX1,SY1)
                  CALL UPDTF(C,CNEW,NSNR,2)
               ELSE
                  CALL SH180_2(CNEW,A,LSD/2,NSAM,NROW,SX2,SY2)
                  CALL UPDTF(C,A,NSNR,2)
               ENDIF

               SOLD = ENFR_2(C,LSD,NSAM,NROW)
               WRITE(NOUT,2065)  SOLD
2065           FORMAT('  Initial average.  Squared sum=',1PE12.5)

c$omp          parallel do private(imi)
               DO IMI=1,NIMA
                  SHIFT(1,IMI) = 0.0
                  SHIFT(2,IMI) = 0.0
                  CKOT(IMI)    = .TRUE.
               ENDDO
            ENDIF
         ENDDO

C       ITERATIONS TO GET BETTER APPROXIMATION

         ITER = 0
901      CONTINUE

         ITER   = ITER+1
         CH_ANG = .FALSE.

         DO    IMI=1,NIMA
C           Subtract from the average ...
            IF (CKOT(IMI))  THEN
               CALL SH180_2
     &         (X(1,1,IMI),B,LSD/2,NSAM,NROW,SHIFT(1,IMI),SHIFT(2,IMI))

            ELSE
               CALL SHFC_2
     &         (X(1,1,IMI),B,LSD/2,NSAM,NROW,SHIFT(1,IMI),SHIFT(2,IMI))
            ENDIF

            CALL SUBAF(C,B,A,NSNR,NIMA)

            LSC = NSAM+2-MOD(NSAM,2)
            CALL CCRS_2(A,X(1,1,IMI),D, LSC,NSAM,NROW)

            CALL FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)

            CALL CR180_2(A,X(1,1,IMI),D,LSD/2,NSAM,NROW)
            CALL FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)

            SX2 = -SX2
            SY2 = -SY2

            IF (CMX1 .GE. CMX2)  THEN
               IF (CKOT(IMI)
     &            .OR.SHIFT(1,IMI).NE.SX1.OR.SHIFT(2,IMI).NE.SY1) THEN
                  CH_ANG       = .TRUE.
                  CKOT(IMI)    = .FALSE.
                  SHIFT(1,IMI) = SX1
                  SHIFT(2,IMI) = SY1

                  CALL  SHFC_2(X(1,1,IMI),B,LSD/2,NSAM,NROW,SX1,SY1)
               ENDIF

               CALL  UPDTF(CNEW,B,NSNR,IMI)
            ELSE
               IF (.NOT. CKOT(IMI)
     &         .OR.SHIFT(1,IMI).NE.SX2.OR.SHIFT(2,IMI).NE.SY2) THEN
                  CH_ANG       = .TRUE.
                  CKOT(IMI)    = .TRUE.
                  SHIFT(1,IMI) = SX2
                  SHIFT(2,IMI) = SY2

                  CALL  SH180_2(X(1,1,IMI),B,LSD/2,NSAM,NROW,SX2,SY2)
               ENDIF

               CALL UPDTF(CNEW,B,NSNR,IMI)
            ENDIF
         ENDDO
         SNEW = ENFR_2(CNEW,LSD,NSAM,NROW)

         WRITE(NOUT,2066)  ITER,SNEW
2066     FORMAT('  Iteration: ',I4,'   Squared sum:',1PE12.5)

         IF (SNEW .GE. SOLD .AND. CH_ANG)  THEN
            CALL  COP(CNEW,C,NSNR)
            SOLD = SNEW
            GOTO  901
         ENDIF

C sep 12   WRITE(NOUT,2001) (CKOT(J),SHIFT(1,J),SHIFT(2,J),J=1,NIMA)

         REWIND NDOC
         K1   = 1
         KT1  = 1
         KT2  = 1
         NIM  = 0
978      LERR = -1
         CALL  UNSAV(DOCFIL,KT1,NDOC,K1,DLIST,4,LERR,KT2)
         IF (LERR.NE.0)  GOTO  988

         K1 = K1+1
         IF(IFIX(DLIST(4)).NE.NGRP)  GOTO  978

         NIM=NIM+1
         DO    I=5,2,-1
            DLIST(I)=DLIST(I-1)
         ENDDO

C        CALCULATE DISTANCES ...
         IF (CKOT(NIM))  THEN
            CALL SH180_2
     &      (X(1,1,NIM),B,LSD/2,NSAM,NROW,SHIFT(1,NIM),SHIFT(2,NIM))

            CALL SUBAF(C,B,A,NSNR,NIMA)
            CALL CR180_2(A,X(1,1,NIM),D,LSD/2,NSAM,NROW)
            CALL FINDMX(D,LSD,NSAM,NROW,CMX1,SX2,SY2,JACUP)
         ELSE
            CALL SHFC_2
     &      (X(1,1,NIM),B,LSD/2,NSAM,NROW,SHIFT(1,NIM),SHIFT(2,NIM))

            CALL SUBAF(C,B,A,NSNR,NIMA)

            LSC = NSAM+2-MOD(NSAM,2)
            CALL CCRS_2(A,X(1,1,NIM),D, LSC,NSAM,NROW)

            CALL FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
         ENDIF

         EAV  = ENFR_2(A,LSD,NSAM,NROW)
         SNEW = EAV+ENE(NIM)-2*CMX1

         DLIST(1) = NIM
         IF(CKOT(NIM))  DLIST(3) = DLIST(3)+180.0
         DLIST(5) = SHIFT(1,NIM)
         DLIST(6) = SHIFT(2,NIM)
         DLIST(7) = SNEW
         CALL  SAVD(NDOUT,DLIST,7,IRTFLG)
         GOTO  978

988      CALL  SAVDC
         CLOSE(NDOUT)
         DEALLOCATE(A,B,C,D,X)
         END


C++*********************************************************************
C
C    SAQB_F.F 
C              OPFILEC                             FEB  03 ARDEAN LEITH
C
C **********************************************************************
C
C--*********************************************************************

         SUBROUTINE SAQB_F(BUF,LSD,NSAM,NROW,NIMA,NGRP,JACUP,
     &                      CNEW,FINPAT,NLET,DOCFIL,FINPIC)

         INCLUDE 'CMBLOCK.INC'

         CHARACTER (LEN=*) :: FINPAT,DOCFIL,FINPIC

         REAL, ALLOCATABLE :: A(:,:),B(:,:),C(:,:),D(:,:)
         REAL, ALLOCATABLE ::X(:,:,:)

         DIMENSION         CNEW(LSD,NROW)
         DOUBLE PRECISION  SOLD,SNEW,EAV,ENE(NIMA),ENFR_2
         DIMENSION         DLIST(7),BUF(1024)
         DIMENSION         DIST(NIMA),SHIFT(2,NIMA)
         LOGICAL           CKOT(NIMA)
         LOGICAL*1         CH_POS

         DATA              IOUTMP/77/
         DATA              INPIC/77/,NDOC/55/,NDOUT/56/

         ALLOCATE (A(LSD,NROW),
     &             B(LSD,NROW),
     &             C(LSD,NROW), 
     &             D(LSD,NROW), 
     &             X(LSD,NROW,NIMA), STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            MWANT =  4*LSD*NROW + LSD*NROW*NIMA 
            CALL ERRT(46,'SAQB_P; A,...',MWANT)
            RETURN
         ENDIF

         NSNR = LSD*NROW
         SOLD = 8.0D0*DATAN(1.0D0)/360.0D0
         REWIND NDOC
         K1   = 1
         KT1  = 1
         KT2  = 1
         IMI  = 0
778      LERR = -1
         CALL  UNSAV(DOCFIL,KT1,NDOC,K1,DLIST,4,LERR,KT2)
         IF (LERR .NE. 0)  GOTO  788

         K1 = K1+1
         IF (IFIX(DLIST(4)) .NE. NGRP)  GOTO  778
         IMI=IMI+1
C        AN(IMI)=DLIST(2)
         L=DLIST(1)

         CALL FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)

         MAXIM = 0
         CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',ITYPE,NSAMT,NROWT,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
          
         IF (IRTFLG .NE. 0)  THEN
            CALL ERRT(4,'SAQB_F',NE)
            DEALLOCATE (A,B,C,D,X)
            RETURN
         ENDIF

         DO K2=1,NROW
            CALL  REDLIN(INPIC,A(1,K2),NSAM,K2)
         ENDDO
         CLOSE(INPIC)

         CALL  RTQ_Q(A,X(1,1,IMI),LSD,NSAM,NROW,DLIST(2))

C        FORWARD FFT
         INS = 1
         CALL FMRS_2(X(1,1,IMI),NSAM,NROW,INS)
         IF (INS .EQ. 0)  THEN
            CALL  ERRT(38,'AP SA',NE)
            DEALLOCATE (A,B,C,D,X)
            RETURN
         ENDIF

         GOTO  778

788      CONTINUE

c$omp    parallel do private(imi)
         DO IMI=1,NIMA
            ENE(IMI)=ENFR_2(X(1,1,IMI),LSD,NSAM,NROW)
         ENDDO

C        BUILD FIRST AVERAGE
C        TWO ESTIMATION OF INITIAL AVERAGE ARE USED
C        ONLY ONE !!!  11/06/91

         DO ICR=1,1

C        DIST  IS USED HERE FOR THE RANDOM CHOOSING OF IMAGES

c$omp       parallel do private(imi)
            DO IMI=1,NIMA
               DIST(IMI) = 0.0
            ENDDO

            CALL RANDOM_NUMBER(CIID)

            IMI = MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))

            DIST(IMI)    = 1.0
            CKOT(IMI)    = .FALSE.
            SHIFT(1,IMI) = 0.0
            SHIFT(2,IMI) = 0.0

            CALL COP(X(1,1,IMI),C,NSNR)

            DO KTN=2,NIMA

804            CALL RANDOM_NUMBER(CIID)
 
               M   = MIN0(NIMA,MAX0(1,INT(CIID*(NIMA-KTN+1)+0.5)))

               IMI = 0
               DO I=1,NIMA
                  IF (DIST(I) .NE .1.0)  THEN
                     IMI = IMI+1
                     IF (IMI .EQ. M)  GOTO  810
                  ENDIF
               ENDDO
               GOTO  804

810            IMI       = I
               DIST(IMI) = 1.0

               LSC = NSAM+2-MOD(NSAM,2)
               CALL CCRS_2(C,X(1,1,IMI),D, LSC,NSAM,NROW)

               CALL FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)

               SHIFT(1,IMI) = SX1
               SHIFT(2,IMI) = SY1

               CALL SHFC_2(X(1,1,IMI),A,LSD/2,NSAM,NROW,SX1,SY1)
               CALL UPDTF(C,A,NSNR,KTN)
            ENDDO

            SOLD = ENFR_2(C,LSD,NSAM,NROW)

            WRITE(NOUT,2055)  ICR,SOLD
2055        FORMAT('  INITIAL ESTIMATION #',I1, 
     &             '   SQUARED SUM:',1PE12.5)

C           WRITE(NOUT,2001)  (SHIFT(1,J),SHIFT(2,J),J=1,NIMA)
2001        FORMAT(4(2X,2(1X,F8.3)))

            IF (ICR.EQ.1)  THEN
               CALL  COP(C,CNEW,NSNR)
            ELSE
               LSC = NSAM+2-MOD(NSAM,2)
               CALL CCRS_2(C,CNEW,D, LSC,NSAM,NROW)

               CALL FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
               CALL SHFM_2(CNEW,LSD/2,NSAM,NROW,SX1,SY1)
               CALL UPDTF(C,CNEW,NSNR,2)

               SOLD = ENFR_2(C,LSD,NSAM,NROW)
               WRITE(NOUT,2065)  SOLD
2065           FORMAT('  INITIAL AVERAGE.  SQUARED SUM=',1PE12.5)

c$omp          parallel do private(imi)
               DO IMI=1,NIMA
                  SHIFT(1,IMI)=0.0
                  SHIFT(2,IMI)=0.0
               ENDDO
            ENDIF
         ENDDO

C        ITERATIONS TO GET BETTER APPROXIMATION

         ITER=0
901      CONTINUE

         ITER=ITER+1
         CH_POS=.FALSE.


         DO    IMI=1,NIMA
C           SUBTRACT FROM THE AVERAGE ...
            CALL  SHFC_2
     &      (X(1,1,IMI),B,LSD/2,NSAM,NROW,SHIFT(1,IMI),SHIFT(2,IMI))
            CALL  SUBAF(C,B,A,NSNR,NIMA)

            LSC = NSAM+2-MOD(NSAM,2)
            CALL  CCRS_2(A,X(1,1,IMI),D, LSC,NSAM,NROW)

            CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)

            IF (SHIFT(1,IMI).NE.SX1.OR.SHIFT(2,IMI).NE.SY1) THEN
               CH_POS       = .TRUE.
               SHIFT(1,IMI) = SX1
               SHIFT(2,IMI) = SY1
               CALL  SHFC_2(X(1,1,IMI),B,LSD/2,NSAM,NROW,SX1,SY1)
            ENDIF
            CALL  UPDTF(CNEW,B,NSNR,IMI)
         ENDDO

         SNEW = ENFR_2(CNEW,LSD,NSAM,NROW)

         WRITE(NOUT,2066)  ITER,SNEW
2066     FORMAT('  ITERATION #',I4,'   SQUARED SUM=',1PE12.5)
         IF (SNEW .GE. SOLD .AND. CH_POS)  THEN
            CALL  COP(CNEW,C,NSNR)
            SOLD = SNEW
            GOTO  901
         ENDIF

c sep12al         WRITE(NOUT,2001)  (SHIFT(1,J),SHIFT(2,J),J=1,NIMA)

         REWIND NDOC
         K1   = 1
         KT1  = 1
         KT2  = 1
         NIM  = 0
978      LERR = -1
         CALL  UNSAV(DOCFIL,KT1,NDOC,K1,DLIST,4,LERR,KT2)
         IF (LERR.NE.0)  GOTO  988

         K1 = K1+1
         IF (IFIX(DLIST(4)) .NE. NGRP)  GOTO  978
         NIM = NIM+1

         DO I=5,2,-1
            DLIST(I) = DLIST(I-1)
         ENDDO

C        CALCULATE DISTANCES ...
         CALL SHFC_2
     &     (X(1,1,NIM),B,LSD/2,NSAM,NROW,SHIFT(1,NIM),SHIFT(2,NIM))

         CALL SUBAF(C,B,A,NSNR,NIMA)

         LSC = NSAM+2-MOD(NSAM,2)
         CALL CCRS_2(A,X(1,1,NIM),D, LSC,NSAM,NROW)

         CALL FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)

         EAV  = ENFR_2(A,LSD,NSAM,NROW)
         SNEW = EAV+ENE(NIM)-2*CMX1

         DLIST(1) = NIM
         DLIST(5) = SHIFT(1,NIM)
         DLIST(6) = SHIFT(2,NIM)
         DLIST(7) = SNEW
         CALL SAVD(NDOUT,DLIST,7,IRTFLG)
         GOTO  978

988      CALL SAVDC
         CLOSE(NDOUT)

         DEALLOCATE(A,B,C,D,X)

         END
@


1.28
log
@RDPRI1S BUG,COMMON REMOVED,COSMETIC
@
text
@d13 1
a13 1
C=* Email: spider@@wadsworth.org                                        *
@


1.27
log
@merged in saqb_p, saqb_f,   some prompts changed
@
text
@d3 4
a6 3
C              OPFILEC                            FEB 03  ARDEAN LEITH
C              SALB_P INSERTED                    MAR 12  ARDEAN LEITH
C              SALB_F INSERTED                    MAR 12  ARDEAN LEITH
d29 4
a32 1
C  SHIFT ALIGNMENT  07/31/91, NON-POWER-OF-TWO DIMENSIONS
d37 20
a56 22
c  Procedures called:
C       SUBROUTINE  SAQB(MAXMEM)
C       SUBROUTINE  SAQB_P(BUF,NSAM,NROW,NIMA,NGRP,JACUP,
C       SUBROUTINE  SAQB_F(BUF,NSAM,NROW,NIMA,NGRP,JACUP,
C       SUBROUTINE  UPDTF(C,A,N,IMI)
C       SUBROUTINE  COP(A,B,N)
C       SUBROUTINE  CRSM_2(X,Y,O,NSAM,NROW,WRK)
C       SUBROUTINE   MLC(X,Y,O,N)
C       SUBROUTINE  SHFC_2(X,Y,NSAM,NROW,WRK,SX,SY)
C       SUBROUTINE  SH180_2(X,Y,NSAM,NROW,WRK,SX,SY)
C       SUBROUTINE  SHFM_2(X,NSAM,NROW,WRK,SX,SY)
C       SUBROUTINE  CR180_2(X,Y,O,NSAM,NROW,WRK)
C       SUBROUTINE   MJC(X,Y,O,N)
C       SUBROUTINE  FMR_2(X,NSAM,NROW,WORK,INV)
C       SUBROUTINE  FMR_1(X,N,WORK,INV)
C       SUBROUTINE  FFTMCF (A,B,NTOT,N,NSPAN,ISN)
C       SUBROUTINE  FINDMX(D,NSAM,NROW,CMX,SX,SY,JACUP)
C       DOUBLE PRECISION FUNCTION ENFR_2(A,NSAM,NROW)
C       SUBROUTINE  RTQ(X,OUT,NSAM,NROW,THETA)
C       FUNCTION QUADRI(XX, YY, NXDATA, NYDATA, FDATA)
C
C IMAGE_PROCESSING_ROUTINE
a57 1
C        1         2         3         4         5         6         7
d68 1
a68 2
        CHARACTER*80  FINPAT,DOCFIL,FINPIC
        COMMON  /FISPEC/  FINPAT,NLET,FINPIC,DOCFIL,NLETI
d70 3
a72 3
        REAL, ALLOCATABLE     :: CNEW(:,:)
        CHARACTER(LEN=1)      :: FLIP 
        CHARACTER(LEN=1)      :: NULL = CHAR(0) 
d74 2
a75 2
        INTEGER, PARAMETER    :: INPIC = 77
        INTEGER,PARAMETER     :: NDOC  = 55 
d81 1
a81 1
        CALL FILERD(DOCFIL,NLETI,NULL,
d85 1
a85 1
        CALL RDPRI1S(NGRP,NIMA,NOT_USED,'GROUP NUMBER',IRTFLG)
a92 1

d95 5
a99 5
        K    = 0
        K2   = 1
        NIMA = 0
778     LERR = -1
        KP1  = K+1
d101 2
a102 2
        IF (LERR .EQ. 0)  THEN
           IF (IFIX(BUF(4)) .EQ. NGRP)  NIMA = NIMA + 1
d110 2
a111 2
        IF (NIMA .EQ. 0)  THEN
           WRITE(NOUT,*)  ' *** DESIRED GROUP NOT FOUND !'
d116 1
d136 2
a137 1
           CALL SAQB_P(BUF,LSD,NSAM,NROW,NIMA,NGRP,JACUP,CNEW)           
d139 2
a140 1
           CALL SAQB_F(BUF,LSD,NSAM,NROW,NIMA,NGRP,JACUP,CNEW)     
d150 1
d154 1
a154 1
        CALL WRITEV(INPIC,CNEW,LSD,NROW,NSAM,NROW,NSLICE)
a168 20
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
a169 3
C IMAGE_PROCESSING_ROUTINE
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d173 1
a173 1
     &                      CNEW)
d177 1
a177 1
         COMMON  /FISPEC/  FINPAT,NLET,FINPIC,DOCFIL,NLETI
d179 19
a197 15
         REAL, ALLOCATABLE, DIMENSION(:,:) :: A,B,C,D
         REAL, ALLOCATABLE, DIMENSION(:,:,:) ::X
         DIMENSION  CNEW(LSD,NROW)
         DOUBLE PRECISION  SOLD,SNEW,EAV,ENE(NIMA),ENFR_2
         DIMENSION  DLIST(7),BUF(1024)
         DIMENSION  DIST(NIMA),SHIFT(2,NIMA)
         LOGICAL    CKOT(NIMA)
         LOGICAL*1  CH_ANG
         CHARACTER*80  FINPAT,DOCFIL,FINPIC

         DATA  INPIC/77/,NDOC/55/,NDOUT/56/

         ALLOCATE (A(LSD,NROW),B(LSD,NROW),C(LSD,NROW), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'AP SA, A,B & C',IER)
d201 3
a203 6
         ALLOCATE (D(LSD,NROW), X(LSD,NROW,NIMA), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
             CALL ERRT(46,'SAQB_P, D & X',IER)
             DEALLOCATE (A,B,C)
             RETURN
         ENDIF 
d205 4
a208 7
         NSNR=LSD*NROW
         SOLD=8.0D0*DATAN(1.0D0)/360.0D0
         REWIND NDOC
         K1=1
         KT1=1
         KT2=1
         IMI=0
d210 1
a210 1
778      LERR=-1
d212 5
a216 1
         IF (LERR.NE.0)  GOTO  788
a217 3
         K1=K1+1
         IF (IFIX(DLIST(4)).NE.NGRP)  GOTO  778
         IMI=IMI+1
d219 1
a219 1
         L=DLIST(1)
d221 1
a221 1
         CALL  FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)
d232 1
a232 1
         DO    K2=1,NROW
d237 1
a237 1
         INS=1
d240 1
a240 1
         IF (INS.EQ.0)  THEN
d262 1
a262 1
c$omp parallel do private(imi)
d279 1
d295 1
a295 1
               CALL  CCRS_2(C,X(1,1,IMI),D, LSC,NSAM,NROW)
d297 4
a300 1
               CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d302 2
a303 4
               CALL  CR180_2(C,X(1,1,IMI),D,LSD/2,NSAM,NROW)
               CALL  FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)
               SX2=-SX2
               SY2=-SY2
d306 5
a310 5
                  CKOT(IMI)=.FALSE.
                  SHIFT(1,IMI)=SX1
                  SHIFT(2,IMI)=SY1
                  CALL  SHFC_2(X(1,1,IMI),A,LSD/2,NSAM,NROW,SX1,SY1)
                  CALL  UPDTF(C,A,NSNR,KTN)
d312 3
a314 3
                  CKOT(IMI)=.TRUE.
                  SHIFT(1,IMI)=SX2
                  SHIFT(2,IMI)=SY2
d326 1
a326 1
C
d328 1
a328 1
               CALL  COP(C,CNEW,NSNR)
d331 7
a337 1
               CALL  CCRS_2(C,CNEW,D, LSC,NSAM,NROW)
d339 2
a340 1
               CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d342 3
a344 8
               CALL  CR180_2(C,CNEW,D,LSD/2,NSAM,NROW)
               CALL  FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)
               SX2=-SX2
               SY2=-SY2

               IF (CMX1.GE.CMX2)  THEN
                  CALL  SHFM_2(CNEW,LSD/2,NSAM,NROW,SX1,SY1)
                  CALL  UPDTF(C,CNEW,NSNR,2)
d346 2
a347 2
                  CALL  SH180_2(CNEW,A,LSD/2,NSAM,NROW,SX2,SY2)
                  CALL  UPDTF(C,A,NSNR,2)
d349 2
a350 1
               SOLD=ENFR_2(C,LSD,NSAM,NROW)
d353 6
a358 5
c$omp parallel do private(imi)
               DO    IMI=1,NIMA
                  SHIFT(1,IMI)=0.0
                  SHIFT(2,IMI)=0.0
                  CKOT(IMI)=.TRUE.
d363 1
a363 1
C  ITERATIONS TO GET BETTER APPROXIMATION
d365 1
a365 1
         ITER=0
d367 3
a369 2
         ITER=ITER+1
         CH_ANG=.FALSE.
d374 1
a374 1
               CALL  SH180_2
d378 1
a378 1
               CALL  SHFC_2
d382 1
a382 1
            CALL  SUBAF(C,B,A,NSNR,NIMA)
d385 3
a387 1
            CALL  CCRS_2(A,X(1,1,IMI),D, LSC,NSAM,NROW)
d389 2
a390 1
            CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d392 2
a393 4
            CALL  CR180_2(A,X(1,1,IMI),D,LSD/2,NSAM,NROW)
            CALL  FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)
            SX2=-SX2
            SY2=-SY2
d395 2
a396 2
            IF(CMX1.GE.CMX2)  THEN
               IF(CKOT(IMI)
d401 2
a402 1
                  SHIFT(2,IMI)=SY1
d405 1
d410 5
a414 4
                  CH_ANG       =.TRUE.
                  CKOT(IMI)    =.TRUE.
                  SHIFT(1,IMI) =SX2
                  SHIFT(2,IMI) =SY2
d417 2
a418 1
               CALL  UPDTF(CNEW,B,NSNR,IMI)
d422 1
d425 1
d428 1
a428 1
            SOLD=SNEW
d432 1
a432 1
         WRITE(NOUT,2001) (CKOT(J),SHIFT(1,J),SHIFT(2,J),J=1,NIMA)
d435 5
a439 5
         K1=1
         KT1=1
         KT2=1
         NIM=0
978      LERR=-1
d442 2
a443 1
         K1=K1+1
d445 1
d450 2
a451 1
C        Calculate distances ...
d453 1
a453 1
            CALL  SH180_2
d455 4
a458 3
            CALL  SUBAF(C,B,A,NSNR,NIMA)
            CALL  CR180_2(A,X(1,1,NIM),D,LSD/2,NSAM,NROW)
            CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX2,SY2,JACUP)
d460 1
a460 1
            CALL  SHFC_2
d462 2
a463 1
            CALL  SUBAF(C,B,A,NSNR,NIMA)
d466 1
a466 1
            CALL  CCRS_2(A,X(1,1,NIM),D, LSC,NSAM,NROW)
d468 1
a468 1
            CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
a469 2
         EAV=ENFR_2(A,LSD,NSAM,NROW)
         SNEW=EAV+ENE(NIM)-2*CMX1
d471 8
a478 5
         DLIST(1)=NIM
         IF(CKOT(NIM))  DLIST(3)=DLIST(3)+180.0
         DLIST(5)=SHIFT(1,NIM)
         DLIST(6)=SHIFT(2,NIM)
         DLIST(7)=SNEW
d487 1
a493 21
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
a494 1
C23456789012345678901234567890123456789012345678901234567890123456789012
d497 2
a498 1
         SUBROUTINE  SAQB_F(BUF,LSD,NSAM,NROW,NIMA,NGRP,JACUP,CNEW)
a500 2
         CHARACTER*80  FINPAT,DOCFIL,FINPIC
         COMMON  /FISPEC/  FINPAT,NLET,FINPIC,DOCFIL,NLETI
d502 1
a502 17
         REAL, ALLOCATABLE, DIMENSION(:,:) :: A,B,C,D
         REAL, ALLOCATABLE, DIMENSION(:,:,:) ::X
         DIMENSION  CNEW(LSD,NROW)
         DOUBLE PRECISION  SOLD,SNEW,EAV,ENE(NIMA),ENFR_2
         DIMENSION  DLIST(7),BUF(1024)
         DIMENSION  DIST(NIMA),SHIFT(2,NIMA)
         LOGICAL    CKOT(NIMA)
         LOGICAL*1  CH_POS

         DATA  IOUTMP/77/
         DATA  INPIC/77/,NDOC/55/,NDOUT/56/

         ALLOCATE (A(LSD,NROW), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'AP SA, A',IER)
            RETURN
         ENDIF
d504 2
a505 6
         ALLOCATE (B(LSD,NROW), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'SAQB_P, B',IER)
            DEALLOCATE (A)
            RETURN
         ENDIF
d507 18
a524 4
         ALLOCATE (C(LSD,NROW), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'SAQB_P, C',IER)
            DEALLOCATE (A,B)
d528 2
a529 16
         ALLOCATE (D(LSD,NROW), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'SAQB_P, D',IER)
            DEALLOCATE (A,B,C)
            RETURN
         ENDIF 

         ALLOCATE (X(LSD,NROW,NIMA), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'SAQB_P, X',IER)
            DEALLOCATE (A,B,C,D)
            RETURN
         ENDIF 

         NSNR=LSD*NROW
         SOLD=8.0D0*DATAN(1.0D0)/360.0D0
d531 5
a535 5
         K1=1
         KT1=1
         KT2=1
         IMI=0
778      LERR=-1
d537 1
a537 1
         IF (LERR.NE.0)  GOTO  788
d539 2
a540 2
         K1=K1+1
         IF (IFIX(DLIST(4)).NE.NGRP)  GOTO  778
d545 1
a545 1
         CALL  FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)
d557 1
a557 1
         DO    K2=1,NROW
d563 5
a567 3
         INS=1
         CALL  FMRS_2(X(1,1,IMI),NSAM,NROW,INS)
         IF(INS.EQ.0)  THEN
d572 1
d574 1
d577 2
a578 2
c$omp parallel do private(imi)
         DO    IMI=1,NIMA
d586 1
a586 1
         DO    ICR=1,1
d590 2
a591 2
c$omp parallel do private(imi)
            DO    IMI=1,NIMA
d596 1
d599 5
a603 4
            DIST(IMI)=1.0
            CKOT(IMI)=.FALSE.
            SHIFT(1,IMI)=0.0
            SHIFT(2,IMI)=0.0
d608 2
a609 1
804            CALL RANDOM_NUMBER(CIID) 
d629 2
a630 2
               SHIFT(1,IMI)=SX1
               SHIFT(2,IMI)=SY1
d637 1
d641 1
d649 5
a653 1
               CALL  CCRS_2(C,CNEW,D, LSC,NSAM,NROW)
d655 1
a655 4
               CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
               CALL  SHFM_2(CNEW,LSD/2,NSAM,NROW,SX1,SY1)
               CALL  UPDTF(C,CNEW,NSNR,2)
               SOLD=ENFR_2(C,LSD,NSAM,NROW)
d660 1
a660 1
               DO    IMI=1,NIMA
d667 1
a667 1
C  ITERATIONS TO GET BETTER APPROXIMATION
d677 1
a677 1
C SUBTRACT FROM THE AVERAGE ...
d679 1
a679 1
     &   (X(1,1,IMI),B,LSD/2,NSAM,NROW,SHIFT(1,IMI),SHIFT(2,IMI))
d687 1
a687 1
            IF(SHIFT(1,IMI).NE.SX1.OR.SHIFT(2,IMI).NE.SY1) THEN
d696 1
a696 1
         SNEW=ENFR_2(CNEW,LSD,NSAM,NROW)
d700 1
a700 1
         IF (SNEW.GE.SOLD.AND.CH_POS)  THEN
d706 1
a706 2
         WRITE(NOUT,2001)  (SHIFT(1,J),SHIFT(2,J),J=1,NIMA)

d709 5
a713 5
         K1=1
         KT1=1
         KT2=1
         NIM=0
978      LERR=-1
d715 2
a716 1
         IF(LERR.NE.0)  GOTO  988
d718 1
a718 1
         IF (IFIX(DLIST(4)).NE.NGRP)  GOTO  978
d722 1
a722 1
            DLIST(I)=DLIST(I-1)
d726 4
a729 3
         CALL  SHFC_2
     &   (X(1,1,NIM),B,LSD/2,NSAM,NROW,SHIFT(1,NIM),SHIFT(2,NIM))
         CALL  SUBAF(C,B,A,NSNR,NIMA)
d732 3
a734 1
         CALL  CCRS_2(A,X(1,1,NIM),D, LSC,NSAM,NROW)
d736 2
a737 3
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
         EAV=ENFR_2(A,LSD,NSAM,NROW)
         SNEW=EAV+ENE(NIM)-2*CMX1
d743 1
a743 1
         CALL  SAVD(NDOUT,DLIST,7,IRTFLG)
d746 1
a746 1
988      CALL  SAVDC
@


1.26
log
@GPL_2010
@
text
@d3 159
a194 1
         PARAMETER  (NLIST=7)
d203 1
a203 1
         DIMENSION  DLIST(NLIST),BUF(1024)
d480 1
a480 1
         CALL  SAVD(NDOUT,DLIST,NLIST,IRTFLG)
d488 295
@


1.25
log
@ccrs_ added parameter
@
text
@a6 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d8 5
a12 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d14 1
a14 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d21 1
a21 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a22 1
C=*                                                                    *
d24 1
a24 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.24
log
@GPL License fixed
@
text
@d160 3
a162 1
               CALL  CCRS_2(C,X(1,1,IMI),D,NSAM,NROW)
d195 3
a197 1
               CALL  CCRS_2(C,CNEW,D,NSAM,NROW)
d244 3
a246 1
            CALL  CCRS_2(A,X(1,1,IMI),D,NSAM,NROW)
d312 4
a315 1
            CALL  CCRS_2(A,X(1,1,NIM),D,NSAM,NROW)
@


1.23
log
@HRI GPL License used
@
text
@a1 1
C++************************************************************************
a6 3
C **************************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
d10 1
a10 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a29 7

C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
a30 1
C **************************************************************************
a35 1
C--************************************************************************
@


1.22
log
@opfilec
@
text
@d1 1
d7 1
d9 1
d11 24
d41 1
d47 1
@


1.21
log
@ccr* phase parameter removed
@
text
@d4 1
d26 1
d41 1
a41 14
         ALLOCATE (A(LSD,NROW), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'AP SA, A',IER)
            RETURN
         ENDIF

         ALLOCATE (B(LSD,NROW), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'SAQB_P, B',IER)
            DEALLOCATE (A)
            RETURN
         ENDIF

         ALLOCATE (C(LSD,NROW), STAT=IRTFLG)
d43 1
a43 2
            CALL ERRT(46,'SAQB_P, C',IER)
            DEALLOCATE (A,B)
d47 1
a47 1
         ALLOCATE (D(LSD,NROW), STAT=IRTFLG)
d49 1
a49 1
             CALL ERRT(46,'SAQB_P, D',IER)
a53 7
         ALLOCATE (X(LSD,NROW,NIMA), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 
             CALL ERRT(46,'SAQB_P, X',IER)
             DEALLOCATE (A,B,C,D)
             RETURN
         ENDIF 

d65 1
a71 1

d75 1
a75 1
         CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAMT,NROWT,NSL,
a78 1
            CALL ERRT(4,'SAQB_P',NE)
@


1.20
log
@ccrs_2 parameter added
@
text
@d164 1
a164 1
               CALL  CCRS_2(C,X(1,1,IMI),D,NSAM,NROW,.FALSE.)
d197 1
a197 1
               CALL  CCRS_2(C,CNEW,D,NSAM,NROW,.FALSE.)
d244 1
a244 1
            CALL  CCRS_2(A,X(1,1,IMI),D,NSAM,NROW,.FALSE.)
d310 1
a310 1
            CALL  CCRS_2(A,X(1,1,NIM),D,NSAM,NROW,.FALSE.)
@


1.19
log
@random equation changed
@
text
@a16 1
C        1         2         3         4         5         6         7
d164 1
a164 1
               CALL  CCRS_2(C,X(1,1,IMI),D,NSAM,NROW)
d197 1
a197 1
               CALL  CCRS_2(C,CNEW,D,NSAM,NROW)
d232 1
a232 1
C Subtract from the average ...
d244 1
a244 1
            CALL  CCRS_2(A,X(1,1,IMI),D,NSAM,NROW)
d255 3
a257 3
                  CH_ANG=.TRUE.
                  CKOT(IMI)=.FALSE.
                  SHIFT(1,IMI)=SX1
d263 1
a263 1
               IF (.NOT.CKOT(IMI)
d265 4
a268 4
                  CH_ANG=.TRUE.
                  CKOT(IMI)=.TRUE.
                  SHIFT(1,IMI)=SX2
                  SHIFT(2,IMI)=SY2
d274 1
a274 1
         SNEW=ENFR_2(CNEW,LSD,NSAM,NROW)
d276 2
a277 2
2066     FORMAT('  Iteration #',I4,'   Squared sum=',1PE12.5)
         IF (SNEW.GE.SOLD.AND.CH_ANG)  THEN
d283 1
a283 1
         WRITE(NOUT,2001)  (CKOT(J),SHIFT(1,J),SHIFT(2,J),J=1,NIMA)
d299 1
a299 1
C Calculate distances ...
d310 1
a310 1
            CALL  CCRS_2(A,X(1,1,NIM),D,NSAM,NROW)
@


1.18
log
@rot not full or randomly filled
@
text
@a126 1

d140 1
a140 1
            IMI          = MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))
d151 1
a151 1
               M=MIN0(NIMA,MAX0(1,INT(CIID*(NIMA-KTN+1)+0.5)))
d157 1
a157 1
                     IF (IMI.EQ.M)  GOTO  810
@


1.17
log
@replaced ccrs_2r with ccrs_2
@
text
@a14 1
C
a36 1
         CHARACTER*1  NULL
a39 2
         NULL=CHAR(0)

d84 1
a84 1
         IF(LERR.NE.0)  GOTO  788
d125 1
a125 1
C  BUILD FIRST AVERAGE
d128 2
a129 2
C  TWO ESTIMATION OF INITIAL AVERAGE ARE USED
C  ONLY ONE !!  11/06/91
d133 2
a134 2
C  DIST  IS USED HERE FOR THE RANDOM CHOOSING OF IMAGES
C
d137 1
a137 1
                DIST(IMI)=0.0
d141 1
a141 1
            IMI=MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))
d143 4
a146 4
            DIST(IMI)=1.0
            CKOT(IMI)=.FALSE.
            SHIFT(1,IMI)=0.0
            SHIFT(2,IMI)=0.0
a150 1

d154 1
a154 1
               IMI=0
d156 4
a159 4
                  IF(DIST(I).EQ.1.0)  GOTO  809
                  IMI=IMI+1
                  IF(IMI.EQ.M)  GOTO  810
809               CONTINUE
a161 2
810            IMI=I
               DIST(IMI)=1.0
d163 2
a164 2
         CALL  CCRS_2(C,X(1,1,IMI),D,NSAM,NROW)
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d166 5
a170 2
         CALL  CR180_2(C,X(1,1,IMI),D,LSD/2,NSAM,NROW)
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)
d178 1
a178 1
         CALL  SHFC_2(X(1,1,IMI),A,LSD/2,NSAM,NROW,SX1,SY1)
d184 1
a184 1
         CALL  SH180_2(X(1,1,IMI),A,LSD/2,NSAM,NROW,SX2,SY2)
d191 3
a193 2
     &      '   Squared sum=',1PE12.5)
C        WRITE(NOUT,2001) (CKOT(J),SHIFT(1,J),SHIFT(2,J),J=1,NIMA)
d196 1
a196 1
            IF(ICR.EQ.1)  THEN
d201 1
a201 1
C
d206 2
a207 2
C
               IF(CMX1.GE.CMX2)  THEN
d225 1
a225 1
C
d227 1
a227 1
C
d232 1
a232 2
C
C
d235 1
a235 1
            IF(CKOT(IMI))  THEN
d237 1
a237 1
     &   (X(1,1,IMI),B,LSD/2,NSAM,NROW,SHIFT(1,IMI),SHIFT(2,IMI))
d241 1
a241 1
     &   (X(1,1,IMI),B,LSD/2,NSAM,NROW,SHIFT(1,IMI),SHIFT(2,IMI))
d245 1
a245 1
C
d248 1
a248 1
C
d253 1
a253 1
C
d256 1
a256 1
     &   .OR.SHIFT(1,IMI).NE.SX1.OR.SHIFT(2,IMI).NE.SY1) THEN
d265 1
a265 1
               IF(.NOT.CKOT(IMI)
d278 2
a279 3
2066     FORMAT('  Iteration #',I4,
     &   '   Squared sum=',1PE12.5)
         IF(SNEW.GE.SOLD.AND.CH_ANG)  THEN
d284 1
a284 1
C
d286 1
a286 2
C
C
d294 1
a294 1
         IF(LERR.NE.0)  GOTO  988
d302 1
a302 1
         IF(CKOT(NIM))  THEN
d304 1
a304 1
     &   (X(1,1,NIM),B,LSD/2,NSAM,NROW,SHIFT(1,NIM),SHIFT(2,NIM))
d317 1
a317 1
C
d325 1
@


1.16
log
@adapted for dynamical memory allocation
@
text
@d170 1
a170 1
         CALL  CCRS_2R(C,X(1,1,IMI),D,LSD/2,NSAM,NROW)
d202 1
a202 1
               CALL  CCRS_2R(C,CNEW,D,LSD/2,NSAM,NROW)
d250 1
a250 1
            CALL  CCRS_2R(A,X(1,1,IMI),D,LSD/2,NSAM,NROW)
d318 1
a318 1
            CALL  CCRS_2R(A,X(1,1,NIM),D,LSD/2,NSAM,NROW)
@


1.15
log
@header
@
text
@d12 1
a12 1
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
d16 1
d18 2
d23 1
a23 1
     &                      CKOT,SHIFT,ENE,A,B,C,D,X,DIST,CNEW)
d27 5
a31 2
         DIMENSION  X(LSD,NROW,NIMA),CNEW(LSD,NROW)
         DIMENSION  A(LSD,NROW),B(LSD,NROW),C(LSD,NROW),D(LSD,NROW)
a32 1
         LOGICAL    CKOT(NIMA)
d35 2
a36 1
         COMMON  /FISPEC/  FINPAT,NLET,FINPIC,DOCFIL,NLETI
a37 2
         LOGICAL*1  CH_ANG
         CHARACTER*8  ZEIT
d42 35
a76 1
	NULL=CHAR(0)
d94 2
d97 8
a104 3
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'O',NF,NSL)
         IF (NF.NE.2)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
d107 1
d109 2
a110 2
           CALL  REDLIN(INPIC,A(1,K2),NSAM,K2)
	 ENDDO
d114 1
d118 1
d126 2
a127 2
           ENE(IMI)=ENFR_2(X(1,1,IMI),LSD,NSAM,NROW)
	 ENDDO
d129 1
a129 1
C  Build first average
a130 3
         CALL  TIME(ZEIT)
         ISEED=MOD(ICHAR(ZEIT(4:4))+100*ICHAR(ZEIT(5:5))
     &   +1000*ICHAR(ZEIT(7:7))+10000*ICHAR(ZEIT(8:8)),340189)
d132 2
a133 2
C  Two estimation of initial average are used
C  Only one !!  11/06/91
d137 1
a137 1
C  DIST  is used here for the random choosing of images
d140 29
a168 23
         DO    IMI=1,NIMA
           DIST(IMI)=0.0
	 ENDDO
         IMI=MIN0(NIMA,MAX0(1,INT(RAND_P(ISEED)*NIMA+0.5)))

         DIST(IMI)=1.0
         CKOT(IMI)=.FALSE.
         SHIFT(1,IMI)=0.0
         SHIFT(2,IMI)=0.0
         CALL  COP(X(1,1,IMI),C,NSNR)

         DO    KTN=2,NIMA
C
804      M=MIN0(NIMA,MAX0(1,INT(RAND_P(ISEED)*(NIMA-KTN+1)+0.5)))
         IMI=0
         DO  809  I=1,NIMA
         IF(DIST(I).EQ.1.0)  GOTO  809
         IMI=IMI+1
         IF(IMI.EQ.M)  GOTO  810
809      CONTINUE
         GOTO  804
810      IMI=I
         DIST(IMI)=1.0
d175 2
a176 2
         SX2=-SX2
         SY2=-SY2
d178 4
a181 4
         IF(CMX1.GE.CMX2)  THEN
         CKOT(IMI)=.FALSE.
         SHIFT(1,IMI)=SX1
         SHIFT(2,IMI)=SY1
d183 5
a187 5
         CALL  UPDTF(C,A,NSNR,KTN)
         ELSE
         CKOT(IMI)=.TRUE.
         SHIFT(1,IMI)=SX2
         SHIFT(2,IMI)=SY2
d189 7
a195 7
         CALL  UPDTF(C,A,NSNR,KTN)
         ENDIF
	 ENDDO
         SOLD=ENFR_2(C,LSD,NSAM,NROW)
         WRITE(NOUT,2055)  ICR,SOLD
2055     FORMAT('  Initial estimation #',I1,
     &   '   Squared sum=',1PE12.5)
d197 1
a197 7
2001     FORMAT(4(1X,L1,2(1X,F8.3)))
C
         IF(ICR.EQ.1)  THEN
	 CALL  COP(C,CNEW,NSNR)
         ELSE
         CALL  CCRS_2R(C,CNEW,D,LSD/2,NSAM,NROW)
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d199 21
a219 15
         CALL  CR180_2(C,CNEW,D,LSD/2,NSAM,NROW)
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)
         SX2=-SX2
         SY2=-SY2
C
         IF(CMX1.GE.CMX2)  THEN
         CALL  SHFM_2(CNEW,LSD/2,NSAM,NROW,SX1,SY1)
         CALL  UPDTF(C,CNEW,NSNR,2)
         ELSE
         CALL  SH180_2(CNEW,A,LSD/2,NSAM,NROW,SX2,SY2)
         CALL  UPDTF(C,A,NSNR,2)
         ENDIF
         SOLD=ENFR_2(C,LSD,NSAM,NROW)
         WRITE(NOUT,2065)  SOLD
2065     FORMAT('  Initial average.  Squared sum=',1PE12.5)
d221 7
a227 7
         DO    IMI=1,NIMA
         SHIFT(1,IMI)=0.0
         SHIFT(2,IMI)=0.0
         CKOT(IMI)=.TRUE.
	 ENDDO
         ENDIF
	 ENDDO
d229 1
a229 1
C  Iterations to get better approximation
d239 2
a240 2
         IF(CKOT(IMI))  THEN
         CALL  SH180_2
d242 3
a244 2
         ELSE
         CALL  SHFC_2
d246 3
a248 2
         ENDIF
         CALL  SUBAF(C,B,A,NSNR,NIMA)
d250 2
a251 2
         CALL  CCRS_2R(A,X(1,1,IMI),D,LSD/2,NSAM,NROW)
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d253 4
a256 4
         CALL  CR180_2(A,X(1,1,IMI),D,LSD/2,NSAM,NROW)
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX2,SX2,SY2,JACUP)
         SX2=-SX2
         SY2=-SY2
d258 2
a259 2
         IF(CMX1.GE.CMX2)  THEN
         IF(CKOT(IMI)
d261 19
a279 19
         CH_ANG=.TRUE.
         CKOT(IMI)=.FALSE.
         SHIFT(1,IMI)=SX1
         SHIFT(2,IMI)=SY1
         CALL  SHFC_2(X(1,1,IMI),B,LSD/2,NSAM,NROW,SX1,SY1)
         ENDIF
         CALL  UPDTF(CNEW,B,NSNR,IMI)
         ELSE
         IF(.NOT.CKOT(IMI)
     &   .OR.SHIFT(1,IMI).NE.SX2.OR.SHIFT(2,IMI).NE.SY2) THEN
         CH_ANG=.TRUE.
         CKOT(IMI)=.TRUE.
         SHIFT(1,IMI)=SX2
         SHIFT(2,IMI)=SY2
         CALL  SH180_2(X(1,1,IMI),B,LSD/2,NSAM,NROW,SX2,SY2)
         ENDIF
         CALL  UPDTF(CNEW,B,NSNR,IMI)
         ENDIF
	 ENDDO
d285 3
a287 3
         CALL  COP(CNEW,C,NSNR)
         SOLD=SNEW
         GOTO  901
d305 2
a306 2
           DLIST(I)=DLIST(I-1)
	 ENDDO
d309 1
a309 1
         CALL  SH180_2
d311 3
a313 3
         CALL  SUBAF(C,B,A,NSNR,NIMA)
         CALL  CR180_2(A,X(1,1,NIM),D,LSD/2,NSAM,NROW)
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX2,SY2,JACUP)
d315 5
a319 5
         CALL  SHFC_2
     &   (X(1,1,NIM),B,LSD/2,NSAM,NROW,SHIFT(1,NIM),SHIFT(2,NIM))
         CALL  SUBAF(C,B,A,NSNR,NIMA)
         CALL  CCRS_2R(A,X(1,1,NIM),D,LSD/2,NSAM,NROW)
         CALL  FINDMX(D,LSD,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d333 1
d335 1
@


1.14
log
@a
@
text
@d3 1
a3 1
C $$ SAQB_P.FOR
d18 1
a18 3
C
C $$ SAQB_P.FOR
C
d20 2
a21 1
     &   CKOT,SHIFT,ENE,A,B,C,D,X,DIST,CNEW)
d35 1
d39 1
a39 1
C
d47 1
d52 1
a52 1
         IF(IFIX(DLIST(4)).NE.NGRP)  GOTO  778
d54 1
a54 1
C     AN(IMI)=DLIST(2)
d58 3
a60 3
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
d69 3
a71 3
         IF(INS.EQ.0)  THEN
		CALL  ERRT(38,'AP SA',NE)
         RETURN
d75 1
a75 1
C
d80 1
a80 1
C
d82 1
a82 2
C
C
d86 1
a86 1
C
d89 1
a89 1
C
d91 1
a91 1
C
d99 1
a99 1
C
d105 1
a105 1
C
d118 1
a118 1
C
d121 1
a121 1
C
d126 1
a126 1
C
d145 1
a145 1
C     WRITE(NOUT,2001) (CKOT(J),SHIFT(1,J),SHIFT(2,J),J=1,NIMA)
@


1.13
log
@OpenMP
@
text
@d37 1
a37 1
CNO_SAVE
@


1.12
log
@modified intrinsic function call for f90 compatibility
@
text
@d75 1
a75 1
c$doacross local(imi)
d94 1
a94 1
c$doacross local(imi)
d169 1
a169 1
c$doacross local(imi)
@


1.11
log
@R
@
text
@d98 1
a98 1
         IMI=MIN0(NIMA,MAX0(1,JNINT(RAND_P(ISEED)*NIMA+0.5)))
d108 1
a108 1
804      M=MIN0(NIMA,MAX0(1,JNINT(RAND_P(ISEED)*(NIMA-KTN+1)+0.5)))
@


1.10
log
@*** empty log message ***
@
text
@d56 1
a56 1
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'R',NF,NSL)
@


1.9
log
@*** empty log message ***
@
text
@d61 3
a63 2
         DO  611  K2=1,NROW
611      CALL  REDLIN(INPIC,A(1,K2),NSAM,K2)
d76 3
a78 2
         DO  791  IMI=1,NIMA
791      ENE(IMI)=ENFR_2(X(1,1,IMI),LSD,NSAM,NROW)
d90 1
a90 1
         DO  880  ICR=1,1
d95 3
a97 2
         DO  803  IMI=1,NIMA
803      DIST(IMI)=0.0
d106 1
a106 1
         DO  802  KTN=2,NIMA
d140 1
a140 1
802      CONTINUE
d170 1
a170 1
         DO  885  IMI=1,NIMA
d173 2
a174 1
885      CKOT(IMI)=.TRUE.
d176 1
a176 1
880      CONTINUE
d186 1
a186 1
         DO  812  IMI=1,NIMA
d226 1
a226 1
812      CONTINUE
d251 3
a253 2
         DO  989  I=5,2,-1
989      DLIST(I)=DLIST(I-1)
@


1.8
log
@*** empty log message ***
@
text
@a35 1
         DATA  NULL/0/
d38 1
@


1.7
log
@new version for new FFT
@
text
@d146 1
a146 4
c$doacross local(imi)
         DO  881  J=1,NROW
         DO  881  I=1,NSAM
881      CNEW(I,J)=C(I,J)
@


1.6
log
@error 38
@
text
@d21 2
a22 2
         SUBROUTINE  SAQB_P(BUF,NSAM,NROW,NIMA,NGRP,JACUP,
     &   WRK,CKOT,SHIFT,ENE,A,B,C,D,X,DIST,CNEW)
a23 1
#ifdef SP_UNIX
d25 2
a26 5
#else
         INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
         DIMENSION  X(NSAM,NROW,NIMA),CNEW(NSAM,NROW),WRK(*)
         DIMENSION  A(NSAM,NROW),B(NSAM,NROW),C(NSAM,NROW),D(NSAM,NROW)
d40 1
a40 1
         NSNR=NSAM*NROW
d64 1
a64 1
         CALL  RTQ(A,X(1,1,IMI),NSAM,NROW,DLIST(2))
d66 1
a66 1
         CALL  FMR_2(X(1,1,IMI),NSAM,NROW,WRK,INS)
d68 1
a68 1
	CALL  ERRT(38,'AP SA',NE)
d74 1
d76 1
a76 1
791      ENE(IMI)=ENFR_2(X(1,1,IMI),NSAM,NROW)
d92 1
d116 2
a117 2
         CALL  CRSM_2(C,X(1,1,IMI),D,NSAM,NROW,WRK)
         CALL  FINDMX(D,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d119 2
a120 2
         CALL  CR180_2(C,X(1,1,IMI),D,NSAM,NROW,WRK)
         CALL  FINDMX(D,NSAM,NROW,CMX2,SX2,SY2,JACUP)
d128 1
a128 1
         CALL  SHFC_2(X(1,1,IMI),A,NSAM,NROW,WRK,SX1,SY1)
d134 1
a134 1
         CALL  SH180_2(X(1,1,IMI),A,NSAM,NROW,WRK,SX2,SY2)
d138 1
a138 1
         SOLD=ENFR_2(C,NSAM,NROW)
d146 1
d151 2
a152 2
         CALL  CRSM_2(C,CNEW,D,NSAM,NROW,WRK)
         CALL  FINDMX(D,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d154 2
a155 2
         CALL  CR180_2(C,CNEW,D,NSAM,NROW,WRK)
         CALL  FINDMX(D,NSAM,NROW,CMX2,SX2,SY2,JACUP)
d160 1
a160 1
         CALL  SHFM_2(CNEW,NSAM,NROW,WRK,SX1,SY1)
d163 1
a163 1
         CALL  SH180_2(CNEW,A,NSAM,NROW,WRK,SX2,SY2)
d166 1
a166 1
         SOLD=ENFR_2(C,NSAM,NROW)
d169 1
d189 1
a189 1
     &   (X(1,1,IMI),B,NSAM,NROW,WRK,SHIFT(1,IMI),SHIFT(2,IMI))
d192 1
a192 1
     &   (X(1,1,IMI),B,NSAM,NROW,WRK,SHIFT(1,IMI),SHIFT(2,IMI))
d196 2
a197 2
         CALL  CRSM_2(A,X(1,1,IMI),D,NSAM,NROW,WRK)
         CALL  FINDMX(D,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d199 2
a200 2
         CALL  CR180_2(A,X(1,1,IMI),D,NSAM,NROW,WRK)
         CALL  FINDMX(D,NSAM,NROW,CMX2,SX2,SY2,JACUP)
d211 1
a211 1
         CALL  SHFC_2(X(1,1,IMI),B,NSAM,NROW,WRK,SX1,SY1)
d221 1
a221 1
         CALL  SH180_2(X(1,1,IMI),B,NSAM,NROW,WRK,SX2,SY2)
d226 1
a226 1
         SNEW=ENFR_2(CNEW,NSAM,NROW)
d255 1
a255 1
     &   (X(1,1,NIM),B,NSAM,NROW,WRK,SHIFT(1,NIM),SHIFT(2,NIM))
d257 2
a258 2
         CALL  CR180_2(A,X(1,1,NIM),D,NSAM,NROW,WRK)
         CALL  FINDMX(D,NSAM,NROW,CMX1,SX2,SY2,JACUP)
d261 1
a261 1
     &   (X(1,1,NIM),B,NSAM,NROW,WRK,SHIFT(1,NIM),SHIFT(2,NIM))
d263 2
a264 2
         CALL  CRSM_2(A,X(1,1,NIM),D,NSAM,NROW,WRK)
         CALL  FINDMX(D,NSAM,NROW,CMX1,SX1,SY1,JACUP)
d266 1
a266 1
         EAV=ENFR_2(A,NSAM,NROW)
@


1.5
log
@logical*4
@
text
@d72 1
a72 4
         WRITE(NOUT,*)
     $   '**Array dimensions MUST be factorisable with prime'//
     $   '  factors smaller than 23 !**'//
     $   '** Program stopped !  **'
@


1.4
log
@nosave
@
text
@d32 1
a32 1
         LOGICAL*1  CKOT(NIMA)
@


1.3
log
@imsl removed
@
text
@d42 1
@


1.2
log
@cpp_lines_added
@
text
@d22 1
a22 1
     &   WRK,CKOT,SHIFT,ENE,A,B,C,D,X,DIST,CNEW,WORK,KXORD,KYORD)
a39 3
C ---  Workspace for IMSL
         DIMENSION  WORK(*)
C -------------------------
a63 1
         IF(KXORD.EQ.0)  THEN
a67 7
         ELSE
         DO  61  K2=1,NROW
61       CALL  REDLIN(INPIC,X(1,K2,IMI),NSAM,K2)
         CLOSE(INPIC)
         THETA=DLIST(2)*SOLD
         CALL  ROTBS(X(1,1,IMI),WORK,NSAM,NROW,KXORD,KYORD,THETA)
         ENDIF
@


1.1
log
@Initial revision
@
text
@d24 3
d28 1
@
