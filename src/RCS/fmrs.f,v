head	1.19;
access;
symbols
	healthdept_2018:1.19
	pre_getangas:1.16
	GPL2010:1.14
	pre_GPL2010:1.13
	pre_var_equation:1.13
	pre_fftwrings:1.9;
locks; strict;
comment	@c @;


1.19
date	2018.10.03.14.34.06;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2012.12.17.19.09.29;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2012.12.17.14.08.14;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.25.14.17.43;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2010.10.22.16.48.20;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.24.13.25.42;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2009.03.06.12.37.11;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.19.17.09.54;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.19.19.08.01;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.19.12.02.50;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.12.15.24.39;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.07.20.10.45;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.29.18.12.24;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2008.02.29.14.49.18;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.29.14.35.13;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.29.12.46.57;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.22.14.05.15;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.24.16.25.36;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2008.01.24.15.52.05;	author leith;	state Exp;
branches;
next	;


desc
@@


1.19
log
@email_health_dept
@
text
@
C++*********************************************************************
C
C FMRS.F      CREATED FROM FMRS_1 & _2 & _3.F    JAN 2008 ARDEAN LEITH
C             ALTERED                            FEB 2008 ARDEAN LEITH
C             FMRS_PLANB                         APR 2008 ARDEAN LEITH
C             FMRS_PLANB 16TH SLOT BUG           DEC 2008 ARDEAN LEITH
C             IPD(6  FOR -PLAN BUG               MAR 2009 ARDEAN LEITH
C             REMOVED OLD SGI CODE               OCT 2010 ARDEAN LEITH
C             REMOVED SPIDER FFT CALLS           DEC 2010 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  FMRS(BUF, NX,NY,NZ, FFTW3PLAN, 
C       SPIDER_SIGN, SPIDER_SCALE, INV,IRTFLG)
C
C  PARAMETERS: BUF            REAL ARRAY (LDA*NY*NZ)     SENT/RET.
C                                LDA = NX + 2 - MOD(NX,2)
C                                EVEN NX --> EVEN LDA = NX +2
C                                ODD  NX --> EVEN LDA = NX +1
C              NX..           NON-FOURIER DIMENSIONS               SENT
C              FFTW3PLAN      EXISTING FFTW3 PLAN OR ZERO          SENT
C              SPIDER_SIGN    CHANGE SIGN OF IMAGINARY TO SPIDER   SENT
C              SPIDER_SCALE   SCALE THE OUTPUT FLAG                SENT
C              INV            1=REG. DATA, -1= FOURIER DATA        SENT
C              IRTFLG         ERROR FLAG (O=NORMAL)                RET.
C
C  PURPOSE:  REAL MIXED RADIX FFT.
C
C            OUTPUT: 
C            N=EVEN  BUF(N+2)
C               ORDER OF ELEMENTS IN BUF:
C               R(0),0.0, R(1), I(1), R(2), I(2), ....., 
C                     R(N/2-1), I(N/2-1), R(N/2),0.0
C
C            N=ODD  BUF(N+1)
C               ORDER OF ELEMENTS IN BUF:
C                    R(0),0.0, R(1), I(1), R(2), I(2), ....., 
C                    R(N/2-1), I(N/2-1), R(N/2),I(N/2)
C
C            FOLLOWING CONVENTION THAT INTEGER DIVISION 
C            IS ROUNDED DOWN, E.G. 5/2 =2)
C
C--*********************************************************************

      MODULE FMRS_INFO
        USE TYPE_KINDS      
        INTEGER, PARAMETER                   :: NPLANS = 16
        INTEGER(KIND=I_8), DIMENSION(NPLANS) :: PLANS  = 0
        INTEGER, DIMENSION(NPLANS,6),SAVE    :: IPD
      END MODULE FMRS_INFO



C       -------------------- FMRS ------------------------------------

	SUBROUTINE FMRS(BUF, NX,NY,NZ, FFTW3PLAN, 
     &                  SPIDER_SIGN, SPIDER_SCALE, INV,IRTFLG)

        USE TYPE_KINDS      
        INTEGER(KIND=I_8), INTENT(IN) :: FFTW3PLAN  ! STRUCTURE POINTER 
        INTEGER(KIND=I_8)             :: PLAN       ! STRUCTURE POINTER 

	REAL,    INTENT(INOUT) :: BUF(*)
        INTEGER, INTENT(IN)    :: NX,NY,NZ
        LOGICAL, INTENT(IN)    :: SPIDER_SIGN, SPIDER_SCALE 
        INTEGER, INTENT(INOUT) :: INV
        INTEGER, INTENT(OUT)   :: IRTFLG

        INTEGER                :: OMP_GET_NUM_THREADS
        INTEGER                :: OMP_GET_NUM_PROCS
        LOGICAL                :: USEBUF

        INCLUDE 'CMBLOCK.INC'

        LDA = NX + 2 - MOD(NX,2)
        IF (FFTW3PLAN .GT. 0) THEN 
C          USE PLAN SENT FROM CALLER
           PLAN = FFTW3PLAN
        ELSE

           IF (NUMFFTWTH .LE. 0) THEN
C             FIRST TIME FFTW3 USED IN THIS RUN
	      CALL FFTW3_INIT_THREADS(IRTFLG)
           ENDIF

           NUMTHWANT = NUMFFTWTH
#ifdef SP_MP
C          COMPILED FOR OMP USE

C          NUMTHP = OMP_GET_NUM_PROCS()
           NUMTH = OMP_GET_NUM_THREADS()
           IF (NUMTH .GT. 1) THEN
C             INSIDE OMP PARALLEL SECTION, CAN NOT MAKE A NEW PLAN
              NUMTHWANT = 1
           ENDIF
           !write(6,*) 'in fmrs, threads,numthwant: ',numth,numthwant
#endif
                   
           !write(6,908) NX,NY,NZ,NUMTHWANT,INV
 908       format( ' Calling fmrs_planb for: (',
     &              I5,',', I5,',', I5,') ',2i5)

C          USE CACHED PLAN OR CREATE A NEW ONE IF CACHE NOT USEFULL
           USEBUF = .FALSE.
	   CALL FMRS_PLANB(.FALSE.,FDUM,NX,NY,NZ,NUMTHWANT,
     &                     INV,PLAN,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ENDIF

        CALL FFTW3_USEPLAN(BUF, NX,NY,NZ, 
     &                     SPIDER_SIGN, SPIDER_SCALE, 
     &                     PLAN,INV,IRTFLG)

	END





C       -------------------- FMRS_PLAN ------------------------------------

        SUBROUTINE FMRS_PLAN(USEBUF,BUF, NX,NY,NZ,
     &                       NUMTHWANT,INV,IRTFLG)

        LOGICAL, INTENT(IN)            :: USEBUF
	REAL,    INTENT(IN)            :: BUF(*)
        INTEGER, INTENT(IN)            :: NX,NY,NZ
        INTEGER, INTENT(IN)            :: NUMTHWANT
        INTEGER, INTENT(IN)            :: INV
        INTEGER, INTENT(OUT)           :: IRTFLG

        INTEGER *8                     :: PLAN  !STRUCTURE POINTER

C       USING FFTW3 LIBRARY CALLS FOR FFT 

C       CREATE A NEW PLAN IF CACHE NOT USEFULL
C       DOES NOT RETURN PLAN TO CALLER

	CALL FMRS_PLANB(USEBUF,BUF,NX,NY,NZ,
     &                     NUMTHWANT,INV,PLAN,IRTFLG)

        RETURN
 	END




C       -------------------- FMRS_PLANB -------------------------------

       SUBROUTINE FMRS_PLANB(USEBUF,BUF, NX,NY,NZ,
     &                       NTH,INV,PLAN,IRTFLG)

C       USING FFTW3 LIBRARY CALLS FOR FFT 

        USE TYPE_KINDS      
        USE FMRS_INFO      

        LOGICAL, INTENT(IN)            :: USEBUF
	REAL,    INTENT(IN)            :: BUF(*)
        INTEGER, INTENT(IN)            :: NX,NY,NZ
        INTEGER, INTENT(IN)            :: NTH
        INTEGER, INTENT(IN)            :: INV
        INTEGER(KIND=I_8), INTENT(OUT) :: PLAN   !STRUCTURE POINTER 
        INTEGER, INTENT(OUT)           :: IRTFLG

        INCLUDE 'CMBLOCK.INC'

        IRTFLG = 1

        MT         = -1              ! EMPTY PLAN SLOT
        IREP       = -1              ! REPLACEABLE PLAN SLOT
        NUMTHINOUT = NTH

C       SEE IF THERE IS ANY SUITABLE CACHED PLAN
        DO IPLAN = 1,NPLANS
           PLAN = PLANS(IPLAN)
           IF (PLAN == 0 .AND. MT < 0) THEN
C             AN MT SLOT FOR A PLAN
              MT = IPLAN
              !write(6,934) mt
934           format('  Found MT slot: ',i3)

           ELSEIF (PLAN .NE. 0) THEN
C             THIS IS A VALID CACHED PLAN

              IF (NX     == IPD(IPLAN,1) .AND. 
     &            NY     == IPD(IPLAN,2) .AND.
     &            NZ     == IPD(IPLAN,3) .AND. 
     &            NTH    == IPD(IPLAN,4) .AND.
     &            INV    == IPD(IPLAN,5)) THEN
C                THIS IS A SUITABLE CACHED PLAN 

                 !write(6,903) iplan, (ipd(iplan,i),i=1,6), plan
 903             format('  Found suitable plan: ',i2,': (',i5,','
     &                  ,i5,',',i5,'):', i2,' ',i2,' ',i2,' Plan:',i14)

C                PRESERVE CACHED PLAN FOR THIS OPERATIONS USE
                 IF (IPD(IPLAN,6) < 0)  IPD(IPLAN,6) = 1

                 IRTFLG = 0
                 RETURN            ! CAN USE THIS PLAN

              ELSEIF (IPD(IPLAN,6) < 0 .AND. IREP < 0) THEN
C                NOT SUITABLE, BUT PLAN CAN BE REPLACED FOR THIS OPERATION
                 IREP = IPLAN

                 !write(6,901) iplan, (ipd(iplan,i),i=1,6), plan
 901             format('  Found replaceble plan: ',i2,': (',i5,','
     &                  ,i5,',',i5,'):', i2,' ',i2,' ',i2,' Plan:',i14)
              ENDIF
           ENDIF
        ENDDO

C       CREATE A NEW CACHED PLAN

        IF (MT > 0) THEN
C          HAVE AN EMPTY PLAN SLOT
           IPLAN = MT
           PLAN  = PLANS(IPLAN)

        ELSEIF (IREP > 0) THEN
C          HAVE AN REPLACEABLE PLAN SLOT
           IPLAN = IREP
           PLAN  = PLANS(IPLAN)

        ELSE
C          NO REMAINING PLAN SLOT FOR ANOTHER CACHED PLAN
        
           WRITE(NOUT,*) '  PROGRAMMING ERROR, TELL THE PROGRAMMER'
           DO IPLAN = 1,NPLANS
              WRITE(6,900) IPLAN,(IPD(IPLAN,I),I=1,6), PLANS(IPLAN)
 900          FORMAT('  CACHED PLAN: ',I2,': (',I5,',',I5,',',I5,'):',
     &                  I2,' ',I2,' ',I2,' PLAN:',I14)
           ENDDO

           CALL ERRT(102,'AVAILABLE FFTW3 PLANS LIMITED TO',NPLANS)
           IRTFLG = 1
           RETURN
        ENDIF

C       THIS IS A EMPTY OR REPLACABLE PLAN SLOT, FILL IT

        LDA = NX + 2 - MOD(NX,2)
        IF (USEBUF) THEN
c          write(6,899)NX,NY,NZ,numthinout,inv
c899       format('  Calling makeplanb for: ',3i6,i4,i3)
           CALL FFTW3_MAKEPLANB(BUF,LDA,NX,NY,NZ,
     &                          NUMTHINOUT,PLAN,INV,IRTFLG)
        ELSE
c          write(6,890)NX,NY,NZ,numthinout,inv
c890       format('  Calling makeplan for: ',3i6,i4,i3)
           CALL FFTW3_MAKEPLAN(NX,NY,NZ,
     &                         NUMTHINOUT,PLAN,INV,IRTFLG)
        ENDIF
        IF (IRTFLG .NE. 0) RETURN

        !write(6,902),iplan,plan,mt,irep
902     format('  Slot:',i4,' Plan:',i20,'  mt,irep:',2i5)

        PLANS(IPLAN) = PLAN
        IPD(IPLAN,1) = NX
        IPD(IPLAN,2) = NY
        IPD(IPLAN,3) = NZ
        IPD(IPLAN,4) = NUMTHINOUT
        IPD(IPLAN,5) = INV
        IPD(IPLAN,6) = 1     
                 
        END


C       -------------------- FMRS_DEPLAN -------------------------------

        SUBROUTINE FMRS_DEPLAN(IRTFLG)

C       USING FFTW3 LIBRARY CALLS FOR FFT 

        USE FMRS_INFO      

        INTEGER, INTENT(OUT)   :: IRTFLG

C       DE-PLAN ALL CACHED PLANS
        DO IPLAN = 1,NPLANS
           IF (PLANS(IPLAN) .NE. 0) IPD(IPLAN,6) = -1 
        ENDDO
        IRTFLG = 0
 
        END






#ifdef NEVER
C-------------------------- old unused -----------------------

C       -------------------- FMRS_PLANB -------------------------------

        SUBROUTINE FMRS_PLANB(USEBUF,BUF,NX,NY,NZ,
     &                       NTH,INV,PLAN,IRTFLG)

C       USING FFTW3 LIBRARY CALLS FOR FFT 

        USE TYPE_KINDS      

        LOGICAL, INTENT(IN)            :: USEBUF
	REAL,    INTENT(IN)            :: BUF(*)
        INTEGER, INTENT(IN)            :: NX,NY,NZ
        INTEGER, INTENT(IN)            :: NTH
        INTEGER, INTENT(IN)            :: INV
        INTEGER(KIND=I_8), INTENT(OUT) :: PLAN   !STRUCTURE POINTER 
        INTEGER, INTENT(OUT)           :: IRTFLG

        INTEGER(KIND=I_8), SAVE :: PLAN1O=0, PLAN1OR=0
        INTEGER(KIND=I_8), SAVE :: PLAN2O=0, PLAN2OR=0
        INTEGER(KIND=I_8), SAVE :: PLAN3O=0, PLAN3OR=0

        INTEGER, SAVE :: NX3O=0,  NY3O=0, NZ3O=0
        INTEGER, SAVE :: NX2O=0,  NY2O=0
        INTEGER, SAVE :: NX1O=0

        INTEGER, SAVE :: NX3OR=0, NY3OR=0, NZ3OR=0
        INTEGER, SAVE :: NX2OR=0, NY2OR=0
        INTEGER, SAVE :: NX1OR=0

        INTEGER, SAVE :: NUMFFTWTHO1=-1, NUMFFTWTHOR1=-1
        INTEGER, SAVE :: NUMFFTWTHO2=-1, NUMFFTWTHOR2=-1
        INTEGER, SAVE :: NUMFFTWTHO3=-1, NUMFFTWTHOR3=-1

        INCLUDE 'CMBLOCK.INC'

        IRTFLG    = 1
        LDA       = NX + 2 - MOD(NX,2)
        NUMTHWANT = NTH

        IF (INV .GT. 0) THEN
C          FORWARD TRANSFORM

           IF (NZ .GT. 1) THEN
C             3D TRANSFORM
              IF (NX     .NE. NX3O .OR. 
     &           NY      .NE. NY3O .OR. 
     &           NZ    .NE. NZ3O .OR.
     &           NUMTHWANT .NE. NUMFFTWTHO3) THEN
C               SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

                !write(6,899)NX,NY,NZ,numthwant,inv
 899            format(' Calling makeplan for: ',3i6,i4,i2)
 
                IF (USEBUF) THEN
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NX,NY,NZ,
     &                               NUMTHWANT,PLAN3O,INV,IRTFLG)
                ELSE
                   CALL FFTW3_MAKEPLAN(NX,NY,NZ,
     &                               NUMTHWANT,PLAN3O,INV,IRTFLG)
                ENDIF
                IF (IRTFLG .NE. 0) RETURN

                NX3O      = NX
                NY3O      = NY
                NZ3O    = NZ
                NUMFFTWTHO3 = NUMTHWANT
             ENDIF
             PLAN = PLAN3O

          ELSEIF  (NY .GT. 1) THEN
C             2D TRANSFORM
              IF (NX     .NE. NX2O .OR. 
     &           NY      .NE. NY2O .OR. 
     &           NUMTHWANT .NE. NUMFFTWTHO2) THEN
C               SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

                !write(6,899)NX,NY,NZ,numthwant,inv

                IF (USEBUF) THEN
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NX,NY,NZ,
     &                               NUMTHWANT,PLAN2O,INV,IRTFLG)
                ELSE
                   CALL FFTW3_MAKEPLAN(NX,NY,NZ,
     &                               NUMTHWANT,PLAN2O,INV,IRTFLG)
                ENDIF
                IF (IRTFLG .NE. 0) RETURN

                NX2O      = NX
                NY2O      = NY
                NUMFFTWTHO2 = NUMTHWANT
             ENDIF

             PLAN = PLAN2O

          ELSE 
C             1D TRANSFORM
              IF (NX     .NE. NX1O .OR. 
     &           NUMTHWANT .NE. NUMFFTWTHO1) THEN
C                SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

                !write(6,899)NX,NY,NZ,numthwant,inv

                IF (USEBUF) THEN
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NX,NY,NZ,
     &                               NUMTHWANT,PLAN1O,INV,IRTFLG)
                ELSE
                   CALL FFTW3_MAKEPLAN(NX,NY,NZ,
     &                               NUMTHWANT,PLAN1O,INV,IRTFLG)
                ENDIF
                IF (IRTFLG .NE. 0) RETURN

                NX1O      = NX
                NUMFFTWTHO1 = NUMTHWANT
             ENDIF

             PLAN = PLAN1O
          ENDIF

       ELSE

C          REVERSE TRANSFORM
           IF (NZ .GT. 1) THEN
C             3D TRANSFORM
              IF (NX      .NE. NX3OR .OR. 
     &            NY      .NE. NY3OR .OR. 
     &            NZ    .NE. NZ3OR .OR.
     &            NUMTHWANT .NE. NUMFFTWTHOR3) THEN
C                SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

                 !write(6,899)NX,NY,NZ,numthwant,inv

                 IF (USEBUF) THEN
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NX,NY,NZ,
     &                               NUMTHWANT,PLAN3OR,INV,IRTFLG)
                 ELSE
                   CALL FFTW3_MAKEPLAN(NX,NY,NZ,
     &                               NUMTHWANT,PLAN3OR,INV,IRTFLG)
                 ENDIF
                 IF (IRTFLG .NE. 0) RETURN

                 NX3OR        = NX
                 NY3OR        = NY
                 NZ3OR        = NZ
                 NUMFFTWTHOR3 = NUMTHWANT
             ENDIF

             PLAN = PLAN3OR

          ELSEIF  (NY .GT. 1) THEN
C             2D TRANSFORM
              IF (NX       .NE. NX2OR .OR. 
     &            NY       .NE. NY2OR .OR. 
     &           NUMTHWANT .NE. NUMFFTWTHOR2) THEN
C               SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

                !write(6,899)NX,NY,NZ,numthwant,inv

                IF (USEBUF) THEN
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NX,NY,NZ,
     &                               NUMTHWANT,PLAN2OR,INV,IRTFLG)
                ELSE
                   CALL FFTW3_MAKEPLAN(NX,NY,NZ,
     &                               NUMTHWANT,PLAN2OR,INV,IRTFLG)
                ENDIF
               IF (IRTFLG .NE. 0) RETURN

                NX2OR      = NX
                NY2OR      = NY
                NUMFFTWTHOR2 = NUMTHWANT
             ENDIF

             PLAN = PLAN2OR

           ELSE 
C             1D TRANSFORM
              IF (NX       .NE. NX1OR .OR. 
     &           NUMTHWANT .NE. NUMFFTWTHOR1) THEN
C               SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

                !write(6,898) NX, NX1or, numthwant ,numfftwthor1
 898            format(' NX,NX1or, numthwant,numfftwthor1:',4i7)
                !write(6,899)NX,NY,NZ,numthwant,inv

                IF (USEBUF) THEN
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NX,NY,NZ,
     &                               NUMTHWANT,PLAN1OR,INV,IRTFLG)
                ELSE
                   CALL FFTW3_MAKEPLAN(NX,NY,NZ,
     &                               NUMTHWANT,PLAN1OR,INV,IRTFLG)
                ENDIF
                IF (IRTFLG .NE. 0) RETURN

                NX1OR      = NX
                NUMFFTWTHOR1 = NUMTHWANT
             ENDIF

             PLAN = PLAN1OR
          ENDIF

        ENDIF
        IRTFLG = 0

        END

#endif
@


1.18
log
@comment
@
text
@d17 1
a17 1
C=* Email: spider@@wadsworth.org                                        *
@


1.17
log
@no more spider fft calling capability
@
text
@d33 1
a33 1
C  FMRS(BUF, NX,NY,NZ, FFTW3PLAN, DOCALC,
d40 1
a40 1
C              NX..         NON-FOURIER DIMENSIONS               SENT
d50 1
a50 1
C            N EVEN  BUF(N+2)
d55 1
a55 1
C            N ODD  BUF(N+1)
d60 1
a60 1
C            FOLLOWING THE CONVENTION THAT INTEGER DIVISION 
@


1.16
log
@comments
@
text
@d4 7
a10 6
C FMRS.F        CREATED FROM FMRS_1 & _2 & _3.F    JAN 2008 ARDEAN LEITH
C               ALTERED                            FEB 2008 ARDEAN LEITH
C               FMRS_PLANB                         APR 2008 ARDEAN LEITH
C               FMRS_PLANB 16TH SLOT BUG           DEC 2008 ARDEAN LEITH
C               IPD(6  FOR -PLAN BUG               MAR 2009 ARDEAN LEITH
C               REMOVED OLD SGI CODE              OCT 2010 ARDEAN LEITH
d15 1
a15 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d33 1
a33 1
C  FMRS(BUF, NSAM,NROW,NSLICE, FFTW3PLAN, DOCALC,
d36 5
a40 5
C  PARAMETERS: BUF            REAL ARRAY (LDA*NROW*NSLICE)     SENT/RET.
C                                LDA = NSAM + 2 - MOD(NSAM,2)
C                                EVEN NSAM --> EVEN LDA = NSAM +2
C                                ODD  NSAM --> EVEN LDA = NSAM +1
C              NSAM..         NON-FOURIER DIMENSIONS               SENT
a64 1
#ifdef SP_LIBFFTW3
a70 1
#endif
d76 1
a76 1
	SUBROUTINE FMRS(BUF, NSAM,NROW,NSLICE, FFTW3PLAN, 
a78 1
#ifdef SP_LIBFFTW3
a81 1
#endif
d84 1
a84 1
        INTEGER, INTENT(IN)    :: NSAM,NROW,NSLICE
d95 1
a95 11
#ifdef SP_LIBFFTW
C       USING FFTW2 LIBRARY CALLS FOR FFT ----------------------- FFTW2
        CALL ERRT(101,'FFTW2 NO LONGER IN USE, DEFINE SP_LIBFFTW3',NE)
        IRTFLG = 1
        END
#endif


#ifdef SP_LIBFFTW3

        LDA = NSAM + 2 - MOD(NSAM,2)
d119 1
a119 1
           !write(6,908) NSAM,NROW,NSLICE,NUMTHWANT,INV
d125 1
a125 1
	   CALL FMRS_PLANB(.FALSE.,FDUM,NSAM,NROW,NSLICE,NUMTHWANT,
d130 1
a130 1
        CALL FFTW3_USEPLAN(BUF, NSAM,NROW,NSLICE, 
a132 5
        RETURN

#else

C       NATIVE SPIDER FFT  (NOT OPTIMAL) ----------------------- SPIDER
a133 97
        REAL, DIMENSION(NSAM+16) :: WORK

        !call errt(101,'calling native spider fft',ne)

        IF (INV .LT. 0 .AND. .NOT. SPIDER_SIGN) THEN
C          UN- CHANGE FFTW FORMAT TO SPIDER FFT FORMAT 
C          SPIDER IMAGINARY PARTS HAVE OPPOSITE SIGNS FROM FFTW 
           LDA = NSAM + 2 - MOD(NSAM,2)
           JH  = LDA/2

c$omp      parallel do private(i)
           DO I = 2,2*JH*NROW*NSLICE,2	
              BUF(I) = -BUF(I)           
           ENDDO
        ENDIF  ! END OF: IF (.NOT. SPIDER_SIGN)

        IF (NSLICE .GT. 1) THEN
C          3D FFT,   HAVE TO CHANGE NSAM
           LDA = NSAM+2-MOD(NSAM,2)
           CALL FMRS_3R(A,LDA,NSAM,NROW,NSLICE,INV)

        ELSEIF (NROW .GT. 1) THEN
C          2D FFT,   HAVE TO CHANGE NSAM
           LDA = NSAM+2-MOD(NSAM,2)

           CALL FMRS_2R(BUF,LDA,NSAM,NROW,INV)
        ELSE
C         ONE DIMENSIONAL FFT
          N = NSAM 
          IF (INV .GE. 1)  THEN
C            FORWARD TRANSFORM

             DO I=1,N
                WORK(I) = 0.0
             ENDDO
             CALL FFTMCF(BUF,WORK,N,N,N,INV)

             IF (MOD(N,2) .LE. 0)  THEN
                DO I=N+1,3,-2
                   BUF(I)   = BUF((I+1)/2)
                   BUF(I+1) = WORK((I+1)/2)
                ENDDO
                BUF(2)   = 0.0
                BUF(N+2) = 0.0
              ELSE
                DO I=N,3,-2
                   BUF(I)   = BUF(I/2+1)
                   BUF(I+1) = WORK(I/2+1)
                ENDDO

                BUF(2)= 0.0
             ENDIF
          ELSE
C            INVERSE TRANSFORM

             DO I=2,N/2+1
                WORK(I)     = BUF(2*I)/N
                WORK(N-I+2) = -WORK(I)
             ENDDO

             WORK(1) = 0.0

             DO I=1,N/2+1
                BUF(I) = BUF(2*I-1)/N
             ENDDO
             DO I=N,N/2+2,-1
                BUF(I) = BUF(N-I+2)
             ENDDO

             CALL FFTMCF(BUF,WORK,N,N,N,INV)

          ENDIF  ! END OF: REVERSE TRANSFORM
       ENDIF     ! END OF: ELSE FOR DIMENSION

       IF (INV .GT. 0 .AND. .NOT. SPIDER_SIGN) THEN
C         UN- CHANGE FFTW FORMAT TO SPIDER FFT FORMAT 
C         SPIDER IMAGINARY PARTS HAVE OPPOSITE SIGNS FROM FFTW 
          LDA = NSAM + 2 - MOD(NSAM,2)
          JH  = LDA/2

c$omp     parallel do private(i)
          DO I = 2,2*JH*NROW*NSLICE,2	
             BUF(I) = -BUF(I)           
          ENDDO
        ENDIF  ! END OF: IF (.NOT. SPIDER_SIGN)

        IF (INV .LE. 0 .AND. .NOT. SPIDER_SCALE) THEN
C           UN-SCALING NEEDED
            PIX = (NSAM * NROW * NSLICE)

c$omp       parallel do private(i)
            DO I=1,LDA*NROW*NSLICE
               BUF(I) = BUF(I) * PIX
            ENDDO
        ENDIF    ! END OF: IF (.NOT. SPIDER_SCALE)
        IRTFLG = 0
#endif
d142 1
a142 1
        SUBROUTINE FMRS_PLAN(USEBUF,BUF, NSAM,NROW,NSLICE,
d147 1
a147 1
        INTEGER, INTENT(IN)            :: NSAM,NROW,NSLICE
a153 6
#ifndef SP_LIBFFTW3
C       USING SGI OR NATIVE LIBRARY CALLS FOR FFT 
        IRTFLG = 0

        END
#else
d159 1
a159 1
	CALL FMRS_PLANB(USEBUF,BUF,NSAM,NROW,NSLICE,
a164 1
#endif
d170 1
a170 1
       SUBROUTINE FMRS_PLANB(USEBUF,BUF, NSAM,NROW,NSLICE,
a172 7
#ifndef SP_LIBFFTW3

C       USING SGI OR NATIVE LIBRARY CALLS FOR FFT 
        IRTFLG = 0

        END
#else
d180 1
a180 1
        INTEGER, INTENT(IN)            :: NSAM,NROW,NSLICE
d197 1
a197 1
           IF (PLAN .EQ. 0 .AND. MT .LT. 0) THEN
d206 5
a210 5
              IF (NSAM   .EQ. IPD(IPLAN,1) .AND. 
     &            NROW   .EQ. IPD(IPLAN,2) .AND.
     &            NSLICE .EQ. IPD(IPLAN,3) .AND. 
     &            NTH    .EQ. IPD(IPLAN,4) .AND.
     &            INV    .EQ. IPD(IPLAN,5)) THEN
d218 1
a218 1
                 IF (IPD(IPLAN,6) .LT. 0)  IPD(IPLAN,6) = 1
d223 1
a223 1
              ELSEIF (IPD(IPLAN,6) .LT. 0 .AND. IREP .LT. 0) THEN
d236 1
a236 1
        IF (MT .GT. 0) THEN
d241 1
a241 1
        ELSEIF (IREP .GT. 0) THEN
d263 1
a263 1
        LDA = NSAM + 2 - MOD(NSAM,2)
d265 1
a265 1
c          write(6,899)nsam,nrow,nslice,numthinout,inv
d267 1
a267 1
           CALL FFTW3_MAKEPLANB(BUF,LDA,NSAM,NROW,NSLICE,
d270 1
a270 1
c          write(6,890)nsam,nrow,nslice,numthinout,inv
d272 1
a272 1
           CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,
d281 3
a283 3
        IPD(IPLAN,1) = NSAM
        IPD(IPLAN,2) = NROW
        IPD(IPLAN,3) = NSLICE
a288 1
#endif
a294 5
#ifndef SP_LIBFFTW3
C       USING SGI OR NATIVE LIBRARY CALLS FOR FFT 
        INTEGER, INTENT(OUT)           :: IRTFLG
        IRTFLG = 0
#else
d299 1
a299 1
        INTEGER, INTENT(OUT)           :: IRTFLG
d301 1
a301 1
C       DEPLAN ALL CACHED PLANS
d305 1
a305 2
       IRTFLG = 0
#endif
d319 1
a319 1
       SUBROUTINE FMRS_PLANB(USEBUF,BUF,NSAM,NROW,NSLICE,
a321 7
#ifndef SP_LIBFFTW3

C       USING SGI OR NATIVE LIBRARY CALLS FOR FFT 
        IRTFLG = 0

        END
#else
d328 1
a328 1
        INTEGER, INTENT(IN)            :: NSAM,NROW,NSLICE
d338 7
a344 7
        INTEGER, SAVE :: NSAM3O=0,  NROW3O=0, NSLICE3O=0
        INTEGER, SAVE :: NSAM2O=0,  NROW2O=0
        INTEGER, SAVE :: NSAM1O=0

        INTEGER, SAVE :: NSAM3OR=0, NROW3OR=0, NSLICE3OR=0
        INTEGER, SAVE :: NSAM2OR=0, NROW2OR=0
        INTEGER, SAVE :: NSAM1OR=0
d353 1
a353 1
        LDA       = NSAM + 2 - MOD(NSAM,2)
d359 1
a359 1
           IF (NSLICE .GT. 1) THEN
d361 3
a363 3
              IF (NSAM     .NE. NSAM3O .OR. 
     &           NROW      .NE. NROW3O .OR. 
     &           NSLICE    .NE. NSLICE3O .OR.
d367 1
a367 1
                !write(6,899)nsam,nrow,nslice,numthwant,inv
d371 1
a371 1
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NSAM,NROW,NSLICE,
d374 1
a374 1
                   CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,
d379 3
a381 3
                NSAM3O      = NSAM
                NROW3O      = NROW
                NSLICE3O    = NSLICE
d386 1
a386 1
          ELSEIF  (NROW .GT. 1) THEN
d388 2
a389 2
              IF (NSAM     .NE. NSAM2O .OR. 
     &           NROW      .NE. NROW2O .OR. 
d393 1
a393 1
                !write(6,899)nsam,nrow,nslice,numthwant,inv
d396 1
a396 1
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NSAM,NROW,NSLICE,
d399 1
a399 1
                   CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,
d404 2
a405 2
                NSAM2O      = NSAM
                NROW2O      = NROW
d413 1
a413 1
              IF (NSAM     .NE. NSAM1O .OR. 
d417 1
a417 1
                !write(6,899)nsam,nrow,nslice,numthwant,inv
d420 1
a420 1
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NSAM,NROW,NSLICE,
d423 1
a423 1
                   CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,
d428 1
a428 1
                NSAM1O      = NSAM
d438 1
a438 1
           IF (NSLICE .GT. 1) THEN
d440 3
a442 3
              IF (NSAM      .NE. NSAM3OR .OR. 
     &            NROW      .NE. NROW3OR .OR. 
     &            NSLICE    .NE. NSLICE3OR .OR.
d446 1
a446 1
                 !write(6,899)nsam,nrow,nslice,numthwant,inv
d449 1
a449 1
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NSAM,NROW,NSLICE,
d452 1
a452 1
                   CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,
d457 3
a459 3
                 NSAM3OR      = NSAM
                 NROW3OR      = NROW
                 NSLICE3OR    = NSLICE
d465 1
a465 1
          ELSEIF  (NROW .GT. 1) THEN
d467 2
a468 2
              IF (NSAM     .NE. NSAM2OR .OR. 
     &           NROW      .NE. NROW2OR .OR. 
d472 1
a472 1
                !write(6,899)nsam,nrow,nslice,numthwant,inv
d475 1
a475 1
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NSAM,NROW,NSLICE,
d478 1
a478 1
                   CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,
d483 2
a484 2
                NSAM2OR      = NSAM
                NROW2OR      = NROW
d492 1
a492 1
              IF (NSAM     .NE. NSAM1OR .OR. 
d496 3
a498 3
                !write(6,898) nsam, nsam1or, numthwant ,numfftwthor1
 898            format(' nsam,nsam1or, numthwant,numfftwthor1:',4i7)
                !write(6,899)nsam,nrow,nslice,numthwant,inv
d501 1
a501 1
                   CALL FFTW3_MAKEPLANB(BUF,LDA,NSAM,NROW,NSLICE,
d504 1
a504 1
                   CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,
d509 1
a509 1
                NSAM1OR      = NSAM
a519 1
#endif
@


1.15
log
@REMOVED OLD SGI CODE
@
text
@d38 2
a39 2
C                                ODD  NSAM --> ODD  LDA = NSAM +1
C              NSAM..         DIMENSIONS                           SENT
@


1.14
log
@GPL_2010
@
text
@d9 1
a148 2
#ifdef SP_LIBFFT
C       USING SGI_COMPLIB FOR FFT --------------------------------- SGI
a149 113
        INTEGER, SAVE                 :: NSAMO=0, NROWO=0, NSLICEO=0
        REAL, DIMENSION(:), POINTER, SAVE :: COEFF
        REAL, DIMENSION(NSAM+16)          :: WORK

        IRTFLG = 1

        IF (INV .LT. 0 .AND. .NOT. SPIDER_SIGN) THEN
C          UN-CHANGE FFTW FORMAT TO SPIDER FORMAT (REVERSE TRANSFORM)
C          SPIDER IMAGINARY PARTS HAVE OPPOSITE SIGNS FROM FFTW 
           LDA = NSAM + 2 - MOD(NSAM,2)

c$omp      parallel do private(i)
           DO I = 2,LDA*NROW*NSLICE,2	
              BUF(I) = -BUF(I)           
           ENDDO
        ENDIF  ! END OF: IF (.NOT. SPIDER_SIGN)

        IF (NROW .LE. 1) THEN
C          ONE DIMENSIONAL SGI FFT
           CALL SCFFT1DUI(NSAM,WORK)

           INC = 1
           IF (INV .GT. 0) THEN
              CALL SCFFT1DU(INV,NSAM,BUF,INC,WORK)
           ELSE
              CALL CSFFT1DU(INV,NSAM,BUF,INC,WORK)
              QT = 1.0 / FLOAT(NSAM)
              IF (SPIDER_SCALE) CALL SSCAL1D(NSAM,QT,BUF,INC)
           ENDIF

        ELSEIF (NSLICE .LE. 1) THEN
C          TWO DIMENSIONAL SGI FFT
           !write(6,*) 'TWO DIMENSIONAL SGI FFT'
           IF (NSAM.NE.NSAMO .OR. NROW.NE.NROWO) THEN
C             SIZE CHANGED MUST RE-ESTABLISH COEFFICIENTS

              IF (ASSOCIATED(COEFF)) DEALLOCATE(COEFF)
              ALLOCATE(COEFF(NSAM+15+2*(NROW+15)),STAT=IRTFLG)
              IF (IRTFLG .NE. 0) THEN
                 MWANT = NSAM + 15 + 2 * (NROW+15)
                 CALL ERRT(46,'FMRS, COEFF',MWANT)
                 RETURN
              ENDIF

              CALL SCFFT2DUI(NSAM,NROW,COEFF) !ESTABLISH COEFFICIENTS

              NSAMO   = NSAM
              NROWO   = NROW
              NSLICEO = 1
           ENDIF

           LDA = NSAM + 2 - MOD(NSAM,2)
           IF (INV .GT. 0)  THEN
C             FORWARD TRANSFORM
              CALL SCFFT2DU(INV,NSAM,NROW,BUF,LDA,COEFF)
           ELSE
              CALL CSFFT2DU(INV,NSAM,NROW,BUF,LDA,COEFF)
              IF (SPIDER_SCALE) THEN
                 QT = 1.0 / FLOAT(NSAM) / FLOAT(NROW)
                 CALL SSCAL2D(NSAM,NROW,QT,BUF,LDA)
              ENDIF
           ENDIF
        ELSE
C          THREE DIMENSIONAL SGI FFT
           IF (NSAM   .NE.  NSAMO .OR. 
     &         NROW   .NE.  NROWO .OR. 
     &         NSLICE .NE.  NSLICEO) THEN

              IF (ASSOCIATED(COEFF)) DEALLOCATE(COEFF)
              ALLOCATE(COEFF(NSAM+15+2*(NROW+15)+2*(NSLICE+15)),
     &                 STAT=IRTFLG)
              IF (IRTFLG.NE.0) THEN
                 MWANT = NSAM+15+2*(NROW+15)+2*(NSLICE+15)
                 CALL ERRT(46,'FMRS, COEFF',MWANT)
                 RETURN
              ENDIF

              CALL  SCFFT3DUI(NSAM,NROW,NSLICE,COEFF) !ESTABLISH COEFFICIENTS

              NSAMO   = NSAM
              NROWO   = NROW
              NSLICEO = NSLICE
           ENDIF

           LDA = NSAM + 2 - MOD(NSAM,2)
           IF (INV .GT. 0) THEN
C             FORWARD FFT
              CALL SCFFT3DU(INV,NSAM,NROW,NSLICE,BUF,LDA,NROW,COEFF)
           ELSE
C             REVERSE FFT
              CALL CSFFT3DU(INV,NSAM,NROW,NSLICE,BUF,LDA,NROW,COEFF)

              IF (SPIDER_SCALE) THEN
                 QT = 1.0 / FLOAT(NSAM) / FLOAT(NROW) / FLOAT(NSLICE)
                 CALL SSCAL3D(NSAM,NROW,NSLICE,QT,BUF,LDA,NROW)
              ENDIF
           ENDIF
        ENDIF

        IF (INV .GT. 0 .AND. .NOT. SPIDER_SIGN) THEN
C          UN- CHANGE FFTW FORMAT TO SPIDER FFT FORMAT 
C          SPIDER IMAGINARY PARTS HAVE OPPOSITE SIGNS FROM FFTW 
           LDA = NSAM + 2 - MOD(NSAM,2)

c$omp      parallel do private(i)
           DO I = 2,LDA*NROW*NSLICE,2	
              BUF(I) = -BUF(I)           
           ENDDO
        ENDIF  ! END OF: IF (.NOT. SPIDER_SIGN)

        IRTFLG = 0
        RETURN
#else
a247 1
#endif
@


1.13
log
@intel negative iplan bug ipd used
@
text
@a9 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
d11 5
a15 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d17 1
a17 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d22 1
a22 1
C=* This program is distributed in the hope that it will be useful,    *
d24 1
a24 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a25 1
C=*                                                                    *
d27 1
a27 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.12
log
@16th plan bug fixed
@
text
@d8 1
a8 1
C
d11 1
a11 1
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d71 2
a72 2
        INTEGER(KIND=I_8), DIMENSION(NPLANS) :: PLANS = 0
        INTEGER, DIMENSION(NPLANS,5),SAVE    :: IPD
d448 2
a453 6
c            write(6,900) iplan,
c    &                     ipd(iplan,1),ipd(iplan,2),ipd(iplan,3),
c    &                     ipd(iplan,4),ipd(iplan,5), plan
c900           format('  Found plan: ',i2,': (',i5,',',i5,',',i5,'):',
c    &                  i2,' ',i2,' Plan:',i14)

d461 6
a466 5
                 IF (PLAN .LT. 0) THEN
C                   PRESERVE CACHED PLAN FOR THIS OPERATIONS USE
                    PLANS(IPLAN) = -PLAN
	            PLAN         = PLANS(IPLAN)
                 ENDIF
d471 2
a472 2
              ELSEIF (PLAN .LT. 0 .AND. IREP .LT. 0) THEN
C                NOT SUITABLE, PLAN CAN BE REPLACED FOR THIS OPERATION
d474 4
d499 1
a499 3
              WRITE(6,900) IPLAN,
     &                     IPD(IPLAN,1),IPD(IPLAN,2),IPD(IPLAN,3),
     &                     IPD(IPLAN,4),IPD(IPLAN,5), PLANS(IPLAN)
d501 1
a501 1
     &                  I2,' ',I2,' PLAN:',I14)
d513 1
a513 1
c           write(6,899)nsam,nrow,nslice,numthinout,inv
d518 1
a518 1
c           write(6,890)nsam,nrow,nslice,numthinout,inv
d525 2
a526 3
c        write(6,901),iplan,plan,mt,irep
c901     format('  Slot:',i4,' plan:',i18,' mt,irep:',2i5)

d534 1
d557 1
a557 1
           IF (PLANS(IPLAN) .GT. 0) PLANS(IPLAN) = -PLANS(IPLAN) 
@


1.11
log
@ELSEIF (PLAN .EQ. 0 .AND. MT .LT. 0) logic
@
text
@d7 1
d486 2
d491 2
d510 1
a510 4
C       THIS IS A EMPTY PLAN SLOT, FILL IT

        !write(6,899)nsam,nrow,nslice,numthwant,inv
 899    format(' Calling makeplan for: ',3i6,i4,i2)
d514 2
d519 2
d526 4
@


1.10
log
@FFTW3 plan changes
@
text
@d444 5
a448 1
           IF (PLAN .NE. 0) THEN
d471 5
a475 1
                 RETURN
a476 8

           ELSEIF (PLAN .EQ. 0 .AND. MT .LT. 0) THEN
C             AN MT SLOT FOR A PLAN
              MT = IPLAN

           ELSEIF (PLAN .LT. 0 .AND. IREP .LT. 0) THEN
C             THIS PLAN CAN BE REPLACED FOR THIS OPERATION
              IREP = IPLAN
d491 9
a499 1
           WRITE(NOUT,*) '  PROGRAMING ERROR'
@


1.9
log
@rewrite
@
text
@d6 1
d66 10
d94 4
d110 1
d125 1
d131 1
d135 1
a135 1
 908       format( ' Calling fmrs_plan for: (',
d139 3
a141 1
	   CALL FMRS_PLAN(NSAM,NROW,NSLICE,NUMTHWANT,INV,PLAN,IRTFLG)
a144 1
        !write(6,*) ' Calling useplan: ',NUMTHWANT,PLAN
d186 1
a186 1
c          write(6,*) 'TWO DIMENSIONAL SGI FFT'
d271 1
a271 3
          write(6,*) 'calling native spider fft!!!!!!!!!!'
          call errt(101,'calling native spider fft',ne)

d373 11
a383 1
C       -------------------- FMRS_PLAN -------------------------------
d385 27
a411 1
	SUBROUTINE FMRS_PLAN(NSAM,NROW,NSLICE, NTH, INV, PLAN,IRTFLG)
d420 1
d423 1
d425 4
a428 1
        INTEGER, INTENT(IN)            :: NSAM,NROW,NSLICE,NTH
d430 105
a535 1
        INTEGER(KIND=I_8), INTENT(OUT) :: PLAN   !STRUCTURE POINTER 
d538 29
d569 10
d583 11
a593 11
	INTEGER, SAVE :: NSAM3O=0,  NROW3O=0, NSLICE3O=0
	INTEGER, SAVE :: NSAM2O=0,  NROW2O=0
	INTEGER, SAVE :: NSAM1O=0

	INTEGER, SAVE :: NSAM3OR=0, NROW3OR=0, NSLICE3OR=0
	INTEGER, SAVE :: NSAM2OR=0, NROW2OR=0
	INTEGER, SAVE :: NSAM1OR=0

	INTEGER, SAVE :: NUMFFTWTHO1=-1, NUMFFTWTHOR1=-1
	INTEGER, SAVE :: NUMFFTWTHO2=-1, NUMFFTWTHOR2=-1
	INTEGER, SAVE :: NUMFFTWTHO3=-1, NUMFFTWTHOR3=-1
d598 1
a598 1

d615 7
a621 2
                CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                              PLAN3O,INV,IRTFLG)
d624 3
a626 3
	        NSAM3O      = NSAM
	        NROW3O      = NROW
	        NSLICE3O    = NSLICE
d640 7
a646 2
                CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                               PLAN2O,INV,IRTFLG)
d649 2
a650 2
	        NSAM2O      = NSAM
	        NROW2O      = NROW
d664 7
a670 2
                CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                              PLAN1O,INV,IRTFLG)
d673 1
a673 1
	        NSAM1O      = NSAM
d693 7
a699 2
                 CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                               PLAN3OR,INV,IRTFLG)
d702 3
a704 3
	         NSAM3OR      = NSAM
	         NROW3OR      = NROW
	         NSLICE3OR    = NSLICE
d719 8
a726 3
                CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                               PLAN2OR,INV,IRTFLG)
                IF (IRTFLG .NE. 0) RETURN
d728 2
a729 2
	        NSAM2OR      = NSAM
	        NROW2OR      = NROW
d745 7
a751 2
                CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                               PLAN1OR,INV,IRTFLG)
d754 1
a754 1
	        NSAM1OR      = NSAM
d767 1
@


1.8
log
@removed docalc from fmrs call
@
text
@d5 1
d33 1
a33 1
C  FMRS(BUF, NSAM,NROW,NSLICE, FFTW3PLAN,
d65 4
a68 1
	SUBROUTINE FMRS(BUF, NSAM,NROW,NSLICE, FFTW3PLAN,
d73 2
d77 3
a79 1
	REAL ,INTENT(INOUT)    :: BUF(*)
a81 1
        LOGICAL, INTENT(IN)    :: SPIDER_SIGN, SPIDER_SCALE
d83 3
a85 1
#if defined (SP_LIBFFTW)
d87 1
a87 1
        CALL ERRT(101,'FFTW2 NO LONGER IN USE, DEFINE SP_LIBFFTW3',IER)
d89 1
a89 1
        RETURN
d95 4
a98 16
C       USING FFTW3 LIBRARY CALLS FOR FFT ----------------------- FFTW3

C       FFTW3PLAN, PLAN & PLANR ARE POINTERS TO STRUCTURES 
        INTEGER(KIND=I_8)       :: FFTW3PLAN
        INTEGER(KIND=I_8), SAVE :: PLAN=0, PLANO=0, PLANR=0, PLANOR=0

	INTEGER, SAVE :: NSAMO=0,  NROWO=0,  NSLICEO= 0
	INTEGER, SAVE :: NSAMOR=0, NROWOR=0, NSLICEOR=0
	INTEGER, SAVE :: NUMFFTWTHO=1, NUMFFTWTHOR=1

#include "FFTW3.INC"
        INCLUDE 'CMBLOCK.INC'

        IRTFLG = 1

        NUMTHWANT = NUMFFTWTH
d100 3
a102 25
        IF (INV .GT. 0) THEN
C          FORWARD TRANSFORM

           IF (FFTW3PLAN .LE. 0) THEN 
              IF (NSAM      .NE. NSAMO .OR. 
     &            NROW      .NE. NROWO .OR. 
     &            NSLICE    .NE. NSLICEO .OR.
     &            NUMTHWANT .NE. NUMFFTWTHO) THEN
C                SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

c                write(6,*) ' Calling makeplan for:',numthwant
                 CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                               PLANO,INV,IRTFLG)
                 IF (IRTFLG .NE. 0) RETURN

	         NSAMO      = NSAM
	         NROWO      = NROW
	         NSLICEO    = NSLICE
                 NUMFFTWTHO = NUMTHWANT
              ENDIF

              PLAN = PLANO

           ELSE
              PLAN = FFTW3PLAN
d105 8
a112 38
c          write(6,*) ' Calling useplanfor:',numthwant,plan
 	   CALL FFTW3_USEPLAN(BUF, NSAM,NROW,NSLICE, 
     &                             SPIDER_SIGN, .FALSE., 
     &                             PLAN,INV,IRTFLG)
        ELSE

C          REVERSE TRANSFORM
           NUMTHWANTR = NUMFFTWTH

           IF (FFTW3PLAN .LE. 0) THEN 
	      IF (NSAM      .NE. NSAMOR .OR. 
     &           NROW       .NE. NROWOR .OR.
     &           NSLICE     .NE. NSLICEOR .OR.
     &           NUMTHWANTR .NE. NUMFFTWTHOR) THEN
C                SIZE OR THREADING CHANGED, CREATE NEW REVERSE PLAN

c                write(6,*) 'nsam,nsamor:',nsam,nsamor
c                write(6,*) 'nrow,nrowor:',nrow,nrowor
c                write(6,*) 'nslice,nsliceor:',nslice,nsliceor
c                write(6,*) 'numthwantr,numfftwthor:',numthwantr,numfftwthor
c                write(6,*) ' Calling makeplan rev, :',numthwant
c                write(6,*) ' Calling makeplan rev: ',numthwantr

                 CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANTR,
     &                               PLANOR,INV,IRTFLG)
                 IF (IRTFLG .NE. 0) RETURN

	         NSAMOR      = NSAM
	         NROWOR      = NROW
	         NSLICEOR    = NSLICE
                 NUMFFTWTHOR = NUMTHWANTR

              ENDIF

C             CARRY OUT FFT USING THIS PLAN
              PLANR = PLANOR
           ELSE
              PLANR = FFTW3PLAN
d114 10
d125 5
a129 6
c          write(6,*) ' Calling useplan rev:',numthwant,planr
	   CALL FFTW3_USEPLAN(BUF, NSAM,NROW,NSLICE, 
     &                           SPIDER_SIGN, SPIDER_SCALE, 
     &                           PLANR,INV,IRTFLG)
        ENDIF
        IRTFLG = 0
d252 4
d353 183
@


1.7
log
@IF (.NOT. DOCALC) RETURN needed
@
text
@a4 1
C               DOCALC ADDED                       FEB 2008 ARDEAN LEITH
d32 1
a32 1
C  FMRS(BUF, NSAM,NROW,NSLICE, FFTW3PLAN, DOCALC,
a40 1
C              DOCALC         CARRY OUT FFT                        SENT
d64 1
a64 1
	SUBROUTINE FMRS(BUF, NSAM,NROW,NSLICE, FFTW3PLAN, DOCALC,
d74 1
a74 1
        LOGICAL, INTENT(IN)    :: SPIDER_SIGN, SPIDER_SCALE, DOCALC
a124 1
              IF (.NOT. DOCALC) RETURN     ! INITIALIZE ONLY
a161 1
                 IF (.NOT. DOCALC) RETURN     ! INITIALIZE ONLY
@


1.6
log
@removed debug output
@
text
@d157 1
a157 1
     &                           PLANOR,INV,IRTFLG)
d164 2
@


1.5
log
@bad numfftwth for reverse
@
text
@d154 1
a154 1
                write(6,*) ' Calling makeplan rev:',numthwant
@


1.4
log
@docalc parameter for fmrs
@
text
@d140 1
a140 1
           NUMTHWANTR = NUMFFTWH
d143 1
a143 1
	      IF (NSAM       .NE. NSAMOR .OR. 
d153 2
a154 1
c                write(6,*) ' Calling makeplan rev:',numthwant
@


1.3
log
@added plan parameter
@
text
@d5 1
d33 1
a33 1
C  FMRS(BUF, NSAM,NROW,NSLICE, FFTW3PLAN,
d42 1
d66 1
a66 1
	SUBROUTINE FMRS(BUF, NSAM,NROW,NSLICE, FFTW3PLAN, 
d76 1
a76 1
        LOGICAL, INTENT(IN)    :: SPIDER_SIGN, SPIDER_SCALE
d127 2
@


1.2
log
@typo
@
text
@d32 2
a33 1
C  FMRS(BUF, NSAM,NROW,NSLICE,SPIDER_SIGN, SPIDER_SCALE, INV,IRTFLG)
d35 4
a38 1
C  PARAMETERS: BUF            ARRAY (LDA*NROW*NSLICE)          SENT/RET.
d40 1
a46 1
C            INPUT:  BUF(N) - REAL ARRAY
d58 2
a59 1
C            HERE WE FOLLOW THE CONVENTION THAT INTEGER DIVISION 
d64 1
a64 1
	SUBROUTINE FMRS(BUF, NSAM,NROW,NSLICE, 
d67 1
d69 1
a83 2


d88 2
a89 1
C       PLAN & PLANR ARE POINTERS TO STRUCTURES 
d97 1
d101 1
a101 3
        NUMTHWANT = 0

c         write(6,*) ' in fmrs ',nsam,nrow,nslice
d106 21
a126 16
	   IF (NSAM      .NE. NSAMO .OR. 
     &         NROW      .NE. NROWO .OR. 
     &         NSLICE    .NE. NSLICEO .OR.
     &         NUMTHWANT .NE. NUMFFTWTHO) THEN
C             SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

c             write(6,*) ' calling makeplan for:',numthwant

              CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                            PLANO,INV,IRTFLG)
              IF (IRTFLG .NE. 0) RETURN

	      NSAMO      = NSAM
	      NROWO      = NROW
	      NSLICEO    = NSLICE
              NUMFFTWTHO = NUMTHWANT
d129 1
a129 4
           PLAN = PLANO

c          write(6,*) ' calling useplanfor:',numthwant,plan

d136 1
d138 12
a149 11
	   IF (NSAM       .NE. NSAMOR .OR. 
     &         NROW       .NE. NROWOR .OR.
     &         NSLICE     .NE. NSLICEOR .OR.
     &         NUMTHWANTR .NE. NUMFFTWTHOR) THEN
C             SIZE OR THREADING CHANGED, CREATE NEW REVERSE PLAN

c             write(6,*) 'nsam,nsamor:',nsam,nsamor
c             write(6,*) 'nrow,nrowor:',nrow,nrowor
c             write(6,*) 'nslice,nsliceor:',nslice,nsliceor
c            write(6,*) 'numthwantr,numfftwthor:',numthwantr,numfftwthor
c         write(6,*) ' calling makeplan rev:',numthwant
d151 1
a151 1
              CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
d153 1
a153 1
              IF (IRTFLG .NE. 0) RETURN
d155 10
a164 4
	      NSAMOR      = NSAM
	      NROWOR      = NROW
	      NSLICEOR    = NSLICE
              NUMFFTWTHOR = NUMTHWANT
d167 1
a167 4
C          CARRY OUT FFT USING THIS PLAN
           PLANR = PLANOR

c          write(6,*) ' calling useplan rev:',numthwant,planr
d185 1
a185 1
C          UN- CHANGE FFTW FORMAT TO SPIDER FFT FORMAT 
a187 1
           JH  = LDA/2
d190 1
a190 1
           DO I = 2,2*JH*NROW*NSLICE,2	
d199 1
a199 1
           LDA = 1
d201 1
a201 1
              CALL SCFFT1DU(INV,NSAM,BUF,LDA,WORK)
d203 1
a203 1
              CALL CSFFT1DU(INV,NSAM,BUF,LDA,WORK)
d205 1
a205 1
              IF (SPIDER_SCALE) CALL SSCAL1D(NSAM,QT,BUF,LDA)
d210 1
a210 1

d212 1
a212 1
C             SIZE CHANGED MUST REESTABLISH COEFFICIENTS
d232 1
a232 1
              CALL  SCFFT2DU(INV,NSAM,NROW,BUF,LDA,COEFF)
d234 1
a234 1
              CALL  CSFFT2DU(INV,NSAM,NROW,BUF,LDA,COEFF)
a280 1
           JH  = LDA/2
d283 1
a283 1
           DO I = 2,2*JH*NROW*NSLICE,2	
@


1.1
log
@new
@
text
@d76 87
d172 1
a172 1
        IF (.INV .LT. 0 .AND. .NOT. SPIDER_SIGN) THEN
d240 1
a240 1
                 CALL ERRT(46,''FMRS, COEFF',MWANT)
d258 1
d266 1
a266 1
        IF (.INV .GT. 0 .AND. .NOT. SPIDER_SIGN) THEN
a279 87
#endif



#ifdef SP_LIBFFTW3

C       USING FFTW3 LIBRARY CALLS FOR FFT ----------------------- FFTW3

C       PLAN & PLANR ARE POINTERS TO STRUCTURES 
        INTEGER(KIND=I_8), SAVE :: PLAN=0, PLANO=0, PLANR=0, PLANOR=0

	INTEGER, SAVE :: NSAMO=0,  NROWO=0,  NSLICEO= 0
	INTEGER, SAVE :: NSAMOR=0, NROWOR=0, NSLICEOR=0
	INTEGER, SAVE :: NUMFFTWTHO=1, NUMFFTWTHOR=1

#include "FFTW3.INC"

        IRTFLG = 1

        NUMTHWANT = 0

c         write(6,*) ' in fmrs ',nsam,nrow,nslice

        IF (INV .GT. 0) THEN
C          FORWARD TRANSFORM

	   IF (NSAM      .NE. NSAMO .OR. 
     &         NROW      .NE. NROWO .OR. 
     &         NSLICE    .NE. NSLICEO .OR.
     &         NUMTHWANT .NE. NUMFFTWTHO) THEN
C             SIZE OR THREADING CHANGED, CREATE NEW FORWARD PLAN

c             write(6,*) ' calling makeplan for:',numthwant

              CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                            PLANO,INV,IRTFLG)
              IF (IRTFLG .NE. 0) RETURN

	      NSAMO      = NSAM
	      NROWO      = NROW
	      NSLICEO    = NSLICE
              NUMFFTWTHO = NUMTHWANT
           ENDIF

           PLAN = PLANO

c          write(6,*) ' calling useplanfor:',numthwant,plan

 	   CALL FFTW3_USEPLAN(BUF, NSAM,NROW,NSLICE, 
     &                             SPIDER_SIGN, .FALSE., 
     &                             PLAN,INV,IRTFLG)
        ELSE

C          REVERSE TRANSFORM

	   IF (NSAM       .NE. NSAMOR .OR. 
     &         NROW       .NE. NROWOR .OR.
     &         NSLICE     .NE. NSLICEOR .OR.
     &         NUMTHWANTR .NE. NUMFFTWTHOR) THEN
C             SIZE OR THREADING CHANGED, CREATE NEW REVERSE PLAN

c             write(6,*) 'nsam,nsamor:',nsam,nsamor
c             write(6,*) 'nrow,nrowor:',nrow,nrowor
c             write(6,*) 'nslice,nsliceor:',nslice,nsliceor
c            write(6,*) 'numthwantr,numfftwthor:',numthwantr,numfftwthor
c         write(6,*) ' calling makeplan rev:',numthwant

              CALL FFTW3_MAKEPLAN(NSAM,NROW,NSLICE,NUMTHWANT,
     &                           PLANOR,INV,IRTFLG)
              IF (IRTFLG .NE. 0) RETURN

	      NSAMOR      = NSAM
	      NROWOR      = NROW
	      NSLICEOR    = NSLICE
              NUMFFTWTHOR = NUMTHWANT
           ENDIF

C          CARRY OUT FFT USING THIS PLAN
           PLANR = PLANOR

c          write(6,*) ' calling useplan rev:',numthwant,planr
	   CALL FFTW3_USEPLAN(BUF, NSAM,NROW,NSLICE, 
     &                           SPIDER_SIGN, SPIDER_SCALE, 
     &                           PLANR,INV,IRTFLG)
        ENDIF
        IRTFLG = 0

d285 1
a285 1
        IF (.INV .LT. 0 .AND. .NOT. SPIDER_SIGN) THEN
d306 1
a306 1
           CALL FMRS_2R(X,LDA,NSAM,NROW,INV)
d316 1
a316 1
             CALL FFTMCF(X,WORK,N,N,N,INV)
d318 1
a318 1
             IF (MOD(N,2) LE. 0)  THEN
d320 2
a321 2
                   X(I)   = X((I+1)/2)
                   X(I+1) = WORK((I+1)/2)
d323 2
a324 2
                X(2)   = 0.0
                X(N+2) = 0.0
d327 2
a328 2
                   X(I)   = X(I/2+1)
                   X(I+1) = WORK(I/2+1)
d331 1
a331 1
                X(2)= 0.0
d337 1
a337 1
                WORK(I)     = X(2*I)/N
d344 1
a344 1
                X(I) = X(2*I-1)/N
d347 1
a347 1
                X(I) = X(N-I+2)
d350 1
a350 1
             CALL FFTMCF(X,WORK,N,N,N,INV)
d355 1
a355 1
       IF (.INV .GT. 0 .AND. .NOT. SPIDER_SIGN) THEN
d378 1
@

