head	1.70;
access;
symbols
	pre_getangas:1.57
	pre_GPL2010:1.53
	pre_var_equation:1.52
	pre_fftwrings:1.48
	pre_opfiles:1.44
	src:1.44
	best-code:1.42
	x-named-regs:1.42
	x:1.42
	v13-00:1.42
	pre_GPL:1.41
	prec_CA:1.35
	noindx:1.31
	Bproc:1.23
	oct21:1.13
	last77:1.11;
locks; strict;
comment	@c @;


1.70
date	2015.10.07.15.20.16;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2014.02.12.15.33.10;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2014.02.12.13.43.03;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.27.16.24.50;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2014.01.12.19.50.38;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2013.02.20.17.20.17;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2013.02.15.19.50.30;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2013.01.04.15.15.47;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2012.08.27.16.28.34;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2012.01.04.15.35.51;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2012.01.03.19.29.42;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2011.12.29.17.42.07;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2011.03.28.15.53.32;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.12.18.51.07;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2011.01.10.16.32.00;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2011.01.04.19.54.40;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2011.01.03.16.22.00;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2009.10.01.11.14.58;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2009.02.12.13.10.39;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2008.12.22.13.40.14;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2008.10.17.12.50.18;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2008.05.19.12.02.51;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.24.17.42.42;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.24.04.43.17;	author cyang;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.09.18.36.55;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.25.16.35.22;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.20.16.34.47;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.17.16.01.34;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.17.16.56.07;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.22.14.28.32;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.19.14.16.20;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2004.10.13.16.34.56;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2004.09.30.16.37.37;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.10.14.15.26;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.16.15.39.19;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.29.17.57.39;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.16.15.32.22;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.23.20.50.20;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.19.15.56.04;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.28.21.26.22;	author pawel;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.10.18.41.49;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.30.18.40.34;	author pawel;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.23.23.43.55;	author pawel;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.16.20.09.36;	author pawel;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.15.21.34.48;	author pawel;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.07.20.58.45;	author pawel;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.07.19.37.41;	author pawel;	state Exp;
branches;
next	1.23;

1.23
date	2000.02.09.21.43.31;	author bimal;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.08.20.54.25;	author bimal;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.08.20.47.46;	author bimal;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.08.20.35.41;	author bimal;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.08.20.17.55;	author bimal;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.11.17.03.48;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.11.16.57.27;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	99.12.21.22.39.56;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	99.11.10.18.46.30;	author pawel;	state Exp;
branches;
next	1.14;

1.14
date	99.11.10.17.03.07;	author pawel;	state Exp;
branches;
next	1.13;

1.13
date	99.06.07.19.09.13;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	99.06.03.20.51.01;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	99.03.18.21.00.27;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	98.12.10.17.00.29;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	98.12.03.20.36.39;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	98.12.03.17.05.51;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	98.12.02.19.54.42;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	98.12.01.19.06.49;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	98.11.30.19.19.40;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	98.11.30.17.28.14;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	98.11.24.13.24.08;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	98.10.22.15.40.21;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.10.22.15.13.10;	author pawel;	state Exp;
branches;
next	;


desc
@BP 3F
@


1.70
log
@NILMAXT = -1   ! NEEDED SO IT DOES NOT ASK FOR LIST in merging volumes
@
text
@
C++*********************************************************************
C
C  BP3F.F                                          MAY 02 P.A. Penczek
C              REPLACED BESSEL FUNCTIONS           MAY 02 P.A. Penczek
C              OPFILEC                             FEB 03 ArDean Leith
C              BUILDM PARAMETERS                   JUL 03 ArDean Leith
C              BUILDM PARAMETERS                   SEP 03 ArDean Leith
C              ALLOCATION ERROR HANDLING           OCT 04 ArDean Leith
C              OMP PRIVATE XX                      NOV 04 ArDean Leith
C              MPI DECONSTRUCTED FROM BP32D        NOV 06 ArDean Leith 
C              REWRITE                             DEC 06 ArDean Leith
C              FILLBESSIL                          DEC 08 ArDean Leith
C              CLOSE LUNIN                         SEP 09 ArDean Leith
C              OPFILES PARAMETERS                  DEC 10 ArDean Leith
C              PREVIOUSLY NAMED WIW2D**            JAN 11 ArDean Leith
C              ROT2QS --> RTSQ RENAMED             DEC 11 ArDean Leith
C              RTSF SUPPORT                        JAN 12 ArDean Leith
C              NSAM --> NX, RTSQ PARAM.            JAN 12 ArDean Leith
C              ILIST ALLOC                         JAN 13 ArDean Leith
C              HALT ADDED                          FEB 13 ArDean Leith
C              NILMAXT NEEDED = NOT ASK FOR LIST   OCT 15 ArDean Leith
C
C=**********************************************************************
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright (C)2002,2015 P. A. Penczek & ArDean Leith                *
C=* University of Texas - Houston Medical School                       *
C=* Email:  pawel.a.penczek@@uth.tmc.edu                                *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C=**********************************************************************
C
C   BP3F(CALLRTSQ,HALT)
C
C   PURPOSE:  FOR: 'BP 3F' IMPROVED WITH LESS MEMORY REQUIRED AND
C             MORE STACK USAGE. WITH CALLRTSQ CAN OUTPUT THE
C             ROTATED/SHIFTED FILES USED FOR THE BACKPROJECTION
C             FOR: 'RB 3F' ALSO
C
C  OPERATION: 'BP 3F'
C  BP3F  ---->  BUILDM1  
C    |          BUILDS  
C    |          BP3FQ  -->  FMRS_PLAN
C    |                      PADD2
C    |                      FMRS_2
C    |                      ONELINE
C    |                      SYMPLANE0
C    |                      NRMW2 
C    |                      WINDKB2A 
C    v  MPI
C    | 
C  BP3F_MPI --> BUILDM1  
C                BUILDS  
C                BP3FQ_MPI  --> BUILDM1
C                    |          FMRS_2
C                    |          ONELINE
C                    |          SYMPLANE0
C                    |          NRMW2 
C                    |          WINDKB2 
C                   COP 
C
CC     
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE BP3F(CALLRTSQ,HALT)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

        LOGICAL               :: CALLRTSQ,HALT

C       DOC FILE POINTERS
        REAL, POINTER         :: ANGBUF(:,:), ANGSYM(:,:)

        REAL,    ALLOCATABLE  :: DM(:,:),SM(:,:)
        REAL,    ALLOCATABLE  :: W(:,:,:)
        COMPLEX, ALLOCATABLE  :: X(:,:,:)
        REAL,    ALLOCATABLE  :: TEMP(:)
        REAL,    ALLOCATABLE  :: ROTANG(:),SHX(:),SHY(:)
        INTEGER, ALLOCATABLE  :: ILIST(:)

        LOGICAL               :: ANGINDOC,WANTVOL
        CHARACTER(LEN=MAXNAM) :: FILPAT,VOLNAM,VOLWGH
        CHARACTER(LEN=MAXNAM) :: ANGDOC

        INTEGER, PARAMETER    :: LUNIN   = 16
        INTEGER, PARAMETER    :: LUNVOL  = 17
        INTEGER, PARAMETER    :: LUNVOLV = 18
        INTEGER, PARAMETER    :: LUNVOLW = 19
        INTEGER, PARAMETER    :: LUNROTT = 20
        INTEGER, PARAMETER    :: LUNDOC  = 80
        INTEGER, PARAMETER    :: LUNXM1  = 0  ! UNUSABLE NEED #s
        INTEGER, PARAMETER    :: LUNXM2  = 82

#ifdef USE_MPI
C       KLUDGE TO OVERCOME BUG REPORTED BY L. ALAMO, NOV 2006
        CALL BP3F_MPI()
        RETURN
#else
        MYPID = -1
#endif

        NILMAX = NIMAXPLUS
        ALLOCATE(ILIST(NILMAX),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'BP32F; ILIST....',NILMAX)
           RETURN
        ENDIF 

C       OPEN INPUT IMAGE FILES 
        CALL OPFILES(0,LUNIN,LUNDOC,LUNXM1, 
     &             .TRUE.,FILPAT,NLET, 'O',
     &             ITYPE,NX,NY,NZ,MAXIM1,
     &             'IMAGE FILE NAME OR TEMPLATE (E.G. STK@@****)~~',
     &             .FALSE., ILIST,NILMAX, 
     &             NDUM,NANG,IMGNUM, IRTFLG) 
        IF (IRTFLG .NE. 0) GOTO 999

        IF (NX .NE. NY) THEN
           CALL ERRT(101,'ONLY WORKS ON SQUARE IMAGES',NDUM)
           GOTO 999
        ENDIF

        MAXNUM = MAXVAL(ILIST(1:NANG))
         
C       NANG - TOTAL NUMBER OF IMAGES
        IF (MYPID .LE. 0) WRITE(NOUT,2001) NANG
2001    FORMAT('  NUMBER OF IMAGES: ',I7,I7)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
C       PSI, THE, PHI, REF#, EXP#, INPLANE, SX, SY  
        MAXXT = 8 + 1
        MAXYT = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,LUNDOC,.FALSE.,MAXXT,
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        !write(6,*)'gotdocdat:MAXXT,MAXYT,MAXNUM',MAXXT,MAXYT,MAXNUM

C
C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 4
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,LUNDOC,
     &                 .TRUE.,MAXXS, MAXSYM,ANGSYM,IRTFLG)
        IF (IRTFLG .NE. 0) MAXSYM = 1

        N2      = 2 * NX
        LSD     = N2 + 2 - MOD(N2,2)
        NMAT    = LSD * N2 * N2
        NDIMSYM = MAX(1,MAXSYM)

        ALLOCATE(DM(9,MAXNUM), 
     &           SM(9,NDIMSYM), 
     &           W(0:NX,N2,N2), 
     &           X(0:NX,N2,N2), STAT=IRTFLG)

        IF (IRTFLG .NE. 0) THEN 
           MWANT = 9*MAXNUM + 9*NDIMSYM + 3*(NX+1)*N2*N2 
           CALL ERRT(46,'BP3F, DM..', MWANT)
           GOTO 999
        ENDIF

C       GET ANGLES FROM DOCUMENT FILE AND PLACE IN DM
        CALL BUILDM1(ILIST,NANG, DM,ANGBUF,9,MAXNUM, IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        IF (.NOT. CALLRTSQ) DEALLOCATE(ANGBUF)
 
        IF (MAXSYM > 1)  THEN
C          HAVE SYMMETRIES, CONSTRUCT SM ANGLES ARRAY
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
        ENDIF

        IF (HALT) THEN
C          OPEN THE NEW FOURIER VOLUME AND REAL WEIGHTS FILES

           IFORM  = 3
           MAXIM  = 0
           NXP1   = NX + 1
           NXP1T2 = 2  * NXP1

           !write(6,*) 'nx,n2,nxp1,nxp1t2:',nx,n2,nxp1,nxp1t2

           CALL OPFILEC(0,.TRUE.,VOLNAM,LUNVOLV,'U',IFORM,NXP1T2,N2,N2,
     &                  MAXIM,'PARTIAL VOLUME',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

           LENAT   = INDEX(VOLNAM,'@@')
           IF (LENAT > 1) THEN
              VOLWGH = VOLNAM(1:LENAT-1) // '_W' // VOLNAM(LENAT:NLET)
           ELSE              
              VOLWGH = VOLNAM(1:NLET) // '_W' 
           ENDIF

C          OPEN WEIGHTS VOLUMES 
           IFORM  = 3
           MAXIM  = 0
           !write(6,*) 'volwgh:',volwgh(1:22)
           CALL OPFILEC(0,.FALSE.,VOLWGH,LUNVOLW,'U',IFORM,NXP1,N2,N2,
     &                  MAXIM,'PARTIAL WEIGHT',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
            
        ELSE

C          OPEN REGULAR OUTPUT VOLUME
           IFORM = 3
           CALL OPFILEC(0,.TRUE.,VOLNAM,LUNVOL,'U',IFORM,NX,NX,NX,
     &               MAXIM,'RECONSTRUCTED VOLUME',.FALSE.,IRTFLG)
           WANTVOL = (IRTFLG == 0) 
        ENDIF

C       BACK PROJECTION
        CALL BP3FQ(NX,X,W,LSD,N2, CALLRTSQ,FILPAT,ANGBUF,
     &        ILIST,NANG, DM,IMGNUM,SM,MAXSYM, 
     &        LUNIN,LUNROTT,LUNDOC,LUNXM1,LUNXM2,
     &        MAXIM1,HALT, MAXNUM,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        IF (HALT) THEN
C          SAVE THE FOURIER VOLUME AND REAL WEIGHTS TO FILES

           !X(0:NX,N2,N2)
           CALL WRTVOL(LUNVOLV,NXP1T2,N2, 1,N2, X,IRTFLG)
           CLOSE(LUNVOLV)

           !W(0:NX,N2,N2) 
           CALL WRTVOL(LUNVOLW,NXP1,N2, 1,N2, W,IRTFLG)
           CLOSE(LUNVOLW)

           IF (.NOT. WANTVOL) GOTO 999   ! FINISHED
        ENDIF


C       ADDITIONAL SYMMETRIZATION OF THE VOLUME IN REAL SPACE 05/03/02
	IF (MAXSYM > 1)  THEN
           ALLOCATE(TEMP(NX*NX*NX), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN 
              CALL ERRT(46,'BP 3F, TEMP',NX*NX*NX)
              GOTO 999
           ENDIF

	   CALL COP(X,TEMP, NX*NX*NX)  ! JUST COPIES X INTO: TEMP

c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,NX
                    X(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO

           IF (MOD(NX,2) == 0)  THEN
              KNX = NX/2-1
           ELSE
              KNX = NX/2
           ENDIF
           KLX = -NX/2

           CALL SYMVOL(TEMP,X,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
           DEALLOCATE(TEMP)
        ENDIF


C       NOTE: NX=NY=NZ 
        CALL WRTVOL(LUNVOL,NX,NX, 1,NX, X,IRTFLG)

999     CLOSE(LUNVOL)
        CLOSE(LUNIN)

        IF (ALLOCATED(DM)) DEALLOCATE(DM)
        IF (ALLOCATED(SM)) DEALLOCATE(SM)
        IF (ALLOCATED(X))  DEALLOCATE(X)
        IF (ALLOCATED(W))  DEALLOCATE(W)

        END

 
C       ------------------ BP3FQ ---------------------------------

        SUBROUTINE BP3FQ(NX,X,W,LSD,N2, CALLRTSQ,FILPAT,ANGBUF,
     &                   INUMBRT,NANG, DM,IMGNUM,SM,MAXSYM,
     &                   LUNIN,LUNROTT,LUNDOC,LUNXM1,LUNXM2,
     &                   MAXIM1,HALT,MAXNUM,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        INTEGER                  :: NX,LSD,N2
        COMPLEX                  :: X(0:NX, N2,N2)
        REAL                     :: W(0:NX, N2,N2)
        LOGICAL                  :: CALLRTSQ
        REAL                     :: ANGBUF(9,MAXNUM)
        INTEGER                  :: NANG,IMGNUM,MAXSYM
        REAL                     :: DM(3,3,MAXNUM)
        REAL                     :: SM(3,3,MAXSYM)
        INTEGER                  :: LUNIN,LUNROTT,LUNDOC,LUNXM1,LUNXM2
        INTEGER                  :: MAXIM1
        LOGICAL                  :: HALT
        INTEGER                  :: IRTFLG

        REAL                     :: DMS(3,3)

        CHARACTER(LEN=*)         :: FILPAT

        INTEGER                  :: INUMBRT(NANG)
        REAL,    ALLOCATABLE     :: PROJ(:,:),PROJTEMP(:,:)
        COMPLEX, ALLOCATABLE     :: BI(:,:)
        CHARACTER (LEN=MAXNAM)   :: FILPATOUT,DOCNAM
        INTEGER, ALLOCATABLE     :: INUMBROUT(:)

        LOGICAL                  :: ANGINDOC
        INTEGER                  :: NXLD

        DOUBLE PRECISION         :: PI

C       COMMON: /TABS/ IS USED IN ONELINE, EXTRACTLINE, PUTLINE3, ETC
        INTEGER, PARAMETER          :: LTAB=4999
        COMMON  /TABS/ LN2,FLTB,TABI(0:LTAB)

        MYPID = -1                ! NOT MPI

C       GENERALIZED KAISER-BESSEL WINDOW ACCORDING TO LEWITT
        CALL FILLBESSIL(N2,LN2,LTAB,FLTB,TABI,ALPHA,AAAA,NNN)

        NSIZE  = 1
        LUNROT = 0    ! IF ZERO --> NO RTSQ OUTPUT WANTED
        NXLD   = NX

        IF (CALLRTSQ) THEN
           IF ( USE_FBS_INTERP) NXLD = NX + 2 - MOD(NX,2)

C          READ IMAGE AND ROTATE, SCALE & SHIFT INTO: PROJ
           NSIZE = NX
           ALLOCATE(INUMBROUT(NANG), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'INUMBROUT', NANG)
              GOTO 9999
           ENDIF

C          OPEN OUTPUT IMAGE(S) FOR RTSQ/RTSF 
           ITYPE = 1
           CALL OPFILES(LUNIN,LUNROTT,LUNDOC,LUNXM2, 
     &            .TRUE., FILPATOUT,NLETO,'U',
     &            ITYPE,NX,NX,1, MAXIM2,
     &            'TRANSFORMED OUTPUT IMAGES TEMPLATE (E.G. ROT@@****)~',
     &            .FALSE., INUMBROUT,NANG, 
     &            NDUM,NANGT, IMGNUMOUT, IRTFLG) 

C          IF IRTFLG IS NEGATIVE THEN NO RTSQ OUTPUT WANTED
           IF (IRTFLG == 0) LUNROT = LUNROTT
           IF (IRTFLG > 0) GOTO 9999
        ENDIF

        ALLOCATE(PROJ(NX,NX), 
     &           PROJTEMP(NXLD,NSIZE),
     &           BI(0:NX,N2), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           NEEDED = NX*NX + NXLD*NSIZE + 2*(NX+1)*N2*N2 +
     &             (NX+1)*N2
           CALL ERRT(46,'BP3F, PROJ...',NEEDED)
           RETURN
        ENDIF

C       CREATE FFTW3 PLAN FOR 2D FFT ON BI USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,BI,N2,N2,1, 0,+1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
c$omp   parallel do private(i,j,k)
        DO K=1,N2
           DO J=1,N2
              DO I=0,NX
                 X(I,J,K) = CMPLX(0.0,0.0)
                 W(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

#ifdef  SP_MP
C	LN1 = LN + 1           ! WHY?? LN ALWAYS EQUALS: 5
	LN1 = 6                ! WHY?? LN ALWAYS EQUALS: 5
#endif

        NWANT1 = 1
        NWANT2 = 1
        DO 
c          write(6,*)  'Projection #: ',IMGNUM

           IF (CALLRTSQ) THEN
C             READ IMAGE INTO: PROJTEMP (X PADDED IF FBS)
              CALL READV(LUNIN,PROJTEMP,NXLD,NX, NX,NX,1)

C             Reg. numbers for angle & shift =(6,7,8)
  
              IF (USE_FBS_INTERP) THEN
C                ROTATE & SHIFT FROM: PROJTEMP  INTO: PROJ
	         CALL RTSF(PROJTEMP,PROJ, 
     &                     NXLD,NX,NX,
     &                     ANGBUF(7,IMGNUM), 1.0,
     &                     ANGBUF(8,IMGNUM),ANGBUF(9,IMGNUM),IRTFLG)

              ELSE
C                ROTATE & SHIFT FROM:PROJTEMP  INTO: PROJ
	         CALL RTSQ(PROJTEMP,PROJ, 
     &                     NX,NX, NX,NX,
     &                     ANGBUF(7,IMGNUM), 1.0,
     &                     ANGBUF(8,IMGNUM),ANGBUF(9,IMGNUM),IRTFLG)
              ENDIF

              IF (LUNROT > 0) THEN
                 CALL WRTVOL(LUNROT, NX,NX,1,1, PROJ,IRTFLG)
                 CLOSE(LUNROT)
              ENDIF

              IF (VERBOSE) WRITE(NOUT,90)IMGNUM,
     &                                   ANGBUF(7,IMGNUM),
     &                                   ANGBUF(8,IMGNUM),
     &                                   ANGBUF(9,IMGNUM)
90            FORMAT('  IMAGE: ',I6,
     &               '  ANGLE: ',G10.3,
     &               '  SHIFT: (',G10.3,',',G10.3,')')

           ELSE
C             READ IMAGE INTO: PROJ
              CALL REDVOL(LUNIN,NX,NX, 1,1, PROJ,IRTFLG)
           ENDIF


C          PAD: PROJ TO SIZE: N2
           CALL PADD2(PROJ,NX,BI,LSD,N2)

C          FOURIER TRANSFORM OF: BI
           INV = +1
           CALL FMRS_2(BI,N2,N2,INV)  

c$omp      parallel do private(i,j)
           DO J=1,N2
              DO I=0,NX
                 BI(I,J) = BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO ISYM=1,MAXSYM
             IF (MAXSYM > 1)  THEN
C               SYMMETRIES, MULTIPLY MATRICES
                DMS = MATMUL(SM(:,:,ISYM),DM(:,:,IMGNUM))
             ELSE
                DMS = DM(:,:,IMGNUM)
             ENDIF

#ifdef SP_MP
	     DO JT=1,LN1
c$omp           parallel do private(j)
                DO J=-NX+JT,NX,LN1
                   CALL ONELINE(J,N2,NX,X,W,BI,DMS)
                ENDDO
             ENDDO
#else
             DO J=-NX+1,NX
               CALL ONELINE(J,N2,NX,X,W,BI,DMS)
             ENDDO
#endif
           ENDDO                          ! END OF SYMMETRIES LOOP

           IF (NWANT1 >= NANG) EXIT      ! END OF LIST

C          OPEN NEXT SET OF I/O FILES 
           CALL NEXTFILES(NWANT1, NWANT2, INUMBRT,INUMBROUT, 
     &                     .FALSE.,LUNXM1,LUNXM2,
     &                     NANG,NANGT,  
     &                     MAXIM1,MAXIM2,   
     &                     LUNIN,LUNIN,LUNROT, FILPAT,FILPATOUT,
     &                     IMGNUM,IMGNUMOUT,IRTFLG) 
           IF (IRTFLG .LT. 0) EXIT         ! END OF INPUT STACK
           IF (IRTFLG .NE. 0) GOTO 9999    ! ERROR
        ENDDO                              ! END OF PROJECTIONS LOOP 

C       SYMMETRIZE PLANE 0
        CALL SYMPLANE0(X,W,NX,N2)

        IF ( .NOT. HALT) THEN
C          WEIGHT AND FOURIER TRANSFORM
           CALL NRMW2(X,W,NX,N2)

C          WINDOW
           CALL WINDKB2A(X,X,NX,LSD,N2,ALPHA,AAAA,NNN)
        ENDIF

        IRTFLG = 0

9999    IF (ALLOCATED(PROJ)) DEALLOCATE(PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE(BI)

        CLOSE(LUNIN)
        CLOSE(LUNROTT)
        CLOSE(LUNXM2)

        END













C       ------------------ BP3F_MERGE ------------------------------

        SUBROUTINE BP3F_MERGE()

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'
C       FROM CMBLOCK.INC --> INTEGER,DIMENSION(NIMAX) :: INUMBR

C       DOC FILE POINTERS
        REAL, POINTER         :: ANGBUF(:,:), ANGSYM(:,:)

        REAL,    ALLOCATABLE  :: SM(:,:)
        COMPLEX, ALLOCATABLE  :: X(:,:,:),XOUT(:,:,:)
        REAL,    ALLOCATABLE  :: W(:,:,:),WOUT(:,:,:)

        CHARACTER(LEN=MAXNAM) :: ANGDOC
        CHARACTER(LEN=MAXNAM) :: FILPATV,FILPATW,VOLNAM,FILNAMW

        INTEGER, PARAMETER    :: LUNINV  = 16
        INTEGER, PARAMETER    :: LUNINW  = 17
        INTEGER, PARAMETER    :: LUNVOL  = 18
        INTEGER, PARAMETER    :: LUNWAT  = 19
        INTEGER, PARAMETER    :: LUNDOC  = 80
        INTEGER, PARAMETER    :: LUNXMV  = 0  ! UNUSABLE NEED #s
        INTEGER, PARAMETER    :: LUNXMW  = 0  ! UNUSABLE NEED #s

        INTEGER, PARAMETER    :: LTAB=4999
        REAL                  :: TABI(0:LTAB)
        INTEGER               :: LN2,NNN
        REAL                  :: FLTB,ALPHA,AAAA

C       OPEN FIRST INPUT VOLUME FILE 
        NILMAX = NIMAX
        CALL OPFILES(0,LUNINV,LUNDOC,LUNXMV, 
     &             .TRUE.,FILPATV,NLET, 'O',
     &             ITYPEV,NXV,NYV,NZV,MAXIMV,
     &             'PARTIAL VOLUME FILES TEMPLATE (E.G. BPSTK@@****)~~',
     &             .FALSE., INUMBR,NILMAX, 
     &             NDUM,NVOLV,IMGNUM, IRTFLG) 
        IF (IRTFLG .NE. 0) GOTO 999

        IF (MYPID <= 0) WRITE(NOUT,2001) NVOLV
2001    FORMAT('  NUMBER OF VOLUMES: ',I7,I7)


        LENAT   = INDEX(FILPATV,'@@')
        LENSTAR = INDEX(FILPATV,'*')
        IF (LENAT > 1) THEN
           FILPATW = FILPATV(1:LENAT-1) // '_W' // FILPATV(LENAT:NLET)
        ELSEIF (LENSTAR > 1) THEN             
           FILPATW = FILPATV(1:LENAST-1) // '_W'//FILPATV(LENAST:NLET)
        ELSE
           CALL ERRT(101,'INVALID TEMPLATE',NDUM)
           GOTO 999
        ENDIF

C       OPEN FIRST INPUT WEIGHT FILE 
        FILNAMW = FILPATW
        NILMAXT = -1   ! NEEDED SO IT DOES NOT ASK FOR LIST
        CALL OPFILES(0,LUNINW,LUNDOC,LUNXMW, 
     &             .FALSE.,FILPATW,NLETW, 'O',
     &             ITYPEW,NXW,NYW,NZW,MAXIMW,
     &             FILNAMW,
     &             .TRUE., INUMBR,NILMAXT, 
     &             IDUM,NVOLW,IMGNUMW, IRTFLG) 
        IF (IRTFLG .NE. 0) GOTO 999

        CALL SIZCHK(UNUSED,0,NYV,NZV,0,
     &                     0,NYW,NZW,0,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        NXP1T2 = NXV
        N2     = NYV  
        NY     = N2 / 2 
        NX     = NY
        NVOLW  = NVOLV
        MAXNUM = MAXVAL(INUMBR(1:NVOLV))
        NMAT   = NXV * NYV * NZV 
        LSD    = N2 + 2 - MOD(N2,2)

        !write(6,*)' maxsym:',maxsym,lsd,nmat,ndimsym

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 4
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,LUNDOC,
     &                 .TRUE.,MAXXS, MAXSYM,ANGSYM,IRTFLG)

        IF (IRTFLG .NE. 0) MAXSYM = 1
        NDIMSYM = MAX(1,MAXSYM)

        ALLOCATE(SM(9,NDIMSYM), 
     &           W(0:NX,N2,N2), WOUT(0:NX,N2,N2),
     &           X(0:NX,N2,N2), XOUT(0:NX,N2,N2),
     &          STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           MWANT = 9*MAXNUM + 6*(NX+1)*N2*N2
           CALL ERRT(46,'BP3F_MERGE, SM..', MWANT)
           GOTO 999
        ENDIF
 
        IF (MAXSYM > 1)  THEN
C          HAVE SYMMETRIES, CONSTRUCT SM ANGLES ARRAY FROM ANGDOC
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
        ENDIF

C       OPEN OUTPUT VOLUME
        IFORM = 3
        CALL OPFILEC(LUNINV,.TRUE.,VOLNAM,LUNVOL,'U',IFORM,NX,NX,NX,
     &                  MAXIM,'RECONSTRUCTED VOLUME',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        

        NWANTV = 1
        NWANTW = 1
        DO 
           !write(6,*)  ' Volume #: ',IMGNUM,nwantv,nvol

C          LOAD VOLUME INTO: X
           CALL REDVOL(LUNINV,NXV,NYV, 1,NZV, X,IRTFLG)

C          LOAD WEIGHTS INTO: W
           CALL REDVOL(LUNINW,NXW,NYW, 1,NZW, W,IRTFLG)

C          ADD VOLUMES & WEIGHTS, PLACE IN XOUT AND WOUT
           CALL ADDADA(XOUT,X, NMAT)
           CALL ADDADA(WOUT,W, NMAT/2)

           !write(6,*)  ' Added: ',NXV,nyv,nxw,nyw,nmat

           IF (NWANTV >= NVOLV) EXIT      ! END OF LIST

C          OPEN NEXT INPUT VOLUME FILE
           CALL NEXTFILE(NWANTV,  INUMBR, 
     &                  .TRUE.,   LUNXMV,
     &                   NVOLV,   MAXIMV,   
     &                   LUNINV,  0, 
     &                   FILPATV, 'O',
     &                   IMGNUMV, IRTFLG) 
           IF (IRTFLG < 0)    EXIT        ! END OF INPUT STACK
           IF (IRTFLG .NE. 0) GOTO 999    ! ERROR

C          OPEN NEXT INPUT WEIGHT FILE
           CALL NEXTFILE(NWANTW,   INUMBR, 
     &                   .TRUE.,   LUNXMW,
     &                   NVOLW,    MAXIMW,   
     &                   LUNINW,   0, 
     &                   FILPATW,  'O',
     &                   IMGNUMW,  IRTFLG) 
           IF (IRTFLG < 0) THEN   ! END OF INPUT STACK
              CALL ERRT(101,'INSUFFICIENT WEIGHT VOLUMES', NE)
              GOTO 999    ! ERROR
           ENDIF
           IF (IRTFLG .NE. 0) GOTO 999    ! ERROR
        ENDDO                             ! END OF PROJECTIONS LOOP 


C       WEIGHT:XOUT  USING: WOUT & THEN INVERSE FOURIER TRANSFORM IT
        CALL NRMW2(XOUT,WOUT,NX,N2)

        !write(6,*)  'called nrmw2: NX,N2',NX,N2

C       GENERALIZED KAISER-BESSEL WINDOW ACCORDING TO LEWITT
        CALL FILLBESSIL(N2,LN2,LTAB,FLTB,TABI,ALPHA,AAAA,NNN)

C       WINDOWS FROM 2X PADDED NON-CENTERED SPACE TO REAL VOLUME
        CALL WINDKB2A(XOUT,XOUT,NX,LSD,N2, ALPHA,AAAA,NNN)

C       ADDITIONAL SYMMETRIZATION OF THE VOLUME IN REAL SPACE 
	IF (MAXSYM > 1)  THEN

           CALL COP(XOUT, X,NX*NX*NX)  ! COPIES: XOUT INTO: X

C          ZEROES XOUT
c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,NX
                    X(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO

           IF (MOD(NX,2) == 0)  THEN
              KNX = NX/2-1
           ELSE
              KNX = NX/2
           ENDIF
           KLX = -NX/2

C          INPUTS: X   OUTPUTS TO: XOUT
           CALL SYMVOL(X,XOUT,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)

        ENDIF

C       NOTE: NX=NY=NZ 
        CALL WRTVOL(LUNVOL,NX,NX, 1,NX, XOUT,IRTFLG)

999     CLOSE(LUNINV)
        CLOSE(LUNINW)
        CLOSE(LUNVOL)

        IF (ALLOCATED(SM))    DEALLOCATE(SM)
        IF (ALLOCATED(X))     DEALLOCATE(X)
        IF (ALLOCATED(W))     DEALLOCATE(W)
        IF (ALLOCATED(XOUT))  DEALLOCATE(XOUT)
        IF (ALLOCATED(WOUT))  DEALLOCATE(WOUT)

        END



	
C++*********************************************************************
C
C BP3F_MPI.F   DECONSTRUCTED FROM BP32D        NOV  06 ARDEAN LEITH
C                 ORIGINAL BP3F GAVE WRONG RESULTS
C                 WHEN USED UNDER MPI
C                 FFTW3 CORRECTIONS               SEP  08 ARDEAN LEITH
C **********************************************************************
C
C  BP3F_MPI
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE BP3F_MPI

C       NOTE: STUPID TRANSFORM OF N2-->N AND N2/2-->N2 !!!!al
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

C       DOC FILE POINTERS
        REAL, POINTER         :: ANGBUF(:,:), ANGSYM(:,:)

        REAL,    ALLOCATABLE  :: DM(:,:), SM(:,:) 
        COMPLEX, ALLOCATABLE  :: XE(:,:,:)
        REAL,    ALLOCATABLE  :: WE(:,:,:)
        INTEGER, ALLOCATABLE  :: ILIST(:)

        REAL,    ALLOCATABLE  :: TEMP(:)
        LOGICAL               :: ANGINDOC
        CHARACTER(LEN=1)      :: NULL = CHAR(0)
        CHARACTER(LEN=MAXNAM) :: ANGDOC
        CHARACTER(LEN=MAXNAM) :: FILPAT,FILNAM
        CHARACTER(LEN=MAXNAM) :: VOLNAM
 
        INTEGER, PARAMETER    :: LUNVOL   = 18
        INTEGER, PARAMETER    :: LUNIN   = 19
        INTEGER, PARAMETER    :: LUNDOC  = 77


#ifndef USE_MPI
        PRINT *, ' THIS ROUTINE for MPI ONLY'
        STOP
#else
        CALL SET_MPI(ICOMM,MYPID,MPIERR)  ! SETS ICOMM AND MYPID

        NILMAX = NIMAXPLUS
        ALLOCATE(ILIST(NILMAX),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'BP32F; ILIST....',NILMAX)
           RETURN
        ENDIF 

        CALL FILELIST(.TRUE.,LUNIN,FILPAT,NLET,ILIST,NILMAX,NANG,
     &                 'TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(LUNIN)     ! USED FOR SELECTION FILE??
        MAXNUM = MAXVAL(ILIST(1:NANG))

C       NANG - TOTAL NUMBER OF IMAGES
        IF (MYPID <= 0) WRITE(NOUT,2001) NANG
2001    FORMAT('  NUMBER OF IMAGES: ',I8)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        ANGINDOC = .TRUE.

C       PSI, THE, PHI, REF#, EXP#, INPLANE, SX, SY  
        MAXXT    = 8 + 1
        MAXYT    = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,LUNDOC,.FALSE.,MAXXT,
     &                 MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) ANGINDOC = .FALSE.

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 0
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,LUNDOC,
     &                 .TRUE.,MAXXS,MAXSYM,ANGSYM,IRTFLG)
        IF (IRTFLG .NE. 0)  MAXSYM = 1

C       OPEN FIRST IMAGE FILE TO DETERMINE NX, NY, NSL
        CALL FILGET(FILPAT,FILNAM,0,ILIST(1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',IFORM,NX,NY,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        IF (MYPID  .LE. 0) CLOSE(LUNIN)

        N2   = 2 * NX
        LSD  = N2 + 2 - MOD(N2,2)
        NMAT = LSD * N2 * N2

        IF (ANGINDOC) THEN
C          GET ANGLES FROM DOC. FILE 
           ALLOCATE(DM(9,MAXNUM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN
              MEMWANT = 9 * NANG
              CALL ERRT(46,'BP 3F, DM',MEMWANT)
              GOTO 9999
           ENDIF

           CALL BUILDM1(ILIST,NANG, DM,ANGBUF,9,MAXNUM,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        
           IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        ELSE
C          GET ANGLES FROM IMAGE FILE HEADER 
           ALLOCATE(DM(9,1), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'BP 3F, DM',IER)
              GOTO 9999
           ENDIF
        ENDIF

        IF (MAXSYM .GT. 1)  THEN
C          HAVE SYMMETRIES 
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              MEMWANT = 9 * MAXSYM
              CALL ERRT(46,'BP 3F, SM',MEMWANT)
              GOTO 9999
           ENDIF
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)

       ELSE
           ALLOCATE(SM(1,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
               CALL ERRT(46,'BP 3F, SM(1,1)',IER)
               GOTO 9999
           ENDIF
        ENDIF

        ALLOCATE(XE(0:NX,N2,N2),
     &           WE(0:NX,N2,N2), STAT=IRTFLG)

        IF (IRTFLG.NE.0) THEN 
C           X ARRAYS ARE COMPLEX SO 3 NOT 2
            MEMWANT = 3 * ((NX)+1) * N2 * N2
            CALL ERRT(46,'BP 3F; XE & WE ',MEMWANT)
            GOTO 9999
        ENDIF

        CALL BP3FQ_MPI(NX,XE,WE,LSD,N2, FILPAT,FILNAM,LUNIN,
     &                  ILIST,NANG, DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999

C       NOW XE IS READY, SYMMETRIZE IF NECESSARY
C       ADDITIONAL SYMMETRIZATION OF THE VOLUME XE IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
           ALLOCATE (TEMP(NX*NX*NX), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              MEMWANT = NX * NX * NX 
              CALL ERRT(46,'BP 3F, TEMP',MEMWANT)
              GOTO 9999
           ENDIF

C          COPY XE to TEMP
	   CALL COP(XE,TEMP,NX*NX*NX)

c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,NX
                    XE(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO

           IF (MOD(NX,2) .EQ. 0)  THEN
              KNX = NX/2-1
           ELSE
              KNX = NX/2
           ENDIF
           KLX = -NX/2
	   CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	ENDIF

C       OPEN OUTPUT VOLUME
        IFORM = 3
        CALL OPFILEC(0,.TRUE.,VOLNAM,LUNVOL,'U',IFORM,NX,NX,NX,
     &                  MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       NOTE: NX=NY=NZ 
        CALL WRTVOL(LUNVOL,NX,NX, 1,NX, XE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (MYPID .LE. 0) CLOSE(LUNIN)
        IF (MYPID .LE. 0) CLOSE(LUNVOL)

9999    IF (ALLOCATED(DM))      DEALLOCATE(DM)
        IF (ALLOCATED(SM))      DEALLOCATE(SM)
        IF (ALLOCATED(XE))      DEALLOCATE(XE)
        IF (ALLOCATED(WE))      DEALLOCATE(WE)
        IF (ALLOCATED(TEMP))    DEALLOCATE(TEMP)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)
#endif
 
        END

C       ---------------- BP3FQ_MPI -------------------------------------

        SUBROUTINE BP3FQ_MPI(NX,XE,WE,LSD,N2, 
     &                 FILPAT,FILNAM,LUNIN, 
     &                 INUMBRT,NGOT,DM, NANG,SM,MAXSYM,ANGINDOC,IRTFLG)

        INCLUDE 'CMLIMIT.INC'

        LOGICAL               :: ANGINDOC
        REAL,  ALLOCATABLE    :: PROJ(:,:)
        COMPLEX, ALLOCATABLE  :: BI(:,:)
        REAL                  :: ANGBUF(4)
        REAL                  :: WE(0:NX,N2,N2)
        COMPLEX               :: XE(0:NX,N2,N2)
        INTEGER               :: INUMBRT(NANG)
        REAL                  :: DM(3,3,NANG)
        REAL                  :: SM(3,3,MAXSYM)
        REAL                  :: DMS(3,3)

        CHARACTER(LEN=*)      :: FILPAT,FILNAM

        REAL   , ALLOCATABLE  :: PRJLOC(:,:,:)
        REAL   , ALLOCATABLE  :: PRJBUF(:,:,:)
        REAL   , ALLOCATABLE  :: WELOC(:,:,:)
        COMPLEX, ALLOCATABLE  :: XELOC(:,:,:)
        INTEGER, ALLOCATABLE  :: PSIZE(:), NBASE(:)

        LOGICAL, PARAMETER    :: SPIDER_SIGN  = .TRUE.
        LOGICAL, PARAMETER    :: SPIDER_SCALE = .TRUE.
 
C       COMMON: /TABS/ IS USED IN ONELINE, EXTRACTLINE, PUTLINE3, ETC
        INTEGER, PARAMETER    :: LTAB = 499
        COMMON  /TABS/ LN2,FLTB,TABI(0:LTAB)

C       THIS MPI VERSION IS MEMORY INTENSIVE.
C       2-D IMAGES ARE READ INTO MEMORY AND DISTRIBUTED.
C       EACH PROCESSOR WILL HOLD ROUGHLY NANG/NPROC  2-D IMAGES. 

#ifndef USE_MPI
        MYPID = -1
        PRINT *, ' THIS ROUTINE FOR MPI COMPILATION AND USE ONLY'
        STOP
#else
        INCLUDE 'mpif.h'
        INTEGER          :: ISTAT(MPI_STATUS_SIZE)
                          
        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
        CALL MPI_COMM_SIZE(ICOMM, NPROCS, MPIERR)

C       GENERALIZED KAISER-BESSEL WINDOW ACCORDING TO LEWITT
        CALL FILLBESSIL(N2,LN2,LTAB,FLTB,TABI,ALPHA,AAAA,NNN)

        DO K=1,N2
           DO J=1,N2
              DO I=0,NX
                 XE(I,J,K) = CMPLX(0.0,0.0)
                 WE(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

        ALLOCATE(PROJ(NX,NX),
     &           BI(0:NX,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           MEMWANT = NX*NX + (NX + 1) * N2  
           CALL ERRT(46,'BP 3F, PROJ, ...',MEMWANT)
           RETURN
        ENDIF

C       DISTRIBUTE PARTICLES TO PROCESSORS.
C       NANGLOC IS THE NUMBER OF PARTICLES ASSIGNED TO EACH PROCESSOR.

        ALLOCATE(PSIZE(NPROCS),
     &           NBASE(NPROCS), 
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = 2 * NPROCS 
           CALL ERRT(46,'BP 3F, PSIZE, NBASE...',MEMWANT)
           RETURN
        ENDIF

C       SETPART RETURNS SIZE OF LOCAL PIECE AND THE GLOBAL OFFSET.

        CALL SETPART(NANG, PSIZE, NBASE)
        NANGLOC = PSIZE(MYPID+1)

C       2-D IMAGES ARE DISTRIBUTED AND HELD IN PRJLOC ON EACH PROCESSOR

        ALLOCATE(PRJBUF(NX,NX,PSIZE(1)),
     &           PRJLOC(NX,NX,NANGLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = NX*NX*PSIZE(1) + NX*NX*NANGLOC
           CALL ERRT(46,'BP 3F, PRJBUF, PRJLOC',MEMWANT)
           RETURN
        ENDIF

C       PROCESSOR 0 READS IMAGE FILES AND DISTRIBUTE THEM.
C       (THIS VERSION ASSUMES THAT THERE IS SUFFICIENT
C        MEMORY TO HOLD NANG/NPROCS IMAGES)

        DO IPROC = 1, NPROCS
           NANGLOC = PSIZE(IPROC)

C          READ IMAGES INTO THE BUFFER FIRST, THEN DISTRIBUTE

           DO JLOC = 1, NANGLOC
              JGLB = NBASE(IPROC) + JLOC
              CALL FILGET(FILPAT,FILNAM,0,INUMBRT(JGLB),IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
              MAXIM = 0
              CALL OPFILEC(0      ,.FALSE., FILNAM, LUNIN, 'O'  ,
     &                     IFORM  , NX  , NX  , NSL   , MAXIM,
     &                     'DUMMY',.FALSE., IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
              CALL READV1P(LUNIN,PRJBUF(1,1,JLOC),
     &                     NX,NX,NX,NX,1)
            ENDDO

           IF (IPROC .GT. 1) THEN
               IF  (MYPID .EQ. 0) THEN
C                 SEND TO ANOTHER PROCESSOR
                  CALL MPI_SEND(PRJBUF , NX*NX*NANGLOC, MPI_REAL,
     &                          IPROC-1, IPROC-1      , ICOMM    ,
     &                          MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) ' BP32DQ: SEND ERROR!'
                     STOP
                  ENDIF
               ELSEIF (MYPID .EQ. IPROC-1) THEN
C                 RECEIVE PROJECTION IMAGES FROM PROCESSOR 0
                  CALL MPI_RECV(PRJLOC, NX*NX*NANGLOC, MPI_REAL,
     &                          0     , MPI_ANY_TAG  , ICOMM    ,
     &                          ISTAT , MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) ' BP32DQ: RECV FAILED'
                     STOP
                  ENDIF
              ENDIF  
           ELSEIF (MYPID .EQ. 0) THEN
C             KEEP FOR MYSELF
              DO JLOC = 1, NANGLOC
                 DO ISAM = 1, NX
                     DO JROW = 1, NX
                        PRJLOC(ISAM,JROW,JLOC) = PRJBUF(ISAM,JROW,JLOC)
                     ENDDO
                  ENDDO
               ENDDO
           ENDIF
        ENDDO
        IF (ALLOCATED(PRJBUF)) DEALLOCATE(PRJBUF)

        IF (.NOT. ANGINDOC) THEN
C           GET ANGLES FROM HEADER
            ANGBUF(1) = INUMBRT(K)
            CALL LUNGETVALS(LUNIN,IAPLOC+1,3,ANGBUF(2),IRTFLG)

            CALL BUILDM1(INUMBRT,1, DM,ANGBUF,4,1,IRTFLG)
            IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
        CLOSE(LUNIN)

C       PERFORM CALCULATIONS IN PARALLEL NOW

C       CREATE FFTW3 PLAN FOR THIS PROCESSOR
        INV       = +1            ! FORWARD FFT
        NUMTHWANT = 1             ! MAY RETURN THIS

C       CREATE FFTW3 PLAN FOR 2D FFT ON BI USING ONE THREAD
        CALL FMRS_PLAN(.TRUE.,BI, N2,N2,1, NUMTHWANT,INV,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        ALLOCATE (WELOC(0:NX,N2,N2), 
     &            XELOC(0:NX,N2,N2), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = 2 * (NX+1)*N2*N2 
           CALL ERRT(46,'BP 3F, WELOC, XELOC',MEMWANT)
           GOTO 9999
        ENDIF

        DO K=1,N2
           DO J=1,N2
              DO I=0,NX
                 XELOC(I,J,K) = CMPLX(0.0,0.0)
                 WELOC(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

        NANGLOC = PSIZE(MYPID+1)
        DO JLOC = 1, NANGLOC
           JGLB = NBASE(MYPID+1) + JLOC

C          PAD: PRJLOC TO SIZE: N2
           CALL PADD2(PRJLOC(1,1,JLOC),NX,BI,LSD,N2)

C          FOURIER TRANSFOR OF: BI
           CALL FMRS_2(BI,N2,N2,INV)

           DO J=1,N2
              DO I=0,NX
                 BI(I,J) = BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO ISYM=1,MAXSYM
              IF (MAXSYM .GT. 1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS = MATMUL(SM(:,:,ISYM),DM(:,:,JGLB))
              ELSE
                 DMS = DM(:,:,JGLB)
              ENDIF

              DO J=-NX+1,NX
                 CALL ONELINE(J,N2,NX,XELOC,WELOC,BI,DMS)
              ENDDO
           ENDDO
        ENDDO

C       SUM UP X & W FROM LOCAL PIECES (XLOC, WLOC) RESIDING ON EACH PROCESSOR

        DO K3 = 1, N2
           CALL MPI_ALLREDUCE(XELOC(0,1,K3), XE(0,1,K3), (NX+1)*N2, 
     &                        MPI_COMPLEX  , MPI_SUM   , ICOMM    ,
     &                        MPIERR)
           IF (MPIERR. NE. 0) THEN
              WRITE(6,*) ' BP32DQ: FAILED TO ALLREDUCE XELOC'
              STOP
           ENDIF

           CALL MPI_ALLREDUCE(WELOC(0,1,K3), WE(0,1,K3), (NX+1)*N2, 
     &                        MPI_REAL     , MPI_SUM   , ICOMM    ,
     &                        MPIERR)
           IF (MPIERR. NE. 0) THEN
              WRITE(6,*) ' BP32DQ: FAILED TO ALLREDUCE WELOC'
              STOP
           ENDIF
        ENDDO 

C       SYMMETRIZE VOLUME
        CALL SYMPLANE0(XE,WE,NX,N2)

C       WEIGHT AND INVERSE FOURIER TRANSFORM
        CALL NRMW2(XE,WE,NX,N2)

C       WINDOW
        CALL WINDKB2A(XE,XE,NX,LSD,N2,ALPHA,AAAA,NNN)



9999    IF (ALLOCATED(PRJLOC)) DEALLOCATE(PRJLOC)
        IF (ALLOCATED(XELOC))  DEALLOCATE(XELOC)
        IF (ALLOCATED(WELOC))  DEALLOCATE(WELOC)
        IF (ALLOCATED(PROJ))   DEALLOCATE(PROJ)
        IF (ALLOCATED(BI))     DEALLOCATE(BI)
#endif

        END





C++*********************************************************************
C
C  BUILDM1.F        MERGED WITH REANG                JUL 03 ARDEAN LEITH
C                   BYLIST ADDED                     SEP 03 ARDEAN LEITH
C                   BYLIST FILLSS,SS REMOVED         FEB 13 ARDEAN LEITH
C **********************************************************************
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright (C) 1985-2013  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C **********************************************************************
C
C  BUILDM1(ILIST,DM,NANG, ANGBUF,MAXX,MAXY, IRTFLG)
C
C  PURPOSE: BULID ROTATION MATRICES FROM THREE EULERIAN ANGLES
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE BUILDM1(ILIST,NANG, DM,ANGBUF,MAXX,MAXY, IRTFLG)

        INCLUDE 'CMBLOCK.INC' 

        INTEGER :: ILIST(NANG)
        INTEGER :: NANG
        REAL    :: DM(9,MAXY), ANGBUF(MAXX,MAXY)
        INTEGER :: MAXX,MAXY
        INTEGER :: IRTFLG

        INTEGER :: ICOMM,MYPID,MPIERR,K,ITMP,ICOUNT,J
        REAL    :: SSDUM

        LOGICAL, PARAMETER :: FILLSS = .FALSE.


        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

C       READ ANGLES FROM THE DOCUMENT FILE.
C       ORDER IN THE DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES 
C       ARE IN DEGREES! IN ANG ARRAY IT IS OTHER WAY AROUND
C       OUTPUT IS COMPACTED TO 1...NANG LINES (NOT BY SELECTOR)

        DO K=1,NANG

C          GET ANGLE SELECTOR INDEX FROM ILIST
           ITMP   = ILIST(K)

           !write(6,*) 'nang,k,itmp,maxy:',nang,k,itmp,maxy

           ICOUNT = ANGBUF(1,ITMP)
           IF (ICOUNT <= 0) THEN
C             MISSING KEY
              CALL ERRT(102,'MISSING ANGLE FOR IMAGE',ITMP)
              IRTFLG = 1
              RETURN
           ENDIF

           CALL CANG(ANGBUF(4,ITMP),ANGBUF(3,ITMP),ANGBUF(2,ITMP),
     &               FILLSS,SSDUM,DM(1,ITMP))

           IF (MYPID <= 0 .AND. VERBOSE) THEN
              WRITE(NOUT,333) K,(ANGBUF(J,ITMP),J=2,4)
333           FORMAT('  PROJECTION #',I7,
     &               '  PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
           ENDIF
         ENDDO

        IRTFLG = 0

        END


C       ------------------- PADD2 -------------------------------

        SUBROUTINE PADD2(PROJ,L,BI,LSD,N)

C       PADS: PROJ OF SIZE: L  INTO: BI  WITH SIZE: N

        REAL             :: PROJ(L,L),BI(LSD,N)

        DOUBLE PRECISION :: QS
        DOUBLE PRECISION :: DKLP

        KLP = 0
        R   = L/2
        QS  = 0.0D0

C       ESTIMATE AVERAGE OUTSIDE THE CIRCLE
        CALL ASTA_D(PROJ,L,R,QS,DKLP)

        QS = QS / REAL(DKLP)

C       ZEROS ALL OF: BI
c$omp   parallel do private(i,j)
        DO J=1,N
           DO I=1,N
              BI(I,J) = 0.0
           ENDDO
        ENDDO

C       FOR L ODD ADD ONE.  N IS ALWAYS EVEN
        IP = (N-L) / 2 + MOD(L,2)

c$omp   parallel do private(i,j)
        DO J=1,L
           DO I=1,L
              BI(IP+I,IP+J) = PROJ(I,J) - QS
           ENDDO
        ENDDO

        END

C       ------------------- NRMW2 -------------------------------

        SUBROUTINE NRMW2(R,W,N2,N)

        COMPLEX :: R(0:N2,N,N)
        REAL    :: W(0:N2,N,N)
        INTEGER :: N2,N

        INTEGER :: I,J,K,INV

c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=0,N2
                IF (W(I,J,K) > 0.1)  THEN
		   R(I,J,K) = R(I,J,K) * (-1)**(I+J+K)/W(I,J,K)
		ELSE
		   R(I,J,K) = (0.0,0.0)
		ENDIF
              ENDDO
           ENDDO
        ENDDO

        INV = -1
        CALL FMRS_3(R,N,N,N,INV) 

        END

	





	
@


1.69
log
@if PART do not want to open output volume
@
text
@d22 1
d27 1
a27 1
C=* Copyright (C)2002,2014 P. A. Penczek & ArDean Leith                *
d588 1
d593 1
a593 1
     &             .TRUE., INUMBR,NILMAX, 
@


1.68
log
@removed debug output line
@
text
@d219 1
a219 1
        ENDIF
d221 3
a223 3
C       OPEN REGULAR OUTPUT VOLUME
        IFORM = 3
        CALL OPFILEC(0,.TRUE.,VOLNAM,LUNVOL,'U',IFORM,NX,NX,NX,
d225 2
a226 1
        WANTVOL = (IRTFLG == 0) 
@


1.67
log
@prompt
@
text
@a695 3
      write(6,*)  'called windkb2a: nx,lsd,n2,nnn', nx,lsd,n2,nnn


@


1.66
log
@enter
@
text
@d26 1
a26 1
C=* Copyright (C)2002,2013 P. A. Penczek & ArDean Leith                *
d224 1
a224 1
     &               MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
@


1.65
log
@OPEN REGULAR OUTPUT VOLUME even if halt capability
@
text
@d799 1
a799 1
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
@


1.64
log
@bp 3f merge & part ,  also cosmetic
@
text
@d96 1
a96 1
        LOGICAL               :: ANGINDOC
d161 1
a161 1
        IF (IRTFLG.NE.0) MAXSYM = 1
d218 2
d221 5
a225 8
        ELSE

C          OPEN REGULAR OUTPUT VOLUME
           IFORM = 3
           CALL OPFILEC(0,.TRUE.,VOLNAM,LUNVOL,'U',IFORM,NX,NX,NX,
     &                  MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
        ENDIF
d245 1
a245 1
           GOTO 999   ! FINISHED
@


1.63
log
@DKLP replaces KLP for more pixels
ILIST with NIMAXPLUS for more images
@
text
@d4 1
a4 1
C  BP3F_DL.F                                       MAY 02 P.A. Penczek
d14 1
a14 1
C              CLOSE INPIC                         SEP 09 ArDean Leith
d21 1
d45 1
a45 1
C   BP3F_DL(CALLRTSQ)
d47 1
a47 1
C   PURPOSE:  FOR: 'BPD 3F' IMPROVED WITH LESS MEMORY REQUIRED AND
d53 9
a61 10
C  BP3F_DL  ---->  BUILDM1  
C    |             BUILDS  
C    |             BP3FQ_DL  -->  FMRS_PLAN
C    |                            ROT2WS_DL
C    |                            PADD2
C    |                            FMRS_2
C    |                            ONELINE
C    |                            SYMPLANE0
C    |                            NRMW2 
C    |                            WINDKB2A 
d64 9
a72 9
C  BP3F_MPI_DL  -->  BUILDM1  
C                    BUILDS  
C                    BP3FQ_MPI_DL  --> BUILDM1
C                     |           FMRS_2
C                     |           ONELINE
C                     |           SYMPLANE0
C                     |           NRMW2 
C                     |           WINDKB2 
C                    COP 
d74 1
a74 11
C
C  OPERATION: 'BP 3F OLD'
C  BP3F  ---->  BUILDM  
C               BUILDS  
C               BP3FQ  -->  PADD2
C                           FMRS_2
C                           ONELINE
C                           SYMPLANE0
C                           NRMW2 
C                           WINDKB2 
C     
d78 1
a78 1
        SUBROUTINE BP3F_DL(CALLRTSQ)
d84 2
d90 1
d96 2
a97 2
        LOGICAL               :: ANGINDOC,CALLRTSQ
        CHARACTER(LEN=MAXNAM) :: FILPAT,VOLNAM
d100 4
a103 2
        INTEGER, PARAMETER    :: INPIC   = 18
        INTEGER, PARAMETER    :: IOPIC   = 19
d111 1
a111 1
        CALL BP3F_MPI_DL()
d121 1
a121 1
           CALL ERRT(46,'BP32F_DL; ILIST....',NILMAX)
d126 1
a126 1
        CALL OPFILES(0,INPIC,LUNDOC,LUNXM1, 
d153 3
d160 1
a160 1
     7                 .TRUE.,MAXXS, MAXSYM,ANGSYM,IRTFLG)
d170 1
d172 4
a175 3
        IF (IRTFLG.NE.0) THEN 
           MWANT = 9*MAXNUM + 9*NDIMSYM + (NX+1)*N2*N2
           CALL ERRT(46,'BP 3F, DM..', MWANT)
d180 1
a180 2
        CALL BUILDM1(ILIST,DM,9,NANG,ANGBUF,.FALSE.,SSDUM,
     &              .TRUE.,IRTFLG)
d184 1
a184 1
        IF (MAXSYM .GT. 1)  THEN
d190 40
a229 1
        CALL BP3FQ_DL(NX,X,LSD,N2, CALLRTSQ,FILPAT,ANGBUF,
d231 2
a232 1
     &        INPIC,LUNROTT,LUNDOC,LUNXM1,LUNXM2,MAXIM1,IRTFLG)
d234 15
a248 1
C       write(6,*) ' 0  x(75,75,75):', x(75,75,75)
d251 1
a251 1
	IF (MAXSYM .GT. 1)  THEN
d253 1
a253 1
           IF (IRTFLG.NE.0) THEN 
d258 1
a258 1
	   CALL COP(X,TEMP, NX*NX*NX)
d269 1
a269 1
           IF (MOD(NX,2) .EQ. 0)  THEN
d276 3
a278 3
	   CALL SYMVOL(TEMP,X,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	   DEALLOCATE(TEMP)
	ENDIF
a279 5
C       OPEN OUTPUT VOLUME
        IFORM = 3
        CALL OPFILEC(0,.TRUE.,VOLNAM,IOPIC,'U',IFORM,NX,NX,NX,
     &                  MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
d282 1
a282 1
        CALL WRTVOL(IOPIC,NX,NX, 1,NX, X,IRTFLG)
d284 2
a285 2
999     CLOSE(IOPIC)
        CLOSE(INPIC)
d290 1
d294 2
d297 4
a300 6
C       ------------------ BP3FQ_DL ---------------------------------

        SUBROUTINE BP3FQ_DL(NX,X,LSD,N2, CALLRTSQ,FILPAT,ANGBUF,
     &                    INUMBRT,NANG, DM,IMGNUM,SM,MAXSYM,
     &                    INPIC,LUNROTT,LUNDOC,
     &                    LUNXM1,LUNXM2,MAXIM1,IRTFLG)
d305 22
a326 14
        REAL                        :: DM(3,3,NANG)
        REAL                        :: SM(3,3,MAXSYM)
        REAL                        :: DMS(3,3)

        COMPLEX                     :: X(0:NX, N2,N2)
        CHARACTER(LEN=*)            :: FILPAT

        REAL                        :: ANGBUF(9,NANG)
        INTEGER                     :: INUMBRT(NANG)
        REAL,    ALLOCATABLE        :: PROJ(:,:),PROJTEMP(:,:)
        REAL,    ALLOCATABLE        :: W(:,:,:)
        COMPLEX, ALLOCATABLE        :: BI(:,:)
        CHARACTER (LEN=MAXNAM)      :: FILPATOUT,DOCNAM
        INTEGER, ALLOCATABLE        :: INUMBROUT(:)
d328 2
a329 2
        LOGICAL                     :: ANGINDOC,CALLRTSQ
        INTEGER                     :: NXLD
d331 1
a331 1
        DOUBLE PRECISION            :: PI
d359 1
a359 1
           CALL OPFILES(INPIC,LUNROTT,LUNDOC,LUNXM2, 
d367 2
a368 2
           IF (IRTFLG .EQ. 0) LUNROT = LUNROTT
           IF (IRTFLG .GT. 0) GOTO 9999
a372 1
     &           W(0:NX,N2,N2), 
d377 1
a377 1
           CALL ERRT(46,'BP 3F, PROJ...',NEEDED)
d407 1
a407 1
              CALL READV(INPIC,PROJTEMP,NXLD,NX, NX,NX,1)
d441 1
a441 1
              CALL REDVOL(INPIC,NX,NX, 1,1, PROJ,IRTFLG)
d444 1
d460 1
a460 1
             IF (MAXSYM .GT. 1)  THEN
d481 1
a481 1
           IF (NWANT1 .GE. NANG) EXIT      ! END OF LIST
d488 1
a488 1
     &                     INPIC,INPIC,LUNROT, FILPAT,FILPATOUT,
d497 3
a499 2
C       WEIGHT AND FOURIER TRANSFORM
        CALL NRMW2(X,W,NX,N2)
d501 3
a503 2
C       WINDOW
        CALL WINDKB2A(X,X,NX,LSD,N2,ALPHA,AAAA,NNN)
d507 2
a508 3
9999    IF (ALLOCATED(W))    DEALLOCATE (W)
        IF (ALLOCATED(PROJ)) DEALLOCATE (PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE (BI)
d510 1
a510 1
        CLOSE(INPIC)
d516 228
d747 1
a747 1
C BP3F_MPI_DL.F   DECONSTRUCTED FROM BP32D        NOV  06 ARDEAN LEITH
d753 1
a753 1
C  BP3F_MPI_DL
d758 1
a758 1
        SUBROUTINE BP3F_MPI_DL
d780 2
a781 2
        INTEGER, PARAMETER    :: IOPIC   = 18
        INTEGER, PARAMETER    :: INPIC   = 19
d795 1
a795 1
           CALL ERRT(46,'BP32F_DL; ILIST....',NILMAX)
d799 1
a799 1
        CALL FILELIST(.TRUE.,INPIC,FILPAT,NLET,ILIST,NILMAX,NANG,
d802 1
a802 1
        CLOSE(INPIC)     ! USED FOR SELECTION FILE??
d831 1
a831 1
        CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,NX,NY,NSL,
d834 1
a834 1
        IF (MYPID .LE. 0) CLOSE(INPIC)
d849 1
a849 2
           CALL BUILDM1(ILIST,DM,9,NANG,ANGBUF,.FALSE.,SSDUM,
     &                 .TRUE.,IRTFLG)
d891 1
a891 1
        CALL BP3FQ_MPI_DL(NX,XE,WE,LSD,N2, FILPAT,FILNAM,INPIC,
d928 1
a928 1
        CALL OPFILEC(0,.TRUE.,VOLNAM,IOPIC,'U',IFORM,NX,NX,NX,
d933 1
a933 1
        CALL WRTVOL(IOPIC,NX,NX, 1,NX, XE,IRTFLG)
d936 2
a937 2
        IF (MYPID .LE. 0) CLOSE(INPIC)
        IF (MYPID .LE. 0) CLOSE(IOPIC)
d950 1
a950 1
C       ---------------- BP3FQ_MPI_DL -------------------------------------
d952 2
a953 2
        SUBROUTINE BP3FQ_MPI_DL(NX,XE,WE,LSD,N2, 
     &                 FILPAT,FILNAM,INPIC, 
d1062 1
a1062 1
              CALL OPFILEC(0      ,.FALSE., FILNAM, INPIC, 'O'  ,
d1066 1
a1066 1
              CALL READV1P(INPIC,PRJBUF(1,1,JLOC),
d1106 3
a1108 3
            CALL LUNGETVALS(INPIC,IAPLOC+1,3,ANGBUF(2),IRTFLG)
            CALL BUILDM1(INUMBRT,DM,4,1,ANGBUF,.FALSE.,SSDUM,
     &                  .TRUE.,IRTFLG)
d1111 1
a1111 1
        CLOSE(INPIC)
d1218 1
d1220 3
a1222 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d1246 1
a1246 1
C  BUILDM1(ILIST,DM,IX,NANG,ANGBUF,FILLSS,SS,BYLIST,IRTFLG)
d1253 1
a1253 2
        SUBROUTINE BUILDM1(ILIST,DM,IX,NANG,ANGBUF,FILLSS,
     &                     SS,BYLIST,IRTFLG)
a1256 1
        REAL    :: DM(9,NANG),ANGBUF(IX,NANG),SS(6,NANG)
d1258 10
a1267 1
        LOGICAL :: FILLSS,BYLIST
d1281 2
d1284 1
a1284 1
           IF (ICOUNT .LE. 0) THEN
a1290 3
           KT = K
           IF (BYLIST) KT = ITMP

d1292 1
a1292 1
     &               FILLSS,SS(1,KT),DM(1,KT))
d1294 2
a1295 2
           IF (VERBOSE) THEN
              IF (MYPID .LE. 0)WRITE(NOUT,333)K,(ANGBUF(J,ITMP),J=2,4)
d1302 1
d1350 5
a1354 2
        DIMENSION  W(0:N2,N,N)
        COMPLEX    R(0:N2,N,N)
d1360 1
a1360 1
                IF (W(I,J,K) .GT. 0.1)  THEN
@


1.62
log
@FORMAT(' IMAGE  and ;
@
text
@d20 1
d23 3
a25 2
C=* From: SPIDER - MODULAR IMAGE PROCESSING SYSTEM                     *
C=* Copyright (C)2002,2012 P. A. Penczek & ArDean Leith                *
d101 1
d121 8
a128 1
        NILMAX = NIMAX
d135 1
a135 1
     &             .FALSE., INUMBR,NILMAX, 
d144 1
a144 1
        MAXNUM = MAXVAL(INUMBR(1:NANG))
d180 1
a180 1
        CALL BUILDM1(INUMBR,DM,9,NANG,ANGBUF,.FALSE.,SSDUM,
d192 1
a192 1
     &        INUMBR,NANG, DM,IMGNUM,SM,MAXSYM, 
d462 3
a464 3
C                  ORIGINAL BP3F GAVE WRONG RESULTS
C                  WHEN USED UNDER MPI
C                  FFTW3 CORRECTIONS                SEP  08 ARDEAN LEITH
d485 1
d489 1
a489 1
        CHARACTER(LEN=1)      :: NULL
d505 7
a511 2
        NULL   = CHAR(0)
        NILMAX = NIMAX
d513 1
a513 1
        CALL FILELIST(.TRUE.,INPIC,FILPAT,NLET,INUMBR,NILMAX,NANG,
d517 1
a517 1
        MAXNUM = MAXVAL(INUMBR(1:NANG))
d520 2
a521 2
        IF (MYPID .LE. 0) WRITE(NOUT,2001) NANG
2001    FORMAT('  NUMBER OF IMAGES: ',I7)
d541 1
a541 1
        CALL FILGET(FILPAT,FILNAM,0,INUMBR(1),IRTFLG)
d563 1
a563 1
           CALL BUILDM1(INUMBR,DM,9,NANG,ANGBUF,.FALSE.,SSDUM,
d607 1
a607 1
     &                  INUMBR,NANG, DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
d1018 4
a1021 2
        DIMENSION  PROJ(L,L),BI(LSD,N)
        DOUBLE     PRECISION QS
d1028 3
a1030 2
        CALL ASTA(PROJ,L,R,QS,KLP)
        QS = QS/REAL(KLP)
d1041 1
a1041 1
        IP = (N-L)/2+MOD(L,2)
@


1.61
log
@NSAM --> NX, RTSQ PARAM.
@
text
@d369 1
a369 1
90            FORMAT(' IMAGE: ',I6,
d988 1
a988 1
     &               '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
@


1.60
log
@nsam --> nx,    fbs support with rtsf call
@
text
@d18 2
a19 1
C              RTSF SUPPORT                        Jan 11 ArDean Leith
d262 1
d277 2
d280 2
d305 1
a305 1
     &           PROJTEMP(NX,NSIZE),
d309 1
a309 1
           NEEDED = NX*NX + NX*NSIZE + 2*(NX+1)*N2*N2 +
d340 2
a341 12
C             READ IMAGE AND ROTATE, SCALE & SHIFT INTO: PROJ
              CALL REDVOL(INPIC,NX,NX, 1,1,PROJTEMP,IRTFLG)

              IF (VERBOSE) WRITE(NOUT,90)IMGNUM,
     &                                   ANGBUF(7,IMGNUM),
     &                                   ANGBUF(8,IMGNUM),
     &                                   ANGBUF(9,IMGNUM)
90            FORMAT(' IMAGE: ',I6,
     &               '  ANGLE: ',G10.3,
     &               '  SHIFT: (',G10.3,',',G10.3,')')

C             Reg. numbers for angle, scale,& shift =(6,0,7,8)  
d343 2
d346 1
a346 1
                 NXLD = NX + 2 - MOD(NX,2)  ! PAD FOR FFTW
d353 5
a357 4
C                IRECOFF = 0, LUNOUT = 0 (not used)
	         CALL RTSQ(PROJTEMP,PROJ, NX,NX,
     &                    ANGBUF(7,IMGNUM),1.0,
     &                    ANGBUF(8,IMGNUM),ANGBUF(9,IMGNUM),0,0)
d359 3
a361 2
              IF (LUNROT .GT. 0) THEN
                 CALL WRTVOL(LUNROT,NX,NX,1,1, PROJ,IRTFLG)
d364 9
@


1.59
log
@ROT2QS --> RTSQ
@
text
@d4 15
a18 14
C  BP3F_DL.F                                       MAY  02 P.A. Penczek
C              REPLACED BESSEL FUNCTIONS           MAY  02 P.A. Penczek
C              OPFILEC                             FEB  03 ArDean Leith
C              BUILDM PARAMETERS                   JUL  03 ArDean Leith
C              BUILDM PARAMETERS                   SEP  03 ArDean Leith
C              ALLOCATION ERROR HANDLING           OCT  04 ArDean Leith
C              OMP PRIVATE XX                      NOV  04 ArDean Leith
C              MPI DECONSTRUCTED FROM BP32D        NOV  06 ArDean Leith 
C              REWRITE                             DEC  06 ArDean Leith
C              FILLBESSIL                          DEC  08 ArDean Leith
C              CLOSE INPIC                         SEP  09 ArDean Leith
C              OPFILES PARAMETERS                  DEC  10 ArDean Leith
C              PREVIOUSLY NAMED WIW2D**            JAN  11 ArDean Leith
C              ROT2QS --> RTSQ RENAMED             DEC  11 ArDean Leith
d22 1
a22 1
C=* Copyright (C)2002,2011 P. A. Penczek & ArDean Leith                *
d122 1
a122 1
     &             ITYPE,NSAM,NROW,NSLICE,MAXIM1,
d128 1
a128 1
        IF (NSAM .NE. NROW) THEN
d154 1
a154 1
        N2      = 2 * NSAM
d161 1
a161 1
     &           X(0:NSAM,N2,N2), STAT=IRTFLG)
d163 1
a163 1
           MWANT = 9*MAXNUM + 9*NDIMSYM + (NSAM+1)*N2*N2
d180 1
a180 1
        CALL BP3FQ_DL(NSAM,X,LSD,N2, CALLRTSQ,FILPAT,ANGBUF,
d188 1
a188 1
           ALLOCATE(TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
d190 1
a190 1
              CALL ERRT(46,'BP 3F, TEMP',NSAM*NSAM*NSAM)
d194 2
a195 1
	   CALL COP(X,TEMP, NSAM*NSAM*NSAM)
d199 1
a199 1
                 DO I=0,NSAM
d205 2
a206 2
           IF (MOD(NSAM,2) .EQ. 0)  THEN
              KNX = NSAM/2-1
d208 1
a208 1
              KNX = NSAM/2
d210 1
a210 1
           KLX = -NSAM/2
d218 1
a218 1
        CALL OPFILEC(0,.TRUE.,VOLNAM,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d222 2
a223 2
C       NOTE: NSAM=NROW=NSLICE 
        CALL WRTVOL(IOPIC,NSAM,NSAM, 1,NSAM, X,IRTFLG)
d234 1
d237 1
a237 1
        SUBROUTINE BP3FQ_DL(NSAM,X,LSD,N2, CALLRTSQ,FILPAT,ANGBUF,
d249 1
a249 1
        COMPLEX                     :: X(0:NSAM, N2,N2)
d277 1
a277 1
           NSIZE = NSAM
d284 1
a284 1
C          OPEN OUTPUT IMAGE(S) FOR RTSQ 
d288 1
a288 1
     &            ITYPE,NSAM,NSAM,1, MAXIM2,
d298 4
a301 4
        ALLOCATE(PROJ(NSAM,NSAM), 
     &           PROJTEMP(NSAM,NSIZE),
     &           W(0:NSAM,N2,N2), 
     &           BI(0:NSAM,N2), STAT=IRTFLG)
d303 2
a304 2
           NEEDED = NSAM*NSAM + NSAM*NSIZE + 2*(NSAM+1)*N2*N2 +
     &             (NSAM+1)*N2
d316 1
a316 1
              DO I=0,NSAM
d335 1
a335 1
              CALL REDVOL(INPIC,NSAM,NSAM, 1,1,PROJTEMP,IRTFLG)
d345 12
a356 2
C             Reg. numbers for angle, scale,& shift =(6,0,7,8)   
	      CALL RTSQ(PROJTEMP,PROJ, NSAM,NSAM,
d359 1
d361 1
a361 1
                 CALL WRTVOL(LUNROT,NSAM,NSAM,1,1, PROJ,IRTFLG)
d366 1
a366 1
              CALL REDVOL(INPIC,NSAM,NSAM, 1,1, PROJ,IRTFLG)
d370 1
a370 1
           CALL PADD2(PROJ,NSAM,BI,LSD,N2)
d378 1
a378 1
              DO I=0,NSAM
d394 2
a395 2
                DO J=-NSAM+JT,NSAM,LN1
                   CALL ONELINE(J,N2,NSAM,X,W,BI,DMS)
d399 2
a400 2
             DO J=-NSAM+1,NSAM
               CALL ONELINE(J,N2,NSAM,X,W,BI,DMS)
d419 1
a419 1
        CALL SYMPLANE0(X,W,NSAM,N2)
d422 1
a422 1
        CALL NRMW2(X,W,NSAM,N2)
d425 1
a425 1
        CALL WINDKB2A(X,X,NSAM,LSD,N2,ALPHA,AAAA,NNN)
d468 1
a468 1
        LOGICAL               :: ANGINDOC,CALLRTSQ
d515 1
a515 1
C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
d520 1
a520 1
        CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,NSAM,NROW,NSL,
d525 1
a525 1
        N2   = 2 * NSAM
d571 2
a572 2
        ALLOCATE(XE(0:NSAM,N2,N2),
     &           WE(0:NSAM,N2,N2), STAT=IRTFLG)
d576 1
a576 1
            MEMWANT = 3 * ((NSAM)+1) * N2 * N2
d581 1
a581 1
        CALL BP3FQ_MPI_DL(NSAM,XE,WE,LSD,N2, FILPAT,FILNAM,INPIC,
d588 1
a588 1
           ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
d590 1
a590 1
              MEMWANT = NSAM * NSAM * NSAM 
d596 1
a596 1
	   CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
d601 1
a601 1
                 DO I=0,NSAM
d607 2
a608 2
           IF (MOD(NSAM,2) .EQ. 0)  THEN
              KNX = NSAM/2-1
d610 1
a610 1
              KNX = NSAM/2
d612 1
a612 1
           KLX = -NSAM/2
d618 1
a618 1
        CALL OPFILEC(0,.TRUE.,VOLNAM,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d622 2
a623 2
C       NOTE: NSAM=NROW=NSLICE 
        CALL WRTVOL(IOPIC,NSAM,NSAM, 1,NSAM, XE,IRTFLG)
d642 1
a642 1
        SUBROUTINE BP3FQ_MPI_DL(NSAM,XE,WE,LSD,N2, 
d652 2
a653 2
        REAL                  :: WE(0:NSAM,N2,N2)
        COMPLEX               :: XE(0:NSAM,N2,N2)
d695 1
a695 1
              DO I=0,NSAM
d702 2
a703 2
        ALLOCATE(PROJ(NSAM,NSAM),
     &           BI(0:NSAM,N2), STAT=IRTFLG)
d705 1
a705 1
           MEMWANT = NSAM*NSAM + (NSAM + 1) * N2  
d729 2
a730 2
        ALLOCATE(PRJBUF(NSAM,NSAM,PSIZE(1)),
     &           PRJLOC(NSAM,NSAM,NANGLOC),
d733 1
a733 1
           MEMWANT = NSAM*NSAM*PSIZE(1) + NSAM*NSAM*NANGLOC
d753 1
a753 1
     &                     IFORM  , NSAM  , NSAM  , NSL   , MAXIM,
d757 1
a757 1
     &                     NSAM,NSAM,NSAM,NSAM,1)
d763 1
a763 1
                  CALL MPI_SEND(PRJBUF , NSAM*NSAM*NANGLOC, MPI_REAL,
d772 1
a772 1
                  CALL MPI_RECV(PRJLOC, NSAM*NSAM*NANGLOC, MPI_REAL,
d783 2
a784 2
                 DO ISAM = 1, NSAM
                     DO JROW = 1, NSAM
d813 2
a814 2
        ALLOCATE (WELOC(0:NSAM,N2,N2), 
     &            XELOC(0:NSAM,N2,N2), STAT=IRTFLG)
d816 1
a816 1
           MEMWANT = 2 * (NSAM+1)*N2*N2 
d823 1
a823 1
              DO I=0,NSAM
d835 1
a835 1
           CALL PADD2(PRJLOC(1,1,JLOC),NSAM,BI,LSD,N2)
d841 1
a841 1
              DO I=0,NSAM
d854 2
a855 2
              DO J=-NSAM+1,NSAM
                 CALL ONELINE(J,N2,NSAM,XELOC,WELOC,BI,DMS)
d863 1
a863 1
           CALL MPI_ALLREDUCE(XELOC(0,1,K3), XE(0,1,K3), (NSAM+1)*N2, 
d871 1
a871 1
           CALL MPI_ALLREDUCE(WELOC(0,1,K3), WE(0,1,K3), (NSAM+1)*N2, 
d881 1
a881 1
        CALL SYMPLANE0(XE,WE,NSAM,N2)
d884 1
a884 1
        CALL NRMW2(XE,WE,NSAM,N2)
d887 1
a887 1
        CALL WINDKB2A(XE,XE,NSAM,LSD,N2,ALPHA,AAAA,NNN)
@


1.58
log
@error trap for non-square images
@
text
@d4 8
a11 8
C  BP3F_DL.F                                                  05/03/02
C              REPLACED BESSEL FUNCTIONS
C              OPFILEC                             FEB  03 ARDEAN LEITH
C              BUILDM PARAMETERS                   JUL  03 ARDEAN LEITH
C              BUILDM PARAMETERS                   SEP  03 ARDEAN LEITH
C              ALLOCATION ERROR HANDLING           OCT  04 ARDEAN LEITH
C              OMP PRIVATE XX                      NOV  04 ARDEAN LEITH
C              MPI DECONSTRUCTED FROM BP32D        NOV  06 ARDEAN LEITH 
d17 1
d21 1
a21 1
C=* Copyright (C)2002,2011 P. A. Penczek & ArDean Leith                             *
d343 1
a343 1
	      CALL ROT2QS(PROJTEMP,PROJ, NSAM,NSAM,
@


1.57
log
@rot2qs_dl --> rot2qs
@
text
@d11 1
a11 1
C              MPI DECONSTRUCTED FROM BP32D       NOV  06 ARDEAN LEITH 
d16 2
a17 1
C              PREVIOUSLY NAMED WIW2D**          JAN   11 ArDean Leith
d20 1
a20 1
C=* Copyright (C)2002,2009 P. A. Penczek & ArDean Leith                             *
d125 5
@


1.56
log
@renamed from wiw3d.f
@
text
@d336 1
a336 1
	      CALL ROT2QS_DL(PROJTEMP,PROJ, NSAM,NSAM,
@


1.55
log
@FORMAT('  PROJECTION
@
text
@d4 1
a4 1
C  WIW3D_DL.F                                                  05/03/02
d11 1
a11 1
C              MPI DECONSTRUCTED FROM WIW32D       NOV  06 ARDEAN LEITH 
d16 1
d38 1
a38 1
C   WIW3D_DL(CALLRTSQ)
d46 1
a46 1
C  WIW3D_DL  ----> BUILDM1  
d48 1
a48 1
C    |             WIW3DQ_DL  --> FMRS_PLAN
d58 1
a58 1
C  WIW3D_MPI_DL  --> BUILDM1  
d60 1
a60 1
C                    WIW3DQ_MPI_DL  --> BUILDM1
d70 1
a70 1
C  WIW3D  ----> BUILDM  
d72 1
a72 1
C               WIW3DQ  --> PADD2
d82 1
a82 1
        SUBROUTINE WIW3D_DL(CALLRTSQ)
d109 1
a109 1
        CALL WIW3D_MPI_DL()
d172 1
a172 1
        CALL WIW3DQ_DL(NSAM,X,LSD,N2, CALLRTSQ,FILPAT,ANGBUF,
d225 1
a225 1
C       ------------------ WIW3DQ_DL ---------------------------------
d227 1
a227 1
        SUBROUTINE WIW3DQ_DL(NSAM,X,LSD,N2, CALLRTSQ,FILPAT,ANGBUF,
d421 2
a422 2
C WIW3D_MPI_DL.F   DECONSTRUCTED FROM WIW32D        NOV  06 ARDEAN LEITH
C                  ORIGINAL WIW3D GAVE WRONG RESULTS
d427 1
a427 1
C  WIW3D_MPI_DL
d432 1
a432 1
        SUBROUTINE WIW3D_MPI_DL
d560 1
a560 1
        CALL WIW3DQ_MPI_DL(NSAM,XE,WE,LSD,N2, FILPAT,FILNAM,INPIC,
d619 1
a619 1
C       ---------------- WIW3DQ_MPI_DL -------------------------------------
d621 1
a621 1
        SUBROUTINE WIW3DQ_MPI_DL(NSAM,XE,WE,LSD,N2, 
d746 1
a746 1
                     WRITE(6,*) ' WIW32DQ: SEND ERROR!'
d755 1
a755 1
                     WRITE(6,*) ' WIW32DQ: RECV FAILED'
d846 1
a846 1
              WRITE(6,*) ' WIW32DQ: FAILED TO ALLREDUCE XELOC'
d854 1
a854 1
              WRITE(6,*) ' WIW32DQ: FAILED TO ALLREDUCE WELOC'
@


1.54
log
@ opfiles parameters
@
text
@d115 1
a115 1
C       OPEN IMPUT IMAGE FILES 
d956 1
a956 1
333           FORMAT(' PROJECTION #',I7,
@


1.53
log
@*** empty log message ***
@
text
@d15 1
d40 3
a42 1
C             MORE STACK USAGE.
d88 1
a88 1
        REAL, DIMENSION(:,:), POINTER          :: ANGBUF, ANGSYM
d90 15
a104 10
        REAL,    ALLOCATABLE, DIMENSION(:,:)   :: DM,SM
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: X
        REAL,    ALLOCATABLE, DIMENSION(:)     :: TEMP
        REAL,    ALLOCATABLE, DIMENSION(:)     :: ROTANG,SHX,SHY

        LOGICAL                                :: ANGINDOC,CALLRTSQ
        CHARACTER(LEN=MAXNAM)                  :: FILPAT,VOLNAM
        CHARACTER(LEN=MAXNAM)                  :: ANGDOC

        DATA  INPIC/18/,IOPIC/19/,LUNROTT/20/,LUNDOC/80/
d115 7
a121 4
        CALL OPFILES(0,INPIC,LUNDOC, FILPAT,NLET, 'O',
     &             ITYPE,NSAM,NROW,NSLICE,MAXIM,
     &             'IMAGE FILE NAME OR TEMPLATE (E.G. STK@@****)~',
     &             .FALSE., INUMBR,NILMAX, NANG,IMGNUM, IRTFLG) 
d145 4
a148 3
        N2   = 2 * NSAM
        LSD  = N2 + 2 - MOD(N2,2)
        NMAT = LSD * N2 * N2
d150 3
a152 1
        ALLOCATE(DM(9,MAXNUM), STAT=IRTFLG)
d154 2
a155 1
           CALL ERRT(46,'BP 3F, DM', 9*NANG)
a163 8

        NDIMSYM = MAX(1,MAXSYM)
        ALLOCATE(SM(9,NDIMSYM), X(0:NSAM,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
            MWANT = 9*NDIMSYM + (NSAM+1)*N2*N2
            CALL ERRT(46,'BP 3F, SM & X',MWANT)
            GOTO 999
        ENDIF
d172 2
a173 2
     &        INUMBR,NANG, DM,IMGNUM,SM,MAXSYM,
     &        INPIC,LUNROTT,LUNDOC,IRTFLG)
d206 1
d228 2
a229 1
     &                    INPIC,LUNROTT,LUNDOC,IRTFLG)
d234 14
a247 14
        REAL                                   :: DM(3,3,NANG)
        REAL                                   :: SM(3,3,MAXSYM)
        REAL                                   :: DMS(3,3)

        COMPLEX                                :: X(0:NSAM, N2,N2)
        CHARACTER(LEN=*)                       :: FILPAT

        REAL, DIMENSION(9,NANG)                :: ANGBUF
        INTEGER, DIMENSION(NANG)               :: INUMBRT
        REAL,    ALLOCATABLE, DIMENSION(:,:)   :: PROJ,PROJTEMP
        REAL,    ALLOCATABLE, DIMENSION(:,:,:) :: W
        COMPLEX, ALLOCATABLE, DIMENSION(:,:)   :: BI
        CHARACTER (LEN=MAXNAM)                 :: FILPATOUT,DOCNAM
        INTEGER, ALLOCATABLE, DIMENSION(:)     :: INUMBROUT
d249 1
a249 1
        LOGICAL                                :: ANGINDOC,CALLRTSQ
d251 1
a251 1
        DOUBLE PRECISION                       :: PI
d254 1
a254 1
        INTEGER, PARAMETER                     :: LTAB=4999
d265 1
d273 1
a273 1
C          OPEN OUTPUT IMAGE(S) FOR RTSQ (IF ANY)
d275 3
a277 2
           CALL OPFILES(INPIC,LUNROTT,LUNDOC, FILPATOUT,NLETO, 'U',
     &            ITYPE,NSAM,NSAM,1, MAXIM,
d279 3
a281 1
     &           .FALSE., INUMBROUT,NANG, NANGT, IMGNUMOUT, IRTFLG) 
d317 2
a318 1
        NWANT = 1
d383 1
a383 1
           IF (NWANT .GE. NANG) EXIT      ! END OF LIST
d386 6
a391 4
           CALL NEXTFILES(NWANT, INUMBRT,INUMBROUT,   
     &                    INPIC,INPIC,LUNROT,
     &                    FILPAT,FILPATOUT,
     &                    IMGNUM,IMGNUMOUT,IRTFLG) 
d410 1
d413 1
d439 1
a439 1
        REAL, DIMENSION(:,:), POINTER          :: ANGBUF, ANGSYM
d441 10
a450 10
        REAL,    ALLOCATABLE, DIMENSION(:,:)   :: DM,SM 
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XE
        REAL,    ALLOCATABLE, DIMENSION(:,:,:) :: WE

        REAL,    ALLOCATABLE, DIMENSION(:)     :: TEMP
        LOGICAL                                :: ANGINDOC,CALLRTSQ
        CHARACTER(LEN=1)                       :: NULL
        CHARACTER(LEN=MAXNAM)                  :: ANGDOC
        CHARACTER(LEN=MAXNAM)                  :: FILPAT,FILNAM
        CHARACTER(LEN=MAXNAM)                  :: VOLNAM
d452 4
a455 1
        DATA  IOPIC/18/,INPIC/19/,LUNDOC/77/
d626 18
a643 18
        LOGICAL                                :: ANGINDOC
        REAL, DIMENSION(:,:), ALLOCATABLE      :: PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE   :: BI
        REAL, DIMENSION(4)                     :: ANGBUF
        DIMENSION                              :: WE(0:NSAM,N2,N2)
        COMPLEX                                :: XE(0:NSAM,N2,N2)
        INTEGER                                :: INUMBRT(NANG)
        REAL                                   :: DM(3,3,NANG)
        REAL                                   :: SM(3,3,MAXSYM)
        REAL                                   :: DMS(3,3)

        CHARACTER(LEN=*)                       :: FILPAT,FILNAM

        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJLOC
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJBUF
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: WELOC
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XELOC
        INTEGER, ALLOCATABLE, DIMENSION(:)     :: PSIZE, NBASE
d645 2
a646 2
        LOGICAL, PARAMETER                     :: SPIDER_SIGN  = .TRUE.
        LOGICAL, PARAMETER                     :: SPIDER_SCALE = .TRUE.
d649 1
a649 1
        PARAMETER (LTAB=4999)
d870 2
a871 2
        IF (ALLOCATED(XELOC))  DEALLOCATE (XELOC)
        IF (ALLOCATED(WELOC))  DEALLOCATE (WELOC)
@


1.52
log
@*** empty log message ***
@
text
@d14 1
d17 1
a17 1
C=* Copyright (C)2002,2008 P. A. Penczek                               *
d21 1
a21 1
C=* This program is free software; you can redistribute it and/or      *
d26 1
a26 1
C=* This program is distributed in the hope that it will be useful,    *
d32 1
a32 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d96 1
a96 1
        DATA  IOPIC/98/,INPIC/99/,LUNDOC/80/
d123 1
a123 1
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
d130 2
a131 2
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                  MAXSYM,ANGSYM,IRTFLG)
d165 2
a166 1
     &              INUMBR,NANG, DM,IMGNUM,SM,MAXSYM,IRTFLG)
d202 1
a202 1
        IF (IRTFLG .NE. 0) GOTO 9997
d207 2
a208 1
9997    CLOSE(IOPIC)
d210 1
a210 1
999     IF (ALLOCATED(DM)) DEALLOCATE(DM)
d219 2
a220 1
     &                    INUMBRT,NANG, DM,IMGNUM,SM,MAXSYM,IRTFLG)
d225 3
a227 1
        REAL :: DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)
a247 2
        DATA  INPROJ/99/,LUNROTT/81/,LUNDOC/80/

d254 1
a254 1
        LUNROT = 0    ! NO RTSQ OUTPUT WANTED
d265 1
a265 1
           CALL OPFILES(INPROJ,LUNROTT,LUNDOC, FILPATOUT,NLETO, 'U',
d310 1
a310 1
              CALL REDVOL(INPROJ,NSAM,NSAM, 1,1,PROJTEMP,IRTFLG)
d326 1
d330 1
a330 1
              CALL REDVOL(INPROJ,NSAM,NSAM, 1,1, PROJ,IRTFLG)
d373 1
a373 1
     &                    INPROJ,INPROJ,LUNROT,
d378 1
a378 1
        ENDDO                             ! END OF PROJECTIONS LOOP 
d394 1
d434 1
a434 1
        DATA  IOPIC/18/,INPIC/19/
d436 1
a436 5
#ifdef USE_MPI
        INCLUDE 'mpif.h'
        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
d439 2
a440 1
#endif
a441 1
#ifdef USE_MPI
d448 1
a448 1
        CLOSE(INPIC)
d461 1
a461 1
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
d468 2
a469 2
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
a541 1

d583 1
d600 2
a601 2
     &                   FILPAT,FILNAM,INPROJ, 
     &                  INUMBRT,NGOT,DM, NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
a617 4
        DOUBLE PRECISION                       :: PI
	LOGICAL                                :: ITMP
        LOGICAL, PARAMETER                     :: SPIDER_SIGN  = .TRUE.
        LOGICAL, PARAMETER                     :: SPIDER_SCALE = .TRUE.
d624 3
d709 1
a709 1
              CALL OPFILEC(0      ,.FALSE., FILNAM, INPROJ, 'O'  ,
d713 3
a715 4
              CALL READV1P(INPROJ,PRJBUF(1,1,JLOC),NSAM,NSAM,NSAM,NSAM,
     &                     1)
              CLOSE(INPROJ)
           ENDDO
d753 1
a753 1
            CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
d758 1
a758 1
        CLOSE(INPROJ)
d907 1
a907 7
#ifdef USE_MPI
        include 'mpif.h' 
        ICOMM = MPI_COMM_WORLD 
        CALL MPI_COMM_RANK(ICOMM, MYPID, IERR)
#else
        MYPID = -1 
#endif  
@


1.51
log
@fillbessil
@
text
@d453 1
a453 1
2001    FORMAT(' NUMBER OF IMAGES: ',I7)
@


1.50
log
@ mpi bug, split out wiw3d_old
@
text
@d13 1
d246 1
a246 1
        MYPID = -1
d249 1
a249 22
        LN    = 5
        LN2   = LN / 2                    ! USED IN COMMON /TABS/
	R     = NSAM / 2
	V     = REAL(LN-1) / 2.0 / REAL(N2)
	ALPHA = 6.5
	AAAA  = 0.9*V
	NNN   = 3

C       GENERATE TABLE WITH INTERPOLANTS
 	B0   = SQRT(ALPHA) * BESI1(ALPHA)
        FLTB = REAL(LTAB) / REAL(LN2+1)

cc$omp  parallel do private(i,s,x),shared(mmm)
        DO I=0,LTAB
	   S = REAL(I) / FLTB / N2
	   IF (S .LE. AAAA)  THEN
	      XT      = SQRT(1.0 - (S/AAAA)**2)
	      TABI(I) = SQRT(ALPHA*XT) * BESI1(ALPHA*XT) / B0 
	   ELSE
	      TABI(I) = 0.0
	   ENDIF
        ENDDO
d332 1
a647 2
        LN    = 5
        LN2   = LN/2
d649 1
a649 19
	R     = NSAM/2
	V     = REAL(LN-1)/2.0/REAL(N2)
	ALPHA = 6.5
	AAAA  = 0.9*V
	NNN   = 3

C       GENERATE TABLE WITH INTERPOLANTS
 	B0   = SQRT(ALPHA) * BESI1(ALPHA)
        FLTB = REAL(LTAB) / REAL(LN2+1)

        DO I=0,LTAB
	   S = REAL(I)/FLTB/N2
	   IF (S .LE. AAAA)  THEN
	      X       = SQRT(1.0-(S/AAAA)**2)
	      TABI(I) = SQRT(ALPHA*X) * BESI1(ALPHA*X) / B0
	  ELSE
	      TABI(I) = 0.0
	  ENDIF
        ENDDO
@


1.49
log
@FFTW3 plan changes
@
text
@d4 1
a4 1139
C  WIW3D.F                                                     05/03/02
C              REPLACED BESSEL FUNCTIONS
C              OPFILEC                             FEB  03 ARDEAN LEITH
C              BUILDM PARAMETERS                   JUL  03 ARDEAN LEITH
C              BUILDM PARAMETERS                   SEP  03 ARDEAN LEITH
C              ALLOCATION ERROR HANDLING           OCT  04 ARDEAN LEITH
C              OMP PRIVATE XX                      NOV  04 ARDEAN LEITH
C              MPI DECONSTRUCTED FROM WIW32D       NOV  06 ARDEAN LEITH 
C              FMRS_PLAN                           MAY  08 ARDEAN LEITH
C
C=**********************************************************************
C=* From: SPIDER - MODULAR IMAGE PROCESSING SYSTEM                     *
C=* Copyright (C)2002-2008, P. A. Penczek                                   *
C=*                                                                    *
C=* University of Texas - Houston Medical School                       *
C=*                                                                    *
C=* Email:  pawel.a.penczek@@uth.tmc.edu                                *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C=**********************************************************************
C
C   WIW3D
C
C   PURPOSE:  FOR 'BP 3F' BACK PROJECTION - 3D, INTERPOLATED IN 
C             FOURIER SPACE ||*
C             AND FOR: 'BPD 3F' IMPROVED WITH LESS MEMORY REQUIRED AND
C             MORE STACK USAGE.
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE WIW3D

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

        REAL, DIMENSION(:,:), ALLOCATABLE      :: DM,SM
        COMPLEX, DIMENSION(:,:,:), ALLOCATABLE :: X
        REAL, DIMENSION(:), ALLOCATABLE        :: TEMP
C       DOC FILE POINTERS
        REAL, DIMENSION(:,:), POINTER          :: ANGBUF, ANGSYM

        COMMON /F_SPEC/ FINPAT,NLET,FINPIC
        CHARACTER*80    FINPIC,FINPAT,FILNAM,ANGDOC

        DATA  IOPIC/98/,INPIC/99/

#ifdef USE_MPI
C       KLUDGE TO OVERCOME BUG REPORTED BY L. ALAMO, NOV 2006
        CALL WIW3D_MPI()
        RETURN
#else
        MYPID = -1
#endif
        NILMAX = NIMAX

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,INUMBR,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)
        MAXNUM = MAXVAL(INUMBR(1:NANG))

C       N    - LINEAR DIMENSION OF PROJECTIONS AND RESTORED CUBE
C       NANG - TOTAL NUMBER OF IMAGES

        IF (MYPID .LE. 0)  WRITE(NOUT,2001) NANG
2001    FORMAT('  NUMBER OF IMAGES =',I5)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        MAXXT = 4
        MAXYT = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 4
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF(IRTFLG.NE.0)  MAXSYM=1

C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(1),INTFLG)

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)

        N2     = 2*NSAM
        LSD    = N2+2-MOD(N2,2)
        NMAT   = LSD*N2*N2

        ALLOCATE(DM(9,NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, DM',9*NANG)
           GOTO 999
        ENDIF

        CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),.FALSE.,SSDUM,
     &              .FALSE.,IRTFLG)
        DEALLOCATE(ANGBUF)
        IF (IRTFLG .NE. 0) GOTO 999

        IF (MAXSYM .GT. 1)  THEN
C          HAS SYMMETRIES
           ALLOCATE(SM(9,MAXSYM), 
     &              X(0:N2/2,N2,N2), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,' BP 3F, SM...',9*MAXSYM+NSAM*N2*N2)
              GOTO 999
           ENDIF

           CALL  BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
        ELSE
           ALLOCATE(SM(1,1), 
     &              X(0:N2/2,N2,N2), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, SM...',1+NSAM*N2*N2)
              GOTO 999
           ENDIF
        ENDIF

C       CREATE FFTW3 PLAN FOR 3D FFT ON X USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,X,N2,N2,N2, 0,-1,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
 
        CALL WIW3DQ(NSAM,X,LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

C       ADDITIONAL SYMMETRIZATION OF THE VOLUME IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
           ALLOCATE(TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, TEMP',NSAM*NSAM*NSAM)
              GOTO 999
           ENDIF

	   CALL COP(X,TEMP,NSAM*NSAM*NSAM)

c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,N2/2
                    X(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO

           IF (MOD(NSAM,2) .EQ. 0)  THEN
              KNX = NSAM/2-1
           ELSE
              KNX = NSAM/2
           ENDIF
           KLX = -NSAM/2

	   CALL SYMVOL(TEMP,X,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	   DEALLOCATE(TEMP)
	ENDIF

        IFORM = 3
        CALL OPFILEC(0,.TRUE.,FILNAM,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &                  MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9997

C       NOTE: NSAM=NROW=NSLICE 

        CALL WRITEV(IOPIC,X,NSAM,NSAM,NSAM,NSAM,NSAM)

9997    CLOSE(IOPIC)

999     IF (ALLOCATED(DM)) DEALLOCATE(DM)
        IF (ALLOCATED(SM)) DEALLOCATE(SM)
        IF (ALLOCATED(X))  DEALLOCATE(X)

        END



C       ------------------ WIW3DQ ----------------------------------

        SUBROUTINE  WIW3DQ(NS,X,LSD,N,N2,INUMBR,
     &                     DM,NANG,SM,MAXSYM,IRTFLG)
       
C       NOTE: STUPID TRANSFORM OF N2-->N AND N2/2-->N2 !!!!al

        COMPLEX           X(0:N2,N,N)
        DIMENSION         INUMBR(NANG)
        DIMENSION         DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)

        REAL, DIMENSION(:,:), ALLOCATABLE    :: PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(:,:,:), ALLOCATABLE  :: W

        CHARACTER*80      FINPIC,FINPAT
        COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
        DOUBLE PRECISION  PI
        PARAMETER         (LTAB=4999)
        COMMON  /TABS/    LN2,FLTB,TABI(0:LTAB)
	COMMON  /BESSEL_PARAM/  ALPHA,AAAA,NNN
C,mmm
        DATA  INPROJ/99/
	PARAMETER (QUADPI = 3.1415926535897932384626)
	PARAMETER (TWOPI = 2*QUADPI)

#ifdef USE_MPI
c       This MPI version is memory intensive. 
c       It requires 4 copies of the 3-D volumn,
c       2-D images are read into memory and distributed.
c       Each processor will hold roughly nang/nproc
c       2-D images.  Memory requirement will be reduced
c       in a future version.

        INCLUDE 'mpif.h'
        INTEGER MYPID, COMM, MPIERR, NPROCS
        INTEGER ISTAT(MPI_STATUS_SIZE)
        INTEGER, ALLOCATABLE, DIMENSION(:) :: PSIZE, NBASE
 
        INTEGER  NANGLOC, NREM, IPROC, ISAM, JROW, JGLB, JLOC
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJLOC, PRJBUF
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: WLOC
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XLOC

        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID , MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
#else
        MYPID = -1
#endif

        LN    = 5
        LN2   = LN/2

C       Generalized Kaiser-Bessel window according to Lewitt
	R     = NS/2
	V     = REAL(LN-1)/2.0/REAL(N)
	ALPHA = 6.5
	AAAA  = 0.9*V
	NNN   = 3

C       GENERATE TABLE WITH INTERPOLANTS
	B0   = SQRT(ALPHA)*BESI1(ALPHA)
        FLTB = REAL(LTAB)/REAL(LN2+1)

cc$omp  parallel do private(i,s,xx)
        DO I=0,LTAB
	   S=REAL(I)/FLTB/N
	   IF (S.LE.AAAA)  THEN
	      XX      = SQRT(1.0-(S/AAAA)**2)
	      TABI(I) = SQRT(ALPHA*XX)*BESI1(ALPHA*XX)/B0
	   ELSE
	      TABI(I) = 0.0
	   ENDIF
        ENDDO

        ALLOCATE(W(0:N2,N,N), 
     &           PROJ(NS,NS), 
     &           BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           NEEDED = (N2+1)*N*N + NS*NS + 2*(N2+1)*N
           CALL ERRT(46,'BP 3F, W,PROJ,BI',NEEDED)
           RETURN
        ENDIF

C       CREATE FFTW3 PLAN FOR 2D FFT ON BI USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,BI,N2,N2,1, 0,+1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=0,N2
                 X(I,J,K) = CMPLX(0.0,0.0)
                 W(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

#ifdef  SP_MP
	LN1=LN+1
#endif

#ifdef  USE_MPI

C       DISTRIBUTE PARTICLES TO PROCESSORS.
C       NANGLOC IS THE NUMBER OF PARTICLES ASSIGNED
C       TO EACH PROCESSOR.

        ALLOCATE(PSIZE(NPROCS),NBASE(NPROCS),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'BP 3F, PSIZE,NBASE',NPROCS*2)
           RETURN
        ENDIF

C       SETPART RETURNS THE SIZE OF THE LOCAL PIECE
C       AND THE GLOBAL OFFSET.

        CALL SETPART(NANG, PSIZE, NBASE)
        NANGLOC = PSIZE(MYPID+1)

C       2-D IMAGES ARE DISTRIBUTED AND HELD IN PRJLOC
C       ON EACH PROCESSOR

        ALLOCATE(PRJBUF(NS,NS,PSIZE(1)), PRJLOC(NS,NS,NANGLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           NEEDED = NS*NS*PSIZE(1) + NS*NS*NANGLOC
           CALL ERRT(46,'BP 3F, PRJLOC...',NEEDED)
           RETURN
        ENDIF

C       PROCESSOR 0 READS IMAGE FILES AND DISTRIBUTE THEM.
C       (THIS VERSION ASSUMES THAT THERE IS SUFFICIENT
C        MEMORY TO HOLD NANG/NPROCS IMAGES)

        DO IPROC = 1, NPROCS
            NANGLOC = PSIZE(IPROC)

C           READ A BUNCH OF 2-D IMAGES 

            DO JLOC = 1, NANGLOC
               JGLB = NBASE(IPROC) + JLOC
               CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(JGLB),IRTFLG)
               IF (IRTFLG .NE. 0) GOTO 999
               MAXIM = 0
               CALL OPFILEC(0      ,.FALSE., FINPIC, INPROJ, 'O'  ,
     &                      IFORM  , NSAM  , NSAM  , NSL   , MAXIM,
     &                      'DUMMY',.FALSE., IRTFLG)
               IF (IRTFLG .NE. 0) GOTO 999
               CALL READV1P(INPROJ,PRJBUF(1,1,JLOC),NS,NS,NS,NS,1)
               CLOSE(INPROJ)
            ENDDO
C
            IF (IPROC .GT. 1) THEN
               IF (MYPID .EQ. 0) THEN

C                 SEND TO ANOTHER PROCESSOR
#ifdef  MPI_DEBUG
                  WRITE(6,*) 'WIW3DQ: SENDING TO PID = ', IPROC-1
#endif
                  CALL MPI_SEND(PRJBUF , NS*NS*NANGLOC, MPI_REAL,
     &                          IPROC-1, IPROC-1      , COMM    ,
     &                          MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) 'WIW3DQ: SEND ERROR!'
                     STOP
                  ENDIF
               ELSE IF (MYPID .EQ. IPROC-1) THEN

C                 RECEIVE PROJECTION IMAGES FROM PROCESSOR 0

                  CALL MPI_RECV(PRJLOC, NS*NS*NANGLOC, MPI_REAL,
     &                          0     , MPI_ANY_TAG  , COMM    ,
     &                          ISTAT , MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) 'WIW3DQ: RECV FAILED'
                     STOP
                  END IF
#ifdef MPI_DEBUG
                  WRITE(6,111) MYPID
 111              FORMAT(' WIW3DQ: MYPID = ', I3, ' RECEIVED!')
#endif
               ENDIF
            ELSE IF (MYPID .EQ. 0) THEN
C              KEEP FOR MYSELF
               DO JLOC = 1, NANGLOC
                  DO ISAM = 1, NS
                     DO JROW = 1, NS
                          PRJLOC(ISAM,JROW,JLOC) 
     &                  = PRJBUF(ISAM,JROW,JLOC)
                     END DO
                  END DO
               END DO
            ENDIF
        ENDDO
        IF (ALLOCATED(PRJBUF)) DEALLOCATE(PRJBUF)

C       PERFORM CALCULATIONS IN PARALLEL NOW 

        ALLOCATE (WLOC(0:N2,N,N), XLOC(0:N2,N,N), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MWANT = ((N2+1)*N*N) * 2
           CALL ERRT(46,'BP 3F, WLOC, XLOC',MWANT)
           RETURN
        ENDIF

        DO    K=1,N
           DO    J=1,N
              DO    I=0,N2
                 XLOC(I,J,K)=CMPLX(0.0,0.0)
                 WLOC(I,J,K)=0.0
              ENDDO
           ENDDO
        ENDDO

        NANGLOC = PSIZE(MYPID+1)
        DO JLOC = 1, NANGLOC
           JGLB = NBASE(MYPID+1) + JLOC

C          PAD: BI  TO SIZE N
           CALL PADD2(PRJLOC(1,1,JLOC),NS,BI,LSD,N)
C          FOURIER TRANSFORM OF: BI
           INV = +1
           CALL FMRS_2(BI,N,N,INV) 

           DO J=1,N
              DO I=0,N2
                 BI(I,J) = BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO ISYM=1,MAXSYM
              IF (MAXSYM.GT.1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS = MATMUL(SM(:,:,ISYM),DM(:,:,jglb))
              ELSE
                 DMS=DM(:,:,jglb)
              ENDIF

              DO J=-N2+1,N2
                 CALL ONELINE(J,N,N2,XLOC,WLOC,BI,DMS)
              ENDDO
           END DO
        ENDDO
        IF (ALLOCATED(PRJLOC)) DEALLOCATE(PRJLOC)

C       SUM UP X AND W FROM THE LOCAL PIECES (XLOC, WLOC)
C       RESIDING ON EACH PROCESSOR 

        DO K = 1, N 
           CALL MPI_ALLREDUCE(XLOC(1,1,K), X   , (N2+1)*N, MPI_COMPLEX,
     &                        MPI_SUM    , COMM, MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW3DQ: FAILED TO ALLREDUCE'
              STOP
           END IF
           CALL MPI_ALLREDUCE(WLOC(1,1,K), W   , (N2+1)*N, MPI_REAL,
     &                        MPI_SUM    , COMM, MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW3DQ: FAILED TO ALLREDUCE'
              STOP
           END IF
        ENDDO
        IF (ALLOCATED(XLOC))    DEALLOCATE (XLOC)
        IF (ALLOCATED(WLOC))    DEALLOCATE (WLOC)
#ifdef MPI_DEBUG
        WRITE(6,*) 'WIW3DQ: COMPLETED GLOBAL SUM, MYPID = ', MYPID
#endif

#else

        DO K=1,NANG
C          PRINT  *,' PROJECTION #',K

C          OPEN DESIRED FILE
           CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(K),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPROJ,'O',IFORM,NSAM,NSAM,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

	   CALL READV(INPROJ,PROJ,NS,NS,NS,NS,1)
           CLOSE(INPROJ)

C          PAD: PROJ TO SIZE: N
           CALL PADD2(PROJ,NS,BI,LSD,N)
C          FOURIER TRANSFOR OF: BI
           INV = +1
           CALL FMRS_2(BI,N,N,INV)

c$omp      parallel do private(i,j)
           DO J=1,N
              DO I=0,N2
                 BI(I,J) = BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO ISYM=1,MAXSYM
            IF (MAXSYM.GT.1)  THEN
C              SYMMETRIES, MULTIPLY MATRICES
               DMS = MATMUL(SM(:,:,ISYM),DM(:,:,K))
            ELSE
               DMS = DM(:,:,K)
            ENDIF

#ifdef      SP_MP
	    DO  JT=1,LN1

c$omp          parallel do private(j)
               DO J=-N2+JT,N2,LN1
                  CALL ONELINE(J,N,N2,X,W,BI,DMS)
               ENDDO

            ENDDO
#else
            DO J=-N2+1,N2
              CALL ONELINE(J,N,N2,X,W,BI,DMS)
            ENDDO
#endif
           ENDDO  ! END OF SYMMETRIES LOOP
        ENDDO  ! END OF PROJECTIONS LOOP 
#endif

C       SYMMETRIZE PLANE 0
	CALL  SYMPLANE0(X,W,N2,N)

        CALL NRMW2(X,W,N2,N)

        CALL WINDKB2(X,X,NS,LSD,N)

        IRTFLG = 0

999     CONTINUE
        IF (ALLOCATED(W))    DEALLOCATE (W)
        IF (ALLOCATED(PROJ)) DEALLOCATE (PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE (BI)
        END




C       ------------------- PADD2 -------------------------------

        SUBROUTINE PADD2(PROJ,L,BI,LSD,N)

C       PADS: PROJ OF SIZE: L  INTO: BI  WITH SIZE: N

        DIMENSION  PROJ(L,L),BI(LSD,N)
        DOUBLE     PRECISION QS

        KLP = 0
        R   = L/2
        QS  = 0.0D0

C       ESTIMATE AVERAGE OUTSIDE THE CIRCLE
        CALL ASTA(PROJ,L,R,QS,KLP)
        QS = QS/REAL(KLP)

C       ZEROS ALL OF: BI
c$omp   parallel do private(i,j)
        DO J=1,N
           DO I=1,N
              BI(I,J) = 0.0
           ENDDO
        ENDDO

C       FOR L ODD ADD ONE.  N IS ALWAYS EVEN
        IP = (N-L)/2+MOD(L,2)

c$omp   parallel do private(i,j)
        DO J=1,L
           DO I=1,L
              BI(IP+I,IP+J) = PROJ(I,J) - QS
           ENDDO
        ENDDO

        END

C       ------------------- NRMW2 -------------------------------

        SUBROUTINE NRMW2(R,W,N2,N)

        DIMENSION  W(0:N2,N,N)
        COMPLEX    R(0:N2,N,N)

c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=0,N2
                IF (W(I,J,K).GT.0.1)  THEN
		   R(I,J,K) = R(I,J,K)*(-1)**(I+J+K)/W(I,J,K)
		ELSE
		   R(I,J,K) = (0.0,0.0)
		ENDIF
              ENDDO
           ENDDO
        ENDDO

        INV = -1
        CALL FMRS_3(R,N,N,N,INV) 

        END

	
C++*********************************************************************
C
C  WIW3D_MPI.F     DECONSTRUCTED FROM WIW32D        NOV  06 ARDEAN LEITH
C                  ORIGINAL WIW3D GAVE WRONG RESULTS
C                  WHEN USED UNDER MPI
C
C=**********************************************************************
C=* From: SPIDER - MODULAR IMAGE PROCESSING SYSTEM                     *
C=* Copyright (C)2002, P. A. Penczek                                   *
C=*                                                                    *
C=* University of Texas - Houston Medical School                       *
C=*                                                                    *
C=* Email:  pawel.a.penczek@@uth.tmc.edu                                *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C=**********************************************************************
C
C  WIW3D_MPI
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE WIW3D_MPI

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

C       DOC FILE POINTERS
        REAL, DIMENSION(:,:), POINTER          :: ANGBUF, ANGSYM

        REAL, DIMENSION(:,:), ALLOCATABLE      :: DM,SM 
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XE
        REAL, ALLOCATABLE, DIMENSION(:,:,:)    :: WE

        REAL, DIMENSION(:), ALLOCATABLE        :: TEMP
        LOGICAL                                :: ANGINDOC
        CHARACTER(LEN=1)                       :: NULL

        CHARACTER(LEN=MAXNAM)                  :: ANGDOC
        CHARACTER(LEN=MAXNAM)                  :: FINPAT,FINPIC
        CHARACTER(LEN=MAXNAM)                  :: FOUTPIC
 
#ifndef SP_32
        INTEGER *8                           :: FFTW_PLAN_F,FFTW_PLAN_B
#else
        INTEGER *4                           :: FFTW_PLAN_F,FFTW_PLAN_B
#endif

        DATA  IOPIC/18/,INPIC/19/

#ifdef USE_MPI
        INCLUDE 'mpif.h'
        INTEGER MYPID, COMM, MPIERR
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
#else
        PRINT *, ' THIS ROUTINE for MPI ONLY'
        STOP
#endif

#ifdef USE_MPI
        NULL   = CHAR(0)
        NILMAX = NIMAX

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,INUMBR,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)
        MAXNUM = MAXVAL(INUMBR(1:NANG))

C       NANG - TOTAL NUMBER OF IMAGES
        IF (MYPID .LE. 0) WRITE(NOUT,2001) NANG
2001    FORMAT(' NUMBER OF IMAGES: ',I7)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        ANGINDOC = .TRUE.
        MAXXT    = 4
        MAXYT    = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                 MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) ANGINDOC = .FALSE.

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 0
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF (IRTFLG .NE. 0)  MAXSYM=1

C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FINPIC,0,INUMBR(1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CLOSE(INPIC)

        N2   = 2*NSAM
        LSD  = N2+2-MOD(N2,2)
        NMAT = LSD * N2 * N2

        IF (ANGINDOC) THEN
        
           ALLOCATE(DM(9,NANG), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN
              MEMWANT = 9 * NANG
              CALL ERRT(46,'BP 32F, DM',MEMWANT)
              GOTO 999
           ENDIF

           CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),.FALSE.,SSDUM,
     &                 .FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
        
           IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        ELSE
           ALLOCATE(DM(9,1), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'BP 32F, DM',IER)
              GOTO 999
           ENDIF
        ENDIF

        IF (MAXSYM .GT. 1)  THEN
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              MEMWANT = 9 * MAXSYM
              CALL ERRT(46,'BP 3F, SM',MEMWANT)
              GOTO 999
           ENDIF
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)

       ELSE
           ALLOCATE(SM(1,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
               CALL ERRT(46,'BP 3F, SM(1,1)',IER)
               GOTO 999
           ENDIF
        ENDIF

        ALLOCATE(XE(0:N2/2,N2,N2),
     &           WE(0:N2/2,N2,N2), STAT=IRTFLG)

        IF (IRTFLG.NE.0) THEN 
C          X ARRAYS ARE COMPLEX SO 3 NOT 2
           MEMWANT = 3 * ((N2/2)+1) * N2 * N2
           CALL ERRT(46,'BP 32F; XE & WE ',MEMWANT)
           GOTO 999
        ENDIF

C       CREATE FFTW3 PLAN FOR 3D FFT ON X USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,XE,N2,N2,N2, 0,-1,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
 
 
        CALL WIW3DQ_MPI(NSAM,XE,WE,LSD,N2,N2/2,FINPAT,FINPIC,INPIC,
     &                  INUMBR,DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL  FILERD(FOUTPAC,NLETI,NULL,'RECONSTRUCTED 3D',IRTFLG) 
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL NRMW2(XE,WE,N2/2,N2)

        CALL WINDKB2(XE,XE,NSAM,LSD,N2)

C       NOW XE IS READY, SYMMETRIZE IF NECESSARY
C       ADDITIONAL SYMMETRIZATION OF THE VOLUME XE IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
           ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              MEMWANT = NSAM * NSAM * NSAM 
              CALL ERRT(46,'BP 32F, TEMP',MEMWANT)
              GOTO 999
           ENDIF
	   CALL COP(XE,TEMP,NSAM*NSAM*NSAM)

c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,N2/2
                    XE(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO

           IF (MOD(NSAM,2) .EQ. 0)  THEN
              KNX = NSAM/2-1
           ELSE
              KNX = NSAM/2
           ENDIF
           KLX = -NSAM/2
	   CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	ENDIF

C       OUTPUT FILE
        IFORM = 3
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FOUTPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)

        IF (MYPID .LE. 0) CLOSE(IOPIC)

999     CONTINUE
        IF (ALLOCATED(DM))      DEALLOCATE(DM)
        IF (ALLOCATED(SM))      DEALLOCATE(SM)
        IF (ALLOCATED(XE))      DEALLOCATE(XE)
        IF (ALLOCATED(WE))      DEALLOCATE(WE)
        IF (ALLOCATED(TEMP))    DEALLOCATE(TEMP)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)
#endif
 
        END

C       ---------------- WIW3DQ_MPI -------------------------------------

        SUBROUTINE WIW3DQ_MPI(NS,XE,WE,LSD,N,N2,FINPAT,FINPIC,INPROJ, 
     &                     INUMBRT,DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)

C       NOTE: STUPID TRANSFORM OF N2-->N AND N2/2-->N2 !!!!al

        INCLUDE 'CMLIMIT.INC'

        LOGICAL                              :: ANGINDOC
        REAL, DIMENSION(:,:), ALLOCATABLE    :: PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(4)                   :: ANGBUF
        DIMENSION                            :: WE(0:N2,N,N)
        COMPLEX                              :: XE(0:N2,N,N)
        INTEGER                              :: INUMBRT(NANG)
        REAL                                 :: DM(3,3,NANG)
        REAL                                 :: SM(3,3,MAXSYM),DMS(3,3)

        CHARACTER(LEN=*)                     :: FINPAT,FINPIC

        DOUBLE PRECISION                     :: PI
	LOGICAL                              :: ITMP

        PARAMETER (LTAB=4999)
        COMMON  /TABS/  LN2,FLTB,TABI(0:LTAB)

C       IN THIS VERSION THE ORDER OF THE BESSEL FUNCTION IS MMM=1
	COMMON  /BESSEL_PARAM/  ALPHA,AAAA,NNN

	PARAMETER (QUADPI = 3.1415926535897932384)
	PARAMETER (TWOPI = 2*QUADPI)

c       This MPI version is memory intensive.
c       2-D images are read into memory and distributed.
c       Each processor will hold roughly nang/nproc
c       2-D images. 

#ifndef USE_MPI
        MYPID = -1
        PRINT *, ' THIS ROUTINE FOR MPI COMPILATION/USE ONLY'
        STOP
#else
        INCLUDE 'mpif.h'
        INTEGER MYPID, COMM, MPIERR, NPROCS, K3
        INTEGER ISTAT(MPI_STATUS_SIZE)
        INTEGER, ALLOCATABLE, DIMENSION(:) :: PSIZE, NBASE
                          
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJLOC
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJBUF
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: WELOC
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XELOC

        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)

        LN    = 5
        LN2   = LN/2
C       GENERALIZED KAISER-BESSEL WINDOW ACCORDING TO LEWITT
	R     = NS/2
	V     = REAL(LN-1)/2.0/REAL(N)
	ALPHA = 6.5
	AAAA  = 0.9*V
	NNN   = 3

C       GENERATE TABLE WITH INTERPOLANTS
 	B0   = SQRT(ALPHA)*BESI1(ALPHA)
        FLTB = REAL(LTAB)/REAL(LN2+1)

C       CANNOT BE PARALLEL AS THERE ARE DATA STATEMENTS IN BESSI
cc$omp  parallel do private(i,s,x),shared(mmm)
        DO I=0,LTAB
	   S = REAL(I)/FLTB/N
	   IF (S .LE. AAAA)  THEN
	      X       = SQRT(1.0-(S/AAAA)**2)
	      TABI(I) = SQRT(ALPHA*X)*BESI1(ALPHA*X)/B0
	  ELSE
	     TABI(I) = 0.0
	  ENDIF
        ENDDO

c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=0,N2
                 XE(I,J,K) = CMPLX(0.0,0.0)
                 WE(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

        ALLOCATE (PROJ(NS,NS),
     &            BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           MEMWANT = NS*NS + 2*(N2 + 1) * N  
           CALL ERRT(46,'BP 32F, PROJ, ...',MEMWANT)
           RETURN
        ENDIF

C       CREATE FFTW3 PLAN FOR 2D FFT ON BI USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,BI,N2,N2,1, 0,+1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
C       --- BEGIN MPI VERSION ---
C       DISTRIBUTE PARTICLES TO PROCESSORS.
C       NANGLOC IS THE NUMBER OF PARTICLES ASSIGNED TO EACH PROCESSOR.

        ALLOCATE(PSIZE(NPROCS) ,NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = 2 * NPROCS 
           CALL ERRT(46,'BP 3F, PSIZE & NBASE',MEMWANT)
           RETURN
        ENDIF

C       SETPART RETURNS THE SIZE OF THE LOCAL PIECE
C       AND THE GLOBAL OFFSET.

        CALL SETPART(NANG, PSIZE, NBASE)
        NANGLOC = PSIZE(MYPID+1)

C       2-D IMAGES ARE DISTRIBUTED AND HELD IN PRJLOC ON EACH PROCESSOR

        ALLOCATE(PRJBUF(NS,NS,PSIZE(1)),
     &           PRJLOC(NS,NS,NANGLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = NS*NS*PSIZE(1) + NS*NS*NANGLOC
           CALL ERRT(46,'BP 3F, PRJBUF, PRJLOC',MEMWANT)
           RETURN
        ENDIF

C       PROCESSOR 0 READS IMAGE FILES AND DISTRIBUTE THEM.
C       (THIS VERSION ASSUMES THAT THERE IS SUFFICIENT
C        MEMORY TO HOLD NANG/NPROCS IMAGES)

        DO IPROC = 1, NPROCS
           NANGLOC = PSIZE(IPROC)

C          READ IMAGES INTO THE BUFFER FIRST, THEN DISTRIBUTE

           DO JLOC = 1, NANGLOC
              JGLB = NBASE(IPROC) + JLOC
              CALL FILGET(FINPAT,FINPIC,0,INUMBRT(JGLB),IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
              MAXIM = 0
              CALL OPFILEC(0      ,.FALSE., FINPIC, INPROJ, 'O'  ,
     &                     IFORM  , NSAM  , NSAM  , NSL   , MAXIM,
     &                     'DUMMY',.FALSE., IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
              CALL READV1P(INPROJ,PRJBUF(1,1,JLOC),NS,NS,NS,NS,1)
              CLOSE(INPROJ)
           ENDDO
C
           IF (IPROC .GT. 1) THEN
               IF  (MYPID .EQ. 0) THEN

C                 SEND TO ANOTHER PROCESSOR
#ifdef MPI_DEBUG
                  WRITE(6,*) 'WIW32DQ: SENDING TO PID = ', IPROC-1
#endif
                  CALL MPI_SEND(PRJBUF , NS*NS*NANGLOC, MPI_REAL,
     &                          IPROC-1, IPROC-1      , COMM    ,
     &                          MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) 'WIW32DQ: SEND ERROR!'
                     STOP
                  ENDIF
               ELSEIF (MYPID .EQ. IPROC-1) THEN
C
C                 RECEIVE PROJECTION IMAGES FROM PROCESSOR 0
C
                  CALL MPI_RECV(PRJLOC, NS*NS*NANGLOC, MPI_REAL,
     &                          0     , MPI_ANY_TAG  , COMM    ,
     &                          ISTAT , MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) 'WIW32DQ: RECV FAILED'
                     STOP
                  ENDIF
#ifdef MPI_DEBUG
                  WRITE(6,111) MYPID
 111              FORMAT(1X,'WIW32DQ: MYPID = ', I3, ' RECEIVED!')
#endif
              ENDIF  
           ELSEIF (MYPID .EQ. 0) THEN
C             KEEP FOR MYSELF
              DO JLOC = 1, NANGLOC
                 DO ISAM = 1, NS
                     DO JROW = 1, NS
                          PRJLOC(ISAM,JROW,JLOC)
     &                  = PRJBUF(ISAM,JROW,JLOC)
                     ENDDO
                  ENDDO
               ENDDO
           ENDIF
        ENDDO
        IF (ALLOCATED(PRJBUF)) DEALLOCATE(PRJBUF)

        IF (.NOT. ANGINDOC) THEN
C           GET ANGLES FROM HEADER
            ANGBUF(1) = INUMBRT(K)
            CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
            CALL BUILDM(INUMBRT,DM,1,ANGBUF,.FALSE.,SSDUM,
     &                  .FALSE.,IRTFLG)
            IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
        CLOSE(INPROJ)

C       PERFORM CALCULATIONS IN PARALLEL NOW

        ALLOCATE (WELOC(0:N2,N,N), XELOC(0:N2,N,N), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = 2*(N2+1)*N*N 
           CALL ERRT(46,'BP 3F, WELOC, XELOC, ...',MEMWANT)
           RETURN
        ENDIF

        DO K=1,N
           DO J=1,N
              DO I=0,N2
                 XELOC(I,J,K) = CMPLX(0.0,0.0)
                 WELOC(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO
C
        NANGLOC = PSIZE(MYPID+1)
        DO JLOC = 1, NANGLOC
           JGLB = NBASE(MYPID+1) + JLOC

C          PAD: PRJLOC  TO SIZE: N
           CALL PADD2(PRJLOC(1,1,JLOC),NS,BI,LSD,N)
C          FOURIER TRANSFORM OF: BI
           INV = +1
           CALL FMRS_2(BI,N,N,INV) 

           DO J=1,N
              DO I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO ISYM=1,MAXSYM
              IF (MAXSYM.GT.1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS = MATMUL(SM(:,:,ISYM),DM(:,:,JGLB))
              ELSE
                 DMS = DM(:,:,JGLB)
              ENDIF

              DO J=-N2+1,N2
                 CALL ONELINE(J,N,N2,XELOC,WELOC,BI,DMS)
              ENDDO
           ENDDO
        ENDDO
        IF (ALLOCATED(PRJLOC)) DEALLOCATE(PRJLOC)

C       SUM UP X AND W FROM THE LOCAL PIECES (XLOC, WLOC)
C       RESIDING ON EACH PROCESSOR

        DO K3 = 1, N
           CALL MPI_ALLREDUCE(XELOC(1,1,K3), XE(1,1,K3), (N2+1)*N, 
     &                        MPI_COMPLEX  , MPI_SUM   , COMM    ,
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF

           CALL MPI_ALLREDUCE(WELOC(1,1,K3), WE(1,1,K3), (N2+1)*N, 
     &                        MPI_REAL     , MPI_SUM   , COMM    ,
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
        ENDDO 

        IF (ALLOCATED(XELOC)) DEALLOCATE (XELOC)
        IF (ALLOCATED(WELOC)) DEALLOCATE (WELOC)

#ifdef MPI_DEBUG
        WRITE(6,*) 'WIW32DQ: COMPLETED GLOBAL SUM, MYPID = ', MYPID
#endif
C       --- END OF MPI VERSION ---     

C       SYMMETRIZE VOLUME
        CALL  SYMPLANE0(XE,WE,N2,N)

9999    IF (ALLOCATED(PROJ)) DEALLOCATE (PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE (BI)
#endif

        END



C++*********************************************************************
C
C  WIW3D_DL.F                                                     05/03/02
d15 1
a15 1
C=* Copyright (C)2002, P. A. Penczek                                   *
d38 37
d167 1
a167 1
C       write(6,*) ' 0  x(65,65,65):', x(65,65,65)
d214 1
a214 1
C       ------------------ WIW3DQ ----------------------------------
a348 1
c          write(6,*) ' 0  maxval(proj):', maxval(proj)
a394 2
c       write(6,*) ' 0  x(65,65,65):', x(65,65,65)

d399 1
a399 1
C       WEIGHT, FOURIER TRANSFORM, AND WINDOW
d401 2
a413 3



d417 1
a417 1
C  WIW3D_MPI.F     DECONSTRUCTED FROM WIW32D        NOV  06 ARDEAN LEITH
d420 1
a420 1
C
d423 1
a423 1
C  WIW3D_MPI
d447 1
a447 1
        CHARACTER(LEN=MAXNAM)                  :: FOUTPIC
d453 2
a454 3
        INTEGER MYPID, COMM, MPIERR
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d489 1
a489 1
        IF (IRTFLG .NE. 0)  MAXSYM=1
d499 1
a499 1
        CLOSE(INPIC)
d510 1
a510 1
              CALL ERRT(46,'BP 32F, DM',MEMWANT)
d523 1
a523 1
              CALL ERRT(46,'BP 32F, DM',IER)
d553 1
a553 1
            CALL ERRT(46,'BP 32F; XE & WE ',MEMWANT)
a560 8
c       write(6,*) '  x4(65,65,65):', x(65,65,65)

        CALL FILERD(FOUTPAC,NLETI,NULL,'RECONSTRUCTED 3D',IRTFLG) 
        IF (IRTFLG .NE. 0)  GOTO 9999

C       WEIGHT, FOURIER TRANSFORM, AND WINDOW
        CALL NRMW2(XE,WE,NSAM,N2)
        CALL WINDKB2A(XE,XE,NSAM,LSD,N2,ALPHA,AAAA,NNN)
d568 1
a568 1
              CALL ERRT(46,'BP 32F, TEMP',MEMWANT)
d572 1
d595 2
a596 3
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FOUTPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
d616 1
a616 1
C       ---------------- WIW3DQ_MPI -------------------------------------
d624 10
a633 9
        LOGICAL                              :: ANGINDOC
        REAL, DIMENSION(:,:), ALLOCATABLE    :: PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(4)                   :: ANGBUF
        DIMENSION                            :: WE(0:NSAM,N2,N2)
        COMPLEX                              :: XE(0:NSAM,N2,N2)
        INTEGER                              :: INUMBRT(NANG)
        REAL                                 :: DM(3,3,NANG)
        REAL                                 :: SM(3,3,MAXSYM),DMS(3,3)
d635 1
a635 1
        CHARACTER(LEN=*)                     :: FILPAT,FILNAM
d637 9
a645 2
        DOUBLE PRECISION                     :: PI
	LOGICAL                              :: ITMP
d651 3
a653 4
c       This MPI version is memory intensive.
c       2-D images are read into memory and distributed.
c       Each processor will hold roughly nang/nproc
c       2-D images. 
d661 1
a661 3
        INTEGER MYPID, COMM, MPIERR, NPROCS, K3
        INTEGER ISTAT(MPI_STATUS_SIZE)
        INTEGER, ALLOCATABLE, DIMENSION(:) :: PSIZE, NBASE
d663 3
a665 8
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJLOC
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJBUF
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: WELOC
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XELOC

        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
d699 2
a700 2
        ALLOCATE (PROJ(NSAM,NSAM),
     &            BI(0:NSAM,N2), STAT=IRTFLG)
d703 1
a703 1
           CALL ERRT(46,'BP 32F, PROJ, ...',MEMWANT)
d710 3
a712 1
        ALLOCATE(PSIZE(NPROCS) ,NBASE(NPROCS), STAT=IRTFLG)
d715 1
a715 1
           CALL ERRT(46,'BP 3F, PSIZE & NBASE',MEMWANT)
d719 1
a719 2
C       SETPART RETURNS THE SIZE OF THE LOCAL PIECE
C       AND THE GLOBAL OFFSET.
a760 3
#ifdef MPI_DEBUG
                  WRITE(6,*) 'WIW32DQ: SENDING TO PID = ', IPROC-1
#endif
d762 1
a762 1
     &                          IPROC-1, IPROC-1      , COMM    ,
d765 1
a765 1
                     WRITE(6,*) 'WIW32DQ: SEND ERROR!'
d771 1
a771 1
     &                          0     , MPI_ANY_TAG  , COMM    ,
d774 1
a774 1
                     WRITE(6,*) 'WIW32DQ: RECV FAILED'
a776 3
#ifdef MPI_DEBUG
                  WRITE(6,*)'WIW32DQ: MYPID=', MYPID,' RECEIVED!'
#endif
d783 1
a783 2
                          PRJLOC(ISAM,JROW,JLOC)
     &                  = PRJBUF(ISAM,JROW,JLOC)
d802 11
a812 1
        ALLOCATE (WELOC(0:NSAM,N2,N2), XELOC(0:NSAM,N2,N2), STAT=IRTFLG)
d816 1
a816 1
           RETURN
d834 3
a836 3
C          FOURIER TRANSORM OF: BI
           INV = +1
           CALL FMRS_2(BI,N2,N2,INV) 
d840 1
a840 1
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
d845 1
a845 1
              IF (MAXSYM.GT.1)  THEN
a856 1
        IF (ALLOCATED(PRJLOC)) DEALLOCATE(PRJLOC)
d858 1
a858 2
C       SUM UP X AND W FROM THE LOCAL PIECES (XLOC, WLOC)
C       RESIDING ON EACH PROCESSOR
d860 3
a862 3
        DO K3 = 1, N
           CALL MPI_ALLREDUCE(XELOC(1,1,K3), XE(1,1,K3), (NSAM+1)*N2, 
     &                        MPI_COMPLEX  , MPI_SUM   , COMM    ,
d864 2
a865 2
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
d869 2
a870 2
           CALL MPI_ALLREDUCE(WELOC(1,1,K3), WE(1,1,K3), (NSAM+1)*N2, 
     &                        MPI_REAL     , MPI_SUM   , COMM    ,
d872 2
a873 2
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
d878 8
a885 2
        IF (ALLOCATED(XELOC)) DEALLOCATE (XELOC)
        IF (ALLOCATED(WELOC)) DEALLOCATE (WELOC)
a886 3
#ifdef MPI_DEBUG
        WRITE(6,*) 'WIW32DQ: COMPLETED GLOBAL SUM, MYPID = ', MYPID
#endif
a887 2
C       SYMMETRIZE VOLUME
        CALL SYMPLANE0(XE,WE,NSAM,N2)
d889 5
a893 2
9999    IF (ALLOCATED(PROJ)) DEALLOCATE(PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE(BI)
d899 3
d950 2
a951 2
        icomm = MPI_COMM_WORLD 
        call MPI_COMM_RANK(icomm, mypid, ierr)
d953 1
a953 1
        mypid = -1 
d990 70
@


1.48
log
@ INUMBERT --> INUMBR  (Would not compile here)
@
text
@d12 2
d16 1
a16 1
C=* Copyright (C)2002, P. A. Penczek                                   *
a37 1
C **********************************************************************
d41 5
d127 2
a128 1
           ALLOCATE(SM(9,MAXSYM),X(0:N2/2,N2,N2), STAT=IRTFLG)
d137 2
a138 1
           ALLOCATE(SM(1,1),X(0:N2/2,N2,N2), STAT=IRTFLG)
d144 5
d205 2
a207 1
        
d277 3
a279 1
        ALLOCATE(W(0:N2,N,N),PROJ(NS,NS),BI(0:N2,N), STAT=IRTFLG)
d281 1
a281 1
           NEEDED = (N2+1)*N*N + NS*NS + (N2+1)*N
d285 5
a289 1
	
d380 1
a380 1
#ifdef    MPI_DEBUG
d382 1
a382 1
 111              FORMAT(1X,'WIW3DQ: MYPID = ', I3, ' RECEIVED!')
d420 2
d423 1
d425 1
a425 1
           CALL FMRS_2(BI,N,N,INV)
d429 1
a429 1
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
d436 1
a436 1
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,jglb))
d442 1
a442 1
                 CALL ONELINE(J,N,N2,Xloc,Wloc,BI,DMS)
d466 1
a466 1
        IF (ALLOCATED(Wloc))    DEALLOCATE (Wloc)
d487 1
d489 1
d496 1
a496 1
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
d502 2
a503 2
C              symmetries, multiply matrices
               DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
d505 1
a505 1
               DMS=DM(:,:,K)
d528 1
d530 1
d548 2
d557 1
d561 1
d575 1
a575 1
              BI(IP+I,IP+J)=PROJ(I,J)-QS
d602 1
a602 1
        CALL FMRS_3(R,N,N,N,INV)
a636 1
C **********************************************************************
d664 6
d723 1
a723 1
        NMAT = LSD*N2*N2
d775 5
d848 2
d938 1
a938 1
           MEMWANT = NS*NS + (N2 + 1) * N  
d943 4
a946 1

d1072 2
d1075 1
d1077 1
a1077 1
           CALL FMRS_2(BI,N,N,INV)
d1393 4
a1396 2
        ALLOCATE(PROJ(NSAM,NSAM),PROJTEMP(NSAM,NSIZE),
     &            W(0:NSAM,N2,N2),BI(0:NSAM,N2), STAT=IRTFLG)
d1398 1
a1398 1
           NEEDED = NSAM*NSAM + NSAM*NSIZE + (NSAM+1)*N2*N2 +
d1404 4
d1452 1
d1454 1
d1456 1
a1456 1
           CALL FMRS_2(BI,N2,N2,INV)
d1535 1
d1937 1
a1937 1
C
d1941 2
d1944 1
d1946 1
a1946 1
           CALL FMRS_2(BI,N2,N2,INV)
@


1.47
log
@INUMBRT was undeclared on line 1519. Added the declaration.
Correct a few more syntax errors.
@
text
@a11 1
C **********************************************************************
a1494 2

        INTEGER, DIMENSION(NANG)               :: INUMBRT
d1512 1
a1512 1
        CALL FILELIST(.TRUE.,INPIC,FILPAT,NLET,INUMBRT,NILMAX,NANG,
d1516 1
a1516 1
        MAXNUM = MAXVAL(INUMBRT(1:NANG))
d1540 1
a1540 1
        CALL FILGET(FILPAT,FILNAM,0,INUMBRT(1),IRTFLG)
d1562 1
a1562 1
           CALL BUILDM1(INUMBRT,DM,9,NANG,ANGBUF,.FALSE.,SSDUM,
d1606 1
a1606 1
     &                  INUMBRT,NANG, DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
@


1.46
log
@list bug
@
text
@d1496 2
d1811 2
a1812 1
              CALL READV1P(INPROJ,PRJBUF(1,1,JLOC),NSAM,NSAM,NSAM,NSAM,1)
d1839 1
a1839 1
                  WRITE(6,*)'WIW32DQ: MYPID=', MYPID,' RECEIVED!')
@


1.45
log
@BPD
@
text
@d1191 1
a1191 1
        ALLOCATE(DM(9,NANG), STAT=IRTFLG)
d1199 1
a1199 1
     &              .FALSE.,IRTFLG)
d1272 1
d1377 8
d1556 1
a1556 1
           ALLOCATE(DM(9,NANG), STAT=IRTFLG)
d1564 1
a1564 1
     &                 .FALSE.,IRTFLG)
d1858 1
a1858 1
     &                  .FALSE.,IRTFLG)
@


1.44
log
@*** empty log message ***
@
text
@d1091 934
@


1.43
log
@mpi version deconstructed from wiw32d.f as buggy
@
text
@d643 2
a644 1
        MYPID = -1
d646 2
d799 1
a833 1
#ifdef USE_MPI
a834 1
c       It requires 6 copies of the 3-D volumn,
d837 1
a837 2
c       2-D images.  Memory requirement will be reduced in
c       a future version.
d839 5
a856 5
#else
        MYPID = -1
        PRINT *, ' THIS ROUTINE for MPI ONLY'
        STOP
#endif
a901 3

#ifdef USE_MPI
C
a1079 4
#else
        PRINT *, ' VERSION FOR MPI ONLY'
        STOP
#ENDIF
d1086 1
@


1.42
log
@Pawels GPL License used
@
text
@d10 2
a11 2
C              OMP PRIVATE XX                       NOV  04 ARDEAN LEITH
C        
d62 3
a64 5
        INCLUDE 'mpif.h'
        INTEGER MYPID, COMM, MPIERR

        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d577 519
@


1.41
log
@(N2+1)*N*N) * 2 fixed
@
text
@d2 1
a2 1
C++************************************************************************
d12 26
a37 6
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.
C *  WIW3D.F   COPYRIGHT (C)2002, P.A.PENCZEK
C *  UNIVERSITY OF TEXAS - HOUSTON MEDICAL SCHOOL
C *  pawel.a.penczek@@uth.tmc.edu
C **************************************************************************
@


1.40
log
@OMP PRIVATE XX
@
text
@d366 1
a366 1
           MWANT = (N2+1)*N*N) * 2
@


1.39
log
@ALLOCATION ERROR HANDLING
@
text
@d10 1
d106 1
a106 1
              CALL ERRT(46,'BP 3F, SM...',9*MAXSYM+N2*N2*N2)
d115 1
a115 1
              CALL ERRT(46,'BP 3F, SM...',1+N2*N2*N2)
d221 3
a223 3
C       K=6
        LN=5
        LN2=LN/2
d225 5
a229 8
C       M=NS, N=N
	R=NS/2
	V=REAL(LN-1)/2.0/REAL(N)
	ALPHA=6.5
C	AAAA=0.0079
	AAAA=0.9*V
	NNN=3
C	mmm=1
a231 1
C	B0   = (SQRT(ALPHA)**mmm)*BESSI(mmm,ALPHA)
d234 2
a235 1
cc$omp  parallel do private(i,s,x),shared(mmm)
d257 2
a258 2
                 X(I,J,K)=CMPLX(0.0,0.0)
                 W(I,J,K)=0.0
d268 1
a268 1
c
d272 1
a272 1
C      
d278 1
a278 1
C       
d281 1
a281 1
C 
d284 1
a284 1
C
d287 1
a287 1
C
d295 1
a295 1
C
d299 1
a299 1
C
d302 1
a302 1
C
d304 1
a304 1
C
d365 3
a367 2
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'BP 3F, WLOC, XLOC',IER)
d468 2
a469 2
C,schedule(static)
c$omp          parallel do private(j),shared(N,N2,JT,X,W,BI,DMS)
d473 1
d488 1
d507 3
a509 3
        KLP=0
        R=L/2
        QS=0.0D0
d513 1
d515 3
a517 3
        DO  J=1,N
           DO  I=1,N
              BI(I,J)=0.0
d525 2
a526 2
        DO  J=1,L
           DO  I=1,L
a548 1
C     &            *W(I,J,K)/(W(I,J,K)**2+0.05)
@


1.38
log
@mpi
@
text
@d9 2
a10 1
C                        
d71 2
a72 2
        MAXXS=4
        MAXSYM=0
d106 1
a106 1
             GOTO 999
d115 1
a115 1
             GOTO 999
d118 2
a119 3
       CALL WIW3DQ(NSAM,X,
     &              LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM)
       write(6,*) ' after WIW3DQ'
d123 1
a123 1
           ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
a129 1
       write(6,*) ' after cop'
a138 1
       write(6,*) ' after omp loop'
d173 1
a173 1
     &                     DM,NANG,SM,MAXSYM)
d180 1
a180 1
        REAL, DIMENSION(:,:), ALLOCATABLE :: PROJ
d182 1
a182 1
        REAL, DIMENSION(:,:,:), ALLOCATABLE :: W
d192 1
a192 1
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d234 3
a236 3
C	B0=(SQRT(ALPHA)**mmm)*BESSI(mmm,ALPHA)
	B0=SQRT(ALPHA)*BESI1(ALPHA)
        FLTB=REAL(LTAB)/REAL(LN2+1)
d241 2
a242 5
	      XX=SQRT(1.0-(S/AAAA)**2)
	      TABI(I)=
C(            SQRT(ALPHA*XX)**mmm)*BESSI(mmm,ALPHA*XX)/B0
C             TEMPO=
     &	      SQRT(ALPHA*XX)*BESI1(ALPHA*XX)/B0
d244 1
a244 1
	      TABI(I)=0.0
d250 2
a251 1
           CALL ERRT(46,'BP 3F, W,PROJ,BI',IER)
d256 3
a258 3
        DO    K=1,N
           DO    J=1,N
              DO    I=0,N2
d275 1
a275 1
        ALLOCATE(PSIZE(NPROCS),STAT=IRTFLG)
d277 1
a277 1
           CALL ERRT(46,'BP 3F, PSIZE',IER)
a279 5
        ALLOCATE(NBASE(NPROCS),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'BP 3F, NBASE',IER)
           RETURN
        ENDIF
d293 2
a294 1
           CALL ERRT(46,'BP 3F, PRJLOC',IER)
d371 1
d388 2
a389 2
           DO  J=1,N
              DO  I=0,N2
d394 3
a396 3
           DO  ISYM=1,MAXSYM
              IF(MAXSYM.GT.1)  THEN
C                symmetries, multiply matrices
d453 2
a454 2
           DO  J=1,N
              DO  I=0,N2
d460 1
a460 1
            IF(MAXSYM.GT.1)  THEN
d488 1
@


1.37
log
@removed unused old #ifdef NEVER code,  & cosmetic & mypid use
@
text
@a14 2
C *  THE CONTENTS OF THIS DOCUMENT CANNOT BE CHANGED WITHOUT WRITTEN
C *  PERMISSION OF THE AUTHOR                                        *
d40 2
a41 2
        include 'mpif.h'
        integer mypid, comm, ierr
d43 2
a44 2
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid, ierr)
d119 1
d130 2
d136 1
a136 1
                    X(I,J,K)=CMPLX(0.0,0.0)
d140 1
d148 1
d154 1
a154 2
        IF (MYPID .LE. 0) THEN 
           CALL OPFILEC(0,.TRUE.,FILNAM,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d156 1
a156 6
           IF (IRTFLG .NE. 0) GOTO 9997
        ENDIF

#ifdef USE_MPI
        if (mypid .gt. 0) ibcnt = ibcnt + 1
#endif
d205 4
a208 4
        include 'mpif.h'
        integer mypid, comm, ierr, nprocs
        integer istat(MPI_STATUS_SIZE)
        integer, allocatable, dimension(:) :: psize, nbase
d210 10
a219 9
        integer  nangloc, nrem, iproc, isam, jrow, jglb, jloc
        real   , allocatable, dimension(:,:,:) :: prjloc
        real   , allocatable, dimension(:,:,:) :: prjbuf
        real   , allocatable, dimension(:,:,:) :: Wloc
        complex, allocatable, dimension(:,:,:) :: Xloc

        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid , ierr)
        call MPI_COMM_SIZE(comm, nprocs, ierr)
d275 5
a279 5
c       Distribute particles to processors.
c       nangloc is the number of particles assigned
c       to each processor.
c      
        allocate(psize(nprocs),STAT=IRTFLG)
d281 1
a281 1
           CALL ERRT(46,'BP 3F, psize',IER)
d284 1
a284 1
        allocate(nbase(nprocs),STAT=IRTFLG)
d286 1
a286 1
           CALL ERRT(46,'BP 3F, nbase',IER)
d289 12
a300 11
c       
c       setpart returns the size of the local piece
c       and the global offset.
c 
        call setpart(nang, psize, nbase)
        nangloc = psize(mypid+1)
c
c       2-D images are distributed and held in prjloc
c       on each processor
c
        allocate(prjloc(NS,NS,nangloc),stat=irtflg)
d302 1
a302 1
           CALL ERRT(46,'BP 3F, prjloc',IER)
d305 25
a329 35
c
c       Processor 0 reads image files and distribute them.
c       (this version assumes that there is sufficient
c        memory to hold nang/nprocs images)
c
        if (mypid .eq. 0) then
c
c           Read images into the buffer first, then distributed 
c
            allocate(prjbuf(NS, NS, nangloc),stat=irtflg)
            IF (IRTFLG .NE. 0) THEN 
               CALL ERRT(46,'BP 3F, prjbuf',IER)
               RETURN
            ENDIF
            do iproc = 1, nprocs
               nangloc = psize(iproc)
c
c              read a bunch of 2-D images 
c
               do jloc = 1, nangloc
                  jglb = nbase(iproc) + jloc
                  CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(jglb),IRTFLG)
                  IF (IRTFLG .NE. 0) GOTO 999
                  MAXIM = 0
                  CALL OPFILEC(0      ,.FALSE., FINPIC, INPROJ, 'O'  ,
     &                         IFORM  , NSAM  , NSAM  , NSL   , MAXIM,
     &                         'DUMMY',.FALSE., IRTFLG)
                  IF (IRTFLG .NE. 0) GOTO 999
                  CALL READV(INPROJ,prjbuf(1,1,jloc),NS,NS,NS,NS,1)
                  CLOSE(INPROJ)
               enddo
c
               if (iproc .gt. 1) then
c
c                 Send to another processor
d331 3
a333 2
#ifdef            MPI_DEBUG
                  write(6,*) 'WIW3DQ: Sending to pid = ', iproc-1
d335 18
a352 33
                  call MPI_SEND(prjbuf , NS*NS*nangloc, MPI_REAL,
     &                          iproc-1, iproc-1          , comm    ,
     &                          ierr)
                  if (ierr .ne. 0) then
                     write(6,*) 'WIW3DQ: Send error!'
                     stop
                  endif
               else

c                 Keep for myself
                  do jloc = 1, nangloc
                     do isam = 1, NS
                        do jrow = 1, NS
                             prjloc(isam,jrow,jloc) 
     &                     = prjbuf(isam,jrow,jloc)
                        end do
                     end do
                  end do
               end if
            end do
            if (allocated(prjbuf)) deallocate(prjbuf)
        else

c         Receive projection images from processor 0

          call MPI_RECV(prjloc, NS*NS*nangloc, MPI_REAL,
     &                  0     , MPI_ANY_TAG      , comm    ,
     &                  istat , ierr)
          if (ierr .ne. 0) then
             write(6,*) 'WIW3DQ: recv failed'
             stop
          end if

d354 2
a355 2
          write(6,111) mypid
 111      format(1x,'WIW3DQ: mypid = ', I3, ' received!')
d357 14
a370 1
        end if 
d372 1
a372 1
c       Perform calculations in parallel now 
d374 1
a374 1
        ALLOCATE (Wloc(0:N2,N,N), Xloc(0:N2,N,N), STAT=IRTFLG)
d376 1
a376 1
           CALL ERRT(46,'BP 3F, Wloc, Xloc',IER)
d382 2
a383 2
                 Xloc(I,J,K)=CMPLX(0.0,0.0)
                 Wloc(I,J,K)=0.0
d388 4
a391 4
        nangloc = psize(mypid+1)
        do jloc = 1, nangloc
           jglb = nbase(mypid+1) + jloc
           CALL PADD2(prjloc(1,1,jloc),NS,BI,LSD,N)
d413 2
a414 1
        end do
d416 2
a417 2
c       Sum up X and W from the local pieces (Xloc, Wloc)
c       residing on each processor 
d419 15
a433 13
        call MPI_ALLREDUCE(Xloc   , X   , (N2+1)*N*N, MPI_COMPLEX,
     &                     MPI_SUM, comm, ierr)
        if ( ierr. ne. 0 ) then
           write(6,*) 'WIW3DQ: Failed to ALLREDUCE'
           stop
        end if
        call MPI_ALLREDUCE(Wloc   , W   , (N2+1)*N*N, MPI_REAL,
     &                     MPI_SUM, comm, ierr)
        if ( ierr. ne. 0 ) then
           write(6,*) 'WIW3DQ: Failed to ALLREDUCE'
           stop
        end if
        IF (ALLOCATED(Xloc))    DEALLOCATE (Xloc)
d436 1
a436 1
        write(6,*) 'WIW3DQ: Completed global sum, mypid = ', mypid
@


1.36
log
@maxxs for sym. doc file = 4
@
text
@d1 1
a1 1
#if 1
d30 1
a30 1
        REAL, DIMENSION(:,:), ALLOCATABLE :: DM,SM
d32 1
a32 1
        REAL, DIMENSION(:), ALLOCATABLE :: TEMP
d34 1
a34 1
        REAL, DIMENSION(:,:), POINTER :: ANGBUF, ANGSYM
d47 2
d60 3
a62 8
#ifdef USE_MPI
        if (mypid .eq. 0) then
           WRITE(NOUT,2001) NANG
        endif
#else
        WRITE(NOUT,2001) NANG
#endif
2001    FORMAT(' NUMBER OF IMAGES =',I5)
d151 1
a151 2
#ifdef USE_MPI
        if (mypid .eq. 0) then 
d155 4
a158 7
        else
           ibcnt = ibcnt + 1
        endif 
#else
        CALL OPFILEC(0,.TRUE.,FILNAM,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &           MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9997
d207 1
a207 1
c
d218 1
a218 1
c
d236 1
d241 1
a241 1
cc$omp parallel do private(i,s,x),shared(mmm)
d255 1
a255 1
        ALLOCATE (W(0:N2,N,N),PROJ(NS,NS),BI(0:N2,N), STAT=IRTFLG)
d261 1
a261 1
c$omp parallel do private(i,j,k)
d271 1
a271 1
#ifdef SP_MP
d275 1
a275 1
#ifdef USE_MPI
d341 2
a342 1
#ifdef MPI_DEBUG
d353 1
a353 1
c
a354 1
c
d367 1
a367 1
c
d369 1
a369 1
c
d377 2
a378 1
#ifdef MPI_DEBUG
d383 1
a383 1
c
d385 1
a385 1
c
d399 1
a399 1
c
d406 1
a406 1
c
d412 1
a412 1
c
d420 1
a420 1
c
d426 1
a426 1
c
d429 1
a429 1
c
d450 1
a450 1
        DO    K=1,NANG
d475 1
a475 1
           DO  ISYM=1,MAXSYM
d477 2
a478 2
C  symmetries, multiply matrices
             DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
d480 1
a480 1
             DMS=DM(:,:,K)
d482 2
a483 1
#ifdef SP_MP
d486 4
a489 4
c$omp parallel do private(j),shared(N,N2,JT,X,W,BI,DMS)
             DO J=-N2+JT,N2,LN1
              CALL ONELINE(J,N,N2,X,W,BI,DMS)
             ENDDO
d496 2
a497 5
C   END OF SYMMETRIES LOOP
           ENDDO
C
C          END OF PROJECTIONS LOOP
        ENDDO
d504 1
a511 321
#else

C++************************************************************************
C
C  WIW3D.F                                        01/11/00
C                                         
C **********************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
C **********************************************************************
C
C   WIW3D
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE WIW3D

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

        REAL, DIMENSION(:,:), ALLOCATABLE :: DM,SM
        COMPLEX, DIMENSION(:,:,:), ALLOCATABLE :: X
C       DOC FILE POINTERS
        REAL, DIMENSION(:,:), POINTER :: ANGBUF, ANGSYM

        COMMON /F_SPEC/ FINPAT,NLET,FINPIC
        CHARACTER*80    FINPIC,FINPAT,FILNAM,ANGDOC

        DATA  IOPIC/98/,INPIC/99/

        NILMAX = NIMAX

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,INUMBR,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        MAXNUM = MAXVAL(INUMBR(1:NANG))
        CLOSE(INPIC)

C       N    - LINEAR DIMENSION OF PROJECTIONS AND RESTORED CUBE
C       NANG - TOTAL NUMBER OF IMAGES
        WRITE(NOUT,2001) NANG
2001    FORMAT(' NUMBER OF IMAGES =',I5)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        MAXXT = 4
        MAXYT = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9998

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS=0
        MAXSYM=0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF(IRTFLG.NE.0)  MAXSYM=1

C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(1),INTFLG)

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)

        N2     = 2*NSAM
        LSD    = N2+2-MOD(N2,2)
        NMAT   = LSD*N2*N2

        ALLOCATE(DM(9,NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) CALL ERRT(46,'BP 3F, DM',9*NANG)

        CALL  BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),.FALSE.,SSDUM,IRTFLG)
        DEALLOCATE(ANGBUF)
        IF (IRTFLG .NE. 0) GOTO 9998

        IF (MAXSYM .GT. 1)  THEN
           ALLOCATE(SM(9,MAXSYM),X(0:N2/2,N2,N2), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, SM',9*MAXSYM)
              GOTO 9998
           ENDIF

           CALL  BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
        ELSE
           ALLOCATE(SM(1,1),X(0:N2/2,N2,N2), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, SM-2ND',N2*N2*N2+1)
               GOTO 9998
           ENDIF
        ENDIF

        CALL WIW3DQ(NSAM,X,LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM)

        IFORM = 3
        CALL OPFILEC(0,.TRUE.,FILNAM,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &           MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9997


C        NOTE: NSAM=NROW=NSLICE 
         CALL WRITEV(IOPIC,X,NSAM,NSAM,NSAM,NSAM,NSAM)


9997    CLOSE(IOPIC)

9998    IF (ALLOCATED(DM)) DEALLOCATE(DM)
        IF (ALLOCATED(SM)) DEALLOCATE(SM)
        IF (ALLOCATED(X))  DEALLOCATE(X)

        END



C       ------------------ WIW3DQ ----------------------------------

        SUBROUTINE  WIW3DQ(NS,X,LSD,N,N2,INUMBR,
     &                     DM,NANG,SM,MAXSYM)

        
        COMPLEX           X(0:N2,N,N)
        DIMENSION         INUMBR(NANG)
        DIMENSION         DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)

        REAL, DIMENSION(:,:), ALLOCATABLE :: PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(:,:,:), ALLOCATABLE :: W

        CHARACTER*80      FINPIC,FINPAT
        COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
        DOUBLE PRECISION  PI
        PARAMETER         (LTAB=4999)
        COMMON  /TABS/    LN2,FLTB,TABI(0:LTAB)

        DATA  INPROJ/99/

        LN=5
        LN2=LN/2
        PI=4.0D0*DATAN(1.0D0)
        SIG=3.0/PI
        SIG2=SIG*SIG
C       SIGMA IN REAL SPACE
        SIR=REAL(N)/(2.0*PI*SIG)

        TNR=DSQRT(2.0D0*PI)*SIG

C       GENERATE TABLE WITH INTERPOLANTS
        FLTB=REAL(LTAB)/REAL(LN2+1)
c$omp   parallel do private(i)
        DO  I=0,LTAB
           TABI(I)=EXP(-0.5*((REAL(I)/FLTB)**2)/SIG2)/TNR
        ENDDO

        ALLOCATE (W(0:N2,N,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, W',IER)
           RETURN
        ENDIF
        
c$omp   parallel do private(i,j,k)
        DO    K=1,N
           DO    J=1,N
              DO    I=0,N2
                 X(I,J,K)=CMPLX(0.0,0.0)
                 W(I,J,K)=0.0
              ENDDO
           ENDDO
        ENDDO


        ALLOCATE (PROJ(NS,NS), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, PROJ',IER)
           DEALLOCATE (W)
           RETURN
        ENDIF

        ALLOCATE (BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, BI',IER)
           DEALLOCATE (W)
           DEALLOCATE (PROJ)
        ENDIF

        DO    K=1,NANG
C          PRINT  *,' PROJECTION #',K

C          OPEN DESIRED FILE
           CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(K),IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPROJ,'O',IFORM,NSAM,NSAM,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           DO J=1,NS
              CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
           ENDDO
           CLOSE(INPROJ)

           CALL PADD2(PROJ,NS,BI,LSD,N)
           INV = +1
           CALL FMRS_2(BI,N,N,INV)
c$omp      parallel do private(i,j)
           DO  J=1,N
              DO  I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO
C
           DO  ISYM=1,MAXSYM
            IF(MAXSYM.GT.1)  THEN
C              symmetries, multiply matrices
               DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
            ELSE
               DMS=DM(:,:,K)
            ENDIF
c$omp parallel do private(j),shared(N,N2,X,W,BI,DM),schedule(static)
            DO J=-N2+1,N2
              CALL ONELINE(J,N,N2,X,W,BI,DMS)
            ENDDO
C          END OF SYMMETRIES LOOP
           ENDDO

C          END OF PROJECTIONS LOOP
        ENDDO
C       SYMMETRIZE PLANE 0
        DO  IZA=2,N2
           DO  IYA=2,N2
              X(0,IYA,IZA)=X(0,IYA,IZA)+CONJG(X(0,N-IYA+2,N-IZA+2))
              W(0,IYA,IZA)=W(0,IYA,IZA)+W(0,N-IYA+2,N-IZA+2)
              X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
              W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
              X(0,N-IYA+2,IZA)=X(0,N-IYA+2,IZA)+CONJG(X(0,IYA,N-IZA+2))
              W(0,N-IYA+2,IZA)=W(0,N-IYA+2,IZA)+W(0,IYA,N-IZA+2)
              X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
              W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
           ENDDO
        ENDDO
        DO  IYA=2,N2
           X(0,IYA,1)=X(0,IYA,1)+CONJG(X(0,N-IYA+2,1))
           W(0,IYA,1)=W(0,IYA,1)+W(0,N-IYA+2,1)
           X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
           W(0,N-IYA+2,1)=W(0,IYA,1)
        ENDDO
        DO  IZA=2,N2
           X(0,1,IZA)=X(0,1,IZA)+CONJG(X(0,1,N-IZA+2))
           W(0,1,IZA)=W(0,1,IZA)+W(0,1,N-IZA+2)
           X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
           W(0,1,N-IZA+2)=W(0,1,IZA)
        ENDDO

        CALL NRMW2(X,W,N2,N)
        CALL WIND2(X,X,NS,LSD,N,SIR)
        DEALLOCATE (W,PROJ,BI)
        END


C       ------------------- WIND2 -------------------------------

        SUBROUTINE WIND2(BI,R,L,LSD,N,SIR)

        DIMENSION  R(L,L,L),BI(LSD,N,N)

        TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
        IP=(N-L)/2+MOD(L,2)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 R(I,J,K)=BI(IP+I,IP+J,IP+K)*TNR
              ENDDO
           ENDDO
        ENDDO
        L2=(L/2)**2
        L2P=(L/2-1)**2
        IP=L/2+1
        S2=1.0/(2*SIR*SIR)
        TNR=0.0
        M=0
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR.LE.L2) THEN
                    R(I,J,K) = R(I,J,K)/EXP(-LR*S2)
                    IF(LR.GE.L2P .AND. LR.LE.L2) THEN
                       TNR=TNR+R(I,J,K)
                       M=M+1
                    ENDIF
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        TNR=TNR/REAL(M)
c$omp   parallel do private(i,j,k,lr)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF(LR.LE.L2) THEN
                    R(I,J,K)=R(I,J,K)-TNR
                 ELSE
                    R(I,J,K)=0.0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END

a512 1
#endif
d536 1
d545 1
d548 1
a548 1
        SUBROUTINE  NRMW2(R,W,N2,N)
d558 1
a558 1
		  R(I,J,K)=R(I,J,K)*(-1)**(I+J+K)/W(I,J,K)
d560 1
a560 1
		  R(I,J,K)=(0.0,0.0)
d566 1
d568 1
a568 1
        CALL  FMRS_3(R,N,N,N,INV)
@


1.35
log
@buildm parameters changed
@
text
@d75 1
a75 1
        MAXXS=0
@


1.34
log
@mpi
@
text
@d8 1
d100 2
a101 1
        CALL  BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),.FALSE.,SSDUM,IRTFLG)
@


1.33
log
@reang --> buildm (incorporating cang call)
@
text
@d40 7
d57 5
d63 1
a119 1

d152 9
d164 1
d205 24
d278 175
d503 2
@


1.32
log
@opfilec
@
text
@d5 1
a5 1
C              Replaced Bessel functions
d7 2
a8 1
C                                         
d11 2
a12 3
C *  WIW3D.f
C *  COPYRIGHT (C)2002, P.A.Penczek
C *  University of Texas - Houston Medical School
d14 2
a15 2
C *    THE CONTENTS OF THIS DOCUMENT CANNOT BE CHANGED WITHOUT WRITTEN
C *    PERMISSION OF THE AUTHOR                          *
d82 2
a83 1
           CALL ERRT(46,'BP 3F, DM',IER)
d85 2
a86 1
        CALL  BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
d90 3
a92 2
        IF(MAXSYM.GT.1)  THEN
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
d94 2
a95 2
              CALL ERRT(46,'BP 3F, SM',IER)
              DEALLOCATE (DM)
d97 1
d101 1
a101 1
           ALLOCATE(SM(1,1), STAT=IRTFLG)
d103 2
a104 2
              CALL ERRT(46,'BP 3F, SM-2nd',IER)
              DEALLOCATE (DM)
a107 6
        ALLOCATE (X(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, X',IER)
           DEALLOCATE (DM, SM)
        ENDIF

d111 15
a125 13
C  Additional symmetrization of the volume in real space 05/03/02
	IF(MAXSYM.GT.1)  THEN
        ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, TEMP',IER)
           DEALLOCATE (DM, SM, X)
        ENDIF
	CALL COP(X,TEMP,NSAM*NSAM*NSAM)
c$omp parallel do private(i,j,k)
        DO    K=1,N2
           DO    J=1,N2
              DO    I=0,N2/2
                 X(I,J,K)=CMPLX(0.0,0.0)
a127 1
        ENDDO
d135 2
a136 2
	CALL SYMVOL(TEMP,X,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	DEALLOCATE(TEMP)
d144 1
a144 3
C        NOTE: NSAM=NROW=NSLICE 

         CALL WRITEV(IOPIC,X,NSAM,NSAM,NSAM,NSAM,NSAM)
d146 1
d182 2
a183 1
C K=6
d186 2
a187 2
C Generalized Kaiser-Bessel window according to Lewitt
C M=NS, N=N
d200 11
a210 11
        DO  I=0,LTAB
	 S=REAL(I)/FLTB/N
	 IF(S.LE.AAAA)  THEN
	  XX=SQRT(1.0-(S/AAAA)**2)
	  TABI(I)=
C(SQRT(ALPHA*XX)**mmm)*BESSI(mmm,ALPHA*XX)/B0
CTEMPO=
     &		SQRT(ALPHA*XX)*BESI1(ALPHA*XX)/B0
	 ELSE
	  TABI(I)=0.0
	 ENDIF
d249 2
a250 1
c$omp parallel do private(i,j)
d256 1
a256 1
C
d371 3
a373 2
        IF (IRTFLG.NE.0) CALL ERRT(46,'BP 3F, DM',IER)
        CALL  BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
d377 2
a378 2
        IF(MAXSYM.GT.1)  THEN
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
d380 2
a381 2
              CALL ERRT(46,'BP 3F, SM',IER)
              DEALLOCATE (DM)
d383 1
d387 1
a387 1
           ALLOCATE(SM(1,1), STAT=IRTFLG)
d389 2
a390 2
              CALL ERRT(46,'BP 3F, SM-2nd',IER)
              DEALLOCATE (DM)
d394 1
a394 8
        ALLOCATE (X(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, X',IER)
           DEALLOCATE (DM, SM)
        ENDIF

       CALL WIW3DQ(NSAM,X,
     &              LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM)
a402 1

d407 5
a411 2
        DEALLOCATE(DM)
9998    DEALLOCATE(SM,X)
d636 1
d655 4
a658 4
        DO  K=1,N
           DO  J=1,N
              DO  I=0,N2
                IF(W(I,J,K).GT.0.1)  THEN
@


1.31
log
@corrected sym
@
text
@d4 3
a6 1
C  WIW3D.F                                        05/03/02
a19 3
C IMAGE_PROCESSING_ROUTINE
C
C        1         2         3         4         5         6         7
d22 1
a22 1
C Replaced Bessel functions
d71 1
a71 1
        CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAM,NROW,NSL,
d141 1
a141 1
        CALL OPFIL(.TRUE.,FILNAM,IOPIC,'U',NSAM,NSAM,NSAM,
a144 1

d240 1
a240 1
           CALL OPFIL(.FALSE.,FINPIC,INPROJ,'O',NSAM,NSAM,NSL,
a309 3
C IMAGE_PROCESSING_ROUTINE
C
C        1         2         3         4         5         6         7
a314 1

d361 1
a361 1
        CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAM,NROW,NSL,
d402 1
a402 1
        CALL OPFIL(.TRUE.,FILNAM,IOPIC,'U',NSAM,NSAM,NSAM,
d453 1
a453 1
c$omp parallel do private(i)
d464 1
a464 1
c$omp parallel do private(i,j,k)
a481 2


d497 1
a497 1
           CALL OPFIL(.FALSE.,FINPIC,INPROJ,'O',NSAM,NSAM,NSL,
a500 2
 

d509 1
a509 1
c$omp parallel do private(i,j)
d518 2
a519 2
C  symmetries, multiply matrices
             DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
d521 1
a521 1
             DMS=DM(:,:,K)
d527 1
a527 1
C   END OF SYMMETRIES LOOP
d529 1
a529 1
C
d601 1
a601 1
c$omp parallel do private(i,j,k,lr)
d633 1
a633 1
c$omp parallel do private(i,j)
d641 1
a641 1
c$omp parallel do private(i,j)
d656 1
a656 1
c$omp parallel do private(i,j,k)
@


1.30
log
@cosmetic
@
text
@d1 1
a1 1

d4 2
a5 3
C  WIW3D.F   
C                  REPLACED BESSEL FUNCTIONS  05/03/02 pp              
C                                
d8 1
a8 1
C *  WIW3D.F
d10 1
a10 1
C *  UNIVERSITY OF TEXAS - HOUSTON MEDICAL SCHOOL
d20 1
d23 1
a23 1

d52 1
a52 1
2001    FORMAT(' NUMBER OF IMAGES:',I7)
d62 2
a63 2
        MAXXS  = 0
        MAXSYM = 0
d66 1
a66 1
        IF (IRTFLG .NE. 0)  MAXSYM=1
d74 1
a74 1
        IF (IRTFLG .NE. 0) GOTO 999
a83 1
           GOTO 999
d85 1
a85 1
        CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
d89 1
a89 1
        IF (MAXSYM .GT. 1)  THEN
d91 1
a91 1
           IF (IRTFLG .NE. 0) THEN 
d93 1
a93 1
              GOTO 999
d101 1
a101 1
              GOTO 999
d108 1
a108 1
           GOTO 999
d111 2
a112 1
        CALL WIW3DQ(NSAM,X,LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM)
d114 13
a126 14
C       Additional symmetrization of the volume in real space 05/03/02
	IF (MAXSYM .GT. 1)  THEN
           ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, TEMP',IER)
              GOTO 999
           ENDIF
	   CALL COP(X,TEMP,NSAM*NSAM*NSAM)
c$omp      parallel do private(i,j,k)
           DO K=1,N
              DO J=1,N
                 DO I=0,N2/2
                    X(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
d129 1
d137 2
a138 2
	   CALL SYMVOL(TEMP,X,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	   DEALLOCATE(TEMP)
d146 2
a147 2
C       NOTE: NSAM=NROW=NSLICE 
        CALL WRITEV(IOPIC,X,NSAM,NSAM,NSAM,NSAM,NSAM)
d149 1
d151 1
d154 3
a156 4
999     IF (ALLOCATED(DM))      DEALLOCATE(DM)
        IF (ALLOCATED(SM))      DEALLOCATE(SM)
        IF (ALLOCATED(X))       DEALLOCATE(X)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
d189 2
a190 2
C       Generalized Kaiser-Bessel window according to Lewitt
C       M=NS, N=N
d194 4
a197 4
C	AAAA = 0.0079
	AAAA = 0.9*V
	NNN  = 3
C	mmm  = 1
d199 4
a202 4
C	B0   = (SQRT(ALPHA)**mmm)*BESSI(mmm,ALPHA)
	B0   = SQRT(ALPHA)*BESI1(ALPHA)
        FLTB = REAL(LTAB)/REAL(LN2+1)
cc$omp  parallel do private(i,s,x),shared(mmm)
d204 10
a213 10
	   S = REAL(I)/FLTB/N
	   IF (S .LE. AAAA)  THEN
	     XX     = SQRT(1.0-(S/AAAA)**2)
	     TABI(I) = SQRT(ALPHA*XX)*BESI1(ALPHA*XX)/B0

C	     TABI(I) = (SQRT(ALPHA*XX)**mmm)*BESSI(mmm,ALPHA*XX)/B0
C            TEMPO   = SQRT(ALPHA*XX)*BESI1(ALPHA*XX)/B0
	   ELSE
	     TABI(I)=0.0
	   ENDIF
d222 4
a225 4
c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=0,N2
d233 1
a233 1
	LN1 = LN+1
d235 2
a236 2
        DO K=1,NANG
C          PRINT  *,' PROJECTION #:',K
d252 1
a252 1
c$omp      parallel do private(i,j)
d260 2
a261 2
            IF (MAXSYM .GT. 1)  THEN
C              symmetries, multiply matrices
d268 5
a272 5
C             ,schedule(static)
c$omp         parallel do private(j),shared(N,N2,JT,X,W,BI,DM)
              DO J=-N2+JT,N2,LN1
                 CALL ONELINE(J,N,N2,X,W,BI,DMS)
              ENDDO
d279 1
a279 1
C          END OF SYMMETRIES LOOP
d281 1
a281 1

a283 1

a287 1

d295 334
d643 1
a643 1
c$omp   parallel do private(i,j)
a648 1

d651 1
a651 1
c$omp   parallel do private(i,j)
a658 1

d666 1
a666 1
c$omp   parallel do private(i,j,k)
a678 1

d683 2
@


1.29
log
@*** empty log message ***
@
text
@d1 1
a1 1
#if 1
d4 3
a6 2
C  WIW3D.F                                        05/03/02
C                                         
d9 1
a9 1
C *  WIW3D.f
d11 1
a11 1
C *  University of Texas - Houston Medical School
a20 1
C        1         2         3         4         5         6         7
d23 1
a23 1
C Replaced Bessel functions
d52 1
a52 1
2001    FORMAT(' NUMBER OF IMAGES =',I5)
d62 2
a63 2
        MAXXS=0
        MAXSYM=0
d66 1
a66 1
        IF(IRTFLG.NE.0)  MAXSYM=1
d74 1
a74 1
        IF (IRTFLG .NE. 0) RETURN
d84 1
d86 1
a86 1
        CALL  BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
d90 1
a90 1
        IF(MAXSYM.GT.1)  THEN
d92 1
a92 1
           IF (IRTFLG.NE.0) THEN 
d94 1
a94 1
              DEALLOCATE (DM)
d102 1
a102 1
              DEALLOCATE (DM)
d109 1
a109 1
           DEALLOCATE (DM, SM)
d112 1
a112 2
       CALL WIW3DQ(NSAM,X,
     &              LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM)
d114 14
a127 13
C  Additional symmetrization of the volume in real space 05/03/02
	IF(MAXSYM.GT.1)  THEN
        ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, TEMP',IER)
           DEALLOCATE (DM, SM, X)
        ENDIF
	CALL COP(X,TEMP,NSAM*NSAM*NSAM)
c$omp parallel do private(i,j,k)
        DO    K=1,N
           DO    J=1,N
              DO    I=0,N2/2
                 X(I,J,K)=CMPLX(0.0,0.0)
a129 1
        ENDDO
d137 2
a138 2
	CALL SYMVOL(TEMP,X,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	DEALLOCATE(TEMP)
d146 2
a147 2

C        NOTE: NSAM=NROW=NSLICE 
a148 1
         CALL WRITEV(IOPIC,X,NSAM,NSAM,NSAM,NSAM,NSAM)
a149 1

d152 4
a155 3
999     IF (ALLOCATED(DM)) DEALLOCATE(DM)
        IF (ALLOCATED(SM)) DEALLOCATE(SM)
        IF (ALLOCATED(X))  DEALLOCATE(X)
d188 2
a189 2
C Generalized Kaiser-Bessel window according to Lewitt
C M=NS, N=N
d193 4
a196 4
C	AAAA=0.0079
	AAAA=0.9*V
	NNN=3
C	mmm=1
d198 4
a201 4
C	B0=(SQRT(ALPHA)**mmm)*BESSI(mmm,ALPHA)
	B0=SQRT(ALPHA)*BESI1(ALPHA)
        FLTB=REAL(LTAB)/REAL(LN2+1)
cc$omp parallel do private(i,s,x),shared(mmm)
d203 10
a212 10
	 S=REAL(I)/FLTB/N
	 IF(S.LE.AAAA)  THEN
	  XX=SQRT(1.0-(S/AAAA)**2)
	  TABI(I)=
C(SQRT(ALPHA*XX)**mmm)*BESSI(mmm,ALPHA*XX)/B0
CTEMPO=
     &		SQRT(ALPHA*XX)*BESI1(ALPHA*XX)/B0
	 ELSE
	  TABI(I)=0.0
	 ENDIF
d221 4
a224 4
c$omp parallel do private(i,j,k)
        DO    K=1,N
           DO    J=1,N
              DO    I=0,N2
d232 1
a232 1
	LN1=LN+1
d234 2
a235 2
        DO    K=1,NANG
C          PRINT  *,' PROJECTION #',K
d251 1
a251 1
c$omp parallel do private(i,j)
d259 2
a260 2
            IF(MAXSYM.GT.1)  THEN
C  symmetries, multiply matrices
d267 5
a271 5
C,schedule(static)
c$omp parallel do private(j),shared(N,N2,JT,X,W,BI,DM)
             DO J=-N2+JT,N2,LN1
              CALL ONELINE(J,N,N2,X,W,BI,DMS)
             ENDDO
d278 1
a278 1
C   END OF SYMMETRIES LOOP
d280 1
a280 1
C
d283 1
d288 1
a295 332
#else

C++************************************************************************
C
C  WIW3D.F                                        01/11/00
C                                         
C **********************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
C **********************************************************************
C
C   WIW3D
C
C IMAGE_PROCESSING_ROUTINE
C
C        1         2         3         4         5         6         7
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE WIW3D


        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

        REAL, DIMENSION(:,:), ALLOCATABLE :: DM,SM
        COMPLEX, DIMENSION(:,:,:), ALLOCATABLE :: X
C       DOC FILE POINTERS
        REAL, DIMENSION(:,:), POINTER :: ANGBUF, ANGSYM

        COMMON /F_SPEC/ FINPAT,NLET,FINPIC
        CHARACTER*80    FINPIC,FINPAT,FILNAM,ANGDOC

        DATA  IOPIC/98/,INPIC/99/

        NILMAX = NIMAX

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,INUMBR,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        MAXNUM = MAXVAL(INUMBR(1:NANG))
        CLOSE(INPIC)

C       N    - LINEAR DIMENSION OF PROJECTIONS AND RESTORED CUBE
C       NANG - TOTAL NUMBER OF IMAGES
        WRITE(NOUT,2001) NANG
2001    FORMAT(' NUMBER OF IMAGES =',I5)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        MAXXT = 4
        MAXYT = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9998

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS=0
        MAXSYM=0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF(IRTFLG.NE.0)  MAXSYM=1

C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(1),INTFLG)

        MAXIM = 0
        CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)

        N2     = 2*NSAM
        LSD    = N2+2-MOD(N2,2)
        NMAT   = LSD*N2*N2

        ALLOCATE(DM(9,NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) CALL ERRT(46,'BP 3F, DM',IER)
        CALL  BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
        DEALLOCATE(ANGBUF)
        IF (IRTFLG .NE. 0) GOTO 9998

        IF(MAXSYM.GT.1)  THEN
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, SM',IER)
              DEALLOCATE (DM)
           ENDIF
           CALL  BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
        ELSE
           ALLOCATE(SM(1,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, SM-2nd',IER)
              DEALLOCATE (DM)
           ENDIF
        ENDIF

        ALLOCATE (X(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, X',IER)
           DEALLOCATE (DM, SM)
        ENDIF

       CALL WIW3DQ(NSAM,X,
     &              LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM)

        IFORM = 3
        CALL OPFIL(.TRUE.,FILNAM,IOPIC,'U',NSAM,NSAM,NSAM,
     &           MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9997


C        NOTE: NSAM=NROW=NSLICE 

         CALL WRITEV(IOPIC,X,NSAM,NSAM,NSAM,NSAM,NSAM)


9997    CLOSE(IOPIC)
        DEALLOCATE(DM)
9998    DEALLOCATE(SM,X)
        END



C       ------------------ WIW3DQ ----------------------------------

        SUBROUTINE  WIW3DQ(NS,X,LSD,N,N2,INUMBR,
     &                     DM,NANG,SM,MAXSYM)

        
        COMPLEX           X(0:N2,N,N)
        DIMENSION         INUMBR(NANG)
        DIMENSION         DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)

        REAL, DIMENSION(:,:), ALLOCATABLE :: PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(:,:,:), ALLOCATABLE :: W

        CHARACTER*80      FINPIC,FINPAT
        COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
        DOUBLE PRECISION  PI
        PARAMETER         (LTAB=4999)
        COMMON  /TABS/    LN2,FLTB,TABI(0:LTAB)

        DATA  INPROJ/99/

        LN=5
        LN2=LN/2
        PI=4.0D0*DATAN(1.0D0)
        SIG=3.0/PI
        SIG2=SIG*SIG
C       SIGMA IN REAL SPACE
        SIR=REAL(N)/(2.0*PI*SIG)

        TNR=DSQRT(2.0D0*PI)*SIG

C       GENERATE TABLE WITH INTERPOLANTS
        FLTB=REAL(LTAB)/REAL(LN2+1)
c$omp parallel do private(i)
        DO  I=0,LTAB
           TABI(I)=EXP(-0.5*((REAL(I)/FLTB)**2)/SIG2)/TNR
        ENDDO

        ALLOCATE (W(0:N2,N,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, W',IER)
           RETURN
        ENDIF
        
c$omp parallel do private(i,j,k)
        DO    K=1,N
           DO    J=1,N
              DO    I=0,N2
                 X(I,J,K)=CMPLX(0.0,0.0)
                 W(I,J,K)=0.0
              ENDDO
           ENDDO
        ENDDO


        ALLOCATE (PROJ(NS,NS), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, PROJ',IER)
           DEALLOCATE (W)
           RETURN
        ENDIF



        ALLOCATE (BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, BI',IER)
           DEALLOCATE (W)
           DEALLOCATE (PROJ)
        ENDIF

        DO    K=1,NANG
C          PRINT  *,' PROJECTION #',K

C          OPEN DESIRED FILE
           CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(K),IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           MAXIM = 0
           CALL OPFIL(.FALSE.,FINPIC,INPROJ,'O',NSAM,NSAM,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

 

           DO J=1,NS
              CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
           ENDDO
           CLOSE(INPROJ)

           CALL PADD2(PROJ,NS,BI,LSD,N)
           INV = +1
           CALL FMRS_2(BI,N,N,INV)
c$omp parallel do private(i,j)
           DO  J=1,N
              DO  I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO
C
           DO  ISYM=1,MAXSYM
            IF(MAXSYM.GT.1)  THEN
C  symmetries, multiply matrices
             DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
            ELSE
             DMS=DM(:,:,K)
            ENDIF
c$omp parallel do private(j),shared(N,N2,X,W,BI,DM),schedule(static)
            DO J=-N2+1,N2
              CALL ONELINE(J,N,N2,X,W,BI,DMS)
            ENDDO
C   END OF SYMMETRIES LOOP
           ENDDO
C
C          END OF PROJECTIONS LOOP
        ENDDO
C       SYMMETRIZE PLANE 0
        DO  IZA=2,N2
           DO  IYA=2,N2
              X(0,IYA,IZA)=X(0,IYA,IZA)+CONJG(X(0,N-IYA+2,N-IZA+2))
              W(0,IYA,IZA)=W(0,IYA,IZA)+W(0,N-IYA+2,N-IZA+2)
              X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
              W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
              X(0,N-IYA+2,IZA)=X(0,N-IYA+2,IZA)+CONJG(X(0,IYA,N-IZA+2))
              W(0,N-IYA+2,IZA)=W(0,N-IYA+2,IZA)+W(0,IYA,N-IZA+2)
              X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
              W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
           ENDDO
        ENDDO
        DO  IYA=2,N2
           X(0,IYA,1)=X(0,IYA,1)+CONJG(X(0,N-IYA+2,1))
           W(0,IYA,1)=W(0,IYA,1)+W(0,N-IYA+2,1)
           X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
           W(0,N-IYA+2,1)=W(0,IYA,1)
        ENDDO
        DO  IZA=2,N2
           X(0,1,IZA)=X(0,1,IZA)+CONJG(X(0,1,N-IZA+2))
           W(0,1,IZA)=W(0,1,IZA)+W(0,1,N-IZA+2)
           X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
           W(0,1,N-IZA+2)=W(0,1,IZA)
        ENDDO

        CALL NRMW2(X,W,N2,N)
        CALL WIND2(X,X,NS,LSD,N,SIR)
        DEALLOCATE (W,PROJ,BI)
        END


C       ------------------- WIND2 -------------------------------

        SUBROUTINE WIND2(BI,R,L,LSD,N,SIR)

        DIMENSION  R(L,L,L),BI(LSD,N,N)

        TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
        IP=(N-L)/2+MOD(L,2)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 R(I,J,K)=BI(IP+I,IP+J,IP+K)*TNR
              ENDDO
           ENDDO
        ENDDO
        L2=(L/2)**2
        L2P=(L/2-1)**2
        IP=L/2+1
        S2=1.0/(2*SIR*SIR)
        TNR=0.0
        M=0
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR.LE.L2) THEN
                    R(I,J,K) = R(I,J,K)/EXP(-LR*S2)
                    IF(LR.GE.L2P .AND. LR.LE.L2) THEN
                       TNR=TNR+R(I,J,K)
                       M=M+1
                    ENDIF
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        TNR=TNR/REAL(M)
c$omp parallel do private(i,j,k,lr)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF(LR.LE.L2) THEN
                    R(I,J,K)=R(I,J,K)-TNR
                 ELSE
                    R(I,J,K)=0.0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END

a296 1
#endif
d310 1
a310 1
c$omp parallel do private(i,j)
d316 1
d319 1
a319 1
c$omp parallel do private(i,j)
d327 1
d335 1
a335 1
c$omp parallel do private(i,j,k)
d348 1
@


1.28
log
@changed ||
@
text
@a628 115

C       --------------------- ONELINE ---------------------------------

        SUBROUTINE  ONELINE(J,N,N2,X,W,BI,DM)

        DIMENSION      W(0:N2,N,N)
        COMPLEX        BI(0:N2,N),X(0:N2,N,N),BTQ
        DIMENSION      DM(6)
        PARAMETER      (LTAB=4999)
        COMMON  /TABS/ LN2,FLTB,TABI(0:LTAB)

        IF (J .GE. 0)  THEN
           JP=J+1
        ELSE
           JP=N+J+1
        ENDIF

        DO  I=0,N2
           IF ((I*I+J*J.LT.N*N/4).AND..NOT.(I.EQ.0.AND.J.LT.0))  THEN
              XNEW=I*DM(1)+J*DM(4)
              YNEW=I*DM(2)+J*DM(5)
              ZNEW=I*DM(3)+J*DM(6)
              IF (XNEW.LT.0.0)  THEN
                 XNEW=-XNEW
                 YNEW=-YNEW
                 ZNEW=-ZNEW
                 BTQ=CONJG(BI(I,JP))
              ELSE
                 BTQ=BI(I,JP)
              ENDIF
              IXN=IFIX(XNEW+0.5+N)-N
              IYN=IFIX(YNEW+0.5+N)-N
              IZN=IFIX(ZNEW+0.5+N)-N
              IF (IXN.LE.N2-LN2-1 .AND.
     &        IYN.GE.-N2+2+LN2.AND.IYN.LE.N2-LN2-1 .AND.
     &        IZN.GE.-N2+2+LN2.AND.IZN.LE.N2-LN2-1) THEN
                 IF (IXN.GE.0) THEN
C                   MAKE SURE THAT LOWER LIMIT FOR X DOES NOT GO BELOW 0
                    LB=-MIN0(IXN,LN2)
                    DO LZ=-LN2,LN2
                       IZP=IZN+LZ
                       IF(IZP.GE.0) THEN
                          IZA=IZP+1
                       ELSE
                          IZA=N+IZP+1
                       ENDIF
                       TZ = TABI(NINT(ABS(ZNEW-IZP)*FLTB))
           	       IF(TZ.NE.0.0)  THEN
                       DO  LY=-LN2,LN2
                          IYP=IYN+LY
                          IF (IYP.GE.0) THEN
                             IYA=IYP+1
                          ELSE
                             IYA=N+IYP+1
                          ENDIF
                          TY = TABI(NINT(ABS(YNEW-IYP)*FLTB))*TZ
           		  IF(TY.NE.0.0)  THEN
                          DO  LX=LB,LN2
                             IXP=IXN+LX
C                            GET THE WEIGHT
C                            WG=FINF(XNEW,YNEW,ZNEW,IXT,IYT,IZT)
                             WG=TABI(NINT(ABS(XNEW-IXP)*FLTB))*TY
			     IF(WG.NE.0.0)  THEN
                              X(IXP,IYA,IZA)=X(IXP,IYA,IZA)+BTQ*WG
                              W(IXP,IYA,IZA)=W(IXP,IYA,IZA)+WG
			     ENDIF
                          ENDDO
			  ENDIF
                       ENDDO
		       ENDIF
                   ENDDO
                ENDIF

C               ADD REFLECTED POINTS
                IF (IXN .LT. LN2) THEN
                   DO  LZ=-LN2,LN2
                      IZP=IZN+LZ
                      IF (IZP.GT.0)  THEN
                         IZT=N-IZP+1
                      ELSE
                         IZT=-IZP+1
                      ENDIF
                      TZ=TABI(NINT(ABS(ZNEW-IZP)*FLTB))
C
           	      IF(TZ.NE.0.0)  THEN
                      DO  LY=-LN2,LN2
                         IYP=IYN+LY
                         IF (IYP.GT.0) THEN
                            IYT=N-IYP+1
                         ELSE
                            IYT=-IYP+1
                         ENDIF
                         TY=TABI(NINT(ABS(YNEW-IYP)*FLTB))*TZ
			 IF(WG.NE.0.0)  THEN
                         DO  LX=-LN2,-1-IXN
                            IXP=IXN+LX
C                           GET THE WEIGHT
C                           WG=FINF(XNEW,YNEW,ZNEW,IXT,IYT,IZT)
                            WG=TABI(NINT(ABS(XNEW-IXP)*FLTB))*TY
			    IF(WG.NE.0.0)  THEN
                          X(-IXP,IYT,IZT)=X(-IXP,IYT,IZT)+CONJG(BTQ)*WG
                            W(-IXP,IYT,IZT)=W(-IXP,IYT,IZT)+WG
			    ENDIF
                         ENDDO
			 ENDIF
                      ENDDO
		      ENDIF
                   ENDDO
                ENDIF
              ENDIF
           ENDIF
C          END J-I LOOP
        ENDDO

        END
@


1.27
log
@ilist changed
@
text
@a25 1

a42 1
	PRINT *,'  BESSEL'
d59 1
a59 1
        IF (IRTFLG .NE. 0) GOTO 9998
d87 1
a87 1
        IF (IRTFLG .NE. 0) GOTO 9998
d153 5
a157 2
        DEALLOCATE(DM)
9998    DEALLOCATE(SM,X)
d179 1
a179 1
        PARAMETER         (LTAB=5000)
d216 3
a218 3
        ALLOCATE (W(0:N2,N,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, W',IER)
d232 3
a234 17

        ALLOCATE (PROJ(NS,NS), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, PROJ',IER)
           DEALLOCATE (W)
           RETURN
        ENDIF



        ALLOCATE (BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, BI',IER)
           DEALLOCATE (W)
           DEALLOCATE (PROJ)
        ENDIF

d240 1
a240 2
           IF (IRTFLG .NE. 0) RETURN

d244 1
a244 1
           IF (IRTFLG .NE. 0) RETURN
d246 1
a246 5
 

           DO J=1,NS
              CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
           ENDDO
d266 9
a274 1
c$omp parallel do private(j),shared(N,N2,X,W,BI,DM),schedule(static)
d278 1
d287 5
a291 2
        CALL WINDKB2(X,X,NS,LSD,N,SIR)
        DEALLOCATE (W, PROJ, BI)
d442 1
a442 1
        PARAMETER         (LTAB=5000)
d570 1
a570 3
        DEALLOCATE (W)
        DEALLOCATE(PROJ)
        DEALLOCATE (BI)
d637 1
a637 1
        PARAMETER      (LTAB=5000)
@


1.26
log
@corrected normalization
@
text
@a30 1
        INTEGER, ALLOCATABLE, DIMENSION(:) :: ILIST
d44 2
a45 7
        ALLOCATE (ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, ILIST',IER)
           RETURN
        ENDIF

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NANG,
d47 1
a47 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(ILIST)
           RETURN
        ENDIF
d49 1
a49 1
        MAXNUM = MAXVAL(ILIST(1:NANG))
d71 1
a71 1
        CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
a85 1
           DEALLOCATE (ILIST)
d87 1
a87 1
        CALL  BUILDM(ILIST,DM,NANG,ANGBUF(1,1),IRTFLG)
d95 1
a95 1
              DEALLOCATE (ILIST,DM)
d103 1
a103 1
              DEALLOCATE (ILIST,DM)
d110 1
a110 1
           DEALLOCATE (ILIST, DM, SM)
d114 1
a114 1
     &              LSD,N2,N2/2,ILIST,DM,NANG,SM,MAXSYM)
d121 1
a121 1
           DEALLOCATE (ILIST, DM, SM, X)
d155 1
a155 1
        DEALLOCATE (ILIST,DM)
d163 1
a163 1
        SUBROUTINE  WIW3DQ(NS,X,LSD,N,N2,ILIST,
d168 1
a168 1
        DIMENSION         ILIST(NANG)
d252 1
a252 1
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K),IRTFLG)
a330 1
        INTEGER, ALLOCATABLE, DIMENSION(:) :: ILIST
d343 3
a345 5
        ALLOCATE (ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, ILIST',IER)
           RETURN
        ENDIF
d347 1
a347 7
        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(ILIST)
           RETURN
        ENDIF
        MAXNUM = MAXVAL(ILIST(1:NANG))
d370 1
a370 1
        CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
d383 2
a384 5
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, DM',IER)
           DEALLOCATE (ILIST)
        ENDIF
        CALL  BUILDM(ILIST,DM,NANG,ANGBUF(1,1),IRTFLG)
d392 1
a392 1
              DEALLOCATE (ILIST,DM)
d400 1
a400 1
              DEALLOCATE (ILIST,DM)
d407 1
a407 1
           DEALLOCATE (ILIST, DM, SM)
d411 1
a411 1
     &              LSD,N2,N2/2,ILIST,DM,NANG,SM,MAXSYM)
a424 1
        DEALLOCATE (ILIST)        
d426 1
a426 2
9998    DEALLOCATE(SM)
        DEALLOCATE (X)
d433 1
a433 1
        SUBROUTINE  WIW3DQ(NS,X,LSD,N,N2,ILIST,
d438 1
a438 1
        DIMENSION         ILIST(NANG)
d507 1
a507 1
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K),IRTFLG)
@


1.25
log
@*** empty log message ***
@
text
@a302 1

a310 220
C       --------------------- ONELINE ---------------------------------

        SUBROUTINE  ONELINE(J,N,N2,X,W,BI,DM)

        DIMENSION      W(0:N2,N,N)
        COMPLEX        BI(0:N2,N),X(0:N2,N,N),BTQ
        DIMENSION      DM(6)
        PARAMETER      (LTAB=5000)
        COMMON  /TABS/ LN2,FLTB,TABI(0:LTAB)

        IF (J .GE. 0)  THEN
           JP=J+1
        ELSE
           JP=N+J+1
        ENDIF

        DO  I=0,N2
           IF ((I*I+J*J.LT.N*N/4).AND..NOT.(I.EQ.0.AND.J.LT.0))  THEN
              XNEW=I*DM(1)+J*DM(4)
              YNEW=I*DM(2)+J*DM(5)
              ZNEW=I*DM(3)+J*DM(6)
              IF (XNEW.LT.0.0)  THEN
                 XNEW=-XNEW
                 YNEW=-YNEW
                 ZNEW=-ZNEW
                 BTQ=CONJG(BI(I,JP))
              ELSE
                 BTQ=BI(I,JP)
              ENDIF
              IXN=IFIX(XNEW+0.5+N)-N
              IYN=IFIX(YNEW+0.5+N)-N
              IZN=IFIX(ZNEW+0.5+N)-N
              IF (IXN.LE.N2-LN2-1 .AND.
     &        IYN.GE.-N2+2+LN2.AND.IYN.LE.N2-LN2-1 .AND.
     &        IZN.GE.-N2+2+LN2.AND.IZN.LE.N2-LN2-1) THEN
                 IF (IXN.GE.0) THEN
C                   MAKE SURE THAT LOWER LIMIT FOR X DOES NOT GO BELOW 0
                    LB=-MIN0(IXN,LN2)
                    DO LZ=-LN2,LN2
                       IZP=IZN+LZ
                       IF(IZP.GE.0) THEN
                          IZA=IZP+1
                       ELSE
                          IZA=N+IZP+1
                       ENDIF
                       TZ = TABI(NINT(ABS(ZNEW-IZP)*FLTB))
           	       IF(TZ.NE.0.0)  THEN
                       DO  LY=-LN2,LN2
                          IYP=IYN+LY
                          IF (IYP.GE.0) THEN
                             IYA=IYP+1
                          ELSE
                             IYA=N+IYP+1
                          ENDIF
                          TY = TABI(NINT(ABS(YNEW-IYP)*FLTB))*TZ
           		  IF(TY.NE.0.0)  THEN
                          DO  LX=LB,LN2
                             IXP=IXN+LX
C                            GET THE WEIGHT
C                            WG=FINF(XNEW,YNEW,ZNEW,IXT,IYT,IZT)
                             WG=TABI(NINT(ABS(XNEW-IXP)*FLTB))*TY
			     IF(WG.NE.0.0)  THEN
                              X(IXP,IYA,IZA)=X(IXP,IYA,IZA)+BTQ*WG
                              W(IXP,IYA,IZA)=W(IXP,IYA,IZA)+WG
			     ENDIF
                          ENDDO
			  ENDIF
                       ENDDO
		       ENDIF
                   ENDDO
                ENDIF

C               ADD REFLECTED POINTS
                IF (IXN .LT. LN2) THEN
                   DO  LZ=-LN2,LN2
                      IZP=IZN+LZ
                      IF (IZP.GT.0)  THEN
                         IZT=N-IZP+1
                      ELSE
                         IZT=-IZP+1
                      ENDIF
                      TZ=TABI(NINT(ABS(ZNEW-IZP)*FLTB))
C
           	      IF(TZ.NE.0.0)  THEN
                      DO  LY=-LN2,LN2
                         IYP=IYN+LY
                         IF (IYP.GT.0) THEN
                            IYT=N-IYP+1
                         ELSE
                            IYT=-IYP+1
                         ENDIF
                         TY=TABI(NINT(ABS(YNEW-IYP)*FLTB))*TZ
			 IF(WG.NE.0.0)  THEN
                         DO  LX=-LN2,-1-IXN
                            IXP=IXN+LX
C                           GET THE WEIGHT
C                           WG=FINF(XNEW,YNEW,ZNEW,IXT,IYT,IZT)
                            WG=TABI(NINT(ABS(XNEW-IXP)*FLTB))*TY
			    IF(WG.NE.0.0)  THEN
                          X(-IXP,IYT,IZT)=X(-IXP,IYT,IZT)+CONJG(BTQ)*WG
                            W(-IXP,IYT,IZT)=W(-IXP,IYT,IZT)+WG
			    ENDIF
                         ENDDO
			 ENDIF
                      ENDDO
		      ENDIF
                   ENDDO
                ENDIF
              ENDIF
           ENDIF
C          END J-I LOOP
        ENDDO

        END

C       ------------------- PADD2 -------------------------------

        SUBROUTINE PADD2(PROJ,L,BI,LSD,N)

        DIMENSION  PROJ(L,L),BI(LSD,N)
        DOUBLE     PRECISION QS

        KLP=0
        R=L/2
        QS=0.0D0

        CALL ASTA(PROJ,L,R,QS,KLP)
        QS = QS/REAL(KLP)
c$omp parallel do private(i,j)
        DO  J=1,N
           DO  I=1,N
              BI(I,J)=0.0
           ENDDO
        ENDDO
C       FOR L ODD ADD ONE.  N IS ALWAYS EVEN
        IP = (N-L)/2+MOD(L,2)
c$omp parallel do private(i,j)
        DO  J=1,L
           DO  I=1,L
              BI(IP+I,IP+J)=PROJ(I,J)-QS
           ENDDO
        ENDDO

        END

C       ------------------- WIND2 -------------------------------

        SUBROUTINE WIND2(BI,R,L,LSD,N,SIR)

        DIMENSION  R(L,L,L),BI(LSD,N,N)

        TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
        IP=(N-L)/2+MOD(L,2)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 R(I,J,K)=BI(IP+I,IP+J,IP+K)*TNR
              ENDDO
           ENDDO
        ENDDO
        L2=(L/2)**2
        L2P=(L/2-1)**2
        IP=L/2+1
        S2=1.0/(2*SIR*SIR)
        TNR=0.0
        M=0
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR.LE.L2) THEN
                    R(I,J,K) = R(I,J,K)/EXP(-LR*S2)
                    IF(LR.GE.L2P .AND. LR.LE.L2) THEN
                       TNR=TNR+R(I,J,K)
                       M=M+1
                    ENDIF
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        TNR=TNR/REAL(M)
c$omp parallel do private(i,j,k,lr)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF(LR.LE.L2) THEN
                    R(I,J,K)=R(I,J,K)-TNR
                 ELSE
                    R(I,J,K)=0.0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END


C       ------------------- NRMW2 -------------------------------

        SUBROUTINE  NRMW2(R,W,N2,N)

        DIMENSION  W(0:N2,N,N)
        COMPLEX    R(0:N2,N,N)

c$omp parallel do private(i,j,k)
        DO  K=1,N
           DO  J=1,N
              DO  I=0,N2
                 IF(W(I,J,K).NE.0.0)  
     &             R(I,J,K)=R(I,J,K)*(-1)**(I+J+K)/W(I,J,K)
C     &            *W(I,J,K)/(W(I,J,K)**2+0.05)
              ENDDO
           ENDDO
        ENDDO
        INV = -1
        CALL  FMRS_3(R,N,N,N,INV)

        END
d499 1
a499 1
	
a571 1

d606 56
d708 1
a708 1
           
d717 1
a717 1
           
d723 8
a730 4
                             X(IXP,IYA,IZA)=X(IXP,IYA,IZA)+BTQ*WG
                             W(IXP,IYA,IZA)=W(IXP,IYA,IZA)+WG
                         ENDDO
                      ENDDO
d745 1
d754 1
a754 1

d760 1
d763 1
d765 1
d767 1
a775 1

a804 55

C       ------------------- WIND2 -------------------------------

        SUBROUTINE WIND2(BI,R,L,LSD,N,SIR)

        DIMENSION  R(L,L,L),BI(LSD,N,N)

        TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
        IP=(N-L)/2+MOD(L,2)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 R(I,J,K)=BI(IP+I,IP+J,IP+K)*TNR
              ENDDO
           ENDDO
        ENDDO
        L2=(L/2)**2
        L2P=(L/2-1)**2
        IP=L/2+1
        S2=1.0/(2*SIR*SIR)
        TNR=0.0
        M=0
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR.LE.L2) THEN
                    R(I,J,K) = R(I,J,K)/EXP(-LR*S2)
                    IF(LR.GE.L2P .AND. LR.LE.L2) THEN
                       TNR=TNR+R(I,J,K)
                       M=M+1
                    ENDIF
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        TNR=TNR/REAL(M)
c$omp parallel do private(i,j,k,lr)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF(LR.LE.L2) THEN
                    R(I,J,K)=R(I,J,K)-TNR
                 ELSE
                    R(I,J,K)=0.0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END


d816 5
a820 2
                 IF(W(I,J,K).NE.0.0)  
     &             R(I,J,K)=R(I,J,K)*(-1)**(I+J+K)/W(I,J,K)
a828 1
#endif
@


1.24
log
@New version with Bessel functions and additional symmetrization
@
text
@d1 1
a1 1
#ifdef 1
@


1.23
log
@*** empty log message ***
@
text
@d1 1
d4 532
d1039 1
a1039 2

	
@


1.22
log
@cosmetic
@
text
@d25 3
a27 3
        INCLUDE '/net/ithaca/usr1/spider/src/CMBLOCK.INC'
        INCLUDE '/net/ithaca/usr1/spider/src/CMLIMIT.INC'
        INCLUDE '/net/ithaca/usr1/spider/src/F90ALLOC.INC'
@


1.21
log
@cosmetic
@
text
@d107 5
a111 1
           ALLOCATE(SM(1,1))
@


1.20
log
@cosmetic
@
text
@d89 5
a93 1
        ALLOCATE(DM(9,NANG))
d99 5
a103 1
           ALLOCATE(SM(9,MAXSYM))
d131 1
a131 1
        DEALLOCATE(ILIST)
@


1.19
log
@adapted for dynamical memory allocation
@
text
@d123 1
@


1.18
log
@*** empty log message ***
@
text
@d4 1
a4 1
C
d16 3
d22 2
a23 13
	SUBROUTINE WIW3D(MAXMEM)
C 
	PARAMETER  (NILMAX=99998)
        INCLUDE 'CMBLOCK.INC'
	COMMON /F_SPEC/ FINPAT,NLET,FINPIC
	CHARACTER*80    FINPIC,FINPAT,FILNAM,ANGDOC
	CHARACTER*1     NULL
	COMMON          BUF(1024),ILIST(NILMAX),BAF(1)
        LOGICAL         RUNTIME

        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q
d25 7
a33 2
        REAL, DIMENSION(:,:), ALLOCATABLE :: DM,SM
	DATA  IOPIC/98/,INPIC/99/
d35 2
a36 1
	NULL = CHAR(0)
d38 1
a38 2
C       N    - LINEAR DIMENSION OF PROJECTIONS AND RESTORED CUBE
C       NANG - NUMBER OF ANGLES (PROJECTIONS)
d40 1
a40 3
 	CALL FILERD(FINPAT,NLET,NULL,
     &	   'ENTER TEMPLATE FOR 2-D IMAGE NAME',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
d42 5
a46 2
 	CALL FILERD(FINPIC,NLETI,NULL,'SELECTION DOC',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
d48 8
a55 18
	K      = 0
	K2     = 1
	NANG   = 0
        MAXNUM = 0
778	LERR   = -1
	IF (NANG .EQ. NILMAX)  THEN
           WRITE(NOUT,*) '*** TOO MANY IMAGES, LIST TRUNCATED'
           GOTO 779
	ENDIF
	KP1 = K + 1
	CALL  UNSAV(FINPIC,K,INPIC,KP1,BUF,1,LERR,K2)
	IF (LERR .EQ. 0)  THEN
	   NANG        = NANG+1
	   ILIST(NANG) = BUF(1)
	   IF (ILIST(NANG) .GT. MAXNUM) MAXNUM = ILIST(NANG)
	   K           = K+1
	   GOTO  778
	ENDIF
d57 1
a57 2
779	CLOSE(INPIC)

d59 2
a60 2
	WRITE(NOUT,2001) NANG
2001	FORMAT(' NUMBER OF IMAGES =',I5)
d68 8
a75 7
C       Retrieve array with symmetries data in it
	MAXXS=0
	MAXSYM=0
	CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &	                 MAXSYM,ANGSYM,IRTFLG)
	IF(IRTFLG.NE.0)  MAXSYM=1
C
d77 1
a77 1
 	CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
d83 1
a83 1
	CLOSE(INPIC)
d85 3
a87 20
	N2     = 2*NSAM
	LSD    = N2+2-MOD(N2,2)
	NMAT   = LSD*N2*N2

	K_PROJ = 1
	K_X    = IPALIGN64(K_PROJ+NSAM*NSAM)
	K_CB   = IPALIGN64(K_X+LSD*N2)
	K_CW   = IPALIGN64(K_CB+NMAT)
	MEMTOT = IPALIGN64(K_CW+NMAT/2)

	IRTFLG = -9
        CALL CHKMEM(MEMTOT,BAF,MAXMEM,RUNTIME,IPQ,IRTFLG)
	IF (IRTFLG .NE. 0)  GOTO 9998
#ifdef SP_F90
        Q = > IPQ
#endif

        WRITE(NOUT,1001)  MEMTOT
1001	FORMAT(/,' 3-D FOURIER INTERPOLATION RECONSTRUCTION',/,
     &              ' YOU HAVE RESERVED MEMORY:',I9,/)
d89 1
a89 1
	ALLOCATE(DM(9,NANG))
d91 1
a91 1
	DEALLOCATE(ANGBUF)
d93 14
a106 7
	IF(MAXSYM.GT.1)  THEN
	 ALLOCATE(SM(9,MAXSYM))
         CALL  BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
	 DEALLOCATE(ANGSYM)
	ELSE
	 ALLOCATE(SM(1,1))
	ENDIF
d108 1
a108 1
        CALL WIW3DQ(Q(K_PROJ),NSAM,Q(K_X),Q(K_CB),Q(K_CW),
d116 4
a119 4
        DO   K=1,NSAM*NSAM
           MI = (K-1) * NSAM
           CALL WRTLIN(IOPIC,Q(K_CB+MI),NSAM,K)
        ENDDO
a120 3
9997	CLOSE(IOPIC)
	DEALLOCATE(DM)
	IF (RUNTIME) CALL DEALLOCMEM_R(IPQ,IRTFLG)
d122 2
d125 2
a127 1
	END
a129 1

d132 1
a132 1
        SUBROUTINE  WIW3DQ(PROJ,NS,BI,X,W,LSD,N,N2,ILIST,
d135 2
a136 2
        DIMENSION         PROJ(NS,NS),W(0:N2,N,N)
	COMPLEX           BI(0:N2,N),X(0:N2,N,N)
d139 5
d146 3
a148 3
	DOUBLE PRECISION  PI
	PARAMETER         (LTAB=5000)
	COMMON  /TABS/    LN2,FLTB,TABI(0:LTAB)
d152 5
a156 5
	LN=5
	LN2=LN/2
	PI=4.0D0*DATAN(1.0D0)
	SIG=3.0/PI
	SIG2=SIG*SIG
d158 1
a158 1
	SIR=REAL(N)/(2.0*PI*SIG)
d160 1
a160 1
	TNR=DSQRT(2.0D0*PI)*SIG
d163 1
a163 1
	FLTB=REAL(LTAB)/REAL(LN2+1)
d165 1
a165 1
	DO  I=0,LTAB
d167 1
a167 1
	ENDDO
d169 6
d179 3
a181 3
	         X(I,J,K)=CMPLX(0.0,0.0)
	         W(I,J,K)=0.0
	      ENDDO
d183 10
a192 1
	ENDDO
d194 8
d203 1
a203 1
C	   PRINT  *,' PROJECTION #',K
d206 1
a206 1
	   CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K),IRTFLG)
d214 2
d218 1
a218 1
	   ENDDO
d221 3
a223 3
	   CALL PADD2(PROJ,NS,BI,LSD,N)
	   INV = +1
	   CALL FMRS_2(BI,N,N,INV)
d226 4
a229 4
	      DO  I=0,N2
	         BI(I,J)=BI(I,J)*(-1)**(I+J+1)
	      ENDDO
	   ENDDO
d231 2
a232 2
	   DO  ISYM=1,MAXSYM
	    IF(MAXSYM.GT.1)  THEN
d234 4
a237 4
	     DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
	    ELSE
	     DMS=DM(:,:,K)
	    ENDIF
d239 3
a241 3
	    DO J=-N2+1,N2
	      CALL ONELINE(J,N,N2,X,W,BI,DMS)
	    ENDDO
d243 1
a243 1
	   ENDDO
d246 1
a246 1
	ENDDO
d249 2
a250 2
	DO  IZA=2,N2
	   DO  IYA=2,N2
d253 2
a254 2
	      X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
	      W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
d257 5
a261 5
	      X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
	      W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
	   ENDDO
	ENDDO
	DO  IYA=2,N2
d264 4
a267 4
	   X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
	   W(0,N-IYA+2,1)=W(0,IYA,1)
	ENDDO
	DO  IZA=2,N2
d270 3
a272 3
	   X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
	   W(0,1,N-IZA+2)=W(0,1,IZA)
	ENDDO
d274 5
a278 3
	CALL NRMW2(X,W,N2,N)
	CALL WIND2(X,X,NS,LSD,N,SIR)

d284 1
a284 1
	SUBROUTINE  ONELINE(J,N,N2,X,W,BI,DM)
d286 5
a290 5
	DIMENSION      W(0:N2,N,N)
	COMPLEX        BI(0:N2,N),X(0:N2,N,N),BTQ
	DIMENSION      DM(6)
	PARAMETER      (LTAB=5000)
	COMMON  /TABS/ LN2,FLTB,TABI(0:LTAB)
d345 1
a345 1
         	         ENDDO
d351 1
a351 1
	        IF (IXN .LT. LN2) THEN
d370 1
a370 1
	                 DO  LX=-LN2,-1-IXN
d374 1
a374 1
	                    WG=TABI(NINT(ABS(XNEW-IXP)*FLTB))*TY
d377 3
a379 3
	                 ENDDO
	              ENDDO
	           ENDDO
d381 2
a382 2
	      ENDIF
	   ENDIF
d384 1
a384 1
	ENDDO
d386 1
a386 1
	END
d390 1
a390 1
	SUBROUTINE PADD2(PROJ,L,BI,LSD,N)
d392 2
a393 2
	DIMENSION  PROJ(L,L),BI(LSD,N)
	DOUBLE     PRECISION QS
d395 3
a397 3
	KLP=0
	R=L/2
	QS=0.0D0
d399 2
a400 2
	CALL ASTA(PROJ,L,R,QS,KLP)
	QS = QS/REAL(KLP)
d402 5
a406 5
	DO  J=1,N
	   DO  I=1,N
	      BI(I,J)=0.0
	   ENDDO
	ENDDO
d408 1
a408 1
	IP = (N-L)/2+MOD(L,2)
d410 5
a414 5
	DO  J=1,L
	   DO  I=1,L
	      BI(IP+I,IP+J)=PROJ(I,J)-QS
	   ENDDO
	ENDDO
d416 1
a416 1
	END
d420 1
a420 1
	SUBROUTINE WIND2(BI,R,L,LSD,N,SIR)
d422 1
a422 1
	DIMENSION  R(L,L,L),BI(LSD,N,N)
d424 13
a436 13
	TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
	IP=(N-L)/2+MOD(L,2)
	DO  K=1,L
	   DO  J=1,L
	      DO  I=1,L
	         R(I,J,K)=BI(IP+I,IP+J,IP+K)*TNR
	      ENDDO
	   ENDDO
	ENDDO
	L2=(L/2)**2
	L2P=(L/2-1)**2
	IP=L/2+1
	S2=1.0/(2*SIR*SIR)
d438 5
a442 5
	M=0
	DO  K=1,L
	   DO  J=1,L
	      DO  I=1,L
	         LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
d444 1
a444 1
	            R(I,J,K) = R(I,J,K)/EXP(-LR*S2)
d452 1
a452 1
	ENDDO
d454 1
a454 1
	TNR=TNR/REAL(M)
d456 9
a464 9
	DO  K=1,L
	   DO  J=1,L
	      DO  I=1,L
	         LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
	         IF(LR.LE.L2) THEN
	            R(I,J,K)=R(I,J,K)-TNR
	         ELSE
	            R(I,J,K)=0.0
	         ENDIF
d466 2
a467 2
	   ENDDO
	ENDDO
d469 1
a469 1
	END
d474 1
a474 1
	SUBROUTINE  NRMW2(R,W,N2,N)
d476 2
a477 2
	DIMENSION  W(0:N2,N,N)
	COMPLEX    R(0:N2,N,N)
d480 1
a480 1
	DO  K=1,N
d484 2
a485 2
     &		   R(I,J,K)=R(I,J,K)*(-1)**(I+J+K)/W(I,J,K)
C     &		   *W(I,J,K)/(W(I,J,K)**2+0.05)
d489 4
a492 2
	INV = -1
	CALL  FMRS_3(R,N,N,N,INV)
d494 1
a494 1
	END
@


1.17
log
@symmetries added
@
text
@d155 2
a156 1
        SUBROUTINE  WIW3DQ(PROJ,NS,BI,X,W,LSD,N,N2,ILIST,DM,NANG,SM,MAXSYM)
d233 1
a233 1
	      CALL ONELINE(J,N,N2,X,W,BI,DM(1,K))
@


1.16
log
@WIND2 corrected margin
@
text
@d3 1
a3 1
C  WIW3D.F
d20 1
a20 1
C                                                    10/22/98
d34 2
a35 1
        REAL, DIMENSION(:,:), POINTER :: ANGBUF
d80 8
a87 2
        IF (IRTFLG .NE. 0) RETURN

d101 1
a101 3
 	K_DM   = 1
	K_SS   = IPALIGN64(K_DM+9*NANG)
	K_PROJ = IPALIGN64(K_SS+6*NANG)
d118 11
a128 2
	CALL REANG(ILIST,Q(K_DM),Q(K_SS),NANG,ANGBUF(1,1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9997
d131 1
a131 1
     &              LSD,N2,N2/2,ILIST,Q(K_DM),NANG)
d143 3
a145 2
9997    IF (RUNTIME) CALL DEALLOCMEM_R(IPQ,IRTFLG)
	CLOSE(IOPIC)
d147 1
a147 1
9998    DEALLOCATE(ANGBUF)
d155 1
a155 1
        SUBROUTINE  WIW3DQ(PROJ,NS,BI,X,W,LSD,N,N2,ILIST,DM,NANG)
d159 2
a160 2
        DIMENSION         ILIST(NANG),DM(9,NANG)
        COMMON            BUF(1024)
d222 8
a229 1

d231 1
a231 1
	   DO J=-N2+1,N2
d233 2
d236 1
a236 1

@


1.15
log
@*** empty log message ***
@
text
@d399 2
a400 1
	L2=L*L/4
d411 1
a411 1
                    IF (LR.EQ.L2) THEN
@


1.14
log
@getdocdat changed
@
text
@d132 1
a132 1
9998    CALL DEALLOCATE(ANGBUF)
@


1.13
log
@*** empty log message ***
@
text
@a28 1
#ifdef SP_F90
d34 1
a34 10
        REAL, DIMENSION(:), POINTER :: IPANG
        REAL, DIMENSION(:), POINTER :: ANGBUF
#else
        DIMENSION       Q(1)
        POINTER         (IPQ,Q)
 
        DIMENSION       ANGBUF(1)
        POINTER         (IPANG,ANGBUF) 
#endif

d78 1
a78 1
     &                       MAXYT,IPANG,IRTFLG)
a79 3
#ifdef SP_F90
         ANGBUF = > IPANG
#endif
d113 1
a113 1
	CALL REANG(ILIST,Q(K_DM),Q(K_SS),NANG,ANGBUF(1),IRTFLG)
d117 1
a117 1
     &              LSD,N2,N2/2,ILIST,Q(K_DM),NANG,NOUT,ANGBUF(1))
d132 1
a132 1
9998    CALL DEALLOCMEM_R(IPANG,IRTFLG)
a133 1
        RETURN
d140 1
a140 2
        SUBROUTINE  WIW3DQ(PROJ,NS,BI,X,W,LSD,N,N2,ILIST,DM,
     &                     NANG,NOUT,ANGBUF)
a150 2

        DIMENSION         ANGBUF(1)
@


1.12
log
@OpenMP
@
text
@a398 1
        RETURN
@


1.11
log
@f90
@
text
@d183 1
a183 1
c$doacross local(i)
d188 1
a188 1
c$doacross local(i,j,k)
d218 1
a218 1
c$doacross local(i,j)
d225 1
a225 1
c$doacross local(j),share(N,N2,X,W,BI,DM),mp_schedtype=simple
d384 1
a384 1
c$doacross local(i,j)
d392 1
a392 1
c$doacross local(i,j)
d438 1
a438 1
c$doacross local(i,j,k,lr)
d462 1
a462 1
c$doacross local(i,j,k)
@


1.10
log
@bad reang call in f77
@
text
@d33 2
d36 1
d39 2
a40 1
        POINTER         (IPQ,Q) 
d46 1
a46 1
CNO_SAVE
d90 3
d118 3
d126 1
a126 6
#ifdef SP_F90
        Q = >IPQ
	CALL REANG(ILIST,Q(K_DM),Q(K_SS),NANG,IPANG,IRTFLG)
#else
	CALL REANG(ILIST,Q(K_DM),Q(K_SS),NANG,ANGBUF,IRTFLG)
#endif
d130 1
a130 1
     &              LSD,N2,N2/2,ILIST,Q(K_DM),NANG,NOUT,IPANG)
d142 1
a142 1
9997    IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'WIW3D',IRTFLG)
d145 1
a145 2
9998    RUNTIME = .TRUE.
        CALL ALLOCIT(0,RUNTIME,IPANG,'WIW3D',IRTFLG)
d147 1
d150 2
d155 1
a155 1
     &                     NANG,NOUT,IPANG)
a167 1
        POINTER           (IPANG,ANGBUF) 
a169 1
CNO_SAVE
@


1.9
log
@f90 & error recovery
@
text
@d118 3
a121 1
	CALL REANG(ILIST,Q(K_DM),Q(K_SS),NANG,IPANG,IRTFLG)
d159 1
@


1.8
log
@99998
@
text
@d110 6
a115 4
	IF (IRTFLG .EQ. 0)  THEN
	   WRITE(NOUT,1001)  MEMTOT
1001	   FORMAT(/,' 3-D FOURIER INTERPOLATION RECONSTRUCTION',/,
     1              ' YOU HAVE RESERVED MEMORY:',I9,/)
d117 1
a117 1
           Q = >IPQ
d119 5
a123 1
	   CALL REANG(ILIST,Q(K_DM),Q(K_SS),NANG,IPANG)
d125 4
a128 2
	   CALL WIW3DQ(Q(K_PROJ),NSAM,Q(K_X),Q(K_CB),Q(K_CW),
     &                 LSD,N2,N2/2,ILIST,Q(K_DM),NANG,NOUT,IPANG)
d130 4
a133 10
           IFORM = 3
           CALL OPFIL(.TRUE.,FILNAM,IOPIC,'U',NSAM,NSAM,NSAM,
     &             MAXIM,'RECONSTRUCTED 3-D',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998

	   DO   K=1,NSAM*NSAM
	      MI = (K-1) * NSAM
	      CALL WRTLIN(IOPIC,Q(K_CB+MI),NSAM,K)
	   ENDDO
	ENDIF
d135 1
a135 1
        IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'WIW3D',IRTFLG)
@


1.7
log
@bad getdocdat call
@
text
@d21 1
a21 1
	PARAMETER  (NILMAX=99999)
@


1.6
log
@I have no idea whether it is correct.
@
text
@d83 1
a83 1
        CALL GETDOCDAT('ANGLES DOC',ANGDOC,.TRUE.,77,.FALSE.,MAXXT,
@


1.5
log
@buffer 99999
@
text
@a138 1
        RETURN
a251 1
        RETURN
a358 1
        RETURN
a441 1
        RETURN
a464 1
        RETURN
@


1.4
log
@bad maxyt value used
@
text
@d21 1
a21 1
	PARAMETER  (NILMAX=20000)
@


1.3
log
@used opfil, getdocdat, & cosmetic
@
text
@d55 5
a59 4
	K    = 0
	K2   = 1
	NANG = 0
778	LERR = -1
d64 1
a64 1
	KP1 = K+1
d66 1
a66 1
	IF (LERR.EQ.0)  THEN
d69 1
d82 1
a82 1
        MAXYT = NANG
d96 11
a106 11
	N2=2*NSAM
	LSD=N2+2-MOD(N2,2)
	NMAT=LSD*N2*N2

 	K_DM=1
	K_SS=IPALIGN64(K_DM+9*NANG)
	K_PROJ=IPALIGN64(K_SS+6*NANG)
	K_X=IPALIGN64(K_PROJ+NSAM*NSAM)
	K_CB=IPALIGN64(K_X+LSD*N2)
	K_CW=IPALIGN64(K_CB+NMAT)
	MEMTOT=IPALIGN64(K_CW+NMAT/2)
@


1.2
log
@*** empty log message ***
@
text
@d1 18
d23 6
a28 5
	COMMON /F_SPEC/  FINPAT,NLET,FINPIC
	CHARACTER*80  FINPIC,FINFO
	CHARACTER*80  FINPAT
	CHARACTER*1   NULL
	COMMON        DUMMY(80),BUF(1024),ILIST(NILMAX),BAF(1)
d33 1
d35 4
a38 2
        DIMENSION     Q(1)
        POINTER       (IPQ,Q) 
a39 1
        LOGICAL       RUNTIME
d43 1
a43 1
	NULL=CHAR(0)
d45 2
a46 2
C       N - linear dimension of projections and restored cube
C       NANG - number of angles (projections)
d48 1
a48 2
	IUNIT=NOUT
 	CALL  FILERD(FINPAT,NLET,NULL,
d50 12
a61 8
 	CALL  FILERD(FINPic,NLETi,NULL,'SELECTION DOC',IRTFLG)
	K=0
	K2=1
	NANG=0
778	LERR=-1
	IF (NANG.EQ.NILMAX)  THEN
           WRITE(NOUT,*) '  TOO MANY IMAGES, LIST TRUNCATED'
           GOTO  779
d63 1
a63 1
	KP1=K+1
d66 3
a68 3
	   NANG=NANG+1
	   ILIST(NANG)=BUF(1)
	   K=K+1
d73 2
d76 10
a85 6
2001	FORMAT('  NUMBER OF IMAGES =',i5)
C       NANG - total number of images
	CALL  FILERD(FINFO,NLET1,NULL,'ANGLES DOC',ITRFLG)
	FINFO=FINFO(1:NLET1)//'.'//DATEXC(1:3)
	OPEN(77,FILE=FINFO,STATUS='OLD')
C
d87 5
a91 5
 	CALL OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
 	IF (NF .NE. 2)  THEN
	   WRITE(NOUT,*) ' FILE NOT FOUND'
	   RETURN
	ENDIF
d93 1
a93 1
C
d97 1
a97 1
C
d106 1
a106 1
	IRTFLG=-9
d108 1
a108 1
	IF (IRTFLG.EQ.0)  THEN
d110 2
a111 2
1001	   FORMAT(//'  3-D Fourier interpolation reconstruction',/,
     1              '   you have reserved ',I9,/)
d113 1
a113 1
         Q = >IPQ
d115 10
a124 12
	   CALL  REANG(ILIST,Q(K_DM),Q(K_SS),NANG,NOUT)
	   CALL  WIW3DQ
     &	   (Q(K_PROJ),NSAM,
     &        Q(K_X),Q(K_CB),Q(K_CW),
     &         LSD,N2,N2/2,
     &		ILIST,Q(K_DM),NANG,NOUT)
C
	CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',ITRFLG)
	IF (IRTFLG.EQ.-1)  GOTO 9999
	IFORM=3
 	CALL  OPENFB(BUF,FINPIC,IOPIC,NSAM,NSAM,'UNKNOWN',NF,NSAM)
	IF (NF.NE.2)  GOTO 9999
d126 2
a127 2
	      MI=(K-1)*NSAM
	      CALL  WRTLIN(IOPIC,Q(K_CB+MI),NSAM,K)
d130 2
a131 1
        IF (RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'BP 3F',IRTFLG)
d133 5
a137 2
C
9999	CONTINUE
d139 11
a149 11
C
        SUBROUTINE  WIW3DQ
     &  (PROJ,NS,
     &     BI,X,W,
     &	      LSD,N,N2,
     &          ILIST,DM,NANG,NOUT)
        DIMENSION  PROJ(NS,NS),W(0:N2,N,N)
	COMPLEX  BI(0:N2,N),X(0:N2,N,N)
        DIMENSION  ILIST(NANG),DM(9,NANG)
        COMMON     DUMMY(80),BUF(1024)
        CHARACTER*80  FINPIC,FINPAT
d152 5
a156 3
	PARAMETER (LTAB=5000)
	COMMON  /TABS/  LN2,FLTB,TABI(0:LTAB)
C
d159 1
a159 1
C
d165 1
a165 1
C sigma in real space
d167 1
a167 1
C
d169 2
a170 1
C Generate table with interpolants
d174 1
a174 1
        TABI(I)=EXP(-0.5*((REAL(I)/FLTB)**2)/SIG2)/TNR
d176 1
a176 1
C
d179 6
a184 4
        DO    J=1,N
        DO    I=0,N2
        X(I,J,K)=CMPLX(0.0,0.0)
	W(I,J,K)=0.0
d186 1
a186 3
	ENDDO
	ENDDO
c
d188 19
a206 16
C	print  *,' Projection #',K
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K),INTFLAG)
        CALL  OPENFB(BUF,FINPIC,INPROJ,NSAM,NROW,'O',NF,NSL)
        IF(NF.NE.2)  THEN
        write(nout,2032)   FINPIC
2032    FORMAT(' File not found ',A80,/,' Operation abandoned')
        RETURN
        ENDIF
        DO    J=1,NS
        CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
	ENDDO
        CLOSE(INPROJ)
C
	CALL PADD2(PROJ,NS,BI,LSD,N)
	INV=+1
	CALL FMRS_2(BI,N,N,INV)
d208 6
a213 6
        DO    J=1,N
	DO    I=0,N2
	BI(I,J)=BI(I,J)*(-1)**(I+J+1)
	ENDDO
	ENDDO
C
d215 5
a219 3
	DO  J=-N2+1,N2
C
	CALL  ONELINE(J,N,N2,X,W,BI,DM(1,K))
d221 2
a222 4
C
C  end of projections loop
	ENDDO
C Symmetrize plane 0
d224 10
a233 10
	DO  IYA=2,N2
        X(0,IYA,IZA)=X(0,IYA,IZA)+CONJG(X(0,N-IYA+2,N-IZA+2))
        W(0,IYA,IZA)=W(0,IYA,IZA)+W(0,N-IYA+2,N-IZA+2)
	X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
	W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
        X(0,N-IYA+2,IZA)=X(0,N-IYA+2,IZA)+CONJG(X(0,IYA,N-IZA+2))
        W(0,N-IYA+2,IZA)=W(0,N-IYA+2,IZA)+W(0,IYA,N-IZA+2)
	X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
	W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
	ENDDO
d236 4
a239 4
        X(0,IYA,1)=X(0,IYA,1)+CONJG(X(0,N-IYA+2,1))
        W(0,IYA,1)=W(0,IYA,1)+W(0,N-IYA+2,1)
	X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
	W(0,N-IYA+2,1)=W(0,IYA,1)
d242 4
a245 4
        X(0,1,IZA)=X(0,1,IZA)+CONJG(X(0,1,N-IZA+2))
        W(0,1,IZA)=W(0,1,IZA)+W(0,1,N-IZA+2)
	X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
	W(0,1,N-IZA+2)=W(0,1,IZA)
d247 5
a251 3
C
	CALL  NRMW2(X,W,N2,N)
	CALL  WIND2(X,X,NS,LSD,N,SIR)
d253 4
a256 1
C
d258 11
a268 63
	DIMENSION  W(0:N2,N,N)
	COMPLEX  BI(0:N2,N),X(0:N2,N,N),BTQ
	DIMENSION  DM(6)
	PARAMETER (LTAB=5000)
	COMMON  /TABS/  LN2,FLTB,TABI(0:LTAB)
C
	     IF(J.GE.0)  THEN
             JP=J+1
	     ELSE
             JP=N+J+1
	     ENDIF
C
	DO  I=0,N2
	IF((I*I+J*J.LT.N*N/4).AND..NOT.(I.EQ.0.AND.J.LT.0))  THEN
	 XNEW=I*DM(1)+J*DM(4)
	 YNEW=I*DM(2)+J*DM(5)
	 ZNEW=I*DM(3)+J*DM(6)
         IF(XNEW.LT.0.0)  THEN
         XNEW=-XNEW
         YNEW=-YNEW
         ZNEW=-ZNEW
         BTQ=CONJG(BI(I,JP))
         ELSE
         BTQ=BI(I,JP)
         ENDIF
	 IXN=IFIX(XNEW+0.5+N)-N
	 IYN=IFIX(YNEW+0.5+N)-N
	 IZN=IFIX(ZNEW+0.5+N)-N
        IF(IXN.LE.N2-LN2-1 .AND.
     &     IYN.GE.-N2+2+LN2.AND.IYN.LE.N2-LN2-1 .AND.
     &     IZN.GE.-N2+2+LN2.AND.IZN.LE.N2-LN2-1) THEN
         IF(IXN.GE.0) THEN
C Make sure that lower limit for x does not go below 0
         LB=-MIN0(IXN,LN2)
         DO  LZ=-LN2,LN2
         IZP=IZN+LZ
         IF(IZP.GE.0)  THEN
          IZA=IZP+1
         ELSE
          IZA=N+IZP+1
         ENDIF
         TZ=TABI(NINT(ABS(ZNEW-IZP)*FLTB))
C
          DO  LY=-LN2,LN2
          IYP=IYN+LY
          IF(IYP.GE.0)  THEN
           IYA=IYP+1
          ELSE
           IYA=N+IYP+1
          ENDIF
          TY=TABI(NINT(ABS(YNEW-IYP)*FLTB))*TZ
C
	   DO  LX=LB,LN2
           IXP=IXN+LX
C  Get the weight
c            WG=finf(XNEW,YNEW,ZNEW,IXT,IYT,IZT)
	     WG=TABI(NINT(ABS(XNEW-IXP)*FLTB))*TY
            X(IXP,IYA,IZA)=X(IXP,IYA,IZA)+BTQ*WG
            W(IXP,IYA,IZA)=W(IXP,IYA,IZA)+WG
C
	   ENDDO
	  ENDDO
	 ENDDO
d270 87
a356 38
C
C  Add reflected points
	IF(IXN.LT.LN2) THEN
         DO  LZ=-LN2,LN2
         IZP=IZN+LZ
         IF(IZP.GT.0)  THEN
          IZT=N-IZP+1
         ELSE
          IZT=-IZP+1
         ENDIF
         TZ=TABI(NINT(ABS(ZNEW-IZP)*FLTB))
C
          DO  LY=-LN2,LN2
          IYP=IYN+LY
          IF(IYP.GT.0)  THEN
           IYT=N-IYP+1
          ELSE
           IYT=-IYP+1
          ENDIF
          TY=TABI(NINT(ABS(YNEW-IYP)*FLTB))*TZ
C
	   DO  LX=-LN2,-1-IXN
           IXP=IXN+LX
C  Get the weight
c            WG=finf(XNEW,YNEW,ZNEW,IXT,IYT,IZT)
	     WG=TABI(NINT(ABS(XNEW-IXP)*FLTB))*TY
             X(-IXP,IYT,IZT)=X(-IXP,IYT,IZT)+CONJG(BTQ)*WG
             W(-IXP,IYT,IZT)=W(-IXP,IYT,IZT)+WG
	   ENDDO
	  ENDDO
	 ENDDO
        ENDIF
C
	
	ENDIF
C
	ENDIF
C  end j-i loop
d358 2
d361 3
a363 1
C
d365 1
d367 2
a368 1
	DOUBLE PRECISION QS
d372 1
d374 1
a374 1
	QS=QS/REAL(KLP)
d377 3
a379 2
	DO  I=1,N
	BI(I,J)=0.0
d381 2
a382 3
	ENDDO
C For L odd add one.  N is ALWAYS even
	IP=(N-L)/2+MOD(L,2)
d385 3
a387 2
	DO  I=1,L
	BI(IP+I,IP+J)=PROJ(I,J)-QS
d389 2
a390 1
	ENDDO
d392 3
a394 1
C
d396 1
d398 1
d402 5
a406 3
	DO  J=1,L
	DO  I=1,L
	R(I,J,K)=BI(IP+I,IP+J,IP+K)*TNR
a407 2
	ENDDO
	ENDDO
d414 12
a425 10
	DO  J=1,L
	DO  I=1,L
	LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
	IF(LR.LE.L2) THEN
	R(I,J,K)=R(I,J,K)/EXP(-LR*S2)
	 IF(LR.EQ.L2) THEN
	 TNR=TNR+R(I,J,K)
	 M=M+1
	 ENDIF
	ENDIF
d427 1
a427 2
	ENDDO
	ENDDO
d431 10
a440 8
	DO  J=1,L
	DO  I=1,L
	LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
	IF(LR.LE.L2) THEN
	R(I,J,K)=R(I,J,K)-TNR
	ELSE
	R(I,J,K)=0.0
	ENDIF
d442 2
a443 2
	ENDDO
	ENDDO
d445 4
a448 1
C
d450 1
d452 2
a453 1
	COMPLEX   R(0:N2,N,N)
d456 9
a464 9
	DO  J=1,N
	DO  I=0,N2
	IF(W(I,J,K).NE.0.0)  
     &		R(I,J,K)=R(I,J,K)*(-1)**(I+J+K)/W(I,J,K)
c     &		*W(I,J,K)/(W(I,J,K)**2+0.05)
	ENDDO
	ENDDO
	ENDDO
	INV=-1
d466 2
@


1.1
log
@Initial revision
@
text
@d153 1
a153 1
	print  *,' Projection #',K
@
