head	1.31;
access;
symbols
	pre_mrcs:1.31
	healthdept_2018:1.31
	pre_getangas:1.29
	GPL2010:1.29
	pre_GPL2010:1.28
	pre_var_equation:1.28
	pre_fftwrings:1.28
	pre_opfiles:1.28
	src:1.28
	best-code:1.28
	x-named-regs:1.28
	x:1.28
	v13-00:1.28
	pre_GPL:1.26
	prec_CA:1.25
	noindx:1.24
	Bproc:1.23
	oct21:1.19
	last77:1.18;
locks; strict;
comment	@c @;


1.31
date	2018.10.03.14.33.54;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2012.11.01.18.54.50;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2010.06.24.13.25.00;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.17.19.59.56;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.17.17.55.56;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.21.20.16.23;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.02.16.07.34;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.03.14.49.38;	author bimal;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.27.15.59.34;	author pawel;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.27.14.29.01;	author pawel;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.26.22.31.32;	author pawel;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.03.21.32.50;	author pawel;	state Exp;
branches;
next	1.19;

1.19
date	99.09.08.17.00.07;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	99.03.08.13.28.20;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	97.11.06.18.23.23;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	97.09.30.22.17.48;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	96.08.30.19.16.11;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	96.08.30.17.02.08;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	96.08.28.18.46.10;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	96.08.27.21.06.15;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	96.08.27.20.16.41;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	96.07.26.15.28.32;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	96.07.26.15.24.54;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	96.07.25.21.26.46;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	96.01.12.21.45.10;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	95.08.03.14.52.14;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	95.03.24.18.13.17;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	95.03.23.20.04.18;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	94.11.08.09.49.08;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.02.11;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.41.10;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.31
log
@email_health_dept
@
text
@


C++*********************************************************************
C
C  ADD.F                    CHANGED              7/21/86 MN
C                           OUTPUT FILES CHANGED AUG 96  ARDEAN LEITH
C                           REWRITTEN            MAR 99  ARDEAN LEITH
C                           DIV BUG              SEP 03  ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  ADD(VOLBUF,LUNIN,ITYPE,NX,NY,NZ,SIGT)
C
C  PURPOSE:  ADD, SUBTRACT, OR MULTIPLY IMAGES
C            OR MULTIPLY FOURIER TRANSFORMS
C            BOTH IMAGES HAVE TO HAVE THE SAME SIZE.
C
C  PARAMETERS:     
C        VOLBUF       INPUT VOLUME (#1)
C        LUNIN        I/O UNIT NUMBER OF INPUT FILE #2
C        ITYPE       IFORM OF INPUT VOLUME
C        NX,NY    X & Y DIMENSIONS OF IMAGES
C        NZ       Z DIMENSION OF IMAGES
C        SIGT        +1    1 IS ADDED TO 2
C                    -1    2 IS SUBTRACTED FROM 1 
C                    +2    1 IS MULTIPLIED WITH 2 
C                    -2    2 IS DIVIDED BY 1,
C                          OR COMPLEX FOURIER MULTIPLICATION WITH CONJUGATE
C                    -3    COMPLEX 2 IS DIVIDED BY COMPLEX 1
C                    +5    ARITHMETIC OR OF 1 WITH 2 
C                          
C    VARIABLES: IFORM (TYPE)  FILE TYPE SPECIFIER. 
C	         +1    R    2-D IMAGE
C                +3   R3    3-D IMAGE
C               -11   O2    2-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -12   E2    2-D FOURIER TRANSFORM, MIXED RADIX EVEN
C               -21   O3    3-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -22   E3    3-D FOURIER TRANSFORM, MIXED RADIX EVEN
C
CC23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE ADD(VOLBUF,LUNIN,ITYPE,NX,NY,NZ,SIGN)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        REAL       :: VOLBUF(1)
        INTEGER    :: LUNIN,ITYPE,NX,NY,NZ 
        REAL       :: SIGN

        REAL       :: SIGT

        COMMON /IOBUF/ BUF(NBUFSIZ)

C       DOES NOT WORK ON SOME ODD FILE FORMATS NO LONGER IN USE
        IF (ITYPE == 0  .OR. ITYPE == 8  .OR. ITYPE == 11 .OR.
     &	    ITYPE == 12 .OR. ITYPE == 16 .OR. ITYPE == -9)  THEN
            CALL ERRT(102,'ADD; UNSUPPORTED FORMAT',ITYPE)
            RETURN
        ENDIF

C       SIGT MAY BE A CONSTANT
        SIGT = SIGN

        IF ( INDEX(FCHAR(4:) ,'D') > 0 .OR. 
     &             FCHAR(1:2) == '12')   THEN
C           DIVIDE
            IF (ITYPE < 0) THEN
C              FOURIER FILES
               SIGT = -3.0
               WRITE(NOUT,*) 'COMPLEX DIVISION'
            ELSE
               SIGT = -2.0
               WRITE(NOUT,*) 'DIVISION'
            ENDIF

        ELSEIF ( INDEX(FCHAR(4:) ,'M') > 0 ) THEN
           SIGT = -2.0
           WRITE(NOUT,*) 'COMPLEX MULTIPLICATION -- (X) * CONJG(Y)'

        ELSEIF ( INDEX(FCHAR(4:) ,'O') > 0 ) THEN
           SIGT = +5.0
           WRITE(NOUT,*) 'ARITHMETIC OR'
        ENDIF


	NREC  = NY * NZ
        ILOC  = 0

	IF (SIGT == +1.0)  THEN
C           SIGT        +1    2 IS ADDED TO 1 --------------------- ADD
            DO IREC=1,NREC
		CALL REDLIN(LUNIN,BUF,NX,IREC)

            	DO  IX=1,NX
                   ILOC         = ILOC + 1
  		   VOLBUF(ILOC) = VOLBUF(ILOC) + BUF(IX)
                ENDDO
            ENDDO
           	
	ELSEIF (SIGT == -1.0)  THEN
C          SIGT        -1    2 IS SUBTRACTED FROM 1 --------------- SUB
           DO IREC=1,NREC
	       CALL REDLIN(LUNIN,BUF,NX,IREC)
          	DO  IX=1,NX
                  ILOC         = ILOC + 1
                  VOLBUF(ILOC) = VOLBUF(ILOC) - BUF(IX)
               ENDDO
           ENDDO

	ELSEIF (SIGT == +2.0)  THEN
C          SIGT        +2    2 IS MULTIPLIED BY 1 ---------------- MULT

	   IF (IFORM > 0)  THEN
C              REAL FILES
               DO IREC=1,NREC
		  CALL REDLIN(LUNIN,BUF,NX,IREC)
            	  DO  IX=1,NX
                     ILOC         = ILOC + 1
  		     VOLBUF(ILOC) = VOLBUF(ILOC) * BUF(IX)
                  ENDDO
              ENDDO

	   ELSEIF (IFORM < 0)  THEN
C             FOURIER FILES
              CALL CADD(VOLBUF,LUNIN,ITYPE,NX,NY,NZ,SIGT)	
           ENDIF
	
	ELSEIF (SIGT  ==  -2.0)  THEN
C          SIGT        -2    1 IS DIVIDED BY 2 ----------------- DIVIDE
C          OR COMPLEX FOURIER MULTIPLICATION WITH CONJUGATE
           WRITE(NOUT,*) 'DIVISION'

	   IF (IFORM > 0)  THEN
	       IZCOUN = 0
               DO IREC=1,NREC
		  CALL REDLIN(LUNIN,BUF,NX,IREC)
            	  DO  IX=1,NX
                     ILOC         = ILOC + 1
		     IF (BUF(IX) .NE. 0) THEN
		        VOLBUF(ILOC) = VOLBUF(ILOC) / BUF(IX)
		     ELSE
		        VOLBUF(ILOC) = 0.0
		        IZCOUN = IZCOUN + 1
		     ENDIF
                  ENDDO
              ENDDO

	      IF (IZCOUN .GT. 0) WRITE(NOUT,160) IZCOUN
160	      FORMAT(' --- WARNING: ',I7,' OUTPUT PIXELS SET TO 0.0 ',
     &               'WHEN DIVISION BY 0 ATTEMPTED')

	   ELSEIF (IFORM .LT. 0)  THEN
C             COMPLEX FOURIER MULTIPLICATION WITH CONJUGATE

              CALL CADD(VOLBUF,LUNIN,ITYPE,NX,NY,NZ,SIGT)	
	   ENDIF


   	ELSEIF (SIGT == -3.0)  THEN
C          SIGT        -3    COMPLEX 2 IS DIVIDED BY COMPLEX 1 ---- DIV
           WRITE(NOUT,*) 'COMPLEX DIVISION'

           CALL CADD(VOLBUF,LUNIN,ITYPE,NX,NY,NZ,SIGT)	


	ELSEIF (SIGT == +5.0)  THEN
C          SIGT        +5   ARITHMETIC OR OF 1 WITH 2 -------------- OR

	   IF  (IFORM .GT. 0)  THEN
               DO IREC=1,NREC
		  CALL REDLIN(LUNIN,BUF,NX,IREC)
            	  DO  IX=1,NX
                     ILOC = ILOC + 1
                     B    = BUF(IX)
                     IF (B  ==  0.0) B = VOLBUF(ILOC)
                     VOLBUF(ILOC) = B
                  ENDDO
              ENDDO

	   ELSE
C              NOT IMPLEMENTED FOR FOURIER
	       CALL ERRT(101,'ADD, OR NOT IMPLEMENTED FOR FOURIER',NE)
	   ENDIF
	ELSE
C          UNKNOWN SIGT
	   CALL ERRT(23,'ADD',NE)
	ENDIF

        RETURN
        END
 
C++*********************************************************************
C
C  CADD.F                                   WRITTEN MAR 99 ARDEAN LEITH
C
C **********************************************************************
C
C       CADD IS KLUDGE TO AVOID EQUIVALENCING VOLBUF TO  CVOLBUFF
C
C **********************************************************************

        SUBROUTINE CADD(CVOLBUF,LUNIN,ITYPE,NX,NY,NZ,SIGT)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        COMPLEX         :: CVOLBUF(1)

        COMMON /IOBUF/ BUF(NBUFSIZ)
        COMPLEX        :: CBUF(1)
        EQUIVALENCE       (BUF(1),CBUF(1))

	NREC  = NY * NZ
        ILOC  = 0

	IF (SIGT == +2.0)  THEN
C          SIGT        +2    2 IS MULTIPLIED BY 1 --------------- MULT

C          FOURIER FILES
	   NSH = NX / 2

           DO IREC=1,NREC
	      CALL REDLIN(LUNIN,BUF,NX,IREC)
              DO  IX=1,NSH
                 ILOC          = ILOC + 1
                 CVOLBUF(ILOC) = CVOLBUF(ILOC) * CBUF(IX)
              ENDDO
           ENDDO

	ELSEIF (SIGT == -2.0)  THEN

C          COMPLEX 1 FOURIER MULTIPLICATION WITH 2 CONJUGATE ---- CMULT
           NSH = NX / 2

           DO IREC=1,NREC
              CALL REDLIN(LUNIN,BUF,NX,IREC)
              DO  IX=1,NSH
                 ILOC          = ILOC + 1
                 CVOLBUF(ILOC) = CVOLBUF(ILOC) * CONJG(CBUF(IX))
              ENDDO
           ENDDO

	ELSEIF (SIGT == +3.0)  THEN
C          SIGT        +3    1 IS SQUARED -------------------------- SQ

	   NSH = NX / 2

           DO IX=1,NREC*NSH
  	      CVOLBUF(IX) = CVOLBUF(IX) *CONJG(CVOLBUF(IX))
           ENDDO

	ELSEIF (SIGT == -3.0)  THEN
C          SIGT        -3    COMPLEX 1 IS DIVIDED BY COMPLEX 2 --- CDIV

	   NSH = NX / 2

           DO IREC=1,NREC
	      CALL REDLIN(LUNIN,BUF,NX,IREC)
              DO  IX=1,NSH
                 ILOC          = ILOC + 1
  	         CVOLBUF(ILOC) =  CVOLBUF(ILOC) / CBUF(IX)
              ENDDO
           ENDDO

        ENDIF

        END

@


1.30
log
@changes for 'MU 2'... support, NX
@
text
@d17 1
a17 1
C=* Email: spider@@wadsworth.org                                        *
d70 1
a70 1
        INTEGER    :: LUNIN,ITYPE,NX,NY,NZ
@


1.29
log
@GPL_2010
@
text
@d33 1
a33 1
C  ADD(VOLBUF,LUNIN,IFORMT,NSAM,NROW,NSLICE,SIGT)
d42 3
a44 3
C        IFORMT       IFORM OF INPUT VOLUME
C        NSAM,NROW    X & Y DIMENSIONS OF IMAGES
C        NSLICE       Z DIMENSION OF IMAGES
d61 1
a61 5
C
C SUPPORT_ROUTINE
C
C        1         2         3         4         5         6         7
C23456789012345678901234567890123456789012345678901234567890123456789012
d64 1
a64 1
        SUBROUTINE ADD(VOLBUF,LUNIN,IFORMT,NSAM,NROW,NSLICE,SIGN)
d69 5
a73 1
        DIMENSION      VOLBUF(1)
d78 3
a80 3
        IF (IFORMT.EQ.0  .OR. IFORMT.EQ.8  .OR. IFORMT.EQ.11 .OR.
     &	    IFORMT.EQ.12 .OR. IFORMT.EQ.16 .OR. IFORMT.EQ.-9)  THEN
            CALL ERRT(39,'ADD',NE)
d87 2
a88 1
   	IF (FCHAR(4:4) .EQ. 'D' .OR. FCHAR(1:2) .EQ. '12') THEN
d90 1
a90 1
            IF (IFORMT .LT. 0) THEN
d99 1
a99 1
        ELSEIF (FCHAR(4:4) .EQ. 'M')  THEN
d103 1
a103 1
        ELSEIF (FCHAR(4:4) .EQ. 'O')  THEN
d109 1
a109 1
	NREC  = NROW * NSLICE
d112 1
a112 1
	IF (SIGT .EQ. +1.0)  THEN
d115 3
a117 2
		CALL REDLIN(LUNIN,BUF,NSAM,IREC)
            	DO  ISAM=1,NSAM
d119 1
a119 1
  		   VOLBUF(ILOC) = VOLBUF(ILOC) + BUF(ISAM)
d123 1
a123 1
	ELSEIF (SIGT .EQ. -1.0)  THEN
d126 2
a127 2
	       CALL REDLIN(LUNIN,BUF,NSAM,IREC)
          	DO  ISAM=1,NSAM
d129 1
a129 1
                  VOLBUF(ILOC) = VOLBUF(ILOC) - BUF(ISAM)
d133 1
a133 1
	ELSEIF (SIGT .EQ. +2.0)  THEN
d136 1
a136 1
	   IF (IFORM .GT. 0)  THEN
d139 2
a140 2
		  CALL REDLIN(LUNIN,BUF,NSAM,IREC)
            	  DO  ISAM=1,NSAM
d142 1
a142 1
  		     VOLBUF(ILOC) = VOLBUF(ILOC) * BUF(ISAM)
d146 1
a146 1
	   ELSEIF (IFORM .LT. 0)  THEN
d148 1
a148 1
              CALL CADD(VOLBUF,LUNIN,IFORMT,NSAM,NROW,NSLICE,SIGT)	
d151 1
a151 1
	ELSEIF (SIGT .EQ. -2.0)  THEN
d156 1
a156 1
	   IF (IFORM.GT.0)  THEN
d159 2
a160 2
		  CALL REDLIN(LUNIN,BUF,NSAM,IREC)
            	  DO  ISAM=1,NSAM
d162 2
a163 2
		     IF (BUF(ISAM) .NE. 0) THEN
		        VOLBUF(ILOC) = VOLBUF(ILOC) / BUF(ISAM)
d178 1
a178 1
              CALL CADD(VOLBUF,LUNIN,IFORMT,NSAM,NROW,NSLICE,SIGT)	
d182 1
a182 1
   	ELSEIF (SIGT .EQ. -3.0)  THEN
d186 1
a186 1
           CALL CADD(VOLBUF,LUNIN,IFORMT,NSAM,NROW,NSLICE,SIGT)	
d189 1
a189 1
	ELSEIF (SIGT.EQ.+5.0)  THEN
d194 2
a195 2
		  CALL REDLIN(LUNIN,BUF,NSAM,IREC)
            	  DO  ISAM=1,NSAM
d197 2
a198 2
                     B    = BUF(ISAM)
                     IF (B .EQ. 0.0) B = VOLBUF(ILOC)
d205 1
a205 1
	       CALL ERRT(2,'ADD',NE)
d221 1
a221 2
C       CADD IS USED AS KLUDGE TO AVOID EQUIVALENCING VOLBUF TO
C       CVOLBUFF
d225 1
a225 1
        SUBROUTINE CADD(CVOLBUF,LUNIN,IFORMT,NSAM,NROW,NSLICE,SIGT)
d230 1
a230 1
        COMPLEX        CVOLBUF(1)
d233 2
a234 2
        COMPLEX        CBUF(1)
        EQUIVALENCE    (BUF(1),CBUF(1))
d236 1
a236 1
	NREC  = NROW * NSLICE
d239 2
a240 2
	IF (SIGT .EQ. +2.0)  THEN
C          SIGT        +2    2 IS MULTIPLIED BY 1
d243 1
a243 1
	   NSH = NSAM / 2
d246 2
a247 2
	      CALL REDLIN(LUNIN,BUF,NSAM,IREC)
              DO  ISAM=1,NSH
d249 1
a249 1
                 CVOLBUF(ILOC) = CVOLBUF(ILOC) * CBUF(ISAM)
d253 1
a253 1
	ELSEIF (SIGT .EQ. -2.0)  THEN
d255 2
a256 2
C          COMPLEX 1 FOURIER MULTIPLICATION WITH 2 CONJUGATE
           NSH = NSAM / 2
d259 2
a260 2
              CALL REDLIN(LUNIN,BUF,NSAM,IREC)
              DO  ISAM=1,NSH
d262 1
a262 1
                 CVOLBUF(ILOC) = CVOLBUF(ILOC) * CONJG(CBUF(ISAM))
d266 2
a267 2
	ELSEIF (SIGT .EQ. +3.0)  THEN
C          SIGT        +3    1 IS SQUARED
d269 1
a269 1
	   NSH = NSAM / 2
d271 2
a272 2
           DO ISAM=1,NREC*NSH
  	      CVOLBUF(ISAM) = CVOLBUF(ISAM) *CONJG(CVOLBUF(ISAM))
d275 2
a276 2
	ELSEIF (SIGT .EQ. -3.0)  THEN
C          SIGT        -3    COMPLEX 1 IS DIVIDED BY COMPLEX 2
d278 1
a278 1
	   NSH = NSAM / 2
d281 2
a282 2
	      CALL REDLIN(LUNIN,BUF,NSAM,IREC)
              DO  ISAM=1,NSH
d284 1
a284 1
  	         CVOLBUF(ILOC) =  CVOLBUF(ILOC) / CBUF(ISAM)
@


1.28
log
@GPL License fixed
@
text
@a11 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d13 5
a17 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d19 1
a19 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d24 1
a24 1
C=* This program is distributed in the hope that it will be useful,    *
d26 1
a26 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a27 1
C=*                                                                    *
d29 1
a29 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.27
log
@HRI GPL License used
@
text
@a4 1
C++************************************************************************
a11 3
C **************************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
d15 1
a15 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a34 7

C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
a35 1
C **************************************************************************
a70 1
C--************************************************************************
a217 1
C++************************************************************************
a221 1
C **************************************************************************
a226 1
C **************************************************************************
@


1.26
log
@no change
@
text
@d4 1
d12 1
d14 1
d16 24
d46 1
d82 1
d230 1
d235 1
d241 1
@


1.25
log
@div bug
@
text
@d2 2
@


1.24
log
@header
@
text
@d7 1
d64 2
a65 2
        IF (IFORMT.EQ.0 .OR. IFORMT.EQ.8 .OR. IFORMT.EQ.11 .OR.
     &	     IFORMT.EQ.12 .OR. IFORMT.EQ.16 .OR. IFORMT.EQ.-9)  THEN
d73 1
a73 1
   	IF (FCHAR(4:4) .EQ. 'D') THEN
@


1.23
log
@*** empty log message ***
@
text
@d46 4
@


1.22
log
@*** empty log message ***
@
text
@d242 1
a242 1
                 CVOLBUF(ILOC) = CVOLBUF(ISAM) * CONJG(CBUF(ILOC))
@


1.21
log
@order of MU M corrected
@
text
@d229 1
a229 1
                 CVOLBUF(ILOC) = CBUF(ISAM) * CVOLBUF(ILOC)
@


1.20
log
@complex division order fixed
@
text
@d235 1
a235 1
C          COMPLEX FOURIER MULTIPLICATION WITH CONJUGATE
d242 1
a242 1
                 CVOLBUF(ILOC) = CBUF(ISAM) * CONJG(CVOLBUF(ILOC))
@


1.19
log
@CMLIMIT.INC
@
text
@d256 1
a256 1
C          SIGT        -3    COMPLEX 2 IS DIVIDED BY COMPLEX 1
d264 1
a264 1
  	         CVOLBUF(ILOC) = CBUF(ISAM) / CVOLBUF(ILOC)
a269 1
        RETURN
@


1.18
log
@removed imsq.f, rewritten
@
text
@d52 1
a55 1
        PARAMETER      (NBUFSIZ = 17008)
d208 1
a211 1
        PARAMETER      (NBUFSIZ = 17008)
@


1.17
log
@complex operations fixed.
@
text
@d1 1
d4 3
a6 1
C  ADD.FOR                   OUTPUT FILES CHANGED AUG 96 al
d18 1
a18 1
C  ADD(LUN1, LUN2, LUN3, NSAM, NROW, NSLICE, SIGT)
d20 1
a20 1
C  PURPOSE:  ADD, SUBTRACT, OR MULTIPLY TWO IMAGES
d22 6
a27 8
C            THIS SUBROUTINE ADDS, SUBTRACTS, OR MULTIPLIES AN IMAGE
C            STORED IN FILE 1 TO, FROM, OR WITH AN IMAGE STORED IN
C            FILE 2.  BOTH IMAGES HAVE TO HAVE THE SAME SIZE.
C
C********************CHANGED ON 7/21/86 BY MN**************************
C        LUN1         LOGICAL UNIT NUMBER OF INPUT FILE 1
C        LUN2         LOGICAL UNIT NUMBER OF INPUT FILE 2
C        LUN3         LOGICAL UNIT NUMBER OF OUTPUT FILE 
d30 4
a33 4
C        SIGT        +1    1 IS ADDED TO 2, AND RESULT PUT INTO 3
C                    -1    1 IS SUBTRACTED FROM 2, AND RESULT PUT INTO 3
C                    +2    1 IS MULTIPLIED WITH 2, AND RESULT PUT INTO 3
C                    -2    1 IS DIVIDED BY 2, AND RESULT PUT INTO 3
d35 2
a36 5
C                    -3    COMPLEX 1 IS DIVIDED BY COMPLEX 2
C                    +3    1 IS SQUARED, RESULT PUT INTO 3
C                    +4    SQUARE ROOT OF 1 IS COMPUTED AND PUT INTO 3
C                    +5    1 IS MULTIPLIED USING ARITHMETIC OR WITH 2, 
C                             AND RESULT PUT INTO 3
a37 1
C
a45 7
C   !!!  W A R N I N G  !!!
C   What in the comments is referred to as a "second file" is in fact
C   first file in the order of questions asked by the corresponding
C   operation, and what is referred to as a "first file" is
C   the second file in order of questions asked.
C   In other words in it is LUN3 = LUN2 "operation" LUN1
C
d49 1
a49 1
         SUBROUTINE ADD(LUN1,LUN2,LUN3, NSAM,NROW,NSLICE,SIGT)
d51 1
a51 1
         INCLUDE 'CMBLOCK.INC'
d53 1
a53 4
         COMMON  BUF(1)
         COMPLEX CBUF(1)
         COMPLEX DIV
         EQUIVALENCE(BUF(1),CBUF(1))
d55 2
a56 1
CNO_SAVE
d59 2
a60 2
        IF (IFORM.EQ.0 .OR. IFORM.EQ.8 .OR. IFORM.EQ.11 .OR.
     &	     IFORM.EQ.12 .OR. IFORM.EQ.16 .OR. IFORM.EQ.-9)  THEN
d65 23
a88 1
	NSAM1 = NSAM + 1
d90 1
d93 6
a98 6
C           SIGT        +1    1 IS ADDED TO 2, RESULT PUT INTO 3
            DO   I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
            	DO  K=1,NSAM
  		   BUF(K) = BUF(K)+BUF(NSAM+K)
a99 1
 		CALL WRTLIN(LUN3,BUF,NSAM,I)
d101 1
a101 1
		
d103 7
a109 8
C          SIGT        -1    1 IS SUBTRACTED FROM 2, RESULT PUT INTO 3
	   DO  I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		DO   K=1,NSAM
  		   BUF(K)=-BUF(K)+BUF(NSAM+K)
                ENDDO
 		CALL WRTLIN(LUN3,BUF,NSAM,I)
d113 2
a114 1
C          SIGT        +2    1 IS MULTIPLIED WITH 2, RESULT PUT INTO 3
d116 8
a123 9
C               REAL FILES
		DO  I=1,NREC
		   CALL REDLIN(LUN1,BUF,NSAM,I)
		   CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		   DO  K=1,NSAM
                      BUF(K)=BUF(K)*BUF(NSAM+K)
                   ENDDO
		   CALL WRTLIN(LUN3,BUF,NSAM,I)
                ENDDO
d126 3
a128 11
C               FOURIER FILES	
		NSH = NSAM/2
		DO I=1,NREC
		   CALL REDLIN(LUN1,BUF,NSAM,I)
		   CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		   DO  N=1,NSH
    		      CBUF(N)=CBUF(N)*CBUF(NSH+N)
                   ENDDO
    		   CALL WRTLIN(LUN3,BUF,NSAM,I)
                ENDDO
	   ENDIF
d131 4
a134 2
C          SIGT        -2    1 IS DIVIDED BY 2, AND RESULT PUT INTO 2
C                    OR COMPLEX FOURIER MULTIPLICATION WITH CONJUGATE
d136 17
a152 14
		IZCOUN = 0
		DO  I=1,NREC
		   CALL REDLIN(LUN1,BUF,NSAM,I)
		   CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		   DO  K=1,NSAM
		      IF (BUF(K) .NE. 0) THEN
		         BUF(K) = BUF(NSAM+K) / BUF(K)
		      ELSE
		         BUF(K) = 0.0
		         IZCOUN = IZCOUN + 1
		      ENDIF
                   ENDDO
 		   CALL WRTLIN(LUN3,BUF,NSAM,I)
                ENDDO
d154 2
a155 3
		IF (IZCOUN .GT. 0) WRITE(NOUT,160) IZCOUN
160	        FORMAT(' --- WARNING: ',I7,' OUTPUT PIXELS SET TO 0.0 ',
     &                 'WHEN DIVISION BY 0 ATTEMPTED')
d157 1
a157 11
	   ELSEIF (IFORM .LT. 0)  THEN
C               FOURIER MULTIPLICATION 	
		NSH = NSAM / 2
		DO I = 1,NREC
		   CALL REDLIN(LUN1,BUF,NSAM,I)
		   CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		   DO N=1,NSH
    		      CBUF(N) = CBUF(NSH+N) * CONJG(CBUF(N))
                   ENDDO
    		   CALL WRTLIN(LUN3,BUF,NSAM,I)
                ENDDO
a158 12
C
	ELSEIF (SIGT .EQ. +3.0)  THEN
C          SIGT        +3    1 IS SQUARED, RESULT PUT INTO 3
	   IF (IFORM .GT. 0)  THEN
C               REAL IMAGE
		DO  I=1,NREC
		   CALL REDLIN(LUN1,BUF,NSAM,I)
		   DO  K=1,NSAM
                      BUF(NSAM+K)=BUF(K)*BUF(K)
                   ENDDO
 		   CALL WRTLIN(LUN3,BUF(NSAM1),NSAM,I)
                ENDDO
a159 11
	   ELSEIF (IFORM .LT. 0)  THEN	
C               FOURIER IMAGES
		NSH = NSAM/2
		DO I=1,NREC
		   CALL REDLIN(LUN1,BUF,NSAM,I)
		   DO N=1,NSH
                      CBUF(N) = CBUF(N)*CONJG(CBUF(N))
                   ENDDO
                   CALL WRTLIN(LUN3,BUF,NSAM,I)
                ENDDO
	   ENDIF
d161 3
a163 11
	ELSEIF (SIGT .EQ. -3.0)  THEN
C          SIGT        -3    COMPLEX 1 IS DIVIDED BY COMPLEX 2
		NSH = NSAM / 2
		DO I = 1,NREC
		   CALL REDLIN(LUN1,BUF,NSAM,I)
		   CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		   DO N=1,NSH
    		      CBUF(N) = CBUF(NSH+N) / CBUF(N)
                   ENDDO
    		   CALL WRTLIN(LUN3,BUF,NSAM,I)
                ENDDO
d165 1
a166 14
	ELSEIF(SIGT .EQ. +4.0)  THEN
C           SIGT        +4    SQUARE ROOT OF 1 IS COMPUTED AND PUT IN 3
	    IF  (IFORM .GT. 0)  THEN
		DO  I=1,NREC
                   CALL REDLIN(LUN1,BUF,NSAM,I)
                   DO K=1,NSAM
                      BUF(NSAM+K)=SQRT(BUF(K))
                   ENDDO
                   CALL WRTLIN(LUN3,BUF(NSAM+1),NSAM,I)
                ENDDO
	    ELSE
C               NOT IMPLEMENTED FOR FOURIER
		CALL ERRT(2,'ADD',NE)
	    ENDIF
d169 2
a170 2
C          SIGT        +5   1 IS MULTIPLIED WITH 2, RESULT PUT IN 3
C                           WITH ARITHMETIC OR
d172 10
a181 10
		DO  I=1,NREC
                   CALL REDLIN(LUN1,BUF,NSAM,I)
                   CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
                   DO K=1,NSAM
                      B = BUF(NSAM+K)
                      IF (BUF(NSAM+K) .EQ. 0.) B = BUF(K)
                      BUF(K) = B
                   ENDDO
                   CALL WRTLIN(LUN3,BUF,NSAM,I)
                ENDDO
d183 2
a184 2
C               NOT IMPLEMENTED FOR FOURIER
		CALL ERRT(2,'ADD',NE)
d191 82
a272 3
      RETURN
      END
      
@


1.16
log
@*** empty log message ***
@
text
@d34 1
a34 1
C                    -3    COMPLEX 1 IS DIVIDED BY COMPLEX 2 WITH THRESHOLD
a43 1
C                -9   FS    3-D SIMPLE FORMAT FOURIER (MICHAEL'S FORMAT)
d49 7
d72 1
a72 1
     &	     IFORM.EQ.12 .OR. IFORM.EQ.16)  THEN
d159 1
a159 1
    		      CBUF(N) = CBUF(N) * CONJG(CBUF(NSH+N))
d178 1
a178 1
C               FOURIER IAMGES
d190 7
a196 16
C          SIGT        -3    COMPLEX 1 IS DIVIDED BY COMPLEX 2 WITH THRESHOLD
	   IF (IFORM .EQ. -9)  THEN
		WRITE(NOUT,*) 'S-FORMAT COMPLEX DIVISION WITH THRESHOLD'
		CALL RDPRM(THRESH,NLOOP,ILOOP,'THRESHOLD')
		NREC = NREC
		NSH  = NSAM / 2
		DO  L=1,NREC
                   CALL REDLIN(LUN1,BUF,NSAM,L)
                   CALL REDLIN(LUN2,BUF(NSAM+1),NSAM,L)
                   DO  I=1,NSH
                      DIV = CBUF(I)
                      IF (CABS(DIV) .GE. THRESH) THEN
                         CBUF(I) = CBUF(NSH+I) / DIV
                      ELSE
                         CBUF(I) = CBUF(I) / THRESH
                      ENDIF
d198 1
a198 1
                   CALL WRTLIN(LUN3,BUF,NSAM,L)
d200 1
a200 3
	   ELSE
		CALL ERRT(2,'ADD',NE)
	   ENDIF
@


1.15
log
@no need for nsamo calculation
@
text
@d143 1
a143 1
160	        FORMAT(' --- WARNING: ',I7,' OUTPUT PIXELS SET TO 0.0 '
@


1.14
log
@added output files
@
text
@d53 1
a53 1
         SUBROUTINE ADD(LUN1,LUN2,LUN3, NSAMO,NROW,NSLICE,SIGT)
a70 7
	IF (IFORM .GT. 0)  THEN
C          REAL IMAGES
	   NSAM = NSAMO
	ELSE
C          FOURIER IMAGES
	   NSAM = NSAMO+2-MOD(NSAMO,2)
	ENDIF
a73 1

@


1.13
log
@bug fixed
@
text
@d3 1
a3 1
C  ADD.FOR
d15 1
a15 1
C  ADD(LUN1, LUN2, NSAM, NROW, NSLICE, SIGT)
d20 1
a20 1
C            STORED ON FILE 1 TO, FROM, OR WITH AN IMAGE STORED ON
d24 9
a32 7
C        LUN1         LOGICAL UNIT NUMBER OF FILE 1
C        LUN2         LOGICAL UNIT NUMBER OF FILE 2
C        NSAM,NROW    DIMENSIONS OF IMAGES
C        SIGT        +1    1 IS ADDED TO 2
C                    -1    1 IS SUBTRACTED FROM 2
C                    +2    1 IS MULTIPLIED WITH 2, AND RESULT PUT INTO 2
C                    -2    1 IS DIVIDED BY 2, AND RESULT PUT INTO 2
d35 5
a39 4
C                    +3    1 IS SQUARED, RESULT PUT INTO 2
C                    +4    SQUARE ROOT OF 1 IS COMPUTED AND PUT INTO 2
C                    +5    1 IS MULTIPLIED WITH 2, AND RESULT PUT INTO 2
C                          WITH ARITHMETIC OR
d42 3
a44 11
C                0     D    DATA FILE (UNUSED?)
C	        +1     R    2-D IMAGE
C               +3     R3   3-D FILE
C               +8     8    8 BIT BLACK AND WHITE FILE
C               +11    C    8 BIT COLOR FILE
C               +12   -     8 BIT RUNLENGTH BLACK AND WHITE FILE
C               +16   16    16 BIT BLACK AND WHITE FILE
C               -1    F     2-D FOURIER TRANSFORM
C               -3    F3    3-D FOURIER TRANSFORM
C               -7    FQ    3-D FOURIER TRANSFORM, PAUL'S FORMAT
C               -9    FS    3-D SIMPLE FORMAT FOURIER (MICHAEL'S FORMAT)
a49 1
C
d53 2
a54 1
         SUBROUTINE ADD(LUN1,LUN2,NSAMO,NROW,NSLICE,SIGT)
d56 1
d61 1
a61 1
         INTEGER H
d64 3
a66 2
         IF (IFORM.EQ.0 .OR. IFORM.EQ.8 .OR. IFORM.EQ.11
     &	  .OR. IFORM.EQ.12 .OR. IFORM.EQ.16 .OR. IFORM.EQ.-3)  THEN
d68 6
a73 4
         RETURN
         ENDIF
	IF(IFORM.GT.0)  THEN
	NSAM=NSAMO
d75 2
a76 1
	NSAM=NSAMO+2-MOD(NSAMO,2)
d78 116
a193 89
C
	NSAM1=NSAM+1
	NREC=NROW*NSLICE
	IF(SIGT.EQ.+1.0)  THEN
C        SIGT        +1    1 IS ADDED TO 2
		DO  1  I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
            	DO  10  K=1,NSAM
10		BUF(K) = BUF(K)+BUF(NSAM+K)
1		CALL WRTLIN(LUN2,BUF,NSAM,I)
C		
	ELSEIF(SIGT.EQ.-1.0)  THEN
C        SIGT        -1    1 IS SUBTRACTED FROM 2
		DO  2  I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		DO  20 K=1,NSAM
20		BUF(K)=-BUF(K)+BUF(NSAM+K)
2		CALL WRTLIN(LUN2,BUF,NSAM,I)
C
	ELSEIF(SIGT.EQ.+2.0)  THEN
C        SIGT        +2    1 IS MULTIPLIED WITH 2, AND RESULT PUT INTO 2
		IF(IFORM.GT.0)  THEN
		DO  3  I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		DO  30 K=1,NSAM
30		BUF(K)=BUF(K)*BUF(NSAM+K)
3		CALL WRTLIN(LUN2,BUF,NSAM,I)
		ELSEIF(IFORM.LT.0)  THEN	
		NSH=NSAM/2
		DO 4001 I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		DO 4002 N=1,NSH
4002		CBUF(N)=CBUF(N)*CBUF(NSH+N)
4001		CALL WRTLIN(LUN2,BUF,NSAM,I)
		ENDIF
C	
	ELSEIF(SIGT.EQ.-2.0)  THEN
C        SIGT        -2    1 IS DIVIDED BY 2, AND RESULT PUT INTO 2
C                          OR COMPLEX FOURIER MULTIPLICATION WITH CONJUGATE
		IF(IFORM.GT.0)  THEN
		IZCOUN=0
		DO  4  I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		DO  40  K=1,NSAM
		IF (BUF(K) .NE. 0) THEN
		BUF(K) = BUF(NSAM+K)/BUF(K)
		ELSE
		BUF(K) = 0.0
		IZCOUNT=IZCOUN+1
		ENDIF
40		CONTINUE
4		CALL WRTLIN(LUN2,BUF,NSAM,I)
		IF(IZCOUN.GT.0) WRITE(NOUT,160) IZCOUN
160	FORMAT(' *** WARNING:',I6,' TIMES DIVIDE BY 0 ENCOUNTERED',/,
     $	1X,' *** OUTPUT PIXELS SET TO 0')
		ELSEIF(IFORM.LT.0)  THEN	
		NSH=NSAM/2
		DO 5001 I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		DO 5002 N=1,NSH
5002		CBUF(N)=CBUF(N)*CONJG(CBUF(NSH+N))
5001		CALL WRTLIN(LUN2,BUF,NSAM,I)
		ENDIF
C
	ELSEIF(SIGT.EQ.+3.0)  THEN
C        SIGT        +3    1 IS SQUARED, RESULT PUT INTO 2
		IF(IFORM.GT.0)  THEN
		DO  6  I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		DO  60  K=1,NSAM
60		BUF(NSAM+K)=BUF(K)*BUF(K)
6		CALL WRTLIN(LUN2,BUF(NSAM1),NSAM,I)
		ELSEIF(IFORM.LT.0)  THEN	
		NSH=NSAM/2
		DO 6001 I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		DO 6002 N=1,NSH
6002		CBUF(N)=CBUF(N)*CONJG(CBUF(N))
6001		CALL WRTLIN(LUN2,BUF,NSAM,I)
		ENDIF
	ELSEIF(SIGT.EQ.-3.0)  THEN
C        SIGT        -3    COMPLEX 1 IS DIVIDED BY COMPLEX 2 WITH THRESHOLD
		IF(IFORM.EQ.-9)  THEN
d196 16
a211 15
		NREC=NREC
		NSH=NSAM/2
		DO  7001  L=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,L)
		CALL REDLIN(LUN2,BUF(NSAM+1),NSAM,L)
		DO  7002  I=1,NSH
		DIV=CBUF(I)
		IF (CABS(DIV).GE.THRESH) THEN
		CBUF(I)=CBUF(NSH+I)/DIV
		ELSE
		CBUF(I)=CBUF(I)/THRESH
		ENDIF
7002		CONTINUE
7001		CALL WRTLIN(LUN2,BUF,NSAM,L)
		ELSE
d213 14
a226 11
		ENDIF
C
	ELSEIF(SIGT.EQ.+4.0)  THEN
C        SIGT        +4    SQUARE ROOT OF 1 IS COMPUTED AND PUT INTO 2
		IF(IFORM.GT.0)  THEN
		DO  8  I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		DO  80  K=1,NSAM
80		BUF(NSAM+K)=SQRT(BUF(K))
8		CALL WRTLIN(LUN2,BUF(NSAM+1),NSAM,I)
		ELSE
d228 18
a245 15
		ENDIF
C
	ELSEIF(SIGT.EQ.+5.0)  THEN
C        SIGT        +5    1 IS MULTIPLIED WITH 2, AND RESULT PUT INTO 2
C                          WITH ARITHMETIC OR
		IF(IFORM.GT.0)  THEN
		DO  9  I=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,I)
		CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
		DO 81 K=1,NSAM
		B=BUF(NSAM+K)
		IF(BUF(NSAM+K).EQ.0.) B=BUF(K)
81		BUF(K)=B
9		CALL WRTLIN(LUN2,BUF,NSAM,I)
		ELSE
d247 1
a247 2
		ENDIF
C
d249 2
a250 1
	CALL  ERRT(23,'ADD',NE)
d252 2
@


1.12
log
@bug fixed
@
text
@d86 1
a86 1
            	DO  10  K=1,LRC
@


1.11
log
@new version
@
text
@d158 1
a158 1
		DO 5001 I=1,NREC
d160 3
a162 3
		DO 5002 N=1,NSH
5002		CBUF(N)=CBUF(N)*CONJG(CBUF(N))
5001		CALL WRTLIN(LUN2,BUF,NSAM,I)
@


1.10
log
@muw removed
@
text
@a0 1

d50 4
a53 2
C               -11   FO    2-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -12   FE    2-D FOURIER TRANSFORM, MIXED RADIX EVEN
d59 1
a59 1
         SUBROUTINE ADD(LUN1,LUN2,NSAM,NROW,NSLICE,SIGT)
d73 5
d79 2
a82 8
		IF(IFORM.EQ.-1)  THEN
		NREC=(NSAM+2)*NROW
		NREC=NREC/NSAM
		IF(MOD((NSAM+2)*NROW,NSAM).NE.0)  NREC=NREC+1
		ELSE
		NREC=NROW*NSLICE
		ENDIF
		NSAM1=NSAM+1
d86 1
a86 1
            	DO  10  K=1,NSAM
a91 8
		IF(IFORM.EQ.-1)  THEN
		NREC=(NSAM+2)*NROW
		NREC=NREC/NSAM
		IF(MOD((NSAM+2)*NROW,NSAM).NE.0)  NREC=NREC+1
		ELSE
		NREC=NROW*NSLICE
		ENDIF
		NSAM1=NSAM+1
a101 2
		NREC=NROW*NSLICE
		NSAM1=NSAM+1
d108 1
a108 20
		ELSEIF(IFORM.EQ.-1)  THEN	
		JRPREV=0
		DO 2200 H=0,NSAM/2
		DO 2100 K=-NROW/2+1,NROW/2
		CALL FFIND(NSAM,NROW,H,K,JR,NADDR,PH)
		IF (JR.EQ.JRPREV) GOTO 2050
		IF (JRPREV.GT.0) CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
		CALL REDLIN(LUN2,CBUF,NSAM,JR)
		CALL REDLIN(LUN1,CBUF(NSAM+1),NSAM,JR)
		JRPREV=JR
2050		CBUF(NADDR)=CBUF(NADDR)*CBUF(NSAM+NADDR)
2100		CONTINUE
2200		CONTINUE
		CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
		ELSEIF(IFORM.EQ.-7)  THEN	
		WRITE(NOUT,*) ' Q-FORMAT FOURIER'
		CALL  MULF3(LUN2,LUN1,BUF,BUF(NSAM+1),BUF(2*NSAM+1),
     &		BUF(3*NSAM+1),NSAM,NROW,NSLICE,SIGT)
		ELSEIF(IFORM.EQ.-9)  THEN
		NREC=NROW*NSLICE
d110 6
a115 9
		DO 4001 L=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,L)
		CALL REDLIN(LUN2,BUF(NSAM+1),NSAM,L)
		DO 4002 I=1,NSH
4002		CBUF(I)=CBUF(I)*CBUF(NSH+I)
4001		CALL WRTLIN(LUN2,BUF,NSAM,L)
		ELSEIF(IFORM.EQ.-11.OR.IFORM.EQ.-12)  THEN	
		CALL  MULF2(LUN2,LUN1,BUF,BUF(NSAM+1),BUF(2*NSAM+1),
     &		BUF(3*NSAM+1),NSAM,NROW,SIGT)
a121 2
		NREC=NROW*NSLICE
		NSAM1=NSAM+1
d138 1
a138 20
		ELSEIF(IFORM.EQ.-1)  THEN	
		JRPREV=0
		DO 5200 H=0,NSAM/2
		DO 5100 K=-NROW/2+1,NROW/2
		CALL FFIND(NSAM,NROW,H,K,JR,NADDR,PH)
		IF (JR.EQ.JRPREV) GOTO 5050
		IF (JRPREV.GT.0) CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
		CALL REDLIN(LUN2,CBUF,NSAM,JR)
		CALL REDLIN(LUN1,CBUF(NSAM+1),NSAM,JR)
		JRPREV=JR
5050		CBUF(NADDR)=CBUF(NADDR)*CONJG(CBUF(NSAM+NADDR))
5100		CONTINUE
5200		CONTINUE
		CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
		ELSEIF(IFORM.EQ.-7)  THEN	
		WRITE(NOUT,*) ' Q-FORMAT FOURIER'
		CALL  MULF3(LUN2,LUN1,BUF,BUF(NSAM+1),BUF(2*NSAM+1),
     &		BUF(3*NSAM+1),NSAM,NROW,NSLICE,SIGT)
		ELSEIF(IFORM.EQ.-9)  THEN
		NREC=NROW*NSLICE
d140 6
a145 9
		DO 5001 L=1,NREC
		CALL REDLIN(LUN1,BUF,NSAM,L)
		CALL REDLIN(LUN2,BUF(NSAM+1),NSAM,L)
		DO 5002 I=1,NSH
5002		CBUF(I)=CBUF(I)*CONJG(CBUF(NSH+I))
5001		CALL WRTLIN(LUN2,BUF,NSAM,L)
		ELSEIF(IFORM.EQ.-11.OR.IFORM.EQ.-12)  THEN	
		CALL  MULF2(LUN2,LUN1,BUF,BUF(NSAM+1),BUF(2*NSAM+1),
     &		BUF(3*NSAM+1),NSAM,NROW,SIGT)
a150 1
		NREC=NROW*NSLICE
d155 8
a162 4
6		CALL WRTLIN(LUN2,BUF(NSAM+1),NSAM,I)
		ELSE
c what about complex squared ?
		CALL ERRT(2,'ADD',NE)
d169 1
a169 1
		NREC=NROW*NSLICE
a189 1
		NREC=NROW*NSLICE
a202 1
		NREC=NROW*NSLICE
@


1.9
log
@new version
@
text
@a71 32
C ...........  will be removed
C        WIENER FILTERING, OPTION 'W'.
         IF (FCHAR(4:4) .EQ. 'W')  THEN
            WRITE(NOUT,*) ' WIENER FILTER'
            CALL RDPRM(SNR,NLOOP,ILOOP,'SNR')
            IF (SNR.NE.0.0)  SNR=1.0/SNR
            IF (IFORM.EQ.-7)  THEN
                CALL  MUW3(LUN2,LUN1,BUF,BUF(NSAM+1),BUF(2*NSAM+1),
     &          BUF(3*NSAM+1),NSAM,NROW,NSLICE,SNR)
            ELSEIF (IFORM.EQ.-1)  THEN
               JRPREV=0
               DO 7200 H=0,NSAM/2
                  DO 7100 K=-NROW/2+1,NROW/2
                     CALL FFIND(NSAM,NROW,H,K,JR,NADDR,PH)
                     IF (JR.EQ.JRPREV) GOTO 7050
                     IF (JRPREV.GT.0)CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
                     CALL REDLIN(LUN2,CBUF,NSAM,JR)
                     CALL REDLIN(LUN1,CBUF(NSAM+1),NSAM,JR)
                     JRPREV=JR
7050                 CBUF(NADDR)=CBUF(NADDR)*CONJG(CBUF(NSAM+NADDR))
     &		        /(CABS(CBUF(NSAM+NADDR))**2+SNR)
7100              CONTINUE
7200           CONTINUE
               CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
	    ELSE
	       WRITE(NOUT,*)
     &              '*** ONLY 2D OR 3D FOURIER FORMAT SUPPORTED !'
               CALL ERRT(100,'ADD',NE)
	    ENDIF
            RETURN
         ENDIF
C ...........
@


1.8
log
@new version
@
text
@d225 1
a225 1
		DO 5001 L=1,IEND
a304 1
	END
@


1.7
log
@nosave
@
text
@d36 2
d39 16
a58 2

#ifdef SP_UNIX
a59 3
#else
         INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
d67 3
a69 4
         IF (IFORM.EQ.-5 .OR. IFORM.EQ.-3)  THEN
            WRITE(NOUT,*)  
     &         '*** COMMAND NOT SUPPORTED FOR THIS FILE FORMAT'
            CALL ERRT(100,'ADD',NE)
d72 1
a72 1

d80 1
a80 1
     &          BUF(3*NSAM+1), NSAM,NROW,NSLICE,SNR)
d103 203
a305 199

C        FOR 2-D F.T. (IT DOES NOT MOVE THE ORIGIN)
         IF (IFORM.EQ.-1.AND.SIGT.NE.1.0) GOTO 2000

C        FOR 3-D F.T. (IT DOES NOT MOVE THE ORIGIN)
         IF (IFORM.EQ.-7.AND.SIGT.NE.1.0) GOTO 3000

C        FOR SIMPLE FORMAT 3D FOURIER. (NO ORIGIN SHIFT)
         IF (IFORM.EQ.-9.AND.ABS(SIGT).EQ.2.0) GOTO 4000

C        SIMPLE FORMAT FOURIER DIVISION
         IF (IFORM.EQ.-9.AND.SIGT.EQ.-3.0) GOTO 5000

C        THIS LINE NEEDS TO BE CHECKED FOR 2D APPLICATIONS:
         IF (IFORM .EQ. -1) NROW=NROW+1
         NSAM1 = NSAM+1
         NROW2 = NSLICE*NROW

C        ADDED FOR 3-D ADDITION
         IF (SIGT .LT. 0.0) GOTO 100

         IF (SIGT .GT. 1.0) GOTO 30

         F1=1.0
C        MU M IS MULTIPLY FIRST COMPLEX FILE BY THE SECOND
         IF (FCHAR(4:4) .EQ. 'M')
     &      CALL RDPRM(F1,NLOOP,ILOOP,'ENTER FACTOR')

C        MULTIPLY
         DO 20 I = 1, NROW2
            CALL REDLIN(LUN1,BUF,NSAM,I)
            CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
            DO 10 K = 1, NSAM
               BUF(K) = BUF(K)*F1+BUF(NSAM+K)
10          CONTINUE
            CALL WRTLIN(LUN2,BUF,NSAM,I)
20       CONTINUE
         RETURN

30       IF (SIGT .GT. 2.5) GOTO 50
         DO 40 I = 1, NROW2
         CALL REDLIN(LUN1,BUF,NSAM,I)
         CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
C        12/08/89 JF: 'MU O' OPTION RESTORED.
         IF (FCHAR(4:4).EQ.'O') THEN
             DO 31 K=1,NSAM
               B=BUF(NSAM+K)
               IF (BUF(NSAM+K).EQ.0.) B=BUF(K)
31          BUF(K)=B
            GOTO 38
         ENDIF
         DO 35 K = 1, NSAM
            BUF(K) = BUF(K)*BUF(NSAM+K)
35       CONTINUE
38       CALL WRTLIN(LUN2,BUF,NSAM,I)
40    CONTINUE
      RETURN

50    IF (SIGT .GT. 3.) GOTO 300
      DO 70 I = 1, NROW2
         CALL REDLIN(LUN1,BUF,NSAM,I)
         DO 55 K = 1, NSAM
            BUF(K) = BUF(K)*BUF(K)
55       CONTINUE
         CALL WRTLIN(LUN2,BUF,NSAM,I)
70    CONTINUE
      RETURN

C     TAKE CARE OF DIVISION OR MUTLTIPLY BY COMPLEX CONJUGATE
100   IF (SIGT .LT. -1.0) GOTO 130

      DO 120 I = 1, NROW2
         CALL REDLIN(LUN1,BUF,NSAM,I)
         CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
         DO 110 K = 1, NSAM
             BUF(K) = -BUF(K) + BUF(NSAM+K)
110      CONTINUE
         CALL WRTLIN(LUN2,BUF,NSAM,I)
120   CONTINUE
      RETURN

C     DIVIDE 1 BY 2
C     BECAUSE IN THE CALL FOR THE MULTIPLICATION IN UTIL2 LUN1,LUN2
C     ARE INTERCHANGED ITS DONE HERE AGAIN.
130   CONTINUE
      IZCOUN=0

      DO 150 I = 1, NROW2
         CALL REDLIN(LUN1,BUF,NSAM,I)
         CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
         DO 140 K = 1,NSAM
            IF (BUF(K) .NE. 0) THEN
               BUF(K) = BUF(NSAM+K)/BUF(K)
            ELSE
               BUF(K) = 0
               IZCOUNT=IZCOUN+1
            ENDIF
140      CONTINUE
         CALL WRTLIN(LUN2,BUF,NSAM,I)
150   CONTINUE
      IF (IZCOUN .GT. 0) WRITE(NOUT,160) IZCOUN
160   FORMAT(' *** WARNING:',I6,' TIMES DIVIDE BY 0 ENCOUNTERED',/,
     $   1X,' *** OUTPUT PIXELS SET TO 0')
      RETURN

300   DO 320 I = 1, NROW2
         CALL REDLIN(LUN1,BUF,NSAM,I)
         DO 310 K = 1, NSAM
310      BUF(NSAM+K)=SQRT(BUF(K))
         CALL WRTLIN(LUN2,BUF(NSAM+1),NSAM,I)
320   CONTINUE
      RETURN


2000  CONTINUE
      JRPREV=0
      DO 2200 H=0,NSAM/2
          DO 2100 K=-NROW/2+1,NROW/2
            CALL FFIND(NSAM,NROW,H,K,JR,NADDR,PH)
            IF (JR.EQ.JRPREV) GOTO 2050
            IF (JRPREV.GT.0) CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
            CALL REDLIN(LUN2,CBUF,NSAM,JR)
            CALL REDLIN(LUN1,CBUF(NSAM+1),NSAM,JR)
            JRPREV=JR
2050        IF (SIGT.EQ.-2.0)  THEN
               CBUF(NADDR)=CBUF(NADDR)*CONJG(CBUF(NSAM+NADDR))
            ELSE
               CBUF(NADDR)=CBUF(NADDR)*CBUF(NSAM+NADDR)
            ENDIF
2100     CONTINUE
2200  CONTINUE
      CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
      RETURN


3000  CONTINUE
      WRITE(NOUT,*) ' Q-FORMAT FOURIER'
      CALL  MULF3(LUN2,LUN1,BUF,BUF(NSAM+1),BUF(2*NSAM+1),
     &   BUF(3*NSAM+1), NSAM,NROW,NSLICE,SIGT)
      RETURN

C        NDIMHH=NROW/2+1
C        NDIMH= NROW/2
C        NDIM=NROW
C        NDDIM= NROW*2
C        KSIGN=1
C        DO 1030 I=1, NDIMHH
C           KSIGN=KSIGN*(-1)
C           DO 1020 II=1,NDDIM
C              CALL REDLIN(LUN1,BUF(NDIM+1),NDIM,(I-1)*NDDIM+II)
C              CALL REDLIN(LUN2,BUF,NDIM,(I-1)*NDDIM+II)
C              DO 1010 K=1,NDIMH
C                 KSIGN=KSIGN*(-1)
C                 CBUF(K)=CBUF(K)*CONJG(CBUF(NDIMH+K))*FLOAT(KSIGN)
C1010          CONTINUE
C              KSIGN=KSIGN*(-1)**(II+1)
C              CALL WRTLIN(LUN2,BUF,NDIM,(I-1)*NDDIM+II)
C1020       CONTINUE
C1030    CONTINUE


4000  WRITE(NOUT,*) 'S-FORMAT FOURIER'
      IEND=NROW*NSLICE
      NSH=NSAM/2
      DO 4001 L=1,IEND
         CALL REDLIN(LUN1,BUF,NSAM,L)
         CALL REDLIN(LUN2,BUF(NSAM+1),NSAM,L)
         DO 4002 I=1,NSH
            IF(SIGT.EQ.-2) THEN
               CBUF(I)=CBUF(I)*CONJG(CBUF(NSH+I))
            ELSE
               CBUF(I)=CBUF(I)*CBUF(NSH+I)
            ENDIF
4002     CONTINUE
         CALL WRTLIN(LUN2,BUF,NSAM,L)
4001  CONTINUE
      RETURN


5000  CONTINUE
      WRITE(NOUT,*) 'S-FORMAT COMPLEX DIVISION WITH THRESHOLD'
      CALL RDPRM(THRESH,NLOOP,ILOOP,'THRESHOLD')
      IEND=NROW*NSLICE
      NSH=NSAM/2
      DO 5001 L=1,IEND
         CALL REDLIN(LUN1,BUF,NSAM,L)
         CALL REDLIN(LUN2,BUF(NSAM+1),NSAM,L)
         DO 5002 I=1,NSH
            DIV=CBUF(I)
            IF (CABS(DIV).GE.THRESH) THEN
               CBUF(I)=CBUF(NSH+I)/DIV
            ELSE
              CBUF(I)=CBUF(I)/THRESH
            ENDIF
5002     CONTINUE
         CALL WRTLIN(LUN2,BUF,NSAM,L)
5001  CONTINUE

      RETURN
@


1.6
log
@cosmetic and / by zero not set to 0
@
text
@d52 1
@


1.5
log
@2D wiener filter added.
@
text
@d1 1
d16 1
a16 1
C  ADD(LUN1, LUN2, NSAM, NROW, NSLICE, SIG)
d35 1
a35 1
C           +4    SQUARE ROOT OF 1 IS COMPUTED AND PUT INTO 2
a50 1
C
d52 1
a52 2
C
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
d54 3
a56 1
         WRITE(NOUT,*)  ' Sorry, command not supported !'
d59 30
a88 28
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C  Wiener filtering, option 'W'.
         IF(FCHAR(4:4).EQ.'W')  THEN
         WRITE(NOUT,*) ' Wiener filter'
         CALL RDPRM(SNR,NLOOP,ILOOP,'SNR')
         IF(SNR.NE.0.0)  SNR=1.0/SNR
         IF(IFORM.EQ.-7)  THEN
       CALL  MUW3(LUN2,LUN1,BUF,BUF(NSAM+1),BUF(2*NSAM+1),BUF(3*NSAM+1),
     &   NSAM,NROW,NSLICE,SNR)
         ELSEIF(IFORM.EQ.-1)  THEN
         JRPREV=0
         DO 7200 H=0,NSAM/2
         DO 7100 K=-NROW/2+1,NROW/2
         CALL FFIND(NSAM,NROW,H,K,JR,NADDR,PH)
         IF (JR.EQ.JRPREV) GOTO 7050
         IF (JRPREV.GT.0) CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
         CALL REDLIN(LUN2,CBUF,NSAM,JR)
         CALL REDLIN(LUN1,CBUF(NSAM+1),NSAM,JR)
         JRPREV=JR
7050     CBUF(NADDR)=CBUF(NADDR)*CONJG(CBUF(NSAM+NADDR))
     &		/(CABS(CBUF(NSAM+NADDR))**2+SNR)
7100     CONTINUE
7200     CONTINUE
         CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
	 ELSE
	 WRITE(NOUT,*)  ' Only 2D or 3D Fourier format supported !'
	 ENDIF
         RETURN
d90 2
d93 2
a94 1
C                            !FOR 2-D F.T. (IT DOES NOT MOVE THE ORIGIN)
d96 2
a97 1
C                            !FOR 3-D F.T. (IT DOES NOT MOVE THE ORIGIN)
d99 2
a100 1
C                            !FOR SIMPLE FORMAT 3D FOURIER. (NO ORIGIN SHIFT)
a101 1
C                            !SIMPLE FORMAT FOURIER DIVISION
d103 2
a104 2
C this line needs to be checked for 2D applications:
         IF (IFORM.EQ.-1) NROW=NROW+1
d107 12
a118 7
C             ADDED FOR 3-D ADDITION
         IF (SIGT.LT.0.) GOTO 100
         IF (SIGT.GT.1.) GOTO 30

         F1=1.
         IF (FCHAR(4:4).EQ.'M')
     &   CALL RDPRM(F1,NLOOP,ILOOP,'ENTER FACTOR$')
d120 6
a125 6
         CALL REDLIN(LUN1,BUF,NSAM,I)
         CALL REDLIN(LUN2,BUF(NSAM1),NSAM,I)
         DO 10 K = 1, NSAM
         BUF(K) = BUF(K)*F1+BUF(NSAM+K)
10       CONTINUE
         CALL WRTLIN(LUN2,BUF,NSAM,I)
d129 1
a129 1
30       IF (SIGT.GT.2.5) GOTO 50
d133 1
a133 1
C 12/08/89 JF: 'MU O' OPTION RESTORED.
d135 5
a139 5
         DO 31 K=1,NSAM
         B=BUF(NSAM+K)
         IF (BUF(NSAM+K).EQ.0.) B=BUF(K)
31       BUF(K)=B
         GOTO 38
d142 1
a142 1
         BUF(K) = BUF(K)*BUF(NSAM+K)
d145 2
a146 2
40       CONTINUE
         RETURN
d148 2
a149 2
50       IF (SIGT.GT.3.)GOTO 300
         DO 70 I = 1, NROW2
d152 1
a152 1
         BUF(K) = BUF(K)*BUF(K)
d155 5
a159 2
70       CONTINUE
         RETURN
d161 1
a161 2
100      IF (SIGT.LT.-1.0) GOTO 130
         DO 120 I = 1, NROW2
d165 1
a165 1
         BUF(K) = -BUF(K) + BUF(NSAM+K)
d168 2
a169 2
120      CONTINUE
         RETURN
d171 5
a175 5
C DIVIDE 1 BY 2
C BECAUSE IN THE CALL FOR THE MULTIPLICATION IN UTIL2 LUN1,LUN2
C ARE INTERCHANGED ITS DONE HERE AGAIN.
130      CONTINUE
         IZCOUN=0
d177 1
a177 1
         DO 150 I = 1, NROW2
d181 6
a186 6
         IF (BUF(K) .NE. 0) THEN
         BUF(K) = BUF(NSAM+K)/BUF(K)
         ELSE
         BUF(NSAM+K)=0
         IZCOUNT=IZCOUN+1
         ENDIF
d189 3
a191 3
150      CONTINUE
         IF (IZCOUN.GT.0)WRITE(NOUT,160) IZCOUN
160      FORMAT(1H ,'*** WARNING:',I6,' TIMES DIVIDE BY 0 ENCOUNTERED'/
d193 1
a193 1
         RETURN
d195 1
a195 1
300      DO 320 I = 1, NROW2
d200 3
a202 4
320      CONTINUE
         RETURN
C
2000     CONTINUE
d204 15
a218 14
         JRPREV=0
         DO 2200 H=0,NSAM/2
         DO 2100 K=-NROW/2+1,NROW/2
         CALL FFIND(NSAM,NROW,H,K,JR,NADDR,PH)
         IF (JR.EQ.JRPREV) GOTO 2050
         IF (JRPREV.GT.0) CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
         CALL REDLIN(LUN2,CBUF,NSAM,JR)
         CALL REDLIN(LUN1,CBUF(NSAM+1),NSAM,JR)
         JRPREV=JR
2050     IF(SIGT.EQ.-2.0)  THEN
         CBUF(NADDR)=CBUF(NADDR)*CONJG(CBUF(NSAM+NADDR))
         ELSE
         CBUF(NADDR)=CBUF(NADDR)*CBUF(NSAM+NADDR)
         ENDIF
d220 35
a254 32
2200     CONTINUE
         CALL WRTLIN(LUN2,CBUF,NSAM,JRPREV)
         RETURN
C
C
3000     CONTINUE
         WRITE(NOUT,*) ' Q-format fourier'
      CALL  MULF3(LUN2,LUN1,BUF,BUF(NSAM+1),BUF(2*NSAM+1),BUF(3*NSAM+1),
     &   NSAM,NROW,NSLICE,SIGT)
         RETURN
C     NDIMHH=NROW/2+1
C      NDIMH= NROW/2
C      NDIM=NROW
C      NDDIM= NROW*2
C      KSIGN=1
C      DO 1030 I=1, NDIMHH
C         KSIGN=KSIGN*(-1)
C         DO 1020 II=1,NDDIM
C            CALL REDLIN(LUN1,BUF(NDIM+1),NDIM,(I-1)*NDDIM+II)
C            CALL REDLIN(LUN2,BUF,NDIM,(I-1)*NDDIM+II)
C            DO 1010 K=1,NDIMH
C               KSIGN=KSIGN*(-1)
C               CBUF(K)=CBUF(K)*CONJG(CBUF(NDIMH+K))*FLOAT(KSIGN)
C1010        CONTINUE
C            KSIGN=KSIGN*(-1)**(II+1)
C            CALL WRTLIN(LUN2,BUF,NDIM,(I-1)*NDDIM+II)
C1020     CONTINUE
C1030  CONTINUE
4000     WRITE(NOUT,*) 'S-format fourier'
         IEND=NROW*NSLICE
         NSH=NSAM/2
         DO 4001 L=1,IEND
d258 5
a262 5
         IF(SIGT.EQ.-2) THEN
         CBUF(I)=CBUF(I)*CONJG(CBUF(NSH+I))
         ELSE
         CBUF(I)=CBUF(I)*CBUF(NSH+I)
         ENDIF
d265 10
a274 8
4001     CONTINUE
         RETURN
5000     CONTINUE
         WRITE(NOUT,*) 'S-format Complex division with threshold'
         CALL RDPRM(THRESH,NLOOP,ILOOP,'THRESHOLD')
         IEND=NROW*NSLICE
         NSH=NSAM/2
         DO 5001 L=1,IEND
d278 6
a283 6
         DIV=CBUF(I)
         IF(CABS(DIV).GE.THRESH) THEN
         CBUF(I)=CBUF(NSH+I)/DIV
         ELSE
         CBUF(I)=CBUF(I)/THRESH
         ENDIF
d286 5
a290 2
5001     CONTINUE
         END
@


1.4
log
@mu w added
@
text
@a60 4
         IF(IFORM.NE.-7)  THEN
		WRITE(NOUT,*)  ' Only 3D Fourier format supported !'
		RETURN
	 ENDIF
d64 1
d67 18
@


1.3
log
@cosmetic
@
text
@d59 13
@


1.2
log
@cpp_lines_added
@
text
@d3 1
a3 1
C $$ ADD.FOR
d15 1
d17 5
a22 14
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ ADD.FOR
C
         SUBROUTINE ADD(LUN1,LUN2,NSAM,NROW,NSLICE,SIGT)
C
C $$ ADD:    ADD, SUBTRACT, OR MULTIPLY TWO IMAGES
C     OR MULTIPLY FOURIER TRANSFORMS
C      THIS SUBROUTINE ADDS, SUBTRACTS, OR MULTIPLIES AN IMAGE
C      STORED ON FILE 1 TO, FROM, OR WITH AN IMAGE STORED ON
C      FILE 2.  BOTH IMAGES HAVE TO HAVE THE SAME SIZE.
C
C      CALL ADD(LUN1, LUN2, NSAM, NROW, NSLICE, SIG)
d35 6
d67 1
a67 1
C
d75 1
a75 1
C
d162 1
a162 1
C
d224 1
a224 1
         CALL RDPRM(THRESH,NLOOP,ILOOP,'THRESHOLD$')
@


1.1
log
@Initial revision
@
text
@d43 3
d47 1
@
