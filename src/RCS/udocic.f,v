head	1.50;
access;
symbols
	healthdept_2018:1.50
	pre_getangas:1.49
	GPL2010:1.49
	pre_GPL2010:1.48
	pre_var_equation:1.47
	pre_fftwrings:1.45
	pre_opfiles:1.41
	src:1.41
	best-code:1.41
	named-reg:1.41
	x-named-regs:1.40
	x:1.40
	v13-00:1.40
	pre_GPL:1.38
	prec_CA:1.34
	noindx:1.30
	Bproc:1.29
	oct21:1.25
	last77:1.21;
locks; strict;
comment	@c @;


1.50
date	2018.10.03.14.51.08;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.24.13.27.10;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.23.15.10.07;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2009.05.29.12.49.34;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.04.13.13.10;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.24.22.52.03;	author cyang;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.27.15.20.33;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.27.14.52.36;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2007.02.26.18.47.08;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.12.15.31.10;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2005.10.17.20.19.53;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2005.10.17.18.12.40;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.03.18.32.34;	author cyang;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.10.16.48.21;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.30.16.40.09;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.30.19.58.00;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.16.14.32.10;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.14.17.25.44;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.09.16.32.17;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.09.15.30.15;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2000.12.19.19.17.21;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.08.19.49.52;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2000.05.04.15.14.14;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.26.15.45.01;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.24.19.55.29;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	99.09.13.18.35.43;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	99.06.23.18.21.35;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	99.06.18.17.51.35;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	99.06.17.19.11.28;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	99.03.15.16.07.54;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	98.08.04.18.29.00;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	98.07.23.18.10.23;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	98.04.07.14.53.26;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	98.04.07.14.35.17;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	98.04.03.21.18.23;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	98.04.03.20.59.28;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	98.01.27.17.09.52;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	97.10.15.19.37.19;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	97.10.15.18.18.08;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	97.02.24.14.29.01;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	97.02.24.14.08.53;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.14.10.55;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	96.09.19.16.17.43;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	96.09.18.15.45.17;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	96.09.17.19.29.59;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	96.09.10.18.08.43;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	96.09.10.15.48.17;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	95.10.25.13.24.29;	author mladjadj;	state Exp;
branches;
next	1.2;

1.2
date	94.07.19.12.02.00;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.51.58;	author leith;	state Exp;
branches;
next	;


desc
@copied from USER2:[PSIDER.CMSREF] on 11 May 1994
@


1.50
log
@email_health_dept
@
text
@

C++*********************************************************************
C
C UDOCIC.F      USED LUNDOC                         JUNE 99 ARDEAN LEITH
C               REMOVED ALLOCIT                     MAY  00 ARDEAN LEITH
C               LUNDOCREDALL PARAMETERS CHANGED     DEC  00 ARDEAN LEITH
C               ADDED 'SD IC' CAPABILITY            JUNE 03 ARDEAN LEITH
C               ADDED 'UD NEXT' CAPABILITY          FEB  07 ARDEAN LEITH
C               ADDED 'UD FIND' CAPABILITY          JUN  08 ARDEAN LEITH
C               NEXTKEY SET TO 1                    MAY  09 ARDEAN LEITH
C               ICOLWANT NLIST BUG                  NOV  09 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C   UDOCIC(NDOCT,ENDIT)
C
C   PURPOSE:  'UD IC' OPERATION DUPLICATES FUNCTION OF 'UD'
C             BUT IT USES IN-CORE STORAGE, WHICH MAKES SUBSEQUENT READ 
C             ACCESSES QUICK.  IT SOLICITS DOC FILE NAME.  THE
C             REGISTERS ARE SPECIFED ON THE COMMAND LINE
C   
C   PARAMETERS:  NDOCT     LUN FOR INPUT DOC FILE                (SENT)
C                ENDIT     FLAG FOR ENDING USE                   (SENT)
C
C   USAGE: 'UD IC 11,X11'       - FIRST ACCESS: READ DOC FILE INTO CORE
C          'UD IC 11,X11'       - SUBSEQUENT ACCESSES: READ FROM CORE
C          'UD ICE'             - TERMINATE CORE ACCESS OF CURRENT DOC
C          'UD NEXT [key],[r1]' - SUBSEQUENT ACCESSES: READ FROM CORE
C          'UD NEXT E'          - TERMINATE CORE ACCESS OF CURRENT DOC
C          'UD FIND [key],[r1]' - SUBSEQUENT ACCESSES: READ FROM CORE
C          'UD FIND E'          - TERMINATE CORE ACCESS OF CURRENT DOC
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

	SUBROUTINE UDOCIC(NDOCT,ENDIT)

        USE DOCIC_INFO

        INCLUDE 'CMBLOCK.INC' 

        CHARACTER(LEN=MAXNAM)       :: DOCNAM
        REAL, DIMENSION(:), POINTER :: IPQ

C       MAXIMUM NUMBER OF REGISTERS RETURNED ON OPERATION LINE
        INTEGER,PARAMETER :: MAXLIST=100
        REAL              :: PLIST(MAXLIST)

        LOGICAL           :: FIRST,ENDIT,UDNEXT,UDFIND
        CHARACTER(LEN=1)  :: NULL

        CALL SET_MPI(ICOMM,MYPID,IRTFLG) ! SETS ICOMM AND MYPID

        NULL   = CHAR(0)
        UDNEXT = (FCHAR(4:6) .EQ. 'NEX') .OR. (FCHAR(4:6) .EQ. 'NXT')
        UDFIND = (FCHAR(4:4) .EQ. 'F')  

        CALL FILERD(DOCNAM,NLET,NULL,
     &              'DOCUMENT FILE OR ARRAY NAME~',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
C       SEE IF THIS FILE IS ALREADY OPEN IN-CORE
        CALL ISDOCINCORE(DOCNAM,NIC,MT,IRTFLG)

	IF (ENDIT) THEN
C          WANT TO CEASE USING A DOC FILE -----------------------------
           IF (NIC .GT. 0) THEN
C              CHANGE OLDNAM SO IT CANNOT MATCH ANY FILE NAME.
	       OLDNAM(NIC)(1:1)  = NULL 
               NLETOLDNAM(NIC)   = 0

C              DEALLOCATE CORRESPONDING RUNTIME ARRAY
               IPQ => LOCDOC(NIC)%IPT
               DEALLOCATE(IPQ)
               NULLIFY(LOCDOC(NIC)%IPT)
           ELSE
              IF (MYPID .LE. 0) WRITE(NOUT,91) DOCNAM
91            FORMAT('  DOCUMENT FILE NOT IN-CORE: ',A)
           ENDIF

           IGOT = 0
           DO I = 1,MAXICDOCS 
              IF (OLDNAM(I)(1:1) .NE. NULL) THEN
                 IGOT = IGOT + 1
                 IF (IGOT .EQ. 1 .AND. MYPID .LE. 0) 
     &              WRITE(NOUT,*)' DOCUMENT FILES LEFT IN-CORE:'
                 ILEN =  NLETOLDNAM(I)
                 IF (MYPID .LE. 0) WRITE(NOUT,92) OLDNAM(I)(1:ILEN)
92               FORMAT(5X,A)
              ENDIF
           ENDDO
           IF (MYPID .LE. 0) THEN
              IF (IGOT .LE. 0)
     &           WRITE(NOUT,*)' NO DOCUMENT FILES LEFT IN-CORE'
              WRITE(NOUT,*) ' '
           ENDIF
           RETURN
	ENDIF      ! END OF: IF (ENDIT)	


C       WANT TO GET REGISTERS FROM A DOC FILE ------------------------
        FIRST = .FALSE.
        IF (NIC .EQ. 0 .AND. MT .LE. 0) THEN
C          ERROR -- NAME NOT FOUND, AND NO SPACE LEFT IN DOC NAME LIST
           IF (MYPID .LE. 0) WRITE(NOUT,93) 
93         FORMAT('  *** NO SPACE AVAILABLE IN DOC. NAME LIST, ',
     &            ' CLOSE ANOTHER INCORE FILE FIRST')
           CALL ERRT(100,'UDOCIC',IDUM)
           RETURN
        
        ELSEIF (NIC .EQ. 0 .AND. MT .GT. 0) THEN
C          NAME NOT FOUND, SO FILE IS NOT YET IN-CORE, SPACE AVAILABLE
           FIRST  = .TRUE.
           NIC    = MT

C          DELAY SETTING OLDNAM UNTIL EVERYTHING IS OK ON RETRIEVAL
           OLDNAM(NIC)(1:1) = NULL
           NLETOLDNAM(NIC)  = 0
        ENDIF

C       DOCUMENT NAME FOUND OR BUFFER SPACE AVAILABLE ----------------

C       REGISTER LINE ALREADY LOADED IN RDPR 
        IF (UDNEXT .OR. UDFIND) THEN
           CALL REG_GET_USED(NLIST)
           NLIST = NLIST - 1
           IKEY  = 1
        ELSE
C          PARSE REGISTER LINE TO GET IKEY & NLIST 
           IX = 6
           CALL REG_DOC_PARSE(FCHAR(IX:),COMOUT,IKEY,NLIST,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ENDIF

C       REGISTER LIST OK 
        IF (IKEY .LT. 0) THEN
C          DESIRE A COMMENTED KEY. 
           CALL ERRT(101,'USE <UD> TO RETRIEVE COMMENT KEYS',NE)
           RETURN

        ELSEIF (NLIST .GT. MAXLIST) THEN
           MAXLISTT = MAXLIST
           CALL ERRT(102,'MAX. NUMBER FOR IN-CORE REGISTERS',MAXLISTT)
           RETURN

        ELSEIF (FIRST) THEN
C          OPEN THE PHYSICAL DOC FILE USING EXTENSION DATEXC
           CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOCT,NDOC,.FALSE.,' ',
     &               .TRUE.,.FALSE.,.FALSE.,NEWFILE,IRTFLGT)
           IF (IRTFLGT .NE. 0) RETURN

C          FIND MAXY BY READING FROM THE ON-DISK DOC FILE
           CALL LUNDOCINFO(NDOC,MAXY,MAXREGS,KEYSINUSE,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

C          SET ARRAY DIMENSIONS, EACH ARRAY LINE INCLUDES A KEY REGISTER 
C          ALLOCATE THIS INCORE ARRAY (ONLY NEED MAXY ROWS)
           MEMWANT = (MAXREGS+1) * MAXY
           ALLOCATE(IPQ(MEMWANT),STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'IPQ',NE)
              GOTO 999
           ENDIF

C          KEEP ARRAY POINTER IN LOCDOC
           LOCDOC(NIC)%IPT => IPQ

C          RECOVER DOC FILE CONTENTS AND PUT THEM IN IPQ
           MAXCOLS = MAXREGS + 1
           CALL LUNDOCREDALL(NDOC,IPQ(1),MAXCOLS,MAXY,.TRUE.,
     &                       NGOT,IRTFLG)
           CLOSE(NDOCT)
           IF (IRTFLG .NE. 0) THEN
C              DEALLOCATE THE CORRESPONDING RUNTIME ARRAY
               DEALLOCATE(IPQ)
               NULLIFY(LOCDOC(NIC)%IPT)
               RETURN
           ENDIF

C          SAVE ARRAY SIZE SIZES
           OLDNAM(NIC)     = DOCNAM(1:NLET) 
           NLETOLDNAM(NIC) = NLET
           NUMCOLS(NIC)    = MAXCOLS
           NUMKEYS(NIC)    = MAXY

C          INITIALIZE RETRIEVAL KEY FOR LUNDOCGETNEXT USE
           NEXTKEY(NIC) = 1

        ELSE
C          GET ARRAY SIZE SAVED WHEN FILLED
           MAXCOLS = NUMCOLS(NIC)
           MAXY    = NUMKEYS(NIC)

C          RECOVER DOC FILE INFO FROM INCORE IMAGE 
           IPQ => LOCDOC(NIC)%IPT
        ENDIF

        IF (.NOT. UDFIND .AND. NLIST .GT. (MAXCOLS - 1)) THEN
           IF (MYPID .LE. 0) WRITE(NOUT,1447) NLIST,MAXCOLS-1
1447       FORMAT('  *** NUMBER OF REGISTERS REQUESTED: ',I2,
     &               ' NUMBER AVAILABLE IN-CORE: ',I2,/)
           CALL ERRT(100,'UDOCIC',NE)
           NLIST = MAXCOLS - 1
        ENDIF

        IF (UDFIND) THEN
C          GET INPUT FOR 'UD FIND' OPERATION
           IF (NLIST .GT. (MAXCOLS - 1)) THEN
           IF (MYPID .LE. 0) WRITE(NOUT,1446) NLIST,MAXCOLS-1
1446          FORMAT('  NUMBER OF REGISTERS REQUESTED: ',I2,
     &               ' SET TO NUMBER AVAILABLE IN-CORE: ',I2,/)
              NLIST = MAXCOLS - 1
           ENDIF

           COLWANT  = 1.0
           VALWANT  = 1.0
           CALL RDPRM2S(COLWANT,VALWANT,NOT_USED,
     &                  'REGISTER COLUMN & VALUE WANTED',IRTFLG)
           IF (IRTFLG .NE. 0) THEN
C             END OF FILE REACHED, SET REGISTER CONTENTS
              NLIST    = 1
              PLIST(1) = 0
              IRTFLG   = 0
              RETURN
           ENDIF

           ICOLWANT = COLWANT + 1.5  ! KEY IS IN COL: 1

           IF (ICOLWANT .GT. MAXCOLS) THEN
              IF (MYPID .LE. 0) WRITE(NOUT,1445) ICOLWANT -1
1445          FORMAT('  *** REGISTER COLUMN: ',I2, ' NOT AVAILABLE ',/)
              CALL ERRT(102,'REGISTER NOT AVAILABLE',ICOLWANT)
              NLIST    = 1
              PLIST(1) = 0
              IRTFLG   = 1
              RETURN
           ENDIF
           ! write(6,*) ' icolwant,valwant: ',icolwant,valwant

C          READ NEXT LINE OF DOC FILE UNTIL DESIRED LINE IS FOUND
           DO WHILE (.TRUE.)      ! ENDLESS LOOP

              CALL LUNDOCREDNXT(-NIC,IKEY,PLIST(2),MAXLIST-1,
     &                          IDUM,NLIST,IRTFLG)
C             write(6,*)'k,igo,1,2,3,:',ikey,igo,(plist(i),i=1,3),irtflg
  
              IF (IRTFLG .EQ. 2) THEN
C                END OF FILE REACHED, SET REGISTER CONTENTS
                 NLIST    = 1
                 PLIST(1) = 0
                 IRTFLG   = 0
                 NEXTKEY(-NIC) = 1
                 EXIT
              ELSEIF (PLIST(ICOLWANT) .EQ. VALWANT) THEN
C                DESIRED REGISTER LINE FOUND
                 NLIST    = NLIST + 1
                 PLIST(1) = IKEY
                 EXIT
              ENDIF
c             write(6,*) ' plist: ',(plist(i),i=1,3)
           ENDDO

C          SET RETRIEVAL KEY FOR LUNDOCGETNEXT USE
           NEXTKEY(NIC) = 1

        ELSEIF (UDNEXT) THEN
C          READ NEXT LINE OF DOC FILE
           CALL LUNDOCREDNXT(-NIC,IKEY,PLIST(2),MAXLIST-1,
     &                       IDUM,NLIST,IRTFLG)
c          write(6,*) ' ikey,igo,nlist,irtflg: ',ikey,igo,nlist,irtflg
 
           IF (IRTFLG .EQ. 2) THEN
C             END OF FILE REACHED, SET REGISTER CONTENTS
              NLIST         = 1
              PLIST(1)      = 0
              IRTFLG        = 0
              NEXTKEY(-NIC) = 1
           ELSE
              NLIST    = NLIST + 1
              PLIST(1) = IKEY
           ENDIF
c          write(6,*) ' plist: ',(plist(i),i=1,3)

        ELSE
C          READ IKEY CONTENTS FROM IPQ AND PLACE IN PLIST
           CALL LUNDOCGETKEY(NDOC,IPQ(1),MAXCOLS,MAXY,IKEY,PLIST,
     &                       NLIST,.TRUE.,IRTFLG)
        ENDIF
        IF (IRTFLG .NE. 0) RETURN

C       SET REGISTER CONTENTS FROM PLIST --------------------------
        CALL REG_SET_NSELA(NLIST,PLIST,.TRUE.,IRTFLG)

        NICLAST = NIC

        IF (.NOT. SILENT .AND. MYPID .LE. 0) WRITE(NOUT,*) ' '
	RETURN

999     CLOSE(NDOCT)
#ifdef USE_MPI
        CALL MPI_BARRIER(ICOMM, MPIERR)
#endif
        RETURN

	END

@


1.49
log
@GPL_2010
@
text
@d19 1
a19 1
C=* Email: spider@@wadsworth.org                                        *
@


1.48
log
@ICOLWANT NLIST BUG
@
text
@d14 4
a17 2
C=* This file is part of:                                              * C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
d28 1
a28 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a29 1
C=*                                                                    *
@


1.47
log
@NEXTKEY
@
text
@d11 2
a12 1
C               NEXTKEY SET TO 1                    MAY  01 ARDEAN LEITH
d14 4
a17 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d19 1
a19 6
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d24 1
a24 1
C=* This program is distributed in the hope that it will be useful,    *
d30 1
a30 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d247 2
a248 2
           IF (ICOLWANT .GT. NLIST) THEN
              IF (MYPID .LE. 0) WRITE(NOUT,1445) ICOLWANT
@


1.46
log
@UD FIND
@
text
@d11 1
d75 1
a75 9
#ifdef USE_MPI
        INCLUDE 'mpif.h'
        ICOMM  = MPI_COMM_WORLD
        MPIERR = 0
        CALL MPI_COMM_RANK(ICOMM, MYPID, IERR)
        CALL MPI_BARRIER(ICOMM, IERR)
#else
        MYPID = -1 
#endif
a206 1
           NEXTKEY(NIC)    = 0
d208 2
a209 2
C          SET RETRIEVAL KEY FOR LUNDOCGETNEXT USE
           IF (UDNEXT .OR. UDFIND) NEXTKEY(NIC) = 1
d266 1
a266 1
     &                          IGO,NLIST,IRTFLG)
d274 1
d291 1
a291 1
     &                       IGO,NLIST,IRTFLG)
d296 4
a299 3
              NLIST    = 1
              PLIST(1) = 0
              IRTFLG   = 0
@


1.45
log
@change all COMM to ICOMM
@
text
@d10 1
d13 1
a13 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d52 2
d71 1
a71 1
        LOGICAL           :: FIRST,ENDIT,UDNEXT
d86 1
d153 1
a153 1
        IF (UDNEXT) THEN
d215 3
a217 1
           IF (UDNEXT) NEXTKEY(NIC) = 1
d228 1
a228 1
        IF (NLIST .GT. (MAXCOLS - 1)) THEN
d236 61
a296 1
        IF (UDNEXT) THEN
@


1.44
log
@renamed UD SEL to UD NEXT
@
text
@d75 2
a76 1
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
d262 3
@


1.43
log
@added nextkey() for UD SEL
@
text
@d9 1
a9 1
C               ADDED 'UD SEL' CAPABILITY           FEB  07 ARDEAN LEITH
d46 5
a50 5
C   USAGE: 'UD IC 11,X11'      - FIRST ACCESS: READ DOC FILE INTO CORE
C          'UD IC 11,X11'      - SUBSEQUENT ACCESSES: READ FROM CORE
C          'UD ICE'            - TERMINATE CORE ACCESS OF CURRENT DOC
C          'UD SEL [key],[r1]' - SUBSEQUENT ACCESSES: READ FROM CORE
C          'UD SEL E'          - TERMINATE CORE ACCESS OF CURRENT DOC
d68 1
a68 1
        LOGICAL           :: FIRST,ENDIT,UDSEL
d80 2
a81 2
        NULL  = CHAR(0)
        UDSEL = (FCHAR(4:6) .EQ. 'SEL')
d138 1
a138 1
           NIC     = MT
d148 1
a148 1
        IF (UDSEL) THEN
d210 1
a210 1
           IF (UDSEL) NEXTKEY(NIC) = 1
d229 1
a229 1
        IF (UDSEL) THEN
@


1.42
log
@UD SEL support
@
text
@d46 5
a50 3
C   USAGE:    'UD IC,11,X11' - FIRST ACCESS: READ DOC. FILE INTO CORE
C             'UD IC,11,X11' - SUBSEQUENT ACCESSES: READ FROM CORE
C             'UD ICE'       - TERMINATE CORE ACCESS OF CURRENT DOCUMENT
d64 3
a66 3
C       MAXIMUM NUMBER OF REGISTERS RETURNED
        INTEGER,PARAMETER  :: MAXLIST=100
        COMMON         PLIST(MAXLIST)
d68 2
a69 2
        LOGICAL          :: FIRST,ENDIT,UDSEL
        CHARACTER(LEN=1) :: NULL
d73 1
a73 2
        INTEGER MYPID, COMM, MPIERR
        COMM   = MPI_COMM_WORLD
d75 1
a75 1
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
d129 1
a129 1
           WRITE(NOUT,93) 
d209 2
a210 1
           IF (UDSEL) IGO  = 1
a218 10

           IF (UDSEL) THEN
C             GET NEXT-KEY FROM CALLING REG
              CALL REG_GET_NSEL(1,FGO,XD,XD,XD,XD,IRTFLG)
              IGO = FGO
              IF (IGO .LT. 0) THEN
                 CALL ERRT(102,'NEXT KEY < 0',IKEY)
                 GOTO 999
              ENDIF
           ENDIF
d222 1
a222 1
           WRITE(NOUT,1447) NLIST,MAXCOLS-1
d241 1
a241 1
              PLIST(1) = IGO
@


1.41
log
@native named registers
@
text
@d9 1
d12 1
a12 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d66 1
a66 1
        LOGICAL          :: FIRST,ENDIT
d79 2
a80 1
        NULL = CHAR(0)
d121 1
a121 1
	ENDIF	
d147 10
a156 4
C       PARSE REGISTER LINE TO GET IKEY & NLIST 
        IX = 6
        CALL REG_DOC_PARSE(FCHAR(IX:),COMOUT,IKEY,NLIST,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
d208 1
d218 9
d237 21
a257 3
C       READ IKEY CONTENTS FROM IPQ AND PLACE IN PLIST
        CALL LUNDOCGETKEY(NDOC,IPQ(1),MAXCOLS,MAXY,IKEY,PLIST,
     &                    NLIST,.TRUE.,IRTFLG)
@


1.40
log
@GPL License fixed
@
text
@d63 1
a63 1
        COMMON         PLIST(MAXLIST),ILIST(MAXLIST)
d143 3
a145 1
C       PARSE REGISTER LINE, CHECK FOR ',' OR 'X'
d147 1
a147 2
        CALL LUNDOCPARSE(FCHAR(IX:),COMOUT,IKEY,ILIST,MAXLIST,
     &                   NLIST,IRTFLG)
d225 1
a225 3
        DO  K=1,NLIST
           CALL REG_SET(ILIST(K), PLIST(K) ,.TRUE.,IRTFLG)
        ENDDO
@


1.39
log
@HRI GPL License used
@
text
@a9 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d13 1
a13 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a32 6

C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.38
log
@removed MPI_BARRIER to reduce comm overhead
@
text
@d11 24
@


1.37
log
@ formatting of output msg
@
text
@a56 1
        CALL MPI_BARRIER(COMM, IERR)
a216 3
#ifdef USE_MPI
        CALL MPI_BARRIER(COMM, MPIERR)
#endif
@


1.36
log
@mpi
@
text
@d83 1
a83 1
91            FORMAT(' DOCUMENT FILE NOT IN-CORE: ',A)
d111 1
a111 1
93         FORMAT(' *** NO SPACE AVAILABLE IN DOC. NAME LIST, ',
d196 1
a196 1
1447       FORMAT(' *** NUMBER OF REGISTERS REQUESTED: ',I2,
@


1.35
log
@mpi
@
text
@d53 3
a55 2
        INTEGER MYPID, COMM, IERR
        COMM = MPI_COMM_WORLD
a66 3
#ifdef USE_MPI
        CALL MPI_BARRIER(COMM, IERR)
#endif
d82 1
a82 7
#ifdef USE_MPI
              IF (MYPID .EQ. 0) THEN
                 WRITE(NOUT,91) DOCNAM
              ENDIF
#else
              WRITE(NOUT,91) DOCNAM
#endif
d90 1
a90 5
#ifdef USE_MPI
                 IF (IGOT .EQ. 1 .AND. MYPID .EQ. 0) 
     &              WRITE(NOUT,*)' DOCUMENT FILES LEFT IN-CORE:'
#else
                 IF (IGOT .EQ. 1) 
a91 1
#endif
d93 1
a93 7
#ifdef USE_MPI
                 IF (MYPID .EQ. 0) THEN
                    WRITE(NOUT,92) OLDNAM(I)(1:ILEN)
                 ENDIF
#else
                 WRITE(NOUT,92) OLDNAM(I)(1:ILEN)
#endif
d97 2
a98 3
#ifdef USE_MPI
           IF (MYPID .EQ. 0) THEN
              IF (IGOT .LE. 0)  
d100 1
a100 1
                 WRITE(NOUT,*) ' '
a101 5
#else
           IF (IGOT .LE. 0)  
     &        WRITE(NOUT,*)' NO DOCUMENT FILES LEFT IN-CORE'
              WRITE(NOUT,*) ' '
#endif
d214 1
a214 8
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
           IF (.NOT. SILENT) WRITE(NOUT,*) ' '
        ENDIF
        CALL MPI_BARRIER(COMM, IERR)
#else
        IF (.NOT. SILENT) WRITE(NOUT,*) ' '
#endif
d219 1
a219 1
        CALL MPI_BARRIER(COMM, IERR)
@


1.34
log
@buggy for sdocic changes
@
text
@d51 10
d66 3
a68 1

d84 5
d90 1
d98 4
d104 1
d106 5
d112 1
d116 7
d124 3
a126 2
     &          WRITE(NOUT,*)' NO DOCUMENT FILES LEFT IN-CORE'
           WRITE(NOUT,*) ' '
a169 1

d239 6
d246 1
d250 3
@


1.33
log
@sd ic related changes
@
text
@d18 1
a18 1
C   UDOCIC(DOCNAM,NDOCT,ENDIT)
d25 2
a26 2
C   PARAMETERS:  DOCNAM    FILE NAME WITH EXTENSION              (SENT)
C                NDOCT     LUN FOR INPUT DOC FILE                (SENT)
d45 1
a45 1
        PARAMETER      (MAXLIST=100)
d53 2
a54 1
        CALL FILERD(DOCNAM,NLET,NULL,'FILE OR ARRAY NAME~',IRTFLG)
d65 1
d67 1
a67 1
C              DEALLOCATE THE CORRESPONDING RUNTIME ARRAY
d82 1
a82 1
                 ILEN = LNBLNK(OLDNAM(I))
d95 1
a95 1

d111 1
d116 1
a116 7

        IX = INDEX(FCHAR,',')
        IF (IX .LE. 0) THEN
           CALL ERRT(101,'NO REGISTERS ON COMMAND LINE',NE)
           RETURN
        ENDIF

d168 4
a171 3
           OLDNAM(NIC)  = DOCNAM
           NUMCOLS(NIC) = MAXCOLS
           NUMKEYS(NIC) = MAXY
@


1.32
log
@isdocincore parameters changed
@
text
@d18 1
a18 1
C   UDOCIC(DOCNAM,NDOC,ENDIT)
d26 1
a26 1
C                NDOC      LUN FOR DOC FILE                      (SENT)
d35 1
a36 2
	SUBROUTINE UDOCIC(DOCNAM,NDOC,ENDIT)

d41 1
a41 1
        CHARACTER(LEN=*)            :: DOCNAM
d53 3
a60 3

C          DETERMINE WHICH OF THE OLD NAMES NEEDS TO BE OBLITERATED

a69 1

d76 1
a76 1
              IF (OLDNAM(I) .NE. NULL) THEN
d94 1
a94 1
        IF (MT .EQ. 0) THEN
d97 1
a97 1
93         FORMAT(' *** NO SPACE AVAILABLE, ',
d102 1
a102 1
        ELSEIF (MT .GT. 0) THEN
d106 1
d108 1
a108 1
           OLDNAM(NIC) = NULL
d112 1
a112 1
C       PROCEED TO PARSE REGISTER LINE, CHECK FOR ',' OR 'X'
a135 2
C          SET ARRAY DIMENSIONS, EACH ARRAY LINE INCLUDES A KEY REGISTER 
           MAXX = NLIST + 1
d137 2
a138 2
C          OPEN THE PHYSICAL DOC FILE USING EXTENSION FROM DOCNAM
           CALL OPENDOC(DOCNAM,.FALSE.,NLET,NDOC,.FALSE.,' ',
d142 2
a143 2
C          FIND MAXY BY READING FROM DISK DOC FILE
           CALL LUNDOCINFO(NDOC,MAXY,MAXXDUM,KEYUSED,.TRUE.,IRTFLG)
d146 1
d148 1
a148 1
           MEMWANT = MAXX * MAXY
d152 1
a152 2
              CLOSE(NDOC)
              RETURN
d159 15
a173 3
           CALL LUNDOCREDALL(NDOC,IPQ(1),MAXX,MAXY,.TRUE.,NGOT,IRTFLG)
           CLOSE(NDOC)
           IF (IRTFLG .NE. 0) RETURN
d177 2
a178 9
           MAXX = NUMREGS(NIC)
           MAXY = NUMKEYS(NIC)
  	   IF (NLIST .GT. (MAXX - 1)) THEN
              WRITE(NOUT,1447) NLIST -1
1447          FORMAT(' *** NUMBER OF REGISTERS REQUESTED: ',I2,
     &               ' NUMBER AVAILABLE IN-CORE: ',I2,/)
              NLIST = MAXX - 1
              CALL ERRT(100,'UDOCIC',NE)
           ENDIF
d185 8
d194 2
a195 2
        CALL LUNDOCGETKEY(NDOC,IPQ(1),MAXX,MAXY,IKEY,PLIST,
     &                    .TRUE.,IRTFLG)
a202 6
        IF (FIRST) THEN
C          DELAY SETTING NAME UNTIL EVERYTHING IS OK ON RETRIEVAL
           OLDNAM(NIC)  = DOCNAM
           NUMKEYS(NIC) = MAXY
           NUMREGS(NIC) = NLIST + 1
        ENDIF           
d207 4
@


1.31
log
@new capabilites
@
text
@d50 1
d52 1
a52 2
C       NEEDED FOR FUTURE CALLS
        SAVE           NICLAST
a53 1

d55 1
a55 1
        CALL ISDOCINCORE(DOCNAM,NICLAST,NIC,MT,IRTFLG)
d64 1
a64 1
	       OLDNAM(NIC)  = '*' 
d78 1
a78 1
              IF (OLDNAM(I) .NE. '*') THEN
d109 1
a109 1
           OLDNAM(NIC) = '*'
@


1.30
log
@lundocredall & opendoc parameters changed
@
text
@d2 2
a3 5
C++************************************************************************
C
C RDDOCA2Q.F    USED LUNDOC     JUNE 99 ArDean Leith
C               REMOVED ALLOCIT MAY  00 ArDean Leith
C               LUNDOCREDALL PARAMETERS CHANGED    DEC   00 ARDEAN LEITH
d5 12
a16 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d18 1
a18 1
C   RDDOCA2Q(DOCNAM,NDOC)
d20 1
a20 1
C   PURPOSE:  ROUTINE DUPLICATES FUNCTION OF RDDOCQ. 
d22 1
a22 1
C             ACCESSES VERY QUICK.  IT SOLICITS DOC FILE NAME.  THE
d28 3
a30 5
C   USAGE:    'UD IC,11,X11'  --  FIRST ACCESS: READ CONTENTS OF ENTIRE 
C                                 DOCUMENT FILE INTO CORE
C             'UD IC,11,X11'' --  SUBSEQUENT ACCESSES: READ DIRECTLY 
C                                 FROM CORE
C             'UD ICE' -- TERMINATE CORE ACCESS OF CURRENT DOCUMENT
d32 2
a33 1
C--*******************************************************************
a34 1
	SUBROUTINE RDDOCA2Q(DOCNAM,NDOC)
d36 1
a36 6
C       ARRAY OF POINTERS TO DOCUMENT STORAGES
        INTEGER, PARAMETER :: MAXICDOCS = 10
        TYPE REAL_POINTER
           REAL, DIMENSION(:), POINTER :: IPT 
        END TYPE REAL_POINTER
        TYPE(REAL_POINTER), DIMENSION(MAXICDOCS) :: LOCDOC
d38 1
a38 1
	INCLUDE 'CMBLOCK.INC' 
d40 3
a43 2
   
        CHARACTER *(*) DOCNAM
d49 1
a49 2
        INTEGER        NUMREGS(MAXICDOCS),NUMKEYS(MAXICDOCS)
	CHARACTER *81  OLDNAM(MAXICDOCS)
d51 2
a52 2
        CHARACTER      NULL
        LOGICAL        FIRST,ISDIGI,FOUNDIT,COMOUT
a53 2
C       NEEDED FOR FUTURE CALLS
        SAVE           IPQ, NUMREGS, NUMKEYS, OLDNAM, LOCDOC, ICLAST
d55 2
a56 1
	DATA           OLDNAM/MAXICDOCS*'*'/
d58 1
a58 1
	IF (FCHAR(6:6) .EQ. 'E') THEN
d60 1
d62 4
a65 6
           FOUNDIT = .FALSE.
           DO  ICORE=1,MAXICDOCS
	     IF  (DOCNAM .EQ. OLDNAM(ICORE)) THEN
C              CHANGE OLDNAM SO THAT IT CANNOT BE MATCHED WITH ANY FILE NAME.
	       OLDNAM(ICORE)  = '*' 
               FOUNDIT        = .TRUE.
d68 1
a68 1
               IPQ => LOCDOC(ICORE)%IPT
d70 2
a71 1
               NULLIFY(LOCDOC(ICORE)%IPT)
a72 5
               GOTO 10
             ENDIF
           ENDDO

           IF (.NOT. FOUNDIT) THEN
d77 1
a77 1
10         IGOT = 0
d82 1
a82 1
     &              WRITE(NOUT,*)'DOCUMENT FILES LEFT IN-CORE:'
d97 6
a102 33
C       COMPARE WITH OLD NAMES
	IC     = 0
        FIRST  = .FALSE.

C       NAME IS MOST-LIKELY STILL THE SAME
        IF (ICLAST .GT. 0 .AND. ICLAST .LE. MAXICDOCS .AND.
     &      DOCNAM .EQ. OLDNAM(ICLAST)) THEN
C          DOCNAM IS ALREADY IN-CORE
           IC    = ICLAST
           GOTO 1300
        ENDIF

C       WANT TO FILL IC = 1 FIRST NOW al
	DO ICORE = MAXICDOCS,1,-1
           IF (DOCNAM .EQ. OLDNAM(ICORE)) THEN
C             DOCNAM IS ALREADY IN-CORE
              IC    = ICORE
              GOTO 1300
           ENDIF

C          REMEMBER WHICH LOCATIONS ARE EMPTY
           IF (OLDNAM(ICORE)  .EQ. '*') IC = ICORE
        ENDDO

C       DOCUMENT NAME NOT FOUND. IF A BUFFER SECTION IS FREE, THE 
C       DOCUMENT FILE CAN BE READ INTO CORE, TO BE AVAILABLE FOR
C       SUBSEQUENT ACCESSES. IF NONE IS FREE, GIVE ERROR MESSAGE.

        IF (IC .EQ. 0) THEN
C          ERROR -- NAME NOT FOUND, AND NO SPACE AVAILABLE
           WRITE(NOUT,90) DOCNAM
90         FORMAT(' *** NO IN-CORE SPACE AVAILABLE FOR: ',A,/)
           CALL ERRT(100,'RDDOCA2Q',IDUM)
d104 5
a108 4

        ELSE
C          NAME NOT FOUND, SPACE AVAILABLE
           FIRST      = .TRUE.
d110 2
a111 2
           OLDNAM(IC) = '*'
         ENDIF
d116 7
a122 1
1300    CALL LUNDOCPARSE(FCHAR(7:),COMOUT,IKEY,ILIST,MAXLIST,
d128 2
a129 17
C          DESIRE A COMMENTED KEY. OPEN FILE FIRST
           CALL OPENDOC(DOCNAM,.FALSE.,NLET,NDOC,.FALSE.,' ',
     &               .TRUE.,.FALSE.,.FALSE.,NEWFILE,IRTFLGT)
           IF (IRTFLGT .NE. 0) RETURN

C          RECOVER COMMENTED KEY INFO
           CALL LUNDOCGETCOM(NDOC,IKEY,PLIST,NLIST,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           CLOSE(NDOC)

C          SET REGISTER CONTENTS FROM PLIST
           DO  K=1,NLIST
C             PARAM(ILIST(K)) = PLIST(K)
              CALL REG_SET(ILIST(K),  PLIST(K) ,.TRUE.,IRTFLG)
           ENDDO
           IRTFLG = 0
d134 1
a134 2
           WRITE(NOUT,*) '*** REGISTER LIST LIMIT: ',MAXLISTT
           CALL ERRT(100,'RDDOCA2Q',NE)
a136 15
        ELSEIF ( .NOT. FIRST) THEN
C          GET ARRAY SIZE SAVED WHEN FILLED
           MAXX = NUMREGS(IC)
           MAXY = NUMKEYS(IC)
  	   IF (NLIST .GT. (MAXX - 1)) THEN
              WRITE(NOUT,1447) NLIST -1
1447          FORMAT(' *** NUMBER OF REGISTERS REQUESTED: ',I2,
     &               ' NUMBER AVAILABLE IN-CORE: ',I2,/)
              NLIST = MAXX - 1
              CALL ERRT(100,'RDDOCA2Q',NE)
           ENDIF

C          RECOVER DOC FILE INFO FROM INCORE IMAGE 
           IPQ => LOCDOC(IC)%IPT

d138 1
a138 1
C          SET ARRAY DIMENSIONS 
d141 1
a141 1
C          OPEN THE DOC FILE USING EXTENSION FROM DOCNAM
d146 1
a146 1
C          FIND MAXY BY READING FROM DOC FILE
d150 1
a150 1
C          ALLOCATE THE RUNTIME ARRAY (ONLY NEED MAXY ROWS NOW)
d154 1
a154 1
              CALL ERRT(100,'RDDOCA2Q',NE)
d159 2
a160 2
C          KEEP ARRAY POINTER IN LUNDOC
           LOCDOC(IC)%IPT => IPQ
d162 1
a162 1
C          RECOVER DOC FILE CONTENTS AND KEEP IN Q
d167 15
d184 1
a184 1
C       READ IKEY CONTENTS FROM IPQ AND KEEP IN PLIST
d190 1
a190 2
333     DO  K=1,NLIST
C          PARAM(ILIST(K)) = PLIST(K)
d196 3
a198 3
           OLDNAM(IC)  = DOCNAM
           NUMKEYS(IC) = MAXY
           NUMREGS(IC) = NLIST + 1
d200 1
a200 1
        ICLAST = IC
@


1.29
log
@used reg_set
@
text
@d4 3
a6 2
C RDDOCA2Q.F                    USED LUNDOC     JUNE 99 ArDean Leith
C                               REMOVED ALLOCIT MAY  00 ArDean Leith
d162 1
a162 1
           CALL OPENDOC(DOCNAM,.FALSE.,NLET,NDOC,.FALSE.,
d206 1
a206 1
           CALL OPENDOC(DOCNAM,.FALSE.,NLET,NDOC,.FALSE.,
d227 1
a227 1
           CALL LUNDOCREDALL(NDOC,IPQ(1),MAXX,MAXY,.TRUE.,IRTFLG)
@


1.28
log
@removed allocit
@
text
@d173 2
a174 1
              PARAM(ILIST(K)) = PLIST(K)
d239 2
a240 1
           PARAM(ILIST(K)) = PLIST(K)
@


1.27
log
@added (1) after ipq for Decu Unix
@
text
@d4 2
a5 1
C RDDOCA2Q.F                           USED LUNDOC JUNE 99 ArDean Leith
a43 1
        INCLUDE 'F90ALLOC.INC'
d58 1
a58 1
        LOGICAL        FIRST,ISDIGI,FOUNDIT,RUNTIME,COMOUT
d76 2
a77 3
               IPQ     => LOCDOC(ICORE)%IPT
               RUNTIME = .TRUE.
               CALL ALLOCIT(0,RUNTIME,IPQ,'RDDOCA2Q',IRTFLG)
d214 1
a214 1
           CALL ALLOCIT(MEMWANT,RUNTIME,IPQ,'RDDOCA2Q',IRTFLG)
d221 2
a222 2
C          KEEP POINTER IN LUNDOC
           LOCDOC(IC)%IPT  => IPQ
d224 1
a224 1
C          RECOVER DOC FILE CONTENTS AND KEEP IN IPQ
@


1.26
log
@SP_F90 removed
@
text
@d226 1
a226 1
           CALL LUNDOCREDALL(NDOC,IPQ,MAXX,MAXY,.TRUE.,IRTFLG)
d233 2
a234 1
        CALL LUNDOCGETKEY(NDOC,IPQ,MAXX,MAXY,IKEY,PLIST,.TRUE.,IRTFLG)
@


1.25
log
@unused DINDEX variable removed
@
text
@a33 3
#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------

a252 223
C     ----------- F90 SPECIFIC CODE ENDS ---------------------
#else

C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------


	SUBROUTINE RDDOCA2Q(DOCNAM,NDOC)

	INCLUDE 'CMBLOCK.INC' 

    
#if defined(SP_SUN4) || defined(SP_NT)
C       MAXIMUM NUMBER OF OPENED CONCURRENT INCORE DOCUMENT FILES 
        PARAMETER      (MAXICDOCST=10)
        INTEGER        LOCDOC(MAXICDOCST)
#else
C       MAXIMUM NUMBER OF OPENED CONCURRENT INCORE DOCUMENT FILES 
        PARAMETER      (MAXICDOCST=10)
        INTEGER * 8    LOCDOC(MAXICDOCST)
#endif
        POINTER (IPQ,QBUF)
        DIMENSION QBUF(1)

C       MAXIMUM NUMBER OF REGISTERS RETURNED
        PARAMETER (MAXLIST=20)

        CHARACTER *(*) DOCNAM
	REAL           PLIST(MAXLIST)
	INTEGER        ILIST(MAXLIST)
        INTEGER        NUMREGS(MAXICDOCST),NUMKEYS(MAXICDOCST)
	CHARACTER *81  OLDNAM(MAXICDOCST)
        CHARACTER      NULL
        LOGICAL        FIRST,ISDIGI,FOUNDIT,RUNTIME,COMOUT

C       NEEDED FOR FUTURE CALLS
        SAVE           IPQ, NUMREGS, NUMKEYS, OLDNAM, LOCDOC, ICLAST

	DATA           OLDNAM/MAXICDOCST*'*'/

	IF (FCHAR(6:6) .EQ. 'E') THEN
C          WANT TO CEASE USING A DOC FILE -----------------------------
C          DETERMINE WHICH OF THE OLD NAMES NEEDS TO BE OBLITERATED
           FOUNDIT = .FALSE.
           DO  ICORE=1,MAXICDOCST
	     IF  (DOCNAM .EQ. OLDNAM(ICORE)) THEN
C              CHANGE OLDNAM SO THAT IT CANNOT BE MATCHED WITH ANY FILE NAME.
	       OLDNAM(ICORE)  = '*' 
               FOUNDIT        = .TRUE.

C              DEALLOCATE THE CORRESPONDING RUNTIME ARRAY
               IPQ     = LOCDOC(ICORE)
               RUNTIME = .TRUE.
               CALL ALLOCIT(0,RUNTIME,IPQ,'RDDOCA2Q',IRTFLG)
               LOCDOC(ICORE) = 0

               GOTO 10
             ENDIF
           ENDDO

           IF (.NOT. FOUNDIT) THEN
              WRITE(NOUT,91) DOCNAM
91            FORMAT(' DOCUMENT FILE NOT IN-CORE: ',A)
           ENDIF

10         IGOT = 0
           DO I = 1,MAXICDOCST 
              IF (OLDNAM(I) .NE. '*') THEN
                 IGOT = IGOT + 1
                 IF (IGOT .EQ. 1) 
     &              WRITE(NOUT,*)'DOCUMENT FILES LEFT IN-CORE:'
                 ILEN = LNBLNK(OLDNAM(I))
                 WRITE(NOUT,92) OLDNAM(I)(1:ILEN)
92               FORMAT(5X,A)
              ENDIF
           ENDDO
           IF (IGOT .LE. 0)  
     &          WRITE(NOUT,*)'NO DOCUMENT FILES LEFT IN-CORE'
           WRITE(NOUT,*) ' '
           RETURN
	ENDIF	


C       WANT TO GET REGISTERS FROM A DOC FILE ------------------------

C       COMPARE WITH OLD NAMES
	IC     = 0
        FIRST  = .FALSE.

C       NAME IS MOST-LIKELY STILL THE SAME
        IF (ICLAST .GT. 0 .AND. ICLAST .LE. MAXICDOCST .AND.
     &      DOCNAM .EQ. OLDNAM(ICLAST)) THEN
C          DOCNAM IS ALREADY IN-CORE
           IC    = ICLAST
           GOTO 1300
        ENDIF

C       WANT TO FILL IC = 1 FIRST NOW al
	DO ICORE = MAXICDOCST,1,-1
           IF (DOCNAM .EQ. OLDNAM(ICORE)) THEN
C             DOCNAM IS ALREADY IN-CORE
              IC    = ICORE
              GOTO 1300
           ENDIF

C          REMEMBER WHICH LOCATIONS ARE EMPTY
           IF (OLDNAM(ICORE)  .EQ. '*') IC = ICORE
        ENDDO

C       DOCUMENT NAME NOT FOUND. IF A BUFFER SECTION IS FREE, THE 
C       DOCUMENT FILE CAN BE READ INTO CORE, TO BE AVAILABLE FOR
C       SUBSEQUENT ACCESSES. IF NONE IS FREE, GIVE ERROR MESSAGE.

        IF (IC .EQ. 0) THEN
C          ERROR -- NAME NOT FOUND, AND NO SPACE AVAILABLE
           WRITE(NOUT,90) DOCNAM
90         FORMAT(' *** NO IN-CORE SPACE AVAILABLE FOR: ',A,/)
           CALL ERRT(100,'RDDOCA2Q',IE)
           RETURN
        ELSE
C          NAME NOT FOUND, SPACE AVAILABLE
           FIRST      = .TRUE.
C          DELAY SETTING OLDNAM UNTIL EVERYTING IS OK ON RETRIEVAL
           OLDNAM(IC) = '*'
         ENDIF

C       PROCEED TO PARSE REGISTER LINE, CHECK FOR ',' OR 'X'
1300    CALL LUNDOCPARSE(FCHAR,COMOUT,IKEY,ILIST,MAXLIST,ICOUNT,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        IF (IKEY .LT. 0) THEN
C          DESIRE A COMMENTED KEY

           CALL OPENDOC(DOCNAM,.FALSE.,NLET,NDOC,.FALSE.,
     &               .TRUE.,.FALSE.,.FALSE.,NEWFILE,IRTFLGT)
           IF (IRTFLGT .NE. 0) RETURN

C          RECOVER COMMENTED INFO
           CALL LUNDOCGETCOM(NDOC,IKEY,PLIST,NLIST,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           CLOSE(NDOC)

C          SET REGISTER CONTENTS FROM PLIST
           DO  K=1,NLIST
              PARAM(ILIST(K)) = PLIST(K)
           ENDDO
           IRTFLG = 0
           RETURN

        ELSEIF (NLIST .GT. MAXLIST) THEN
           MAXLISTT = MAXLIST
           WRITE(NOUT,*) 'REGISTER LIST LIMIT: ',MAXLISTT
           CALL ERRT(100,'RDDOCA2Q',NE)
           RETURN

        ELSE
C          GET ARRAY SIZE SAVED WHEN FILLED
           MAXX = NUMREGS(IC)
           MAXY = NUMKEYS(IC)
  	   IF (NLIST .GT. (MAXX - 1)) THEN
              WRITE(NOUT,1447) NLIST -1
1447          FORMAT(' *** NUMBER OF REGISTERS REQUESTED: ',I2,
     &               ' NUMBER AVAILABLE IN-CORE: ',I2,/)
              NLIST = MAXX - 1
              CALL ERRT(100,'RDDOCA2Q',NE)
           ENDIF

        ELSEIF (FIRST) THEN
C          SET ARRAY DIMENSIONS 
           MAXX        = NLIST + 1

C          FIND MAXY BY READING DOC FILE TO GET MAX KEY NUMBER
C          OPEN THE DOC FILE USING EXTENSION FROM DOCNAM
           CALL OPENDOC(DOCNAM,.FALSE.,NLET,NDOC,.FALSE.,
     &               .TRUE.,.FALSE.,.FALSE.,NEWFILE,IRTFLGT)
           IF (IRTFLGT .NE. 0) RETURN

C          FIND MAXY 
           CALL LUNDOCINFO(NDOC,MAXY,MAXDDM,KEYUSED,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

C          ALLOCATE THE RUNTIME ARRAY (ONLY NEED MAXY ROWS NOW)
           MEMWANT = MAXX * MAXY
           CALL ALLOCIT(MEMWANT,RUNTIME,IPQ,'RDDOCA2Q',IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(100,'RDDOCA2Q',NE)
              RETURN
           ENDIF

C          KEEP POINTER IN LOCDOC
           LOCDOC(IC)  = IPQ

C          RECOVER DOC FILE CONTENTS AND KEEP IN QBUF
           CALL LUNDOCREDALL(NDOC,QBUF,MAXX,MAXY,.TRUE.,IRTFLG)
           CLOSE(NDOC)
           IF (IRTFLG .NE. 0) RETURN
        ELSE
C          RECOVER DOC FILE INFO FROM INCORE QBUF 
           IPQ = LOCDOC(IC)
        ENDIF

C       READ IKEY'S VALUES FROM QBUF
        CALL LUNDOCGETKEY(NDOC,QBUF,MAXX,MAXY,IKEY,PLIST,.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       SET REGISTER CONTENTS FROM PLIST --------------------------
333     DO K=1,NLIST
           PARAM(ILIST(K)) = PLIST(K)
        ENDDO

        IF (FIRST) THEN
C          DELAY SETTING NAME UNTIL EVERYTHING IS OK ON RETRIEVAL
           OLDNAM(IC)  = DOCNAM
           NUMKEYS(IC) = MAXY
           NUMREGS(IC) = NLIST + 1
        ENDIF           
        ICLAST = IC

        IF (.NOT. SILENT) WRITE(NOUT,*) ' '
	RETURN
	END

#endif
@


1.24
log
@keyused parameter added to lundocinfo call
@
text
@d60 1
a60 1
        CHARACTER      NULL,DINDEX
d287 1
a287 1
        CHARACTER      NULL,DINDEX
@


1.23
log
@lundoc changes
@
text
@d213 1
a213 1
           CALL LUNDOCINFO(NDOC,MAXY,MAXXDUM,.TRUE.,IRTFLG)
d434 1
a434 1
           CALL LUNDOCINFO(NDOC,MAXY,MAXDDM,.TRUE.,IRTFLG)
@


1.22
log
@used lundoc
@
text
@a31 2
C   CALLS:    UNSDAL
C
a48 6
C       MAXIMUM NUMBER OF COLUMNS PER KEY 
        PARAMETER (MAXCOL=7)
    
C       MAXIMUM NUMBER OF KEYS IN DOC FILE
        PARAMETER (MAXKEY=9999)

d110 1
a120 1
           ICALL = 1
a128 1
              ICALL = 1
d145 1
a145 1
           CALL ERRT(100,'RDDOCA2Q',IE)
d147 1
d151 1
a151 2
           ICALL      = 0
C          DELAY SETTING OLDNAM UNTIL EVERYTING IS OK ON RETRIEVAL
d164 10
a173 7
C          DESIRE A COMMENTED KEY, RECOVER DOC FILE INFO
           CALL UNSDAL(DOCNAM,ICALL,NDOC,IKEY,PLIST,NLIST,QBUF,
     &              MAXY,MAXX,NKEY,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(100,'RDDOCA2Q',NE)
              RETURN
           ENDIF
d175 6
a180 3
C          DO NOT HAVE INCORE LISTING OF FILE IF FIRST
           FIRST = .FALSE.
           GOTO 333
d187 2
a188 7
        ELSEIF (FIRST) THEN
C          SET ARRAY DIMENSIONS 
           MAXX        = NLIST + 1
           NUMREGS(IC) = NLIST + 1
           MAXY        = MAXCOL * MAXKEY / MAXX
           NUMKEYS(IC) = MAXY
        ELSE
d199 3
a201 1
        ENDIF              
d203 3
a205 2
        IF (FIRST) THEN
C          FIND MAXY BY READING DOC FILE TO GET MAX KEY NUMBER
d212 2
a213 2
           CALL LUNDOCINFO(NDOC,MAXY,MAXCOLS,.TRUE.,IRTFLG)
           CLOSE(NDOC)
d221 1
a226 1
           NUMKEYS(IC) = MAXY
d228 4
a231 2
C          DO NOT PRINT OPEN MESSAGE
           IRTFLG = -9
a232 3
        ELSE
C          RECOVER DOC FILE INFO FROM INCORE IMAGE 
           IPQ => LOCDOC(IC)%IPT
d235 3
a237 7
C       RECOVER DOC FILE INFO
        CALL UNSDAL(DOCNAM,ICALL,NDOC,IKEY,PLIST,NLIST,IPQ,
     &              MAXY,MAXX,NKEY,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(100,'RDDOCA2Q',NE)
           RETURN
        ENDIF
d241 1
a241 11
          IP = ILIST(K)
          IF (IP .GT. 103) THEN
C            CAN ONLY HAVE 103 PARAMETER POSITIONS
             WRITE(NOUT,*) '*** PARAM ARRAY LIMIT < 104, GOT: ',IP
          ELSEIF (IP .GT. 0) THEN
C            PLACE RECOVERED REGISTERS IN PARAM ARRAY
             PARAM(IP) = PLIST(K)

C             WRITE(6,987) IP-1,PARAM(IP)
C987          FORMAT(' REGISTER (',I3,'): ',G11.3)
          ENDIF
d246 3
a248 1
           OLDNAM(IC) = DOCNAM
a265 2
C       MAXIMUM NUMBER OF COLUMNS PER KEY 
        PARAMETER (MAXCOL=7)
a266 4
C       MAXIMUM NUMBER OF KEYS IN DOC FILE
        PARAMETER (MAXKEY=9999)

    
a337 1

a347 1
           ICALL = 1
a355 1
              ICALL = 1
a376 1
           ICALL      = 0
d381 1
d388 3
a390 7
C          RECOVER DOC FILE INFO
           CALL UNSDAL(DOCNAM,ICALL,NDOC,IKEY,PLIST,NLIST,QBUF,
     &                 MAXY,MAXX,NKEY,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(100,'RDDOCA2Q',NE)
              RETURN
           ENDIF
d392 2
a393 2
C          DO NOT HAVE INCORE LISTING OF FILE IF FIRST
           FIRST = .FALSE.
d395 2
a396 1
           GOTO 333
d398 7
d410 1
a410 6
        ELSEIF (FIRST) THEN
C          SET ARRAY DIMENSIONS 
           MAXX        = NLIST + 1
           NUMREGS(IC) = NLIST + 1
           MAXY        = MAXCOL * MAXKEY / MAXX
           NUMKEYS(IC) = MAXY
a421 1
        ENDIF              
d423 3
a426 1
        IF (FIRST) THEN
d433 2
a434 2
           CALL LUNDOCINFO(NDOC,MAXY,MAXCOLS,.TRUE.,IRTFLG)
           CLOSE(NDOC)
a446 1
           NUMKEYS(IC) = MAXY
d448 4
a451 3
C          DO NOT PRINT OPEN MESSAGE
           IRTFLG = -9

d453 1
a453 1
C          RECOVER DOC FILE INFO FROM INCORE IMAGE 
d457 3
a459 7
C       RECOVER DOC FILE INFO
        CALL UNSDAL(DOCNAM,ICALL,NDOC,IKEY,PLIST,NLIST,QBUF,
     &              MAXY,MAXX,NKEY,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(100,'RDDOCA2Q',NE)
           RETURN
        ENDIF
d462 2
a463 12
333     DO  K=1,NLIST
          IP = ILIST(K)
          IF (IP .GT. 103) THEN
C            CAN ONLY HAVE 103 PARAMETER POSITIONS
             WRITE(NOUT,*) '*** PARAM ARRAY LIMIT < 104, GOT: ',IP
          ELSEIF (IP .GT. 0) THEN
C            PLACE RECOVERED REGISTERS IN PARAM ARRAY
             PARAM(IP) = PLIST(K)

C             WRITE(6,987) IP-1,PARAM(IP)
C987          FORMAT(' REGISTER (',I3,'): ',G11.3)
          ENDIF
d468 3
a470 1
           OLDNAM(IC) = DOCNAM
@


1.21
log
@revoded SP_ALLOC
@
text
@d4 1
a4 1
C RDDOCA2Q.F
d18 1
a18 1
C   PURPOSE:  THIS ROUTINE DUPLICATES FUNCTION OF RDDOC (UNSAVE DOCUMENT)
d23 2
a24 2
C   PARAMETERS:     DOCNAM    FILE NAME                   (SENT)
C                   NDOC      LUN FOR DOC FILE            (SENT)
d26 4
a29 3
C   USAGE:    'UD IC' --  FIRST ACCESS: READ CONTENTS OF ENTIRE DOCUMENT 
C                         INTO CORE
C             'UD IC' --  SUBSEQUENT ACCESSES: READ DIRECTLY FROM CORE
a40 2
CNO_SAVE

d59 2
d62 2
a63 1
        PARAMETER (MAXLIST=20)
a64 3
        CHARACTER *(*) DOCNAM
	REAL           PLIST(MAXLIST)
	INTEGER        ILIST(MAXLIST)
d67 1
d69 1
a69 1
        LOGICAL        FIRST,ISDIGI,FOUNDIT,RUNTIME
d113 1
a113 1
     &          WRITE(NOUT,*)'NO DOCUMENT FILES LEFT IN-CORE'
a117 2


d167 3
a169 7
1300	K1=7
        DO K = K1,NALPH
           KNOW = K
           IF (FCHAR(K:K) .EQ. ',' .OR. FCHAR(K:K) .EQ. 'X') GOTO 1414
        ENDDO
	CALL ERRT(26,'RDDOCA2Q',IE)
	RETURN
d171 8
a178 22
1414	IF (FCHAR(KNOW:KNOW) .EQ. ',') THEN

           KNOW = KNOW - 1

C          CHECK IF FIRST ENTRY IS A NUMBER OR AN INDEX OF A DO-LOOP

	   IF (ISDIGI(FCHAR(KNOW:KNOW))) THEN
c              ASSUME FIRST ENTRY IS A NUMBER
               CALL CHKNUMQ(FCHAR(K1:),KNOW-K1+1,'I',IKEY,FNUM,IER)
               IF (IER .NE. 0) THEN
                  CALL ERRT(26,'RDDOCA',IE)
                  RETURN
               ENDIF

           ELSE          
C              FIRST ENTRY IS A DO-LOOP INDEX. PUT ITS VALUE INTO ILIST.

               DINDEX = FCHAR(KNOW:KNOW)
               IDX    = ICHAR(DINDEX) -64
               IKEY   = IALPHA(IDX)+0.5
C              JUMP TO NEXT COMMA
	       KNOW   = KNOW + 1
d181 3
a183 7
        ELSE
C          FIRST ENTRY IS A REGISTER

           KNOW = INDEX (FCHAR(K1:NALPH),',') + K1 - 1
           CALL CHKSTRQ(FCHAR(K1:),KNOW-K1,'I',KLIST,DUM,KNLIST,IER)
           IKEY = PARAM(KLIST) + 0.5
        ENDIF
a184 9
        CALL CHKSTRQ(FCHAR(KNOW+1:),NALPH-KNOW,'I',ILIST,DUM,
     &               NLIST,IER)

C       REGISTER LIST OK -----------------------------------------
        IF (IKEY .LT. 0) THEN
C          DESIRE A COMMENTED KEY
            CALL DOCCOM(DOCNAM,NDOC,IKEY,PLIST,NLIST,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
           GOTO 333
d187 1
a187 1
           WRITE(NOUT,*) 'REGISTER LIST LIMIT: ',MAXLISTT
d211 9
a219 5
           CALL DOCINFO(DOCNAM,NDOC,MAXY,MAXCOLS,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(100,'RDDOCA2Q',NE)
              RETURN
           ENDIF
a282 1
CNO_SAVE
d312 1
a312 1
        LOGICAL        FIRST,ISDIGI,FOUNDIT,RUNTIME
d409 2
a410 2
C       DOCUMENT NAME FOUND OR BUFFER SPACE AVAILABLE ----------------
C       PROCEED TO PARSE REGISTER LINE, CHECK FOR ',' OR 'X'
d412 2
a413 7
1300	K1=7
        DO K = K1,NALPH
           KNOW = K
           IF (FCHAR(K:K) .EQ. ',' .OR. FCHAR(K:K) .EQ. 'X') GOTO 1414
        ENDDO
	CALL ERRT(26,'RDDOCA2Q',IE)
	RETURN
d415 6
a420 22
1414	IF (FCHAR(KNOW:KNOW) .EQ. ',') THEN

           KNOW = KNOW - 1

C          CHECK IF FIRST ENTRY IS A NUMBER OR AN INDEX OF A DO-LOOP

	   IF (ISDIGI(FCHAR(KNOW:KNOW))) THEN
c              ASSUME FIRST ENTRY IS A NUMBER
               CALL CHKNUMQ(FCHAR(K1:),KNOW-K1+1,'I',IKEY,FNUM,IER)
               IF (IER .NE. 0) THEN
                  CALL ERRT(26,'RDDOCA',IE)
                  RETURN
               ENDIF

           ELSE          
C              FIRST ENTRY IS A DO-LOOP INDEX. PUT ITS VALUE INTO ILIST.

               DINDEX = FCHAR(KNOW:KNOW)
               IDX    = ICHAR(DINDEX) -64
               IKEY   = IALPHA(IDX)+0.5
C              JUMP TO NEXT COMMA
	       KNOW   = KNOW + 1
d423 2
a424 15
        ELSE
C          FIRST ENTRY IS A REGISTER

           KNOW = INDEX (FCHAR(K1:NALPH),',') + K1 - 1
           CALL CHKSTRQ(FCHAR(K1:),KNOW-K1,'I',KLIST,DUM,KNLIST,IER)
           IKEY = PARAM(KLIST) + 0.5
        ENDIF

        CALL CHKSTRQ(FCHAR(KNOW+1:),NALPH-KNOW,'I',ILIST,DUM,
     &               NLIST,IER)

C       REGISTER LIST OK -----------------------------------------
        IF (IKEY .LT. 0) THEN
C          DESIRE A COMMENTED KEY
            CALL DOCCOM(DOCNAM,NDOC,IKEY,PLIST,NLIST,IRTFLG)
d427 1
d455 8
a462 5
           CALL DOCINFO(DOCNAM,NDOC,MAXY,MAXCOLS,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(100,'RDDOCA2Q',NE)
              RETURN
           ENDIF
d472 1
a472 1
C          KEEP POINTER IN LUNDOC
@


1.20
log
@added maxicdocst
@
text
@a319 2
#ifdef SP_ALLOC
C       RUN-TIME ALLOCATION SPECIFIC CODE LINES FOLLOW
a331 7
#else
C       NON RUN-TIME SPECIFIC CODE LINES FOLLOW
C       MAXIMUM NUMBER OF OPENED CONCURRENT INCORE DOCUMENT FILES 
        PARAMETER (MAXICDOCST=2)    

        COMMON /DOC_BUF/ DBUF(MAXCOL,MAXKEY,MAXICDOCST)
#endif
d358 1
a358 1
#ifdef SP_ALLOC
d364 1
a364 1
#endif
a515 1
#ifdef SP_ALLOC
a550 16
#else
C       RECOVER INFO FROM DOC FILE OR PROPER IN-CORE IMAGE
        CALL UNSDAL(DOCNAM,ICALL,NDOC,IKEY,PLIST,NLIST,DBUF(1,1,IC),
     &              MAXY,MAXX,NKEY,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(100,'RDDOCA2Q',NE)
           RETURN
        ENDIF

        IF (FIRST) THEN
C          REPORT SIZE OF THE ARRAY THAT WAS OPENED
           WRITE(NOUT,97) NKEY,MAXX-1
97         FORMAT(' IN-CORE DOCUMENT HAS: ',I6, ' KEYS AND: ',I2, 
     &               ' REGISTERS',/)
        ENDIF
#endif
@


1.19
log
@repeated parameter no longer allowed
@
text
@d317 3
d322 2
d325 2
a326 3
        PARAMETER      (MAXICDOCS=10)    
#if defined(SP_SUN4) || defined(SP_NT)
        INTEGER        LOCDOC(MAXICDOCS)
d328 3
a330 1
        INTEGER * 8    LOCDOC(MAXICDOCS)
d337 1
a337 1
        PARAMETER (MAXICDOCS=2)    
d339 1
a339 1
        COMMON /DOC_BUF/ DBUF(MAXCOL,MAXKEY,MAXICDOCS)
d348 2
a349 2
        INTEGER        NUMREGS(MAXICDOCS),NUMKEYS(MAXICDOCS)
	CHARACTER *81  OLDNAM(MAXICDOCS)
d356 1
a356 1
	DATA           OLDNAM/MAXICDOCS*'*'/
d362 1
a362 1
           DO  ICORE=1,MAXICDOCS
d384 1
a384 1
           DO I = 1,MAXICDOCS 
d409 1
a409 1
        IF (ICLAST .GT. 0 .AND. ICLAST .LE. MAXICDOCS .AND.
d418 1
a418 1
	DO ICORE = MAXICDOCS,1,-1
@


1.18
log
@f90 bugs
@
text
@a316 3
C       MAXIMUM NUMBER OF KEYS IN DOC FILE
        PARAMETER (MAXKEY=9999)

@


1.17
log
@f90 changes
@
text
@d47 1
a47 1
        TYPE(REAL_POINTER), DIMENSION(NUMINLN) :: LOCDOC
a58 1
        IPTNOW  => LOCLUN(LUN)%IPT
d90 1
a90 1
               LOCDOC(ICORE) = 0
@


1.16
log
@restored version 1.14
@
text
@d4 1
a4 1
C RDDOCA2Q.F
d35 275
d325 1
a325 1
#ifdef SP_NT
a336 1
 
d601 1
@


1.15
log
@added include F90ALLOC.INC
@
text
@a36 4
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC' 
#endif

@


1.14
log
@used INteger instead of integer *8 for pointers in nt
@
text
@d37 4
@


1.13
log
@typo fixed
@
text
@d50 3
d54 1
a54 1

@


1.12
log
@bad format line
@
text
@d96 1
a96 1
             ENDIFi
@


1.11
log
@bad .
@
text
@d96 1
a96 1
             ENDIF
d101 1
a101 1
91            FORMAT(' DOCUMENT FILE NOT IN-CORE: 'A)
@


1.10
log
@runtime not initailized for deallocate!!
@
text
@d72 1
a72 1
        LOGICAL        FIRST,ISDIGI,FOUNDIT.RUNTIME
@


1.9
log
@MAXCOL undefined if alloc
@
text
@d72 1
a72 1
        LOGICAL        FIRST,ISDIGI,FOUNDIT
d90 2
a91 1
               IPQ = LOCDOC(ICORE)
@


1.8
log
@removed an silent output line.
@
text
@d40 6
a58 5
C       MAXIMUM NUMBER OF COLUMNS PER KEY 
        PARAMETER (MAXCOL=7)
    
C       MAXIMUM NUMBER OF KEYS IN DOC FILE
        PARAMETER (MAXKEY=9999)
@


1.7
log
@changed MAXCOLS for non alloc
@
text
@d318 1
a318 1
        WRITE(NOUT,*) ' '
@


1.6
log
@fixed
@
text
@d54 1
a54 1
        PARAMETER (MAXCOL=10)
a267 3
C          RECOVER DOC FILE INTO RUNTIME ARRAY
           CALL UNSDAL(DOCNAM,ICALL,NDOC,IKEY,PLIST,NLIST,QBUF,
     &              MAXY,MAXX,NKEY,IRTFLG)
a270 2
           CALL UNSDAL(DOCNAM,ICALL,NDOC,IKEY,PLIST,NLIST,
     &                 QBUF,MAXY,MAXX,NKEY,IRTFLG)
d272 4
d291 1
a291 1
           WRITE(NOUT,97) MAXY,MAXX-1
@


1.5
log
@fixed bug in names and memwant
@
text
@d4 1
a4 1
C RDDOCA2Q.FOR
d16 1
a16 1
C   RDDOCA2Q(CFUNC,NALPHT,NDOC)
d23 1
a23 2
C   PARAMETERS:     CFUNC     CALLING LINE FROM DRIVER    (SENT) 
C                   NALPH     NUMBER OF LETTERS IN CFUNC  (SENT)
d35 1
a35 1
	SUBROUTINE RDDOCA2Q(DOCNAM,CFUNC,NALPHT,NDOC)
d43 2
a44 2
        PARAMETER (MAXICDOCS=10)    
        INTEGER * 8     LOCDOC(MAXICDOCS)
d53 2
a54 2
C       ONE PLUS THE MAXIMUM NUMBER OF REGISTERS PER KEY IN 'UD IC'
        PARAMETER (MAXREG=7)
d56 1
a56 1
C       MAXIMUM NUMBER OF KEYS IN 'UD IC'
d59 1
a59 1
        COMMON /DOC_BUF/ DBUF(MAXREG,MAXKEY,MAXICDOCS)
d62 6
a67 3
        CHARACTER *(*) CFUNC,DOCNAM
	REAL           PLIST(20)
	INTEGER        ILIST(20)
d74 1
a74 1
        SAVE           NUMREGS, NUMKEYS, OLDNAM, LOCDOC, IPQ
d78 1
a78 1
	IF (CFUNC(6:6) .EQ. 'E') THEN
d93 1
d102 1
a102 1
           IGOT = 0
d122 1
d127 9
d171 1
a171 1
        DO K = K1,NALPHT
d173 1
a173 1
           IF (CFUNC(K:K) .EQ. ',' .OR. CFUNC(K:K) .EQ. 'X') GOTO 1414
d178 1
a178 1
1414	IF (CFUNC(KNOW:KNOW) .EQ. ',') THEN
d184 1
a184 1
	   IF (ISDIGI(CFUNC(KNOW:KNOW))) THEN
d186 1
a186 1
               CALL CHKNUMQ(CFUNC(K1:),KNOW-K1+1,'I',IKEY,FNUM,IER)
d195 1
a195 1
               DINDEX = CFUNC(KNOW:KNOW)
d205 2
a206 2
           KNOW = INDEX (CFUNC(K1:NALPHT),',') + K1 - 1
           CALL CHKSTRQ(CFUNC(K1:),KNOW-K1,'I',KLIST,DUM,KNLIST,IER)
d210 1
a210 1
        CALL CHKSTRQ(CFUNC(KNOW+1:),NALPHT-KNOW,'I',ILIST,DUM,
d214 11
a224 2

        IF (FIRST) THEN
d227 2
a228 2
           NUMREGS(IC) = MAXX
           MAXY        = MAXREG * MAXKEY / MAXX
d234 2
a235 2
  	   IF (NLIST .GT. MAXX) THEN
              WRITE(NOUT,1447) NLIST
d238 1
a238 1
              NLIST = MAXX
d247 5
a251 2
           CALL DOCINFO(DOCNAM,NDOC,MAXY,MAXX,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d254 1
a254 1
           MEMWANT = (MAXX+1) * MAXY
d256 4
a259 1
           IF (IRTFLG .NE. 0) RETURN
d277 4
a280 1
        IF (IRTFLG .NE. 0) RETURN
a281 1

d285 4
a288 1
        IF (IRTFLG .NE. 0) RETURN
d292 3
a294 2
           WRITE(NOUT,97) MAXY
97         FORMAT(' IN-CORE DOCUMENT HAS: ',I6, ' KEYS',/)
d299 1
a299 1
	DO  K=1,NLIST
d308 2
a309 2
CCC             WRITE(6,987) IP-1,PARAM(IP)
CCC987          FORMAT(' REGISTER (',I3,'): ',G11.3)
d317 1
@


1.4
log
@using unsdal now, can do runtime alloc of 10 doc files
@
text
@d105 1
a105 1
                 ILEN = LNBLNK(OLDNAM)
d225 1
a225 1
           CALL DOCINFO(DOCNAM,NDOC,NUMKEYS(IC),MAXX,.TRUE.,IRTFLG)
d235 1
d242 1
a242 1
     &              NUMKEYS(IC),MAXX,NKEY,IRTFLG)
@


1.3
log
@fixed ud ic command
@
text
@d16 1
a16 1
C   RDDOCA2Q(CFUNC,NALPH,NDOC,DBUF,MAXKEY,MAXREG)
a25 3
C                   DBUF      BUFFER FOR DOC FILE DATA    (RETURNED)
C                   MAXKEY    MAX KEY THAT FITS           (SENT)
C                   MAXREG    MAX REG THAT FITS           (SENT)
d28 1
a28 1
C                           INTO CORE
d32 1
a32 1
C   CALLS:    UNSDAL2
d36 1
a36 1
	SUBROUTINE RDDOCA2Q(CFUNC,NALPH,NDOC,DBUF,MAXKEY,MAXREG)
d38 30
a67 10
	COMMON/UNITS/LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
	COMMON/PARAM/PARAM(103)
	COMMON/DOLOOP/IALPHA(26)
        CHARACTER      COPT
        COMMON/BATCH2/ COPT

	REAL           DBUF(MAXREG,MAXKEY,2),PLIST(6)
	INTEGER        ILIST(7),ICALL(2),NLET(2),NUMREGS(2)
        CHARACTER *(*) CFUNC
	CHARACTER *81  DOCNAM,OLDNAM(2)
d69 1
a69 3
        LOGICAL        FIRST,ISDIGI

	DATA ICALL/0,0/,NUMREGS/0,0/
d71 2
a72 2
C       FIND MAXIMUM NUMBER OF STORAGE LOCATIONS IN EACH DBUF
        MAXVAL = MAXREG * MAXKEY
d74 1
a74 2
	CALL FILERD(DOCNAM,NLETD,NULL,'DOCUMENT',IRTFLG)
        IF(IRTFLG .EQ. -1) RETURN
d77 1
d79 12
a90 11
           IFOUND = 0
           DO  ICORE=1,2
C            ICFREE STORES NUMBER OF BUFFER SECTION FREED UP
	     IF (NLETD .EQ. NLET(ICORE) .AND. 
     &         DOCNAM(1:NLETD) .EQ. OLDNAM(ICORE)(1:NLETD)) THEN
	       OLDNAM(ICORE) = '*'
C              CHANGES OLDNAM SO THAT IT CANNOT BE MATCHED WITH ANY FILE NAME.
               ICALL(ICORE)   = 0
               NLET(ICORE)    = 0
               NUMREGS(ICORE) = 0
               IFOUND         = 1
d94 3
a96 5
           WRITE(NOUT,11) OLDNAM(1),OLDNAM(2)
11         FORMAT(' DOCUMENT FILES LEFT IN CORE:',/5X,A,/5X,A)
           IF (IFOUND .EQ. 0) THEN
               WRITE(NOUT,10) DOCNAM(1:NLETD)
10             FORMAT(' *** WARNING **** NO MATCH FOUND FOR ',/1X,A)
d98 15
d116 3
d120 1
a120 1
	ICFREE = 0
d123 8
a130 7
C       WANT TO FILL IC=1 FIRST NOW al
	DO ICORE=2,1,-1
          IC = ICORE
          IF (ICALL(IC) .EQ. 0) ICFREE=IC
          IF (NLETD .EQ. NLET(ICORE) .AND. 
     &       DOCNAM(1:NLETD) .EQ. OLDNAM(ICORE)(1:NLETD)) GOTO 1300
        END DO
d132 3
d140 1
a140 8
        IF (ICFREE .GT. 0) THEN
           IC         = ICFREE
           OLDNAM(IC) = DOCNAM
           NLET(IC)   = NLETD
           FIRST      = .TRUE.

        ELSE

d142 2
a143 2
           WRITE(NOUT,1201) DOCNAM(1:NLETD)
1201	   FORMAT(' *** NOT FOUND. NO SPACE AVAILABLE:',A)
d146 7
a152 1
        ENDIF
d154 2
a155 1
C       OK, PROCEED TO PARSE REGISTER LINE, CHECK FOR ',' OR 'X'
d158 1
a158 1
        DO K = K1,NALPH
d161 1
a161 1
        END DO
a172 2

               WRITE(NOUT,*) K1,KNOW-K1+1
d180 1
a180 1
C              FIRST ENTRY IS A DO-LOOP INDEX. PUT ITS VALUE INTO DLIST.
d182 1
a182 1
1425           DINDEX = CFUNC(KNOW:KNOW)
d192 2
a193 2
           KNOW = INDEX (CFUNC(K1:NALPH),',') + K1 - 1
1444       CALL CHKSTRQ(CFUNC(K1:),KNOW-K1,'I',KLIST,DUM,KNLIST,IER)
d197 1
a197 1
        CALL CHKSTRQ(CFUNC(KNOW+1:),NALPH-KNOW,'I',ILIST,DUM,
d200 2
d203 2
a204 7
C          MUST SET ARRAY DIMENSIONS FOR DLIST
           MAXX   = NLIST + 1
           IF (MAXX .GT. MAXREG) THEN
              ITEMP = MAXREG - 1
              WRITE(NOUT,*) '*** REGISTER LIMIT:', ITEMP
              RETURN
           ENDIF
d206 2
d209 1
a209 1
C          GET ARRAY SIZE SAVED WHEN DBUF FILLED
d211 8
a219 1
        MAXY = MAXVAL / MAXX 
d221 26
a246 7
  	IF (NLIST .GT. MAXX) THEN
           WRITE(NOUT,1447) NLIST
1447       FORMAT(' *** WARNING: NUMBER OF REGISTERS REQUESTED:',I2,
     &            ' NUMBER AVAILABLE:',I2,/)
           NLIST = MAXX
C          STOP IF BATCH AND PARAM(100) = 1
           CALL ERRT(100,'RDDOCA2Q',NE)
d248 2
d251 4
a254 5
c	CALL UNSDAL2(DOCNAM,ICALL,IC,NDOC,IKEY,PLIST,NLIST,DBUF,
c     1               MAXY,MAXX,NKEY,LERR)
	CALL UNSDAL2(DOCNAM,ICALL,IC,NDOC,IKEY,PLIST,NLIST,DBUF,
     1               MAXKEY,MAXREG,NKEY,LERR)
	IF (LERR .NE. 0) RETURN
d257 5
a261 5
C          REPORT SIZE OF THE DBUF ARRAY THAT WAS OPENED
           WRITE(NOUT,97) MAXX,MAXY,NKEY
97         FORMAT(' INCORE DOCUMENT ARRAY SIZE: ',I4,' X',I5,
     &            '.  HIGHEST KEY FOUND: ',I5,/)
        ENDIF           
d263 1
a265 1

d268 2
a269 3
             WRITE(NOUT,*) ' *** PARAM ARRAY LIMIT < 104, GOT:',IP

          ELSE
d272 3
d276 1
a276 1
        END DO
d278 4
d283 1
@


1.2
log
@used opendoc and cosmetic
@
text
@d190 2
d193 1
a193 1
     1               MAXY,MAXX,NKEY,LERR)
@


1.1
log
@Initial revision
@
text
@d18 4
a21 3
C   PURPOSE:    THIS ROUTINE DUPLICATES FUNCTION OF RDDOC (UNSAVE DOCUMENT)
C               BUT IT USES IN-CORE STORAGE, WHICH MAKES SUBSEQUENT READ 
C               ACCESSES VERY QUICK.
d23 8
a30 1
C   USAGE:      'UD IC' --  FIRST ACCESS: READ CONTENTS OF ENTIRE DOCUMENT 
d32 2
a33 2
C               'UD IC' --  SUBSEQUENT ACCESSES: READ DIRECTLY FROM CORE
C               'UD ICE' -- TERMINATE CORE ACCESS OF CURRENT DOCUMENT
d35 2
d65 1
a65 1
           DO 1100 ICORE=1,2
d76 1
a76 1
1100       CONTINUE
d79 1
a79 1
11         FORMAT(' DOCUMENT FILES LEFT IN CORE:',/1X,A,/1X,A)
d104 1
a104 1
        IF (ICFREE.GT.0) THEN
d191 1
a191 1
     1    MAXY,MAXX,NKEY,LERR)
@
