head	1.48;
access;
symbols
	pre_mrcs:1.38
	healthdept_2018:1.38
	pre_getangas:1.20
	GPL2010:1.20
	pre_GPL2010:1.19
	pre_var_equation:1.19
	pre_fftwrings:1.14
	pre_opfiles:1.14
	src:1.14
	best-code:1.14
	x-named-regs:1.13
	x:1.13
	v13-00:1.13
	pre_GPL:1.12
	prec_CA:1.12
	noindx:1.6;
locks; strict;
comment	@c @;


1.48
date	2020.01.13.19.18.47;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2020.01.09.19.42.20;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2020.01.08.18.27.48;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2020.01.07.19.42.35;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2020.01.06.18.59.59;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2020.01.02.19.44.06;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2020.01.02.19.07.34;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2019.12.31.20.08.20;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2019.12.31.20.00.22;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2019.11.04.17.35.58;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2018.10.03.14.34.03;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2018.01.26.17.07.29;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2016.01.22.14.51.26;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2015.12.10.18.38.55;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2015.10.28.16.08.11;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2015.09.14.18.24.35;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2015.07.15.14.41.15;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2015.07.15.14.11.50;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2015.01.21.16.38.32;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2014.09.15.15.37.33;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.01.12.33.42;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2013.08.01.12.30.25;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2013.07.31.18.07.54;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.21.17.44.03;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.12.12.49.53;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.05.18.46.23;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.21.16.38.59;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2012.05.17.14.48.30;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.24.13.25.18;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.22.13.29.07;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.05.16.28.04;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.19.15.19.39;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.26.12.33.05;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.26.12.29.08;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.09.16.14.10;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.17.20.59.58;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.22.18.38.02;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.11.16.15.14;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.04.16.05.07;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.04.15.47.53;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.03.16.57.36;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.20.21.41.09;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.18.13.49.18;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.15.20.32.51;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.29.19.53.13;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.11.14.08.56;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.04.19.01.45;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.22.18.06.32;	author leith;	state Exp;
branches;
next	;


desc
@@


1.48
log
@cosmetic
@
text
@
C **********************************************************************
C
C COPYFROMMRC   MODIFIED FROM COPYMRC             FEB 02 ArDean Leith         
C               ISSWAB ADDED                      JUL 02 ArDean Leith
C               FLIP QUESTION                     MAR 03 ArDean Leith
C               BAD IRECMRC4 & FLIP               SEP 03 ArDean Leith
C               SCALING                           JAN 05 ArDean Leith
C               I*8                               SEP 08 ArDean Leith
C               NPIX8                             DEC 08 ArDean Leith
C               BOTLEFT OPTION                    MAY 12 ArDean Leith
C               STREAM IO                         FEB 13 ArDean Leith
C               VOL BUG                           JUN 13 ArDean Leith
C               VOL BUG FIXED                     JUL 13 ArDean Leith
C               MODE 6 STACK SUPPORT              SEP 14 ArDean Leith
C               IPOSMRC INTEGER *8                JAN 15 ArDean Leith
C               BOTLEFT DEFAULT                   JUL 15 ArDean Leith
C               2015 STACK SUPPORT                JUL 15 ArDean Leith
C               STACK END BUG                     OCT 15 ArDean Leith
C               'MRCV'                            DEC 15 ArDean Leith
C               REWRITE FOR NATIVE MRC SUPPORT    JAN 20 ArDean Leith
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2020 Health Research Inc.,                          *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C 
C COPYFROMMRC(LUN1,LUN2, LUNDOC,LUNXM1,LUNXM2)
C                                                                      
C PURPOSE: CONVERTS MRC IMAGES TO SPIDER IMAGES, CRUDELY WRITTEN!!!
C
C NOTES: DATA IN MRC FILE
C        MODE   TYPES OF PIXEL IN IMAGE
C               0 : INTEGER*1 BYTES (UNSIGNED) 
C               1 : INTEGER*2       (SIGNED) 
C               2 : 32 BIT REALS
C               6 : INTEGER*2       (UNSIGNED)
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

        SUBROUTINE COPYFROMMRC(LUN1,LUN2, LUNDOC,LUNXM1,LUNXM2)

        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        REAL        :: BUF
        COMMON /IOBUF/ BUF(NBUFSIZ)

        INTEGER                  :: LUN1,LUN2,LUNDOC,LUNXM1,LUNXM2

        LOGICAL                  :: VERBOSE_SAVE,ASKNAM
        LOGICAL                  :: IS_MRC,IS_ACTUALLY_A_VOL,IS_BARE
        LOGICAL                  :: FOUROK = .FALSE.

        CHARACTER (LEN=MAXNAM)   :: PROMPT 
        CHARACTER (LEN=MAXNAM)   :: FILNAM1,FILNAM2
        CHARACTER (LEN=1)        :: NULL = CHAR(0)
        CHARACTER (LEN=1)        :: DISP
        CHARACTER (LEN=4)        :: CAXIS
        CHARACTER (LEN=12)       :: CSTR
        INTEGER                  :: NC,NCC,NE,NOT_USED
        INTEGER                  :: NILMAX,IRTFLG,NSTACK1,NLET1,NINDX1
        INTEGER                  :: IFORM1,NX1,NY1,NZ1,NDUM,NGOT1,NGOT2
        INTEGER                  :: IMG1,NSTACK2,NLET2,IDUM,NINDX2,IMG2
        INTEGER,ALLOCATABLE      :: ILIST1(:),ILIST2(:)

        VERBOSE_SAVE = VERBOSE       ! SAVE CURRENT VERBOSITY

        NILMAX  = NIMAX              ! FROM CMLIMIT
        ALLOCATE(ILIST1(NIMAX),
     &           ILIST2(NIMAX),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'COPYFROMMRC; ILIST...',2*NIMAX)
           RETURN
        ENDIF

C       OPEN FIRST INPUT MRC FILE 

        PROMPT  = 'MRC INPUT FILE OR TEMPLATE (E.G. STK@@****)~~9'
        CALL FILERD(FILNAM1,NLET1,NULL, PROMPT,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

C       APPEND .mrc IF NEEDED
        IF (INDEX(FILNAM1,'.mrc') <= 0 .AND.
     &      INDEX(FILNAM1,'.MRC') <= 0 .AND.
     &      INDEX(FILNAM1,'.map') <= 0 .AND.
     &      INDEX(FILNAM1,'.MAP') <= 0) THEN
            FILNAM1 = FILNAM1(1:NLET1) // '.mrc'
            NLET1   = NLET1 + 4
        ENDIF

        NSTACK1 =  1   ! PARAMETER UNUSED ON INPUT
        DISP    = 'E'  ! DISP = 'E' DOES NOT STOP ON ERROR
        ASKNAM  = .FALSE.  
        CALL OPFILES(0,LUN1,LUNDOC,LUNXM1,  
     &               ASKNAM,FILNAM1,NLET1, DISP,
     &               IFORM1,NX1,NY1,NZ1,NSTACK1,
     &               FILNAM1,
     &               FOUROK, ILIST1,NILMAX, 
     &               NDUM,NGOT1,IMG1, IRTFLG) 
        IF (IRTFLG .NE. 0) RETURN

C       NSTACK1 RET:  -2   IS NON-STACK IMAGE,  -1 IS STACKED IMG,                  
C                    >= 0 IS CURRENT MAX. IMG # FOR STACK             

        !write(3,'(a,5i5)')' In copyfrommrc, nstack1,ngot1,img1:',
        !&                                      nstack1,ngot1,img1
 
C       BE SURE INPUT IS MRC
        CALL LUNGETIS_MRC(LUN1,IS_MRC,IRTFLG)
        IF (.NOT. IS_MRC) THEN    
           CALL ERRT(101,'INPUT IS NOT MRC FILE',NE)
           GOTO 999
        ENDIF

C	OPEN FIRST SPIDER OUTPUT FILE
        NSTACK2 =  1   ! PARAMETER NOT USED ON INPUT
        DISP    = 'U'          
        IMG2    = IMG1

        IF (NSTACK1 >= 0) THEN
           PROMPT = 'SPIDER OUTPUT FILE OR TEMPLATE (E.G. STK@@****)~~9'
        ELSE
           PROMPT = 'SPIDER OUTPUT FILE~'
        ENDIF
        CALL FILERD(FILNAM2,NLET2,NULL, PROMPT,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL LUNGETISBARE_MRC(LUN1,IS_BARE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

C       TREAT THIS IMAGE AS A STACK NOT A VOLUME (WHERE RELEVENT)
        IS_ACTUALLY_A_VOL = .FALSE.

        IF (NSTACK1 >= 0) THEN
C           MAY HAVE ABERRENT MRC HEADER
            IF  (FCHAR(9:12) == 'MRCV') THEN
               IS_ACTUALLY_A_VOL = .TRUE.

            ELSEIF (IS_BARE) THEN
               IMG2   = 1
               CALL RDPRI1S(IMG2,NOT_USED,
     &                  'FIRST IMAGE NUMBER IN SPIDER STACK',IRTFLG)
               IF (IRTFLG .NE. 0) GOTO 999
               IF (IMG2 <= 0) IS_ACTUALLY_A_VOL = .TRUE. 
            ELSE
               IMG2 = 1
            ENDIF
         ENDIF

         IF (IS_ACTUALLY_A_VOL) THEN
C           TREAT THIS IMAGE AS A VOLUME NOT A STACK
            NZ1     = NSTACK1
            NSTACK1 = -2
            CALL LUNSETNSTACK_MRC(LUN1, NZ1,NSTACK1,IRTFLG)
        ENDIF

        ASKNAM = .FALSE.
        CALL OPFILES(LUN1,LUN2,LUNDOC,LUNXM2, 
     &             ASKNAM,FILNAM2,NLET2,DISP,
     &             IFORM1,NX1,NY1,NZ1,NSTACK2,
     &             FILNAM2,
     &             FOUROK, ILIST2,NILMAX, 
     &             NDUM,NGOT2,IMG2, IRTFLG)
 
C       NSTACK2 RET:  -2   IS NON-STACK IMAGE,  -1 IS STACKED IMG,                  
C                    >= 0 IS CURRENT MAX. IMG # FOR STACK             

        !write(6,'(A,4i6)')' Out nstack2,ngot2,img2:',nstack2,ngot2,img2

        CALL WHICH_HAND_MRC(LUN1,FILNAM1,CAXIS,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        !write(3,*) ' Mrc data axis: ',caxis

        IF (NZ1 <= 1) THEN       ! IMAGE(S) INPUT
           CALL RDPRMC(CSTR,NC,.TRUE.,'DATA ORIGIN CORNER (UL/LL)', 
     &              NULL,IRTFLG)
        ELSE                     ! VOLUME(S) INPUT
           CALL RDPRMC(CSTR,NC,.TRUE.,  
     &              'DATA ORIGIN CORNER (UL/LL) & HANDEDNESS (L/R)',
     &              NULL,IRTFLG)
        ENDIF
        IF (IRTFLG .NE. 0)  RETURN

        NCC = INDEX(CSTR(1:NC),',')
        IF (NCC > 0) NCC = NCC - 1
        IF (INDEX(CSTR(1:NCC),'Y') > 0) THEN   ! LEGACY FLIP INPUT
           CALL ERRT(101,
     &         'DATA BYTE FLIP NO LONGER AVAILABLE HERE',IDUM)
           GOTO 999
        ENDIF

        IF (INDEX(CSTR(1:NC),'LL') > 0) CAXIS(1:2) = 'LL'

        IF (NZ1 > 1) THEN    
C          VOLUME OUTPUT
           CAXIS(4:4) = 'L'
           IF (INDEX(CSTR(3:NC),'R')  > 0) CAXIS(4:4) = 'R'

           !WRITE(NOUT,*)' DATA ORIGIN CORNER & HANDEDNESS: (',CAXIS,')'
        ELSE
           !WRITE(NOUT,*)' DATA ORIGIN CORNER: (',CAXIS(1:2),')'
        ENDIF

        CALL LUNSETHAND_MRC(LUN1,CAXIS,IRTFLG)
        CALL LUNSETPOS_MRC (LUN1,NGOT1,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        NINDX1 = 1
        NINDX2 = 1
        DO                ! LOOP OVER ALL IMAGES/STACKS

C          DO NOT REPORT FILE INFO IF WHOLE STACK (VERBOSE IN COMMON)
	   !!!IF (NSTACK1 > 0 .AND. NSTACK2 >= 0) VERBOSE = .FALSE. 

C          COPY THE DESIRED NUMBER OF DATA RECORDS (MRC OK)
           DO IREC = 1,NY1 * NZ1
              CALL REDLIN(LUN1,BUF,NX1,IREC)
              CALL WRTLIN(LUN2,BUF,NX1,IREC)
           ENDDO
           !write(3,*)' in copyfrommrc,ilist.:   ',ilist1(:3),ilist2(:3) 
           !write(3,*)' in copyfrommrc,filnam1:  ',filnam1(1:20)
           !write(3,*)' in copyfrommrc,filnam2:  ',filnam2(1:20)
           !write(3,*)' in copyfrommrc,ngot1..2: ',ngot1,ngot2 
           !write(3,*)' In copyfrommrc,nindx1..2:',nindx1,nindx2 
           !write(3,*)' in copyfrommrc,img1..2:  ',img1,img2 

C          OPEN NEXT SET OF I/O FILES, UPDATES NINDX1 & NINDX2 
           CALL NEXTFILES(NINDX1,NINDX2,  ILIST1,ILIST2, 
     &                    .FALSE., LUNXM1,LUNXM2,
     &                    NGOT1,NGOT2,    NSTACK1,NSTACK2,  
     &                    LUN1,LUN1,LUN2, FILNAM1,FILNAM2,
     &                    IMG1,IMG2, IRTFLG)

           !if (irtflg .ne. 0) then
           !write(6,'(A,4i6)') 
!     &        ' Nextfiles img1,img2,irtflg:',img1,img2,irtflg
           !write(6,'(A,4i6)') 
!     &        ' Nextfiles nindx1,nindx2:',nindx1,nindx2
           !endif

           IF (IRTFLG .NE. 0) EXIT      ! ERROR / END OF INPUT STACK
       ENDDO

       IRTFLG = 0
   
999    CLOSE(LUN1)
       CLOSE(LUN2)

       VERBOSE = VERBOSE_SAVE          ! RESTORE VERBOSITY 
       IF (ALLOCATED(ILIST1)) DEALLOCATE(ILIST1)
       IF (ALLOCATED(ILIST2)) DEALLOCATE(ILIST2)

       END

@


1.47
log
@cosmetic
@
text
@d167 1
a167 2
                IMG2   = 1
                 
d243 2
a244 2
           !write(3,*)' In copyfrommrc,filnam1:  ',filnam1(1:20)
           !write(3,*)' In copyfrommrc,filnam2:  ',filnam2(1:20)
@


1.46
log
@commented out verbose
@
text
@d126 2
a127 2
        !write(3,'(a,5i5)')'  In copyfrommrc, nstack1,ngot1,img1:',
        !&                                    nstack1,ngot1,img1
@


1.45
log
@prompt changed
@
text
@d236 1
a236 1
	   IF (NSTACK1 > 0 .AND. NSTACK2 >= 0) VERBOSE = .FALSE. 
@


1.44
log
@ELSEIF (IS_BARE) THEN
@
text
@d93 1
a93 1
           CALL ERRT(46,'COPYFROMMRC; ILIST....',2*NIMAX)
d99 1
a99 1
        PROMPT  = 'INPUT FILE NAME OR TEMPLATE (E.G. STK@@****)~~9'
d243 6
a250 1
           !write(3,*)' In copyd, calling nextfiles:',nindx1,nindx2 
a256 1
           !write(3,*) ' In copyd, after nextfiles, irtflg',irtflg
@


1.43
log
@stacked image bug with .mrcs
@
text
@d71 1
a71 1
        LOGICAL                  :: IS_MRC,IS_ACTUALLY_A_VOL
d149 4
d154 1
d160 1
a160 1
            ELSEIF (IMG1 > 0) THEN
@


1.42
log
@trap for img1 for non-standard stacks
@
text
@d154 1
d160 4
a163 1
               IF (IMG2 <= 0) IS_ACTUALLY_A_VOL = .TRUE.                   
d217 1
a217 1
           WRITE(NOUT,*)' DATA ORIGIN CORNER & HANDEDNESS: (',CAXIS,')'
d219 1
a219 1
           WRITE(NOUT,*)' DATA ORIGIN CORNER: (',CAXIS(1:2),')'
@


1.41
log
@data origin msg removed
@
text
@d21 1
a21 1
C               REWRITE FOR NATIVE MRC SUPPORT    DEC 19 ArDean Leith
d71 1
a71 1
        LOGICAL                  :: IS_MRC,IS_VOL_NOT_STK
d126 3
a128 2
        !write(6,'(a,8i5)')' In  nstack1,ngot1,img1:',nstack1,ngot1,img1

d149 1
a149 1
        IS_VOL_NOT_STK = .FALSE.
d153 2
a154 2
               IS_VOL_NOT_STK = .TRUE.
            ELSE
d159 1
a159 1
               IF (IMG2 <= 0) IS_VOL_NOT_STK = .TRUE.                   
d163 1
a163 1
         IF (IS_VOL_NOT_STK) THEN
@


1.40
log
@rewrite
@
text
@a212 1
           WRITE(6,*)   ' DATA ORIGIN CORNER & HANDEDNESS: (',CAXIS,')'
a214 1
           WRITE(6,*)   ' DATA ORIGIN CORNER: (',CAXIS(1:2),')'
@


1.39
log
@mrc_support
@
text
@d21 1
a21 2
C               'UL'                              SEP 19 ArDean Leith
C
d26 1
a26 1
C=* Copyright 1985-2019  Health Research Inc.,                         *
d44 1
a44 1
C COPYFROMMRC(LUNSPI,LUNMRC,NX,NY,NZ)
d50 4
a53 4
C               0 : INTEGER*1 (UNSIGNED BYTES) 
C               1 : INTEGER*2 (SIGNED) 
C               2 : REALS
C               6 : INTEGER*2 (UNSIGNED)
d58 1
a58 3
        SUBROUTINE COPYFROMMRC(LUNSPI,LUNMRC,NX,NY,NZ)

C       COPY FROM MRC TO SPIDER FILE FORMAT --------------- FROM MRC
a63 2
 
        COMMON /IOERR/  IERR       ! LEGACY REDLIN ERROR FLAG
d65 2
a66 2
        REAL                    :: BUFIN
        COMMON /IOBUF/  BUFIN(NBUFSIZ)
d68 1
a68 1
        INTEGER                 :: LUNSPI,LUNMRC, NXT,NYT,NZT
d70 24
a93 138
        INTEGER                 :: NX,NY,NZ
        REAL,       ALLOCATABLE :: STREAMBUF(:)
        INTEGER *1, ALLOCATABLE :: I1STREAMBUF(:)
        INTEGER *2, ALLOCATABLE :: I2STREAMBUF(:)
        INTEGER,    ALLOCATABLE :: ILIST(:)
        REAL                    :: BUF(NBUFSIZ),FIXLENBUF(256)
        INTEGER *1              :: I1BUF(1024)
        COMMON                     BUF,FIXLENBUF,I1BUF

        CHARACTER(LEN=MAXNAM)   :: MRCFILE,FILOUT
        CHARACTER(LEN=8)        :: ANS
        LOGICAL                 :: FLIP,BOTLEFT
        INTEGER                 :: IVAL
        INTEGER *1              :: I1VAL
        INTEGER *2              :: I2VAL

        INTEGER *2              :: I2V
        INTEGER *1              :: I1V(2),I1TMP
        EQUIVALENCE                (I2V,I1V)

        REAL    *4              :: R4VALIN,R4VALOUT
        INTEGER *1              :: I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE                (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)

        CHARACTER(LEN=1)        :: NULL = CHAR(0)
        INTEGER                 :: IERR,LENOPENB,LENOPENF,IRTFLG,MODE
        INTEGER                 :: NSYMBT,MACHST,NE,MAXIM,IOFFSET 
        INTEGER                 :: LENOPEN,NCHAR,IRECSPI
        INTEGER                 :: IBOTLEF,NOT_USED,IRECINC,ILOCOUT
        INTEGER                 :: IRECIN,ILOCIN,IRECINT
        REAL                    :: RMS,FMINT,FMAXT,FAVT,FSIGT,FN,FNCON
        REAL                    :: UNUSED,SCALE
        INTEGER                 :: IX,IY,IZ,NLET,LOCAT,NIMG
        INTEGER                 :: I,NSTACKT,ITYPE,NUNUSED,NSTACKOUT
        INTEGER                 :: IMGNUMOUT,IGO,NINDX,IRECSTK
        INTEGER                 :: ISPG,MZ

        INTEGER *8              :: IPOSMRC

        LOGICAL                 :: ASKNAM,FOUROK,WANTSTACK,FOLD
        INTEGER, PARAMETER      :: LUNDOCSEL = 0
        INTEGER, PARAMETER      :: LUNXM     = 0

        integer   :: imax   = -1000000, iymax  = 0, imax2  = 0
        integer   :: ixmax2 = 0, iymax2 = 0
        integer   :: imin   = 100000000, ixmin = 0,iymin = 0, imin2 = 0
        integer   :: ixmin2 = 0, iymin2 = 0
     
        IERR = 0

        NX   = NXT
        NY   = NYT
        NZ   = NZT

C       COPY FROM MRC TO SPIDER FILE FORMAT 

C       OPEN MRC FILE AS DIRECT ACCESS, UNFORMATTED, RECL=1024 BYTES
C       CONVERT TO LITTLE ENDED 
        LENOPENB = 1024
        LENOPENF = 1024 / 4
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'OL',
     &                       'MRC INPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       READ MRC HEADER 
        CALL REDLIN(LUNMRC,FIXLENBUF,LENOPENF,1)
 
C       PARSE MRC HEADER        
        CALL GETHEDCCP4(FIXLENBUF,NX,NY,NZ,MODE,FMIN,FMAX,
     &                  AV,RMS,NSYMBT,FLIP,MACHST,
     &                  ISPG,MZ,IRTFLG)
        IF (IRTFLG == 2) THEN
            CALL ERRT(101,
     &          'NOT CURRENT MRC FORMAT, CAN NOT COPY PRE-2000 MRC', NE)
           GOTO 9999
        ENDIF
C       CLOSE MRC FILE
        CLOSE(LUNMRC)

        WANTSTACK = .FALSE. 

        IF     (ISPG == 0 .AND. MZ == 1 .AND.  NZ > 1) THEN
C          SPIDER IMAGE STACK OUTPUT FILE (SOME PRE 2015 STACKS)
           WANTSTACK = .TRUE. 
           NIMG      = NZ
           NZ        = 1
           ITYPE     = 1
           MAXIM     = 1

        ELSEIF ((ISPG ==  0 .AND. MZ == 1) .OR.
     &          (ISPG ==  1 .AND. MZ == 1)) THEN
C          SPIDER IMAGE OUTPUT

C          OPEN NEW SPIDER IMAGE OUTPUT FILE     
           NIMG   = 1
           NZ     = MZ
           ITYPE  = 1
           MAXIM  = 0

           CALL OPFILEC(0,.TRUE.,FILOUT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                  MAXIM,'SPIDER IMAGE OUTPUT',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

        ELSEIF ((ISPG ==  1 .AND. MZ > 1) .OR.
     &          (ISPG ==  0 .AND. MZ > 1 .AND. FCHAR(9:12) == 'MRCV'))
     &          THEN
C          VOLUME (MAY BE VOLUME STACK IN PRE-2015)
C          MRCV = VOLUME OUTPUT (ABERRENT PRE MRC-2015 CONVENTION)

C          OPEN NEW SPIDER VOLUME OUTPUT FILE     
           NIMG   = 1
           NZ     = MZ
           ITYPE  = 3
           MAXIM  = 0

           CALL OPFILEC(0,.TRUE.,FILOUT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                  MAXIM,'SPIDER VOLUME OUTPUT',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

        ELSEIF (ISPG ==   0 .AND. MZ >  1) THEN
C          SPIDER IMAGE STACK OUTPUT (FOLLOWS MRC-2015 CONVENTION)
           WANTSTACK = .TRUE. 
           NIMG      = MZ
           NZ        = 1
           ITYPE     = 1
           MAXIM     = 1

        ELSEIF (ISPG == 401 .AND. MZ >  1) THEN
C          POST 2015 FORMAT VOLUME STACK 
           WANTSTACK = .TRUE. 
           NIMG      = NZ / MZ
           NZ        = MZ
           ITYPE     = 3
           MAXIM     = 1

        ELSE 
           CALL ERRT(102,'BAD STACK OR VOLUME PARAMETERS',ISPG)
           IRTFLG = 1
d97 1
d99 23
a121 2
        IF (NIMG > 1) THEN
C          SPIDER IMAGE OR VOLUME STACK OUTPUT
d123 2
a124 2
           CALL FILERD(FILOUT,NLET,NULL,'SPIDER OUTPUT STACK~',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
d126 1
a126 9
C          HACK TO USE OPFILES
           LOCAT = INDEX(FILOUT(1:NLET),'@@')
           IF (LOCAT == 0) THEN
              NLET              = NLET + 1
              FILOUT(NLET:NLET) = '@@'
           ELSEIF (LOCAT .NE. NLET) THEN
              NLET = LOCAT
              FILOUT(NLET+1:) = ' ' 
           ENDIF
d128 6
a133 4
           IGO = 1
           CALL RDPRI1S(IGO,NOT_USED,
     &                  'FIRST IMAGE NUMBER IN SPIDER STACK',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
d135 4
d140 4
a143 25
           ALLOCATE(ILIST(NIMG),STAT=IRTFLG)
           IF (IRTFLG > 0) THEN
              CALL ERRT(46,'COPYFROMMRC; ILIST',NIMG)
              GOTO 9999
           ENDIF

C          MAKE LIST OF STACKED FILE NUMBERS
           DO I = IGO,NIMG
              ILIST(I) = I
           ENDDO

           NSTACKT   = -NIMG    ! USE ILIST FOR STACKED IMG NUMBERS
           FOUROK    = .FALSE.  ! NOT FOURIER
           IMGNUMOUT = IGO
           ASKNAM    = .FALSE.
           !write(6,*) 'filout(1:nlet):', filout(1:nlet)

C          OPEN SPIDER STACK OUTPUT FILE     
           CALL OPFILES(0,LUNSPI,LUNDOCSEL,LUNXM,
     &            ASKNAM,FILOUT,NLET, 'N',
     &            ITYPE,NX,NY,NZ,MAXIM,
     &            FILOUT(1:NLET),
     &            FOUROK, ILIST,NSTACKT, 
     &            NUNUSED,NSTACKOUT, IMGNUMOUT, IRTFLG)
ccccccc           write(6,*) 'nstackout, imgnumout:', nstackout, imgnumout 
d145 2
d148 13
a160 12
C       EXTRACT DATA FROM MRC FILE AFTER HEADER & PUT IN SPIDER FILE
        IOFFSET = 1024 + NSYMBT

        IF (MODE == 0) THEN
           ALLOCATE(I1STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)
        ELSEIF (MODE == 1 .OR. MODE == 6)  THEN
           ALLOCATE(I2STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)
        ELSEIF (MODE == 2 )  THEN
           ALLOCATE(STREAMBUF(NX),STAT=IRTFLG)
        ELSE 
           CALL ERRT(102,'UNSUPPORTED MRC MODE',MODE)
        ENDIF 
d162 5
a166 3
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'COPYFROMMRC; **STREAMBUF',NX)
           GOTO 9999
d169 7
a175 22
C       OPEN MRC FILE FOR STREAM ACCESS
C       CONVERT TO LITTLE ENDED 
        CALL OPSTREAMFILE(.FALSE.,MRCFILE,NULL,LUNMRC,
     &                    'UNFORMATTED','OL',' ',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        CALL RDPRMC(ANS,NCHAR,.TRUE.,
     &        'FLIP BYTE ORDERING? (Y/N), ORIGIN CORNER IF NOT (LL)', 
     &         NULL,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (ANS(1:1) == 'Y') FLIP = .NOT. FLIP

        ! BOTLEFT IS USUAL MRC BOTTOM IN CURRENT FORMAT !!!!!
        BOTLEFT = .TRUE.
        IF (NCHAR > 1 .AND. (
     &                       (INDEX(ANS(2:NCHAR),'I') ) > 0) .OR.
     &                       (INDEX(ANS(2:NCHAR),'UL')) > 0) THEN
           BOTLEFT = .FALSE.
           WRITE(NOUT,*) ' MRC DATA ORIGIN CORNER: (UL)'
           WRITE(6,*)    ' MRC DATA ORIGIN CORNER: (UL)' 
        ENDIF
d177 2
a178 15
        NINDX  = 1

        DO  ! POSSIBLE LOOP OVER MRC STACK -------------------------
         IRECSPI = 0
         IRECINC = 1
         IRECSTK = (NINDX-1) * NY

         IF (BOTLEFT) THEN
C           INVERT TOP & BOT OF EACH IMAGE OR EACH IMAGE WITHIN VOLUME
            IRECSPI = NY*NZ + 1    ! NZ HAS BEEN SET = 1 IF STACK
            IRECINC = -1
         ENDIF

         IF (MODE == 0) THEN
C          SIGNED 8 BIT INTEGER MRC INPUT FILE
d180 1
a180 109
           DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY

C               IPOSMRC = IOFFSET + (IREC-1) * NX + 1

                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) I1STREAMBUF

                DO IX = 1,NX
                   IVAL = I1STREAMBUF(IX)
                   IF (IVAL < 0) IVAL = 256 + IVAL
                   STREAMBUF(IX) = IVAL
                ENDDO
  
                !if (irec == 1) then
                !   write(6,*)' ',iposmrc,i1streambuf(1),streambuf(1)
                !endif

                IRECSPI = IRECSPI + IRECINC
                !write(6,*) ' irecspi:',irecspi
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

              ENDDO ! END OF: IY = 1,NY
           ENDDO    ! END OF: IZ = 1,NZ

        ELSEIF (MODE == 1 .OR. MODE == 6) THEN
C         16 BIT INTEGER MRC INPUT FILE

          FOLD = (MODE == 1)
          !write(6,*) 'Flip & fold:',flip,fold

          DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY

c               IPOSMRC = IOFFSET + (IREC-1) * NX * 2 + 1

                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IPOSMRC * 2
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) I2STREAMBUF

                IF (FLIP .AND. FOLD) THEN
C                  INVERT BYTE ORDER & CONVERT SIGNED INTEGER TO UNSIGNED
                   DO IX = 1,NX
                      I2V           = I2STREAMBUF(IX)
                      I1TMP         = I1V(1)
                      I1V(1)        = I1V(2)
                      I1V(2)        = I1TMP

C                     FOLD CONVERTS SIGNED INTEGER TO UNSIGNED
                      IF (I2V < 0) I2V = 65536 + I2V

                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSEIF (FOLD) THEN
C                  CONVERT SIGNED INTEGER TO UNSIGNED
                   DO IX = 1,NX
                      I2V = I2STREAMBUF(IX)
                      IF (I2V < 0) I2V = 65536 + I2V
                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSEIF (FLIP) THEN
C                  INVERT BYTE ORDER
                   DO IX = 1,NX
                      I2V           = I2STREAMBUF(IX)
                      I1TMP         = I1V(1)
                      I1V(1)        = I1V(2)
                      I1V(2)        = I1TMP
                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSE
C                  NO CONVERSION
                   STREAMBUF = I2STREAMBUF
                ENDIF

#ifdef NEVER
                do ix = 1,nx
                   if (streambuf(ix) < imin) then
                      imin2  = imin
                      ixmin2 = ixmin
                      iymin2 = iymin
                      imin   = streambuf(ix)
                      ixmin  = ix
                      iymin  = iy
                   endif
                   if (streambuf(ix) > imax) then
                      imax2  = imax
                      ixmax2 = ixmax
                      iymax2 = iymax
                      imax   = streambuf(ix)
                      ixmax  = ix
                      iymax  = iy
                   endif
                enddo
#endif

C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)
d182 2
a183 2
              ENDDO
           ENDDO
d185 1
a185 44
#ifdef NEVER
           write(6,*) 'maxs: ',ixmax,iymax,imax
           write(6,*) 'maxs2:',ixmax2,iymax2,imax2
           write(6,*) 'mins: ',ixmin,iymin,imin
           write(6,*) 'mins2:',ixmin2,iymin2,imin2
#endif

        ELSEIF (MODE == 2) THEN
C          32 BIT FOATING POINT  MRC INPUT FILE

           DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY
c               IPOSMRC = IOFFSET + (IREC-1) * NX * 4 + 1
                      
                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IPOSMRC * 4
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) STREAMBUF
                IF (IERR .NE. 0) THEN
                   CALL ERRT(102,'READ ERROR ',IERR)
                ENDIF

                IF (FLIP) THEN
C                  INVERT BYTE ORDER
                   DO IX = 1,NX
                      R4VALIN       = STREAMBUF(IX)
                      I1VALOUT(1)   = I1VALIN(4)
                      I1VALOUT(2)   = I1VALIN(3)
                      I1VALOUT(3)   = I1VALIN(2)
                      I1VALOUT(4)   = I1VALIN(1)
                      STREAMBUF(IX) = R4VALOUT
                   ENDDO
                ENDIF

                !if (irec ==1) write(6,*) ' Val:',iposmrc, streambuf(1)
                !if (iz==1 .and. iy==1)
     &          !        write(6,*) ' Val:',iposmrc, streambuf(1)

C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)
d187 7
a193 5
              ENDDO
           ENDDO

        ELSE
           CALL ERRT(102,'CAN NOT COPY MRC MODE',MODE)
d195 1
d197 6
a202 16
        IF (.NOT. WANTSTACK) EXIT    ! FINISHED IF NOT A MRC STACK
        IF (NINDX >= NIMG)   EXIT    ! ALREADY FINISHED WITH STACK

C       OPEN NEXT STACKED OUTPUT FILE 
        CALL NEXTFILE(NINDX, ILIST, 
     &                FOUROK,LUNXM,
     &                NIMG,MAXIM,   
     &                LUNSPI,0,
     &                FILOUT,'N',
     &                IMGNUMOUT, IRTFLG) 
        
       IF (IRTFLG == -99) THEN
           CALL ERRT(102,'INSUFFICIENT OUTPUT FILE NAMES',NINDX)
           EXIT         
        ELSEIF (IRTFLG .NE. 0) THEN
           EXIT                      ! ERROR
d205 1
a205 1
       ENDDO   ! END OF STACK LOOP --------------------------
d207 4
a210 6
      !iposmrc = iposmrc + nx  
      !write(6,*) ' Last iposmrc:',iposmrc, streambuf(1)
        
9999   CLOSE(LUNSPI)
       CLOSE(LUNMRC)
       IF(ALLOCATED(STREAMBUF)) DEALLOCATE(STREAMBUF)
d212 6
a217 1
       END
d219 3
d223 3
a225 1
C       -------------- ISSWAB ----------------------------------------
d227 2
a228 1
        LOGICAL FUNCTION ISSWAB(LUN)
d230 5
a234 6
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
 
        INTEGER               :: IVAL(3)
        CHARACTER(LEN=12)     :: CVAL,CVALIN
        EQUIVALENCE(IVAL,CVAL)
d236 27
a262 2
        CHARACTER(LEN=MAXNAM) :: FILNAM
        LOGICAL               :: VERBOSE_SAVE
d264 1
a264 44
        CHARACTER(LEN=1)      :: NULL = CHAR(0)

C       DO NOT ECHO FILE OPENING
        VERBOSE_SAVE = VERBOSE
        VERBOSE      = .FALSE.

        FILNAM = 'TMP_JNK_SCRATCH'
        CALL OPAUXFILE(.FALSE.,FILNAM,NULL,LUN,12,'U',' ',.TRUE.,IRTFLG)

        CVAL(1:1)   = CHAR(0)
        CVAL(2:2)   = CHAR(0)
        CVAL(3:3)   = CHAR(0)
        CVAL(4:4)   = CHAR(4)
        CVAL(5:5)   = CHAR(48)
        CVAL(6:6)   = CHAR(48)
        CVAL(7:7)   = CHAR(49)
        CVAL(8:8)   = CHAR(50)
        CVAL(9:9)   = CHAR(0)
        CVAL(10:10) = CHAR(0)
        CVAL(11:11) = CHAR(0)
        CVAL(12:12) = CHAR(4)

        CALL WRTLIN(LUN,IVAL,3,1)
        CLOSE(LUN)

        CALL OPAUXFILE(.FALSE.,FILNAM,NULL,LUN,0,'O',' ',.TRUE.,IRTFLG)

        READ(LUN,*) CVALIN

        CLOSE(LUN,STATUS='DELETE')

c       WRITE(NOUT,*) 'CVALIN: ',CVALIN,' == ',CVAL
 
        ISSWAB   = (CVALIN(8:8) .NE. CVAL(8:8))

c       IF (ISSWAB) THEN
c           WRITE(NOUT,*) 'NON-NATIVE BYTE ORDER '
c       ELSE
c           WRITE(NOUT,*) 'NATIVE BYTE ORDER'
c       ENDIF

        VERBOSE = VERBOSE_SAVE

        END
@


1.38
log
@email_health_dept
@
text
@d21 1
d27 1
a27 1
C=* Copyright 1985-2018  Health Research Inc.,                         *
a86 1
        LOGICAL                 :: isswab
a121 6

        REAL    *4              :: R4STAMP 
        INTEGER *1              :: I1STAMP(4)
        INTEGER *4              :: I4STAMP(1)
        EQUIVALENCE                (R4STAMP,I1STAMP)
        EQUIVALENCE                (R4STAMP,I4STAMP)
a141 7
        R4STAMP    = FIXLENBUF(54)
C       write(6,*) 'i1stamp: ',i1stamp
C       write(6,*) 'i4stamp: ',i4stamp
        CALL FLIPBYTES(R4STAMP,I4STAMP,1,IRTFLG)
C       write(6,*) 'i1stamp: ',i1stamp
C       write(6,*) 'i4stamp: ',i4stamp

d291 2
a292 1
     &           'FLIP BYTE ORDERING? (Y/N)', NULL,IRTFLG)
d299 3
a301 1
        IF (NCHAR > 1 .AND. (INDEX(ANS(2:NCHAR),'I')) > 0) THEN
d303 2
a304 2
           WRITE(NOUT,*) '  **** ERROR?? NON-STANDARD CORNER ACTIVE'
           WRITE(6,*)    '  **** ERROR?? NON-STANDARD CORNER ACTIVE' 
@


1.37
log
@machine stamp fixed,  convert=little-ended rewrite
@
text
@d28 1
a28 1
C=* Email: spider@@wadsworth.org                                        *
@


1.36
log
@LOGICAL                 :: isswab
@
text
@d2 1
a2 1
C ++********************************************************************
d4 17
a20 17
C COPYFROMCCP4   MODIFIED FROM COPYMRC             FEB 02 ArDean Leith         
C                ISSWAB ADDED                      JUL 02 ArDean Leith
C                FLIP QUESTION                     MAR 03 ArDean Leith
C                BAD IRECMRC4 & FLIP               SEP 03 ArDean Leith
C                SCALING                           JAN 05 ArDean Leith
C                I*8                               SEP 08 ArDean Leith
C                NPIX8                             DEC 08 ArDean Leith
C                BOTLEFT OPTION                    MAY 12 ArDean Leith
C                STREAM IO                         FEB 13 ArDean Leith
C                VOL BUG                           JUN 13 ArDean Leith
C                VOL BUG FIXED                     JUL 13 ArDean Leith
C                MODE 6 STACK SUPPORT              SEP 14 ArDean Leith
C                IPOSMRC INTEGER *8                JAN 15 ArDean Leith
C                BOTLEFT DEFAULT                   JUL 15 ArDean Leith
C                2015 STACK SUPPORT                JUL 15 ArDean Leith
C                STACK END BUG                     OCT 15 ArDean Leith
C                'MRCV'                            DEC 15 ArDean Leith
d26 1
a26 1
C=* Copyright 1985-2016  Health Research Inc.,                         *
d44 1
a44 1
C COPYFROMCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
d46 1
a46 2
C PURPOSE: CONVERTS SPIDER IMAGES TO OR FROM MRC FORMAT
C          CRUDELY WRITTEN!!!
d58 1
a58 1
        SUBROUTINE COPYFROMCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
d85 1
a85 1
        LOGICAL                 :: FLIP,ISSWABT,BOTLEFT
d123 6
d135 1
a135 1
C       COPY FROM MRC TO SPIDER FILE FORMAT --------------- FROM MRC
d138 1
d141 1
a141 1
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'O',
d148 6
a153 4
C       FIND IF CURRENTLY SWAPPING BYTES DURING FILE OUTPUT
C       THIS MAY BE DONE BY COMPILER, SO HAVE TO ACTUALLY TEST OUTPUT

        ISSWABT = ISSWAB(99)
d157 1
a157 1
     &                  AV,RMS,NSYMBT,ISSWABT,FLIP,MACHST,
d254 1
a254 1
              CALL ERRT(46,'COPYCCP4; ILIST',NIMG)
d293 1
a293 1
           CALL ERRT(46,'COPYCCP4; **STREAMBUF',NX)
d298 1
d300 1
a300 1
     &                    'UNFORMATTED','O',' ',.TRUE.,IRTFLG)
d331 1
a331 1
C          SIGNED 8 BIT INTEGER CCP4 (MRC) INPUT FILE
d363 1
a363 1
C         16 BIT INTEGER CCP4 (MRC) INPUT FILE
d454 1
a454 1
C          32 BIT FOATING POINT CCP4 (MRC) INPUT FILE
@


1.35
log
@volume support for: ISPG ==  0 .AND. MZ > 1
if mrcv
@
text
@d26 1
a26 1
C=* Copyright 1985-2015  Health Research Inc.,                         *
d86 2
a87 1
        LOGICAL                 :: FLIP,ISSWABT,ISSWAB,BOTLEFT
d526 2
a527 2
        INTEGER,DIMENSION(3) ::  IVAL
        CHARACTER(LEN=12) ::     CVAL,CVALIN
d531 1
a531 1
        LOGICAL ::               VERBOSE_SAVE
d533 1
a533 1
        CHARACTER(LEN=1) ::      NULL = CHAR(0)
d568 1
a568 1
c        IF (ISSWAB) THEN
d570 1
a570 1
c        ELSE
d572 1
a572 1
c        ENDIF
@


1.34
log
@STACK END BUG
@
text
@d20 1
d168 5
a172 3
        ELSEIF ((ISPG ==   0 .AND. MZ == 1) .OR.
     &          (ISPG ==   1 .AND. MZ == 1)) THEN
C          SPIDER IMAGE OUTPUT         
a174 2

C          OPEN SPIDER IMAGE OUTPUT FILE     
d177 1
d179 17
a195 1
     &                  MAXIM,'SPIDER OUTPUT',.FALSE.,IRTFLG)
a205 12
        ELSEIF (ISPG ==   1 .AND. MZ > 1) THEN
C          VOLUME (MAY BE VOLUME STACK IN PRE-2015)
           NIMG   = 1
           NZ     = MZ

C          OPEN SPIDER VOLUME OUTPUT FILE     
           ITYPE  = 3
           MAXIM  = 0
           CALL OPFILEC(0,.TRUE.,FILOUT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                  MAXIM,'SPIDER OUTPUT',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

d239 1
a239 1
     &              'FIRST IMAGE NUMBER IN SPIDER STACK',IRTFLG)
d301 5
a305 2
        IF (NCHAR > 2 .AND. (INDEX(ANS(3:NCHAR),'N')) > 0) 
     &     BOTLEFT = .FALSE.
@


1.33
log
@support for pre 2015  ispg=0 stacks
@
text
@d19 1
a19 1
C                2015 STACK SUPPORT                JUL 15 ArDean Leith
d448 3
a450 2
                !if (irec ==1) write(6,*) ' Val:',iposmrc, streambuf(1)
                !write(6,*) ' irec,iposmrc:',irec,iposmrc
d464 4
d480 1
d490 1
a490 5
c       write(6,*)' nindx,nimg,imgnumout,irtflg:',
c     &             nindx,nimg,imgnumout,irtflg

        IF (NINDX > NIMG) EXIT    ! FINISHED 
        IF (IRTFLG == -99) THEN
d498 3
@


1.32
log
@botleft bug
@
text
@d4 16
a19 15
C COPYFROMCCP4             MODIFIED FROM COPYMRC   FEB 02 ArDean Leith         
C                          ISSWAB ADDED            JUL 02 ArDean Leith
C                          FLIP QUESTION           MAR 03 ArDean Leith
C                          BAD IRECMRC4 & FLIP     SEP 03 ArDean Leith
C                          SCALING                 JAN 05 ArDean Leith
C                          I*8                     SEP 08 ArDean Leith
C                          NPIX8                   DEC 08 ArDean Leith
C                          BOTLEFT OPTION          MAY 12 ArDean Leith
C                          STREAM IO               FEB 13 ArDean Leith
C                          VOL BUG                 JUN 13 ArDean Leith
C                          VOL BUG FIXED           JUL 13 ArDean Leith
C                          MODE 6 STACK SUPPORT    SEP 14 ArDean Leith
C                          IPOSMRC INTEGER *8      JAN 15 ArDean Leith
C                          BOTLEFT DEFAULT         JUL 15 ArDean Leith
C                          2015 STACK SUPPORT      JUL 15 ArDean Leith
d159 10
a168 2
        IF    ((ISPG ==   0 .AND. MZ == 1) .OR.
     &         (ISPG ==   1 .AND. MZ == 1)) THEN
d180 8
d189 1
a189 1
C          VOLUME (VOLUME STACK POSSIBLE IN PRE-2015)
a199 8
        ELSEIF (ISPG ==   0 .AND. MZ >  1) THEN
C          SPIDER IMAGE STACK
           WANTSTACK = .TRUE. 
           NIMG   = MZ
           NZ     = 1
           ITYPE  = 1
           MAXIM  = 1

d203 4
a206 4
           NIMG   = NZ / MZ
           NZ     = MZ
           ITYPE  = 3
           MAXIM  = 1
@


1.31
log
@stack support
@
text
@d18 1
d285 1
@


1.30
log
@IPOSMRC  to INTEGER * 8
@
text
@d4 1
a4 1
C COPYCCP4                 MODIFIED FROM COPYMRC   FEB 02 ArDean Leith         
d17 2
d41 1
a41 1
C COPYCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
d43 1
a43 1
C PURPOSE: CONVERTS SPIDER IMAGES TO OR FROM CCP4 FORMAT
d47 1
a47 1
C	 MODE   TYPES OF PIXEL IN IMAGE
d56 3
a58 1
        SUBROUTINE COPYCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
d70 1
a70 1
        INTEGER                 :: LUNSPI,LUNMRC, NX,NY,NZ
d72 1
d81 2
a82 3
        CHARACTER(LEN=MAXNAM)   :: MRCFILE,FILPAT,FILOUT
	CHARACTER(LEN=8)        :: ANS
	CHARACTER(LEN=80)       :: PROMPT
d96 1
a96 1
	CHARACTER(LEN=1)        :: NULL = CHAR(0)
d99 1
a99 1
        INTEGER                 :: LENOPEN,NCHAR,IRECMRC,IRECSPI
d104 1
a104 1
        INTEGER                 :: IX,IY,IZ,NLET,LOCAT,LOCAST
d106 2
a107 1
        INTEGER                 :: IMGNUMOUT,NSTACK,IGO,ISTACK,IRECSTK
d122 3
a124 5
C       FIND IF CURRENTLY SWAPPING BYTES
        ISSWABT = ISSWAB(99)

        IF (FCHAR(4:5)  == 'TO')      GOTO 1000

d132 1
a132 1
     &                       'MRC (CCP4) INPUT',.TRUE.,IRTFLG)
d138 9
a146 3
C	PARSE MRC HEADER	
	CALL GETHEDCCP4(FIXLENBUF,NX,NY,NZ,MODE,FMIN,FMAX,
     &                   AV,RMS,NSYMBT,ISSWABT,FLIP,MACHST,IRTFLG)
d148 2
a149 2
            CALL ERRT(101,'NOT CURRENT MRC FORMAT, MAY BE PRE 1999 MRC',
     &                NE)
a155 1
        NSTACK    = 0
d157 5
a161 4
        IF (NZ > 1) THEN
C          MRC FILE MAY BE VOLUME OR STACK (STUPID FILE FORMAT FOR STACK)
           PROMPT = 
     &      'OUTPUT VOLUME OR TEMPLATE FOR IMAGE STACK (E.G. STK@@*)~'
d163 5
a167 1
           CALL FILERD(FILPAT,NLET,NULL,PROMPT,IRTFLG)
d170 67
a236 24
           LOCAT     = INDEX(FILPAT(1:NLET),'@@')   
           LOCAST    = INDEX(FILPAT(1:NLET),'*')
           WANTSTACK = (LOCAST > LOCAT ) 
           ASKNAM    = .FALSE.    ! ALREADY ASKED OUTPUT FILENAME

           IF (WANTSTACK) THEN
C             OPEN FIRST SPIDER OUTPUT FILE	

              IGO = 1
              CALL RDPRI1S(IGO,NOT_USED,
     &                    'FIRST IMAGE NUMBER IN STACK',IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999

              NSTACK = NZ
              ALLOCATE(ILIST(NSTACK),STAT=IRTFLG)
              IF (IRTFLG > 0) THEN
                 CALL ERRT(46,'COPYCCP4; ILIST',NSTACK)
                 GOTO 9999
              ENDIF

C             MAKE LIST OF STACKED FILE NUMBERS
              DO I = IGO,NSTACK
                 ILIST(I) = I
              ENDDO
d238 9
a246 8
              NSTACKT = -NSTACK    ! USE ILIST FOR STACKED IMG NUMBERS
              FOUROK  = .FALSE.    ! NOT FOURIER
              NZ      = 1          ! NOT A VOLUME
              ITYPE   = 1

C             OPEN SPIDER STACK OUTPUT FILE	
              CALL OPFILES(0,LUNSPI,LUNDOCSEL,LUNXM,
     &            ASKNAM,FILOUT,NLET, 'U',
d248 1
a248 1
     &            FILPAT,
d251 1
a251 17
              !write(6,*) 'nstackout, imgnumout:', nstackout, imgnumout 

           ELSE
C             OPEN SPIDER VOLUME OUTPUT FILE	
              ITYPE  = 3
              MAXIM  = 0
              CALL OPFILEC(0,ASKNAM,FILPAT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                 MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
           ENDIF
        ELSE
C          OPEN SPIDER IMAGE OUTPUT FILE	
           ITYPE  = 1
           MAXIM  = 0
           CALL OPFILEC(0,.TRUE.,FILPAT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                 MAXIM,'SPIDER IMAGE OUTPUT',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
a253 1

a258 1

a260 1

a262 1

d278 1
a278 2
     &           'FLIP BYTE ORDERING? (Y/N), INVERT TOP/BOTTOM? (Y/N)',
     &            NULL,IRTFLG)
d283 5
a287 4
        ! BOTLEFT IS USUAL MRC BOTTOM IN CURRENT FORMAT !!
        BOTLEFT = (NCHAR > 2 .AND. (INDEX(ANS(3:NCHAR),'Y')) > 0) 

        ISTACK  = 1
d292 1
a292 1
         IRECSTK = (ISTACK-1) * NY
d424 1
a424 1
C          32 BIT FOATING POINT CCP4 MRC INPUT FILE
d466 1
a466 1
        CALL NEXTFILE(ISTACK, ILIST, 
d468 1
a468 1
     &                NSTACK,MAXIM,   
d470 1
a470 1
     &                FILPAT,'N',
d472 3
d476 1
a476 1
        IF (ISTACK > NSTACK) EXIT    ! FINISHED 
d478 1
a478 1
           CALL ERRT(102,'INSUFFICIENT OUTPUT FILE NAMES',NSTACK)
d485 4
d490 1
a490 148
       GOTO 9999

	



C      COPY FROM SPIDER TO MRC FILE FORMAT ----------------- TO MRC

1000   CONTINUE

C	OPEN NEW MRC FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
        LENOPENB = 1024
        LENOPENF = LENOPENB / 4
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'U',
     &                 'MRC OUTPUT',.TRUE.,IRTFLG)

        IVAL    = 8
        IBOTLEF = 0
        CALL RDPRI2S(IVAL,IBOTLEF,NOT_USED,
     &       'MRC DATA LENGTH (8/32 BITS), FLIP TOP/BOTTOM =1 (0/1)',
     &        IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        MODE = 2
        IF (IVAL == 8) MODE = 0
        BOTLEFT = (IBOTLEF > 0)   ! USUAL MRC BOTTOM!!

C	CREATE A NEW HEADER FOR THE CCP4 FILE
        FMINT = FMIN
        FMAXT = FMAX
        FAVT  = AV
        FSIGT = SIG

        IF (MODE == 0) THEN
           FN    = (255.0 - 0.0) / (FMAXT - FMINT)
           FNCON = 0.0 - FN * FMINT

           FMINT = 0.0
           FMAXT = 255.0
           I2VAL = FMINT * FN + FNCON
           FAVT  = I2VAL
C          FSIGT IS NOT RIGHT!!!!
           FSIGT = -1.0
        ENDIF

C       TRY TO GET SCALE VALUE (MAY NOT BE USED)
        CALL GETLAB(LUNSPI,NX,UNUSED,21,1,SCALE,IRTFLG)

C	CREATE HEADER. (NOTE: FMIN, FMAX, AV ARE SAME AS SPIDER IMAGE)
        CALL SETHEDCCP4(FIXLENBUF, NX, NY, NZ,
     &            FMINT,FMAXT,FAVT,FSIGT,SCALE,MODE,ISSWABT,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C	WRITE HEADER OF 1024 BYTES (256 FLOATS) TO MRC FILE
        CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,1) 

C       SET STARTING RECORD FOR MRC DATA
        IRECMRC = 1   !SKIPS ONE HEADER RECORD
        ILOCOUT = 0

        IF (MODE == 2) THEN
C          FLOATING POINT OUTPUT

           DO  IRECIN = 1,NY * NZ

C             READ EACH ROW OF SPIDER INPUT FILE 
              IF (BOTLEFT) THEN
                 IRECINT = (NY * NZ) - IRECIN + 1  
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECINT)
              ELSE
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
              ENDIF

C             PUT ROW OUT TO MRC FILE
              DO ILOCIN=1,NX
                ILOCOUT            = ILOCOUT + 1
                FIXLENBUF(ILOCOUT) = BUFIN(ILOCIN)

                IF (ILOCOUT >= LENOPENF) THEN
C                  PUT OUT COMPLETED RECORD

                   IRECMRC = IRECMRC + 1

                   CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,IRECMRC)
                   ILOCOUT = 0
                ENDIF
              ENDDO
           ENDDO

           IF (ILOCOUT > 0) THEN
C             PUT OUT REMAINING RECORD
              IRECMRC = IRECMRC + 1
              CALL WRTLIN(LUNMRC,FIXLENBUF,ILOCOUT,IRECMRC)
           ENDIF
 	
        ELSEIF (MODE == 0) THEN
C          COPY FROM SPIDER TO MRC 8 BIT FILE FORMAT 

           DO IRECIN = 1,NY * NZ
C             READ EACH ROW OF SPIDER INPUT FILE 
              IF (BOTLEFT) THEN
                 IRECINT = (NY * NZ) - IRECIN + 1  
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECINT)
              ELSE
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
              ENDIF

C             PUT ROW OUT TO CCP4 FILE
              DO ILOCIN=1,NX
                ILOCOUT        = ILOCOUT + 1
                I2VAL          = BUFIN(ILOCIN) * FN + FNCON
                I1BUF(ILOCOUT) = I2VAL

                IF (ILOCOUT >= LENOPENB) THEN
C                  PUT OUT COMPLETED RECORD
                   IRECMRC = IRECMRC + 1

                   CALL WRTLIN8(LUNMRC,I1BUF,LENOPENB,IRECMRC)
                   IF (IERR .NE. 0) THEN
                      CALL ERRT(102,'WRITING RECORD',IRECMRC)
                      GOTO 9999
                   ENDIF
                   ILOCOUT = 0
                ENDIF
              ENDDO
           ENDDO

           IF (ILOCOUT > 0) THEN
C             PUT OUT REMAINING RECORD
              IRECMRC = IRECMRC + 1
              CALL WRTLIN8(LUNMRC,I1BUF,ILOCOUT,IRECMRC)
          ENDIF

        ELSE
           CALL ERRT(102,'CAN NOT CREATE MRC MODE',MODE)
           GOTO 9999
        ENDIF

        IF (IERR .NE. 0) THEN
           CALL ERRT(102,'WRITING RECORD',IRECIN)
           GOTO 9999
        ENDIF

	
9999    CLOSE(LUNSPI)
        CLOSE(LUNMRC)
        IF(ALLOCATED(STREAMBUF)) DEALLOCATE(STREAMBUF)

        END
a550 147

C       --------------  OPSTREAMFILE ------------------------------

         SUBROUTINE OPSTREAMFILE(ASKNAME,FILNAM,EXTENT,LUNT,
     &                           FORMVAR, DISP, 
     &                           PROMPTT,CALLERRT,IRTFLG)


        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC'

        
        LOGICAL           :: ASKNAME
        CHARACTER(LEN=*)  :: FILNAM,EXTENT
        INTEGER           :: LUNT
        CHARACTER(LEN=11) :: FORMVAR
        CHARACTER(LEN=*)  :: DISP,PROMPTT
        LOGICAL           :: CALLERRT
        INTEGER           :: IRTFLG

        LOGICAL           :: EX
        CHARACTER(LEN=96) :: PROMPT
        CHARACTER(LEN=80) :: EXTEN
        CHARACTER(LEN=7)  :: STATVAR

        INTEGER           :: ICOMM,MYPID,MPIERR,LENP,NCHAR
        INTEGER           :: LNBLNKN
        INTEGER           :: LENE,IRTFLGT,LUN,IDUM,LENOPEN,LENOPENFILE
        INTEGER           :: LENOPN,LENREC

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID  #ifdef USE_MPI

C       SET DEFAULT ERROR RETURN
        IRTFLG = 1

C       DO NOT WANT TO RETURN EXTEN
        EXTEN = EXTENT

C       INPUT FILE NAME (IF EXTEN EXISTS IT IS ADDED)

        IF (ASKNAME) THEN
C          SET PROMPT TO ALLOW FILE EXTENSION ON INPUT
           LENP   = LEN(PROMPTT)
           LENP   = MIN(LENP,93)
           PROMPT = PROMPTT(1:LENP) // '~9' 

           CALL FILERD(FILNAM,NCHAR,EXTEN,PROMPT(1:LENP+2),IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ELSE
C          MAY WANT TO ADD EXTENT TO FILNAM
           NCHAR = LNBLNKN(FILNAM)
           LENE  = LNBLNKN(EXTENT)
           IF (LENE > 0) THEN
C             ADD THE EXTENSION THAT IS SENT TO FILNAM
              CALL FILNAMANDEXT(FILNAM,EXTEN,FILNAM,NCHAR,
     &                          .TRUE.,IRTFLGT)
           ENDIF
        ENDIF

        LUN = ABS(LUNT)
        IF ((LUN <= 0 .OR. LUN > 100) .AND.
     &     (LUN .NE. 103)) THEN
C          LUN=103 USED IN  SYMPARTEXT 
           CALL ERRT(102,'IN SOURCE CODE, LUN MUST BE 1...100',LUN)
           RETURN
        ENDIF

        IF (LUN > 0 .AND. LUN <= 100) THEN
C          ZERO THE FLAGS USED IN REDLIN/WRTLIN
           CALL LUNSETLUNS(LUN,0,0,LUN,0,IRTFLGT)
 
C          MAKE SURE THIS IS NOT TREATED AS INLINE FILE
           CALL CLOSEINLN(LUN,IRTFLGT)
        ENDIF

C       SET STATUS FOR OPEN
        STATVAR = 'NEW'

        IF (DISP(1:1) == 'N' .OR. DISP(1:1) == 'U') 
     &     STATVAR = 'REPLACE'

        IF (DISP(1:1) == 'S') STATVAR = 'SCRATCH'

        IF (DISP(1:1) == 'O') THEN
C          CHECK FOR FILE EXISTENCE 
           IF (MYPID <= 0) THEN
              INQUIRE (FILE=FILNAM(1:NCHAR),EXIST=EX,IOSTAT=IRTFLGT) 
           ENDIF

#ifdef USE_MPI
           CALL BCAST_MPI('OPSTREAMFILE','EX',           EX,1,'L',ICOMM)
           CALL BCAST_MPI('OPSTREAMFILE','IRTFLGT', IRTFLGT,1,'I',ICOMM)
#endif

           IF (IRTFLGT .NE. 0) THEN
              WRITE(NOUT,*) '*** INQUIRY ERROR'
              IF (CALLERRT)  CALL ERRT(4,'OPSTREAMFILE',IDUM)
              RETURN
        
           ELSEIF (.NOT. EX) THEN
              WRITE(NOUT,*) '*** FILE DOES NOT EXIST: ',FILNAM(1:NCHAR)
              IF (CALLERRT)  CALL ERRT(100,'OPSTREAMFILE',IDUM)
              RETURN

           ENDIF
           STATVAR = 'OLD'
        ENDIF

C       OPEN FILE FOR STREAM ACCESS

C       COMPUTE RECL UNITS (DIFFERS WITH OS &A COMPILER FLAGS)
        LENOPN = LENOPENFILE(LENREC)

        IF (MYPID <= 0) THEN
           IF (STATVAR == 'SCRATCH') THEN
	      OPEN(UNIT=LUN,STATUS=STATVAR,
     &             FORM=FORMVAR, ACCESS='STREAM',
     &             IOSTAT=IRTFLGT)
           ELSE
	      OPEN(UNIT=LUN,FILE=FILNAM(1:NCHAR),STATUS=STATVAR,
     &             FORM=FORMVAR, ACCESS='STREAM', 
     &             IOSTAT=IRTFLGT)
           ENDIF
        ENDIF

#ifdef USE_MPI
        CALL BCAST_MPI('OPSTREAMFILE','IRTFLGT', IRTFLGT,1, 'I',ICOMM)
#endif


        IF (IRTFLGT .NE. 0) THEN
           WRITE(NOUT,90) FORMVAR(1:1), FILNAM(:NCHAR)
 90        FORMAT(' ERROR OPENING (',A1,'): ',A)
           IF (CALLERRT) CALL ERRT(102,'OPSTREAMFILE',IRTFLGT)
           RETURN
        ENDIF

        IF (VERBOSE .AND. MYPID <= 0) THEN
           WRITE(NOUT,91) FORMVAR(1:1), FILNAM(:NCHAR)
 91        FORMAT('  OPENED (',A1,'): ',A)
        ENDIF

        IRTFLG = 0

        END

@


1.29
log
@==,  stack support, speed bug fixed, ..
@
text
@d16 1
d21 1
a21 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d100 1
a100 1
        INTEGER                 :: IPOSMRC,IX,IY,IZ,NLET,LOCAT,LOCAST
d104 2
d269 6
a274 1
                IPOSMRC = IOFFSET + (IREC-1) * NX + 1
d304 7
a310 1
                IPOSMRC = IOFFSET + (IREC-1) * NX * 2 + 1
d392 6
a397 1
                IPOSMRC = IOFFSET + (IREC-1) * NX * 4 + 1
@


1.28
log
@*** empty log message ***
@
text
@d4 12
a15 11
C COPYCCP4                 MODIFIED FROM COPYMRC FEB 02 ArDean Leith         
C                          ISSWAB ADDED          JUL 02 ArDean Leith
C                          FLIP QUESTION         MAR 03 ArDean Leith
C                          BAD IRECMRC4 & FLIP   SEP 03 ArDean Leith
C                          SCALING               JAN 05 ArDean Leith
C                          I*8                   SEP 08 ArDean Leith
C                          NPIX8                 DEC 08 ArDean Leith
C                          BOTLEFT OPTION        MAY 12 ArDean Leith
C                          STREAM IO             FEB 13 ArDean Leith
C                          VOL BUG               JUN 13 ArDean Leith
C                          VOL BUG FIXED         JUL 13 ArDean Leith
d20 1
a20 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d43 6
a48 4
C NOTES: DATA IN MRC FILE:
C	 MODE   0 : IMAGE STORED AS INTEGER*1  
C               1 : IMAGE STORED AS INTEGER*2
C               2 : IMAGE STORED AS REALS
d60 1
a60 1
        COMMON /IOERR/  IERR
d65 1
a65 1
        INTEGER                 :: LUNSPI,LUNMRC,NX,NY,NZ
d67 1
a67 1
        REAL, ALLOCATABLE       :: STREAMBUF(:)
d70 1
d75 3
a77 4
        INTEGER *8              :: NPIX8,NEED8,IGOT8,NT8

        CHARACTER(LEN=MAXNAM)   :: FILNAM,MRCFILE
	CHARACTER(LEN=80)       :: ANS
d87 1
a87 1
        REAL *4                 :: R4VALIN,R4VALOUT
d93 1
a93 1
        INTEGER                 :: NSYMBT,MACHST,NE,MAXIM,IOFFSET,MODEA 
d95 1
a95 2
        INTEGER                 :: ILOCCCCP,NVAL,IBOTLEF,NOT_USED 
        INTEGER                 :: ILOCSPI,ILOCMRC,IRECINC,ILOCOUT
d99 13
a111 2
        INTEGER                 :: IPOSMRC,IX,IY,IZ
    
d143 67
a209 7
C       OPEN SPIDER OUTPUT FILE	
        IFORM  = 1
        IF (NZ > 1) IFORM = 3
        MAXIM  = 0
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNSPI,'U',IFORM,NX,NY,NZ,
     &             MAXIM,'SPIDER OUTPUT',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
d214 2
a215 3
C       NPIX8 = TOTAL NUMBER OF PIXELS IN MRC FILE
        NPIX8 = NX * NY     ! DO NOT SIMPLIFY, COMPILER WRONG
        NPIX8 = NPIX8 * NZ
d217 2
a218 2
C       CHANGE MODE: 0,1,2 TO MODEA: 8,16,32
        MODEA = (2**(MODE + 1)) * 4
d220 1
a220 5
        IF (MODEA == 8) THEN
           ALLOCATE(I1STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)
        ELSEIF (MODEA == 16) THEN
           ALLOCATE(I2STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)
        ELSE
d222 3
d226 1
d234 1
a234 2
     &                    'UNFORMATTED','O', ' ',.TRUE.,IRTFLG)

d238 1
a238 1
     &           'FLIP BYTE ORDERING? (Y/N), INVERT TOP/BOTTEM? (Y/N)',
d244 1
a244 1
        ! USUAL MRC BOTTEM!!
d247 1
a247 2
c        write(6,*)' modea,lenop,NPIX8:',
c     &              modea,lenopen,NPIX8,NX,NY,NZ
d249 1
d252 1
d256 1
a256 1
            IRECSPI = NY*NZ + 1
d260 2
a261 2
        IF (MODEA == 8) THEN
C          8 BIT INTEGER CCP4 (MRC) INPUT FILE
d265 1
a265 1
                IREC    = (IZ -1) * NY + IY
d273 1
a273 1
                   STREAMBUF = IVAL
d284 5
a288 2
              ENDDO
           ENDDO
d290 2
a291 2
        ELSEIF (MODEA == 16) THEN
C          16 BIT INTEGER CCP4 (MRC) INPUT FILE
d295 1
a295 1
                IREC    = (IZ -1) * NY + IY
a298 2
                !if (irec ==1) write(6,*)' Val:',iposmrc,i2streambuf(1)
                !write(6,*) ' irec,iposmrc:',irec,iposmrc
d300 23
a322 1
                IF (FLIP) THEN
d330 5
a334 1
                    ENDDO
d337 20
a356 5
                DO IX = 1,NX
                   IVAL = I2STREAMBUF(IX)
                   IF (IVAL < 0) IVAL = 256 + IVAL
                   STREAMBUF = IVAL
                ENDDO
d365 8
a372 1
        ELSEIF (MODEA == 32) THEN
d375 1
a375 1
          DO IZ = 1,NZ
d377 1
a377 1
                IREC    = (IZ -1) * NY + IY
d407 21
a427 1
        GOTO 9999
d433 1
a433 1
C       COPY FROM SPIDER TO MRC FILE FORMAT ----------------- TO MRC
d435 1
a435 1
1000    CONTINUE
d446 1
a446 1
     &       'MRC DATA LENGTH (8/32 BITS), FLIP TOP/BOTTEM =1 (0/1)',
d451 1
a451 1
        BOTLEFT = (IBOTLEF > 0)   ! USUAL MRC BOTTEM!!
a665 4
#ifdef USE_MPI
        INCLUDE 'mpif.h'
#endif

d726 2
a727 10
           CALL MPI_BCAST(EX, 1, MPI_LOGICAL, 0, ICOMM, MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST EX'
              STOP
           ENDIF 
           CALL MPI_BCAST(IRTFLGT, 1, MPI_INTEGER, 0, ICOMM, MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST IRTFLGT'
              STOP
           ENDIF 
d762 1
a762 5
        CALL MPI_BCAST(IRTFLGT, 1, MPI_INTEGER, 0, ICOMM, MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST IRTFLGT'
           STOP
        ENDIF 
d764 1
@


1.27
log
@*** empty log message ***
@
text
@d167 2
a168 2
     &             'FLIP BYTE ORDERING? (Y/N), FLIP TOP/BOTTEM? (Y/N)',
     &              NULL,IRTFLG)
@


1.26
log
@invert bug fixed for all known cases
@
text
@d167 1
a167 1
     &             'FLIP BYTE ORDERING? (Y/N), FLIP TOP/BOTTEM (Y/N)',
@


1.25
log
@IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 1
@
text
@d13 2
d40 1
d42 1
a42 1
C NOTES: DATA IN CCP4 FILE:
d59 1
a59 1
        REAL                  :: BUFIN
d62 1
a62 1
        INTEGER               :: LUNSPI,LUNMRC,NX,NY,NZ
d64 34
a97 26
        REAL, ALLOCATABLE     :: STREAMBUF(:)
        REAL                  :: BUF(NBUFSIZ),FIXLENBUF(256)
        INTEGER * 1           :: I1BUF(1024)
        COMMON                   BUF,FIXLENBUF,I1BUF

        INTEGER * 8           :: NPIX8,NEED8,IGOT8,NT8

        CHARACTER(LEN=MAXNAM) :: FILNAM,MRCFILE
	CHARACTER(LEN=80)     :: ANS
        LOGICAL               :: FLIP,ISSWABT,ISSWAB,BOTLEFT
        INTEGER * 2           :: I2VAL

        REAL *4               :: R4VALIN,R4VALOUT
        INTEGER *1            :: I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE              (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
 
	CHARACTER(LEN=1)      :: NULL = CHAR(0)
        INTEGER               :: IERR,LENOPENB,LENOPENF,IRTFLG,MODE
        INTEGER               :: NSYMBT,MACHST,NE,MAXIM,IOFFSET,MODEA 
        INTEGER               :: LENOPEN,NCHAR,IRECMRC,IRECSPI
        INTEGER               :: ILOCCCCP,NVAL,IVAL,IBOTLEF,NOT_USED 
        INTEGER               :: ILOCSPI,ILOCMRC,IRECINC,ILOCOUT
        INTEGER               :: IRECIN,ILOCIN,IRECINT
        REAL                  :: RMS,FMINT,FMAXT,FAVT,FSIGT,FN,FNCON
        REAL                  :: UNUSED,SCALE
        INTEGER               :: IPOSMRC,IX
d107 1
a107 1
C       COPY FROM MRC TO SPIDER FILE FORMAT --------------- FROM CCP4
d127 2
d148 4
a151 8
C       CLOSE MRC FILE
        CLOSE(LUNMRC)

        IF (MODEA == 8 .OR. MODEA == 16) THEN
C          REOPEN MRC FILE AS NX*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NX * (MODEA / 8)
           CALL OPAUXFILE(.FALSE.,MRCFILE,NULL,LUNMRC,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
d154 5
a158 4
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'COPYCCP4; STREAMBUF',NX)
              GOTO 9999
           ENDIF
d160 3
a162 4
C          OPEN FOR STREAM ACCESS
           CALL OPSTREAMFILE(.FALSE.,MRCFILE,NULL,LUNMRC,
     &                       'UNFORMATTED','O', ' ',.TRUE.,IRTFLG)
        ENDIF
d166 1
a166 1
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,
d179 9
d189 1
a189 3
C          8 BIT INTEGER CCP4 INPUT FILE
           CALL RAW8TOSPI(LUNMRC,LUNSPI,NX,NPIX8,IOFFSET,.TRUE.,
     &                   LENOPEN,BUF,IRTFLG)
d191 4
a194 2
        ELSEIF (MODEA == 16) THEN
C          16 BIT INTEGER MRC FILE (HEADER LENGTH DIVISABLE BY TWO)
d196 1
a196 4
           IF (IRTFLG .NE. 0) GOTO 9999
           FLIP = .NOT. FLIP
           CALL RAW16TOSPI(LUNMRC,LUNSPI,NX,NPIX8,IOFFSET,FLIP,
     &                   .FALSE.,LENOPEN,BUF,IRTFLG)
d198 13
a210 2
        ELSEIF (MODEA == 32) THEN
C          32 BIT FOATING POINT MRC INPUT FILE
d212 2
a213 6
          IRECSPI = 0
          IRECINC = 1
          IF (BOTLEFT) THEN
             IRECSPI = NY + 1
             IRECINC = -1
          ENDIF
d215 2
a216 2
          DO IREC = 1,NY*NZ
             IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 1
d218 19
a236 1
            !write(6,*) ' irec,iposmrc:',irec,iposmrc
a237 5
             READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) STREAMBUF
             !if (irec ==1) write(6,*) ' Val:',iposmrc, streambuf(1)

             IF (FLIP) THEN
C               INVERT BYTE ORDER
d239 3
a241 6
                   R4VALIN       = STREAMBUF(IX)
                   I1VALOUT(1)   = I1VALIN(4)
                   I1VALOUT(2)   = I1VALIN(3)
                   I1VALOUT(3)   = I1VALIN(2)
                   I1VALOUT(4)   = I1VALIN(1)
                   STREAMBUF(IX) = R4VALOUT
a242 1
             ENDIF
d244 3
a246 7
C            PUT OUT COMPLETED RECORD
             IRECSPI = IRECSPI + IRECINC
             CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

c            itmp = mod(irecspi,NY)
c            if (itmp == 0) write(6,999) irecspi,buf(NX)
999          format(i10,' ; ',1pg13.7)
d248 33
a280 2
          ENDDO
          !write(6,*) ' irec,iposmrc:',irec,iposmrc
d381 1
a381 1
C          COPY FROM SPIDER TO MRC  8 BIT FILE FORMAT 
d383 1
a383 1
           DO  IRECIN = 1,NY * NZ
d653 1
a653 1
        RETURN
a654 1

@


1.24
log
@mpi header needed
@
text
@d194 1
a194 1
             IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 0
@


1.23
log
@OPSTREAMFILE used for 32 bit mrc --> spider conversion
@
text
@d467 4
@


1.22
log
@bot left option added
@
text
@d12 1
d17 1
a17 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d61 1
d86 1
a86 1

d93 1
a93 1
        IF (FCHAR(4:5)  .EQ. 'TO')      GOTO 1000
d138 17
a154 4
C       REOPEN MRC FILE AS NX*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
        LENOPEN = NX * (MODEA / 8)
        CALL OPAUXFILE(.FALSE.,MRCFILE,NULL,LUNMRC,LENOPEN,'O',
     &                ' ',.TRUE.,IRTFLG)
a185 6
          IOFFSET = IOFFSET / 4
          IRECMRC = 0
          ILOCSPI = 0
          ILOCMRC = NX + 1
          IGOT8   = 0

a191 6
    
C         NEED8 IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
          NEED8 = NPIX8 + IOFFSET

          DO WHILE (IGOT8 < NEED8)
             ILOCMRC = ILOCMRC + 1
d193 2
a194 7
             IF (ILOCMRC > NX) THEN
C               NEED TO READ NEW RECORD FROM INPUT
                NVAL = NX
                NT8  = NEED8 - IGOT8
                IF (NT8 .LT. NX) NVAL = NT8
                IRECMRC = IRECMRC + 1
                CALL REDLIN(LUNMRC,FIXLENBUF,NVAL,IRECMRC)
d196 1
a196 2
c               if(IRECMRC .le. 10)write(6,998)IRECMRC,nval,FIXLENBUF(nval)
998             format(' irec,nval,: ',2i10,' ; ',1pg13.7)
d198 2
a199 5
                ILOCMRC = 1
             ENDIF

C            IGOT8 POINTS TO CURRENT WORD IN INPUT FILE
             IGOT8 = IGOT8 + 1
d201 10
a210 15
             IF (IGOT8 > IOFFSET) THEN
C               WANT THIS VALUE FOR AN OUTPUT PIXEL
                ILOCSPI = ILOCSPI + 1
                IF (FLIP) THEN
C                  INVERT BYTE ORDER
                   R4VALIN      = FIXLENBUF(ILOCMRC)
                   I1VALOUT(1)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(2)
                   I1VALOUT(4)  = I1VALIN(1)
                   BUF(ILOCSPI) = R4VALOUT
                ELSE
C                  NO FLIP
                   BUF(ILOCSPI) = FIXLENBUF(ILOCMRC)
                ENDIF
d213 7
a219 9
             IF (ILOCSPI >= NX) THEN
C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,BUF,NX,IRECSPI)
                ILOCSPI = 0

c          itmp = mod(irecspi,NY)
c          if (itmp .eq. 0) write(6,999) irecspi,buf(NX)
999       format(i10,' ; ',1pg13.7)
a220 1
             ENDIF
d222 1
d373 1
d437 66
d504 3
d508 86
@


1.21
log
@nx, mrc not ccp4 labels,  prompts updated
@
text
@d7 1
a7 1
C                          BAD IRECCCP4 & FLIP   SEP 03 ArDean Leith
d11 1
d16 1
a16 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d34 1
a34 1
C COPYCCP4(LUNSPI,LUNCCP4,NX,NY,NZ)
d46 3
a48 1
        SUBROUTINE COPYCCP4(LUNSPI,LUNCCP4,NX,NY,NZ)
d54 2
d58 6
a64 2
        INTEGER * 1           :: I1BUF
        COMMON                BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d66 3
a68 3
        CHARACTER(LEN=MAXNAM) :: FILNAM,CCP4FILE
	CHARACTER(LEN=1)      :: NULL,ANS
        LOGICAL               :: FLIP,ISSWABT,ISSWAB
d75 11
a85 1
        NULL = CHAR(0)
d94 1
a94 1
C       COPY FROM CCP4 TO SPIDER FILE FORMAT --------------- FROM CCP4
d96 1
a96 1
C       OPEN CCP4 FILE AS DIRECT ACCESS, UNFORMATTED, RECL=1024 BYTES
d99 1
a99 1
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENOPENB,'O',
d104 1
a104 1
        CALL REDLIN(LUNCCP4,FIXLENBUF,LENOPENF,1)
d110 1
a110 2
C           NOT CURRENT CCP4 FORMAT
            CALL ERRT(101,'NOT CURRENT MRC FORMAT, TRY OLD MRC FORMAT',
d117 1
a117 1
        IF (NZ .GT. 1) IFORM = 3
d134 1
a134 1
        CLOSE(LUNCCP4)
d138 1
a138 1
        CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
d142 9
a150 3
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,'FLIP BYTE ORDERING? (Y/N)',
     &               NULL,IRT)
        IF (ANS .EQ. 'Y') FLIP = .NOT. FLIP
d157 1
a157 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NX,NPIX8,IOFFSET,.TRUE.,
d161 1
a161 1
C          16 BIT INTEGER CCP4 FILE (HEADER LENGTH DIVISABLE BY TWO)
d165 1
a165 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NX,NPIX8,IOFFSET,FLIP,
d169 1
a169 1
C          32 BIT FOATING POINT CCP4 INPUT FILE
d172 5
a176 1
          IRECCCP = 0
d178 6
a183 4
          ILOCSPI = 0
          ILOCCCP = NX + 1
          IGOT8    = 0
          
d188 3
a190 2
             ILOCCCP = ILOCCCP + 1
             IF (ILOCCCP .GT. NX) THEN
d195 2
a196 2
                IRECCCP = IRECCCP + 1
                CALL REDLIN(LUNCCP4,FIXLENBUF,NVAL,IRECCCP)
d198 1
a198 1
c            if(IRECCCP .le. 10)write(6,998)IRECCCP,nval,FIXLENBUF(nval)
d201 1
a201 1
                ILOCCCP = 1
d207 1
a207 1
             IF (IGOT8 .GT. IOFFSET) THEN
d212 1
a212 1
                   R4VALIN      = FIXLENBUF(ILOCCCP)
d220 1
a220 1
                   BUF(ILOCSPI) = FIXLENBUF(ILOCCCP)
d224 1
a224 1
             IF (ILOCSPI .GE. NX) THEN
d226 1
a226 1
                IRECSPI = IRECSPI + 1
d238 1
a238 1
           CALL ERRT(102,'CAN NOT COPY CCP4 MODE',MODE)
d245 2
d254 1
a254 1
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENOPENB,'U',
d257 5
a261 3
        IVAL = 8
        CALL RDPRI1S(IVAL,NOT_USED,
     &       'ENTER DATA LENGTH FOR MRC FILE (8 OR 32 BITS)',IRTFLG)
d264 2
a265 1
        IF (IVAL .EQ. 8) MODE = 0
d273 1
a273 1
        IF (MODE .EQ. 0) THEN
d293 2
a294 2
C	WRITE HEADER OF 1024 BYTES (256 FLOATS) TO CCP4 FILE
        CALL WRTLIN(LUNCCP4,FIXLENBUF,LENOPENF,1) 
d297 5
a301 2
        IRECOUT         = 1
        ILOCOUT         = 0
a302 1
        IF (MODE .EQ. 2) THEN
a303 2
C             READ EACH ROW OF SPIDER INPUT FILE   
              CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
d305 9
a313 1
C             PUT ROW OUT TO CCP4 FILE
d318 1
a318 1
                IF (ILOCOUT .GE. LENOPENF) THEN
d320 4
a323 2
                   IRECOUT = IRECOUT + 1
                   CALL WRTLIN(LUNCCP4,FIXLENBUF,LENOPENF,IRECOUT)
d329 1
a329 1
           IF (ILOCOUT .GT. 0) THEN
d331 2
a332 2
              IRECOUT = IRECOUT + 1
              CALL WRTLIN(LUNCCP4,FIXLENBUF,ILOCOUT,IRECOUT)
d335 2
a336 2
        ELSEIF (MODE .EQ. 0) THEN
C          COPY FROM SPIDER TO CCP4  8 BIT FILE FORMAT 
d339 7
a345 2
C             READ EACH ROW OF SPIDER INPUT FILE   
              CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
d353 1
a353 1
                IF (ILOCOUT .GE. LENOPENB) THEN
d355 3
a357 2
                   IRECOUT = IRECOUT + 1
                   CALL WRTLIN8(LUNCCP4,I1BUF,LENOPENB,IRECOUT)
d359 1
a359 1
                      CALL ERRT(102,'WRITING RECORD',IRECIN)
d367 1
a367 1
           IF (ILOCOUT .GT. 0) THEN
d369 2
a370 2
              IRECOUT = IRECOUT + 1
              CALL WRTLIN8(LUNCCP4,I1BUF,ILOCOUT,IRECOUT)
d374 1
a374 1
           CALL ERRT(102,'CAN NOT CREATE CCP4 MODE',MODE)
d382 1
a382 1
 
d385 1
a385 1
        CLOSE(LUNCCP4)
a386 1
        RETURN
a400 1
        CHARACTER(LEN=1) ::      NULL
d404 1
a404 1
        NULL = CHAR(0)
d408 1
a408 1
        VERBOSE = .FALSE.
@


1.20
log
@GPL_2010
@
text
@d33 1
a33 1
C COPYCCP4(LUNSPI,LUNCCP4,NSAM,NROW,NSLICE)
d45 1
a45 1
        SUBROUTINE COPYCCP4(LUNSPI,LUNCCP4,NSAM,NROW,NSLICE)
d81 1
a81 1
     &                       'CCP4 INPUT',.TRUE.,IRTFLG)
d84 1
a84 1
C       READ CCP4 HEADER 
d87 2
a88 2
C	PARSE CCP4 HEADER	
	CALL GETHEDCCP4(FIXLENBUF,NSAM,NROW,NSLICE,MODE,FMIN,FMAX,
d90 1
a90 1
        IF (IRTFLG .EQ. 2) THEN
d92 2
a93 1
            CALL ERRT(101,'NOT CCP4 FORMAT, TRY OLD MRC FORMAT',NE)
d99 1
a99 1
        IF (NSLICE .GT. 1) IFORM = 3
d101 1
a101 1
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNSPI,'U',IFORM,NSAM,NROW,NSLICE,
d105 1
a105 1
C       EXTRACT DATA FROM CCP4 FILE AFTER HEADER & PUT IN SPIDER FILE
d108 3
a110 3
C       NPIX8 = TOTAL NUMBER OF PIXELS IN CCP4 FILE
        NPIX8 = NSAM * NROW     ! DO NOT SIMPLIFY, COMPILER WRONG
        NPIX8 = NPIX8 * NSLICE
d115 1
a115 1
C       CLOSE CCP4 FILE
d118 2
a119 2
C       REOPEN CCP4 FILE AS NSAM*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
        LENOPEN = NSAM * (MODEA / 8)
d129 1
a129 1
c     &              modea,lenopen,NPIX8,nsam,nrow,nslice
d131 1
a131 1
        IF (MODEA .EQ. 8) THEN
d133 1
a133 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX8,IOFFSET,.TRUE.,
d136 1
a136 1
        ELSEIF (MODEA .EQ. 16) THEN
d141 1
a141 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX8,IOFFSET,FLIP,
d144 1
a144 1
        ELSEIF (MODEA .EQ. 32) THEN
d151 1
a151 1
          ILOCCCP = NSAM + 1
d157 1
a157 1
          DO WHILE (IGOT8 .LT. NEED8)
d159 1
a159 1
             IF (ILOCCCP .GT. NSAM) THEN
d161 1
a161 1
                NVAL = NSAM
d163 1
a163 1
                IF (NT8 .LT. NSAM) NVAL = NT8
d193 1
a193 1
             IF (ILOCSPI .GE. NSAM) THEN
d196 1
a196 1
                CALL WRTLIN(LUNSPI,BUF,NSAM,IRECSPI)
d199 2
a200 2
c          itmp = mod(irecspi,nrow)
c          if (itmp .eq. 0) write(6,999) irecspi,buf(nsam)
d214 1
a214 1
C       COPY FROM SPIDER TO CCP4 FILE FORMAT ----------------- TO CCP4
d218 1
a218 1
C	OPEN NEW CCP4 FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
d222 1
a222 1
     &                 'CCP4 OUTPUT',.TRUE.,IRTFLG)
d226 1
a226 1
     &       'ENTER DATA LENGTH FOR CCP4 FILE (8 OR 32 BITS)',IRTFLG)
d250 1
a250 1
        CALL GETLAB(LUNSPI,NSAM,UNUSED,21,1,SCALE,IRTFLG)
d253 1
a253 1
        CALL SETHEDCCP4(FIXLENBUF, NSAM, NROW, NSLICE,
d260 1
a260 1
C       SET STARTING RECORD FOR CCP4 DATA
d265 1
a265 1
           DO  IRECIN = 1,NROW * NSLICE
d267 1
a267 1
              CALL REDLIN(LUNSPI,BUFIN,NSAM,IRECIN)
d270 1
a270 1
              DO ILOCIN=1,NSAM
d292 1
a292 1
           DO  IRECIN = 1,NROW * NSLICE
d294 1
a294 1
              CALL REDLIN(LUNSPI,BUFIN,NSAM,IRECIN)
d297 1
a297 1
              DO ILOCIN=1,NSAM
@


1.19
log
@integer 8
@
text
@a11 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                       *
d13 5
a17 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d19 1
a19 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d24 1
a24 1
C=* This program is distributed in the hope that it will be useful,    *
d26 1
a26 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a27 1
C=*                                                                    *
d29 1
a29 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.18
log
@ngot8 in 32 bit bug
@
text
@d57 1
a57 1
        INTEGER * 8           :: NPIX8,NEED8,IGOT8
d131 2
a132 1
c       write(6,*)' modea,lenopen,NPIX8,nsam:',modea,lenopen,NPIX8,nsam,nrow,nslice
d163 4
a166 2
C               NEED8 TO READ NEW RECORD FROM INPUT
                NVAL    = MIN(NSAM,NEED8-IGOT8)
d169 4
d201 5
@


1.17
log
@npix8 on calls
@
text
@d157 1
a157 3
C         NPIX8 = TOTAL NUMBER OF PIXELS IN CCP4 FILE
          NPIX8 = NSAM * NROW * NSLICE
          NEED8 = NPIX + IOFFSET
@


1.16
log
@npix8 & need8
@
text
@d10 1
a10 1
C
d13 1
a13 1
C=* Copyright (C) 1985-208  Health Research Inc.                       *
d57 1
a57 1
        INTEGER * 8           :: NPIX8,NEED8
d111 3
a113 2
C       NPIX = TOTAL NUMBER OF PIXELS IN CCP4 FILE
        NPIX = NSAM * NROW * NSLICE
d131 2
d135 1
a135 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,.TRUE.,
d143 1
a143 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,FLIP,
d154 1
a154 1
          IGOT    = 0
d161 1
a161 1
          DO WHILE (IGOT .LT. NEED8)
d165 1
a165 1
                NVAL    = MIN(NSAM,NEED8-IGOT)
d171 2
a172 2
C            IGOT POINTS TO CURRENT WORD IN INPUT FILE
             IGOT = IGOT + 1
d174 1
a174 1
             IF (IGOT .GT. IOFFSET) THEN
a395 2


@


1.15
log
@npix8 & need8
@
text
@d57 3
a59 3
        INTEGER * 8     :: NPIX8,NEED8
        INTEGER * 1     :: I1BUF
        COMMON          :: BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d68 1
a68 1
        EQUIVALENCE           :: (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
@


1.14
log
@scale
@
text
@d9 1
d13 1
a13 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d57 3
a59 2
        INTEGER * 1     I1BUF
        COMMON          BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d62 7
a68 7
	CHARACTER(LEN=1) ::      NULL,ANS
        LOGICAL  ::              FLIP,ISSWABT,ISSWAB
        INTEGER * 2              I2VAL

        REAL *4                  R4VALIN,R4VALOUT
        INTEGER *1               I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE              (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
d81 1
a81 1
C       OPEN CCP4 FILE AS DIRECT ACCESS, UNFORMATTED, RECL= 1024 BYTES
d153 4
a156 2
C         NEED IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
          NEED = NPIX + IOFFSET
d158 1
a158 1
          DO WHILE (IGOT .LT. NEED)
d161 2
a162 2
C               NEED TO READ NEW RECORD FROM INPUT
                NVAL    = MIN(NSAM,NEED-IGOT)
d329 1
@


1.13
log
@GPL License fixed
@
text
@d8 1
d235 3
d240 1
a240 1
     &            FMINT,FMAXT,FAVT,FSIGT,MODE,ISSWABT,IRTFLG)
@


1.12
log
@flip & offset bugs
@
text
@d10 23
a32 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.11
log
@fixed flip
@
text
@d7 1
d126 2
a127 1
          IRECCCP = 1
d132 1
a132 1

d157 1
a157 1
                   I1VALOUT(3)  = I1VALIN(1)
@


1.10
log
@flip question
@
text
@d153 4
a156 4
                   I1VALOUT(4)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(1)
                   I1VALOUT(1)  = I1VALIN(2)
@


1.9
log
@lunsetluns in opauxfile now
@
text
@a78 4
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,'FLIP BYTE ORDERING? (Y/N)',
     &               NULL,IRT)
        IF (ANS .EQ. 'Y') FLIP = .NOT. FLIP

d104 4
@


1.8
log
@flip on 16
@
text
@d6 2
a7 1
C             
a33 1
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)
a54 2
        LUNARB(LUNCCP4) = LUNCCP4
        LUNSTK(LUNCCP4) = 0
d57 1
d79 4
a307 2
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

a323 1
        LUNARB(LUN) = LUN
@


1.7
log
@opfilec
@
text
@d115 1
@


1.6
log
@*** empty log message ***
@
text
@d84 1
a84 1
        CALL OPFILE(.TRUE.,FILNAM,LUNSPI,'U',IFORM,NSAM,NROW,NSLICE,
@


1.5
log
@*** empty log message ***
@
text
@d42 1
a42 1
        LOGICAL  ::              FLIP,ISSWABT,ISSWAB,REVERSE
d55 2
a58 1

d62 3
a64 2
        LENREC = 1024
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENREC,'O',
a66 2
 
        READ(LUNCCP4,REC=1,IOSTAT=IERR) FIXLENBUF
d68 2
a69 5
        IF (IERR .NE. 0) THEN
           WRITE(NOUT,*) '*** ERROR: (',IERR,') READING CCP4 HEADER'
           CALL ERRT(100,'COPYCCP4',NE)
           GOTO 9999
        ENDIF
d71 1
a71 1
C	PARSE THE CCP4 HEADER	
d94 3
a99 3
C       CHANGE MODE: 0,1,2 TO MODEA: 8,16,32
        MODEA = (2**(MODE + 1)) * 4

d113 2
d119 40
a158 5
C          32 BIT FOATING POINT IMAGE
           NFLIP = 0
           IF (FLIP) NFLIP = 2
           CALL RAW32TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,
     &                     IOFFSET,NFLIP,LENOPEN,BUF,IRTFLG)
d160 8
d180 4
a183 3
C	OPEN A NEW FILE FOR THE CCP4 FORMAT USING DIRECT ACCESS
C       RECORD LENGTH IS 4 BYTES  
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,4,'N',
d185 1
a185 1
	
d211 2
a212 2
C	WRITE HEADER. (NOTE: FMIN, FMAX, AV ARE SAME AS SPIDER IMAGE)
        CALL SETHEDCCP4(BUF, NSAM, NROW, NSLICE,
d216 2
a217 21
        IF (ISSWABT) THEN
           WRITE(NOUT,*)'      Flipping file data byte order'
        ENDIF


C	WRITE HEADER OF 1024 BYTES (256 FLOATS) FLOAT BY FLOAT
	DO IRECT=1, 256
	   WRITE(LUNCCP4,REC=IRECT,IOSTAT=IERR) BUF(IRECT)
           IF (IERR .NE. 0) THEN
              CALL ERRT(102,'WRITING CCCP HEADER POSITION',IRECT)
              GOTO 9999
           ENDIF
 	ENDDO

C	REOPEN CCP4 FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
        CLOSE(LUNCCP4)  
        LENREC = 1024
        CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENREC,'O',
     &                 ' ',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

d220 2
a221 3
        IRECOUT        = 1
        ILOCOUT        = 0
        LUNARB(LUNCCP4) = LUNCCP4
d230 2
a231 13
                ILOCOUT = ILOCOUT + 1

                IF (ISSWABT) THEN
C                  FLIP BYTE ORDER
                   R4VALIN      = BUFIN(ILOCIN)
                   I1VALOUT(4)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(1)
                   I1VALOUT(1)  = I1VALIN(2)
                   BUF(ILOCOUT) = R4VALOUT
                ELSE
                   BUF(ILOCOUT) = BUFIN(ILOCIN)
                ENDIF
d233 1
a233 1
                IF (ILOCOUT .GE. 256) THEN
d236 1
a236 5
                   CALL WRTLIN(LUNCCP4,BUF,256,IRECOUT)
                   IF (IERR .NE. 0) THEN
                      CALL ERRT(102,'WRITING RECORD',IRECIN)
                      GOTO 9999
                   ENDIF
d245 1
a245 1
              CALL WRTLIN(LUNCCP4,BUF,ILOCOUT,IRECOUT)
d261 1
a261 1
                IF (ILOCOUT .GE. LENREC) THEN
d264 1
a264 1
                   CALL WRTLIN8(LUNCCP4,I1BUF,LENREC,IRECOUT)
@


1.4
log
@*** empty log message ***
@
text
@d5 2
a6 1
C                                         
d9 1
a9 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d16 1
a16 1
C COPYCCP4(LUNSPI,LUNNEW)
d41 2
a42 2
	CHARACTER(LEN=1) ::      NULL
        LOGICAL  ::              FLIP
d45 4
d52 3
d76 1
a76 1
     &                   AV,RMS,NSYMBT,FLIP,MACHST,IRTFLG)
d170 1
a170 1
     &                FMINT,FMAXT,FAVT,FSIGT,MODE,IRTFLG)
d173 5
d208 12
a219 1
                BUF(ILOCOUT) = BUFIN(ILOCIN)
d288 66
@


1.3
log
@nloop,iloop_removed
@
text
@d71 1
a71 1
            CALL ERRT(101,'NOT CCP4 FORMAT, TRY MRC FORMAT?',NE)
d108 1
a108 4

           MSB = 1
           IF (FLIP) MSB = 2
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,MSB,
@


1.2
log
@*** empty log message ***
@
text
@d139 1
a139 1
        CALL RDPRI1S(IVAL,NLOOP,ILOOP,
@


1.1
log
@Initial revision
@
text
@d40 2
a41 2
	CHARACTER * 1            NULL
        LOGICAL                  FLIP
d92 2
a93 3
        IF (MODE .EQ. 0) THEN
C          8 BIT INTEGER CCP4 INPUT FILE
           INMODE  = 8
d95 5
a99 5
C          REOPEN CCP4 FILE WITH LENREC = 1 BYTE, DIRECT, FORMATTED
           LENOPEN = NSAM
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
d101 2
d106 1
a106 1
        ELSEIF (MODE .EQ. 1) THEN
a108 6
C          REOPEN CCP4 FILE AS NSAM*2 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NSAM * 2
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

d114 1
a114 1
        ELSEIF (MODE .EQ. 2) THEN
d116 2
a117 9

C          REOPEN CCP4 FILE AS NSAM*4 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NSAM * 4
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                    ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           IMODE = 32
           IF (FLIP) IMODE = -33
d119 1
a119 1
     &                     IOFFSET,IMODE,LENOPEN,BUF,IRTFLG)
d122 1
a122 3
 	   WRITE(NOUT,*)'CCP4 MODE: ',MODE,
     &                  '  CAN NOT BE COPIED TO SPIDER' 
           CALL ERRT(100,'COPYCCP4',NE)
@
