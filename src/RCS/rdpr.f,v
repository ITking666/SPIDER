head	1.84;
access;
symbols
	pre_getangas:1.80
	GPL2010:1.78
	pre_GPL2010:1.77
	pre_var_equation:1.72
	pre_fftwrings:1.72
	pre_opfiles:1.70
	src:1.70
	best-code:1.70
	named-reg:1.68
	x-named-regs:1.67
	x:1.67
	v13-00:1.65
	pre_GPL:1.63
	prec_CA:1.60
	noindx:1.58
	Bproc:1.19
	oct21:1.15
	last77:1.9;
locks; strict;
comment	@c @;


1.84
date	2012.05.22.12.01.40;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	2012.03.29.14.14.22;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	2012.03.12.13.33.14;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	2011.12.06.14.26.18;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2010.09.14.19.50.06;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2010.06.29.18.16.46;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2010.06.24.13.26.39;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.25.18.17.13;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2009.11.23.20.22.51;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2009.11.19.21.31.12;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	2009.08.24.14.45.32;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	2009.06.26.13.59.27;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.14.16.17.02;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.25.13.21.46;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	2006.01.06.15.30.32;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2005.12.14.17.18.58;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2005.12.12.15.29.18;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2005.11.16.15.43.47;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.15.21.51.13;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2005.10.17.20.29.55;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2005.10.17.18.21.08;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2005.06.03.18.34.43;	author cyang;	state Exp;
branches;
next	1.62;

1.62
date	2004.02.18.17.57.53;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2003.11.24.17.25.11;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2003.09.04.13.23.55;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2003.01.28.21.10.39;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2002.10.11.19.12.48;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2002.10.01.14.35.26;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2002.09.30.20.20.07;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2002.09.30.17.24.32;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2002.09.30.15.35.59;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2002.09.13.13.22.20;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.02.14.20.33;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.02.18.21.36;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.28.16.22.37;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.26.19.41.34;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.03.17.10.14;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.29.19.54.23;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.07.15.59.47;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.06.13.01.26;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.18.15.58.41;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.15.19.09.23;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.14.16.50.59;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.05.13.57.59;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.05.12.35.43;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.28.17.41.54;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.18.18.15.11;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2001.04.18.15.37.42;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.10.14.48.35;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.09.14.24.50;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.05.15.47.15;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.22.19.33.35;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.19.18.03.51;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.27.17.17.53;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2001.01.23.15.44.28;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2001.01.05.20.49.09;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.04.19.04.11;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.04.17.43.39;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.04.14.56.04;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.28.20.10.09;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.12.20.14.19;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.12.19.37.05;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.12.18.29.12;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.19.19.45.11;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.18.18.39.15;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.12.18.45.38;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.03.17.04.53;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	99.11.04.17.16.11;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	99.11.04.15.45.50;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	99.10.19.19.41.10;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	99.10.19.19.29.48;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	99.10.19.18.35.44;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	99.09.17.12.46.08;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	99.08.17.14.37.59;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	99.06.17.19.11.40;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	99.02.05.16.26.25;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	98.03.05.15.35.17;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	98.01.27.17.00.48;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	97.10.09.16.19.55;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	97.10.08.16.15.41;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	97.10.02.13.59.24;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	97.03.10.15.47.06;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	97.01.14.20.47.18;	author mladjadj;	state Exp;
branches;
next	1.1;

1.1
date	97.01.06.18.37.14;	author leith;	state Exp;
branches;
next	;


desc
@replaces readch
@


1.84
log
@WRITE PROMPT(1:IDOL),': ',ANS(1:NCHAR)
@
text
@
C++*********************************************************************
C
C  RDPR.F -- CREATED 2/8/90 ARDEAN LEITH 
C	  -- ADD ON-LINE HELP                3/29/93 MAHIEDDINE LADJADJ  
C         -- CONVERTED FROM READCH                  DEC 96 ARDEAN LEITH
C         -- F90 CHANGES                            OCT 97 ARDEAN LEITH
C         -- STRIPS COMMENT                         AUG 99 ARDEAN LEITH
C         -- LUNDONOW ADDED                         OCT 99 ARDEAN LEITH
C         -- TRAILING BLANKS IN COMMENT REMOVED     NOV 99 ARDEAN LEITH
C         -- PUT IN <1> VARIABLE HANDLING           SEP 00 ARDEAN LEITH
C         -- MULTIPLE VARIABLE SUBSTITUTION         JAN 01 ARDEAN LEITH
C         -- USED PROC_GETLINE                      JAN 01 ARDEAN LEITH
C         -- FLAG FOR ; OK                          MAR 01 ARDEAN LEITH
C         -- ADDED FILNAMSUB                        APR 01 ARDEAN LEITH
C         -- ADDED VERBOSE FOR ;                    APR 01 ARDEAN LEITH
C         -- DELAYED PROMPT FOR .NOT. VERBOSE       JUN 01 ARDEAN LEITH
C         -- MOVED SSUPCASE LATER                   SEP 01 ARDEAN LEITH
C         -- NO PROMPT FOR .OP COMMENT LINES        MAR 02 ARDEAN LEITH
C         -- SYMPAR REWRITTEN                       JUN 02 ARDEAN LEITH
C         -- NO SYMPAR FOR 'RR'                     AUG 02 ARDEAN LEITH
C         -- '[]' --> '<>'                          SEP 02 ARDEAN LEITH
C         -- PARAMETERS CHANGED                     APR 05 ARDEAN LEITH
C         -- [] DEFAULT FOR VARIABLES               OCT 05 ARDEAN LEITH
C         -- NDOLINE                                MAY 07 ARDEAN LEITH
C         -- ?prompt?[  FR BUG                      JUN 07 ARDEAN LEITH
C         -- REMOVED IMCx33 OBSOLETE SYNTAX         JUN 09 ARDEAN LEITH
C	  -- REMOVED ON-LINE HELP                   AUG 09 ARDEAN LEITH  
C         -- $DATEXT x11 BUG                        AUG 09 ARDEAN LEITH
C         -- '@@@@' SUPPORT                           NOV 09 ARDEAN LEITH
C         -- NDOLINE                                NOV 09 ARDEAN LEITH
C         -- VMS COMMAND DOES NOT <> --> []         SEP 10 ARDEAN LEITH
C         -- ! COMMENT DELIMITER                    DEC 11 ARDEAN LEITH
C         -- RECURSIVE FILNAMSUB                    MAR 12 ARDEAN LEITH
C         -- IRTFLG 654321                          MAR 12 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  RDPR(PROMPT,NCHAR,ANS,UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI,IRTFLG)
C
C  PURPOSE: OUTPUTS PROMPT
C           READS AN ALPHANUMERIC STRING FROM STORED PROC. LINE, TERMINAL,
C              OR PROMPT.
C           ECHO & SKIP LINES WHICH ONLY CONTAIN A COMMENT AT START OF LINE
C           HANDLES INTERACTIVE HELP
C           CAN ECHO LINE TO CURRENT INTERACTIVE DO-LOOP IFLE.
C           CONVERTS OLD @@B01[X11] PROC. ARG. FORMAT TO TO NEW: () ARG.  
C           CONVERTS OLD <> VARIABLE FORMAT TO NEW [] VARIABLE FORMAT
C           CAN INVOKE VARIABLE SUBSTITUTION FOR [string]. 
C           CAN CONVERT TO UPPERCASE
C           CONVERTS OLD X REGISTER TO  [] VARIABLE FORMAT
C           SUBSTITUTES FOR {***[]} AND ${ENV} STRINGS
C               
C           RETURNS NCHAR=LENGTH OF STRING WITHOUT TRAILING BLANKS OR COMMENT. 
C           COMMENT IS LIMITED TO 80 CHAR.
C           VARIABLE VALUE RESPONSE IS LIMITED TO 160 CHAR.
C             
C           REGISTER SUBSTITUTION OCCURS IN RDPRINC
C            
C  PARAMETERS:  PROMPT    INPUT PROMPT                     (SENT)
C               NCHAR     LAST NON_BLANK CHAR IN           (RETURNED)
C                            ANS RESPONSE BEFORE COMMENT
C               ANS       USER RESPONSE                    (RETURNED)
C               GETANS    READ ANSWER (NOT PROMPT)         (SENT)
C               UPPER     CONVERT TO UPPERCASE             (SENT)
C               WANTSUB   WANT SYM. PARAMETER SUBSTITUTION (SENT)
C                             HERE NOW (USUAL)
C               SAYPRMT   ECHO PROMPT TO OUTPUT            (SENT)
C               SAYANS    ECHO RAW ANSWER TO OUTPUT        (SENT)
C               ENDATSEMI IGNORE SEMICOLON COMMENT         (SENT) 
C                            (FOR vms.f)
C               IRTFLG    RETURN FLAG (0 IS NORMAL)        (RETURNED)
C
C  CALLED BY:   RDPRMC -> RDPR -> SUBSYMPAR &  SSUPCAS & FILNAMSUB
C
C               RDPRM2 -> RDPRINC -> RDPRA -> RDPR -> SUBSYMPAR & 
C                                                     SSUPCAS & 
C                                                     FILNAMSUB
C                               ---> EXPRESS3Q
C                               ---> CHKSTR
C
C               SPIDER -> RDPRMC
C
C               FILERD --> RDPR & FILNAMSUB
C               INQUIREREG
C               VMS,VMS_CD
C               SYMPAR, UTIL4
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE RDPR(PROMPT,NCHAR,ANS,
     &       GETANS,UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI,STRIP,IRTFLG)

      INCLUDE 'CMBLOCK.INC'

      COMMON /LUNDOECHO/ LUNDONOW,NDOLINE

      CHARACTER(LEN=*)   :: PROMPT, ANS
      CHARACTER(LEN=1600):: ANS_CYCLE
      CHARACTER(LEN=80)  :: COMMENTSTR
      CHARACTER(LEN=1 )  :: CTEMP
      LOGICAL            :: LDUM
      LOGICAL            :: GETANS,UPPER,WANTSUB,SAYPRMT,SAYANS
      LOGICAL            :: ENDATSEMI,STRIP,LEGACYREGS,ACCEPTCR 

      CALL SET_MPI(ICOMM,MYPID,MPIERR)

      LEGACYREGS = (IRTFLG .NE. -999)  ! DO NOT CONVERT x**
      ACCEPTCR   = (IRTFLG == 654321)  ! ACCEPT <CR> FOR RDPRI & M
  
      IDOL = INDEX(PROMPT,'$') - 1
      IF (IDOL .LE. 0) IDOL = LEN(PROMPT)

      IRTFLG = 0

10    CONTINUE
C     PROMPT OUTPUT IS DELAYED IN BATCH TO IGNORE COMMENT / BLANK LINES
      IF (SAYPRMT .AND. COPT == 'I' .AND. MYPID <= 0) THEN
         WRITE(NOUT,90,ADVANCE='NO') PROMPT(1:IDOL)
 90      FORMAT(' .',A,': ')
      ENDIF

      IF (GETANS) THEN
C        READ ANSWER STRING

         IF (NIN == 1) THEN
C           UPDATE THE BATCH COUNTER FOR CURRENT PROCEDURE LINE
            IBCNT = IBCNT + 1

C           READ FROM CURRENT STORED PROCEDURE LINE IBCNT
            CALL PROC_GETPLINE(IBCNT,0,ANS,NCHAR,IRTFLG)
            IF (IRTFLG .NE. 0) THEN
               CALL ERRT(101,'PROCEDURE LACKS: RE',NE)
               ANS    = 'RE'
               NCHAR  = 2
               RETURN
            ENDIF

         ELSE
C           UPDATE THE BATCH COUNTER FOR CURRENT PROCEDURE LINE
            IBCNT = IBCNT + 1

C           READ FROM TERMINAL
            READ(NIN,FMT='(A)',IOSTAT=IERR) ANS
            IF (IERR .NE. 0) THEN
               CALL ERRT(101,'RAN OUT OF INPUT',NE)
               ANS    = 'EN'
               NCHAR  = 2
               RETURN
            ENDIF
            NCHAR = lnblnk(ANS)
 
         ENDIF
      ELSE
C        READ FROM PROMPT INSTEAD OF FROM INPUT
         ANS   = PROMPT
         NCHAR = IDOL
      ENDIF
      IF (NCHAR <= 0) RETURN

C     SEE IF THIS IS A COMMENT ONLY LINE WITH ; IN FIRST POSITION
C     (IF ; IS PROCEEDED BY SPACE MAYBE THE USER INPUT A BLANK??)
      LOCSEMI = SCAN(ANS(1:NCHAR),';!')
      NCHARA  = NCHAR           ! NOTHING BEFORE ; FLAG
      IF (LOCSEMI > 0) NCHARA = lnblnk(ANS(1:LOCSEMI-1))

      !write(6,*) 'rdpr, nchara,locsemi:',nchara,locsemi,acceptcr
      !write(6,*) 'rdpr, ANS(NCHARA:NCHARA):',ANS(NCHARA:NCHARA),':'

      IF (ACCEPTCR .AND. 
     &   (NCHARA == 0 .OR. ANS(NCHARA:NCHARA) == '*') ) THEN

C        ACCEPT <CR> or *  RESPONSE BEFORE COMMENT
         IF (MYPID <= 0 .AND. SAYPRMT .AND. COPT == 'B') THEN
            WRITE(NOUT,95)  PROMPT(1:IDOL),': ',ANS(1:NCHAR)
95          FORMAT('  ',A,A,A)
         ENDIF
         NCHAR  = 0
         IRTFLG = 0
         !write(6,*) 'rdpr, nchar:',nchar,irtflg
         RETURN

      ELSEIF (LOCSEMI == 1 .AND. ENDATSEMI) THEN
C        NOTHING BEFORE COMMENT
         IF (VERBOSE .AND. MYPID <= 0) THEN
C           ECHO COMMENT
            IF (SAYPRMT .AND. COPT == 'B') 
     &          WRITE(NOUT,90,ADVANCE='NO')  PROMPT(1:IDOL)
	    IF (NOUT .NE. 0)  WRITE(NOUT,91) ANS(1:NCHAR)
91          FORMAT(' ',A)
         ENDIF
C        READ ANOTHER INPUT LINE
         GOTO 10 
      ENDIF

      IF (STRIP) THEN
C        REMOVE LEADING AND TRAILING NON-PRINTING CHAR. FROM ANSWER
         I      = 1
         J      = 0
         DO WHILE (I <= NCHAR)
            CTEMP = ANS(I:I)
            IF (CTEMP == ';' .OR. CTEMP == '!') THEN
               COMMENTSTR = ANS(I:)
               EXIT
            ELSEIF (J .GT. 0 .OR. 
     &              (CTEMP >= '!' .AND. CTEMP <= '~')) THEN
               J        = J + 1
               ANS(J:J) = ANS(I:I)
            ENDIF
            I = I + 1
         ENDDO
         NCHAR         = lnblnkn(ANS(1:J))
         ANS(NCHAR+1:) = ' '
         NCHARCOM      = lnblnkn(COMMENTSTR)
      ENDIF
                      
      IQUES = INDEX(ANS(:NCHAR),'?')
C     PROMPT OUTPUT IS DELAYED UNTIL HERE IN BATCH TO IGNORE BLANK LINES 
      IF (SAYPRMT .AND. COPT == 'B' .AND. IQUES <= 0) THEN
         IF (MYPID <= 0) THEN
            WRITE(NOUT,94,ADVANCE='NO') PROMPT(1:IDOL)
         ENDIF
94       FORMAT(' .',A,': ')
      ENDIF

C     HANDLE OBSOLETE INTERACTIVE HELP
      IF ( COPT .EQ. 'I'  .AND. 
     &     (IQUES > 0    .OR. 
     &     (INDEX(ANS(:NCHAR),'HELP')     > 0)  .OR.
     &     (INDEX(ANS(:NCHAR),'help')     > 0)) .AND.
     &     (INDEX(ANS(IQUES+1:NCHAR),'>') == 0) .AND.
     &     (INDEX(ANS(IQUES+1:NCHAR),'[') == 0)) THEN
         IF (LOCSEMI <= 0 .OR. LOCSEMI > IQUES) THEN
            WRITE(NOUT,*)' USE YOUR WEB BROWSER FOR SPIDER MANUAL PAGES'
C           READ ANOTHER INPUT LINE
            GOTO 10
         ENDIF            
      ENDIF

      IF (LUNDONOW > 0 .AND. MYPID <= 0) THEN
C        MUST COPY INPUT LINE TO CURRENT INTERACTIVE DO-LOOP FILE
         WRITE(LUNDONOW,*) ANS(1:NCHAR)
         NDOLINE = NDOLINE + 1
         !write(6,*) ' rdpr lundo: ',ANS(1:NCHAR),':',NDOLINE !!!!
      ELSEIF ((COPT == 'I' .AND. NDOLINE > 0)) THEN
         NDOLINE = NDOLINE + 1
         !write(6,*) ' rdpr ndoline: ',ANS(:NCHAR),':',NDOLINE !!!!
      ENDIF

C     CHECK IF JUST BLANKS BEFOR ; & STRIP OFF ANY TRAILING BLANKS
      IF (LOCSEMI > 0 .AND. ENDATSEMI) THEN 
C        PRESERVE COMMENT FOR LATER USE
         COMMENTSTR = ANS(LOCSEMI:)
         NCHAR      = LNBLNKN(ANS(1:LOCSEMI-1))
      ELSEIF(.NOT. ENDATSEMI) THEN 
         LOCSEMI = 0
      ENDIF

      IF (SAYANS) THEN
C        ECHO ANSWER IN RAW FORMAT
         WRITE(NOUT,*) ' ',ANS(1:NCHAR)
      ENDIF
       
C     CONVERT OLD <> VARIABLE FORMAT TO NEW [] VARIABLE FORMAT
      NLENANG = 1
      DO WHILE (NLENANG > 0 .AND. ENDATSEMI)
         CALL CHARINSIDE(ANS(1:NCHAR),'<','>',.FALSE.,.FALSE.,
     &                   IGOANG,IENDANG,NLENANG)

         IF (NLENANG > 0) THEN      
C           CONVERT OLD <> VARIABLE FORMAT TO NEW [] VARIABLE FORMAT
C           write(6,*) 'CONVERT OLD <> VAR. DELIMIT. TO NEW:',ans 
            ANS(IGOANG:IGOANG)   = '['
            ANS(IENDANG:IENDANG) = ']'      !  MAY BE MORE VARIABLES
         ENDIF
      ENDDO

C     SEE IF '[' AND ']' NEED SYMBOL SUBSTITUTION
      IGOBRAK = INDEX(ANS(1:NCHAR), '[') 
      IF (IGOBRAK > 0 .AND. WANTSUB) THEN
C         '[' AND ']' NEED SYMBOL SUBSTITUTION E.G. [str]
          CALL SUBSYMPAR(ANS(1:NCHAR),ANS,NCHAR,0,IRTFLG)
      ENDIF
         
C     SEE IF NEED TO CONVERT OLD x11 REGISTER FORMAT 
      IX = SCAN(ANS(1:NCHAR),'xX')
c!!!  IF (LEGACYREGS .AND. IX > 0) THEN

      IF (IX .GT. 0 .AND. NCHAR > IX) THEN
C        POSSIBLE Xdd OR Xd IN INPUT
C        CONVERT OLD x11 REGISTER FORMAT TO TO NEW: [name] FORMAT
         !write(6,*) ' calling dexreg:',ans(1:nchar),':'
         CALL DEXREG(ANS,NCHAR)
      ENDIF
 
      IF (WANTSUB) THEN
         IF (NCHAR > 1600) THEN
            CALL ERRT(102,'RESPONSE OVERFLOW',NCHAR)
            RETURN
         ENDIF
         
         DO 
            ISUB   = SCAN(ANS(:NCHAR), '{[*$')
            IF (ISUB <= 0) EXIT             ! NO SUB NEEDED

            ANS_CYCLE   = ANS(1:NCHAR)
            NCHAR_CYCLE = NCHAR

C           SUBSTITUTE FOR: {***[]}   {---[]}    ***[]   ${ENV}  .1[] 
            CALL FILNAMSUB(ANS,NCHAR,0,IRTFLG)
            IF (IRTFLG .NE. 0) RETURN

C           EXIT IF THERE WERE NO SUBSTITUTIONS
            IF (NCHAR       == NCHAR_CYCLE .AND.
     &          ANS(:NCHAR) == ANS_CYCLE(:NCHAR)) EXIT

         ENDDO
      ENDIF
 
      IF (UPPER) THEN
C        CONVERT INPUT STRING TO ALL UPPER CASE 
         CALL SSUPCAS(ANS(1:NCHAR))
      ENDIF

      IF (LOCSEMI .GT. 0) THEN
C        PUT COMMENT STRING BACK AT END OF INPUT STRING
         ANS = ANS(1:NCHAR) // COMMENTSTR  
      ENDIF
      IRTFLG = 0

      END


C      *********************** DEXREG ********************************

       SUBROUTINE DEXREG(CINPUT,NCHAR)

      INCLUDE 'CMBLOCK.INC'

      CHARACTER(LEN=*)   :: CINPUT
      CHARACTER(LEN=161) :: CSUB
      CHARACTER(LEN=1 )  :: CTEMP
      LOGICAL            :: INSUB

C     CONVERT OLD x11 REGISTER FORMAT TO TO NEW: [name] FORMAT
      I     = 1
      J     = 0
      INSUB = .TRUE.
      DO WHILE (I < NCHAR)
         CTEMP = CINPUT(I:I)
         IF (INSUB .AND. (CTEMP == 'X' .OR. CTEMP == 'x')) THEN
C           PROBABLE REGISTER START x or X
            NDIG = VERIFY(CINPUT(I+1:NCHAR),'0123456789')
            IF (NDIG > 0) THEN
               NDIG = NDIG - 1
            ELSE
               NDIG = NCHAR - I
            ENDIF

            IF (NDIG > 0) THEN
               CSUB = '[_' // CINPUT(I+1:I+NDIG) // ']' // CHAR(0)
               CALL SUBCHAR(CSUB(1:NDIG+3),CINPUT,I,I+NDIG,
     &                          NCHAR,IRTFLG)
               I = I + NDIG
            ENDIF 

         ELSEIF (INSUB .AND. CTEMP == '[') THEN
            INSUB = .FALSE.

         ELSEIF (.NOT. INSUB .AND. CTEMP == ']') THEN
            INSUB = .TRUE.

         ENDIF
         I = I + 1
      ENDDO

      END





C      *********************** DECOMMENT ********************************

       SUBROUTINE DECOMMENT(CINPUT,NCHAROUT,LOCSEMI)

C      FINDS LOCATION OF COMMENT AND ANY TRAILING BLANKS BEFORE COMMENT

       CHARACTER *(*) CINPUT

C      IGNORE SEMICOLON DENOTED COMMENT AT END OF CINPUT STRING
       LOCSEMI = SCAN(CINPUT,';!')

       IF (LOCSEMI <= 0) THEN
          NCHAROUT = LNBLNKN(CINPUT)

       ELSEIF (LOCSEMI == 1) THEN
          NCHAROUT = 0

       ELSEIF (LOCSEMI > 1) THEN
C         STRIP COMMENT & TRAILING BLANKS
          NCHAROUT = LNBLNKN(CINPUT(1:LOCSEMI-1))
       ENDIF
       RETURN
       END

@


1.83
log
@ACCEPT <CR> or *  RESPONSE BEFORE COMMENT for irtflg=654321
@
text
@d190 2
a191 2
      IF (ACCEPTCR .AND. (NCHARA == 0 .OR.
     &    ANS(NCHARA:NCHARA) == '*')) THEN
d195 2
a196 2
            WRITE(NOUT,95)  PROMPT(1:IDOL), ANS(1:NCHAR)
95          FORMAT('  ',A,A)
@


1.82
log
@RECURSIVE FILNAMSUB
@
text
@d35 1
d95 3
a97 1
C               RDPRM2 -> RDPRINC -> RDPR -> SUBSYMPAR & SSUPCAS & FILNAMSUB
d124 1
a124 1
      LOGICAL            :: ENDATSEMI,STRIP,LEGACYREGS
d129 1
d184 1
a184 1
      NCHARA  = NCHAR
d186 18
a203 1
      IF (LOCSEMI == 1 .AND. ENDATSEMI) THEN
@


1.81
log
@! COMMENT DELIMITER
@
text
@d34 1
d39 1
a39 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d115 7
a121 6
      CHARACTER(LEN=*)  :: PROMPT, ANS
      CHARACTER(LEN=80) :: COMMENTSTR
      CHARACTER(LEN=1 ) :: CTEMP
      LOGICAL           :: LDUM
      LOGICAL           :: GETANS,UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI
      LOGICAL           :: STRIP,LEGACYREGS
d134 1
a134 1
      IF (SAYPRMT .AND. COPT .EQ. 'I' .AND. MYPID .LE. 0) THEN
d142 1
a142 1
         IF (NIN .EQ. 1) THEN
d175 1
a175 1
      IF (NCHAR .LE. 0) RETURN
d184 1
a184 1
         IF (VERBOSE .AND. MYPID .LE. 0) THEN
d186 1
a186 1
            IF (SAYPRMT .AND. COPT .EQ. 'B') 
d199 1
a199 1
         DO WHILE (I .LE. NCHAR)
d205 1
a205 1
     &              (CTEMP .GE. '!' .AND. CTEMP .LE. '~')) THEN
d211 3
a213 3
         NCHAR    = lnblnkn(ANS(1:J))
           ANS(NCHAR+1:) = ' '
         NCHARCOM = lnblnkn(COMMENTSTR)
d218 2
a219 2
      IF (SAYPRMT .AND. COPT .EQ. 'B' .AND. IQUES .LE. 0) THEN
         IF (MYPID .LE. 0) THEN
d227 6
a232 6
     &     (IQUES .GT. 0    .OR. 
     &     (INDEX(ANS(:NCHAR),'HELP') .GT. 0)    .OR.
     &     (INDEX(ANS(:NCHAR),'help') .GT. 0))   .AND.
     &     (INDEX(ANS(IQUES+1:NCHAR),'>').EQ. 0) .AND.
     &     (INDEX(ANS(IQUES+1:NCHAR),'[').EQ. 0)) THEN
         IF (LOCSEMI .LE. 0 .OR. LOCSEMI .GT. IQUES) THEN
d239 1
a239 1
      IF (LUNDONOW .GT. 0 .AND. MYPID .LE. 0) THEN
d244 1
a244 1
      ELSEIF ((COPT .EQ. 'I' .AND. NDOLINE .GT. 0)) THEN
d250 1
a250 1
      IF (LOCSEMI .GT. 0 .AND. ENDATSEMI) THEN 
d265 1
a265 1
      DO WHILE (NLENANG .GT. 0 .AND. ENDATSEMI)
d269 1
a269 1
         IF (NLENANG .GT. 0) THEN      
d279 1
a279 1
      IF (IGOBRAK .GT. 0 .AND. WANTSUB) THEN
d286 1
a286 1
c!!!  IF (LEGACYREGS .AND. IX .GT. 0) THEN
d288 1
a288 1
      IF (IX .GT. 0 .AND. NCHAR .GT. IX) THEN
d296 12
a307 2
         ISUB = SCAN(ANS(:NCHAR), '{[*$')
         IF (ISUB .GT. 0) THEN
d311 6
a316 1
         ENDIF
d326 1
a326 1
         ANS = ANS(1:NCHAR) // COMMENTSTR 
a329 1
      RETURN
d348 1
a348 1
      DO WHILE (I .LT. NCHAR)
d350 1
a350 1
         IF (INSUB .AND. (CTEMP .EQ. 'X' .OR. CTEMP .EQ. 'x')) THEN
d353 1
a353 1
            IF (NDIG .GT. 0) THEN
d359 1
a359 1
            IF (NDIG .GT. 0) THEN
d366 1
a366 1
         ELSEIF (INSUB .AND. CTEMP .EQ. '[') THEN
d369 1
a369 1
         ELSEIF (.NOT. INSUB .AND. CTEMP .EQ. ']') THEN
@


1.80
log
@VMS COMMAND DOES NOT <> --> []
@
text
@d33 1
d38 1
a38 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d177 1
a177 1
      LOCSEMI = INDEX(ANS(1:NCHAR),';')
d179 2
a180 2
      IF (LOCSEMI .GT. 0) NCHARA = lnblnk(ANS(1:LOCSEMI-1))
      IF (LOCSEMI .EQ. 1 .AND. ENDATSEMI) THEN
d199 1
a199 1
            IF (CTEMP .EQ. ';') THEN
d375 1
a375 1
       LOCSEMI = INDEX(CINPUT,';')
d377 1
a377 1
       IF (LOCSEMI .LE. 0) THEN
d380 1
a380 1
       ELSEIF (LOCSEMI .EQ. 1) THEN
d383 1
a383 1
       ELSEIF (LOCSEMI .GT. 1) THEN
@


1.79
log
@no ansret defined
@
text
@d32 1
d262 1
a262 1
      DO WHILE (NLENANG .GT. 0)
@


1.78
log
@GPL_2010
@
text
@d159 1
a159 1
               ANSRET = 'EN'
@


1.77
log
@NINSAVOF removed ndoline bug fixed
@
text
@d33 4
a36 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.                          *
d47 1
a47 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a48 1
C=*                                                                    *
d50 1
a50 1
C=* along with this program. If not, see <http://www.gnu.org/licenses> *       
@


1.76
log
@@@@@proc
@
text
@d30 2
a31 2
C         -- 'OF' SUPPORT                           NOV 09 ARDEAN LEITH
C
d110 1
a110 1
      COMMON /LUNDOECHO/ LUNDONOW,NDOLINE,NINSAVEOF
d130 1
a130 2
      IF (SAYPRMT .AND. COPT .EQ. 'I' .AND. MYPID .LE. 0 .AND.
     &   NINSAVEOF .EQ. 0) THEN
d151 1
a151 1
         ELSEIF (NINSAVOF .LE. 0) THEN
a164 10
         ELSE
C           READ FROM TERMINAL
            READ(NIN,FMT='(A)',IOSTAT=IERR) ANS
            IF (IERR .NE. 0) THEN
C              END OF INPUT FROM OPERATIONS TEXT FILE
               NIN       = NINSAVEOF
               NINSAVEOF = 0
               GOTO 10
            ENDIF
            NCHAR = lnblnk(ANS)
d239 4
@


1.75
log
@'OF' SUPPORT
@
text
@d137 1
a137 1
C        INPUT THE ANSWER
d139 3
a141 2
C        UPDATE THE BATCH COUNTER FOR CURRENT PROCEDURE LINE
         IBCNT = IBCNT + 1
a142 2
C        READ ANSWER STRING
         IF (NIN .EQ. 1) THEN
d146 1
a146 2
               CALL ERRT(101,
     &             'PROCEDURE RETURNS ABNORMALLY, LACKS: RE',NE)
d151 15
a167 1
            IBCNT     = IBCNT - 1
@


1.74
log
@DATEXT x11 BUG, REMOVED ON-LINE HELP, LEGACYREGS
@
text
@d30 1
d110 1
a110 1
      COMMON /LUNDOECHO/ LUNDONOW,NDOLINE
d130 2
a131 1
      IF (SAYPRMT .AND. COPT .EQ. 'I' .AND. MYPID .LE. 0) THEN
d155 8
a162 2
            READ(NIN,80) ANS
80          FORMAT(A)
@


1.73
log
@x11 in filenames by irtflg
@
text
@d26 5
a30 3
C         ?prompt?[  FR BUG                         JUN 07 ARDEAN LEITH
C         REMOVED IMCx33 OBSOLETE SYNTAX            JUN 09 ARDEAN LEITH

d32 5
a36 5
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d38 1
a38 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d43 1
a43 1
C=* This program is distributed in the hope that it will be useful,    *
d49 1
a49 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d212 3
a214 2
C     HANDLE INTERACTIVE HELP
      IF ( COPT .EQ. 'I'  .AND. (IQUES .GT. 0    .OR. 
a218 1
C        M LADJADJ.  ONLY IN INTERACTIVE MODE, DO WE CALL HELP
d220 3
a222 8
#if defined (SP_NT) || defined (__linux__)
C          COMMAND LINE HELP IS NOT AVAILABLE ON NT OR LINUX VERSION
           WRITE(NOUT,*) ' *** NO COMMAND LINE HELP IN LINUX'
#else
           CALL MHELP(PROMPT,IANS,ANS,NCHAR,LDUM)
#endif
C          READ ANOTHER INPUT LINE
           GOTO 10
d269 7
a275 6
c!!!!      IF (LEGACYREGS .AND. IX .GT. 0) THEN
      IF (IX .GT. 0) THEN
        IF (NCHAR .GT. IX .AND. ISDIGI(ANS(IX+1:IX+1))) THEN
C          CONVERT OLD x11 REGISTER FORMAT TO TO NEW: [name] FORMAT
           CALL DEXREG(ANS,NCHAR)
         ENDIF
d281 1
a281 1
C           SUBSTITUTE FOR: {***[]}   {---[]}    ***[]   ${ENV}   .1[] 
@


1.72
log
@?prompt?[  FR BUG
@
text
@d27 2
a28 1
C
d31 1
a31 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d100 2
a101 3
C               RAWTOSPIDER
C               VMS
C               RDPRINC
d118 1
a118 1
      LOGICAL           :: STRIP
d120 1
a120 7
#ifdef USE_MPI
      INCLUDE 'mpif.h'
      icomm = MPI_COMM_WORLD
      call MPI_COMM_RANK(icomm, MYPID, ierr)
#else
      MYPID = -1
#endif
d122 2
d224 1
a224 2
           WRITE(NOUT,*)
     &            ' *** NO COMMAND LINE HELP IN LINUX OR NT SPIDER'
d276 1
d278 4
a281 2
C        CONVERT OLD x11 REGISTER FORMAT TO TO NEW: [name] FORMAT
         CALL DEXREG(ANS,NCHAR)
d319 18
a336 18
C        CONVERT OLD x11 REGISTER FORMAT TO TO NEW: [name] FORMAT
         I     = 1
         J     = 0
         INSUB = .TRUE.
         DO WHILE (I .LT. NCHAR)
            CTEMP = CINPUT(I:I)
            IF (INSUB .AND. (CTEMP .EQ. 'X' .OR. CTEMP .EQ. 'x')) THEN
C              PROBABLE REGISTER START x or X
               NDIG = VERIFY(CINPUT(I+1:NCHAR),'0123456789')
               IF (NDIG .GT. 0) THEN
                  NDIG = NDIG - 1
               ELSE
                  NDIG = NCHAR - I
               ENDIF

               IF (NDIG .GT. 0) THEN
                  CSUB = '[_' // CINPUT(I+1:I+NDIG) // ']' // CHAR(0)
                  CALL SUBCHAR(CSUB(1:NDIG+3),CINPUT,I,I+NDIG,
d338 2
a339 2
                  I = I + NDIG
               ENDIF 
d341 2
a342 2
            ELSEIF (INSUB .AND. CTEMP .EQ. '[') THEN
               INSUB = .FALSE.
d344 2
a345 2
            ELSEIF (.NOT. INSUB .AND. CTEMP .EQ. ']') THEN
               INSUB = .TRUE.
d347 3
a349 3
            ENDIF
            I = I + 1
         ENDDO
d351 1
a351 1
         END
@


1.71
log
@COMMON /LUNDOECHO/ LUNDONOW,NDOLINE
@
text
@d26 1
d30 1
a30 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d219 5
a223 5
      IF ( COPT .EQ. 'I'  .AND. (IQUES .GT. 0  .OR. 
     &     (INDEX(ANS(:NCHAR),'HELP') .GT. 0) .OR.
     &     (INDEX(ANS(:NCHAR),'help') .GT. 0)) .AND.
     &     (INDEX(ANS(IQUES+1:NCHAR),'>').EQ. 0))
     &   THEN
@


1.70
log
@moved parse_response to sympar.f
@
text
@d25 1
d110 1
a110 1
      COMMON /LUNDOECHO/ LUNDONOW
d240 1
@


1.69
log
@unmatched quote line 226
@
text
@a379 54
C      *********************** PARSE_RESPONSE ********************************

       SUBROUTINE PARSE_RESPONSE(RESPONSE,NCHARR,ENDATSEMI,STRIP,
     &            ANSW,NCHAR,COMMENTSTR,NCHARC,IRTFLG)

C      FINDS LOCATION OF COMMENT AND ANY TRAILING BLANKS BEFORE COMMENT

       CHARACTER(LEN=*) :: RESPONSE,ANSW,COMMENTSTR
       LOGICAL          :: ENDATSEMI,STRIP
       LOGICAL          :: KEEPGO
       CHARACTER(LEN=1) :: CTEMP,CTEMPJ

       NCHAR  = 0
       NCHARC = 0

       DO I = 1,NCHARR
          CTEMP = RESPONSE(I:I)

          IF (CTEMP .EQ. ';' .AND. ENDATSEMI) THEN
             COMMENTSTR = RESPONSE(I:)
             NCHARC     = NCHARR - I + 1
             EXIT

          ELSEIF ((CTEMP .LT. '!' .OR. CTEMP .GT. '~') .AND.
     &             .NOT. STRIP) THEN
C            GOT NON PRINTING CHAR LIKE A BLANK
             NCHAR = NCHAR + 1
             ANSW(NCHAR:NCHAR) = CTEMP   ! DO NOT REPLACE WITH BLANK

          ELSEIF ((CTEMP .GE. '!' .AND. CTEMP .LE. '~')) THEN
C            GOT PRINTING CHAR
             NCHAR             = NCHAR + 1
             ANSW(NCHAR:NCHAR) = CTEMP

          ELSEIF ((CTEMP .LT. '!' .OR. CTEMP .GT. '~') .AND.
     &             NCHAR .GT. 0 .AND. I .LT. NCHARR) THEN
C            GOT NON PRINTING CHAR LIKE A BLANK AFTER A PRINTING CHAR
             KEEPGO = .FALSE.
             DO J = I+1,NCHARR
                CTEMPJ = RESPONSE(J:J)
                IF ((CTEMP .GE. '!' .AND. CTEMP .LE. '~')) THEN
C                  GOT PRINTING CHAR
                   KEEPGO = .TRUE.
                   EXIT
                ENDIF
             ENDDO
             IF (.NOT. KEEPGO) EXIT
             NCHAR             = NCHAR + 1
             ANSW(NCHAR:NCHAR) = CTEMP
           ENDIF
       ENDDO
       IRTFLG = 0
       END
  
@


1.68
log
@native named registers
@
text
@d226 2
a227 1
           WRITE(NOUT,*)' *** NO COMMAND LINE HELP IN LINUX OR NT SPIDER'
@


1.67
log
@over 72 col
@
text
@d52 1
a52 1
C  RDPR(PROMPT,NCHAR,ANS,UPPER,WANTSUBT,SAYPRMT,SAYANS,ENDATSEMI,IRTFLG)
d62 4
a65 3
C           INVOKES VARIABLE SUBSTITUTION FOR [string]. (REG. NOW X NOTATION)
C           CONVERTS TO UPPERCASE
C           SUBSTITUTES FOR {***X11} AND ${ENV} STRINGS
d71 2
a72 1
C           REGISTER SUBSTITUTION OCCURS IN RDPRINC or            
d79 1
a79 1
C               WANTSUBT  WANT SYM. PARAMETER SUBSTITUTION (SENT)
d87 13
a99 1
C  CALLED BY:   MOST SPIDER INPUT ROUTINES
d105 1
a105 1
     &          GETANS,UPPER,WANTSUBT,SAYPRMT,SAYANS,ENDATSEMI, IRTFLG)
d112 3
a114 2
      CHARACTER(LEN=80) :: COMMENTSTR,SYMPARVAL
      LOGICAL           :: LDUM,ISDIGI,ALLBLANK
d116 1
a116 1
      LOGICAL           :: WANTSUBT
d139 2
d162 1
a162 1
C        READ FROM PROMPT
d173 7
a179 11
      IF ((PROMPT(1:IDOL) .EQ. 'OPERATION' .AND. NCHARA .EQ. 0) .OR.
     &    (LOCSEMI .EQ. 1 .AND. ENDATSEMI)) THEN
C        NOTHING BEFORE COMMENT, SO SKIP THIS WHOLE LINE.
C        ECHO COMMENT (IF DESIRED) AND READ ANOTHER INPUT LINE
         IF (VERBOSE) THEN
C           PROMPT OUTPUT WAS DELAYED IN BATCH TO IGNORE COMMENT
            IF (MYPID .LE. 0) THEN
               IF (SAYPRMT .AND. COPT .EQ. 'B') 
     &             WRITE(NOUT,90,ADVANCE='NO')  PROMPT(1:IDOL)
	       IF (NOUT .NE. 0)  WRITE(NOUT,91) ANS(1:NCHAR)
            ENDIF
d186 21
d208 2
a209 11
C     PROMPT OUTPUT IS DELAYED UNTIL HERE IN BATCH TO IGNORE COMMENT 
C     IF NOT VERBOSE (OTHERWISE IS DONE UP ABOVE)

      IF (FCHAR(:4) .EQ. 'IQ P' .AND. COPT .EQ. 'B') THEN
C        WANT TO ECHO UNSUBSTITUTED PARAMETER AS PROMPT
         IF (MYPID .LE. 0) THEN
            WRITE(NOUT,93,ADVANCE='NO') PROMPT(1:IDOL),ANS(1:NCHARA)
         ENDIF
93       FORMAT(' .',A,': ',A)

      ELSEIF (SAYPRMT .AND. COPT .EQ. 'B' .AND. IQUES .LE. 0) THEN
d217 1
a217 2
      IF ( COPT .EQ. 'I'  .AND. 
     &     (IQUES .GT. 0  .OR. 
d226 1
a226 2
           WRITE(NOUT,*)
     &            ' *** NO COMMAND LINE HELP IN LINUX OR NT SPIDER'
a244 1

a253 15
C     CONVERT OLD @@b01[x11] PROC. ARG. FORMAT TO TO NEW: () ARG.  FORMAT
      CALL CHARINSIDE(ANS(1:NCHAR),'[',']',.FALSE.,.FALSE.,
     &                IGOBRAK,IENDBRAK,NLENBRAK)

      IPAT   = INDEX(ANS(1:NCHAR), '@@') 

      IF (IPAT .GT. 0 .AND. IGOBRAK .GT. IPAT .AND. 
     &    (ANS(IGOBRAK+1:IGOBRAK+1) .EQ. 'x' .OR.
     &     ANS(IGOBRAK+1:IGOBRAK+1) .EQ. 'X')) THEN
C        CONVERT OLD @@b01[x11] PROC. ARG. FORMAT TO TO NEW: () ARG.  FORMAT
         ANS(IGOBRAK:IGOBRAK)   = '(' 
         ANS(IENDBRAK:IENDBRAK) = ')'
         NLENBRAK               = 0 
      ENDIF

d255 10
a264 28
20    CALL CHARINSIDE(ANS(1:NCHAR),'<','>',.FALSE.,.FALSE.,
     &                IGOANG,IENDANG,NLENANG)

      IF (NLENANG .GT. 0) THEN      
C        CONVERT OLD <> VARIABLE FORMAT TO NEW [] VARIABLE FORMAT
C        write(6,*) 'CONVERT OLD <> VAR. DELIMIT. TO NEW:',ans 
         ANS(IGOANG:IGOANG)   = '['
         ANS(IENDANG:IENDANG) = ']'
         NLENBRAK             = NLENANG
         GO TO 20           ! THERE MAY BE MORE VARIABLES
      ENDIF

      WANTSUB = WANTSUBT
 
      IF (IQUES .GT. 0 .AND. FCHAR(1:4) .NE. 'FR L' .AND.
     &    FCHAR(1:4) .NE. 'FR G' .AND. FCHAR(1:4) .NE. 'FR F' ) THEN
C        SEE IF ALL BLANK BEFORE ? (START OF VARIABLE)
         ALLBLANK = .TRUE.
         DO I = 1,IQUES-1
            IF (ANS(I:I) .GT. CHAR(32)) THEN
               ALLBLANK = .FALSE.
               EXIT
            ENDIF
         ENDDO
         IF (ALLBLANK) THEN
C           MAY HAVE TO SET A VARIABLE
            CALL FRSYMPAR(ANS(1:NCHAR),SYMPARVAL,NCHAR,IRTFLG)
            ANS = SYMPARVAL(1:NCHAR)
d266 1
d268 4
a271 5
      ELSEIF (NLENBRAK .GT. 0 .AND. WANTSUB) THEN
C         '[' AND ']' NEED REGISTER OR SYMBOL SUBSTITUTION E.G. [str]
C         IF CALLER ALSO HAD [] THEN THIS WAS ALREADY SUBSTITUTED AT
C         HIGHER LEVEL PROCEDURE. RETURNS NEW NCHAR (WITHOUT COMMENT)

a272 4

      ELSEIF (UPPER) THEN
C         CONVERT INPUT STRING TO ALL UPPER CASE 
          CALL SSUPCAS(ANS(1:NCHAR))
d274 8
a281 1

d283 4
a286 7
C        OPERATION: 'FR ?' DELAYS SUBSTITUTION UNTIL STRING IS USED!

C        SUBSTITUTE FOR {***X11} and ${ENV} STRINGS NOW
         ILEFCURL = INDEX(ANS(:NCHAR),'{')
         IF (ILEFCURL .GT. 0) THEN
C           SUBSTITUTE FOR {***X??) OR {---X??} IN NEWSTR
            CALL FILNAMSUB(ANS,NCHAR,.FALSE.,IDUM,IRTFLG)
d290 5
d297 1
d306 1
d308 1
d310 1
a310 24
C++*********************************************************************
C
C  FRSYMPAR.F -- CREATED 6/8/02 ARDEAN LEITH 
C
C **********************************************************************
C
C FRSYMPAR(PROMPTNID,SYMPARVAL,NCHAR,IRTFLG)
C
C PURPOSE: 
C     MEANT TO BE USED INSIDE A PROCEDURE!
C     TAKES IN PROMPT & PARAMETER LABEL, THEN QUERIES CALLING
C     PROCEDURE OR TERMINAL FOR ASSOCIATED VALUE USING THIS PROMPT. 
C     ASSOCIATED VALUE IS USED A LOCAL PARAMETER.
C             
C PARAMETERS:     PROMPTNID    PROMPT AND ID                      SENT
C                 SYMPAROUT    VARIABLE PARAMETER VALUE        RETURNED
C                 NCHARV       LENGTH OF SYMPARVAL             RETURNED
C                 IRTFLG       ERROR FLAG (0 IS NORMAL)        RETURNED
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE FRSYMPAR(PROMPTNID,SYMPAROUT,NCHARV,IRTFLG)
d312 26
a337 19
      INCLUDE 'CMBLOCK.INC' 
      INCLUDE 'CMLIMIT.INC' 
 
      CHARACTER (LEN=*) ::         SYMPAROUT,PROMPTNID
      CHARACTER (LEN=2*MAXNAM) ::  SYMPARID,PROMPT,SYMPARIN
      CHARACTER (LEN=1) ::         NULL,CDUM
      LOGICAL   ::                 CALLERRT

C     FOR VARIABLE  HANDLING 
      INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK,IPARNUM
      COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM
#ifdef USE_MPI
      include 'mpif.h'
      icomm = MPI_COMM_WORLD
      call MPI_COMM_RANK(icomm, mypid, ierr)
#else
      MYPID = -1
#endif
d339 2
a340 1
      NULL = CHAR(0)
d342 2
a343 16
C     EXTRACT PROMPT & ID  FROM PROMPTNID INPUT STRING
      CALLERRT = (FCHAR(1:2) .NE. 'RR')
      CALL PARSESYMPAR(PROMPTNID,NULL,PROMPT,NCHARP,
     &                 SYMPARID,NCHARI,CDUM,NDUM,CALLERRT,IRTFLG)
      IF (PROMPT .EQ. NULL) RETURN

      IF (SYMPARID .EQ. NULL .AND. CALLERRT) THEN
C        MUST CREATE A NUMERICAL LABEL
         INUM           = IPARNUM(ISTOP) + 1
         IPARNUM(ISTOP) = INUM
         SYMPARID(1:1)  = '<'
         CALL INTTOCHAR(INUM,SYMPARID(2:),NCHARI,1)
         SYMPARID(NCHARI+2:NCHARI+2) = '>'
         NCHARI  = NCHARI + 2
c        write(6,*)'symparid(1:',nchari,'): ',symparid
      ENDIF
d345 3
a347 34
C     INPUT ASSOCIATED VALUE FOR THIS VARIABLE  

      IF (FROMBATCH) THEN
C        FROM BATCH TO BATCH MODE

C        WRITE TO  RESULTS FILE
         IF (MYPID .LE. 0) THEN
            WRITE(NOUT,*) ' ',PROMPTNID
         ENDIF 

      ELSEIF ((FCHAR(1:2) .EQ. 'FR') .AND. (COPT .EQ. 'I')) THEN
C        'FR' IN INTERACTIVE MODE

C        WRITE  ?---? PROMPT TO TERMINAL
         IF (MYPID .LE. 0) THEN
            WRITE(ITI,990,ADVANCE='NO') PROMPT(1:NCHARP)
         ENDIF
990      FORMAT( ' .',A,': ')

       ELSE
C        'FR OR ?...?' FROM BATCH TO INTERACTIVE MODE

C        WRITE TO RESULTS
         IF (MYPID .LE. 0) THEN
            WRITE(NOUT,*) ' ',PROMPTNID
         ENDIF

C        WRITE  ?---? PROMPT TO TERMINAL 
         IF (MYPID .LE. 0) THEN
            WRITE(ITI,991,ADVANCE='NO') PROMPT(1:NCHARP)
         ENDIF
991      FORMAT( ' .',A,': ')

      ENDIF
d349 1
a349 3
      IF (FROMBATCH) THEN
C        FROM BATCH MODE, NOT FROM INTERACTIVE MODE
C        SO GET SYMPARIN FROM CALLING PROCEDURE FILE
a350 4
C        INCREMENT BATCH LINE POINTER FOR FURTHER READS
         IPSTACK(ISTOP) = IPSTACK(ISTOP) + 1
         CALL PROC_GETPLINE(IPSTACK(ISTOP),IPNUMSTACK(ISTOP-1),SYMPARIN,
     &                         NCHAR,IRTFLG)
a351 34
      ELSE
C        '?...?' FROM BATCH TO INTERACTIVE MODE
C        GET SYMPARIN FROM CALLING TERMINAL
         READ(ITIN,80) SYMPARIN
80       FORMAT(A)
      ENDIF

C     FIND LAST NON-BLANK IN SYMPARIN BEFORE COMMENT
      CALL DECOMMENT(SYMPARIN,NCHAR,LOCSEMI)

20    CALL CHARINSIDE(SYMPARIN(1:NCHAR),'[',']',.FALSE.,.FALSE.,
     &                IGOBRAK,IENDBRAK,NLENBRAK)

      IF (NLENBRAK .GT. 0) THEN      
C        CONVERT  [] VARIABLE DELIMITERS TO QSTRQ <> FORMAT
         SYMPARIN(IGOBRAK:IGOBRAK)   = '<'
         SYMPARIN(IENDBRAK:IENDBRAK) = '>'
C        LOOP TO CHECK FOR FURTHER [] PAIRS
         GO TO 20
      ENDIF

C     SUBSTITUTE FOR VARIABLES & REGISTERS IN HIGHER LEVEL PROCEDURES
      CALL EVALSYMPAR(SYMPARIN(1:NCHAR),SYMPAROUT,NCHARV,IRTFLG)

      IF (CALLERRT) THEN
C        SET VARIABLE AT THIS LEVEL
         CALL SETSYMPAR(SYMPARID(1:NCHARI),SYMPAROUT(1:NCHARV),
     &               .TRUE.,IRTFLG)
      ENDIF
#ifdef USE_MPI
      call MPI_BARRIER(icomm,ierr)
#endif
      RETURN
      END
d379 4
d384 49
@


1.66
log
@named register support
@
text
@d202 2
a203 1
           WRITE(NOUT,*)' *** NO COMMAND LINE HELP IN LINUX OR NT SPIDER'
@


1.65
log
@GPL License fixed
@
text
@d10 3
a12 3
C         -- TRAILING BLANKS IN COMMENTED LINE REMOVED NOV 99 AL
C         -- PUT IN <1> SYMBOLIC PAR. HANDLING      SEP 00 AL
C         -- MULTIPLE SYMBOLIC PAR. SUBSTITUTION    JAN 01 AL
d23 2
a24 1
C         -- NLOG                                   NOV 03 ARDEAN LEITH
d52 1
a52 1
C    RDPR(PROMPT,NCHAR,ANS,UPPER,SAYIT,IRTFLG)
d54 15
a68 10
C    PURPOSE: READ AN ALPHANUMERIC STRING, CAN CONVERT TO UPPERCASE
C             RETURNS NCHAR= LENGTH OF STRING WITHOUT TRAILING BLANKS
C             OR COMMENT. 
C             WILL ECHO & SKIP LINES WHICH ONLY CONTAIN A COMMENT
C             STARTING AT START OF LINE
C             IF INPUT CONTAINS <string>, WILL INVOKE SYMBOLIC PARAMETER
C             SUBSTITUTION.
C             COMMENT IS LIMITED TO 80 CHAR.
C             SYBOLIC PARAMETER RESPONSE IS LIMITED TO 160 CHAR.
C             CAN ECHO LINE TO CURRENT INTERACTIVE DO-LOOP IFLE.
d70 14
a83 10
C    PARAMETERS:  PROMPT    INPUT PROMPT                (SENT)
C                 NCHAR     LAST NON_BLANK CHAR IN      (RETURNED)
C                           RESPONSE BEFORE COMMENT
C                 ANS       USER RESPONSE               (RETURNED)
C                 UPPER     CONVERT TO UPPERCASE        (SENT)
C                 SAYIT     LIST PROMPT OUTPUT          (SENT)
C                 IRTFLG    RETURN FLAG (0 IS NORMAL)   (RETURNED)
C                           (-9 ON INPUT IGNORES ;)
C
C    CALLED BY:   MOST SPIDER INPUT ROUTINES
d85 1
d90 2
a91 1
      SUBROUTINE RDPR(PROMPT,NCHAR,ANS,UPPER,SAYIT,IRTFLG)
d99 4
a102 2
      LOGICAL           :: UPPER,LDUM,SAYIT,ISDIGI,ENDATSEMI,ALLBLANK
      LOGICAL           :: WANTSUB
d104 3
a106 4
      include           'mpif.h'
      integer           mypid, comm, ierr
      comm = MPI_COMM_WORLD
      call MPI_COMM_RANK(comm, mypid, ierr)
d108 1
a108 1
      mypid = -1
a113 2
C     CHECK TO SEE IF SEMICOLON SHOULD BE IGNORED (ONLY IN vms.f)
      ENDATSEMI = (IRTFLG .NE. -9)
a115 3
C     CHECK TO SEE IF DO NOT WANT SYM. PARAMETER SUBSTITUTION NOW
      WANTSUB = (FCHAR(1:2) .NE. 'FR') 

d118 1
a118 1
      IF (SAYIT .AND. COPT .EQ. 'I' .AND. MYPID .LE. 0) THEN
d123 20
a142 12
C     UPDATE THE BATCH COUNTER FOR CURRENT PROCEDURE LINE
      IBCNT = IBCNT + 1

C     READ ANSWER STRING
      IF (NIN .EQ. 1) THEN
C        READ FROM CURRENT STORED PROCEDURE LINE IBCNT
         CALL PROC_GETPLINE(IBCNT,0,ANS,NCHAR,IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(101,'PROCEDURE RETURNS ABNORMALLY, LACKS: RE',NE)
            ANS   = 'RE'
            NCHAR = 2
            RETURN
d145 3
a147 4
C        READ FROM TERMINAL
         READ(NIN,80) ANS
80       FORMAT(A)
         NCHAR = lnblnk(ANS)
d163 1
a163 1
               IF (SAYIT .AND. COPT .EQ. 'B') 
d167 1
a167 1
91          FORMAT(A)
d184 1
a184 1
      ELSEIF (SAYIT .AND. COPT .EQ. 'B' .AND. IQUES .LE. 0) THEN
d202 1
a202 1
           WRITE(NOUT,*)'*** NO COMMAND LINE HELP IN LINUX OR NT SPIDER'
d226 7
a232 3
C     CHECK FOR ARGUMENT TRANSFER USING OLD [] FORMAT. NEW FORMAT IS ()
C     CONVERT NEW [] VARIABLE FORMAT BACK TO OLD <> FORMAT
20    CALL CHARINSIDE(ANS(1:NCHAR),'[',']',.FALSE.,.FALSE.,
d235 1
a235 2
      IF (NLENBRAK .GT. 0) THEN      
         INOT = VERIFY(ANS(IGOBRAK:IENDBRAK),'[ 0123456789,xX]')
d237 20
a256 12
         IF (INOT .EQ. 0 .AND. 
     &      SCAN(ANS(IGOBRAK:IENDBRAK),'Xx') .GT. 0)  THEN
C           MOST LIKELY IS [] ARGUMENT TRANSFER
            ANS(IGOBRAK:IGOBRAK)   = '('
            ANS(IENDBRAK:IENDBRAK) = ')'
         ELSE
C           CONVERT NEW [] VARIABLE DELIMITERS BACK TO OLD <> FORMAT
            ANS(IGOBRAK:IGOBRAK)   = '<'
            ANS(IENDBRAK:IENDBRAK) = '>'

         ENDIF
         GO TO 20
d259 2
a260 5
C     FIND POSSIBLE START OF PARAMETER STRING IN INPUT 
      IP1 = INDEX(ANS(1:NCHAR),'<')
      IP2 = 0
      IF (IP1.GT.0 .AND. IP1.LT.NCHAR) IP2 = INDEX(ANS(IP1+1:NCHAR),'>')
      
d263 1
a263 1
C        SEE IF ALL BLANK BEFORE ? (START OF SYMBOLIC PARAMETER)
d272 1
a272 1
C           MAY HAVE TO SET A SYMBOLIC PARAMETER
d277 3
a279 3
      ELSEIF (IP2 .GT. 0 .AND. WANTSUB) THEN
C         '<' AND CHARS => NEED RUN-TIME SYMBOLIC SUBSTITUTION E.G. <str>
C         IF CALLER ALSO HAD <> THEN THIS WAS ALREADY SUBSTITUTED AT
d290 1
a290 1
C        'FR ?' DELAYS SUBSTITUTION UNTIL STRING IS USED!
d293 2
a294 2
         ILEFBRAK = INDEX(ANS(:NCHAR),'{')
         IF (ILEFBRAK .GT. 0) THEN
a316 24
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C **********************************************************************
d327 1
a327 1
C                 SYMPAROUT    SYMBOLIC PARAMETER VALUE        RETURNED
d344 2
a345 1
C     FOR SYMBOLIC PARAMETER HANDLING 
d350 3
a352 4
      include           'mpif.h'
      integer           mypid, comm, ierr
      comm = MPI_COMM_WORLD
      call MPI_COMM_RANK(comm, mypid, ierr)
d354 1
a354 1
      mypid = -1
d357 1
a357 1
      NULL      = CHAR(0)
d376 1
a376 1
C     INPUT ASSOCIATED VALUE FOR THIS PARAMETER ID 
d383 1
a383 1
            WRITE(NOUT,*) PROMPTNID
d400 1
a400 1
            WRITE(NOUT,*) PROMPTNID
a410 1

a429 1
C     CONVERT NEW [] VARIABLE FORMAT BACK TO OLD <> FORMAT
d434 1
a434 1
C        CONVERT NEW [] VARIABLE DELIMITERS BACK TO OLD <> FORMAT
d441 1
a441 1
C     SUBSTITUTE FOR PARAMETERS & REGISTERS IN HIGHER LEVEL PROCEDURES
d445 1
a445 1
C        SET SYMBOLIC PARAMETER AT THIS LEVEL
d449 3
@


1.64
log
@HRI GPL License used
@
text
@a25 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d29 1
a29 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a48 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
a293 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d297 1
a297 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a316 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.63
log
@removed MPI_BARRIER to reduce comm overhead
@
text
@d27 24
d302 24
@


1.62
log
@; then ?
@
text
@a417 3
#ifdef USE_MPI
      call MPI_BARRIER(comm,ierr)
#endif
@


1.61
log
@NLOG
@
text
@d167 1
a167 1

d169 2
a170 2
C        COMMAND LINE HELP IS NOT AVAILABLE ON NT OR LINUX VERSION
         WRITE(NOUT,*) '*** NO COMMAND LINE HELP IN LINUX OR NT SPIDER'
d172 1
a172 1
         CALL MHELP(PROMPT,IANS,ANS,NCHAR,LDUM)
d174 3
a176 2
C        READ ANOTHER INPUT LINE
         GOTO 10            
@


1.60
log
@mpi
@
text
@d23 1
d77 2
d80 1
d93 1
a93 8
#ifdef USE_MPI
      IF (SAYIT .AND. COPT .EQ. 'I' .and. mypid .eq. 0) THEN
         WRITE(NOUT,90,ADVANCE='NO') PROMPT(1:IDOL)
 90      FORMAT(' .',A,': ')
C90      FORMAT(' .%%%%4',A,': ')
      ENDIF
#else
      IF (SAYIT .AND. COPT .EQ. 'I') THEN
a95 1
C90      FORMAT(' .%%%%4',A,': ')
a96 1
#endif
d130 5
a134 13
#ifdef USE_MPI
            if (mypid .eq. 0) then
            IF (SAYIT .AND. COPT .EQ. 'B') 
     &          WRITE(NOUT,90,ADVANCE='NO')   PROMPT(1:IDOL)
	    IF (NOUT .NE. 0)  WRITE(NOUT,91)  ANS(1:NCHAR)
	    IF (NPROC .NE. 0) WRITE(NPROC,91) ANS(1:NCHAR)
            endif
#else
            IF (SAYIT .AND. COPT .EQ. 'B') 
     &          WRITE(NOUT,90,ADVANCE='NO')   PROMPT(1:IDOL)
	    IF (NOUT .NE. 0)  WRITE(NOUT,91)  ANS(1:NCHAR)
	    IF (NPROC .NE. 0) WRITE(NPROC,91) ANS(1:NCHAR)
#endif
d147 1
a147 2
#ifdef USE_MPI
         if (mypid .eq. 0) then
d149 1
a149 4
         endif
#else
         WRITE(NOUT,93,ADVANCE='NO') PROMPT(1:IDOL),ANS(1:NCHARA)
#endif
d153 1
a153 2
#ifdef USE_MPI
         if (mypid .eq. 0) then
d155 1
a155 4
         endif
#else
         WRITE(NOUT,94,ADVANCE='NO') PROMPT(1:IDOL)
#endif
d178 1
a178 1
      IF (LUNDONOW .GT. 0) THEN
a179 5
#ifdef USE_MPI
         if (mypid .eq. 0) then
            WRITE(LUNDONOW,*) ANS(1:NCHAR)
         endif
#else
a180 1
#endif
d312 1
a312 1
      COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,NLOG,IPSTACK,
d319 2
d348 3
a350 7
#ifdef USE_MPI
         if (mypid .eq. 0) then
         WRITE(NOUT,*) PROMPTNID
         endif 
#else
         WRITE(NOUT,*) PROMPTNID
#endif
d356 1
a356 2
#ifdef USE_MPI
         if (mypid .eq. 0) then
d358 2
a359 5
         endif
#else
         WRITE(ITI,990,ADVANCE='NO') PROMPT(1:NCHARP)
#endif
990      FORMAT( ' .',a,': ')
d365 1
a365 2
#ifdef USE_MPI
         if (mypid .eq. 0) then
d367 1
a367 4
         endif
#else
         WRITE(NOUT,*) PROMPTNID
#endif
d370 1
a370 2
#ifdef USE_MPI
         if (mypid .eq. 0) then
d372 1
a372 4
         endif
#else
         WRITE(ITI,991,ADVANCE='NO') PROMPT(1:NCHARP)
#endif
@


1.59
log
@SP_LINUX --> __linux__
@
text
@d71 6
a76 1

d89 7
d101 1
d135 8
d147 1
d160 5
d166 1
d170 5
d176 1
d201 5
d207 1
a336 1

d341 6
d373 5
d379 1
d385 5
d391 1
d398 5
d404 1
d407 5
d413 1
d458 3
a460 1

@


1.58
log
@[] in sym. par. input
@
text
@d155 1
a155 1
#if defined (SP_NT) || defined (SP_LINUX)
@


1.57
log
@[] bug
@
text
@d369 12
@


1.56
log
@[] <> bug
@
text
@a115 1

d184 2
a185 1
      IF (IGOBRAK .GT. 0) THEN      
d187 3
a189 1
         IF (INOT .EQ. 0) THEN
d197 1
d204 1
@


1.55
log
@[] bug still
@
text
@d181 16
a196 11
      LOCANG = INDEX(ANS(1:NCHAR),'[')
      LOCAT  = INDEX(ANS(1:NCHAR),'@@')
      IF (LOCANG .GT. 0 .AND. 
     &   (LOCAT .EQ. 0 .OR.
     &   (LOCAT  .GT. 1 .OR. LNBLNKN(ANS(1:LOCAT-1)) .GT. 0)))THEN
C        HAS @@ AND DOES NOT HAVE @@PROC[...,  TRANSLATE [] TO <>
         DO I = 1,NCHAR
            IF (ANS(I:I) .EQ. '[') ANS(I:I) = '<'
            IF (ANS(I:I) .EQ. ']') ANS(I:I) = '>'
         ENDDO

a200 1
      IP2 = 0
@


1.54
log
@bug if @@ in [] but not a proc call
@
text
@d184 2
a185 1
     &   (LOCAT  .GT. 1 .OR. LNBLNKN(ANS(1:LOCAT-1)) .GT. 0)) THEN
@


1.53
log
@<> --> []
@
text
@d22 1
a22 1
C         -- '[}' --> '<>'                          SEP 02 ARDEAN LEITH
d181 5
a185 2
C     TRANSLATE [] TO <>
      IF (INDEX(ANS(1:NCHAR),'@@') .EQ. 0) THEN
d190 1
@


1.52
log
@'rr' no longer needs <>
@
text
@d22 1
a140 1
c93      FORMAT(' %%%%%0.',A,': ',A)
a144 1
C94      FORMAT(' %%%%1.',A,': ')
d181 8
a315 1
cc       WRITE(NOUT,*) ' .%%%%1',PROMPTNID
a322 1
c990     FORMAT( ' .%%%%3',a,': ')
a328 1
cc       WRITE(NOUT,*) ' .%%%%6',PROMPTNID
a332 1
cc991    FORMAT( ' .%%%%7',A,': ')
@


1.51
log
@iparnum
@
text
@d21 1
d276 1
d286 1
d288 1
a288 1
     &                 SYMPARID,NCHARI,CDUM,NDUM,.TRUE.,IRTFLG)
d291 1
a291 1
      IF (SYMPARID .EQ. NULL) THEN
d356 3
a358 3

C     SET SYMBOLIC PARAMETER AT THIS LEVEL
      CALL SETSYMPAR(SYMPARID(1:NCHARI),SYMPAROUT(1:NCHARV),
d360 1
@


1.50
log
@sympar
@
text
@d277 1
a277 1
      INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK
d279 1
a279 1
     &                     IPNUMSTACK
d287 11
@


1.49
log
@*** empty log message ***
@
text
@d85 1
d135 1
a135 1
      IF (FCHAR(:4) .EQ. 'IQ P') THEN
d139 1
d142 3
a144 1
         WRITE(NOUT,90,ADVANCE='NO') PROMPT(1:IDOL)
d148 2
a149 2
      IF ((COPT .EQ. 'I') .AND. 
     &    ((IQUES .GT. 0) .OR. 
d184 1
a184 1
      IF (IP1.GT.0 .AND.IP1.LT.NCHAR) IP2 = INDEX(ANS(IP1+1:NCHAR),'>')
d254 1
a254 1
C     TAKES IN A PROMPT & SYM. PARAMATER ID, THEN QUERIES CALLING
d256 1
a256 1
C     ASSOCIATED VALUE IS USED A LOCAL PARAMETER
a266 1
 
d290 28
a317 5
      IF ((.NOT. FROMBATCH) .OR. (ISTOP .EQ. 1)) THEN
C        CAME FROM INTERACTIVE MODE, WRITE OUT ?---? PROMPT TO TERMINAL
         WRITE(ITI,90,ADVANCE='NO')  PROMPT
         WRITE(NOUT,90) PROMPTNID
90       FORMAT(' .',A)
a318 3
C        GET SYMPARIN FROM CALLING TERMINAL
         READ(ITIN,80) SYMPARIN
80       FORMAT(A)
d320 1
a320 1
      ELSE
d324 3
a326 2
         IWHERE = IWHERE + 1
         CALL PROC_GETPLINE(IWHERE,IPNUMSTACK(ISTOP-1),SYMPARIN,
d329 5
a333 3
C        SAVE IWHERE FOR FURTHER READS
         IPSTACK(ISTOP) = IWHERE

a341 6
      IF (FCHAR(1:2) .EQ. 'FR' .AND.
     &   (FROMBATCH .OR. ISTOP .GT. 1)) THEN
C        CAME FROM BATCH MODE, ECHO SYMPAROUT TO RESULTS FILE
         WRITE(NOUT,92) SYMPARIN(1:NCHAR),SYMPAROUT(1:NCHARV)
92       FORMAT(' .',A,': ',A)
      ENDIF
a375 121


C++*********************************************************************
C
C  EVALSYMPAR.F -- CREATED 6/8/02 ARDEAN LEITH 
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C EVALSYMPAR(SYMPARIN,SYMPAROUT,NCHARV,IRTFLG)
C
C PURPOSE: SUBSTITUTE FOR <>,X,I IN SYMPARVAL FROM HIGHER LEVELS
C             
C PARAMETERS:     SYMPARIN     SYMBOLIC PARAMETER VALUE        SENT
C                 SYMPAROUT    SYMBOLIC PARAMETER VALUE        RETURNED
C                 NCHARV       LENGTH OF SYMPAROUT             RETURNED
C                 IRTFLG       ERROR FLAG (0 IS NORMAL)        RETURNED
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE EVALSYMPAR(SYMPARIN,SYMPAROUT,NCHARV,IRTFLG)

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      CHARACTER(LEN=*) ::   SYMPARIN,SYMPAROUT
      CHARACTER(LEN=MAXNAM) ::   SYMPARINT
      LOGICAL  ::           ISDIGI,USEBANKREG
      REAL, DIMENSION(7) :: FREGST(7)

C     FOR SYMBOLIC PARAMETER HANDLING 
      INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK
      COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,NLOG,IPSTACK,
     &                     IPNUMSTACK



      SYMPAROUT = SYMPARIN
      NCHARV    = LEN(SYMPARIN)

C     SYMPARIN MAY CONTAIN PARAMETER SUBSTITUTION FROM HIGHER PROCS.
C     IF SO, SUBSTITUTE THE VALUES FROM THE HIGHER LEVEL PROCS. NOW
      IF (ISTOP .GT. 1) THEN
         SYMPARINT = SYMPARIN

         DO ILEVEL = ISTOP - 1,1,-1
           SYMPARINT = SYMPAROUT

C          SEE IF ANY PARAMETER STRING IN SYMPARIN 
           IF (INDEX(SYMPARINT,'<') .LE. 0) EXIT

C          '<' AND DIGIT => NEED RUN-TIME SYMBOLIC SUBSTITUTION E.G. <1>
           CALL SUBSYMPAR(SYMPARINT,SYMPAROUT,NCHARV,ILEVEL,IRTFLG)
         ENDDO
      ENDIF
    
      NSUB = 0
      IF (SYMPAROUT(:1) .EQ. 'X' .OR. SYMPAROUT(2:2) .EQ. 'X' .OR.
     &    SYMPAROUT(:1) .EQ. 'x' .OR. SYMPAROUT(2:2) .EQ. 'x') THEN
C         ADDED 11/8/79 FOR  QUESTION ANSWERED WITH A REGISTER

         CALL CHKSTR(SYMPAROUT,NCHARV,'RE',IDUM,FREGST,7,INUM,IRTFLG)
         IF (IRTFLG .NE. 0) CALL ERRT(101,'ERROR IN REGISTER SUB.',NE)

C        fix precision error here!!!!!al
         ITEMP = MIN(INUM,6)
         WRITE(SYMPAROUT(1:80),2621) (FREGST(I),I=1,ITEMP)
2621     FORMAT(6(1PG12.5,' '))
         NCHARV            = INUM * 13 + 1
         SYMPAROUT(NCHARV:) = ' '

      ELSE
C        MAY WANT TO SUBSTITUTE. FOR REGS, SEE IF NEW STYLE SUB.

         CALL CHARINSIDE(SYMPAROUT(1:NCHARV),'{','}',.TRUE.,.FALSE., 
     &                     IGOSUB,IENDSUB,NSUB)

C        ADDED 6/02/83 FOR A FILENAME TERMINATING WITH A REG

         IF ((NCHARV .GE. 2 .AND. ISDIGI(SYMPAROUT(NCHARV:NCHARV))).AND. 
     &       (SYMPAROUT(NCHARV-1:NCHARV-1) .EQ. 'X'  .OR. 
     &        SYMPAROUT(NCHARV-1:NCHARV-1) .EQ. 'x')) THEN
C           OLD STYLE X? REG. SUBSTITUTION AT END OF FILE NAME
            SYMPAROUT = SYMPAROUT(1:NCHARV-2) // '000{---' // 
     &                 SYMPAROUT(NCHARV-1:NCHARV) // '}'
            NCHARV  = NCHARV + 8
            NSUB   = 1

         ELSEIF((NCHARV .GE. 3 .AND. 
     &           ISDIGI(SYMPAROUT(NCHARV:NCHARV))).AND.
     &          (SYMPAROUT(NCHARV-2:NCHARV-2) .EQ. 'X'  .OR. 
     &           SYMPAROUT(NCHARV-2:NCHARV-2) .EQ. 'x') .AND.
     &           ISDIGI(SYMPAROUT(NCHARV-1:NCHARV-1))) THEN
C           OLD STYLE X?? REG. SUBSTITUTION AT END OF FILE NAME
            SYMPAROUT = SYMPAROUT(1:NCHARV-3) // '000{---' //
     &                 SYMPAROUT(NCHARV-2:NCHARV) // '}' 
            NCHARV = NCHARV + 8
            NSUB  = 1
         ENDIF
      ENDIF

      IF (NSUB .GT. 0) THEN
C        HAVE EITHER OLD OR NEW STYLE REGISTER SUBSTITUTION

C        PASS THE CURRENT REGISTER (PARAM) SET TO FILNAMSUB
C        SUBSTITUTE FOR {+++X??} OR {---X??} IN SYMPAROUT STRING
C        WILL STOP IN ERRT IN FILNAMSUB IF THERE IS AN ERROR
         CALL FILNAMSUB(SYMPAROUT,NCHARV,.TRUE.,ISTOP,IRTFLG)
      ENDIF

      IRTFLG = 0

      RETURN
      END
@


1.48
log
@fr l binds later now
@
text
@d20 1
d38 1
a38 1
C             IF INPUT CONTAINS <DIGIT>, WILL INVOKE SYMBOLIC PARAMETER
a54 4
C    NOTE:        THIS ROUTINE WAS ADDED BECAUSE THE Q FORMAT DOES NOT
C                 WORK THE SAME IN FORTRAN 77.  BY REPLACING THIS SINGLE 
C                 ROUTINE WITH A FORTRAN 77 COMPATIBLE SUBSTITUTE
C                 Q FORMAT INPUT CAN BE AVOIDED IN SPIDER.
d66 1
a66 2
      CHARACTER(LEN=80) :: COMMENTFUNC
      CHARACTER(LEN=160):: RESPONSE
d68 1
d77 3
d81 5
a85 3
      IF (SAYIT .AND. COPT .EQ. 'I') 
     &    WRITE(NOUT,90,ADVANCE='NO') PROMPT(1:IDOL)
 90   FORMAT(' .',A,': ')
d95 1
a95 2
            CALL ERRT(101,
     &         'YOUR PROCEDURE RETURNS ABNORMALLY, LACKS: RE',IDUM)
d110 3
a112 7
      LOCSEMI  = INDEX(ANS(1:NCHAR),';')

      IF (LOCSEMI .GT. 0 .AND. (PROMPT(1:IDOL) .EQ. 'OPERATION')) THEN
C        SKIPS PROMPT OUTPUT IF JUST A ; LINE
         NCHARA = lnblnk(ANS(1:LOCSEMI-1))
         IF (NCHARA .EQ. 0) LOCSEMI = 1
      ENDIF
d114 2
a115 1
      IF (LOCSEMI .EQ. 1 .AND. ENDATSEMI) THEN
d119 1
a119 1
C           PROMPT OUTPUT IS DELAYED IN BATCH TO IGNORE COMMENT
d130 12
a141 3
C     PROMPT OUTPUT IS DELAYED IN BATCH TO IGNORE COMMENT IF NOT VERBOSE
      IF (SAYIT .AND. COPT .EQ. 'B') 
     &    WRITE(NOUT,90,ADVANCE='NO') PROMPT(1:IDOL)
d143 7
a149 2
      IQUES = INDEX(ANS(:NCHAR),'?')
      IF (COPT .EQ. 'I') THEN
a150 5
         IF (((IQUES   .GT. 0) .OR. 
     &       (INDEX(ANS(:NCHAR),'HELP') .GT. 0) .OR.
     &       (INDEX(ANS(:NCHAR),'help') .GT. 0)) .AND.
     &       (IQUES .GT. 0 .AND. INDEX(ANS(IQUES+1:NCHAR),'>').EQ. 0))
     &       THEN 
d153 2
a154 3
C           COMMAND LINE HELP IS NOT AVAILABLE ON NT OR LINUX VERSION
            WRITE(NOUT,*)
     &            '*** NO COMMAND LINE HELP IN LINUX OR NT SPIDER'
d156 1
a156 1
            CALL MHELP(PROMPT,IANS,ANS,NCHAR,LDUM)
d158 2
a159 3
C           READ ANOTHER INPUT LINE
            GOTO 10            
         ENDIF
d170 2
a171 2
         COMMENTFUNC = ANS(LOCSEMI:)
         NCHAR       = LNBLNKN(ANS(1:LOCSEMI-1))
d179 2
d182 2
a183 1
      IF (IQUES .GT. 0) THEN
d192 4
a195 12
      ENDIF
     
      IF (IQUES .GT. 0 .AND. ALLBLANK) THEN
C        MAY HAVE TO SET SYMBOLIC PARAMETER
         CALL CHARINSIDE(ANS(1:NCHAR),'?','?',.FALSE.,.FALSE., 
     &                   IGO,IEND,NCHARQ)
         IF (IGO .GT. 0) THEN
C           SET SYMBOLIC PARAMETER
            CALL SETSYMPAR(ANS(1:NCHAR),RESPONSE,NLET,IRTFLG)
            IF (IRTFLG .NE. 0) RETURN
            ANS   = RESPONSE(1:NLET)
            NCHAR = NLET
d198 2
a199 2
      ELSEIF (IP1 .GT. 0 .AND. ISDIGI(ANS(IP1+1:IP1+1))) THEN
C         '<' AND DIGIT => NEED RUN-TIME SYMBOLIC SUBSTITUTION E.G. <1>
d202 1
d204 4
a207 3
      ELSE
C         CONVERT INPUT STRING TO ALL UPPER CASE IF DESIRED
          IF (UPPER) CALL SSUPCAS(ANS(1:NCHAR))
d210 1
a210 1
      IF (FCHAR(1:2) .NE. 'FR' ) THEN
d223 248
a470 1
         ANS = ANS(1:NCHAR) // COMMENTFUNC 
d472 1
@


1.47
log
@no prompt for non-verbose op with only ;
@
text
@d208 2
a209 2
      IF (FCHAR(1:2) .NE. 'FR' .OR. FCHAR(1:4) .NE. 'FR T') THEN
C        'FR' & 'FR T' DELAY SUBSTITUTION UNTIL STRING IS USED!
@


1.46
log
@move ssupcase later for 'rr' and ?....? input sub.
@
text
@d19 1
d23 1
a23 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d111 6
d123 2
a124 2
     &          WRITE(NOUT,90,ADVANCE='NO') PROMPT(1:IDOL)
	    IF (NOUT .NE. 0)  WRITE(NOUT,91) ANS(1:NCHAR)
@


1.45
log
@NECHO --> NOUT
@
text
@d2 1
a2 1
C++*************************************************************************
d5 5
a9 5
C	  -- ADD ON-LINE HELP 3/29/93 MAHIEDDINE LADJADJ  
C         -- CONVERTED FROM READCH DEC 96  ARDEAN LEITH
C         -- F90 CHANGES OCT. 97 ARDEAN LEITH
C         -- STRIPS COMMENT AUG 99 ARDEAN LEITH
C         -- LUNDONOW ADDED OCT 99 ARDEAN LEITH
d11 2
a12 2
C         -- PUT IN <1> SYMBOLIC PARAMETER HANDLING    SEP 00 AL
C         -- MULTIPLE SYMBOLIC PARAMETER SUBSTITUTION  JAN 01 AL
d18 2
a149 3
C     CONVERT INPUT STRING TO ALL UPPER CASE IF DESIRED
      IF (UPPER) CALL SSUPCAS(ANS(1:NCHAR))

d196 3
d200 1
a200 1
      
@


1.44
log
@bug in iques use
@
text
@d115 1
a115 1
	    IF (NECHO .NE. 0) WRITE(NECHO,91) ANS(1:NCHAR)
@


1.43
log
@?....? no longer must have first ? in col 1
@
text
@d172 1
a172 1
         DO I = 1,IGO-1
@


1.42
log
@delays operation prompt if .not. verbose to skip comments or blank
@
text
@d68 1
a68 1
      LOGICAL           :: UPPER,LDUM,SAYIT,ISDIGI,ENDATSEMI
d127 1
a129 1
         IQUES = INDEX(ANS(:NCHAR),'?')
d169 12
a180 1
      IF (ANS(1:1) .EQ. '?') THEN
@


1.41
log
@*** empty log message ***
@
text
@d13 5
a17 5
C         -- USED PROC_GETLINE               JAN 01 ARDEAN LEITH
C         -- FLAG FOR ; OK                   MAR 01 ARDEAN LEITH
C         -- ADDED FILNAMSUB                 APR 01 ARDEAN LEITH
C         -- ADDED VERBOSE FOR ;             APR 01 ARDEAN LEITH
C
d78 2
a79 1
      IF (SAYIT) WRITE(NOUT,90,ADVANCE='NO') PROMPT(1:IDOL)
d112 3
d122 4
@


1.40
log
@comment handling simplified
@
text
@d175 1
a175 1
C         IF CALLER ALSO HAD <> THEN THIS WAS ALREADY SUBSTITUED AT
d177 1
a177 1
          CALL SUBSYMPAR(ANS,NCHAR,0,IRTFLG)
@


1.39
log
@used a instead of a80 for input read
@
text
@d73 1
a73 1
C     CHECK TO SEE IF SEMICOLON SHOULD BE IGNORED
d107 1
a107 1
      IF (LOCSEMI .EQ. 1) THEN
d149 5
a153 2
      IF (LOCSEMI .GT. 1 .AND. ENDATSEMI) THEN 
         NCHAR = LNBLNKN(ANS(1:LOCSEMI-1))
d172 1
d176 2
a177 2
C         HIGHER LEVEL PROCEDURE.
          CALL SUBSYMPAR(ANS,LOCSEMI,NCHAR,0,IRTFLG)
d181 1
a181 1
C        'FR' SHOULD DELAY SUBSTITUTION UNTIL STRING IS USED
d192 3
@


1.38
log
@N_VERBOSE --> VERBOSE
@
text
@a29 1
C             STRIPS OFF COMMENT (ANYTHING AFTER A ;)
d98 1
a98 1
80       FORMAT(A80)
a102 3
C     CONVERT INPUT STRING TO ALL UPPER CASE IF DESIRED
      IF (UPPER) CALL SSUPCAS(ANS(1:NCHAR))

d139 3
@


1.37
log
@NVERBOSE ON ;
@
text
@d16 1
a16 1
C         -- ADDED N_VERBOSE FOR ;           APR 01 ARDEAN LEITH
d114 1
a114 1
         IF (N_VERBOSE .EQ. 1) THEN
@


1.36
log
@delay binding of {...} if 'FR'
@
text
@d13 4
a16 3
C         -- USED PROC_GETLINE  JAN 01 ARDEAN LEITH
C         -- FLAG FOR ; OK      MAR 01 ARDEAN LEITH
C         -- ADDED FILNAMSUB    APR 01 ARDEAN LEITH
d20 1
a20 1
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
d114 5
a118 4
	 IF (NECHO .NE. 0) WRITE(NECHO,91) ANS(1:NCHAR)
	 IF (NPROC .NE. 0) WRITE(NPROC,91) ANS(1:NCHAR)
91       FORMAT(A)

@


1.35
log
@rdpr simplification for symbolic parameters & variable subs.
@
text
@d40 8
a47 8
C    PARAMETERS:    PROMPT    INPUT PROMPT                (SENT)
C                   NCHAR     LAST NON_BLANK CHAR IN      (RETURNED)
C                             RESPONSE BEFORE COMMENT
C                   ANS       USER RESPONSE               (RETURNED)
C                   UPPER     CONVERT TO UPPERCASE        (SENT)
C                   SAYIT     LIST PROMPT OUTPUT          (SENT)
C                   IRTFLG    RETURN FLAG (0 IS NORMAL)   (RETURNED)
C                             (-9 ON INPUT IGNORES ;)
d49 1
a49 1
C    CALLED BY:     MOST SPIDER INPUT ROUTINES
d51 4
a54 4
C    NOTE:          THIS ROUTINE WAS ADDED BECAUSE THE Q FORMAT DOES NOT
C                   WORK THE SAME IN FORTRAN 77.  BY REPLACING THIS SINGLE 
C                   ROUTINE WITH A FORTRAN 77 COMPATIBLE SUBSTITUTE
C                   Q FORMAT INPUT CAN BE AVOIDED IN SPIDER.
d174 3
d178 7
a184 6
C     SUBSTITUTE FOR {***X11} and ${ENV} STRINGS NOW
      ILEFBRAK = INDEX(ANS(:NCHAR),'{')
      IF (ILEFBRAK .GT. 0) THEN
C        SUBSTITUTE FOR {***X??) OR {---X??} IN NEWSTR
         CALL FILNAMSUB(ANS,NCHAR,.FALSE.,IDUM,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
@


1.34
log
@ibm did not like ?'[088q
@
text
@d15 1
d36 2
a37 1
C             INPUT LINE IS LIMITED TO 80 CHAR.
a39 1
C
d67 1
d123 2
a124 1
         IF (((INDEX(ANS(:NCHAR),'?') .GT. 0) .OR. 
d127 2
a128 1
     &       (INDEX(ANS(:NCHAR),'>') .EQ. 0)) THEN 
d157 12
a168 2
      IF (ANS (1:1) .NE. '?' .AND.
     &    (IP1 .GT. 0 .AND. ISDIGI(ANS(IP1+1:IP1+1)))) THEN
d170 2
d173 8
@


1.33
log
@flag to not stop at ;
@
text
@d88 1
a88 1
     &         'YOUR PROCEDURE RETURNS ABNORMALLY, LACKS: RE ??',IDUM)
@


1.32
log
@(INDEX(ANS(:NCHAR),'>') .EQ. 0) on help
@
text
@d14 1
d46 1
d64 3
a66 3
      CHARACTER *(*) PROMPT, ANS
      CHARACTER *80  COMMENTFUNC
      LOGICAL        UPPER,LDUM,SAYIT,ISDIGI
d71 4
d144 5
a148 1
      IF (LOCSEMI .GT. 1) NCHAR = LNBLNKN(ANS(1:LOCSEMI-1))
@


1.31
log
@trap for no: RE added
@
text
@d115 1
a115 1
         IF ((INDEX(ANS(:NCHAR),'?') .GT. 0) .OR. 
d117 3
a119 1
     &       (INDEX(ANS(:NCHAR),'help') .GT. 0)) THEN
@


1.30
log
@incore procedures
@
text
@d80 7
@


1.29
log
@subsympar can do multiple subs now
@
text
@d11 3
a13 2
C         -- PUT IN <1> SYMBOLIC PARAMETER HANDLING SEP 00 AL
C         -- MULTIPLE SYMBOLIC PARAMETER SUBSTITUTION JAN 01 AL
d73 1
a73 5
C     READ ANSWER STRING
      READ(NIN,80) ANS
80    FORMAT(A80)

C     UPDATE THE BATCH COUNTER
d76 10
a85 2
C     FIND LAST NON-BLANK (Q WOULD KEEP TRAILING BLANKS)           
      NCHAR = lnblnk(ANS)
@


1.28
log
@*** empty log message ***
@
text
@d12 1
d15 6
a20 6
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
a100 1

d126 2
a127 2
C     FIND START AND END OF PARAMETER STRING IN INPUT 
      CALL CHARINSIDE(ANS(1:NCHAR),'<','>',.FALSE.,IP1,IP2,NCT)
d132 1
a132 1
          CALL SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,0,IRTFLG)
d136 1
@


1.27
log
@split out subsympar.f
@
text
@d129 1
a129 1
1000  IF (ANS (1:1) .NE. '?' .AND.
a132 2
C         MAYBE THERE IS MORE THAN ONE <> ?
          GOTO 1000
@


1.26
log
@added check for > 1 <>
[A.
@
text
@a140 118
C++*************************************************************************
C
C  SUBSYMPAR.F -- CREATED 9/8/00 FROM SPIDER.F  ARDEAN LEITH 
C
C **********************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 2000 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
C **********************************************************************
C
C    SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,IRTFLG)
C
C    PURPOSE:       RUN-TIME SYMBOLIC SUBSTITUTION
C
C    PARAMETERS:    ANS       INPUT PROMPT                (SENT/RET.)
C                   LOCSEMI   LOC. OF :                   (SENT)
C                   NCHAR     LAST NON_BLANK CHAR IN      (SENT/RET.)
C                             RESPONSE BEFORE COMMENT
C                   IP1       LOC. OF <                   (SENT)
C                   IP2       LOC. OF >                   (SENT)
C                   IRTFLG    RETURN FLAG (0 IS NORMAL)   (RETURNED)
C   
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,ILEVELT,IRTFLG)

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      CHARACTER *(*) ANS
      CHARACTER *80  COMMENTFUNC
      LOGICAL        ISDIGI,ISCHAR

      CHARACTER(LEN=MAXQSTR), DIMENSION((MAXPRC)) :: QSTRQSTK
      INTEGER, DIMENSION (NQSTRSIZ,MAXPRC) :: IGOQSTRSTK,IENDQSTRSTK
      INTEGER, DIMENSION (MAXPRC)          ::  NQSTRNOWSTK
      COMMON /QSTR_STUFF/ ISTOP,IGOQSTRSTK,IENDQSTRSTK,NQSTRNOWSTK,
     &                    QSTRQSTK

      ILEVEL = ILEVELT
      IF (ILEVEL .LE. 0) ILEVEL = ISTOP

C     PRESERVE COMMENT
      IF (LOCSEMI .GT. 0) COMMENTFUNC = ANS(LOCSEMI:)
           
C     FIND PARAMETER NUMBER FOR SUBSTITUTION.
      READ(ANS(IP1+1:IP2-1),8000,IOSTAT=IRTFLG) NQSTR
8000  FORMAT(I12)
      IF (IRTFLG .NE. 0) RETURN

      IF (NQSTR .GT. NQSTRNOWSTK(ILEVEL) .OR. 
     &    IGOQSTRSTK(NQSTR,ILEVEL).LE. 0) THEN
         WRITE(NDAT,*) '*** NO SYMBOLIC REFERENCE FOR: ',ANS(IP1:IP2)
         CALL ERRT(100,'SPIDER',NE)
C        STOPS IN ERRT!!
         RETURN
      ENDIF

C     HANDLE REGISTER OR INDEX AFTER <?>
      IF (ANS(IP2+1:IP2+1) .EQ. 'X' .OR. 
     &    ANS(IP2+1:IP2+1) .EQ. 'x') THEN
         IEND = VERIFY(ANS(IP2+2:NCHAR),'0123456789')
         IF (IEND .EQ. 0) THEN
C           SYM. PARAMETER & REG. SUBSTITUTION (<?>X? OR <?>X??..) 
            ANS(IP2+1:) = '{---' // ANS(IP2+1:NCHAR) // '}' 
         ENDIF
      ELSEIF (ISCHAR(ANS(NCHAR:NCHAR)) .AND.
     &       (NCHAR-IP2 .EQ. 1 .OR. ISDIGI(ANS(IP2+1:IP2+1)))) THEN 
C        SYM. PARAMETER & LOOP INDEX SUBSTITUTION 
C       (E.G. <?>i OR <?>0I OR <?>0?I OR <?>0*I )
        ANS(IP2+1:) = '{---' // ANS(NCHAR:NCHAR) // '}' 
      ENDIF

C     COPY CORRESPONDING QSTRQ STRING TO ANS
      IGO  = IGOQSTRSTK(NQSTR,ILEVEL)
      IEND = IENDQSTRSTK(NQSTR,ILEVEL)
      CALL SUBCHAR(QSTRQSTK(ILEVEL)(IGO:IEND),ANS,IP1,IP2,NCHAR,IRTFLG)

C     END SYMBOLIC PARAMETER SUBSTITUTION 
      IF (LOCSEMI .GT. 0) THEN
         ANS = ANS(1:NCHAR) // COMMENTFUNC 
      ENDIF

C     SET NORMAL RETURN FLAG
      IRTFLG = 0

      RETURN
      END


C      *********************** SUBCHAR ****************************

       SUBROUTINE SUBCHAR(INSERT,ORIGINAL,LOC1,LOC2,LENUSED,IRTFLG)

       CHARACTER *(*) INSERT, ORIGINAL

       LENI     = LEN(INSERT)
       LENO     = LEN(ORIGINAL)
       LENAFTER = 0
       IF (LOC2 .LT. LENO) LENAFTER = LNBLNKN(ORIGINAL(LOC2+1:))

       LENUSED  = LOC1 - 1 + LENI + LENAFTER

       IF (LENUSED .GT. LENO) THEN
C         OVERFLOW
          CALL ERRT(101,'STRING OVERFLOW',NDUM)
          IRTFLG = 1
          RETURN
       ENDIF
 
       ORIGINAL(LOC1+LENI:) = ORIGINAL(LOC2+1:)
       ORIGINAL(LOC1:LOC1+LENI-1)  = INSERT

       END
@


1.25
log
@comments added
@
text
@d129 1
a129 1
      IF (ANS (1:1) .NE. '?' .AND.
d133 2
@


1.24
log
@corrected procX removal
@
text
@d26 2
a27 1
C             RETURNS NCHAR= LENGTH OF STRING WITHOUT TRAILING BLANKS. 
d30 5
@


1.23
log
@corrected no procX
@
text
@d126 1
a126 1
          CALL SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,IRTFLG)
d146 1
a146 1
C    SUBSYMPAR(ANS,NCHAR,IP1,IP2,IRTFLG)
d152 1
a152 1
C                   NCHAR     LAST NON_BLANK CHAR IN      (SENT)
d161 1
a161 1
      SUBROUTINE SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,IRTFLG)
d170 9
a178 4
      CHARACTER(LEN=MAXQSTR) ::  QSTRQ
      INTEGER, DIMENSION (NQSTRSIZ) :: IGOQSTR,IENDQSTR
      COMMON /QSTR_STUFF/ IGOQSTR,IENDQSTR,NQSTRNOW,QSTRQ
      
d180 1
a180 1
      IF (ILOCSEMI .GT. 0) COMMENTFUNC = ANS(ILOCSEMI:)
d187 2
a188 1
      IF (NQSTR .GT. NQSTRNOW .OR. IGOQSTR(NQSTR).LE. 0) THEN
d200 1
a200 1
C           SYM. PARAMETER & REG. SUBSTITUTION (<??>X? OR <?>X??..) 
d206 1
a206 1
C       (E.G. <??>i OR <??>0I OR <??>0?I OR <??>0*I )
d211 3
a213 3
      IGO  = IGOQSTR(NQSTR)
      IEND = IENDQSTR(NQSTR)
      CALL SUBCHAR(QSTRQ(IGO:IEND),ANS,IP1,IP2,NCHAR,IRTFLG)
d216 1
a216 1
      IF (ILOCSEMI .GT. 0) THEN
d235 2
a236 1
       LENAFTER = LNBLNKN(ORIGINAL(LOC2:))
d238 1
a238 1
       LENUSED  = LOC1 + LENI + LENAFTER -1
@


1.22
log
@no procX file changes
@
text
@d126 1
a126 1
          CALL SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,0,IRTFLG)
d146 1
a146 1
C    SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,IRTFLG)
d152 1
a152 1
C                   NCHAR     LAST NON_BLANK CHAR IN      (SENT/RET.)
d161 1
a161 1
      SUBROUTINE SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,ILEVELT,IRTFLG)
d170 4
a173 9
      CHARACTER(LEN=MAXQSTR), DIMENSION((MAXPRC)) :: QSTRQSTK
      INTEGER, DIMENSION (NQSTRSIZ,MAXPRC) :: IGOQSTRSTK,IENDQSTRSTK
      INTEGER, DIMENSION (MAXPRC)          ::  NQSTRNOWSTK
      COMMON /QSTR_STUFF/ ISTOP,IGOQSTRSTK,IENDQSTRSTK,NQSTRNOWSTK,
     &                    QSTRQSTK

      ILEVEL = ILEVELT
      IF (ILEVEL .LE. 0) ILEVEL = ISTOP

d175 1
a175 1
      IF (LOCSEMI .GT. 0) COMMENTFUNC = ANS(LOCSEMI:)
d182 1
a182 2
      IF (NQSTR .GT. NQSTRNOWSTK(ILEVEL) .OR. 
     &    IGOQSTRSTK(NQSTR,ILEVEL).LE. 0) THEN
d194 1
a194 1
C           SYM. PARAMETER & REG. SUBSTITUTION (<?>X? OR <?>X??..) 
d200 1
a200 1
C       (E.G. <?>i OR <?>0I OR <?>0?I OR <?>0*I )
d205 3
a207 3
      IGO  = IGOQSTRSTK(NQSTR,ILEVEL)
      IEND = IENDQSTRSTK(NQSTR,ILEVEL)
      CALL SUBCHAR(QSTRQSTK(ILEVEL)(IGO:IEND),ANS,IP1,IP2,NCHAR,IRTFLG)
d210 1
a210 1
      IF (LOCSEMI .GT. 0) THEN
d229 1
a229 2
       LENAFTER = 0
       IF (LOC2 .LT. LENO) LENAFTER = LNBLNKN(ORIGINAL(LOC2+1:))
d231 1
a231 1
       LENUSED  = LOC1 - 1 + LENI + LENAFTER
@


1.21
log
@reverted to pre procX version
@
text
@d11 2
a12 1
C 
d55 2
a56 1
      LOGICAL        UPPER,LDUM,SAYIT
d81 1
a81 1
      ISEMI  = INDEX(ANS(1:NCHAR),';')
d83 1
a83 1
      IF (ISEMI .EQ. 1) THEN
d94 1
a94 3
#ifndef SP_LINUX
#ifndef SP_NT
C     COMMAND LINE HELP IS NOT AVAILABLE ON NT OR LINUX VERSION
d100 5
d106 1
a106 1

a110 2
#endif
#endif
d113 2
a114 2
C         MUST COPY INPUT LINE TO CURRENT INTERACTIVE DO-LOOP FILE
          WRITE(LUNDONOW,*) ANS(1:NCHAR)
d118 76
a193 1
      IF (ISEMI .GT. 1) NCHAR = LNBLNKN(ANS(1:ISEMI-1))
d195 25
d225 26
@


1.20
log
@Bproc RR & FR changes
@
text
@d11 1
a11 2
C         -- PUT IN <1> SYMBOLIC PARAMETER HANDLING SEP 00 AL
C
d54 1
a54 2
      CHARACTER *80  COMMENTFUNC
      LOGICAL        UPPER,LDUM,SAYIT,ISDIGI
d79 1
a79 1
      LOCSEMI  = INDEX(ANS(1:NCHAR),';')
d81 1
a81 1
      IF (LOCSEMI .EQ. 1) THEN
d92 3
a94 1

a99 5
#if defined (SP_NT) || defined (SP_LINUX)
C           COMMAND LINE HELP IS NOT AVAILABLE ON NT OR LINUX VERSION
            WRITE(NOUT,*)
     &            '*** NO COMMAND LINE HELP IN LINUX OR NT SPIDER'
#else
d101 1
a101 1
#endif
d106 2
d110 2
a111 2
C        MUST COPY INPUT LINE TO CURRENT INTERACTIVE DO-LOOP FILE
         WRITE(LUNDONOW,*) ANS(1:NCHAR)
d115 1
a115 95
      IF (LOCSEMI .GT. 1) NCHAR = LNBLNKN(ANS(1:LOCSEMI-1))

C     FIND START AND END OF PARAMETER STRING IN INPUT 
      CALL CHARINSIDE(ANS(1:NCHAR),'<','>',.FALSE.,IP1,IP2,NCT)
      
      IF (ANS (1:1) .NE. '?' .AND.
     &    (IP1 .GT. 0 .AND. ISDIGI(ANS(IP1+1:IP1+1)))) THEN
C         '<' AND DIGIT => NEED RUN-TIME SYMBOLIC SUBSTITUTION E.G. <1>
          CALL SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,IRTFLG)
      ENDIF

      IRTFLG = 0
      RETURN
      END

C++*************************************************************************
C
C  SUBSYMPAR.F -- CREATED 9/8/00 FROM SPIDER.F  ARDEAN LEITH 
C
C **********************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 2000 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
C **********************************************************************
C
C    SUBSYMPAR(ANS,NCHAR,IP1,IP2,IRTFLG)
C
C    PURPOSE:       RUN-TIME SYMBOLIC SUBSTITUTION
C
C    PARAMETERS:    ANS       INPUT PROMPT                (SENT/RET.)
C                   LOCSEMI   LOC. OF :                   (SENT)
C                   NCHAR     LAST NON_BLANK CHAR IN      (SENT)
C                             RESPONSE BEFORE COMMENT
C                   IP1       LOC. OF <                   (SENT)
C                   IP2       LOC. OF >                   (SENT)
C                   IRTFLG    RETURN FLAG (0 IS NORMAL)   (RETURNED)
C   
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE SUBSYMPAR(ANS,LOCSEMI,NCHAR,IP1,IP2,IRTFLG)

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      CHARACTER *(*) ANS
      CHARACTER *80  COMMENTFUNC
      LOGICAL        ISDIGI,ISCHAR

      CHARACTER(LEN=MAXQSTR) ::  QSTRQ
      INTEGER, DIMENSION (NQSTRSIZ) :: IGOQSTR,IENDQSTR
      COMMON /QSTR_STUFF/ IGOQSTR,IENDQSTR,NQSTRNOW,QSTRQ
      
C     PRESERVE COMMENT
      IF (ILOCSEMI .GT. 0) COMMENTFUNC = ANS(ILOCSEMI:)
           
C     FIND PARAMETER NUMBER FOR SUBSTITUTION.
      READ(ANS(IP1+1:IP2-1),8000,IOSTAT=IRTFLG) NQSTR
8000  FORMAT(I12)
      IF (IRTFLG .NE. 0) RETURN

      IF (NQSTR .GT. NQSTRNOW .OR. IGOQSTR(NQSTR).LE. 0) THEN
         WRITE(NDAT,*) '*** NO SYMBOLIC REFERENCE FOR: ',ANS(IP1:IP2)
         CALL ERRT(100,'SPIDER',NE)
C        STOPS IN ERRT!!
         RETURN
      ENDIF

C     HANDLE REGISTER OR INDEX AFTER <?>
      IF (ANS(IP2+1:IP2+1) .EQ. 'X' .OR. 
     &    ANS(IP2+1:IP2+1) .EQ. 'x') THEN
         IEND = VERIFY(ANS(IP2+2:NCHAR),'0123456789')
         IF (IEND .EQ. 0) THEN
C           SYM. PARAMETER & REG. SUBSTITUTION (<??>X? OR <?>X??..) 
            ANS(IP2+1:) = '{---' // ANS(IP2+1:NCHAR) // '}' 
         ENDIF
      ELSEIF (ISCHAR(ANS(NCHAR:NCHAR)) .AND.
     &       (NCHAR-IP2 .EQ. 1 .OR. ISDIGI(ANS(IP2+1:IP2+1)))) THEN 
C        SYM. PARAMETER & LOOP INDEX SUBSTITUTION 
C       (E.G. <??>i OR <??>0I OR <??>0?I OR <??>0*I )
        ANS(IP2+1:) = '{---' // ANS(NCHAR:NCHAR) // '}' 
      ENDIF

C     COPY CORRESPONDING QSTRQ STRING TO ANS
      IGO  = IGOQSTR(NQSTR)
      IEND = IENDQSTR(NQSTR)
      CALL SUBCHAR(QSTRQ(IGO:IEND),ANS,IP1,IP2,NCHAR,IRTFLG)

C     END SYMBOLIC PARAMETER SUBSTITUTION 
      IF (ILOCSEMI .GT. 0) THEN
         ANS = ANS(1:NCHAR) // COMMENTFUNC 
      ENDIF
a121 25


C      *********************** SUBCHAR ****************************

       SUBROUTINE SUBCHAR(INSERT,ORIGINAL,LOC1,LOC2,LENUSED,IRTFLG)

       CHARACTER *(*) INSERT, ORIGINAL

       LENI     = LEN(INSERT)
       LENO     = LEN(ORIGINAL)
       LENAFTER = LNBLNKN(ORIGINAL(LOC2:))

       LENUSED  = LOC1 + LENI + LENAFTER -1

       IF (LENUSED .GT. LENO) THEN
C         OVERFLOW
          CALL ERRT(101,'STRING OVERFLOW',NDUM)
          IRTFLG = 1
          RETURN
       ENDIF
 
       ORIGINAL(LOC1+LENI:) = ORIGINAL(LOC2+1:)
       ORIGINAL(LOC1:LOC1+LENI-1)  = INSERT

       END
@


1.19
log
@SP_LINUX
@
text
@d11 2
a12 1
C 
d55 2
a56 1
      LOGICAL        UPPER,LDUM,SAYIT
d81 1
a81 1
      ISEMI  = INDEX(ANS(1:NCHAR),';')
d83 1
a83 1
      IF (ISEMI .EQ. 1) THEN
d94 1
a94 3
#ifndef SP_LINUX
#ifndef SP_NT
C     COMMAND LINE HELP IS NOT AVAILABLE ON NT OR LINUX VERSION
d100 5
d106 1
a106 1

a110 2
#endif
#endif
d113 2
a114 2
C         MUST COPY INPUT LINE TO CURRENT INTERACTIVE DO-LOOP FILE
          WRITE(LUNDONOW,*) ANS(1:NCHAR)
d118 95
a212 1
      IF (ISEMI .GT. 1) NCHAR = LNBLNKN(ANS(1:ISEMI-1))
d219 25
@


1.18
log
@removed mhelp for Linux
@
text
@d94 1
a94 1
C     COMMAND LINE HELP IS NOT AVAILABLE YET ON NT VERSION
@


1.17
log
@blank space input before ; changeed
@
text
@d92 1
d106 1
@


1.16
log
@can strip blanks before comment now
@
text
@d84 2
a85 2
	 IF (NECHO .NE. 0) WRITE(NECHO,91) ANS(1:NCHART)
	 IF (NPROC .NE. 0) WRITE(NPROC,91) ANS(1:NCHART)
@


1.15
log
@bad )
@
text
@d9 2
a10 1
C         -- LUNDONOW ADDED OCT 99 ARDERAN LEITH
d23 5
a27 1
C    PURPOSE: READ AN ALPHANUMERIC STRING, 
d30 2
a31 1
C                   NCHAR     LAST NON_BLANK CHAR IN RESPONSE (RETURNED)
d37 1
a37 1
C    CALLED BY:     MANY SPIDER INPUT ROUTINES
a42 1
C                   WILL SKIP lines WHICH START WITH ; (SPIDER COMMENT)
a43 1
C
a59 1
#ifdef SP_F90
a61 4
#else
      IF (SAYIT) WRITE(NOUT,90) PROMPT(1:IDOL)
 90   FORMAT($,' .',A,': ')
#endif
d79 1
a79 6
      ISEMI = INDEX(ANS(1:NCHAR),';')  
      IF (ISEMI .GT. 1) THEN
C        CHECK IF JUST BLANKS BEFOR ;
         ILEN = LNBLNKN(ANS(1:ISEMI-1))
         IF (ILEN .LE. 0) ISEMI = 1
      ENDIF
d82 1
a82 1
C        NOTHING BEFORE COMMENT, SO SKIP THIS WHOLE LINE,
d84 2
a85 2
	 IF (NECHO .NE. 0) WRITE(NECHO,91) ANS(1:NCHAR)
	 IF (NPROC .NE. 0) WRITE(NPROC,91) ANS(1:NCHAR)
a89 4

      ELSEIF (ISEMI .GT. 1) THEN
C        STRIP OFF COMMENT HERE
         NCHAR = ISEMI - 1         
d108 6
a113 3
C          MUST COPY INPUT LINE TO CURRENT INTERACTIVE DO-LOOP FILE
           WRITE(LUNDONOW,*) ANS(1:NCHAR)
        ENDIF
d117 1
a118 1

@


1.14
log
@lowercase help detected now, also does not clash with ? in comment
@
text
@d108 1
a108 1
     &       (INDEX(ANS(:NCHAR),'help') .GT. 0))
@


1.13
log
@needed lundonow
@
text
@d50 1
a50 1
      LOGICAL        UPPER,IS_HELP,SAYIT
a74 17
#ifndef SP_NT
C     HELP IS NOT AVAILABLE YET ON NT VERSION
      IF (COPT .EQ. 'I') THEN
C        M LADJADJ.  ONLY IN INTERACTIVE MODE, DO WE CALL HELP
         IANS = INDEX(ANS(:NCHAR),'?')

C	 INDEX WILL RETURN >0 IF ANS() CONTAINS 'HELP'
         IND_HELP = INDEX(ANS,'HELP')
         IS_HELP  = IND_HELP .GT. 0
         IF ((IANS .GT. 0) .OR. IS_HELP) THEN
            CALL MHELP(PROMPT,IANS,ANS,NCHAR,IS_HELP)
C           READ ANOTHER INPUT LINE
            GOTO 10            
         ENDIF
      ENDIF
#endif

d96 1
d99 1
a99 1
         NCHAR = ISEMI -1         
d102 15
d118 1
a118 1
C          MUST COPY LINE TO CURRENT INTERACTIVE DO-LOOP FILE
@


1.12
log
@removed check_this_out (breaks compiler on dec parallel)
@
text
@d5 1
d9 2
a10 1
C
a38 1
C	3/29/93	    MAHIEDDINE LADJADJ -- CHANGED TO ADD ON-LINE HELP
d47 2
d117 5
@


1.11
log
@strips comment now
@
text
@d78 4
a81 3
C	 CHECK_THIS_OUT WILL RETURN IS_HELP = .TRUE. IF ANS()='HELP'
         CALL CHECK_THIS_OUT(ANS,NCHAR,'HELP',4,IS_HELP)
         IF ((IANS .GT. 0) .OR. IS_HELP ) THEN
@


1.10
log
@used lundoc
@
text
@d4 4
a7 3
C  RDPR.F -- CREATED 2/8/90 al 
C         -- CONVERTED FROM READCH DEC 96 TO RATIONALIZE COMMENTS al
C         -- F90 CHANGES OCT. 97 al
a45 2
CNO_SAVE

d101 1
a101 1
C        NOTHING BEFORE COMMENT, SO SKIP THIS LINE,
d108 4
a111 1
         GOTO 10         
@


1.9
log
@removed SP_VMS
@
text
@d95 5
@


1.8
log
@; comment handling changed
@
text
@a61 5
#ifdef SP_VMS
C     NON-PORTABLE VAX FORTRAN Q READ
      READ(NIN,80,END=79) NCHAR,ANS
  80  FORMAT(Q,A80)
#else
a64 1
#endif
d111 1
a111 10

#ifdef SP_VMS
C       RETURN OR STOP (IN BATCH)  ON END_OF_FILE
 79     CALL ERRT(17,'RDPR',NE)
        NCHAR  = 0
        IRTFLG = 1
        RETURN
#endif

	END
@


1.7
log
@commented out mhelp call for nt version
@
text
@d98 3
a100 3
C     SEE IF THIS IS A COMMENT ONLY LINE
      ISEMI   = INDEX(ANS(1:NCHAR),';')
      IF (ISEMI .GT. 1) ILNBLNK = lnblnk(ANS(1:ISEMI-1))
d102 2
a103 4
C     SEE IF ONLY ; OR ONLY BLANKS BEFORE SEMICOLON
      IF (ISEMI .EQ. 1 .OR.
     &   (ISEMI .GT. 1 .AND. ILNBLNK .EQ. 0)) THEN

@


1.6
log
@ifdef for f90 added
@
text
@d79 2
d93 1
@


1.5
log
@returned to $ in format for prompt
@
text
@d6 1
d8 8
a15 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1990, WADSWORTH CENTER FOR LABORATORIES AND              *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d53 6
a58 1
 10   IF (SAYIT) WRITE(NOUT,90) PROMPT(1:IDOL)
d60 1
@


1.4
log
@*** empty log message ***
@
text
@d54 1
a54 1
 90   FORMAT(' .',A,': ')
@


1.3
log
@comments changed
@
text
@d54 1
a54 1
 90   FORMAT($,' .',A,': ')
@


1.2
log
@change ISEM to ISEMI
@
text
@d22 1
a22 1
C                   NCHAR     NUMBER OF CHARS IN RESPONSE (RETURNED)
d34 1
@


1.1
log
@Initial revision
@
text
@d90 1
a90 1
      IF (ISEM .GT. 1) ILNBLNK = lnblnk(ANS(1:ISEMI-1))
@
