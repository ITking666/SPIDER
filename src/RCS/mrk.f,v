head	1.30;
access;
symbols
	pre_getangas:1.28
	GPL2010:1.28
	pre_GPL2010:1.27
	pre_var_equation:1.27
	pre_fftwrings:1.25
	pre_opfiles:1.25
	src:1.25
	best-code:1.25
	x-named-regs:1.25
	x:1.25
	v13-00:1.25
	pre_GPL:1.24
	prec_CA:1.23
	noindx:1.21
	Bproc:1.20
	oct21:1.16
	last77:1.16;
locks; strict;
comment	@c @;


1.30
date	2014.02.19.15.18.59;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2014.02.19.13.54.29;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.24.13.26.15;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.02.19.46.53;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2008.12.02.19.44.16;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.17.21.02.08;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.11.14.16.35;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.08.14.44.34;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.07.19.18.48;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.31.12.40.17;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	99.12.30.21.42.51;	author pawel;	state Exp;
branches;
next	1.19;

1.19
date	99.12.14.15.35.25;	author pawel;	state Exp;
branches;
next	1.18;

1.18
date	99.12.14.15.01.39;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	99.12.07.16.13.57;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	99.03.19.19.55.23;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	99.03.19.19.50.28;	author pawel;	state Exp;
branches;
next	1.14;

1.14
date	97.10.24.17.13.18;	author hedget;	state Exp;
branches;
next	1.13;

1.13
date	97.10.10.17.47.59;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	97.09.02.15.05.52;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	96.06.17.13.45.42;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	96.06.12.19.18.40;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	96.06.12.19.16.08;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	96.04.18.14.20.55;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	95.10.10.15.50.06;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	95.10.03.20.04.52;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	94.07.22.20.30.11;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	94.06.02.14.10.55;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	94.05.26.11.25.16;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.07.36;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.50.23;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.30
log
@PROMPTS & DOC FILE HEADERS & lundoc
@
text
@
C ++********************************************************************
C                                                                      
C   MRK
C          PROMPTS & DOC FILE HEADERS IMPROVED   FEB 2014 ARDEAN LEITH
C                                                                      
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2014  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C                                                                     
C   MRK(IDUM)
C
C   WARNING ! PARAMETERS LS AND LV ARE HARD-WIRED IN ALL SUBROUTINES.
C
C   PURPOSE:  MAIN SUBROUTINE FOR MARKER PROGRAM.
C     ATTEMPTS TO ALIGN A DATA SET USING FIDUCIARY MARKERS.
C
C     THE PROCEDURE IS TO FIRST ROUGHLY TRANSLATIONALLY
C     ALIGN THE IMAGES. USING THIS SET, RECONSTRUCT THE
C     COORDS OF THE POINTS IN THE 3D OBJECT. THEN PROJECT
C     THE POINTS BACK DOWN ONTO A PLANE AND COMPARE THEM
C     WITH THE POINTS FROM PREVIOUS TRIAL. CORRECT THE
C     POINTS AND ONCE AGAIN RECONSTRUCT THE 3D, ETC.
C
C     THE CORRECTIONS ACCUMULATE IN A FEW REGISTERS.
C     ALL COMPARISONS EXCEPT FOR THE ROUGH ALIGNMENT ARE
C     BETWEEN THE ORIGINAL PROJECTIONS AND THEIR PSUEDO-
C     PROJECTIONS.
C
C **********************************************************

      SUBROUTINE MRK(IDUM)

      INCLUDE     'CMBLOCK.INC'
      INCLUDE     'CMLIMIT.INC'

      INTEGER, PARAMETER   :: LV=300
      INTEGER, PARAMETER   :: LS=256
      INTEGER, PARAMETER   :: MAXLOOP = 19999
      REAL, PARAMETER      :: MAXPER  = 1.0E-7
      INTEGER, PARAMETER   :: NLIST   = 2 

      CHARACTER(LEN=MAXNAM):: DOCNAM

      DIMENSION         DLIST(NLIST)
      LOGICAL*1         FULL
      CHARACTER*1       ASKFULL,NULL

      LOGICAL           PARAMQ(4)
      LOGICAL           PTACTIVE(LS,LV)
      INTEGER           NUMPTS(LV)
      REAL              CIR(2)

      DIMENSION         XYPTS(2,LS,LV),PRJ(2,LS,LV)
      DIMENSION         ROT(3,3),ANGLE(3,LV),TPSI(LV)
      DIMENSION         P3D(3,LS),SCALE(LV)
      DIMENSION         NUMBER(LV),SCALEI(LV)
      DIMENSION         CVPT(3)
      DIMENSION         SHFT(2),SHIFT(2,LV),TSHIFT(2,LV)
      DIMENSION         ERVW(LV),ERPT(LS)

      LOGICAL           FIRST
      INTEGER           NTIMES
      DOUBLE PRECISION  TCH,ERTOT

      NDOUT = 70

      NTIMES = 0
      NULL   = CHAR(0)

C     GET COORDS OF MARKERS IN EACH PROJECTION

      CALL MRGETINFO(XYPTS,IREF,NUMBER,ANGLE,SCALE,TSHIFT,FIRST,NTTVL,
     &               PARAMQ,PTACTIVE,NUMPTS,NTVW,NTPT,CIR)

      DO  IVIEW=1,NTVW

        TPSI(IVIEW)    = ANGLE(1,IVIEW)
        SHIFT(1,IVIEW) = TSHIFT(1,IVIEW)
        SHIFT(2,IVIEW) = TSHIFT(2,IVIEW)

        CALL MRALIGN(XYPTS(1,1,IVIEW),
     &	      ANGLE(1,IVIEW),SHIFT(1,IVIEW),SCALE(IVIEW),
     &	      PTACTIVE(1,IVIEW),NTPT)
      ENDDO

C     GET 3D VOLUME
      CALL MR2TO3D(P3D, XYPTS, ANGLE,PTACTIVE,NUMPTS,NTVW,NTPT)
      CALL MRPROJ(P3D, PRJ, ANGLE,NTVW,NTPT)
      CALL MRCALERR(XYPTS,PRJ,ERTOT,ERVW,ERPT,PTACTIVE,NUMPTS,NTVW,NTPT)

      WRITE(NOUT,*) ' INITIAL INFO:'

      FULL = .FALSE.
      CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
     &     NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL,PTACTIVE,NTVW,NTPT,CIR)

      TCH = ERTOT
      WRITE(NOUT,701) NTIMES,ERTOT
 701  FORMAT('  PASS #',I5,' TOTCHANGE: ',10('-'),' ERTOT:',G11.4,/)

C     CREATE PSUEDO-PROJECTIONS AND COMPARE TO LAST RUN

 200  NTIMES = NTIMES + 1

C     DO ONLY IF _IN PLANE_ ROTATION OR _SCALE_ CORRECTIONS REQUESTED.

      IF (PARAMQ(1) .OR. PARAMQ(3))  THEN
	 SHFT(1) = 0.0
	 SHFT(2) = 0.0

         DO  JVIEW=0,NTVW
C          THIS STRANGE TRICK IS TO MAKE SURE THAT FIRST PASS IS OVER 
C          REFERENCE IMAGE, IN SUBSEQUENT ITERATIONS REFERENCE IMAGE 
C          IS SKIPPED.
           IVIEW = JVIEW
           IF (JVIEW .EQ. IREF) CYCLE

           IF (JVIEW .EQ. 0) IVIEW = IREF

C          ASSUMPTION IS THAT TILT OF PROJ AND TILT OF ORIG ARE EQUAL
C          THIS IS THE ONLY REASON WE CAN REALLY COMPARE THE TWO

C          FIND PSI (IN PLANE) ANGLE
           IF (PARAMQ(1)) THEN
              CALL MRANG2(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,PSI,
     &                    PTACTIVE,NTPT)
	   ELSE
	      PSI = 0.0
	   ENDIF

C          FIND SCALE
           IF (PARAMQ(3)) THEN
             CALL MRSCALE(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,SCALEI,
     &                    PTACTIVE,NUMPTS)
             SCAL = SCALEI(IVIEW)
             IF (IVIEW .EQ. IREF) SCAD = 1 / SCALEI(IVIEW)
             SCALEI(IVIEW) = SCALEI(IVIEW) * SCAD
           ELSE
	     SCAL          = 1.0
             SCALEI(IVIEW) = 1.0
           ENDIF

C          UPDATE CORRECTION INFO IN REGISTERS, NO SHIFTS AT THIS MOMENT
           C               = COS(PSI)
           S               = SIN(PSI)
           QT              = TSHIFT(1,IVIEW)
           TSHIFT(1,IVIEW) = SCALEI(IVIEW) * ( QT*C+TSHIFT(2,IVIEW)*S)
           TSHIFT(2,IVIEW) = SCALEI(IVIEW) * (-QT*S+TSHIFT(2,IVIEW)*C)
           TPSI(IVIEW)     = PSI + TPSI(IVIEW)
           SCALE(IVIEW)    = SCALE(IVIEW) * SCALEI(IVIEW)
           ANGLE(1,IVIEW)  = PSI

C          APPLY CORRECTIONS TO POINTS WITH SHFT SET TO ZERO ...
           CALL MRALIGN(XYPTS(1,1,IVIEW),
     &	            PSI,SHFT,SCALEI(IVIEW),PTACTIVE(1,IVIEW),NTPT)

        ENDDO   ! ------------------------------------------------

C       NOW GOTO 3D
	CALL MR2TO3D(P3D, XYPTS, ANGLE,PTACTIVE,NUMPTS,NTVW,NTPT)
      ENDIF


      IF (PARAMQ(4)) THEN
C       FIND TRANSLATION (SHIFT)

C       FIND CENTER OF GRAVITY OF POINTS IN 3D
C       AND APPLY ANY SHIFTS FOUND TO THESE POINTS
	CALL MRCG3D(P3D,NTPT)

C       GOTO 2D
	CALL MRPROJ(P3D, PRJ, ANGLE,NTVW,NTPT)

C       FIND THE SHIFT BETWEEN POINTS AND SHIFT XYPTS
	CALL MRSHIFT(PRJ,XYPTS,SHIFT,PTACTIVE,NTVW,NTPT)

C       UPDATE PARAMETERS
	DO IVIEW=1,NTVW
           TSHIFT(1,IVIEW) = TSHIFT(1,IVIEW) + SHIFT(1,IVIEW)
           TSHIFT(2,IVIEW) = TSHIFT(2,IVIEW) + SHIFT(2,IVIEW)
	ENDDO

C       GOTO 3D AGAIN
        CALL MR2TO3D(P3D,XYPTS,ANGLE,PTACTIVE,NUMPTS,NTVW,NTPT)
      ENDIF


      IF (PARAMQ(2)) THEN
C        FIND THETA (TILT) ANGLE

C        GOTO 2D
	 CALL MRPROJ(P3D, PRJ, ANGLE,NTVW,NTPT)
	 DO JVIEW=0,NTVW

C          THIS STRANGE TRICK IS TO MAKE SURE THAT FIRST PASS IS OVER REFERENCE
C          IMAGE, IN SUBSEQUENT ITERATIONS REFERENCE IMAGE IS SKIPPED.
C          WON'T MODIFY XYPTS, ONLY THETA

           IVIEW = JVIEW
           IF (JVIEW .NE. IREF) THEN
             IF (JVIEW .EQ. 0) IVIEW=IREF
             THETA = ANGLE(2,IVIEW)

C            SET SCALE=1.0 AND PSI=0.0
             CALL MRTHETA(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),
     &                    IVIEW,P3D,THETA,PTACTIVE,NUMPTS,NTPT)
             IF (IVIEW .EQ. IREF) THAD = THETA
             THETA = THETA - THAD

C            CORRECTION OF THETA IS FOUND, SO CALCULATE NEW THETA
             ANGLE(2,IVIEW) = THETA
	  ENDIF
	ENDDO

C       GOTO 3D AGAIN
	CALL MR2TO3D(P3D, XYPTS, ANGLE,PTACTIVE,NUMPTS,NTVW,NTPT)
      ENDIF

C     GOTO 2D AND GET THE ERROR ...
      CALL MRPROJ(P3D,PRJ,ANGLE,NTVW,NTPT)
      CALL MRCALERR(XYPTS,PRJ,ERTOT,ERVW,ERPT,PTACTIVE,NUMPTS,NTVW,NTPT)

      TTCH = SNGL((TCH-ERTOT)/TCH)
      TCH  = ERTOT
      IF (MOD(NTIMES,150) .EQ. 0)  THEN 
           WRITE(NOUT,700)NTIMES,TTCH,ERTOT
 700       FORMAT('  PASS #',I5,' TOTCHANGE= ',G10.3,' ERTOT= ',G11.4)

	   FULL = .FALSE.
     	   CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
     &       NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL,PTACTIVE,NTVW,NTPT,CIR)
	ENDIF

C       DO THE NEXT ITERATION ?
	IF (ABS(TTCH) .GT. MAXPER .AND. NTIMES.LT.MAXLOOP) GOTO 200

C       LOOPS ABOVE --------------------------------------------------


	IF (NTIMES.GE.MAXLOOP)
     &	   WRITE(NOUT,*)'  EXCEEDED LOOP LIMIT, ENDING CYCLE'

C       JUST DO SOME CLEANING UP BEFORE PUTTING OUT VALUES
	TILR = ANGLE(2,IREF)

	DO  IVIEW=1,NTVW
           ANGLE(1,IVIEW) = TPSI(IVIEW)
           ANGLE(2,IVIEW) = ANGLE(2,IVIEW)-TILR
	ENDDO

	CALL  RDPRMC(ASKFULL,NUMC,.TRUE.,'FULL OUTPUT (Y/N)',NULL,IRT)
	FULL = (ASKFULL .NE. 'N')

	CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
     &      NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL,PTACTIVE,NTVW,NTPT,CIR)

987     CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUT,NDOUTT,.TRUE.,
     &               'ERROR PER VIEW OUTPUT DOC',
     &               .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO  51
        IF (NDOUTT .LE. 0) THEN
           CALL ERRT(102,'INCORE DOC FILE NOT ALLOWED HERE.',NE)
           GOTO 987
        ENDIF 
        CALL LUNDOCPUTCOM(NDOUTT,'   ERROR_PER_VIEW', IRTFLG)
       
	DO  IVIEW=1,NTVW
	   DLIST(1) = ERVW(IVIEW)
           CALL LUNDOCWRTDAT(NDOUTT,NUMBER(IVIEW),DLIST,1,IRTFLG)
	ENDDO

        CALL LUNDOCPUTCOM(NDOUTT,'        TOTAL_ERROR', IRTFLG)
C       DLIST(1) = -1
	DLIST(2) = ERTOT
        CALL LUNDOCWRTDAT(NDOUTT,-1,DLIST(2),1,IRTFLG)

51	CLOSE(NDOUT)

986     CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUT,NDOUTT,.TRUE.,
     &               'ERROR PER MARKER OUTPUT DOC',
     &               .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO  52
        IF (NDOUT .LE. 0) THEN
           CALL ERRT(102,'INCORE DOC FILE NOT ALLOWED HERE.',NE)
           GOTO 986
        ENDIF 

        CALL LUNDOCPUTCOM(NDOUTT,'       TOTAL_ERROR', IRTFLG)
	DO  IPT=1,NTPT
	   DLIST(1) = ERPT(IPT)
           CALL LUNDOCWRTDAT(NDOUTT,IPT,DLIST,1,IRTFLG)
	ENDDO

        CALL LUNDOCPUTCOM(NDOUTT,'          ERROR_PER_PT', IRTFLG)
	DLIST(1) = ERTOT
        CALL LUNDOCWRTDAT(NDOUTT,-1,DLIST,1,IRTFLG)
52      CLOSE(NDOUT)

	CALL MRDOC(SCALE,TSHIFT,ANGLE,NUMBER,P3D,NTVW,NTPT)

	END

C------------- UNUSED BELOW ---------------------------

@


1.29
log
@PROMPTS & DOC FILE HEADERS & lundoc
@
text
@d3 1
a3 1
C                                                                      *
d6 1
a6 1
C                                                                      *
d84 1
a84 1
      NDOUTT = 70
d110 1
a110 1
      WRITE(NOUT,*) ' INITIAL INFO   '
d118 1
a118 1
 701  FORMAT('  PASS #',I5,' TOTCHANGE= ',10('-'),' ERTOT= ',G11.4,/)
d226 1
a226 1
             IF (IVIEW.EQ.IREF) THAD = THETA
d276 1
a276 1
987     CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUTT,NDOUT,.TRUE.,
d280 1
a280 1
        IF (NDOUT .LE. 0) THEN
d284 1
d288 1
a288 1
           CALL LUNDOCWRTDAT(NDOUT,NUMBER(IVIEW),DLIST,1,IRTFLG)
d291 1
d294 1
a294 1
        CALL LUNDOCWRTDAT(NDOUT,-1,DLIST(2),1,IRTFLG)
d298 1
a298 1
986     CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUTT,NDOUT,.TRUE.,
d307 1
d310 1
a310 1
           CALL LUNDOCWRTDAT(NDOUT,IPT,DLIST,1,IRTFLG)
d313 1
d315 2
a316 2
        CALL LUNDOCWRTDAT(NDOUT,-1,DLIST,1,IRTFLG)
52      CLOSE(NDOUTT)
@


1.28
log
@GPL_2010
@
text
@d4 2
a5 1
C                                                                      *
d11 1
a11 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d28 5
a32 4
C                                                                      *
C   WARNING !
C   PARAMETERS LS AND LV ARE HARD-WIRED IN ALL THE SUBROUTINES.

d34 1
a34 1
C   ATTEMPTS TO ALIGN A DATA SET USING FIDUCIARY MARKERS.
d47 1
d50 1
a50 1
      SUBROUTINE  MRK(IDUM)
d57 3
a59 3
      INTEGER, PARAMETER   :: MAXLOOP=19999
      REAL, PARAMETER      :: MAXPER=1.0E-7
      INTEGER, PARAMETER   :: NLIST=2 
d110 1
a110 1
      WRITE(NOUT,*) '    INITIAL INFO   '
d118 1
a118 1
 701  FORMAT(' PASS #',I5,' TOTCHANGE= ',10('-'),' ERTOT= ',G11.4,/)
d246 1
a246 1
 700       FORMAT(' PASS #',I5,' TOTCHANGE= ',G10.3,' ERTOT= ',G11.4)
d260 1
a260 1
     &	   WRITE(NOUT,*)' EXCEEDED LOOP LIMIT, ENDING CYCLE'
@


1.27
log
@ removed unused & cosmetic
@
text
@a6 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d8 5
a12 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d14 1
a14 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d21 1
a21 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a22 1
C=*                                                                    *
d24 1
a24 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.26
log
@mk xypts in 2 parameters mralign bug
@
text
@a31 2
C   MAIN SUBROUTINE FOR MARKER PROGRAM.
C
d34 3
a36 3
C
C **********************************************************
C ATTEMPTS TO ALIGN A DATA SET USING FIDUCIARY MARKERS.
d51 1
a51 1
      SUBROUTINE  MRK(MAXDIM)
a320 204

#ifdef NEVERNEVER
      SUBROUTINE  MRK(MAXDIM)

      INCLUDE     'CMBLOCK.INC'
      INCLUDE     'CMLIMIT.INC'

      INTEGER, PARAMETER   :: LV=300
      INTEGER, PARAMETER   :: LS=256
      INTEGER, PARAMETER   :: MAXLOOP=19999
      REAL, PARAMETER      :: MAXPER=1.0E-7
      INTEGER, PARAMETER   :: NLIST=2 

      CHARACTER(LEN=MAXNAM):: DOCNAM

      DIMENSION         DLIST(NLIST)
      LOGICAL*1         FULL
      CHARACTER*1       ASKFULL,NULL

      LOGICAL           PARAMQ(4)
      LOGICAL           PTACTIVE(LS,LV)
      INTEGER           NUMPTS(LV)
      REAL              CIR(2)

      DIMENSION         XYPTS(2,LS,LV),PRJ(2,LS,LV)
      DIMENSION         ROT(3,3),ANGLE(3,LV),TPSI(LV)
      DIMENSION         P3D(3,LS),SCALE(LV)
      DIMENSION         NUMBER(LV),SCALEI(LV)
      DIMENSION         CVPT(3)
      DIMENSION         SHFT(2),SHIFT(2,LV),TSHIFT(2,LV)
      DIMENSION         ERVW(LV),ERPT(LS)

      LOGICAL           FIRST
      INTEGER           NTIMES
      DOUBLE PRECISION  TCH,ERTOT

      NDOUTT = 70

      NTIMES = 0
      NULL   = CHAR(0)

C     GET COORDS OF MARKERS IN EACH PROJECTION

      CALL MRGETINFO(XYPTS,IREF,NUMBER,ANGLE,SCALE,TSHIFT,FIRST,NTTVL,
     &               PARAMQ,PTACTIVE,NUMPTS,NTVW,NTPT,CIR)

      DO  IVIEW=1,NTVW

         TPSI(IVIEW)    = ANGLE(1,IVIEW)
         SHIFT(1,IVIEW) = TSHIFT(1,IVIEW)
         SHIFT(2,IVIEW) = TSHIFT(2,IVIEW)

         CALL MRALIGN(XYPTS(1,1,IVIEW),
     &	          ANGLE(1,IVIEW),SHIFT(1,IVIEW),SCALE(IVIEW),
     &	          PTACTIVE(1,IVIEW),NTPT)
      ENDDO

C     GET 3D VOLUME
      CALL MR2TO3D(P3D, XYPTS, ANGLE,PTACTIVE,NUMPTS,NTVW,NTPT)
      CALL MRPROJ(P3D, PRJ, ANGLE,NTVW,NTPT)
      CALL MRCALERR(XYPTS,PRJ,ERTOT,ERVW,ERPT,PTACTIVE,NUMPTS,NTVW,NTPT)

      WRITE(NOUT,*) '    INITIAL INFO   '

      FULL = .FALSE.
      CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
     &     NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL,PTACTIVE,NTVW,NTPT,CIR)

      TCH = ERTOT
      WRITE(NOUT,701) NTIMES,ERTOT
 701  FORMAT(' PASS #',I5,' TOTCHANGE= ',10('-'),' ERTOT= ',G11.4,/)

C     CREATE PSUEDO-PROJECTIONS AND COMPARE TO LAST RUN -------ERR BELOW

 200  NTIMES = NTIMES + 1

	 SHFT(1) = 0.0
	 SHFT(2) = 0.0

         DO JVIEW=0,NTVW
C          THIS STRANGE TRICK IS TO ENSURE THAT FIRST PASS IS OVER 
C          REFERENCE IMAGE, IN SUBSEQUENT ITERATIONS REF. IMAGE SKIPPED.
           IVIEW = JVIEW
           IF (JVIEW .EQ. IREF) CYCLE
           IF (JVIEW .EQ. 0) IVIEW = IREF

C          ASSUMPTION IS THAT TILT OF PROJ AND TILT OF ORIG ARE EQUAL
C          THIS IS THE ONLY REASON WE CAN REALLY COMPARE THE TWO

C          FIND PSI (IN PLANE) ANGLE
           CALL MRANG2(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,PSI,
     &                    PTACTIVE,NTPT)

C          FIND SCALE
           SCALEI(IVIEW) = 1.0

C          UPDATE CORRECTION INFO, NO SHIFTS AT THIS MOMENT
           C               = COS(PSI)
           S               = SIN(PSI)
           QT              = TSHIFT(1,IVIEW)
           TSHIFT(1,IVIEW) = SCALEI(IVIEW) * ( QT*C + TSHIFT(2,IVIEW)*S)
           TSHIFT(2,IVIEW) = SCALEI(IVIEW) * (-QT*S + TSHIFT(2,IVIEW)*C)
           TPSI(IVIEW)     = PSI + TPSI(IVIEW)
           SCALE(IVIEW)    = SCALE(IVIEW) * SCALEI(IVIEW)
           ANGLE(1,IVIEW)  = PSI

C          APPLY CORRECTIONS TO POINTS WITH SHFT SET TO ZERO ...
           CALL MRALIGN(XYPTS(1,1,IVIEW),
     &	            PSI,SHFT,SCALEI(IVIEW),PTACTIVE(1,IVIEW),NTPT)

        ENDDO   ! ------------------------------------------------

C       NOW GOTO 3D
	CALL MR2TO3D(P3D, XYPTS, ANGLE,PTACTIVE,NUMPTS,NTVW,NTPT)

C     GOTO 2D AND GET THE ERROR ...
      CALL MRPROJ(P3D,PRJ,ANGLE,NTVW,NTPT)
      CALL MRCALERR(XYPTS,PRJ,ERTOT,ERVW,ERPT,PTACTIVE,NUMPTS,NTVW,NTPT)

      TTCH = SNGL((TCH-ERTOT)/TCH)
      TCH  = ERTOT
      IF (MOD(NTIMES,150) .EQ. 0)  THEN 
           WRITE(NOUT,700)NTIMES,TTCH,ERTOT
 700       FORMAT(' PASS #',I5,' TOTCHANGE= ',G10.3,' ERTOT= ',G11.4)

	   FULL = .FALSE.
     	   CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
     &       NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL,PTACTIVE,NTVW,NTPT,CIR)
	ENDIF

C       DO THE NEXT ITERATION ?
	IF (ABS(TTCH) .GT. MAXPER .AND. NTIMES .LT. MAXLOOP) GOTO 200









	IF (NTIMES .GE. MAXLOOP)
     &	    WRITE(NOUT,*)' EXCEEDED LOOP LIMIT, ENDING CYCLE'

C       JUST DO SOME CLEANING UP BEFORE PUTTING OUT VALUES
	TILR = ANGLE(2,IREF)

	DO  IVIEW=1,NTVW
           ANGLE(1,IVIEW) = TPSI(IVIEW)
           ANGLE(2,IVIEW) = ANGLE(2,IVIEW) - TILR
	ENDDO

	CALL  RDPRMC(ASKFULL,NUMC,.TRUE.,'FULL OUTPUT (Y/N)',NULL,IRT)
	FULL = (ASKFULL .NE. 'N')

	CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
     &      NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL,PTACTIVE,NTVW,NTPT,CIR)

987     CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUTT,NDOUT,.TRUE.,
     &               'ERROR PER VIEW OUTPUT DOC',
     &               .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO  51
        IF (NDOUT .LE. 0) THEN
           CALL ERRT(102,'INCORE DOC FILE NOT ALLOWED HERE.',NE)
           GOTO 987
        ENDIF 
       
	DO  IVIEW=1,NTVW
C	   DLIST(1) = NUMBER(IVIEW)
	   DLIST(2) = ERVW(IVIEW)
           CALL LUNDOCWRTDAT(NDOUT,NUMBER(IVIEW),DLIST(2),1,IRTFLG)
	ENDDO

C       DLIST(1) = -1
	DLIST(2) = ERTOT
        CALL LUNDOCWRTDAT(NDOUT,-1,DLIST(2),1,IRTFLG)

51	CLOSE(NDOUT)

986     CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUTT,NDOUT,.TRUE.,
     &               'ERROR PER MARKER OUTPUT DOC',
     &               .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO  52
        IF (NDOUT .LE. 0) THEN
           CALL ERRT(102,'INCORE DOC FILE NOT ALLOWED HERE.',NE)
           GOTO 986
        ENDIF 

	DO  IPT=1,NTPT
C          DLIST(1) = IPT
	   DLIST(2) = ERPT(IPT)
           CALL LUNDOCWRTDAT(NDOUT,IPT,DLIST(2),1,IRTFLG)
	ENDDO

C       DLIST(1) = -1
	DLIST(2) = ERTOT
        CALL LUNDOCWRTDAT(NDOUT,-1,DLIST(2),1,IRTFLG)
52      CLOSE(NDOUTT)

	CALL MRDOC(SCALE,TSHIFT,ANGLE,NUMBER,P3D,NTVW,NTPT)

	END

#endif
@


1.25
log
@GPL License fixed
@
text
@d58 6
a63 9
      PARAMETER (LV=300)
      PARAMETER (LS=256)
      PARAMETER (MAXLOOP=19999)
      REAL MAXPER
      PARAMETER (MAXPER=1.0E-7)
      PARAMETER  (NLIST=2)
      DIMENSION        DLIST(NLIST)
      LOGICAL*1        FULL
      CHARACTER*1      ASKFULL,NULL
d65 9
a73 2
      LOGICAL*1        PTACTIVE(LS,LV),PARAMQ(4)
      COMMON /GENERAL/PTACTIVE,NUMPTS(LV),NTVW,NTPT,CIR(2),PARAMQ
d83 1
a83 1
      LOGICAL*1         FIRST
a86 2
      DATA PI/3.141592654/

d94 2
a95 1
      CALL MRGETINFO(XYPTS,IREF,NUMBER,ANGLE,SCALE,TSHIFT,FIRST,NTTVL)
d99 7
a105 7
        TPSI(IVIEW)=ANGLE(1,IVIEW)
        SHIFT(1,IVIEW)=TSHIFT(1,IVIEW)
        SHIFT(2,IVIEW)=TSHIFT(2,IVIEW)

        CALL MRALIGN(XYPTS(1,1,IVIEW),XYPTS(1,1,IVIEW),
     &	   ANGLE(1,IVIEW),SHIFT(1,IVIEW),SCALE(IVIEW),
     &	   PTACTIVE(1,IVIEW),NTPT)
d109 3
a111 4
      CALL MR2TO3D(P3D, XYPTS, ANGLE)
      CALL MRPROJ(P3D, PRJ, ANGLE)
      CALL MRCALERR(XYPTS,PRJ,ERTOT,ERVW,ERPT)
      WRITE(NOUT,*)'    INITIAL INFO   '
d113 3
a115 1
      FULL=.FALSE.
d117 1
a117 1
     &		NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL)
d119 1
a119 1
      TCH=ERTOT
d121 1
a121 2
 701  FORMAT(' PASS #',I5,' TOTCHANGE= ',10('*'),' ERTOT= ',G11.4)
 700  FORMAT(' PASS #',I5,' TOTCHANGE= ',G10.3,' ERTOT= ',G11.4)
a123 1
 200  NTIMES=NTIMES+1
d125 3
a127 1
C     DO 210 ONLY IF _IN PLANE_ ROTATION OR _SCALE_ CORRECTIONS REQUESTED.
d129 12
a140 9
      IF (PARAMQ(1).OR.PARAMQ(3))  THEN
	 SHFT(1)=0.0
	 SHFT(2)=0.0
         DO 210 JVIEW=0,NTVW
C          THIS STRANGE TRICK IS TO MAKE SURE THAT FIRST PASS IS OVER REFERENCE
C          IMAGE, IN SUBSEQUENT ITERATIONS REFERENCE IMAGE IS SKIPPED.
           IVIEW=JVIEW
           IF(JVIEW.EQ.IREF) GOTO 210
           IF(JVIEW.EQ.0) IVIEW=IREF
a144 3
C          CALL MRQUATER(RPT,VPT,IVIEW,ROT)
C          CALL MRROTATE(ROT,PHI2,THETA,PSI)

a145 1

d147 2
a148 1
              CALL MRANG2(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,PSI)
d150 1
a150 1
	      PSI=0.0
a153 1

d155 5
a159 4
             CALL MRSCALE(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,SCALEI)
             SCAL=SCALEI(IVIEW)
             IF (IVIEW.EQ.IREF) SCAD=1/SCALEI(IVIEW)
             SCALEI(IVIEW)=SCALEI(IVIEW)*SCAD
d161 2
a162 2
	     SCAL=1.0
             SCALEI(IVIEW)=1.0
d166 14
a179 12
           C=COS(PSI)
           S=SIN(PSI)
           QT=TSHIFT(1,IVIEW)
           TSHIFT(1,IVIEW)=SCALEI(IVIEW)*(QT*C+TSHIFT(2,IVIEW)*S)
           TSHIFT(2,IVIEW)=SCALEI(IVIEW)*(-QT*S+TSHIFT(2,IVIEW)*C)
           TPSI(IVIEW)=PSI+TPSI(IVIEW)
           SCALE(IVIEW)=SCALE(IVIEW)*SCALEI(IVIEW)
           ANGLE(1,IVIEW)=PSI
c          apply corrections to points with SHFT set to zero ...
           CALL MRALIGN(XYPTS(1,1,IVIEW),XYPTS(1,1,IVIEW),
     &	      PSI,SHFT,SCALEI(IVIEW),PTACTIVE(1,IVIEW),NTPT)
 210    CONTINUE
d182 1
a182 1
	CALL MR2TO3D(P3D, XYPTS, ANGLE)
a184 1
C     FIND TRANSLATION (SHIFT)
d187 1
d189 3
a191 4
C        FIND CENTER OF GRAVITY OF POINTS IN 3D
C        AND APPLY ANY SHIFTS FOUND TO THESE POINTS

	CALL MRCG3D(P3D)
d194 1
a194 1
	CALL MRPROJ(P3D, PRJ, ANGLE)
d197 1
a197 1
	CALL MRSHIFT(PRJ,XYPTS,SHIFT)
d200 3
a202 3
	DO    IVIEW=1,NTVW
           TSHIFT(1,IVIEW)=TSHIFT(1,IVIEW)+SHIFT(1,IVIEW)
           TSHIFT(2,IVIEW)=TSHIFT(2,IVIEW)+SHIFT(2,IVIEW)
d206 1
a206 1
        CALL MR2TO3D(P3D,XYPTS,ANGLE)
a208 1
C     FIND THETA (TILT) ANGLE
d211 2
d214 20
a233 17
	CALL MRPROJ(P3D, PRJ, ANGLE)
	DO JVIEW=0,NTVW
C         THIS STRANGE TRICK IS TO MAKE SURE THAT FIRST PASS IS OVER REFERENCE
C         IMAGE, IN SUBSEQUENT ITERATIONS REFERENCE IMAGE IS SKIPPED.
C         WON'T MODIFY XYPTS, ONLY THETA
          IVIEW=JVIEW
          IF ( JVIEW.NE.IREF) THEN
            IF (JVIEW.EQ.0) IVIEW=IREF
            THETA = ANGLE(2,IVIEW)
C	    PRINT  *,IVIEW,THETA
C           SET SCALE=1.0 AND PSI=0.0
           CALL MRTHETA(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,P3D,THETA)
            IF (IVIEW.EQ.IREF) THAD = THETA
            THETA=THETA-THAD
CC          CORRECTION OF THETA IS FOUND, SO CALCULATE NEW THETA
C           ANGLE(2,IVIEW)=ANGLE(2,IVIEW)+THETA
            ANGLE(2,IVIEW)=THETA
d237 11
a247 15
C        GOTO 3D AGAIN
	CALL MR2TO3D(P3D, XYPTS, ANGLE)
        ENDIF

C       GOTO 2D AND GET THE ERROR ...
	CALL MRPROJ(P3D,PRJ,ANGLE)
	CALL MRCALERR(XYPTS,PRJ,ERTOT,ERVW,ERPT)

	TTCH=SNGL((TCH-ERTOT)/TCH)
C       IF (MOD(NTIMES,10).EQ.0) THEN
C          WRITE(NOUT,700)NTIMES,BOXERR,TTCH,ERTOT
C          WRITE(NDAT,700)NTIMES,BOXERR,TTCH,ERTOT
C       ENDIF
	TCH=ERTOT
        IF (MOD(NTIMES,150).EQ.0)  THEN 
d249 3
a251 1
	   FULL=.FALSE.
d253 1
a253 1
     &		NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL)
d257 4
a260 2
	IF (ABS(TTCH) .GT. MAXPER
     &	    .AND. NTIMES.LT.MAXLOOP) GOTO 200
d266 2
a267 3
	TILR=ANGLE(2,IREF)
c       XSH=TSHIFT(1,IREF)
c       YSH=TSHIFT(2,IREF)
d269 2
a270 5
           ANGLE(1,IVIEW)=TPSI(IVIEW)
           ANGLE(2,IVIEW)=ANGLE(2,IVIEW)-TILR
C          THIS IS DONE TO PUT TILT AXIS AT (0,0) OF REFERENCE VIEW
C          TSHIFT(1,IVIEW)=TSHIFT(1,IVIEW)-(XSH*COS(ANGLE(2,IVIEW)))
C          TSHIFT(2,IVIEW)=TSHIFT(2,IVIEW)-YSH
a272 1
        WRITE(NOUT,700)NTIMES,TTCH,ERTOT
d274 1
a274 1
	FULL = (ASKFULL.NE.'N')
d277 203
a479 1
     &		       NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL)
d499 1
d522 1
a522 1
	CALL MRDOC(SCALE,TSHIFT,ANGLE,NUMBER,P3D)
d525 2
@


1.24
log
@ls-->256
@
text
@d7 23
a29 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.23
log
@opendoc incore parameter
@
text
@d42 1
a42 1
      PARAMETER (LS=100)
@


1.22
log
@incore lundoc for opendoc
@
text
@d68 1
a68 2
C     OPENDOC CAN ALTER NDOUT
      NDOUT  = 70
d258 1
a258 1
987     CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUT,.TRUE.,
a263 1
           NDOUT  = 70
d278 1
a278 1
986     CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUT,.TRUE.,
a283 1
           NDOUT  = 70
d296 1
a296 1
52      CLOSE(NDOUT)
@


1.21
log
@doc files updated for missing markers
propts fixed
@
text
@a65 1
      DATA  NDOUT/56/
d68 3
d203 1
a203 1
          CALL MRTHETA(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,P3D,THETA)
d259 1
a259 1
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUT,.TRUE.,
d263 6
a268 1

a271 1
C	   CALL SAVD(NDOUT,DLIST,NLIST,IRTFLG)
d280 1
a280 1
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOUT,.TRUE.,
d284 5
a292 1
C          CALL SAVD(NDOUT,DLIST,NLIST,IRTFLG)
@


1.20
log
@*** empty log message ***
@
text
@d8 1
a8 1
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
d36 16
a51 14
	SUBROUTINE  MRK(MAXDIM)
	INCLUDE     'CMBLOCK.INC'
        PARAMETER (LV=300)
        PARAMETER (LS=100)
        PARAMETER (MAXREG=7)
        PARAMETER (MAXKEY=100)
        PARAMETER (MAXLOOP=19999)
        REAL MAXPER
        PARAMETER (MAXPER=1.0E-7)
	PARAMETER  (NLIST=2)
	DIMENSION  DLIST(NLIST)
	LOGICAL*1      FULL
	CHARACTER*1  ASKFULL,NULL
	LOGICAL*1   PTACTIVE(LS,LV),PARAMQ(4)
d64 8
a71 5
	DOUBLE PRECISION  TCH,ERTOT
        DATA  NDOUT/56/
	DATA PI/3.141592654/
	NTIMES=0
	NULL=CHAR(0)
d77 1
a77 10
c        IF(FIRST.AND.PARAMQ(4)) THEN
cc
cC           ROUGH ALIGN THESE PROJECTIONS IF FIRST TIME RUNNING
cc
c      CALL MRCENTI(XYPTS(1,1,IVIEW),CVPT,ptactive(1,IVIEW),ls)
c          SHIFT(1,IVIEW)=-cvpt(1)
c          SHIFT(2,IVIEW)=-cvpt(2)
c        TSHIFT(1,IVIEW)=SHIFT(1,IVIEW)
c        TSHIFT(2,IVIEW)=SHIFT(2,IVIEW)
c	else
d81 4
a84 4
c	ENDIF
      CALL MRALIGN(XYPTS(1,1,IVIEW),XYPTS(1,1,IVIEW),
     &	ANGLE(1,IVIEW),SHIFT(1,IVIEW),SCALE(IVIEW),
     &	PTACTIVE(1,IVIEW),NTPT)
d86 2
a87 2
C
C           GET 3D VOLUME
d92 2
a93 1
	FULL=.FALSE.
d96 2
a97 2
C
	TCH=ERTOT
d101 2
a102 4
C
C  ** MAIN LOOP **
C
C           CREATE PSUEDO-PROJECTIONS AND COMPARE TO LAST RUN
d104 54
a157 52
c
c  do 210 only if _in plane_ rotation or _scale_ corrections requested.
c
	IF(PARAMQ(1).OR.PARAMQ(3))  THEN
	SHFT(1)=0.0
	SHFT(2)=0.0
      DO 210 JVIEW=0,NTVW
c this strange trick is to make sure that first pass is over reference
c image, in subsequent iterations reference image is skipped.
        IVIEW=JVIEW
        IF(JVIEW.EQ.IREF) GOTO 210
        IF(JVIEW.EQ.0) IVIEW=IREF
C
C        ASSUMPTION IS THAT TILT OF PROJ AND TILT OF ORIG ARE EQUAL
C        THIS IS THE ONLY REASON WE CAN REALLY COMPARE THE TWO
C
C        CALL MRQUATER(RPT,VPT,IVIEW,ROT)
C        CALL MRROTATE(ROT,PHI2,THETA,PSI)
c
c  Find psi (in plane) angle
c
        IF(PARAMQ(1)) THEN
        CALL MRANG2(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,PSI)
	ELSE
	PSI=0.0
	ENDIF
c
c  Find scale
c
        IF(PARAMQ(3)) THEN
         CALL MRSCALE(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,SCALEI)
         SCAL=SCALEI(IVIEW)
         IF(IVIEW.EQ.IREF) SCAD=1/SCALEI(IVIEW)
         SCALEI(IVIEW)=SCALEI(IVIEW)*SCAD
        ELSE
	 SCAL=1.0
         SCALEI(IVIEW)=1.0
        ENDIF
C           UPDATE CORRECTION INFO IN REGISTERS, no shifts at this moment
        C=COS(PSI)
        S=SIN(PSI)
	QT=TSHIFT(1,IVIEW)
        TSHIFT(1,IVIEW)=SCALEI(IVIEW)*(qt*C+TSHIFT(2,IVIEW)*S)
        TSHIFT(2,IVIEW)=SCALEI(IVIEW)*(-qt*S+TSHIFT(2,IVIEW)*C)
        TPSI(IVIEW)=PSI+TPSI(IVIEW)
        SCALE(IVIEW)=SCALE(IVIEW)*SCALEI(IVIEW)
        ANGLE(1,IVIEW)=PSI
c  apply corrections to points with SHFT set to zero ...
      CALL MRALIGN(XYPTS(1,1,IVIEW),XYPTS(1,1,IVIEW),
     &	PSI,SHFT,SCALEI(IVIEW),PTACTIVE(1,IVIEW),NTPT)
 210  CONTINUE
c now goto 3D
d159 9
a167 9
	ENDIF
c
c  Find translation (shift)
c
	IF(PARAMQ(4)) THEN
c
c  find center of gravity of points in 3D
c  and apply any shifts found to these points
c
d169 2
a170 1
c goto 2D
d172 2
a173 1
c find the shift between points and shift XYPTS
d175 15
a189 14
c update parameters
	do    IVIEW=1,ntvw
        TSHIFT(1,IVIEW)=TSHIFT(1,IVIEW)+shift(1,IVIEW)
        TSHIFT(2,IVIEW)=TSHIFT(2,IVIEW)+shift(2,IVIEW)
	enddo
c
c goto 3D again
	CALL MR2TO3D(P3D,XYPTS,ANGLE)
	ENDIF
c
c  Find theta (tilt) angle
c
        IF(PARAMQ(2)) THEN
c goto 2D
d192 3
a194 3
c this strange trick is to make sure that first pass is over reference
c image, in subsequent iterations reference image is skipped.
c won't modify XYPTS, only THETA
d196 2
a197 2
          IF(JVIEW.NE.IREF) THEN
            IF(JVIEW.EQ.0) IVIEW=IREF
d199 4
a202 4
c	print  *,IVIEW,theta
c set scale=1.0 and psi=0.0
        CALL MRTHETA(PRJ(1,1,IVIEW),XYPTS(1,1,IVIEW),IVIEW,P3D,THETA)
            IF(IVIEW.EQ.IREF) THAD = THETA
d204 2
a205 2
cc correction of theta is found, so calculate new theta
c           ANGLE(2,IVIEW)=ANGLE(2,IVIEW)+THETA
d209 2
a210 2
c
c goto 3D again
d213 2
a214 2
c
c  goto 2D and get the error ...
d217 1
a217 1
C
d219 4
a222 4
c      IF(MOD(NTIMES,10).EQ.0) THEN
c        WRITE(NOUT,700)NTIMES,BOXERR,TTCH,ERTOT
c        WRITE(NDAT,700)NTIMES,BOXERR,TTCH,ERTOT
c      ENDIF
d224 4
a227 4
        IF(MOD(NTIMES,150).EQ.0)  THEN 
        WRITE(NOUT,700)NTIMES,TTCH,ERTOT
	FULL=.FALSE.
     	CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
d230 9
a238 11
c
c  do the next iteration ?
c
c      IF(TTCH.GT.MAXPER
	IF(ABS(TTCH).GT.MAXPER
     &			.AND. NTIMES.LT.MAXLOOP) GOTO 200
c
	IF(NTIMES.GE.MAXLOOP)
     &	 WRITE(NOUT,*)'  EXCEEDED LOOP LIMIT, ENDING CYCLE'
C
C           JUST DO SOME CLEANING UP BEFORE PUTTING OUT VALUES
d240 2
a241 2
c      XSH=TSHIFT(1,IREF)
c      YSH=TSHIFT(2,IREF)
d243 5
a247 5
        ANGLE(1,IVIEW)=TPSI(IVIEW)
        ANGLE(2,IVIEW)=ANGLE(2,IVIEW)-TILR
c  this is done to put tilt axis at (0,0) of reference view
c        TSHIFT(1,IVIEW)=TSHIFT(1,IVIEW)-(XSH*COS(ANGLE(2,IVIEW)))
c        TSHIFT(2,IVIEW)=TSHIFT(2,IVIEW)-YSH
d249 1
a249 2
c
	FULL=.TRUE.
d251 3
a253 6
	CALL  RDPRMC(ASKFULL,NUMC,.TRUE.,'Full output (Y/N)',NULL,IRT)
	IF(ASKFULL.EQ.'Y'.OR.ASKFULL.EQ.'y') THEN
	FULL=.TRUE.
	ELSE
	FULL=.FALSE.
	ENDIF
d255 7
a261 1
     &		NUMBER,TSHIFT,SCALE,ERVW,ERPT,FULL)
d263 4
a266 4
	 DLIST(1)=IVIEW
	 DLIST(2)=ERVW(IVIEW)
	 CALL  SAVD(NDOUT,DLIST,NLIST,IRTFLG)
	 IF(IRTFLG.EQ.-1)  GOTO  51
d268 11
a278 4
	DLIST(1)=-1
	DLIST(2)=ERTOT
51	CALL  SAVDC
	CLOSE(NDOUT)
d280 4
a283 4
	 DLIST(1)=IPT
	 DLIST(2)=ERPT(IPT)
	 CALL  SAVD(NDOUT,DLIST,NLIST,IRTFLG)
	 IF(IRTFLG.EQ.-1)  GOTO  52
d285 6
a290 5
	DLIST(1)=-1
	DLIST(2)=ERTOT
52	CALL  SAVDC
	CLOSE(NDOUT)
C
d292 1
a292 1
C
@


1.19
log
@*** empty log message ***
@
text
@d45 2
a46 1

d63 1
a66 1

d215 2
a216 2
      CALL MRPROJ(P3D,PRJ,ANGLE)
      CALL MRCALERR(XYPTS,PRJ,ERTOT,ERVW,ERPT)
d237 2
a238 3
      IF(NTIMES.GE.MAXLOOP) THEN
            WRITE(NOUT,*)'  EXCEEDED LOOP LIMIT, ENDING CYCLE'
      ENDIF
d244 1
a244 1
      DO  IVIEW=1,NTVW
d250 1
a250 1
      ENDDO
d260 1
a260 1
      CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
d262 24
a285 3
      CALL MRDOC(SCALE,TSHIFT,ANGLE,NUMBER,P3D)
c
      END
@


1.18
log
@*** empty log message ***
@
text
@d182 1
a182 1
	CALL MR2TO3D(P3D, XYPTS, ANGLE)
d214 1
a214 1
      CALL MRPROJ(P3D, PRJ, ANGLE)
@


1.17
log
@header
@
text
@d44 1
a44 1
        PARAMETER (MAXPER=1.0e-7)
d254 1
a254 1
	CALL  RDPRMC(ASKFULL,NUMC,.TRUE., 'Full output (Y/N)',NULL,IRT)
@


1.16
log
@*** empty log message ***
@
text
@d1 14
a14 1
C **********************************************************
@


1.15
log
@*** empty log message ***
@
text
@d177 1
a177 1
      DO 212 JVIEW=0,NTVW
d181 4
a184 4
        IVIEW=JVIEW
        IF(JVIEW.NE.IREF) THEN
         IF(JVIEW.EQ.0) IVIEW=IREF
         THETA = ANGLE(2,IVIEW)
d188 2
a189 2
         IF(IVIEW.EQ.IREF) THAD = THETA
         THETA=THETA-THAD
d191 3
a193 3
c        ANGLE(2,IVIEW)=ANGLE(2,IVIEW)+THETA
         ANGLE(2,IVIEW)=THETA
	 ENDIF
@


1.14
log
@removed H edit descriptor
@
text
@a0 1

d24 1
a24 3

      INCLUDE     'CMBLOCK.INC'

d33 1
a33 1
      LOGICAL*1      FULL
d35 1
a35 1
      LOGICAL*1   PTACTIVE(LS,LV),PARAMQ(4)
d49 3
a51 4
      DATA PI/3.141592654/
CNO_SAVE
      NTIMES=0
         NULL=CHAR(0)
d58 1
a58 1
c        IF(FIRST.and.paramq(4)) then
d71 4
a74 4
c	endif
      call MRALIGN(XYPTS(1,1,iview),xypts(1,1,iview),
     &	ANGLE(1,iview),SHIFT(1,iview),SCALE(iview),
     &	PTACTIVE(1,iview),ntpt)
d78 1
a78 1
      CALL MR2TO3D(P3D, XYPTS, ANGLE, ERRX, ERRY, ERRZ)
a85 4
      PERRX=ERRX/NTPT
      PERRY=ERRY/NTPT
      PERRZ=ERRZ/NTPT
      BOXERR=SQRT(PERRX**2+PERRY**2)
d87 3
a89 6
      WRITE(NOUT,701)NTIMES,BOXERR,ERTOT
c      WRITE(NDAT,701)NTIMES,BOXERR,ERTOT
 701  FORMAT(' PASS #',I5,' BERR= ',G10.4,' TOTCHANGE= ',10('*'),
     &      ' ERTOT= ',G11.4)
 700  FORMAT(' PASS #',I5,' BERR= ',G10.4,' TOTCHANGE= ',G10.3,
     &      ' ERTOT= ',G11.4)
d98 1
a98 1
	if(paramq(1).or.paramq(3))  then
d116 3
a118 3
        IF(PARAMQ(1)) then
        CALL MRANG2(prj(1,1,iview),xypts(1,1,iview),IVIEW,PSI)
	else
d120 1
a120 1
	endif
d125 1
a125 1
         CALL MRSCALE(prj(1,1,iview),xypts(1,1,iview),IVIEW,SCALEI)
d136 1
a136 1
	qt=tshift(1,iview)
d143 2
a144 2
      call MRALIGN(XYPTS(1,1,iview),XYPTS(1,1,iview),
     &	PSI,SHFT,SCALEI(iview),PTACTIVE(1,iview),ntpt)
d147 2
a148 2
	CALL MR2TO3D(P3D, XYPTS, ANGLE, ERRX, ERRY, ERRZ)
	endif
d152 1
a152 1
	IF(PARAMQ(4)) then
d163 3
a165 3
	do    iview=1,ntvw
        TSHIFT(1,IVIEW)=TSHIFT(1,IVIEW)+shift(1,iview)
        TSHIFT(2,IVIEW)=TSHIFT(2,IVIEW)+shift(2,iview)
d169 2
a170 2
	CALL MR2TO3D(P3D, XYPTS, ANGLE, ERRX, ERRY, ERRZ)
	endif
d182 4
a185 4
        IF(JVIEW.EQ.IREF) GOTO 212
        IF(JVIEW.EQ.0) IVIEW=IREF
        THETA = ANGLE(2,IVIEW)
c	print  *,iview,theta
d187 3
a189 3
        CALL MRTHETA(prj(1,1,iview),xypts(1,1,iview),IVIEW,P3D,THETA)
        IF(IVIEW.EQ.IREF) THAD = THETA
        THETA=THETA-THAD
d192 3
a194 2
        ANGLE(2,IVIEW)=THETA
212	continue
d197 1
a197 1
	CALL MR2TO3D(P3D, XYPTS, ANGLE, ERRX, ERRY, ERRZ)
a203 4
      PERRX=ERRX/NTPT
      PERRY=ERRY/NTPT
      PERRZ=ERRZ/NTPT
      BOXERR=SQRT(PERRX**2+PERRY**2)
d210 2
a211 2
      IF(MOD(NTIMES,150).EQ.0)  then 
        WRITE(NOUT,700)NTIMES,BOXERR,TTCH,ERTOT
d215 1
a215 1
	endif
a224 1
c            WRITE(NDAT,*)'  EXCEEDED LOOP LIMIT, ENDING CYCLE'
d240 1
a240 1
        WRITE(NOUT,700)NTIMES,BOXERR,TTCH,ERTOT
@


1.13
log
@*** empty log message ***
@
text
@d97 1
a97 1
 701  FORMAT(' PASS #',I5,' BERR= ',G10.4,' TOTCHANGE= ',10(1H*),
@


1.12
log
@ERTOT in DP
@
text
@d61 1
a61 1
      DO 100 IVIEW=1,NTVW
d79 1
a79 1
 100  CONTINUE
d174 1
a174 1
	do  211  iview=1,ntvw
d176 2
a177 1
211     TSHIFT(2,IVIEW)=TSHIFT(2,IVIEW)+shift(2,iview)
d246 1
a246 1
      DO 300 IVIEW=1,NTVW
d252 1
a252 1
 300  CONTINUE
@


1.11
log
@model removed
@
text
@d51 1
a51 1

d217 1
a217 1
	TTCH=(TCH-ERTOT)/TCH
d232 3
a234 3
c      IF(    TTCH.gt.MAXPER
      IF(    abs(TTCH).gt.MAXPER
     &			.and. NTIMES.lt.MAXLOOP) GOTO 200
@


1.10
log
@*** empty log message ***
@
text
@d49 1
a49 1
      LOGICAL*1         FIRST,MODEL3D
d54 2
a55 2
      NULL=CHAR(0)
      NTIMES=0         
d59 2
a60 3
      CALL MRGETINFO(XYPTS,IREF,NUMBER,ANGLE,SCALE,TSHIFT,FIRST,
     &   P3D,MODEL3D,NTTVL)
      IF(.NOT.MODEL3D)  THEN
a82 2
C will skip all the above if 3D model available
      ENDIF
@


1.9
log
@model added
@
text
@d61 1
a61 1
      IF(.NOT.MODEL3D)  HTEN
@


1.8
log
@ask for long output
@
text
@d49 1
a49 1
      LOGICAL*1         FIRST
d54 2
a55 2
      NTIMES=0
         NULL=CHAR(0)
d59 3
a61 2
      CALL MRGETINFO(XYPTS,IREF,NUMBER,ANGLE,SCALE,TSHIFT,FIRST,NTTVL)

d84 2
@


1.7
log
@nosave
@
text
@a25 1
#ifdef SP_UNIX
a26 3
#else
      INCLUDE     'COMMON1:CMBLOCK.INC'
#endif
d36 2
a37 1
      LOGICAL     FULL
d55 1
a222 1
	FULL=.FALSE.
d225 1
d255 6
@


1.6
log
@non f77 stuff removed
logical full not defined
@
text
@d56 1
a56 1

@


1.5
log
@LV set to 300 (number of projections)
@
text
@d1 3
a3 5
	subroutine  mrk(maxdim)
c Main subroutine for marker program.
c
c   Warning !
c   Parameters LS and LV are hard-wired in all the subroutines.
d5 3
d22 4
a25 2
C
C
d40 1
d46 1
a46 1
      DIMENSION         P3D(3,LS),SCALE(LV),TVC(LV)
d48 1
a48 1
      DIMENSION         CRPT(3),CVPT(3)
d51 1
a51 1
C
d54 1
a54 2
      CHARACTER*10      ANS
C
d56 1
a56 1
C
d59 1
a59 1
C           GET COORDS OF MARKERS IN EACH PROJECTION
@


1.4
log
@number of iterations increased
@
text
@d29 1
a29 1
        PARAMETER (LV=100)
@


1.3
log
@number of iterations increased ...
@
text
@d35 1
a35 1
        PARAMETER (MAXPER=1.0e-6)
d218 1
a218 1
        WRITE(NOUT,700)NTIMES,BOXERR,TTCH,ERTOT
d223 3
a225 2
      IF(MOD(NTIMES,150).EQ.0) 
     &	CALL MRPUTINFO(XYPTS,PRJ,ANGLE,P3D,
d227 1
d253 1
@


1.2
log
@cpp_lines_added
@
text
@d33 1
a33 1
        PARAMETER (MAXLOOP=999)
d94 5
a98 3
      WRITE(NOUT,700)NTIMES,BOXERR,TCH,ERTOT
c      WRITE(NDAT,700)NTIMES,BOXERR,TCH,ERTOT
 700  FORMAT(' PASS #',I3,' BERR= ',G10.4,' TOTCHANGE= ',G10.3,
@


1.1
log
@Initial revision
@
text
@d23 3
d27 1
@
