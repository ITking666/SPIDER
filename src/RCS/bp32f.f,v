head	1.69;
access;
symbols
	pre_mrcs:1.69
	healthdept_2018:1.69
	pre_getangas:1.62
	pre_GPL2010:1.58
	pre_var_equation:1.57
	pre_fftwrings:1.54
	pre_opfiles:1.50
	src:1.50
	best-code:1.48
	x-named-regs:1.48
	x:1.48
	v13-00:1.48
	pre_GPL:1.47
	prec_CA:1.43
	noindx:1.39
	Bproc:1.21
	oct21:1.16
	last77:1.12;
locks; strict;
comment	@c @;


1.69
date	2013.02.15.19.51.39;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2013.02.04.19.29.48;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2013.01.04.15.15.05;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2012.08.27.16.30.48;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2012.01.04.15.36.07;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2011.12.29.17.41.04;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2011.04.07.13.07.03;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2011.01.12.18.52.12;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2011.01.10.17.16.37;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.10.16.31.20;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2011.01.03.16.21.49;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.09.17.19.56;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2009.02.12.13.10.03;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2008.10.20.14.55.28;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2008.05.19.12.02.52;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.09.18.36.46;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.07.14.11.53;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.05.17.27.40;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.25.16.35.15;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2006.09.21.15.03.20;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.29.19.46.10;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.17.16.55.05;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2005.06.03.18.39.55;	author cyang;	state Exp;
branches;
next	1.46;

1.46
date	2004.09.30.16.37.40;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.10.15.26.50;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.30.20.38.45;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.29.17.57.32;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.16.15.32.20;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.23.20.50.18;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.19.21.24.19;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.23.14.24.49;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.23.13.22.46;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2002.07.24.17.19.35;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2002.07.23.23.33.05;	author pawel;	state Exp;
branches;
next	1.35;

1.35
date	2002.07.23.15.30.02;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.22.12.35.20;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.12.16.44.43;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.28.21.26.28;	author pawel;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.23.23.43.43;	author pawel;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.16.20.10.24;	author pawel;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.15.21.35.02;	author pawel;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.07.22.17.25;	author pawel;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.07.20.58.37;	author pawel;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.07.19.39.44;	author pawel;	state Exp;
branches;
next	1.25;

1.25
date	2002.02.25.14.36.48;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.11.12.41.58;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.05.16.31.03;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.14.18.38.23;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.29.15.05.59;	author bimal;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.09.21.48.58;	author bimal;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.24.14.36.03;	author pawel;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.11.16.57.39;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	99.11.10.17.00.13;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	99.07.16.21.11.15;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	99.07.06.20.06.55;	author pawel;	state Exp;
branches;
next	1.14;

1.14
date	99.06.07.19.06.58;	author pawel;	state Exp;
branches;
next	1.13;

1.13
date	99.06.04.21.02.19;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	99.03.18.21.00.24;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	98.12.10.17.00.12;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	98.12.03.20.36.49;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	98.12.03.17.05.32;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	98.12.02.15.19.19;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	98.12.01.19.07.04;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	98.11.30.19.19.23;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	98.11.30.18.53.58;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	98.11.30.17.28.32;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	98.11.24.13.24.13;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	98.11.07.20.44.49;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.11.07.18.45.42;	author pawel;	state Exp;
branches;
next	;


desc
@BP 32F
@


1.69
log
@COMMENTS & COSMETIC
BP32F_D --> BP32F name
BUILDM1 parameters changed
@
text
@
C++*********************************************************************
C
C  BP32F.F                                         JAN 00 P.A. Penczek
C              ANGLES IN HEADER                    JUL 01 ArDean Leith
C              OPFILE 'U'                          FEB 02 ArDean Leith
C              BESSELS                             MAY 02 P.A. Penczek
C              OPFILEC                             FEB 03 ArDean Leith
C              BUILDM PARAMETERS                   JUL 03 ArDean Leith
C              BUILDM PARAMETERS                   SEP 03 ArDean Leith
C              MPI                                 OCT 03 Chao Yang
C              REWRITE                             DEC 06 ArDean Leith
C              MPI CHANGES                         OCT 06 ArDean Leith
C              MPI READV1P BUG                     DEC 09 ArDean Leith
C              OPFILES PARAMETERS                  DEC 10 ArDean Leith
C              PREVIOUSLY NAMED WIW32**            JAN 11 ArDean Leith
C              MPI HAD UNDEFINED NY BUG            MAR 11 ArDean Leith
C              ROT2QS --> RTSQ RENAMED             DEC 11 ArDean Leith
C              NSAM --> NX, RTSQ PARAM.            JAN 12 ArDean Leith
C              ILIST ALLOC                         JAN 13 ArDean Leith
C              COMMENTS & COSMETIC                 FEB 13 ArDean Leith
C
C=**********************************************************************
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright (C)2002,2013 P. A. Penczek & ArDean Leith                *
C=* University of Texas - Houston Medical School                       *
C=* Email:  pawel.a.penczek@@uth.tmc.edu                                *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C=**********************************************************************
C
C  BP32F(CALLRTSQ)
C
C  PURPOSE:  FOR: 'BP 32F' IMPROVED WITH LESS MEMORY REQUIRED AND
C            MORE STACK USAGE.
C
C  CONTAINS: WINDKB2A
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE BP32F(CALLRTSQ)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

C       DOC FILE POINTERS
        REAL, POINTER          :: ANGBUF(:,:), ANGSYM(:,:)

        REAL,    ALLOCATABLE   :: DM(:,:),  SM(:,:) 
        REAL,    ALLOCATABLE   :: WE(:,:,:),WO(:,:,:)
        COMPLEX, ALLOCATABLE   :: XE(:,:,:),XO(:,:,:)
        REAL,    ALLOCATABLE   :: TEMP(:)
        REAL,    ALLOCATABLE   :: ROTANG(:),SHX(:),SHY(:)
        INTEGER, ALLOCATABLE   :: ILIST(:)

        LOGICAL                :: ANGINDOC,CALLRTSQ
        CHARACTER(LEN=1)       :: NULL = CHAR(0)
        CHARACTER(LEN=MAXNAM)  :: FILPAT 
        CHARACTER(LEN=MAXNAM)  :: EVENVOL,ODDVOL,BOTHVOL
        CHARACTER(LEN=MAXNAM)  :: ANGDOC

C       COMMON: /TABS/ IS USED IN ONELINE, EXTRACTLINE, PUTLINE3, ETC
        INTEGER, PARAMETER     :: LTAB = 4999
        COMMON  /TABS/ LN2,FLTB,TABI(0:LTAB)

        INTEGER, PARAMETER     :: IOPIC   = 18
        INTEGER, PARAMETER     :: INPROJ  = 19
        INTEGER, PARAMETER     :: LUNDOC  = 80
        INTEGER, PARAMETER     :: LUNXM1  = 0    ! UNSABLE NEED #'s
        !INTEGER, PARAMETER    :: LUNXM2  = 83   ! IN CALLED SUB
        !INTEGER, PARAMETER    :: LUNDOC  = 80   ! IN CALLED SUB
        !INTEGER, PARAMETER    :: LUNROTT = 81   ! IN CALLED SUB 

        CALL SET_MPI(ICOMM,MYPID,MPIERR)      ! SETS ICOMM AND MYPID

        NILMAX = NIMAXPLUS
        ALLOCATE(ILIST(NILMAX),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'BP32F; ILIST....',NILMAX)
           RETURN
        ENDIF 

C       OPEN INPUT IMAGE FILES 
        CALL OPFILES(0,INPROJ,LUNDOC,LUNXM1, 
     &             .TRUE.,FILPAT,NLET, 'O',
     &             ITYPE,NX,NY,NZ,MAXIM1,
     &             'TEMPLATE FOR IMAGE FILES (E.G. STK@@****)~~',
     &             .FALSE., ILIST,NILMAX, 
     &             NDUM,NANG,IMGNUM, IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        IF (NX .NE. NY) THEN
           CALL ERRT(101,'ONLY WORKS ON SQUARE IMAGES',NDUM)
           GOTO 999
        ENDIF

        MAXNUM = MAXVAL(ILIST(1:NANG))

C       NANG - TOTAL NUMBER OF IMAGES
        IF (MYPID <= 0) WRITE(NOUT,2001) NANG
2001    FORMAT('  NUMBER OF IMAGES: ',I7)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        ANGINDOC = .TRUE.

C       PSI, THE, PHI, REF#, EXP#, INPLANE, SX, SY  
        MAXXT    = 8 + 1
        MAXYT    = MAXNUM

        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                 MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) ANGINDOC = .FALSE.
        !write(6,*)'gotdocdat, 9999:',angbuf(1,9999),angbuf(1,10000)
                
C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 0
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF (IRTFLG .NE. 0)  MAXSYM = 1
        

        N2   = 2 * NX
        LSD  = N2 + 2 - MOD(N2,2)
        NMAT = LSD * N2 * N2
       
        NDIMANG = 1
        IF (ANGINDOC) NDIMANG = MAXNUM
        NDIMSYM = MAX(1,MAXSYM)

        ALLOCATE(DM(9,NDIMANG), 
     &           SM(9,NDIMSYM), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           MWANT = 9*NDIMANG + 9*NDIMSYM 
           CALL ERRT(46,'BP 32F; DM, SM', MWANT)
           GOTO 999
        ENDIF

        IF (ANGINDOC) THEN
C          GET ANGLES FROM DOCUMENT FILE
           CALL BUILDM1(ILIST,NANG, DM,ANGBUF,9,MAXYT,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

C          NO LONGER NEED ANGBUF        
           IF (.NOT. CALLRTSQ) DEALLOCATE(ANGBUF)
        ENDIF

        !write(6,*)'gotdocdat,buildm1:',irtflg,dm(1,5)
        CALL FLUSHRESULTS()

        IF (MAXSYM .GT. 1)  THEN
C          HAVE SYMMETRIES
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
        ENDIF

        ALLOCATE(XE(0:NX, N2,N2),
     &           WE(0:NX, N2,N2),
     &           XO(0:NX, N2,N2), 
     &           WO(0:NX, N2,N2), STAT=IRTFLG)

        IF (IRTFLG.NE.0) THEN 
C          SOME ARRAYS ARE COMPLEX SO 6 NOT 4
           MWANT = 6 * (NX+1) * N2 * N2
           CALL ERRT(46,'BP 32F; XE, WE, WO, & XO',MWANT)
           GOTO 999
        ENDIF

C       CREATE FFTW3 PLAN FOR REVERSE 3D FFT ON XE USING ALL THREADS
        !write(6,*) ' bp32f;  inv plan on xe: ',n2
        CALL FMRS_PLAN(.TRUE.,XE,N2,N2,N2, 0,-1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
C       GENERALIZED KAISER-BESSEL WINDOW ACCORDING TO LEWITT
        LN    = 5
        LN2   = LN / 2                    ! USED IN COMMON /TABS/
        R     = NX / 2
        V     = REAL(LN-1) / 2.0 / REAL(N2)
        ALPHA = 6.5
        AAAA  = 0.9*V
        NNN   = 3

C       GENERATE TABLE WITH INTERPOLANTS
        B0   = SQRT(ALPHA) * BESI1(ALPHA)
        FLTB = REAL(LTAB) / REAL(LN2+1)

cc$omp  parallel do private(i,s,x),shared(mmm)
        DO  I=0,LTAB
           S = REAL(I) / FLTB / N2
           IF (S <= AAAA)  THEN
              X       = SQRT(1.0 - (S/AAAA)**2)
              TABI(I) = SQRT(ALPHA*X) * BESI1(ALPHA*X) / B0
           ELSE
              TABI(I) = 0.0
           ENDIF
        ENDDO

C       BP32FQ(NS,XE,WE,XO,WO,LSD,N,N2, 
C       BP32FQ(NX,XE,WE,XO,WO,LSD,N

        CALL BP32FQ(NX, XE,WE,XO,WO,LSD,N2, CALLRTSQ,FILPAT,
     &               INPROJ,ANGBUF,ILIST,NANG, 
     &               DM,IMGNUM,SM,MAXSYM,ANGINDOC, 
     &               LUNXM1,MAXIM1,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL FILERD(BOTHVOL,NLETI,NULL,'RECONSTRUCTED VOLUME',IRTFLG) 
        IF (IRTFLG .NE. 0) GOTO 999

        CALL FILERD(EVENVOL,NLETI,NULL,'FIRST SAMPLE VOLUME',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
 
        CALL FILERD(ODDVOL,NLETI,NULL,'SECOND SAMPLE VOLUME',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

C       CBE AND CBO (XE & XO) ARE LSD x N2 x N2
C       CWE AND CWO (WE & WO) ARE (LSD/2) x N2 x N2
        LSDD2 = LSD / 2

        !write(6,*) ' Opening bothvol'
        !call flushresults

C       STORE FOURIER XE TEMPORARILY IN OVERALL VOLUME: BOTHVOL
        MAXIM = 0
        ITYPE = 3
        CALL OPFILEC(0,.FALSE.,BOTHVOL,IOPIC,'U',ITYPE,LSD,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        !write(6,*) ' opened bothvol; irtflg',irtflg

        CALL WRITEV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        IF (MYPID <= 0) CLOSE(IOPIC)

        !write(6,*) ' xe  cached in: ',bothvol
        !call flushresults

C       STORE WEIGHT WE TEMPORARILY IN ODDVOL (ODD VOLUME)
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,ODDVOL,IOPIC,'U',ITYPE,LSDD2,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,WE,LSDD2,N2,LSDD2,N2,N2)
        IF (MYPID <= 0) CLOSE(IOPIC)

        !write(6,*) ' we cached in:',oddvol
        !call flushresults

C       PROCESS EVEN VOLUME -------------------------------- EVEN
c        write(6,*) 'vals: even',xe(1,1,1),xe(1,1,1),
c    &                           we(1,1,1),we(2,2,2),
c    &                           xo(2,2,2),xo(2,2,2),
c    &                           wo(2,2,2),wo(2,2,2)
 
C       WEIGHT, FOURIER TRANSFORM, & WINDOW USING: XE AND WE
        !write(6,*) 'BP32F;  nrmw2 xe : ',NX,n2
        CALL NRMW2(XE,WE,NX,N2)
        CALL WINDKB2A(XE,XE,NX,LSD,N2,ALPHA,AAAA,NNN)

C       NOW EVEN VOLUME IS READY, SYMMETRIZE IF NECESSARY
        IF (MAXSYM .GT. 1)  THEN
C          ADDITIONAL SYMMETRIZATION OF VOLUME XE IN REAL SPACE 05/03/02
           ALLOCATE (TEMP(NX*NX*NX), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              MEMWANT = NX * NX * NX 
              CALL ERRT(46,'BP 32F; TEMP',MEMWANT)
              GOTO 999
           ENDIF
           CALL COP(XE,TEMP,NX*NX*NX)
c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,NX
                    XE(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO
           IF (MOD(NX,2) .EQ. 0)  THEN
              KNX = NX/2-1
           ELSE
              KNX = NX/2
           ENDIF
           KLX = -NX/2
           CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
        ENDIF

C       WRITE EVEN VOLUME TO FILE: EVENVOL,  NOTE: NX=NY=NZ 
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,EVENVOL,IOPIC,'U',ITYPE,NX,NX,NX,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CALL WRTVOL(IOPIC,NX,NX, 1,NX, XE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        IF (MYPID <= 0) CLOSE(IOPIC)

        !write(6,*) ' even stored in:',evenvol
        !call flushresults

C       RECOVER XE FROM BOTHVOL AND PUT IT IN: XE --------------- BOTH 
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,BOTHVOL,IOPIC,'O',ITYPE,LSD,N2,N2,
     &               MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CALL READV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        CLOSE(IOPIC)

        !write(6,*) ' xe recovered'
        !call flushresults

C       RECOVER WEIGHT WE  TEMP. STORED IN: ODDVOL AND PUT IT IN: WE 
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,ODDVOL,IOPIC,'O',ITYPE,LSDD2,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CALL READV(IOPIC,WE,LSDD2,N2,LSDD2,N2,N2)
        CLOSE(IOPIC)

        !write(6,*) ' we recovered'
        !call flushresults

        !write(6,*) 'vals: rec ',xe(1,1,1),xe(1,1,1),
c    &                           we(1,1,1),we(2,2,2),
c    &                           xo(2,2,2),xo(2,2,2),
c    &                           wo(2,2,2),wo(2,2,2)

C       ADD EVEN AND ODD VOLUMES, PLACE IN XE AND WE
        CALL ADDADA(XE,XO,NMAT)
        CALL ADDADA(WE,WO,NMAT/2)

C       WEIGHT, FOURIER TRANSFORM, AND WINDOW BOTHVOL USING: XE AND WE
        !write(6,*) ' BP32F;  nrmw2 xe : ',NX,n2
        CALL NRMW2(XE,WE,NX,N2)
        CALL WINDKB2A(XE,XE,NX,LSD,N2,ALPHA,AAAA,NNN)

C       OVEALL VOLUME IS NOW IN: XE
        IF (MAXSYM .GT. 1)  THEN
C          ADDITIONAL SYMMETRIZATION OF VOLUME TOTAL IN REAL SPACE 05/03/02
           CALL COP(XE, TEMP,NX*NX*NX)
c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,NX
                    XE(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO
           CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
        ENDIF

C       WRITE OVERALL VOLUME FROM: XE  TO: BOTHVOL
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,BOTHVOL,IOPIC,'U',ITYPE,NX,NX,NX,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
        CALL WRTVOL(IOPIC,NX,NX, 1,NX, XE,IRTFLG)
        IF (MYPID <= 0) CLOSE(IOPIC)

        !write(6,*) 'vals: end ',xe(1,1,1),xe(1,1,1),
c    &                          we(1,1,1),we(2,2,2),
c    &                          xo(2,2,2),xo(2,2,2),
c    &                          wo(2,2,2),wo(2,2,2)
        !write(6,*) ' overall stored'
        !call flushresults

C       ODD VOLUME IS STILL UNDAMAGED IN: XO --------------------- ODD

C       WEIGHT, FOURIER TRANSFORM, AND WINDOW ODD VOL. USING: XO AND WO
        !write(6,*) ' BP32F;  nrmw2 xo : ',NX,n2
        CALL NRMW2(XO,WO,NX,N2)
        CALL WINDKB2A(XO,XO,NX,LSD,N2,ALPHA,AAAA,NNN)

        IF (MAXSYM .GT. 1)  THEN
C          ADDITIONAL SYMMETRIZATION OF VOLUME XO IN REAL SPACE 05/03/02
           CALL COP(XO,TEMP, NX*NX*NX)
c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,NX
                    XO(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO
           CALL SYMVOL(TEMP,XO,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
        ENDIF

C       WRITE ODD FILE VOLUME FROM: XO  TO: ODDVOL
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,ODDVOL,IOPIC,'U',ITYPE,NX,NX,NX,
     &              MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CALL WRTVOL(IOPIC,NX,NX, 1,NX, XO,IRTFLG)
        IF (MYPID <= 0) CLOSE(IOPIC)

        !write(6,*) ' odd stored'

999     CONTINUE
        IF (ALLOCATED(ILIST))   DEALLOCATE(ILIST)
        IF (ALLOCATED(DM))      DEALLOCATE(DM)
        IF (ALLOCATED(SM))      DEALLOCATE(SM)
        IF (ALLOCATED(XE))      DEALLOCATE(XE)
        IF (ALLOCATED(WE))      DEALLOCATE(WE)
        IF (ALLOCATED(XO))      DEALLOCATE(XO)
        IF (ALLOCATED(WO))      DEALLOCATE(WO)
        IF (ALLOCATED(TEMP))    DEALLOCATE(TEMP)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)

        CLOSE(INPROJ)
        CLOSE(LUNXM1)

        END

C       ---------------- BP32FQ -----------------------------------

        SUBROUTINE BP32FQ(NX,XE,WE,XO,WO,LSD,N, CALLRTSQ,FILPAT,
     &                     INPROJ,ANGBUF,INUMBRT,NANG, 
     &                     DM,IMGNUM,SM,MAXSYM,ANGINDOC,
     &                     LUNXM1,MAXIM1,IRTFLG)

C       NOTE: STUPID TRANSFORM OF N2-->N  !!!!al

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        REAL                  :: DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)

        REAL                  :: ANGBUF(9,NANG)
        LOGICAL               :: ANGINDOC,CALLRTSQ
        CHARACTER(LEN=*)      :: FILPAT
        LOGICAL, ALLOCATABLE  :: RANDLIST(:)
        REAL,    ALLOCATABLE  :: PROJ(:,:), PROJTEMP(:,:)
        COMPLEX, ALLOCATABLE  :: BI(:,:)
        REAL                  :: ANGBUFT(4)
        INTEGER               :: INUMBRT(NANG)
        REAL                  :: WE(0:NX,N,N)
        REAL                  :: WO(0:NX,N,N)
        COMPLEX               :: XE(0:NX,N,N)
        COMPLEX               :: XO(0:NX,N,N)

        CHARACTER(LEN=MAXNAM) :: FILNAM,ODDVOL,FILPATOUT
        INTEGER, ALLOCATABLE  :: INUMBROUT(:)

        DOUBLE PRECISION      :: PI
        LOGICAL               :: ITMP

        INTEGER, PARAMETER    :: LUNDOC  = 80
        INTEGER, PARAMETER    :: LUNROTT = 81 
        INTEGER, PARAMETER    :: LUNXM2  = 81 

#ifdef USE_MPI
c       This MPI version is memory intensive.
c       It requires 6 copies of the 3-D volume,
c       2-D images are read into memory and distributed.
c       Each processor will hold roughly nang/nproc 2-D images.  

        INCLUDE 'mpif.h'
        INTEGER               :: ISTAT(MPI_STATUS_SIZE)
        INTEGER, ALLOCATABLE  :: PSIZE(:), NBASE(:)
                          
        REAL   , ALLOCATABLE  :: PRJLOC(:,:,:)
        REAL   , ALLOCATABLE  :: PRJBUF(:,:,:)
        REAL   , ALLOCATABLE  :: WELOC(:,:,:), WOLOC(:,:,:)
        COMPLEX, ALLOCATABLE  :: XELOC(:,:,:), XOLOC(:,:,:)

        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID,  MPIERR)
        CALL MPI_COMM_SIZE(ICOMM, NPROCS, MPIERR)
#else
        MYPID = -1
#endif

c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=0,NX
                 XE(I,J,K) = CMPLX(0.0,0.0)
                 WE(I,J,K) = 0.0
                 XO(I,J,K) = CMPLX(0.0,0.0)
                 WO(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

        NSIZE  = 1
        LUNROT = 0    ! IF ZERO --> NO RTSQ OUTPUT WANTED
        NXLD   = NX

        IF (CALLRTSQ) THEN
           IF (USE_FBS_INTERP) NXLD = NX + 2 - MOD(NX,2)

C          READ IMAGE AND ROTATE, SCALE & SHIFT INTO: PROJ
           NSIZE = NX
           ALLOCATE(INUMBROUT(NANG), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP32FQ; INUMBROUT', NANG)
              GOTO 9999
           ENDIF

C          OPEN OUTPUT IMAGE(S) FOR RTSQ 
           ITYPE = 1
           CALL OPFILES(INPROJ,LUNROTT,LUNDOC,LUNXM2,
     &            .TRUE.,FILPATOUT,NLETO, 'U',
     &            ITYPE,NX,NX,1, MAXIM2,
     &            'TRANSFORMED OUTPUT IMAGES TEMPLATE (E.G. ROT@@****)~',
     &            .FALSE., INUMBROUT,NANG, 
     &            NDUM,NANGT, IMGNUMOUT, IRTFLG) 

C          IF IRTFLG IS NEGATIVE THEN NO RTSQ OUTPUT WANTED
           IF (IRTFLG .EQ. 0) LUNROT = LUNROTT
           IF (IRTFLG .GT. 0) GOTO 9999

           IF (USE_FBS_INTERP) NXLD = NX + 2 - MOD(NX,2)
        ENDIF

        ALLOCATE (PROJ(NX,NX),
     &            PROJTEMP(NX,NSIZE),
     &            BI(0:NX,N),
     &            RANDLIST(NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           MEMWANT = NX*NX + NX*NSIZE + 2*(NX+1)*N + NANG 
           CALL ERRT(46,'BPFQ; PROJ, ...',MEMWANT)
           RETURN
        ENDIF

C       CREATE LIST OF IMAGES FOR EACH RECONSTRUCTION
        RANDLIST(1:NANG/2)      = .TRUE.
        RANDLIST(NANG/2+1:NANG) = .FALSE.

        DO  K=1,NANG
           CALL RANDOM_NUMBER(HARVEST=X)
           IORD           = MIN(NANG,MAX(1,INT(X*NANG+0.5)))
           ITMP           = RANDLIST(IORD)
           RANDLIST(IORD) = RANDLIST(K)
           RANDLIST(K)    = ITMP
        ENDDO


#ifdef USE_MPI

C       --- BEGIN MPI VERSION ----------------------------------- MPI
C       DISTRIBUTE PARTICLES TO PROCESSORS.
C       NANGLOC IS THE NUMBER OF PARTICLES ASSIGNED TO EACH PROCESSOR.

C       CREATE FORWARD FFTW3 PLAN FOR 2D FFT ON BI USING ONE THREAD
        !write(6,*) ' BP32F;  inv plan on bi,n : ',n

        CALL FMRS_PLAN(.TRUE.,BI,N,N,1, 1,+1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
   
        ALLOCATE(PSIZE(NPROCS) ,NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = 2 * NPROCS 
           CALL ERRT(46,'BP 32F; PSIZE & NBASE',MEMWANT)
           RETURN
        ENDIF

C       SETPART RETURNS THE SIZE OF THE LOCAL PIECE AND GLOBAL OFFSET.
C       PARTITIONS NANG DATA ITEMS EVENLY AMONG AVAILABLE PROCESSORS.
C       PSIZE HAS NUMBER OF PARTICLES, NBASE HAS STARTING LOCATION.
        CALL SETPART(NANG, PSIZE, NBASE)

C       NANGLOC IS THE # OF PARTICLES TO BE USED FOR CURRENT PROCESS.
        NANGLOC = PSIZE(MYPID+1)

C       2-D IMAGES ARE DISTRIBUTED AND HELD IN PRJLOC ON EACH PROCESSOR
        ALLOCATE(PRJBUF(NX,NX,PSIZE(1)),
     &           PRJLOC(NX,NX,NANGLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = NX*NX*PSIZE(1) + NX*NX*NANGLOC
           CALL ERRT(46,'BP 32F; PRJBUF, PRJLOC',MEMWANT)
           RETURN
        ENDIF

C       PROCESSOR 0 READS IMAGE FILES AND DISTRIBUTES THEM 
C       SO EACH PROCESSOR GETS DIFFERENT SET OF IMAGE FILES
C       (ASSUMES SUFFICIENT MEMORY TO HOLD NANG/NPROCS IMAGES)
C       FOR IPROC =1,  MYPID=0 READS AND KEEPS IMAGES FOR ITSELF
C       FOR IPROC =1,  MYPID>0 SKIPS READ 
C       FOR IPROC >1,  MYPID=0 READS AND BROADCASTS IMAGES
C       FOR IPROC >1,  MYPID>0 SKIPS READ AND RECEIVES  IMAGES 
           
        !if(mypid <= 0)write(6,'(a,i4)') 'In BP32Fq; nprocs:', nprocs
        !if(mypid <= 0)write(6,'(a,i4)') 'In BP32Fq; psize(1):', psize(1)

        DO IPROC = 1, NPROCS
           NANGLOC = PSIZE(IPROC)

C          READ IMAGES INTO THE PRJBUF BUFFER FIRST, THEN DISTRIBUTE

           DO JLOC = 1, NANGLOC
              JGLB = NBASE(IPROC) + JLOC
            
              NLET = 0     ! TO USE: lnblnkn IN FILGET
              CALL FILGET(FILPAT,FILNAM,NLET,INUMBRT(JGLB),IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
              MAXIM = 0

              CALL OPFILEC(0,   .FALSE.,  FILNAM, INPROJ, 'O',
     &                     IFORM,   NX,    NY,   NSL,    MAXIM,
     &                     'DUMMY', .FALSE., IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999

              IF (MYPID <= 0) THEN
C                ONLY PROCESS WITH MYPID = 0 NEEDS TO READ
                 DO IROW = 1,NY
                    CALL REDLIN1P(INPROJ,PRJBUF(1,IROW,JLOC),NX,IROW)
                 ENDDO
              ENDIF
              CLOSE(INPROJ)
           ENDDO

           IF (IPROC > 1) THEN
#ifdef MPI_DEBUG
               write(6,'(a,i4)') 'In BP32FQ: iproc: ', iproc
#endif

               IF  (MYPID .EQ. 0) THEN
C                 SEND PROJECTION IMAGES TO OTHER PROCESSOR(S)
#ifdef MPI_DEBUG
                  write(6,*) 'In BP32FQ; Sending to mypid= ', mypid
#endif
                  CALL MPI_SEND(PRJBUF , NX*NX*NANGLOC, MPI_REAL,
     &                          IPROC-1, IPROC-1, ICOMM, MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) ' *** BP32FQ: SEND ERROR!'
                     STOP
                  ENDIF

               ELSEIF (MYPID .EQ. IPROC-1) THEN
C                 RECEIVE PROJECTION IMAGES FROM PROCESSOR 0
#ifdef MPI_DEBUG
                  write(6,'(a,i4)') 'In BP32FQ; Receiving mypid: ', mypid
#endif
                  CALL MPI_RECV(PRJLOC, NX*NX*NANGLOC, MPI_REAL,
     &                          0, MPI_ANY_TAG, ICOMM, ISTAT , MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) ' *** BP32FQ: RECV FAILED'
                     STOP
                  ENDIF
#ifdef MPI_DEBUG
                  write(6,*)' In BP32Fq: mypid: ',mypid,' received' 
#endif
              ENDIF 

           ELSEIF (MYPID .EQ. 0) THEN
C             KEEP PROJECTION IMAGES FOR THIS PROCESS 

#ifdef MPI_DEBUG
              write(6,'(a,i4)') 'In BP32FQ; Keeping mypid: ', mypid
#endif
              DO JLOC = 1, NANGLOC
                 DO ISAM = 1, NX
                     DO JROW = 1, NX
                        PRJLOC(ISAM,JROW,JLOC) = PRJBUF(ISAM,JROW,JLOC)
                     ENDDO
                  ENDDO
               ENDDO
           ENDIF
        ENDDO

        !write(6,'(a,i4)') 'In BP32FQ: deallocating now, pid:',mypid

        IF (ALLOCATED(PRJBUF)) DEALLOCATE(PRJBUF)

        IF (.NOT. ANGINDOC) THEN
C           GET ANGLES FROM HEADER
            ANGBUFT(1) = INUMBRT(K)
            CALL LUNGETVALS(INPROJ,IAPLOC+1,8,ANGBUFT(2),IRTFLG)
            CALL BUILDM(INUMBRT,DM,1,ANGBUFT,.FALSE.,SSDUM,
     &                  .FALSE.,IRTFLG)
            IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
        CLOSE(INPROJ)

C       PERFORM CALCULATIONS IN PARALLEL NOW
        !if(mypid <= 0)write(6,'(a,i4)') 'In BP32Fq; calculating' 

        ALLOCATE (WELOC(0:NX,N,N), XELOC(0:NX,N,N), 
     &            WOLOC(0:NX,N,N), XOLOC(0:NX,N,N), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = 4*(NX+1)*N*N 
           CALL ERRT(46,'BP 3F; WELOC, XELOC, ...',MEMWANT)
           RETURN
        ENDIF

       !write(6,*) ' BP32Fq: xeloc zero = ', mypid
        DO K=1,N
           DO J=1,N
              DO I=0,NX
                 XELOC(I,J,K) = CMPLX(0.0,0.0)
                 XOLOC(I,J,K) = CMPLX(0.0,0.0)
                 WELOC(I,J,K) = 0.0
                 WOLOC(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

        INV     = +1      ! FORWARD FOURIER TRANSFORMS
        NANGLOC = PSIZE(MYPID+1)

        DO JLOC = 1, NANGLOC
           JGLB = NBASE(MYPID+1) + JLOC

C          PAD: PRJLOC  TO SIZE: N
           CALL PADD2(PRJLOC(1,1,JLOC),NX,BI,LSD,N)

C          FORWARD FOURIER TRANSFORM OF: BI
           !write(6,*) ' BP32F;  fft on bi,n : ',n
           CALL FMRS_2(BI,N,N,INV)

           DO J=1,N
              DO I=0,NX
                 BI(I,J) = BI(I,J) * (-1)**(I+J+1)
              ENDDO
           ENDDO

           DO  ISYM=1,MAXSYM
              IF (MAXSYM .GT. 1 )  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS = MATMUL(SM(:,:,ISYM),DM(:,:,JGLB))
              ELSE
                 DMS = DM(:,:,JGLB)
              ENDIF

             IF (RANDLIST(JGLB)) THEN
                 DO J=-NX+1,NX
                    CALL ONELINE(J,N,NX,XELOC,WELOC,BI,DMS)
                 ENDDO
              ELSE
                 DO J=-NX+1,NX
                    CALL ONELINE(J,N,NX,XOLOC,WOLOC,BI,DMS)
                 ENDDO
              ENDIF
           ENDDO
        ENDDO

        !write(6,*) ' before reduce ; n,NX,nangloc: ', n,NX,nangloc
        !write(6,*) ' xe:' , xeloc(0,1,1),xeloc(0,1,2),xeloc(75,75,75)
        !write(6,*) ' xo:' , xoloc(0,1,1),xoloc(0,1,2),xoloc(75,75,75)
        !write(6,*) ' we:' , weloc(0,1,1),weloc(0,1,2),weloc(75,75,75)
        !write(6,*) ' wo:' , woloc(0,1,1),woloc(0,1,2),woloc(75,75,75)

C       SUM UP X AND W FROM THE LOCAL PIECES (XLOC, WLOC)
C       RESIDING ON EACH PROCESSOR
        NVAL = (NX + 1) * N
        DO K3 = 1, N
           CALL ALLREDUCE_MPI('BP32FQ','XELOC',
     &              XELOC(0,1,K3),XE(0,1,K3),NVAL, 'X','S',ICOMM)
           CALL ALLREDUCE_MPI('BP32FQ','XOLOC',
     &              XOLOC(0,1,K3),XO(0,1,K3),NVAL, 'X','S',ICOMM)
           CALL ALLREDUCE_MPI('BP32FQ','WELOC',
     &              WELOC(0,1,K3),WE(0,1,K3),NVAL, 'R','S',ICOMM)
           CALL ALLREDUCE_MPI('BP32FQ','WOLOC',
     &              WOLOC(0,1,K3),WO(0,1,K3),NVAL, 'R','S',ICOMM)
        ENDDO 

        IF (ALLOCATED(PRJLOC))   DEALLOCATE(PRJLOC)
        IF (ALLOCATED(XOLOC))    DEALLOCATE (XOLOC)
        IF (ALLOCATED(XELOC))    DEALLOCATE (XELOC)
        IF (ALLOCATED(WOLOC))    DEALLOCATE (WOLOC)
        IF (ALLOCATED(WELOC))    DEALLOCATE (WELOC)

#ifdef MPI_DEBUG
        write(6,*) 'BP32FQ; Completed global sum, mypid: ', mypid
#endif



C       --------------------  END OF MPI VERSION ----------------------    
#else

C       CREATE FFTW3 PLAN FOR 2D FFT ON BI USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,BI,N,N,1, 0,+1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
#ifdef  SP_MP
        LN1 = LN + 1         ! WHY?? LN ALWAYS EQUALED: 5 (IN CALLER)
        LN1 = 6              
#endif

        NWANT1 = 1
        NWANT2 = 1
        DO 
c          write(6,*)  'Projection #: ',IMGNUM

           IF (CALLRTSQ) THEN
C             READ IMAGE INTO: PROJTEMP

C             Reg. numbers for angle & shift =(6,7,8)
              CALL READV(INPROJ,PROJTEMP, NXLD,NX, NX,NX,1)

              IF (USE_FBS_INTERP) THEN
C                ROTATE & SHIFT FROM: PROJTEMP  INTO: PROJ
	         CALL RTSF(PROJTEMP,PROJ, 
     &                     NXLD,NX,NX,
     &                     ANGBUF(7,IMGNUM), 1.0,
     &                     ANGBUF(8,IMGNUM),ANGBUF(9,IMGNUM),IRTFLG)

              ELSE
C                ROTATE & SHIFT FROM: PROJTEMP  INTO: PROJ
	         CALL RTSQ(PROJTEMP,PROJ, 
     &                     NX,NX, NX,NX,
     &                     ANGBUF(7,IMGNUM), 1.0,
     &                     ANGBUF(8,IMGNUM),ANGBUF(9,IMGNUM),IRTFLG)
              ENDIF

              IF (LUNROT > 0) THEN
                 CALL WRTVOL(LUNROT,NX,NX,1,1, PROJ,IRTFLG)
                 !CLOSE(LUNROT)
              ENDIF

              IF (VERBOSE) WRITE(NOUT,90)IMGNUM,
     &                                   ANGBUF(7,IMGNUM),
     &                                   ANGBUF(8,IMGNUM),
     &                                   ANGBUF(9,IMGNUM)
90            FORMAT('  IMAGE: ',I6,
     &               '  ANGLE: ',G10.3,
     &               '  SHIFT: (',G10.3,',',G10.3,')')
           ELSE
C             READ IMAGE INTO: PROJ
              CALL REDVOL(INPROJ,NX,NX, 1,1, PROJ,IRTFLG)
           ENDIF

           IF (.NOT. ANGINDOC) THEN
C             GET PROJECTION ANGLES FROM HEADER
              ANGBUFT(1) = INUMBRT(NWANT1)
              CALL LUNGETVALS(INPROJ,IAPLOC+1,8,ANGBUFT(2),IRTFLG)
              CALL BUILDM(INUMBRT,DM,1,ANGBUFT,.FALSE.,SSDUM,
     &                    .FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
           ENDIF

C          PAD: PROJ  TO SIZE: N
           CALL PADD2(PROJ,NX,BI,LSD,N)

C          FORWARD FOURIER TRANSFORM OF: BI
           INV = +1
           CALL FMRS_2(BI,N,N,INV)

c$omp      parallel do private(i,j)
           DO J=1,N
              DO I=0,NX
                 BI(I,J) = BI(I,J) * (-1)**(I+J+1)
              ENDDO
           ENDDO

           DO  ISYM=1,MAXSYM
              IF (MAXSYM. GT. 1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS = MATMUL(SM(:,:,ISYM),DM(:,:,IMGNUM))
              ELSE
                 DMS = DM(:,:,IMGNUM)
              ENDIF
#ifdef SP_MP
              IF (RANDLIST(NWANT1)) THEN
                 DO JT=1,LN1
c$omp               parallel do private(j)
                    DO J=-NX+JT,NX,LN1
                       CALL ONELINE(J,N,NX,XE,WE,BI,DMS)
                    ENDDO
                ENDDO
             ELSE
                DO JT=1,LN1
c$omp              parallel do private(j)
                   DO J=-NX+JT,NX,LN1
                      CALL ONELINE(J,N,NX,XO,WO,BI,DMS)
                   ENDDO
                ENDDO
             ENDIF
#else
             IF (RANDLIST(NWANT1)) THEN
                 DO J=-NX+1,NX
                    CALL ONELINE(J,N,NX,XE,WE,BI,DMS)
                 ENDDO
             ELSE
                 DO J=-NX+1,NX
                    CALL ONELINE(J,N,NX,XO,WO,BI,DMS)
                 ENDDO
             ENDIF
#endif
          ENDDO                           ! END OF SYMMETRIES LOOP

          IF (NWANT1 .GE. NANG) EXIT      ! END OF INPUT LIST
              
C         OPEN NEXT SET OF I/O FILES 
          CALL NEXTFILES(NWANT1, NWANT2,        INUMBRT,INUMBROUT, 
     &                   .FALSE.,LUNXM1,LUNXM2,
     &                   NANG,NANGT,            MAXIM1,MAXIM2,   
     &                   INPROJ,INPROJ,LUNROT,  FILPAT,FILPATOUT,
     &                   IMGNUM,IMGNUMOUT,IRTFLG) 

          IF (IRTFLG .LT. 0) EXIT         ! END OF INPUT STACK
          IF (IRTFLG .NE. 0) GOTO 9999    ! ERROR
        ENDDO                             ! END OF PROJECTIONS LOOP 
#endif
C       --------------------  END OF NON-MPI VERSION ------------------    

        !write(6,*) '   ' 
        !write(6,*) ' xe:' , xe(0,1,1),xe(0,1,2),xe(75,75,75)
        !write(6,*) ' xo:' , xo(0,1,1),xo(0,1,2),xo(75,75,75)
        !write(6,*) ' we:' , we(0,1,1),we(0,1,2),we(75,75,75)
        !write(6,*) ' wo:' , wo(0,1,1),wo(0,1,2),wo(75,75,75)


C       SYMMETRIZE PLANE 0 OF BOTH VOLUMES
c$omp   parallel sections
c$omp   section
        CALL  SYMPLANE0(XE,WE,NX,N)
c$omp   section
        CALL  SYMPLANE0(XO,WO,NX,N)
c$omp   end parallel sections

9999    IF (ALLOCATED(PROJ))      DEALLOCATE(PROJ)
        IF (ALLOCATED(BI))        DEALLOCATE(BI)
        IF (ALLOCATED(RANDLIST))  DEALLOCATE(RANDLIST)
        IF (ALLOCATED(INUMBROUT)) DEALLOCATE(INUMBROUT)
        CLOSE(LUNROTT)
        CLOSE(LUNXM2)

        END

C       ------------------- WINDKB2A -------------------------------

C       DERIVED FROM:  WINDKB2 (now in var3d.f) 

        SUBROUTINE WINDKB2A(BI,R, L,LSD,N, ALPHA,AAAA,NNN)

        REAL      :: BI(LSD,N,N)      ! INPUT
        REAL      :: R(L,L,L)         ! OUTPUT

        PARAMETER (QUADPI = 3.14159265358979323846)
        PARAMETER (TWOPI  = 2*QUADPI)

        IP = (N-L ) / 2 + MOD(L,2)

ccc$omp   parallel do private(i,j,k)
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 R(I,J,K) = BI(IP+I,IP+J,IP+K)
              ENDDO
           ENDDO
        ENDDO

        L2   = (L / 2)**2
        L2P  = (L / 2 - 1)**2
        IP   = L / 2 + 1
        XNU  = REAL(NNN) / 2.0
        
        RI   = RIBSL(ALPHA,XNU)

        WKB0 = ALPHA**XNU / RI
        QRT  = (TWOPI * AAAA)**2
        TNR  = 0.0
        M    = 0

        DO K=1,L
           KMIPSQ = (K-IP)**2

           DO J=1,L
              JMIPSQ = (J-IP)**2 + KMIPSQ

              DO I=1,L

C                SPHERE RADIUS
                 LR = JMIPSQ + (I-IP)**2

                 IF (LR <= L2) THEN
C                  INSIDE SPHERE RADIUS

                   SIGMA = QRT * LR - ALPHA * ALPHA

                   IF (ABS(SIGMA) < 1.0E-7) THEN
                     WKB = 1.0

                   ELSEIF(SIGMA > 0.0) THEN
C                    2PI A R > ALPHA
                     ART = SQRT(SIGMA)
                     RI  = RJBSL(ART, XNU)
                     WKB = WKB0 * RI / ART**XNU

                   ELSE
C                    2PI A R < ALPHA
                     ART = SQRT(ABS(SIGMA))
                     RI  = RIBSL(ART,XNU)
                     WKB = WKB0 * RI / ART**XNU
                   ENDIF

C                  DIVIDE BY WEIGHT?
                   R(I,J,K) = R(I,J,K) / ABS(WKB)

                   IF (LR >= L2P .AND. LR <= L2) THEN
C                     RUNNING SUM OF VALUES
                      TNR = TNR + R(I,J,K)
                      M   = M + 1
                   ENDIF
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        TNR = TNR / REAL(M)

c$omp   parallel do private(i,j,jmipsq,k,kmipsq,lr)
        DO K=1,L
           KMIPSQ = (K-IP)**2

           DO J=1,L
              JMIPSQ = (J-IP)**2 + KMIPSQ

              DO I=1,L

                 LR = JMIPSQ + (I-IP)**2

                 IF (LR <= L2) THEN
C                   INSIDE SPHERE
                    R(I,J,K) = R(I,J,K) - TNR
                 ELSE
C                   OUTSIDE SPHERE
                    R(I,J,K) = 0.0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END



C       ----------------SYMPLANE0 ---------------------------------------
 
        SUBROUTINE  SYMPLANE0(X,W,N2,N)

        REAL    :: W(0:N2,N,N)
        COMPLEX :: X(0:N2,N,N)

C       SYMMETRIZE PLANE 0
        DO IZA=2,N2
           DO IYA=2,N2
              X(0,IYA,IZA)         = X(0,IYA,IZA) + 
     &                               CONJG(X(0,N-IYA+2,N-IZA+2))
              W(0,IYA,IZA)         = W(0,IYA,IZA) +
     &                               W(0,N-IYA+2,N-IZA+2)
              X(0,N-IYA+2,N-IZA+2) = CONJG(X(0,IYA,IZA))
              W(0,N-IYA+2,N-IZA+2) = W(0,IYA,IZA)
              X(0,N-IYA+2,IZA)     = X(0,N-IYA+2,IZA) +
     &                               CONJG(X(0,IYA,N-IZA+2))
              W(0,N-IYA+2,IZA)     = W(0,N-IYA+2,IZA) +
     &                               W(0,IYA,N-IZA+2)
              X(0,IYA,N-IZA+2)     = CONJG(X(0,N-IYA+2,IZA))
              W(0,IYA,N-IZA+2)     = W(0,N-IYA+2,IZA)
           ENDDO
        ENDDO

        DO IYA=2,N2
           X(0,IYA,1)     = X(0,IYA,1)+CONJG(X(0,N-IYA+2,1))
           W(0,IYA,1)     = W(0,IYA,1)+W(0,N-IYA+2,1)
           X(0,N-IYA+2,1) = CONJG(X(0,IYA,1))
           W(0,N-IYA+2,1) = W(0,IYA,1)
        ENDDO

        DO IZA=2,N2
           X(0,1,IZA)     = X(0,1,IZA)+CONJG(X(0,1,N-IZA+2))
           W(0,1,IZA)     = W(0,1,IZA)+W(0,1,N-IZA+2)
           X(0,1,N-IZA+2) = CONJG(X(0,1,IZA))
           W(0,1,N-IZA+2) = W(0,1,IZA)
        ENDDO

        END

C       ---------ADDADA ---------------------------------------

        SUBROUTINE  ADDADA(X,Y,N)

        REAL ::  X(N),Y(N)

C       JUST A SIMPLE ELEMENT BY ELEMENT SUM OF THE TWO ARRAYS 

c$omp   parallel do private(k)
        DO K=1,N
           X(K) = X(K) + Y(K)
        ENDDO

        END

@


1.68
log
@moved wind2bk.f to var3d.f
@
text
@d4 1
a4 1
C  BP32F_DL.F                                      JAN 00 P.A. Penczek
d21 1
d47 1
a47 1
C  BP32F_DL(CALLRTSQ)
d49 1
a49 1
C  PURPOSE:  FOR: 'BPD 32F' IMPROVED WITH LESS MEMORY REQUIRED AND
d52 2
d57 1
a57 1
        SUBROUTINE BP32F_DL(CALLRTSQ)
a132 1

d139 1
d159 1
a159 2
           CALL BUILDM1(ILIST,DM,9,NANG,ANGBUF,.FALSE.,SSDUM,
     &                 .TRUE.,IRTFLG)
d217 1
a217 1
C       BP32FQ_DL(NX,XE,WE,XO,WO,LSD,N
d219 1
a219 1
        CALL BP32FQ_DL(NX, XE,WE,XO,WO,LSD,N2, CALLRTSQ,FILPAT,
d431 1
a431 1
C       ---------------- BP32FQ_DL -----------------------------------
d433 1
a433 1
        SUBROUTINE BP32FQ_DL(NX,XE,WE,XO,WO,LSD,N, CALLRTSQ,FILPAT,
d513 1
a513 1
              CALL ERRT(46,'BP32FQ_DL; INUMBROUT', NANG)
d539 1
a539 1
           CALL ERRT(46,'BPFQ_DL; PROJ, ...',MEMWANT)
d945 1
d947 2
a948 3
        SUBROUTINE WINDKB2A(BI,R,L,LSD,N,ALPHA,AAAA,NNN)

        DIMENSION  R(L,L,L), BI(LSD,N,N)
d951 1
a951 1
        PARAMETER (TWOPI = 2*QUADPI)
d954 2
d964 4
a967 4
        L2   = (L/2)**2
        L2P  = (L/2-1)**2
        IP   = L / 2+1
        XNU  = REAL(NNN) / 2.
d972 1
a972 1
        QRT  = (TWOPI*AAAA)**2
d975 1
d977 2
d980 2
a982 5
                 LR = (K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR<=L2) THEN
                 SIGMA = QRT*LR-ALPHA*ALPHA
                  IF (ABS(SIGMA).LT.1.0E-7) THEN
                     WKB=1.0
d984 12
a995 1
                  ELSEIF(SIGMA.GT.0.0) THEN
d999 1
a999 1
                     WKB = WKB0*RI/ART**XNU
d1001 1
a1001 1
                  ELSE
d1005 5
a1009 2
                     WKB = WKB0*RI/ART**XNU
                  ENDIF
d1011 5
a1015 5
                  R(I,J,K) = R(I,J,K) / ABS(WKB)
                  IF (LR .GE. L2P .AND. LR <= L2) THEN
                      TNR = TNR+R(I,J,K)
                      M   = M+1
                  ENDIF
d1020 1
d1022 2
a1023 1
c$omp   parallel do private(i,j,k,lr)
d1025 2
d1028 2
d1031 3
a1033 1
                 LR = (K-IP)**2 + (J-IP)**2 + (I-IP)**2
d1035 1
d1038 1
d1053 2
a1054 2
        DIMENSION  W(0:N2,N,N)
        COMPLEX  X(0:N2,N,N)
d1059 12
a1070 8
              X(0,IYA,IZA)=X(0,IYA,IZA)+CONJG(X(0,N-IYA+2,N-IZA+2))
              W(0,IYA,IZA)=W(0,IYA,IZA)+W(0,N-IYA+2,N-IZA+2)
              X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
              W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
              X(0,N-IYA+2,IZA)=X(0,N-IYA+2,IZA)+CONJG(X(0,IYA,N-IZA+2))
              W(0,N-IYA+2,IZA)=W(0,N-IYA+2,IZA)+W(0,IYA,N-IZA+2)
              X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
              W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
d1075 4
a1078 4
           X(0,IYA,1)=X(0,IYA,1)+CONJG(X(0,N-IYA+2,1))
           W(0,IYA,1)=W(0,IYA,1)+W(0,N-IYA+2,1)
           X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
           W(0,N-IYA+2,1)=W(0,IYA,1)
d1082 4
a1085 4
           X(0,1,IZA)=X(0,1,IZA)+CONJG(X(0,1,N-IZA+2))
           W(0,1,IZA)=W(0,1,IZA)+W(0,1,N-IZA+2)
           X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
           W(0,1,N-IZA+2)=W(0,1,IZA)
d1094 3
a1096 1
        DIMENSION  X(N),Y(N)
d1100 1
a1100 1
           X(K) = X(K)+Y(K)
@


1.67
log
@NIMAXPLUS for ILIST and more images
@
text
@d941 3
a1018 79

C       ------------------- WINDKB2 -------------------------------

        SUBROUTINE WINDKB2(BI,R,L,LSD,N)

        DIMENSION  R(L,L,L),BI(LSD,N,N)
        COMMON  /BESSEL_PARAM/  ALPHA,AAAA,NNN

        PARAMETER (QUADPI = 3.14159265358979323846)
        PARAMETER (TWOPI = 2*QUADPI)

        IP = (N-L)/2+MOD(L,2)
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 R(I,J,K) = BI(IP+I,IP+J,IP+K)
              ENDDO
           ENDDO
        ENDDO

        L2  = (L/2)**2
        L2P = (L/2-1)**2
        IP  = L/2+1
        XNU = REAL(NNN)/2.
        
        RI = RIBSL(ALPHA,XNU)
C       IF (ABS(RI-RIN).GT.1.E-5)  PRINT  *,'BESSIK'

        WKB0 = ALPHA**XNU/RI
        QRT  = (TWOPI*AAAA)**2
        TNR  = 0.0
        M    = 0
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 LR = (K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR<=L2) THEN
                 SIGMA=QRT*LR-ALPHA*ALPHA
                  IF (ABS(SIGMA).LT.1.0E-7)  THEN
                     WKB=1.0
                  ELSEIF(SIGMA.GT.0.0)  THEN
C                    2PI A R > ALPHA
                     ART = SQRT(SIGMA)
                     RI = RJBSL(ART, XNU)
C       if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessjy',i,j,k
                     WKB=WKB0*RI/ART**XNU
                  ELSE
C                    2PI A R < ALPHA
                     ART = SQRT(ABS(SIGMA))
                     RI = RIBSL(ART,XNU)
C       if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessik',i,j,k,ri,rin
                     WKB=WKB0*RI/ART**XNU
                  ENDIF
                  R(I,J,K) = R(I,J,K)/ABS(WKB)
                  IF (LR .GE. L2P .AND. LR <= L2) THEN
                      TNR = TNR+R(I,J,K)
                      M   = M+1
                  ENDIF
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        TNR = TNR/REAL(M)
c$omp   parallel do private(i,j,k,lr)
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR<=L2) THEN
                    R(I,J,K)=R(I,J,K)-TNR
                 ELSE
                    R(I,J,K)=0.0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END
@


1.66
log
@no need to: !CLOSE(LUNROT).
@
text
@d20 1
d23 3
a25 2
C=* From: SPIDER - MODULAR IMAGE PROCESSING SYSTEM                     *
C=* Copyright (C)2002,2012 P. A. Penczek & ArDean Leith                *
d68 1
d71 1
a71 1
        CHARACTER(LEN=1)       :: NULL
d90 7
a96 3
        NULL   = CHAR(0)

        NILMAX = NIMAX
d103 1
a103 1
     &             .FALSE., INUMBR,NILMAX, 
d112 1
a112 1
        MAXNUM = MAXVAL(INUMBR(1:NANG))
d115 1
a115 1
        IF (MYPID .LE. 0) WRITE(NOUT,2001) NANG
d156 1
a156 1
           CALL BUILDM1(INUMBR,DM,9,NANG,ANGBUF,.FALSE.,SSDUM,
d206 1
a206 1
           IF (S .LE. AAAA)  THEN
d218 1
a218 1
     &               INPROJ,ANGBUF,INUMBR,NANG, 
d248 1
a248 1
        IF (MYPID .LE. 0) CLOSE(IOPIC)
d260 1
a260 1
        IF (MYPID .LE. 0) CLOSE(IOPIC)
d310 1
a310 1
        IF (MYPID .LE. 0) CLOSE(IOPIC)
d372 1
a372 1
        IF (MYPID .LE. 0) CLOSE(IOPIC)
d408 1
a408 1
        IF (MYPID .LE. 0) CLOSE(IOPIC)
d413 1
d620 1
a620 1
              IF (MYPID .LE. 0) THEN
d972 1
a972 1
                 IF (LR.LE.L2) THEN
d991 1
a991 1
                  IF (LR .GE. L2P .AND. LR .LE. L2) THEN
d1005 1
a1005 1
                 IF (LR .LE. L2) THEN
d1052 1
a1052 1
                 IF (LR.LE.L2) THEN
d1070 3
a1072 3
                  IF (LR.GE.L2P .AND. LR.LE.L2) THEN
                      TNR=TNR+R(I,J,K)
                      M=M+1
d1078 1
d1085 1
a1085 1
                 IF (LR.LE.L2) THEN
d1105 2
a1106 2
        DO  IZA=2,N2
           DO  IYA=2,N2
d1118 1
a1118 1
        DO  IYA=2,N2
d1125 1
a1125 1
        DO  IZA=2,N2
d1134 1
a1134 1
C----------------ADDADA ---------------------------------------
d1141 1
a1141 1
        DO  K=1,N
d1144 1
@


1.65
log
@NSAM --> NX, RTSQ PARAM
@
text
@d456 1
a456 1
        INTEGER, PARAMETER    :: LUNXM2 = 81 
d816 1
a816 1
              IF (LUNROT .GT. 0) THEN
d818 1
a818 1
                 CLOSE(LUNROT)
d825 1
a825 1
90            FORMAT(' IMAGE: ',I6,
d893 1
a893 1
             
@


1.64
log
@ROT2QS --> RTSQ
@
text
@d4 16
a19 15
C  BP32F_DL.F                                    JAN   00
C              ANGLES IN HEADER                  JUL   01 ArDean Leith
C              OPFILE 'U'                        FEB   02 ArDean Leith
C              BESSELS                           MAY   02 P.A. Penczek
C              OPFILEC                           FEB   03 ArDean Leith
C              BUILDM PARAMETERS                 JUL   03 ArDean Leith
C              BUILDM PARAMETERS                 SEP   03 ArDean Leith
C              MPI                               OCT   03 CHAO YANG
C              REWRITE                           DEC   06 ArDean Leith
C              MPI CHANGES                       OCT   06 ArDean Leith
C              MPI READV1P BUG                   DEC   09 ArDean Leith
C              OPFILES PARAMETERS                DEC   10 ArDean Leith
C              PREVIOUSLY NAMED WIW32**          JAN   11 ArDean Leith
C              MPI HAD UNDEFINED NROW BUG        MAR   11 ArDean Leith
C              ROT2QS --> RTSQ RENAMED           DEC   11 ARDEAN LEITH
d23 1
a23 1
C=* Copyright (C)2002,2011 P. A. Penczek & ArDean Leith                *
d94 1
a94 1
     &             ITYPE,NSAM,NROW,NSLICE,MAXIM1,
d100 1
a100 1
        IF (NSAM .NE. NROW) THEN
d131 1
a131 1
        N2   = 2 * NSAM
d166 4
a169 4
        ALLOCATE(XE(0:NSAM, N2,N2),
     &           WE(0:NSAM, N2,N2),
     &           XO(0:NSAM, N2,N2), 
     &           WO(0:NSAM, N2,N2), STAT=IRTFLG)
d173 1
a173 1
           MWANT = 6 * (NSAM+1) * N2 * N2
d186 1
a186 1
        R     = NSAM / 2
d208 1
a208 1
C       BP32FQ_DL(NSAM,XE,WE,XO,WO,LSD,N
d210 1
a210 1
        CALL BP32FQ_DL(NSAM, XE,WE,XO,WO,LSD,N2, CALLRTSQ,FILPAT,
d265 3
a267 3
        !write(6,*) 'BP32F;  nrmw2 xe : ',nsam,n2
        CALL NRMW2(XE,WE,NSAM,N2)
        CALL WINDKB2A(XE,XE,NSAM,LSD,N2,ALPHA,AAAA,NNN)
d272 1
a272 1
           ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
d274 1
a274 1
              MEMWANT = NSAM * NSAM * NSAM 
d278 1
a278 1
           CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
d282 1
a282 1
                 DO I=0,NSAM
d287 2
a288 2
           IF (MOD(NSAM,2) .EQ. 0)  THEN
              KNX = NSAM/2-1
d290 1
a290 1
              KNX = NSAM/2
d292 1
a292 1
           KLX = -NSAM/2
d296 1
a296 1
C       WRITE EVEN VOLUME TO FILE: EVENVOL,  NOTE: NSAM=NROW=NSLICE 
d298 1
a298 1
        CALL OPFILEC(0,.FALSE.,EVENVOL,IOPIC,'U',ITYPE,NSAM,NSAM,NSAM,
d301 1
a301 1
        CALL WRTVOL(IOPIC,NSAM,NSAM, 1,NSAM, XE,IRTFLG)
d340 3
a342 3
        !write(6,*) ' BP32F;  nrmw2 xe : ',nsam,n2
        CALL NRMW2(XE,WE,NSAM,N2)
        CALL WINDKB2A(XE,XE,NSAM,LSD,N2,ALPHA,AAAA,NNN)
d347 1
a347 1
           CALL COP(XE, TEMP,NSAM*NSAM*NSAM)
d351 1
a351 1
                 DO I=0,NSAM
d361 1
a361 1
        CALL OPFILEC(0,.FALSE.,BOTHVOL,IOPIC,'U',ITYPE,NSAM,NSAM,NSAM,
d364 1
a364 1
        CALL WRTVOL(IOPIC,NSAM,NSAM, 1,NSAM, XE,IRTFLG)
d377 3
a379 3
        !write(6,*) ' BP32F;  nrmw2 xo : ',nsam,n2
        CALL NRMW2(XO,WO,NSAM,N2)
        CALL WINDKB2A(XO,XO,NSAM,LSD,N2,ALPHA,AAAA,NNN)
d383 1
a383 1
           CALL COP(XO,TEMP, NSAM*NSAM*NSAM)
d387 1
a387 1
                 DO I=0,NSAM
d397 1
a397 1
        CALL OPFILEC(0,.FALSE.,ODDVOL,IOPIC,'U',ITYPE,NSAM,NSAM,NSAM,
d400 1
a400 1
        CALL WRTVOL(IOPIC,NSAM,NSAM, 1,NSAM, XO,IRTFLG)
d423 1
a423 1
        SUBROUTINE BP32FQ_DL(NSAM,XE,WE,XO,WO,LSD,N, CALLRTSQ,FILPAT,
d443 4
a446 4
        REAL                  :: WE(0:NSAM,N,N)
        REAL                  :: WO(0:NSAM,N,N)
        COMPLEX               :: XE(0:NSAM,N,N)
        COMPLEX               :: XO(0:NSAM,N,N)
d483 1
a483 1
              DO I=0,NSAM
d494 2
d497 2
d500 1
a500 1
           NSIZE = NSAM
d511 1
a511 1
     &            ITYPE,NSAM,NSAM,1, MAXIM2,
d519 2
d523 3
a525 3
        ALLOCATE (PROJ(NSAM,NSAM),
     &            PROJTEMP(NSAM,NSIZE),
     &            BI(0:NSAM,N),
d528 1
a528 1
           MEMWANT = NSAM*NSAM + NSAM*NSIZE + 2*(NSAM+1)*N + NANG 
d574 2
a575 2
        ALLOCATE(PRJBUF(NSAM,NSAM,PSIZE(1)),
     &           PRJLOC(NSAM,NSAM,NANGLOC),
d578 1
a578 1
           MEMWANT = NSAM*NSAM*PSIZE(1) + NSAM*NSAM*NANGLOC
d608 1
a608 1
     &                     IFORM,   NSAM,    NROW,   NSL,    MAXIM,
d614 2
a615 2
                 DO IROW = 1,NROW
                    CALL REDLIN1P(INPROJ,PRJBUF(1,IROW,JLOC),NSAM,IROW)
d631 1
a631 1
                  CALL MPI_SEND(PRJBUF , NSAM*NSAM*NANGLOC, MPI_REAL,
d643 1
a643 1
                  CALL MPI_RECV(PRJLOC, NSAM*NSAM*NANGLOC, MPI_REAL,
d661 2
a662 2
                 DO ISAM = 1, NSAM
                     DO JROW = 1, NSAM
d687 2
a688 2
        ALLOCATE (WELOC(0:NSAM,N,N), XELOC(0:NSAM,N,N), 
     &            WOLOC(0:NSAM,N,N), XOLOC(0:NSAM,N,N), STAT=IRTFLG)
d690 1
a690 1
           MEMWANT = 4*(NSAM+1)*N*N 
d698 1
a698 1
              DO I=0,NSAM
d714 1
a714 1
           CALL PADD2(PRJLOC(1,1,JLOC),NSAM,BI,LSD,N)
d721 1
a721 1
              DO I=0,NSAM
d735 2
a736 2
                 DO J=-NSAM+1,NSAM
                    CALL ONELINE(J,N,NSAM,XELOC,WELOC,BI,DMS)
d739 2
a740 2
                 DO J=-NSAM+1,NSAM
                    CALL ONELINE(J,N,NSAM,XOLOC,WOLOC,BI,DMS)
d746 1
a746 1
        !write(6,*) ' before reduce ; n,nsam,nangloc: ', n,nsam,nangloc
d754 1
a754 1
        NVAL = (NSAM + 1) * N
d796 24
a819 2
C             READ IMAGE AND ROTATE, SCALE & SHIFT INTO: PROJ
              CALL REDVOL(INPROJ,NSAM,NSAM, 1,1,PROJTEMP,IRTFLG)
a820 2
C             REG. NUMBERS FOR ANGLE, SCALE,& SHIFT =(6,0,7,8)
   
a827 7

              CALL RTSQ(PROJTEMP,PROJ, NSAM,NSAM,
     &                    ANGBUF(7,IMGNUM),1.0,ANGBUF(8,IMGNUM),
     &                    ANGBUF(9,IMGNUM),0,0)
              IF (LUNROT .GT. 0) THEN
                 CALL WRTVOL(LUNROT,NSAM,NSAM,1,1, PROJ,IRTFLG)
              ENDIF
d830 1
a830 1
              CALL REDVOL(INPROJ,NSAM,NSAM, 1,1, PROJ,IRTFLG)
d843 1
a843 1
           CALL PADD2(PROJ,NSAM,BI,LSD,N)
d851 1
a851 1
              DO I=0,NSAM
d867 2
a868 2
                    DO J=-NSAM+JT,NSAM,LN1
                       CALL ONELINE(J,N,NSAM,XE,WE,BI,DMS)
d874 2
a875 2
                   DO J=-NSAM+JT,NSAM,LN1
                      CALL ONELINE(J,N,NSAM,XO,WO,BI,DMS)
d881 2
a882 2
                 DO J=-NSAM+1,NSAM
                    CALL ONELINE(J,N,NSAM,XE,WE,BI,DMS)
d885 2
a886 2
                 DO J=-NSAM+1,NSAM
                    CALL ONELINE(J,N,NSAM,XO,WO,BI,DMS)
d917 1
a917 1
        CALL  SYMPLANE0(XE,WE,NSAM,N)
d919 1
a919 1
        CALL  SYMPLANE0(XO,WO,NSAM,N)
@


1.63
log
@mpi bug fixed
@
text
@d18 1
d22 1
a22 1
C=* Copyright (C)2002,2011 P. A. Penczek & ArDean Leith                               *
d45 2
a46 2
C   PURPOSE:  FOR: 'BPD 32F' IMPROVED WITH LESS MEMORY REQUIRED AND
C             MORE STACK USAGE.
a50 1

d802 1
a802 1
              CALL ROT2QS(PROJTEMP,PROJ, NSAM,NSAM,
@


1.62
log
@rot2qs_dl --> rot2qs
@
text
@d4 1
a4 1
C  BP32F_DL.F                                   JAN   00
d17 1
d50 1
d90 1
a90 1
C       OPEN IMPUT IMAGE FILES 
d99 5
d116 1
d120 2
d155 4
a158 1
 
d178 1
a178 1
c       write(6,*) ' bp32f;  inv plan on xe: ',n2
d185 5
a189 5
	R     = NSAM / 2
	V     = REAL(LN-1) / 2.0 / REAL(N2)
	ALPHA = 6.5
	AAAA  = 0.9*V
	NNN   = 3
d192 1
a192 1
 	B0   = SQRT(ALPHA) * BESI1(ALPHA)
d197 7
a203 7
	   S = REAL(I) / FLTB / N2
	   IF (S .LE. AAAA)  THEN
	      X       = SQRT(1.0 - (S/AAAA)**2)
	      TABI(I) = SQRT(ALPHA*X) * BESI1(ALPHA*X) / B0
	   ELSE
	      TABI(I) = 0.0
	   ENDIF
d228 3
d237 2
d242 3
d250 1
d254 3
d264 1
a264 1
c       write(6,*) 'BP32F;  nrmw2 xe : ',nsam,n2
d269 1
a269 1
	IF (MAXSYM .GT. 1)  THEN
d277 1
a277 1
	   CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
d292 2
a293 2
	   CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	ENDIF
d304 3
d315 3
d326 4
a329 1
c       write(6,*) 'vals: rec ',xe(1,1,1),xe(1,1,1),
d339 1
a339 1
C       write(6,*) ' BP32F;  nrmw2 xe : ',nsam,n2
d344 1
a344 1
	IF (MAXSYM .GT. 1)  THEN
d346 1
a346 1
	   CALL COP(XE, TEMP,NSAM*NSAM*NSAM)
d355 2
a356 2
	   CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	ENDIF
d366 1
a366 1
c       write(6,*) 'vals: end ',xe(1,1,1),xe(1,1,1),
d370 2
d376 1
a376 1
C       write(6,*) ' BP32F;  nrmw2 xo : ',nsam,n2
d380 1
a380 1
	IF (MAXSYM .GT. 1)  THEN
d382 1
a382 1
	   CALL COP(XO,TEMP, NSAM*NSAM*NSAM)
d391 2
a392 2
	   CALL SYMVOL(TEMP,XO,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	ENDIF
d402 2
d451 1
a451 1
	LOGICAL               :: ITMP
d473 1
a473 1
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
d527 2
a528 2
	RANDLIST(1:NANG/2)      = .TRUE.
	RANDLIST(NANG/2+1:NANG) = .FALSE.
d530 1
a530 1
	DO  K=1,NANG
d533 4
a536 4
	   ITMP           = RANDLIST(IORD)
	   RANDLIST(IORD) = RANDLIST(K)
	   RANDLIST(K)    = ITMP
	ENDDO
d546 1
a546 1
c       write(6,*) ' BP32F;  inv plan on bi,n : ',n
d550 1
a550 1
 
d576 1
a576 1
C       PROCESSOR 0 READS IMAGE FILES AND DISTRIBUTE THEM 
d583 3
d600 3
a602 3
              CALL OPFILEC(0      ,.FALSE., FILNAM, INPROJ, 'O'  ,
     &                     IFORM  , NSAM  , NSAM  , NSL   , MAXIM,
     &                     'DUMMY',.FALSE., IRTFLG)
a604 1
C             ONLY PROCESS WITH MYPID = 0 NEEDS TO READ
d606 1
d614 1
a614 1
           IF (IPROC .GT. 1) THEN
d616 1
a616 1
                  write(6,*) 'BP32Fq: iproc = ', iproc
d622 1
a622 1
                  write(6,*) 'bp32fq: sending to mypid= ', mypid
d627 1
a627 1
                     WRITE(6,*) ' BP32FQ: SEND ERROR!'
d634 1
a634 1
                  WRITE(6,*) 'BP32Fq: receiving mypid: ', mypid
d639 1
a639 1
                     WRITE(6,*) ' BP32FQ: RECV FAILED'
d643 1
a643 1
                  write(6,*)' BP32Fq: mypid: ',mypid,' received' 
d651 1
a651 1
              write(6,*) 'bp32fq: keeping mypid= ', mypid
d662 3
d678 1
d688 1
a688 1
c       write(6,*) ' BP32Fq: xeloc zero = ', mypid
d710 1
a710 1
c          write(6,*) ' BP32F;  fft on bi,n : ',n
d739 5
a743 5
c       write(6,*) ' before reduce ; n,nsam,nangloc: ', n,nsam,nangloc
c       write(6,*) ' xe:' , xeloc(0,1,1),xeloc(0,1,2),xeloc(75,75,75)
c       write(6,*) ' xo:' , xoloc(0,1,1),xoloc(0,1,2),xoloc(75,75,75)
c       write(6,*) ' we:' , weloc(0,1,1),weloc(0,1,2),weloc(75,75,75)
c       write(6,*) ' wo:' , woloc(0,1,1),woloc(0,1,2),woloc(75,75,75)
d766 1
a766 1
        write(6,*) 'BP32Fq: completed global sum, mypid: ', mypid
d779 2
a780 2
	LN1 = LN + 1         ! WHY?? LN ALWAYS EQUALED: 5 (IN CALLER)
	LN1 = 6              
d802 1
a802 1
	      CALL ROT2QS(PROJTEMP,PROJ, NSAM,NSAM,
d845 1
a845 1
	         DO JT=1,LN1
d852 1
a852 1
	        DO JT=1,LN1
d887 5
a891 5
c       write(6,*) '   ' 
c       write(6,*) ' xe:' , xe(0,1,1),xe(0,1,2),xe(75,75,75)
c       write(6,*) ' xo:' , xo(0,1,1),xo(0,1,2),xo(75,75,75)
c       write(6,*) ' we:' , we(0,1,1),we(0,1,2),we(75,75,75)
c       write(6,*) ' wo:' , wo(0,1,1),wo(0,1,2),wo(75,75,75)
d917 2
a918 2
	PARAMETER (QUADPI = 3.14159265358979323846)
	PARAMETER (TWOPI = 2*QUADPI)
d932 3
a934 3
	XNU  = REAL(NNN) / 2.
	
	RI   = RIBSL(ALPHA,XNU)
d936 2
a937 2
	WKB0 = ALPHA**XNU / RI
	QRT  = (TWOPI*AAAA)**2
d945 3
a947 3
		 SIGMA = QRT*LR-ALPHA*ALPHA
	          IF (ABS(SIGMA).LT.1.0E-7) THEN
	             WKB=1.0
d949 1
a949 1
	          ELSEIF(SIGMA.GT.0.0) THEN
d951 3
a953 3
		     ART = SQRT(SIGMA)
      		     RI  = RJBSL(ART, XNU)
	             WKB = WKB0*RI/ART**XNU
d955 1
a955 1
	          ELSE
d957 4
a960 4
		     ART = SQRT(ABS(SIGMA))
		     RI  = RIBSL(ART,XNU)
	             WKB = WKB0*RI/ART**XNU
	          ENDIF
d994 1
a994 1
	COMMON  /BESSEL_PARAM/  ALPHA,AAAA,NNN
d996 2
a997 2
	PARAMETER (QUADPI = 3.14159265358979323846)
	PARAMETER (TWOPI = 2*QUADPI)
d1011 4
a1014 4
	XNU = REAL(NNN)/2.
	
	RI = RIBSL(ALPHA,XNU)
C	IF (ABS(RI-RIN).GT.1.E-5)  PRINT  *,'BESSIK'
d1016 2
a1017 2
	WKB0 = ALPHA**XNU/RI
	QRT  = (TWOPI*AAAA)**2
d1025 4
a1028 4
		 SIGMA=QRT*LR-ALPHA*ALPHA
	          IF (ABS(SIGMA).LT.1.0E-7)  THEN
	             WKB=1.0
	          ELSEIF(SIGMA.GT.0.0)  THEN
d1030 5
a1034 5
		     ART = SQRT(SIGMA)
      		     RI = RJBSL(ART, XNU)
C	if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessjy',i,j,k
	             WKB=WKB0*RI/ART**XNU
	          ELSE
d1036 5
a1040 5
		     ART = SQRT(ABS(SIGMA))
		     RI = RIBSL(ART,XNU)
C	if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessik',i,j,k,ri,rin
	             WKB=WKB0*RI/ART**XNU
	          ENDIF
@


1.61
log
@no () on psize, nbase (typo)
@
text
@d757 1
a757 1
	      CALL ROT2QS_DL(PROJTEMP,PROJ, NSAM,NSAM,
@


1.60
log
@renamed from wiw32.f
@
text
@d249 1
a249 1
              CALL ERRT(46,'BP 32F, TEMP',MEMWANT)
d427 1
a427 1
        INTEGER, ALLOCATABLE  :: PSIZE, NBASE
d460 1
a460 1
              CALL ERRT(46,'INUMBROUT', NANG)
d484 1
a484 1
           CALL ERRT(46,'BP 32F, PROJ, ...',MEMWANT)
d516 1
a516 1
           CALL ERRT(46,'BP 32F, PSIZE & NBASE',MEMWANT)
d534 1
a534 1
           CALL ERRT(46,'BP 32F, PRJBUF, PRJLOC',MEMWANT)
d639 1
a639 1
           CALL ERRT(46,'BP 3F, WELOC, XELOC, ...',MEMWANT)
@


1.59
log
@ opfiles parameters
@
text
@d4 1
a4 1
C  WIW32D_DL.F                                   JAN   00
d16 1
d20 1
a20 1
C=* Copyright (C)2002,2009 P. A. Penczek                               *
d41 1
a41 1
C  WIW32D_DL(CALLRTSQ)
d49 1
a49 1
        SUBROUTINE WIW32D_DL(CALLRTSQ)
d165 1
a165 1
c       write(6,*) ' wiw32d;  inv plan on xe: ',n2
d193 2
a194 2
C       WIW32DQ(NS,XE,WE,XO,WO,LSD,N,N2, 
C       WIW32DQ_DL(NSAM,XE,WE,XO,WO,LSD,N
d196 1
a196 1
        CALL WIW32DQ_DL(NSAM, XE,WE,XO,WO,LSD,N2, CALLRTSQ,FILPAT,
d239 1
a239 1
c       write(6,*) 'wiw32d;  nrmw2 xe : ',nsam,n2
d305 1
a305 1
C       write(6,*) ' wiw32d;  nrmw2 xe : ',nsam,n2
d340 1
a340 1
C       write(6,*) ' wiw32d;  nrmw2 xo : ',nsam,n2
d382 1
a382 1
C       ---------------- WIW32DQ_DL -----------------------------------
d384 1
a384 1
        SUBROUTINE WIW32DQ_DL(NSAM,XE,WE,XO,WO,LSD,N, CALLRTSQ,FILPAT,
d508 1
a508 1
c       write(6,*) ' wiw32d;  inv plan on bi,n : ',n
d575 1
a575 1
                  write(6,*) 'wiw32dq: iproc = ', iproc
d581 1
a581 1
                  write(6,*) 'wiw32dq: sending to mypid= ', mypid
d586 1
a586 1
                     WRITE(6,*) ' WIW32DQ: SEND ERROR!'
d593 1
a593 1
                  WRITE(6,*) 'wiw32dq: receiving mypid: ', mypid
d598 1
a598 1
                     WRITE(6,*) ' WIW32DQ: RECV FAILED'
d602 1
a602 1
                  write(6,*)' wiw32dq: mypid: ',mypid,' received' 
d610 1
a610 1
              write(6,*) 'wiw32dq: keeping mypid= ', mypid
d643 1
a643 1
c       write(6,*) ' wiw32dq: xeloc zero = ', mypid
d665 1
a665 1
c          write(6,*) ' wiw32d;  fft on bi,n : ',n
d704 1
a704 1
           CALL ALLREDUCE_MPI('WIW32DQ','XELOC',
d706 1
a706 1
           CALL ALLREDUCE_MPI('WIW32DQ','XOLOC',
d708 1
a708 1
           CALL ALLREDUCE_MPI('WIW32DQ','WELOC',
d710 1
a710 1
           CALL ALLREDUCE_MPI('WIW32DQ','WOLOC',
d721 1
a721 1
        write(6,*) 'wiw32dq: completed global sum, mypid: ', mypid
@


1.58
log
@MPI READV1P BUG
@
text
@d4 12
a15 11
C  WIW32D_DL.F                                01/10/00
C                        ANGLES IN HEADER     JULY  01 ArDean Leith
C                        OPFILE 'U'           FEB   02 ArDean Leith
C                        BESSELS              05/03/02 P.A. Penczek
C                        OPFILEC              FEB   03 ArDean Leith
C                        BUILDM PARAMETERS    JUL   03 ArDean Leith
C                        BUILDM PARAMETERS    SEP   03 ArDean Leith
C                        MPI                  OCT   03 CHAO YANG
C                        REWRITE              DEC   06 ArDean Leith
C                        MPI CHANGES          OCT   06 ArDean Leith
C                        MPI READV1P BUG      DEC   09 ArDean Leith
d55 1
a55 1
        REAL, DIMENSION(:,:), POINTER          :: ANGBUF, ANGSYM
d57 11
a67 11
        REAL,    ALLOCATABLE, DIMENSION(:,:)   :: DM,SM 
        REAL,    ALLOCATABLE, DIMENSION(:,:,:) :: WE,WO
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XE,XO
        REAL,    ALLOCATABLE, DIMENSION(:)     :: TEMP
        REAL,    ALLOCATABLE, DIMENSION(:)     :: ROTANG,SHX,SHY

        LOGICAL                                :: ANGINDOC,CALLRTSQ
        CHARACTER(LEN=1)                       :: NULL
        CHARACTER(LEN=MAXNAM)                  :: FILPAT 
        CHARACTER(LEN=MAXNAM)                  :: EVENVOL,ODDVOL,BOTHVOL
        CHARACTER(LEN=MAXNAM)                  :: ANGDOC
d70 1
a70 1
        INTEGER, PARAMETER                     :: LTAB=4999
d73 7
a79 1
        DATA  IOPIC/98/,INPROJ/99/,LUNDOC/80/
d87 7
a93 4
        CALL OPFILES(0,INPROJ,LUNDOC, FILPAT,NLET, 'O',
     &             ITYPE,NSAM,NROW,NSLICE,MAXIM,
     &             'TEMPLATE FOR IMAGE FILES (E.G. STK@@****)~',
     &             .FALSE., INUMBR,NILMAX, NANG,IMGNUM, IRTFLG) 
d125 1
d127 5
a131 3
        ALLOCATE(DM(9,NDIMANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           CALL ERRT(46,'BP 32F, DM',9 * NDIMANG)
a143 7

        NDIMSYM = MAX(1,MAXSYM)
        ALLOCATE(SM(9,NDIMSYM), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'BP 32F, SM',9*NDIMSYM)
            GOTO 999
        ENDIF
d158 2
a159 2
           MEMWANT = 6 * (NSAM+1) * N2 * N2
           CALL ERRT(46,'BP 32F; XE, WE, WO, & XO',MEMWANT)
d197 2
a198 1
     &               DM,IMGNUM,SM,MAXSYM,ANGINDOC,IRTFLG)
d375 1
d377 1
d385 2
a386 1
     &                     DM,IMGNUM,SM,MAXSYM,ANGINDOC,IRTFLG)
d393 1
a393 1
        REAL ::   DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)
d395 22
a416 20
        REAL, DIMENSION(9,NANG)              :: ANGBUF
        LOGICAL                              :: ANGINDOC,CALLRTSQ
        CHARACTER(LEN=*)                     :: FILPAT
        LOGICAL, ALLOCATABLE, DIMENSION(:)   :: RANDLIST
        REAL,    ALLOCATABLE, DIMENSION(:,:) :: PROJ,PROJTEMP
        COMPLEX, ALLOCATABLE, DIMENSION(:,:) :: BI
        REAL, DIMENSION(4)                   :: ANGBUFT
        INTEGER, DIMENSION(NANG)             :: INUMBRT
        REAL                                 :: WE(0:NSAM,N,N)
        REAL                                 :: WO(0:NSAM,N,N)
        COMPLEX                              :: XE(0:NSAM,N,N)
        COMPLEX                              :: XO(0:NSAM,N,N)

        CHARACTER(LEN=MAXNAM)                :: FILNAM,ODDVOL,FILPATOUT
        INTEGER, ALLOCATABLE, DIMENSION(:)   :: INUMBROUT

        DOUBLE PRECISION                     :: PI
	LOGICAL                              :: ITMP

        DATA  LUNROTT/81/,LUNDOC/80/
d425 2
a426 2
        INTEGER                                :: ISTAT(MPI_STATUS_SIZE)
        INTEGER, ALLOCATABLE, DIMENSION(:)     :: PSIZE, NBASE
d428 4
a431 4
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJLOC
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJBUF
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: WELOC, WOLOC
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XELOC, XOLOC
d453 1
a453 1
        LUNROT = 0    ! NO RTSQ OUTPUT WANTED
d455 1
a456 1

d463 1
a463 1
C          OPEN OUTPUT IMAGE(S) FOR RTSQ
d465 3
a467 2
           CALL OPFILES(INPROJ,LUNROTT,LUNDOC, FILPATOUT,NLETO, 'U',
     &            ITYPE,NSAM,NSAM,1, MAXIM,
d469 4
a472 1
     &            .FALSE., INUMBROUT,NANG, NANGT, IMGNUMOUT, IRTFLG) 
d737 2
a738 1
        NWANT = 1
d740 2
d769 1
a769 1
              ANGBUFT(1) = INUMBRT(NWANT)
d798 1
a798 1
              IF (RANDLIST(NWANT)) THEN
d814 1
a814 1
             IF (RANDLIST(NWANT)) THEN
d824 1
a824 1
          ENDDO                          ! END OF SYMMETRIES LOOP
d826 1
a826 1
          IF (NWANT .GE. NANG) EXIT      ! END OF INPUT LIST
d829 4
a832 3
          CALL NEXTFILES(NWANT, INUMBRT,INUMBROUT,   
     &                   INPROJ,INPROJ,LUNROT,
     &                   FILPAT,FILPATOUT,
d834 1
d837 1
a837 1
         ENDDO                            ! END OF PROJECTIONS LOOP 
d841 5
a845 5
c        write(6,*) '   ' 
c        write(6,*) ' xe:' , xe(0,1,1),xe(0,1,2),xe(75,75,75)
c        write(6,*) ' xo:' , xo(0,1,1),xo(0,1,2),xo(75,75,75)
c        write(6,*) ' we:' , we(0,1,1),we(0,1,2),we(75,75,75)
c        write(6,*) ' wo:' , wo(0,1,1),wo(0,1,2),wo(75,75,75)
d856 4
a859 4
9999    IF (ALLOCATED(PROJ))     DEALLOCATE(PROJ)
        IF (ALLOCATED(BI))       DEALLOCATE(BI)
        IF (ALLOCATED(RANDLIST)) DEALLOCATE(RANDLIST)
        IF (ALLOCATED(INUMBROUT))DEALLOCATE(INUMBROUT)
d861 1
@


1.57
log
@*** empty log message ***
@
text
@d14 1
d18 1
a18 1
C=* Copyright (C)2002,2008 P. A. Penczek                               *
d74 2
a75 7
#ifdef USE_MPI
        INCLUDE 'mpif.h'
        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
        MYPID = -1
#endif
a410 1
c       Memory requirement may be reduced in a future version?
d504 2
d507 2
d521 7
a527 3
C       PROCESSOR 0 READS IMAGE FILES AND DISTRIBUTE THEM.
C       (THIS VERSION ASSUMES THAT THERE IS SUFFICIENT
C       MEMORY TO HOLD NANG/NPROCS IMAGES)
d532 1
a532 1
C          READ IMAGES INTO THE BUFFER FIRST, THEN DISTRIBUTE
d547 6
a552 2
              CALL READV1P(INPROJ,PRJBUF(1,1,JLOC),
     &                           NSAM,NSAM,NSAM,NSAM,1)
d562 1
a562 1
C                 SEND TO OTHER PROCESSOR(S)
a588 1

d590 1
a590 1
C             KEEP FOR MYSELF
a594 1

@


1.56
log
@MPI bugs fixed
@
text
@d94 1
a94 1
2001    FORMAT(' NUMBER OF IMAGES: ',I7)
@


1.55
log
@FFTW3 plan changes
@
text
@a3 907
C  WIW32D.F                                   01/10/00
C                        ANGLES IN HEADER     JULY 01 ArDean Leith
C                        OPFILE 'U'           FEB  02 ArDean Leith
C                        BESSELS              05/03/02 P.A.Penczek
C                        OPFILEC              FEB  03 ARDEAN LEITH
C                        BUILDM PARAMETERS    JUL  03 ARDEAN LEITH
C                        BUILDM PARAMETERS    SEP  03 ARDEAN LEITH
C                        MPI                  OCT  03 CHAO YANG
C                        WIW32D_DL.F          FEB  07 ARDEAN LEITH
C                        FMRS_PLAN            MAY  08 ARDEAN LEITH
C
C=**********************************************************************
C=* From: SPIDER - MODULAR IMAGE PROCESSING SYSTEM                     *
C=* Copyright (C)2002 & 2008, P. A. Penczek                            *
C=*                                                                    *
C=* University of Texas - Houston Medical School                       *
C=*                                                                    *
C=* Email:  pawel.a.penczek@@uth.tmc.edu                                *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C **********************************************************************
C
C  WIW32D
C
C   PURPOSE:  FOR 'BP 32F' BACK PROJECTION - 3D, ODD-EVEN, INTERPOLATED
C             IN FOURIER SPACE ||*
C             AND FOR: 'BPD 32F' IMPROVED WITH LESS MEMORY REQUIRED AND
C             MORE STACK USAGE.
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE WIW32D

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

C       DOC FILE POINTERS
        REAL, DIMENSION(:,:), POINTER ::          ANGBUF, ANGSYM

        REAL, DIMENSION(:,:), ALLOCATABLE ::      DM,SM 
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XE,XO
        REAL, ALLOCATABLE, DIMENSION(:,:,:) ::    WE,WO

        REAL, DIMENSION(:), ALLOCATABLE ::        TEMP
        LOGICAL ::                                ANGINDOC
        CHARACTER(LEN=1) ::                       NULL

        CHARACTER*80    FINPIC,FINFO,ANGDOC,FINPAT
        COMMON /F_SPEC/ FINPAT,NLET,FINPIC

        DATA  IOPIC/98/,INPIC/99/

#ifdef USE_MPI
        INCLUDE 'mpif.h'
        INTEGER MYPID, COMM, MPIERR
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
#else
        MYPID = -1
#endif
        NULL   = CHAR(0)
        NILMAX = NIMAX

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,INUMBR,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)
        MAXNUM = MAXVAL(INUMBR(1:NANG))

C       NANG - TOTAL NUMBER OF IMAGES
        IF (MYPID .LE. 0) WRITE(NOUT,2001) NANG
2001    FORMAT(' NUMBER OF IMAGES: ',I7)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        ANGINDOC = .TRUE.
        MAXXT    = 4
        MAXYT    = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                 MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) ANGINDOC = .FALSE.

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 0
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF (IRTFLG .NE. 0)  MAXSYM=1

C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CLOSE(INPIC)

        N2   = 2*NSAM
        LSD  = N2+2-MOD(N2,2)
        NMAT = LSD*N2*N2

        IF (ANGINDOC) THEN
        
           ALLOCATE(DM(9,NANG), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN
              MEMWANT = 9 * NANG
              CALL ERRT(46,'BP 32F, DM',MEMWANT)
              GOTO 999
           ENDIF

           CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),.FALSE.,SSDUM,
     &                 .FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
        
           IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        ELSE
           ALLOCATE(DM(9,1), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'BP 32F, DM',IER)
              GOTO 999
           ENDIF
        ENDIF

        IF (MAXSYM .GT. 1)  THEN
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              MEMWANT = 9 * MAXSYM
              CALL ERRT(46,'BP 3F, SM',MEMWANT)
              GOTO 999
           ENDIF
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)

       ELSE
           ALLOCATE(SM(1,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
               CALL ERRT(46,'BP 3F, SM(1,1)',IER)
               GOTO 999
           ENDIF
        ENDIF

        ALLOCATE(XE(0:N2/2,N2,N2),
     &           WE(0:N2/2,N2,N2),
     &           WO(0:N2/2,N2,N2),
     &           XO(0:N2/2,N2,N2), STAT=IRTFLG)

        IF (IRTFLG.NE.0) THEN 
C          SOME ARRAYS ARE COMPLEX SO 6 NOT 4
           MEMWANT = 6 * ((N2/2)+1) * N2 * N2
           CALL ERRT(46,'BP 32F; XE, WE, WO, & XO',MEMWANT)
           GOTO 999
        ENDIF

C       CREATE FFTW3 PLAN FOR 3D FFT ON XE USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,XE,N2,N2,N2, 0,-1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
        CALL WIW32DQ(NSAM,XE,WE,XO,WO,
     &       LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3D',IRTFLG) 
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3D',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
 
        CALL FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3D',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

C       STORE FOURIER XE TEMPORARILY 
        IFORM = 3
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,IOPIC,'N',IFORM,LSD,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
        CALL WRITEV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        IF (MYPID .LE. 0) CLOSE(IOPIC)

C       CBE AND CBO (XE & XO) ARE LSD x N2 x N2
C       CWE AND CWO (WE & WO) ARE (LSD/2) x N2 x N2
        LSDD2 = LSD / 2
        IFORM = 3
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINFO,IOPIC,'N',IFORM,LSDD2,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

C       STORE WEIGHT WE TEMPORARILY 
        CALL WRITEV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)

        IF (MYPID .LE. 0) CLOSE(IOPIC)

        CALL NRMW2(XE,WE,N2/2,N2)
        CALL WINDKB2(XE,XE,NSAM,LSD,N2)

C       NOW XE IS READY, SYMMETRIZE IF NECESSARY
C       ADDITIONAL SYMMETRIZATION OF THE VOLUME XE IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
           ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              MEMWANT = NSAM * NSAM * NSAM 
              CALL ERRT(46,'BP 32F, TEMP',MEMWANT)
              GOTO 999
           ENDIF
	   CALL COP(XE,TEMP,NSAM*NSAM*NSAM)

c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,N2/2
                    XE(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO

           IF (MOD(NSAM,2) .EQ. 0)  THEN
              KNX = NSAM/2-1
           ELSE
              KNX = NSAM/2
           ENDIF
           KLX = -NSAM/2
	   CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	ENDIF

        IFORM = 3
        MAXIM = 0

        CALL OPFILEC(0,.FALSE.,FINPAT,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)

        IF (MYPID .LE. 0) CLOSE(IOPIC)

        IFORM = 3
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,IOPIC,'O',IFORM,LSD,N2,N2,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL READV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        CLOSE(IOPIC)

        IFORM = 3
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINFO,IOPIC,'O',IFORM,LSDD2,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL READV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)
        CLOSE(IOPIC)

C       Add E+O
        CALL  ADDADA(XE,XO,NMAT)
        CALL  ADDADA(WE,WO,NMAT/2)
        CALL  NRMW2(XE,WE,N2/2,N2)
        CALL  WINDKB2(XE,XE,NSAM,LSD,N2)

C       TOTAL VOLUME IS READY
C       ADDITIONAL SYMMETRIZATION OF THE VOLUME TOTAL IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
	   CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,N2/2
                    XE(I,J,K)=CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO
	   CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	ENDIF

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)
        IF (MYPID .LE. 0) CLOSE(IOPIC)

        CALL  NRMW2(XO,WO,N2/2,N2)
        CALL  WINDKB2(XO,XO,NSAM,LSD,N2)

C       XO VOLUME IS READY
C       ADDITIONAL SYMMETRIZATION OF THE VOLUME XO IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
	   CALL COP(XO,TEMP,NSAM*NSAM*NSAM)

c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,N2/2
                    XO(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
              ENDDO
           ENDDO
	   CALL SYMVOL(TEMP,XO,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	ENDIF

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINFO,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &              MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL WRITEV(IOPIC,XO,NSAM,NSAM,NSAM,NSAM,NSAM)

        IF (MYPID .LE. 0) CLOSE(IOPIC)

999     CONTINUE
        IF (ALLOCATED(DM))      DEALLOCATE(DM)
        IF (ALLOCATED(SM))      DEALLOCATE(SM)
        IF (ALLOCATED(XE))      DEALLOCATE(XE)
        IF (ALLOCATED(WE))      DEALLOCATE(WE)
        IF (ALLOCATED(XO))      DEALLOCATE(XO)
        IF (ALLOCATED(WO))      DEALLOCATE(WO)
        IF (ALLOCATED(TEMP))    DEALLOCATE(TEMP)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)
 
        END

C       ---------------- WIW32DQ -------------------------------------

        SUBROUTINE WIW32DQ(NS,XE,WE,XO,WO,LSD,N,N2, 
     &                      INUMBRT,DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)

C       NOTE: STUPID TRANSFORM OF N2-->N AND N2/2-->N2 !!!!al

        INCLUDE 'CMLIMIT.INC'

        LOGICAL                              :: ANGINDOC
        LOGICAL, DIMENSION(:), ALLOCATABLE   :: RANDLIST
        REAL, DIMENSION(:,:), ALLOCATABLE    :: PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(4)                   :: ANGBUF
        DIMENSION        WE(0:N2,N,N),WO(0:N2,N,N)
        COMPLEX          XE(0:N2,N,N),XO(0:N2,N,N)
        DIMENSION        INUMBRT(NANG)
        DIMENSION        DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)

        CHARACTER*80     FINPIC,FINPAT
        COMMON  /F_SPEC/ FINPAT,NLET,FINPIC

        DOUBLE PRECISION PI
	LOGICAL          ITMP

        PARAMETER (LTAB=4999)
        COMMON  /TABS/  LN2,FLTB,TABI(0:LTAB)

C       IN THIS VERSION THE ORDER OF THE BESSEL FUNCTION IS MMM=1
	COMMON  /BESSEL_PARAM/ ALPHA,AAAA,NNN

        DATA  INPROJ/99/
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (TWOPI = 2*QUADPI)

#ifdef USE_MPI
c       This MPI version is memory intensive.
c       It requires 6 copies of the 3-D volume,
c       2-D images are read into memory and distributed.
c       Each processor will hold roughly nang/nproc 2-D images.  
c       Memory requirement may be reduced in a future version.

        INCLUDE 'mpif.h'
        INTEGER MYPID, COMM, MPIERR, NPROCS, K3
        INTEGER ISTAT(MPI_STATUS_SIZE)
        INTEGER, ALLOCATABLE, DIMENSION(:) :: PSIZE, NBASE
                          
        INTEGER  NANGLOC, NREM, IPROC, ISAM, JROW, JGLB, JLOC
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJLOC
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: PRJBUF
        REAL   , ALLOCATABLE, DIMENSION(:,:,:) :: WELOC, WOLOC
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XELOC, XOLOC

        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
#else
        MYPID = -1
#endif

C       K=6
        LN=5
        LN2=LN/2
C       GENERALIZED KAISER-BESSEL WINDOW ACCORDING TO LEWITT
C       M=NS, N=N
	R=NS/2
	V=REAL(LN-1)/2.0/REAL(N)
	ALPHA=6.5
C	AAAA=0.0079
C	AAAA=1.1*V
	AAAA=0.9*V
	NNN=3
C	mmm=1
C       GENERATE TABLE WITH INTERPOLANTS
C	B0=(SQRT(ALPHA)**mmm)*BESSI(mmm,ALPHA)
 	B0=SQRT(ALPHA)*BESI1(ALPHA)
C	if(abs(b0-tempo).gt.1.0e-5)  print  *,'B0'
        FLTB=REAL(LTAB)/REAL(LN2+1)

C       CANNOT BE PARALLEL AS THERE ARE DATA STATEMENTS IN BESSI
cc$omp  parallel do private(i,s,x),shared(mmm)
        DO  I=0,LTAB
	   S=REAL(I)/FLTB/N
	   IF (S.LE.AAAA)  THEN
	      X=SQRT(1.0-(S/AAAA)**2)
	      TABI(I)= SQRT(ALPHA*X)*BESI1(ALPHA*X)/B0
	  ELSE
	     TABI(I)=0.0
	  ENDIF
        ENDDO

c$omp   parallel do private(i,j,k)
        DO  K=1,N
           DO  J=1,N
              DO  I=0,N2
                 XE(I,J,K) = CMPLX(0.0,0.0)
                 WE(I,J,K) = 0.0
                 XO(I,J,K) = CMPLX(0.0,0.0)
                 WO(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO

        ALLOCATE (PROJ(NS,NS),
     &            BI(0:N2,N),
     &            RANDLIST(NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN
           MEMWANT = NS*NS + (N2 + 1) * N + NANG 
           CALL ERRT(46,'BP 32F, PROJ, ...',MEMWANT)
           RETURN
        ENDIF

C       CREATE FFTW3 PLAN FOR 2D FFT ON BI USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,BI,N,N,1, 0,+1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
	RANDLIST(1:NANG/2)      = .TRUE.
	RANDLIST(NANG/2+1:NANG) = .FALSE.

	DO  K=1,NANG
           CALL RANDOM_NUMBER(HARVEST=X)
           IORD = MIN(NANG,MAX(1,INT(X*NANG+0.5)))
	   ITMP = RANDLIST(IORD)
	   RANDLIST(IORD) = RANDLIST(K)
	   RANDLIST(K)    = ITMP
	ENDDO

#ifdef  SP_MP
	LN1 = LN+1
#endif

#ifdef USE_MPI

C       --- BEGIN MPI VERSION ---

C       DISTRIBUTE PARTICLES TO PROCESSORS.
C       NANGLOC IS THE NUMBER OF PARTICLES ASSIGNED TO EACH PROCESSOR.

        ALLOCATE(PSIZE(NPROCS) ,NBASE(NPROCS), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = 2 * NPROCS 
           CALL ERRT(46,'BP 3F, PSIZE & NBASE',MEMWANT)
           RETURN
        ENDIF

C       SETPART RETURNS THE SIZE OF THE LOCAL PIECE AND  GLOBAL OFFSET.
        CALL SETPART(NANG, PSIZE, NBASE)
        NANGLOC = PSIZE(MYPID+1)

C       2-D IMAGES ARE DISTRIBUTED AND HELD IN PRJLOC ON EACH PROCESSOR

        ALLOCATE(PRJBUF(NS,NS,PSIZE(1)),
     &           PRJLOC(NS,NS,NANGLOC),
     &           STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = NS*NS*PSIZE(1) + NS*NS*NANGLOC
           CALL ERRT(46,'BP 3F, PRJBUF, PRJLOC',MEMWANT)
           RETURN
        ENDIF

C       PROCESSOR 0 READS IMAGE FILES AND DISTRIBUTE THEM.
C       (THIS VERSION ASSUMES THAT THERE IS SUFFICIENT
C        MEMORY TO HOLD NANG/NPROCS IMAGES)

        DO IPROC = 1, NPROCS
           NANGLOC = PSIZE(IPROC)

C          READ IMAGES INTO THE BUFFER FIRST, THEN DISTRIBUTED
C          READ A BUNCH OF 2-D IMAGES

           DO JLOC = 1, NANGLOC
              JGLB = NBASE(IPROC) + JLOC
              CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(JGLB),IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
              MAXIM = 0
              CALL OPFILEC(0      ,.FALSE., FINPIC, INPROJ, 'O'  ,
     &                     IFORM  , NSAM  , NSAM  , NSL   , MAXIM,
     &                     'DUMMY',.FALSE., IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
              CALL READV1P(INPROJ,PRJBUF(1,1,JLOC),NS,NS,NS,NS,1)
              CLOSE(INPROJ)
           ENDDO
C
           IF (IPROC .GT. 1) THEN
               IF  (MYPID .EQ. 0) THEN

C                 SEND TO ANOTHER PROCESSOR
#ifdef MPI_DEBUG
                  WRITE(6,*) 'WIW32DQ: SENDING TO PID = ', IPROC-1
#endif
                  CALL MPI_SEND(PRJBUF , NS*NS*NANGLOC, MPI_REAL,
     &                          IPROC-1, IPROC-1      , COMM    ,
     &                          MPIERR)
                  IF (MPIERR .NE. 0) THEN
                        WRITE(6,*) 'WIW32DQ: SEND ERROR!'
                        STOP
                  ENDIF
               ELSE IF (MYPID .EQ. IPROC-1) THEN
C                 RECEIVE PROJECTION IMAGES FROM PROCESSOR 0
                  CALL MPI_RECV(PRJLOC, NS*NS*NANGLOC, MPI_REAL,
     &                          0     , MPI_ANY_TAG  , COMM    ,
     &                          ISTAT , MPIERR)
                  IF (MPIERR .NE. 0) THEN
                     WRITE(6,*) 'WIW32DQ: RECV FAILED'
                     STOP
                  ENDIF
#ifdef MPI_DEBUG
                  WRITE(6,111) MYPID
 111              FORMAT(1X,'WIW32DQ: MYPID = ', I3, ' RECEIVED!')
#endif
              ENDIF  
           ELSE IF (MYPID .EQ. 0) THEN
C             KEEP FOR MYSELF
              DO JLOC = 1, NANGLOC
                 DO ISAM = 1, NS
                     DO JROW = 1, NS
                          PRJLOC(ISAM,JROW,JLOC)
     &                  = PRJBUF(ISAM,JROW,JLOC)
                     ENDDO
                  ENDDO
               ENDDO
           ENDIF
        ENDDO
        IF (ALLOCATED(PRJBUF)) DEALLOCATE(PRJBUF)

        IF (.NOT. ANGINDOC) THEN
C           GET ANGLES FROM HEADER
            ANGBUF(1) = INUMBRT(K)
            CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
            CALL BUILDM(INUMBRT,DM,1,ANGBUF,.FALSE.,SSDUM,
     &                  .FALSE.,IRTFLG)
            IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
        CLOSE(INPROJ)

C       PERFORM CALCULATIONS IN PARALLEL NOW

        ALLOCATE (WELOC(0:N2,N,N), XELOC(0:N2,N,N), 
     &            WOLOC(0:N2,N,N), XOLOC(0:N2,N,N), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MEMWANT = 4*(N2+1)*N*N 
           CALL ERRT(46,'BP 3F, WELOC, XELOC, ...',MEMWANT)
           RETURN
        ENDIF

        DO K=1,N
           DO J=1,N
              DO I=0,N2
                 XELOC(I,J,K) = CMPLX(0.0,0.0)
                 XOLOC(I,J,K) = CMPLX(0.0,0.0)
                 WELOC(I,J,K) = 0.0
                 WOLOC(I,J,K) = 0.0
              ENDDO
           ENDDO
        ENDDO
C
        NANGLOC = PSIZE(MYPID+1)
        DO JLOC = 1, NANGLOC
           JGLB = NBASE(MYPID+1) + JLOC

C          PAD: PRJLOC  TO SIZE: N
           CALL PADD2(PRJLOC(1,1,JLOC),NS,BI,LSD,N)

C          FOURIER TRANSFORM OF: BI
           INV = +1
           CALL FMRS_2(BI,N,N,INV)

           DO  J=1,N
              DO  I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO  ISYM=1,MAXSYM
              IF (MAXSYM .GT. 1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS = MATMUL(SM(:,:,ISYM),DM(:,:,JGLB))
              ELSE
                 DMS = DM(:,:,JGLB)
              ENDIF

              IF (RANDLIST(K)) THEN
                 DO J=-N2+1,N2
                    CALL ONELINE(J,N,N2,XEloc,WEloc,BI,DMS)
                 ENDDO
              ELSE
                 DO J=-N2+1,N2
                    CALL ONELINE(J,N,N2,XOloc,WOloc,BI,DMS)
                 ENDDO
              ENDIF
           ENDDO
        ENDDO
        IF (ALLOCATED(PRJLOC)) DEALLOCATE(PRJLOC)

C       SUM UP X AND W FROM THE LOCAL PIECES (XLOC, WLOC)
C       RESIDING ON EACH PROCESSOR

        DO K3 = 1, N
           CALL MPI_ALLREDUCE(XELOC(1,1,K3), XE(1,1,K3), (N2+1)*N, 
     &                        MPI_COMPLEX  , MPI_SUM   , COMM    ,
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
           CALL MPI_ALLREDUCE(XOLOC(1,1,K3), XO(1,1,K3), (N2+1)*N, 
     &                        MPI_COMPLEX  , MPI_SUM   , COMM    , 
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
           CALL MPI_ALLREDUCE(WELOC(1,1,K3), WE(1,1,K3), (N2+1)*N, 
     &                        MPI_REAL     , MPI_SUM   , COMM    ,
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
           CALL MPI_ALLREDUCE(WOLOC(1,1,K3), WO(1,1,K3), (N2+1)*N,
     &                        MPI_REAL     , MPI_SUM   , COMM    ,
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
        ENDDO 
        IF (ALLOCATED(XOLOC))    DEALLOCATE (XOLOC)
        IF (ALLOCATED(XELOC))    DEALLOCATE (XELOC)
        IF (ALLOCATED(WOLOC))    DEALLOCATE (WOLOC)
        IF (ALLOCATED(WEloc))    DEALLOCATE (WEloc)
#ifdef MPI_DEBUG
        WRITE(6,*) 'WIW32DQ: COMPLETED GLOBAL SUM, MYPID = ', MYPID
#endif
C       --- END OF MPI VERSION ---     
#else

        DO K=1,NANG
C          print  *,' Projection #',K

C          OPEN DESIRED FILE
           CALL FILGET(FINPAT,FINPIC,NLET,INUMBRT(K),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPROJ,'O',IFORM,NSAM,NROW,NSL,
     &                   MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

	   CALL READV(INPROJ,PROJ,NS,NS,NS,NS,1)

           IF (.NOT. ANGINDOC) THEN
C             GET ANGLES FROM HEADER
              ANGBUF(1) = INUMBRT(K)
              CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
              CALL BUILDM(INUMBRT,DM,1,ANGBUF,.FALSE.,SSDUM,
     &                    .FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
           ENDIF
           CLOSE(INPROJ)

C          PAD: PROJ  TO SIZE: N
           CALL PADD2(PROJ,NS,BI,LSD,N)

C          FOURIER TRANSFORM OF: BI
           INV=+1
           CALL FMRS_2(BI,N,N,INV)

c$omp      parallel do private(i,j)
           DO J=1,N
              DO I=0,N2
                 BI(I,J) = BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO  ISYM=1,MAXSYM
              IF (MAXSYM. GT. 1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS = MATMUL(SM(:,:,ISYM),DM(:,:,K))
              ELSE
                 DMS = DM(:,:,K)
              ENDIF
#ifdef SP_MP
              IF (RANDLIST(K)) THEN
	         DO JT=1,LN1
C,schedule(static)
c$omp parallel do private(j),shared(N,N2,JT,XE,WE,BI,DMS)
                    DO J=-N2+JT,N2,LN1
                       CALL ONELINE(J,N,N2,XE,WE,BI,DMS)
                    ENDDO
                ENDDO
             ELSE
	        DO JT=1,LN1
c$omp           parallel do private(j),shared(N,N2,JT,XO,WO,BI,DMS)
                   DO J=-N2+JT,N2,LN1
                      CALL ONELINE(J,N,N2,XO,WO,BI,DMS)
                   ENDDO
                ENDDO
             ENDIF
#else
             IF (RANDLIST(K)) THEN
                 DO J=-N2+1,N2
                    CALL ONELINE(J,N,N2,XE,WE,BI,DMS)
                 ENDDO
              ELSE
                 DO J=-N2+1,N2
                    CALL ONELINE(J,N,N2,XO,WO,BI,DMS)
                 ENDDO
              ENDIF
#endif
C             END OF SYMMETRIES LOOP
           ENDDO

C          END OF PROJECTIONS LOOP
        ENDDO
#endif

C       SYMMETRIZE BOTH VOLUMES
c$omp   parallel sections
c$omp   section
        CALL  SYMPLANE0(XE,WE,N2,N)
c$omp   section
        CALL  SYMPLANE0(XO,WO,N2,N)
c$omp   end parallel sections

9999    IF (ALLOCATED(PROJ)) DEALLOCATE (PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE (BI)
        IF (ALLOCATED(RANDLIST)) DEALLOCATE (RANDLIST)

        END

C       ------------------- WINDKB2 -------------------------------

        SUBROUTINE WINDKB2(BI,R,L,LSD,N)

        DIMENSION  R(L,L,L),BI(LSD,N,N)
	COMMON  /BESSEL_PARAM/  ALPHA,AAAA,NNN

	PARAMETER (QUADPI = 3.14159265358979323846)
	PARAMETER (TWOPI = 2*QUADPI)

        IP = (N-L)/2+MOD(L,2)
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 R(I,J,K) = BI(IP+I,IP+J,IP+K)
              ENDDO
           ENDDO
        ENDDO

        L2  = (L/2)**2
        L2P = (L/2-1)**2
        IP  = L/2+1
	XNU = REAL(NNN)/2.
	
	RI = RIBSL(ALPHA,XNU)
C	IF (ABS(RI-RIN).GT.1.E-5)  PRINT  *,'BESSIK'

	WKB0 = ALPHA**XNU/RI
	QRT  = (TWOPI*AAAA)**2
        TNR  = 0.0
        M    = 0
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 LR = (K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR.LE.L2) THEN
		 SIGMA=QRT*LR-ALPHA*ALPHA
	          IF (ABS(SIGMA).LT.1.0E-7)  THEN
	             WKB=1.0
	          ELSEIF(SIGMA.GT.0.0)  THEN
C                    2PI A R > ALPHA
		     ART = SQRT(SIGMA)
      		     RI = RJBSL(ART, XNU)
C	if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessjy',i,j,k
	             WKB=WKB0*RI/ART**XNU
	          ELSE
C                    2PI A R < ALPHA
		     ART = SQRT(ABS(SIGMA))
		     RI = RIBSL(ART,XNU)
C	if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessik',i,j,k,ri,rin
	             WKB=WKB0*RI/ART**XNU
	          ENDIF
                  R(I,J,K) = R(I,J,K)/ABS(WKB)
                  IF (LR.GE.L2P .AND. LR.LE.L2) THEN
                      TNR=TNR+R(I,J,K)
                      M=M+1
                  ENDIF
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        TNR = TNR/REAL(M)
c$omp   parallel do private(i,j,k,lr)
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR.LE.L2) THEN
                    R(I,J,K)=R(I,J,K)-TNR
                 ELSE
                    R(I,J,K)=0.0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END


C       ----------------SYMPLANE0 ---------------------------------------
 
        SUBROUTINE  SYMPLANE0(X,W,N2,N)

        DIMENSION  W(0:N2,N,N)
        COMPLEX  X(0:N2,N,N)

C       SYMMETRIZE PLANE 0
        DO  IZA=2,N2
           DO  IYA=2,N2
              X(0,IYA,IZA)=X(0,IYA,IZA)+CONJG(X(0,N-IYA+2,N-IZA+2))
              W(0,IYA,IZA)=W(0,IYA,IZA)+W(0,N-IYA+2,N-IZA+2)
              X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
              W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
              X(0,N-IYA+2,IZA)=X(0,N-IYA+2,IZA)+CONJG(X(0,IYA,N-IZA+2))
              W(0,N-IYA+2,IZA)=W(0,N-IYA+2,IZA)+W(0,IYA,N-IZA+2)
              X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
              W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
           ENDDO
        ENDDO

        DO  IYA=2,N2
           X(0,IYA,1)=X(0,IYA,1)+CONJG(X(0,N-IYA+2,1))
           W(0,IYA,1)=W(0,IYA,1)+W(0,N-IYA+2,1)
           X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
           W(0,N-IYA+2,1)=W(0,IYA,1)
        ENDDO

        DO  IZA=2,N2
           X(0,1,IZA)=X(0,1,IZA)+CONJG(X(0,1,N-IZA+2))
           W(0,1,IZA)=W(0,1,IZA)+W(0,1,N-IZA+2)
           X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
           W(0,1,N-IZA+2)=W(0,1,IZA)
        ENDDO

        END

C----------------ADDADA ---------------------------------------

        SUBROUTINE  ADDADA(X,Y,N)

        DIMENSION  X(N),Y(N)

c$omp   parallel do private(k)
        DO  K=1,N
           X(K) = X(K)+Y(K)
        ENDDO
        END







C++*********************************************************************
C
d13 1
d17 1
a17 1
C=* Copyright (C)2002, P. A. Penczek                                   *
d40 3
d75 2
a76 3
        INTEGER MYPID, COMM, MPIERR
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d161 2
a162 1
C       CREATE FFTW3 PLAN FOR 3D FFT ON XE USING ALL THREADS
d190 3
a192 2
C  WIW32DQ(NS,XE,WE,XO,WO,LSD,N,N2, 
C  WIW32DQ_DL(NSAM,XE,WE,XO,WO,LSD,N
d235 1
d301 1
d336 2
a337 1
        CALL NRMW2(  XO,WO,NSAM,N2)
d391 1
d402 1
a402 3
        CHARACTER(LEN=MAXNAM)                :: FILNAM,ODDVOL,FILPAT

        CHARACTER (LEN=MAXNAM)               :: FILPATOUT
d418 1
a418 2
        INTEGER MYPID, COMM, MPIERR, NPROCS, K3
        INTEGER ISTAT(MPI_STATUS_SIZE)
a420 1
        INTEGER  NANGLOC, NREM, IPROC, ISAM, JROW, JGLB, JLOC
d426 3
a428 3
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
        CALL MPI_COMM_SIZE(COMM, NPROCS, MPIERR)
d445 1
a445 1
        NSIZE = 1
a475 4
C       CREATE FFTW3 PLAN FOR 2D FFT ON BI USING ALL THREADS
        CALL FMRS_PLAN(.TRUE.,BI,N,N,1, 0,+1,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
d495 6
d529 1
a529 1
C          READ IMAGES INTO THE BUFFER FIRST, THEN DISTRIBUTED
d533 3
a535 1
              CALL FILGET(FILPAT,FILNAM,NLET,INUMBR(JGLB),IRTFLG)
d538 1
d543 1
d545 1
a545 1
     &                     NSAM,NSAM,NSAM,NSAM,1)
d550 4
d555 1
a555 1
C                 SEND TO ANOTHER PROCESSOR
d557 1
a557 1
                  WRITE(6,*) 'WIW32DQ: SENDING TO PID = ', IPROC-1
d560 1
a560 2
     &                          IPROC-1, IPROC-1      , COMM    ,
     &                          MPIERR)
d562 1
a562 1
                     WRITE(6,*) 'WIW32DQ: SEND ERROR!'
d565 1
d568 3
d572 1
a572 2
     &                          0     , MPI_ANY_TAG  , COMM    ,
     &                          ISTAT , MPIERR)
d574 1
a574 1
                     WRITE(6,*) 'WIW32DQ: RECV FAILED'
d578 1
a578 2
                  WRITE(6,111) MYPID
 111              FORMAT(1X,'WIW32DQ: MYPID = ', I3, ' RECEIVED!')
d580 3
a582 1
              ENDIF  
d585 5
d600 1
a600 1
C
d612 1
d621 1
d632 2
a633 1
C
d635 1
d642 2
a643 2
C          FOURIER TRANSFORM OF: BI
           INV = +1
d648 1
a648 1
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
d671 6
a676 1
        IF (ALLOCATED(PRJLOC)) DEALLOCATE(PRJLOC)
d680 1
a680 1

d682 8
a689 28
           CALL MPI_ALLREDUCE(XELOC(1,1,K3), XE(1,1,K3), (NSAM+1)*N, 
     &                        MPI_COMPLEX  , MPI_SUM   , COMM    ,
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
           CALL MPI_ALLREDUCE(XOLOC(1,1,K3), XO(1,1,K3), (NSAM+1)*N, 
     &                        MPI_COMPLEX  , MPI_SUM   , COMM    , 
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
           CALL MPI_ALLREDUCE(WELOC(1,1,K3), WE(1,1,K3), (NSAM+1)*N, 
     &                        MPI_REAL     , MPI_SUM   , COMM    ,
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
           CALL MPI_ALLREDUCE(WOLOC(1,1,K3), WO(1,1,K3), (NSAM+1)*N,
     &                        MPI_REAL     , MPI_SUM   , COMM    ,
     &                        MPIERR)
           IF ( MPIERR. NE. 0 ) THEN
              WRITE(6,*) 'WIW32DQ: FAILED TO ALLREDUCE'
              STOP
           ENDIF
d691 2
d697 1
d699 1
a699 1
        WRITE(6,*) 'WIW32DQ: COMPLETED GLOBAL SUM, MYPID = ', MYPID
d702 2
d707 4
d722 1
a722 1
C             Reg. numbers for angle, scale,& shift =(6,0,7,8)
d755 1
a755 1
C          FOURIER TRANSFORM OF: BI
d805 1
a805 1
          CALL NEXTFILES(NWANT, INUMBR,INUMBROUT,   
d813 8
d847 1
a847 1
        IP = (N-L )/ 2 + MOD(L,2)
d856 4
a859 4
        L2  = (L/2)**2
        L2P = (L/2-1)**2
        IP  = L / 2+1
	XNU = REAL(NNN) / 2.
d861 1
a861 1
	RI = RIBSL(ALPHA,XNU)
d890 1
a890 1
                  IF (LR.GE.L2P .AND. LR.LE.L2) THEN
d903 1
a903 1
                 LR = (K-IP)**2+(J-IP)**2+(I-IP)**2
d916 128
@


1.54
log
@list bug
@
text
@d12 2
a13 1
C                        WIW32D_DL.F          FEF  07 ARDEAN LEITH
d17 1
a17 1
C=* Copyright (C)2002, P. A. Penczek                                   *
d42 4
d173 4
d231 1
a231 1
                    XE(I,J,K)=CMPLX(0.0,0.0)
d346 1
a346 1
        SUBROUTINE  WIW32DQ(NS,XE,WE,XO,WO,LSD,N,N2, 
d349 2
d353 3
a355 3
        LOGICAL ::                              ANGINDOC
        LOGICAL, DIMENSION(:), ALLOCATABLE ::   RANDLIST
        REAL, DIMENSION(:,:), ALLOCATABLE ::    PROJ
d357 1
a357 1
        REAL, DIMENSION(4) ::                   ANGBUF
d456 4
a470 1

d603 2
d606 2
d705 1
d707 2
d711 1
d1065 4
d1093 2
d1281 2
d1368 2
a1369 1
        ALLOCATE (PROJ(NSAM,NSAM),PROJTEMP(NSAM,NSIZE),
d1373 1
a1373 1
           MEMWANT = NSAM*NSAM + NSAM*NSIZE + (NSAM+1)*N + NANG 
d1378 4
d1518 2
d1521 2
d1638 1
d1641 1
a1641 1
C          FOURIER TRANSFORM
@


1.53
log
@itype needed setting
@
text
@d1000 1
a1000 1
        IF (ANGINDOC) NDIMANG = NANG
d1011 1
a1011 1
     &                 .FALSE.,IRTFLG)
d1247 1
a1247 1
C       ---------------- WIW32DQ -------------------------------------
d1253 1
a1564 2
c          write(6,*)  'Projection #: ',IMGNUM

d1569 10
a1578 1
C             Reg. numbers for angle, scale,& shift =(6,0,7,8)   
d1583 1
a1583 1
                 CALL WRTVOL(LUNROT,NSAM,NSAM,1,1, PROJTEMP,IRTFLG)
@


1.52
log
@rot2qs_dl used bug
@
text
@d12 1
d168 2
a169 2
        CALL  WIW32DQ(NSAM,XE,WE,XO,WO,
     &      LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
d172 1
a172 1
        CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3D',IRTFLG) 
d175 1
a175 1
        CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3D',IRTFLG)
d178 1
a178 1
        CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3D',IRTFLG)
d181 1
a186 2

C       STORE FOURIER XE TEMPORARILY 
d1087 2
a1088 1
        CALL OPFILEC(0,.FALSE.,BOTHVOL,IOPIC,'U',IFORM,LSD,N2,N2,
d1096 1
a1096 1
        CALL OPFILEC(0,.FALSE.,ODDVOL,IOPIC,'U',IFORM,LSDD2,N2,N2,
d1141 1
a1141 1
        CALL OPFILEC(0,.FALSE.,EVENVOL,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d1150 1
a1150 1
        CALL OPFILEC(0,.FALSE.,BOTHVOL,IOPIC,'O',IFORM,LSD,N2,N2,
d1158 1
a1158 1
        CALL OPFILEC(0,.FALSE.,ODDVOL,IOPIC,'O',IFORM,LSDD2,N2,N2,
d1194 1
a1194 1
        CALL OPFILEC(0,.FALSE.,BOTHVOL,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d1227 1
a1227 1
        CALL OPFILEC(0,.FALSE.,ODDVOL,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d1352 1
a1352 1
           IORD           = MIN(NANG,MAX0(1,INT(X*NANG+0.5)))
@


1.51
log
@BPD
@
text
@a12 1
C **********************************************************************
a35 1
C=**********************************************************************
d362 2
a363 2
	COMMON  /BESSEL_PARAM/  ALPHA,AAAA,NNN
C,mmm
d370 1
a370 1
c       It requires 6 copies of the 3-D volumn,
d372 2
a373 3
c       Each processor will hold roughly nang/nproc
c       2-D images.  Memory requirement will be reduced in
c       a future version.
d428 4
a431 4
                 XE(I,J,K)=CMPLX(0.0,0.0)
                 WE(I,J,K)=0.0
                 XO(I,J,K)=CMPLX(0.0,0.0)
                 WO(I,J,K)=0.0
d449 2
a450 2
           CALL  RANDOM_NUMBER(HARVEST=X)
           IORD = MIN0(NANG,MAX0(1,INT(X*NANG+0.5)))
d462 1
a462 1
C
d464 1
a464 1
C
d466 2
a467 3
C       NANGLOC IS THE NUMBER OF PARTICLES ASSIGNED
C       TO EACH PROCESSOR.
C
d475 1
a475 3
C       SETPART RETURNS THE SIZE OF THE LOCAL PIECE
C       AND THE GLOBAL OFFSET.
C
d478 3
a480 4
C
C       2-D IMAGES ARE DISTRIBUTED AND HELD IN PRJLOC
C       ON EACH PROCESSOR
C
d489 1
a489 1
C
d493 1
a493 1
C
d496 1
a496 1
C
a497 1
C
d499 1
a499 1
C
a527 1
C
a528 1
C
d535 1
a535 1
                  END IF
a541 1
C
a542 1
C
d548 5
a552 5
                     END DO
                  END DO
               END DO
           END IF
        END DO
d554 1
a554 1
C
d600 1
a600 1
              IF(MAXSYM.GT.1)  THEN
d602 1
a602 1
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,JGLB))
d604 1
a604 1
                 DMS=DM(:,:,JGLB)
d607 1
a607 1
             IF (RANDLIST(K)) THEN
d616 2
a617 2
           END DO
        END DO
d630 1
a630 1
           END IF
d637 1
a637 1
           END IF
d644 1
a644 1
           END IF
d651 1
a651 1
           END IF
d702 1
a702 1
                 DMS=DM(:,:,K)
d710 1
a710 1
                       CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
d759 2
a760 2
C,mmm
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
a762 1
c       TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
a767 1
c*TNR
a775 2
C       +REAL(mmm)
C	CALL  BESSIK(ALPHA,XNU,RI,RK,RIP,RIK)
a794 1
C		     CALL BESSJY(ART,XNU,RI,RK,RIP,RIK)
a800 1
C		     CALL BESSIK(ART,XNU,RI,RK,RIP,RIK)
d1570 1
a1570 1
	      CALL ROT2QS(PROJTEMP,PROJ, NSAM,NSAM,
d1676 1
a1676 1
        IP = (N-L)/2+MOD(L,2)
d1687 2
a1688 2
        IP  = L/2+1
	XNU = REAL(NNN)/2.
d1692 1
a1692 1
	WKB0 = ALPHA**XNU/RI
d1701 2
a1702 2
		 SIGMA=QRT*LR-ALPHA*ALPHA
	          IF (ABS(SIGMA).LT.1.0E-7)  THEN
d1704 2
a1705 1
	          ELSEIF(SIGMA.GT.0.0)  THEN
d1708 3
a1710 4
C		     CALL BESSJY(ART,XNU,RI,RK,RIP,RIK)
      		     RI = RJBSL(ART, XNU)
C	if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessjy',i,j,k
	             WKB=WKB0*RI/ART**XNU
d1714 2
a1715 4
C		     CALL BESSIK(ART,XNU,RI,RK,RIP,RIK)
		     RI = RIBSL(ART,XNU)
C	if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessik',i,j,k,ri,rin
	             WKB=WKB0*RI/ART**XNU
d1717 2
a1718 1
                  R(I,J,K) = R(I,J,K)/ABS(WKB)
d1720 2
a1721 2
                      TNR=TNR+R(I,J,K)
                      M=M+1
d1727 1
a1727 1
        TNR = TNR/REAL(M)
d1732 3
a1734 3
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR.LE.L2) THEN
                    R(I,J,K) = R(I,J,K)-TNR
@


1.50
log
@MEMWANT WRONG FOR XE
@
text
@d898 866
@


1.49
log
@memwant added
@
text
@d163 2
a164 1
           MEMWANT = 4 * ((N2/2)+1) * N2 * N2
@


1.48
log
@Pawels GPL License used
@
text
@d121 2
a122 1
              CALL ERRT(46,'BP 32F, DM',IER)
d142 2
a143 1
              CALL ERRT(46,'BP 3F, SM',IER)
d157 5
a161 2
        ALLOCATE(XE(0:N2/2,N2,N2),WE(0:N2/2,N2,N2),WO(0:N2/2,N2,N2),
     &            XO(0:N2/2,N2,N2), STAT=IRTFLG)
d163 2
a164 1
           CALL ERRT(46,'BP 32F; XE, WE, WO & XO',IER)
d213 2
a214 1
              CALL ERRT(46,'BP 32F, TEMP',IER)
d438 6
a443 3
        ALLOCATE (PROJ(NS,NS),BI(0:N2,N),RANDLIST(NANG),STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, PROJ...',NE)
d471 1
a471 1
        ALLOCATE(PSIZE(NPROCS),STAT=IRTFLG)
d473 2
a474 1
           CALL ERRT(46,'BP 3F, PSIZE',IER)
d477 1
a477 6
        ALLOCATE(NBASE(NPROCS),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'BP 3F, NBASE',IER)
           RETURN
        ENDIF
C
d487 2
a488 1
        ALLOCATE(PRJBUF(NS,NS,PSIZE(1)),PRJLOC(NS,NS,NANGLOC),
d491 2
a492 1
           CALL ERRT(46,'BP 3F, PRJBUF, PRJLOC',IER)
d578 2
a579 1
        ALLOCATE (WELOC(0:N2,N,N), XELOC(0:N2,N,N), STAT=IRTFLG)
d581 2
a582 1
           CALL ERRT(46,'BP 3F, WELOC, XELOC',IER)
d585 8
a592 12
        ALLOCATE (WOLOC(0:N2,N,N), XOLOC(0:N2,N,N), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'BP 3F, WOLOC, XOLOC',IER)
           RETURN
        ENDIF
        DO    K=1,N
           DO    J=1,N
              DO    I=0,N2
                 XELOC(I,J,K)=CMPLX(0.0,0.0)
                 XOLOC(I,J,K)=CMPLX(0.0,0.0)
                 WELOC(I,J,K)=0.0
                 WOLOC(I,J,K)=0.0
@


1.47
log
@removed MPI_BARRIER to reduce comm overhead
@
text
@d2 1
a2 1
C++************************************************************************
d13 26
a38 6
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.
C *  WIW32D.F   COPYRIGHT (C)2002, P.A.PENCZEK
C *  UNIVERSITY OF TEXAS - HOUSTON MEDICAL SCHOOL
C *  pawel.a.penczek@@uth.tmc.edu
C **************************************************************************
@


1.46
log
@mpi
@
text
@a164 3
#ifdef USE_MPI
        CALL MPI_BARRIER(COMM,MPIERR)
#endif
a177 3
#ifdef USE_MPI
        CALL MPI_BARRIER(COMM,MPIERR)
#endif
a219 3
#ifdef USE_MPI
        CALL MPI_BARRIER(COMM, MPIERR)
#endif
a266 3
#ifdef USE_MPI
        CALL MPI_BARRIER(COMM, MPIERR)
#endif
a294 3
#ifdef USE_MPI
        CALL MPI_BARRIER(COMM, MPIERR)
#endif
@


1.45
log
@buildm
@
text
@d48 4
a51 4
        include 'mpif.h'
        INTEGER MYPID, COMM, IERR
        comm = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
d65 1
a65 7
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
           WRITE(NOUT,2001) NANG
        endif
#else
        WRITE(NOUT,2001) NANG
#endif
a156 8
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
           CALL OPFILEC(0,.FALSE.,FINPIC,IOPIC,'N',IFORM,LSD,N2,N2,
     &                MAXIM,'DUMMY',.FALSE.,IRTFLG)
        ENDIF
        call MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, comm, ierr)
        IF (IRTFLG .NE. 0)  GOTO 999
#else
a159 1
#endif
d163 1
d166 1
a166 6
        IF (MYPID .EQ. 0) THEN
           CLOSE(IOPIC)
        ENDIF
        CALL MPI_BARRIER(COMM,IERR)
#else
        CLOSE(IOPIC)
a167 1

a172 8
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
           CALL OPFILEC(0,.FALSE.,FINFO,IOPIC,'N',IFORM,LSDD2,N2,N2,
     &                  MAXIM,'DUMMY',.FALSE.,IRTFLG)
        ENDIF
        CALL MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, COMM, IERR)
        IF (IRTFLG .NE. 0)  GOTO 999
#else
a175 1
#endif
d180 1
d182 1
a182 6
        IF (MYPID .EQ. 0) THEN
           CLOSE(IOPIC)
        ENDIF
        CALL MPI_BARRIER(COMM,IERR)
#else
        CLOSE(IOPIC)
a218 8
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
           CALL OPFILEC(0,.FALSE.,FINPAT,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &                  MAXIM,' ',.FALSE.,IRTFLG)
        ENDIF
        CALL MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, COMM, IERR)
        IF (IRTFLG .NE. 0) GOTO 999
#else
a221 1
#endif
d225 1
d227 1
a227 6
        IF (MYPID .EQ. 0) THEN
           CLOSE(IOPIC)
        ENDIF
        call MPI_BARRIER(COMM, IERR)
#else
        CLOSE(IOPIC)
a269 8
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
           CALL OPFILEC(0,.FALSE.,FINPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &                  MAXIM,'DUMMY',.FALSE.,IRTFLG)
        ENDIF
        call MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, COMM, IERR)
        IF (IRTFLG .NE. 0)  GOTO 999
#else
a272 1
#endif
d275 1
d277 1
a277 6
        IF (MYPID .EQ. 0) THEN
           CLOSE(IOPIC)
        ENDIF
        CALL MPI_BARRIER(COMM, IERR)
#else
        CLOSE(IOPIC)
a299 8
#ifdef USE_MPI
        IF (MYPID .EQ. 0) THEN
           CALL OPFILEC(0,.FALSE.,FINFO,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &                  MAXIM,' ',.FALSE.,IRTFLG)
        ENDIF
        CALL MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, COMM, IERR)
        IF (IRTFLG .NE. 0) GOTO 999
#else
a302 1
#endif
d306 1
d308 1
a308 6
        IF (MYPID .EQ. 0) THEN
           CLOSE(IOPIC)
        ENDIF
        CALL MPI_BARRIER(COMM, IERR)
#else
        CLOSE(IOPIC)
d365 16
a380 14
        include 'mpif.h'
        integer mypid, comm, ierr, nprocs
        integer istat(MPI_STATUS_SIZE)
        integer, allocatable, dimension(:) :: psize, nbase
                                                                                
        integer  nangloc, nrem, iproc, isam, jrow, jglb, jloc
        real   , allocatable, dimension(:,:,:) :: prjloc
        real   , allocatable, dimension(:,:,:) :: prjbuf
        real   , allocatable, dimension(:,:,:) :: WEloc, WOloc
        complex, allocatable, dimension(:,:,:) :: XEloc, XOloc

        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid , ierr)
        call MPI_COMM_SIZE(comm, nprocs, ierr)
d449 1
d451 6
a456 6
c
c       Distribute particles to processors.
c       nangloc is the number of particles assigned
c       to each processor.
c
        allocate(psize(nprocs),STAT=IRTFLG)
d458 1
a458 1
           CALL ERRT(46,'BP 3F, psize',IER)
d461 1
a461 1
        allocate(nbase(nprocs),STAT=IRTFLG)
d463 1
a463 1
           CALL ERRT(46,'BP 3F, nbase',IER)
d466 12
a477 11
c
c       setpart returns the size of the local piece
c       and the global offset.
c
        call setpart(nang, psize, nbase)
        nangloc = psize(mypid+1)
c
c       2-D images are distributed and held in prjloc
c       on each processor
c
        allocate(prjloc(NS,NS,nangloc),stat=irtflg)
d479 1
a479 1
           CALL ERRT(46,'BP 3F, prjloc',IER)
d482 29
a510 35
c
c       Processor 0 reads image files and distribute them.
c       (this version assumes that there is sufficient
c        memory to hold nang/nprocs images)
c
        if (mypid .eq. 0) then
c
c           Read images into the buffer first, then distributed
c
            allocate(prjbuf(NS, NS, nangloc),stat=irtflg)
            IF (IRTFLG .NE. 0) THEN
               CALL ERRT(46,'BP 3F, prjbuf',IER)
               RETURN
            ENDIF
            do iproc = 1, nprocs
               nangloc = psize(iproc)
c
c              read a bunch of 2-D images
c
               do jloc = 1, nangloc
                  jglb = nbase(iproc) + jloc
                  CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(jglb),IRTFLG)
                  IF (IRTFLG .NE. 0) GOTO 9999
                  MAXIM = 0
                  CALL OPFILEC(0      ,.FALSE., FINPIC, INPROJ, 'O'  ,
     &                         IFORM  , NSAM  , NSAM  , NSL   , MAXIM,
     &                         'DUMMY',.FALSE., IRTFLG)
                  IF (IRTFLG .NE. 0) GOTO 9999
                  CALL READV(INPROJ,prjbuf(1,1,jloc),NS,NS,NS,NS,1)
                  CLOSE(INPROJ)
               enddo
c
               if (iproc .gt. 1) then
c
c                 Send to another processor
d512 1
a512 1
                  write(6,*) 'WIW32DQ: Sending to pid = ', iproc-1
d514 18
a531 33
                  call MPI_SEND(prjbuf , NS*NS*nangloc, MPI_REAL,
     &                          iproc-1, iproc-1          , comm    ,
     &                          ierr)
                  if (ierr .ne. 0) then
                     write(6,*) 'WIW32DQ: Send error!'
                     stop
                  endif
               else
c
c                 Keep for myself
c
                  do jloc = 1, nangloc
                     do isam = 1, NS
                        do jrow = 1, NS
                             prjloc(isam,jrow,jloc)
     &                     = prjbuf(isam,jrow,jloc)
                        end do
                     end do
                  end do
               end if
            end do
            if (allocated(prjbuf)) deallocate(prjbuf)
        else
c
c         Receive projection images from processor 0
c
          call MPI_RECV(prjloc, NS*NS*nangloc, MPI_REAL,
     &                  0     , MPI_ANY_TAG      , comm    ,
     &                  istat , ierr)
          if (ierr .ne. 0) then
             write(6,*) 'WIW32DQ: recv failed'
             stop
          end if
d533 2
a534 2
          write(6,111) mypid
 111      format(1x,'WIW32DQ: mypid = ', I3, ' received!')
d536 4
a539 1
        end if
d541 21
a561 11
c           *** WHAT TO DO WITH THIS? ***
c
C           IF (.NOT. ANGINDOC) THEN
C             GET ANGLES FROM HEADER
C              ANGBUF(1) = INUMBRT(K)
C              CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
C              CALL BUILDM(INUMBRT,DM,1,ANGBUF,.FALSE.,SSDUM,
C     &                  .FALSE.,IRTFLG)
C              IF (IRTFLG .NE. 0) GOTO 9999
C           ENDIF
C           CLOSE(INPROJ)
d563 1
a563 1
c       Perform calculations in parallel now
d565 1
a565 1
        ALLOCATE (WEloc(0:N2,N,N), XEloc(0:N2,N,N), STAT=IRTFLG)
d567 1
a567 1
           CALL ERRT(46,'BP 3F, WEloc, XEloc',IER)
d570 1
a570 1
        ALLOCATE (WOloc(0:N2,N,N), XOloc(0:N2,N,N), STAT=IRTFLG)
d572 1
a572 1
           CALL ERRT(46,'BP 3F, WOloc, XOloc',IER)
d578 4
a581 4
                 XEloc(I,J,K)=CMPLX(0.0,0.0)
                 XOloc(I,J,K)=CMPLX(0.0,0.0)
                 WEloc(I,J,K)=0.0
                 WOloc(I,J,K)=0.0
d586 4
a589 4
        nangloc = psize(mypid+1)
        do jloc = 1, nangloc
           jglb = nbase(mypid+1) + jloc
           CALL PADD2(prjloc(1,1,jloc),NS,BI,LSD,N)
d601 2
a602 2
C                symmetries, multiply matrices
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,jglb))
d604 1
a604 1
                 DMS=DM(:,:,jglb)
d617 2
a618 1
        end do
d620 2
a621 2
c       Sum up X and W from the local pieces (Xloc, Wloc)
c       residing on each processor
d623 33
a655 27
        call MPI_ALLREDUCE(XEloc  , XE  , (N2+1)*N*N, MPI_COMPLEX,
     &                     MPI_SUM, comm, ierr)
        if ( ierr. ne. 0 ) then
           write(6,*) 'WIW32DQ: Failed to ALLREDUCE'
           stop
        end if
        call MPI_ALLREDUCE(XOloc  , XO  , (N2+1)*N*N, MPI_COMPLEX,
     &                     MPI_SUM, comm, ierr)
        if ( ierr. ne. 0 ) then
           write(6,*) 'WIW32DQ: Failed to ALLREDUCE'
           stop
        end if
        call MPI_ALLREDUCE(WEloc  , WE  , (N2+1)*N*N, MPI_REAL,
     &                     MPI_SUM, comm, ierr)
        if ( ierr. ne. 0 ) then
           write(6,*) 'WIW32DQ: Failed to ALLREDUCE'
           stop
        end if
        call MPI_ALLREDUCE(WOloc  , WO  , (N2+1)*N*N, MPI_REAL,
     &                     MPI_SUM, comm, ierr)
        if ( ierr. ne. 0 ) then
           write(6,*) 'WIW32DQ: Failed to ALLREDUCE'
           stop
        end if
        IF (ALLOCATED(XOloc))    DEALLOCATE (XOloc)
        IF (ALLOCATED(XEloc))    DEALLOCATE (XEloc)
        IF (ALLOCATED(WOloc))    DEALLOCATE (WOloc)
d658 1
a658 1
        write(6,*) 'WIW32DQ: Completed global sum, mypid = ', mypid
@


1.44
log
@mpi
@
text
@d112 1
a112 1
      &                 .FALSE.,IRTFLG)
d436 1
a436 1
c
d447 1
a447 1
c
d472 1
a472 1
C       CANNOT BE PARALLEL AS THERE ARE DATA SATEMENTS IN BESSI
d633 2
a634 1
C              CALL BUILDM(INUMBRT,DM,1,ANGBUF,.FALSE.,SSDUM,IRTFLG)
d638 1
a638 2
C
c
d640 1
a640 1
c
d668 1
a668 1
c
d674 1
a674 1
c
d682 1
a682 1
c
d694 1
a694 1
c
d697 1
a697 1
c
d750 2
a751 1
              CALL BUILDM(INUMBRT,DM,1,ANGBUF,.FALSE.,SSDUM,IRTFLG)
@


1.43
log
@buildm parameters changed
@
text
@d11 1
a21 2
C  IMAGE_PROCESSING_ROUTINE
C
d49 1
a49 2
        integer mypid, comm, ierr
                                                                                
d51 3
a53 1
        call MPI_COMM_RANK(comm, mypid, ierr)
d66 1
a66 1
        if (mypid .eq. 0) then
d112 1
a112 1
     &                 .FALSE.,IRTFLG)
d164 1
a164 1
        if (mypid .eq. 0) then
d167 1
a167 1
        endif
d178 1
d180 1
a180 1
        if (mypid .eq. 0) then
d182 2
a183 2
        endif
        call MPI_BARRIER(comm,ierr)
d194 1
a194 1
        if (mypid .eq. 0) then
d197 2
a198 2
        endif
        call MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, comm, ierr)
d210 1
a210 1
        if (mypid .eq. 0) then
d212 2
a213 2
        endif  
        call MPI_BARRIER(comm,ierr)
d253 1
a253 1
        if (mypid .eq. 0) then
d256 2
a257 2
        endif
        call MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, comm, ierr)
d266 1
d268 1
a268 1
        if (mypid .eq. 0) then
d270 2
a271 2
        endif
        call MPI_BARRIER(comm, ierr)
d317 1
a317 1
        if (mypid .eq. 0) then
d320 2
a321 2
        endif
        call MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, comm, ierr)
d331 1
a331 1
        if (mypid .eq. 0) then
d333 2
a334 2
        endif
        call MPI_BARRIER(comm, ierr)
d360 1
a360 1
        if (mypid .eq. 0) then
d363 2
a364 2
        endif
        call MPI_BCAST(IRTFLG, 1, MPI_INTEGER, 0, comm, ierr)
d375 1
a375 1
        if (mypid .eq. 0) then
d377 2
a378 2
        endif
        call MPI_BARRIER(comm, ierr)
d442 2
a443 2
        integer  nangloc, nrem, iproc, isam, jrow, kglb, kloc
        real   , allocatable, dimension(:,:,:) :: prkloc
d542 1
a542 1
c       2-D images are distributed and held in prkloc
d545 1
a545 1
        allocate(prkloc(NS,NS,nangloc),stat=irtflg)
d547 1
a547 1
           CALL ERRT(46,'BP 3F, prkloc',IER)
d569 3
a571 3
               do kloc = 1, nangloc
                  kglb = nbase(iproc) + kloc
                  CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(kglb),IRTFLG)
d578 1
a578 1
                  CALL READV(INPROJ,prjbuf(1,1,kloc),NS,NS,NS,NS,1)
d599 1
a599 1
                  do kloc = 1, nangloc
d602 2
a603 2
                             prkloc(isam,jrow,kloc)
     &                     = prjbuf(isam,jrow,kloc)
d614 1
a614 1
          call MPI_RECV(prkloc, NS*NS*nangloc, MPI_REAL,
d629 8
a636 10
        IF (.NOT. ANGINDOC) THEN
c
            write(6,*) 'ha ha ....'
c            GET ANGLES FROM HEADER
            ANGBUF(1) = INUMBRT(K)
            CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
            CALL BUILDM(INUMBRT,DM,1,ANGBUF,.FALSE.,SSDUM,IRTFLG)
            IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
        CLOSE(INPROJ)
d663 3
a665 3
        do kloc = 1, nangloc
           kglb = nbase(mypid+1) + kloc
           CALL PADD2(prkloc(1,1,kloc),NS,BI,LSD,N)
d678 1
a678 1
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,kglb))
d680 1
a680 1
                 DMS=DM(:,:,kglb)
d683 1
a683 2
             IF (RANDLIST(kglb)) THEN
                 write(6,*) ' even: kglb = ', kglb
a687 1
                 write(6,*) ' odd: kglb = ', kglb
@


1.42
log
@mpi
@
text
@d10 1
d111 2
a112 1
           CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),.FALSE.,SSDUM,IRTFLG)
@


1.41
log
@reang --> buildm (incorporating cang call)
@
text
@d47 7
d64 5
d70 1
d156 1
a156 1
       CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3D',IRTFLG)
d161 8
d172 1
d176 6
a181 1

d183 1
d190 8
d201 1
d206 6
d213 1
d248 9
d260 1
d263 6
d270 1
d277 1
a277 1
	
a286 1

d312 8
d323 1
d326 6
d333 1
d355 8
d366 1
d370 6
d377 1
d425 24
d513 219
d805 1
@


1.40
log
@opfilec
@
text
@d4 6
a9 5
C  WIW32D.F                                           01/10/00
C                        ANGLES IN HEADER JULY 01 ArDean Leith
C                        OPFILE 'U'       FEB  02 ArDean Leith
C                        BESSELS         05/03/02 P.A.Penczek
C                        OPFILEC          FEB  03 ARDEAN LEITH
d13 1
a13 2
C *  WIW32F.F
C *  COPYRIGHT (C)2002, P.A.PENCZEK
d97 1
a97 1
           CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
d415 1
a415 1
              CALL BUILDM(INUMBRT,DM,1,ANGBUF,IRTFLG)
@


1.39
log
@INUMBR clash
@
text
@d8 1
d80 1
a80 1
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
d147 2
a148 1
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'N',IFORM,LSD,N2,N2,
d161 2
a162 1
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'N',IFORM,LSDD2,N2,N2,
d203 2
a204 1
        CALL OPFILE(.FALSE.,FINPAT,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d212 2
a213 1
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'O',IFORM,LSD,N2,N2,
d221 2
a222 1
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'O',IFORM,LSDD2,N2,N2,
d251 2
a252 1
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d278 2
a279 1
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d405 1
a405 1
           CALL OPFILE(.FALSE.,FINPIC,INPROJ,'O',IFORM,NSAM,NROW,NSL,
@


1.38
log
@cmlimit needed
@
text
@d295 1
a295 1
     &                      INUMBR,DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
d306 1
a306 1
        DIMENSION        INUMBR(NANG)
d393 1
a393 1
           CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(K),IRTFLG)
d405 1
a405 1
              ANGBUF(1) = INUMBR(K)
d407 1
a407 1
              CALL BUILDM(INUMBR,DM,1,ANGBUF,IRTFLG)
@


1.37
log
@fixes from 1.36 put into 1.34
@
text
@d297 2
@


1.36
log
@corrected
@
text
@d1 1
a1 1
#if 1
d4 5
a8 2
C  WIW32D.F
C                                                    05/03/02
d12 2
a13 2
C *  COPYRIGHT (C)2002, P.A.Penczek
C *  University of Texas - Houston Medical School
a14 2
C *    THE CONTENTS OF THIS DOCUMENT CANNOT BE CHANGED WITHOUT WRITTEN
C *    PERMISSION OF THE AUTHOR                          *
d17 1
a17 1
C   WIW32F
d19 1
a19 1
C IMAGE_PROCESSING_ROUTINE
a20 1
C        1         2         3         4         5         6         7
d25 1
a25 1
C
d31 3
a33 2
        REAL, DIMENSION(:,:), POINTER :: ANGBUF, ANGSYM
        REAL, DIMENSION(:,:), ALLOCATABLE :: DM,SM 
d35 5
a39 2
        REAL, ALLOCATABLE, DIMENSION(:,:,:) :: WE,WO
        REAL, DIMENSION(:), ALLOCATABLE :: TEMP
a42 1
        CHARACTER*1     NULL
d45 2
a46 1
        NULL = CHAR(0)
d57 1
a57 1
2001    FORMAT(' NUMBER OF IMAGES =',I5)
d60 3
a62 2
        MAXXT = 4
        MAXYT = MAXNUM
d64 2
a65 2
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
d68 2
a69 2
        MAXXS=0
        MAXSYM=0
d72 1
a72 1
        IF(IRTFLG.NE.0)  MAXSYM=1
d76 1
a76 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ANGBUF)
           RETURN
        ENDIF
d79 1
a79 1
        CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAM,NROW,NSL,
d81 1
a81 4
        IF (IRTFLG .NE. 0) THEN 
           DEALLOCATE (ANGBUF)
           RETURN
        ENDIF
d88 7
a94 2
        ALLOCATE(DM(9,NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) CALL ERRT(46,'BP 32F, DM',IER)
d96 10
a105 5
        CALL  BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)

        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ANGBUF,DM)
           RETURN
a106 1
        DEALLOCATE(ANGBUF)
d108 1
a108 1
        IF(MAXSYM.GT.1)  THEN
d112 1
a112 2
              DEALLOCATE (DM)
              RETURN
d114 2
a115 2
           CALL  BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
d117 1
a117 1
        ELSE
d120 2
a121 2
               CALL ERRT(46,'BP 3F, SM-2nd',IER)
               DEALLOCATE (DM)
d125 2
a126 1
        ALLOCATE (XE(0:N2/2,N2,N2), STAT=IRTFLG)
d128 2
a129 3
           CALL ERRT(46,'BP 32F, XE',IER)
           DEALLOCATE(DM,SM)
           RETURN
d132 3
a134 6
        ALLOCATE (WE(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, WE',IER)
           DEALLOCATE(DM,SM,XE)
           RETURN
        ENDIF
d136 2
a137 6
        ALLOCATE (XO(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, XO',IER)
           DEALLOCATE(DM,SM,XE,WE)
           RETURN
        ENDIF
d139 2
a140 23
        ALLOCATE (WO(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, WO',IER)
           DEALLOCATE(DM,SM,XE,WE,XO)
           RETURN
        ENDIF

        CALL  WIW32DQ
     &      (NSAM,XE,WE,XO,WO,
     &      LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM)

        CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',ITRFLG) 
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF

        CALL  FILERD(FINPAT,NLETI,NULL,
     &		'RECONSTRUCTED FIRST HALF 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d142 2
a143 6
       CALL  FILERD(FINFO,NLETI,NULL,
     &		'RECONSTRUCTED SECOND HALF 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d146 1
a146 1
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'N',LSD,N2,N2,
d148 1
a148 5
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d150 1
a150 1
C STORE FOURIER XE TEMPORARILY 
d157 1
a157 1
        LSDD2=LSD/2
d159 1
a159 1
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'N',LSDD2,N2,N2,
d161 1
a161 5
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d163 1
a163 2

C STORE WEIGHT WE TEMPORARILY 
d170 17
a186 14
C NOW XE IS READY, SYMMETRIZE IF NECESSARY
C  Additional symmetrization of the volume XE in real space 05/03/02
	IF(MAXSYM.GT.1)  THEN
        ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, TEMP',IER)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
        ENDIF
	CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
c$omp parallel do private(i,j,k)
        DO    K=1,N2
           DO    J=1,N2
              DO    I=0,N2/2
                 XE(I,J,K)=CMPLX(0.0,0.0)
a188 1
        ENDDO
d196 1
a196 1
	CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
d200 3
a202 7
        CALL OPFIL(.FALSE.,FINPAT,IOPIC,'N',NSAM,NSAM,NSAM,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
a203 1

a204 1

d208 3
a210 9
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'O',LSD,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF


a212 3
	


d216 1
a216 1
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'O',LSDD2,N2,N2,
d218 2
a219 6
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
 
d222 1
a223 1
        CLOSE(IOPIC)
d229 11
a239 9
C TOTAL VOLUME IS READY
C  Additional symmetrization of the volume TOTAL in real space 05/03/02
	IF(MAXSYM.GT.1)  THEN
	CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
c$omp parallel do private(i,j,k)
        DO    K=1,N2
           DO    J=1,N2
              DO    I=0,N2/2
                 XE(I,J,K)=CMPLX(0.0,0.0)
d242 1
a242 2
        ENDDO
	CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
d245 1
a245 1
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'N',NSAM,NSAM,NSAM,
d247 1
a247 5
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
a249 1

d254 12
a265 9
C XO VOLUME IS READY
C  Additional symmetrization of the volume XO in real space 05/03/02
	IF(MAXSYM.GT.1)  THEN
	CALL COP(XO,TEMP,NSAM*NSAM*NSAM)
c$omp parallel do private(i,j,k)
        DO    K=1,N2
           DO    J=1,N2
              DO    I=0,N2/2
                 XO(I,J,K)=CMPLX(0.0,0.0)
d268 1
a268 3
        ENDDO
	CALL SYMVOL(TEMP,XO,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	DEALLOCATE(TEMP)
d271 3
a273 8
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'N',NSAM,NSAM,NSAM,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF

d279 11
a289 1
        DEALLOCATE (DM, SM, XE, WE, XO, WO)
d295 1
a295 1
     &                      INUMBR,DM,NANG,SM,MAXSYM)
d297 3
a299 3

        LOGICAL, DIMENSION(:), ALLOCATABLE :: RANDLIST
        REAL, DIMENSION(:,:), ALLOCATABLE :: PROJ
d301 1
d306 1
d309 1
d312 1
d315 2
a316 1
C In this version the order of the Bessel function is mmm=1
d322 2
a323 1
C K=6
d326 2
a327 2
C Generalized Kaiser-Bessel window according to Lewitt
C M=NS, N=N
d341 3
a343 2
C  Cannot be parallel as there are DATA satements in BESSI
cc$omp parallel do private(i,s,x),shared(mmm)
d345 7
a351 11
	 S=REAL(I)/FLTB/N
	 IF(S.LE.AAAA)  THEN
	  X=SQRT(1.0-(S/AAAA)**2)
	  TABI(I)=
C(SQRT(ALPHA*X)**mmm)*BESSI(mmm,ALPHA*X)/B0
CTEMPO=
     &		SQRT(ALPHA*X)*BESI1(ALPHA*X)/B0
C	if(abs(tabi(i)-tempo).gt.1.0e-5)  print  *,'bessi',i
	 ELSE
	  TABI(I)=0.0
	 ENDIF
d354 1
a354 1
c$omp parallel do private(i,j,k)
d366 1
a366 1
        ALLOCATE (PROJ(NS,NS), STAT=IRTFLG)
d368 1
a368 1
           CALL ERRT(46,'BP 32F, PROJ',IER)
d372 2
a373 18

        ALLOCATE (BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, BI',IER)
           DEALLOCATE (PROJ)
	   RETURN
        ENDIF


        ALLOCATE (RANDLIST(NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, RANDLIST',IER)
           DEALLOCATE (PROJ,BI)
	   RETURN
        ENDIF

	RANDLIST(1:NANG/2)=.TRUE.
	RANDLIST(NANG/2+1:NANG)=.FALSE.
d376 5
a380 5
         CALL  RANDOM_NUMBER(HARVEST=X)
         IORD = MIN0(NANG,MAX0(1,INT(X*NANG+0.5)))
	 ITMP=RANDLIST(IORD)
	 RANDLIST(IORD)=RANDLIST(K)
	 RANDLIST(K)=ITMP
d383 3
a385 2
#ifdef SP_MP
	LN1=LN+1
d387 1
a387 1
        DO    K=1,NANG
d392 1
a392 1
           IF (IRTFLG .NE. 0) RETURN
d395 3
a397 3
           CALL OPFIL(.FALSE.,FINPIC,INPROJ,'O',NSAM,NROW,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d400 8
d413 4
a416 4
c$omp parallel do private(i,j)
           DO  J=1,N
              DO  I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
d421 3
a423 3
              IF(MAXSYM.GT.1)  THEN
C  symmetries, multiply matrices
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
d428 2
a429 2
           IF (RANDLIST(K))  THEN
	    DO  JT=1,LN1
d432 12
a443 12
            DO J=-N2+JT,N2,LN1
              CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
             ENDDO
            ENDDO
           ELSE
	    DO  JT=1,LN1
c$omp parallel do private(j),shared(N,N2,JT,XO,WO,BI,DMS)
             DO J=-N2+JT,N2,LN1
              CALL  ONELINE(J,N,N2,XO,WO,BI,DMS)
             ENDDO
            ENDDO
          ENDIF
d445 3
a447 3
              IF (RANDLIST(K))  THEN
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
d450 2
a451 2
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XO,WO,BI,DMS)
d455 1
a455 1
C   END OF SYMMETRIES LOOP
d462 2
a463 2
c$omp parallel sections
c$omp section
d465 1
a465 1
c$omp section
d467 5
a471 1
c$omp end parallel sections
a472 1
        DEALLOCATE (PROJ, BI, RANDLIST)
d474 1
d485 6
a490 6
c        TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
        IP=(N-L)/2+MOD(L,2)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 R(I,J,K)=BI(IP+I,IP+J,IP+K)
d495 6
a500 6
C
        L2=(L/2)**2
        L2P=(L/2-1)**2
        IP=L/2+1
	XNU=REAL(NNN)/2.
C+REAL(mmm)
d503 2
a504 2
	RI=RIBSL(ALPHA,XNU)
C	if(abs(ri-rin).gt.1.e-5)  print  *,'bessik'
d506 9
a514 9
	WKB0=ALPHA**XNU/RI
	QRT=(TWOPI*AAAA)**2
        TNR=0.0
        M=0
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF(LR.LE.L2) THEN
d516 2
a517 2
	          IF(ABS(SIGMA).LT.1.0E-7)  THEN
	           WKB=1.0
d519 4
a522 4
C   2PI A R > ALPHA
		   ART=SQRT(SIGMA)
C		   CALL  BESSJY(ART,XNU,RI,RK,RIP,RIK)
      		   RI=RJBSL(ART, XNU)
d524 1
a524 1
	           WKB=WKB0*RI/ART**XNU
d526 4
a529 4
C   2PI A R < ALPHA
		   ART=SQRT(ABS(SIGMA))
C		   CALL  BESSIK(ART,XNU,RI,RK,RIP,RIK)
		   RI=RIBSL(ART,XNU)
d531 1
a531 1
	           WKB=WKB0*RI/ART**XNU
d534 3
a536 3
                  IF(LR.GE.L2P .AND. LR.LE.L2) THEN
                   TNR=TNR+R(I,J,K)
                   M=M+1
d542 5
a546 5
        TNR=TNR/REAL(M)
c$omp parallel do private(i,j,k,lr)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
d548 1
a548 1
                 IF(LR.LE.L2) THEN
a558 344
C
#else
C++************************************************************************
C
C  WIW32D.F                                           01/10/00
C                        ANGLES IN HEADER JULY 01 ArDean Leith
C                        OPFILE 'U'       FEB  02 ArDean Leith
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C   WIW32D
C
C IMAGE_PROCESSING_ROUTINE
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE WIW32D

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        INCLUDE 'F90ALLOC.INC'

C       DOC FILE POINTERS
        REAL, DIMENSION(:,:), POINTER ::          ANGBUF, ANGSYM
        REAL, DIMENSION(:,:), ALLOCATABLE ::      DM,SM 
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XE,XO
        REAL, ALLOCATABLE, DIMENSION(:,:,:) ::    WE,WO
        LOGICAL ::                                ANGINDOC
        CHARACTER(LEN=1) ::                       NULL

        CHARACTER*80    FINPIC,FINFO,ANGDOC,FINPAT
        COMMON /F_SPEC/ FINPAT,NLET,FINPIC

        DATA  IOPIC/98/,INPIC/99/

        NULL   = CHAR(0)
        NILMAX = NIMAX

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,INUMBR,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        MAXNUM = MAXVAL(INUMBR(1:NANG))
        CLOSE(INPIC)

C       NANG - TOTAL NUMBER OF IMAGES
        WRITE(NOUT,2001) NANG
2001    FORMAT(' NUMBER OF IMAGES =',I5)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        ANGINDOC = .TRUE.
        MAXXT    = 4
        MAXYT    = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) ANGINDOC = .FALSE.

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 0
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF (IRTFLG .NE. 0)  MAXSYM = 1

C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        MAXIM = 0
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CLOSE(INPIC)

        N2   = 2*NSAM
        LSD  = N2+2-MOD(N2,2)
        NMAT = LSD*N2*N2

        IF (ANGINDOC) THEN
        
           ALLOCATE(DM(9,NANG), STAT=IRTFLG)
           IF (IRTFLG.NE.0) GOTO 999

           CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
        
           IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        ELSE
           ALLOCATE(DM(9,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) GOTO 999
        ENDIF

        IF (MAXSYM.GT.1)  THEN
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, SM(9,MAXSYM)',IER)
              GOTO 999
           ENDIF
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)

        ELSE
           ALLOCATE(SM(1,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
               CALL ERRT(46,'BP 3F, SM(1,1)',IER)
               GOTO 999
           ENDIF
        ENDIF

        ALLOCATE(XE(0:N2/2,N2,N2),WE(0:N2/2,N2,N2),WO(0:N2/2,N2,N2),
     &            XO(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F; XE, WE, WO & XO',IER)
           GOTO 999
        ENDIF

        CALL  WIW32DQ(NSAM,XE,WE,XO,WO,
     &      LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM,SIR,ANGINDOC,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',IRTFLG) 
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3-D',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
 
        CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3-D',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'U',IFORM,LSD,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        CLOSE(IOPIC)

C       CBE AND CBO (XE & XO) ARE LSD x N2 x N2
C       CWE AND CWO (WE & WO) ARE (LSD/2) x N2 x N2
        LSDD2 = LSD/2
        IFORM = 3
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'U',IFORM,LSDD2,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)
        CLOSE(IOPIC)

        CALL NRMW2(XE,WE,N2/2,N2)
        CALL WIND2(XE,XE,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPAT,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'O',IFORM,LSD,N2,N2,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
        
        CALL READV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        CLOSE(IOPIC)

        CALL OPFILE(.FALSE.,FINFO,IOPIC,'O',IFORM,LSDD2,N2,N2,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
 
        CALL READV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)
        CLOSE(IOPIC)

C       ADD E+O
        CALL ADDADA(XE,XO,NMAT)
        CALL ADDADA(WE,WO,NMAT/2)
        CALL NRMW2(XE,WE,N2/2,N2)
        CALL WIND2(XE,XE,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

        CALL NRMW2(XO,WO,N2/2,N2)
        CALL WIND2(XO,XO,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL WRITEV(IOPIC,XO,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

 999    CONTINUE
        IF (ALLOCATED(DM))     DEALLOCATE(DM)
        IF (ALLOCATED(SM))     DEALLOCATE(SM)
        IF (ALLOCATED(XE))     DEALLOCATE(XE)
        IF (ALLOCATED(WE))     DEALLOCATE(WE)
        IF (ALLOCATED(XO))     DEALLOCATE(XO)
        IF (ALLOCATED(WO))     DEALLOCATE(WO)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)
        END

C       ---------------- WIW32DQ -------------------------------------

        SUBROUTINE  WIW32DQ(NS,XE,WE,XO,WO, LSD,N,N2,INUMBR,DM,
     &                      NANG,SM,MAXSYM,SIR,ANGINDOC,IRTFLG)

        INCLUDE 'CMLIMIT.INC'

        LOGICAL ::                              ANGINDOC
        REAL, DIMENSION(:,:), ALLOCATABLE ::    PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(4) ::                   ANGBUF
        DOUBLE PRECISION ::                     PI
        DIMENSION        WE(0:N2,N,N),WO(0:N2,N,N)
        COMPLEX          XE(0:N2,N,N),XO(0:N2,N,N)
        DIMENSION        INUMBR(NANG)
        DIMENSION        DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)

        CHARACTER*80     FINPIC,FINPAT
        COMMON  /F_SPEC/ FINPAT,NLET,FINPIC

        PARAMETER (LTAB=4999)
        COMMON  /TABS/  LN2,FLTB,TABI(0:LTAB)

        DATA  INPROJ/99/

        LN   = 5
        LN2  = LN/2
        PI   = 4.0D0*DATAN(1.0D0)
        SIG  = 3.0/PI
        SIG2 = SIG*SIG
C       SIGMA IN REAL SPACE
        SIR  = REAL(N)/(2.0*PI*SIG)

        TNR  = DSQRT(2.0D0*PI)*SIG
C       GENERATE TABLE WITH INTERPOLANTS
        FLTB = REAL(LTAB)/REAL(LN2+1)

c$omp   parallel do private(i)
        DO  I=0,LTAB
           TABI(I) = EXP(-0.5*((REAL(I)/FLTB)**2)/SIG2)/TNR
        ENDDO

c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=0,N2
                 XE(I,J,K)=CMPLX(0.0,0.0)
                 WE(I,J,K)=0.0
                 XO(I,J,K)=CMPLX(0.0,0.0)
                 WO(I,J,K)=0.0
              ENDDO
           ENDDO
        ENDDO

        ALLOCATE (PROJ(NS,NS),BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, PROJ & BI',IER)
           RETURN
        ENDIF

        DO K=1,NANG
C          print  *,' Projection #',K

C          OPEN DESIRED FILE
           CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(K),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

           MAXIM = 0
           CALL OPFILE(.FALSE.,FINPIC,INPROJ,'O',IFORM,NSAM,NROW,NSL,
     &                   MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

           DO  J=1,NS
              CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
           ENDDO
           IF (.NOT. ANGINDOC) THEN
C             GET ANGLES FROM HEADER
              ANGBUF(1) = INUMBR(K)
              CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
              CALL BUILDM(INUMBR,DM,1,ANGBUF,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 999
           ENDIF
           CLOSE(INPROJ)

           CALL PADD2(PROJ,NS,BI,LSD,N)
           INV=+1
           CALL FMRS_2(BI,N,N,INV)
c$omp      parallel do private(i,j)
           DO J=1,N
              DO I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO ISYM=1,MAXSYM
              IF (MAXSYM.GT.1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
              ELSE
                 DMS=DM(:,:,K)
              ENDIF
              IF (MOD(K,2).EQ.0)  THEN
c$omp            parallel do private(j),shared(N,N2,XE,WE,BI,DMS)
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
                 ENDDO
              ELSE
c$omp            parallel do private(j),shared(N,N2,XO,WO,BI,DMS)
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XO,WO,BI,DMS)
                 ENDDO
              ENDIF
C          END OF SYMMETRIES LOOP
           ENDDO

C       END OF PROJECTIONS LOOP
        ENDDO

C       SYMMETRIZE BOTH VOLUMES
c$omp   parallel sections
c$omp   section
        CALL  SYMPLANE0(XE,WE,N2,N)
c$omp   section
        CALL  SYMPLANE0(XO,WO,N2,N)
c$omp   end parallel sections
        IRTFLG = 0
a559 6
999     IF (ALLOCATED(PROJ)) DEALLOCATE (PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE (BI)

        END
#endif

d600 1
d602 2
a603 1
c$omp parallel do private(k)
d605 1
a605 1
           X(K)=X(K)+Y(K)
@


1.35
log
@reverted to revision 1.31 due to bug
@
text
@d1 1
a1 1

d214 2
a215 2
        DO    K=1,N
           DO    J=1,N
d285 2
a286 2
        DO    K=1,N
           DO    J=1,N
d314 2
a315 2
        DO    K=1,N
           DO    J=1,N
a444 1

d608 350
d1000 1
a1000 1
c$omp   parallel do private(k)
a1004 1

@


1.34
log
@itrflg --> itrflg
@
text
@d4 2
a5 5
C  WIW32D.F                                           01/10/00
C                        ANGLES IN HEADER JULY 01 ArDean Leith
C                        OPFILE 'U'       FEB  02 ArDean Leith
C                        BESSELS         05/03/02 P.A.Penczek
C
d9 2
a10 2
C *  COPYRIGHT (C)2002, P.A.PENCZEK
C *  UNIVERSITY OF TEXAS - HOUSTON MEDICAL SCHOOL
d12 2
d16 1
a16 1
C  WIW32D
d18 1
a18 1
C  IMAGE_PROCESSING_ROUTINE
d20 1
d25 1
a25 1

d31 2
a32 3
        REAL, DIMENSION(:,:), POINTER ::          ANGBUF, ANGSYM

        REAL, DIMENSION(:,:), ALLOCATABLE ::      DM,SM 
d34 2
a35 1
        REAL, ALLOCATABLE, DIMENSION(:,:,:) ::    WE,WO
a36 4
        REAL, DIMENSION(:), ALLOCATABLE ::        TEMP
        LOGICAL ::                                ANGINDOC
        CHARACTER(LEN=1) ::                       NULL

d39 1
d42 1
a42 2

        NULL   = CHAR(0)
d53 1
a53 1
2001    FORMAT(' NUMBER OF IMAGES: ',I7)
d56 2
a57 3
        ANGINDOC = .TRUE.
        MAXXT    = 4
        MAXYT    = MAXNUM
d59 2
a60 2
     &                 MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) ANGINDOC = .FALSE.
d63 2
a64 2
        MAXXS  = 0
        MAXSYM = 0
d67 1
a67 1
        IF (IRTFLG .NE. 0)  MAXSYM=1
d71 4
a74 1
        IF (IRTFLG .NE. 0) GOTO 999
d77 1
a77 1
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
d79 4
a82 1
        IF (IRTFLG .NE. 0) GOTO 999
d89 4
a92 7
        IF (ANGINDOC) THEN
        
           ALLOCATE(DM(9,NANG), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN
              CALL ERRT(46,'BP 32F, DM',IER)
              GOTO 999
           ENDIF
d94 3
a96 10
           CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
        
           IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        ELSE
           ALLOCATE(DM(9,1), STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'BP 32F, DM',IER)
              GOTO 999
           ENDIF
d98 1
d100 1
a100 1
        IF (MAXSYM .GT. 1)  THEN
d104 2
a105 1
              GOTO 999
d107 2
a108 2
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)
d110 1
a110 1
       ELSE
d113 2
a114 2
               CALL ERRT(46,'BP 3F, SM(1,1)',IER)
               GOTO 999
d118 15
a132 2
        ALLOCATE(XE(0:N2/2,N2,N2),WE(0:N2/2,N2,N2),WO(0:N2/2,N2,N2),
     &            XO(0:N2/2,N2,N2), STAT=IRTFLG)
d134 3
a136 2
           CALL ERRT(46,'BP 32F; XE, WE, WO & XO',IER)
           GOTO 999
d139 6
a144 3
        CALL  WIW32DQ(NSAM,XE,WE,XO,WO,
     &      LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
d146 9
a154 2
        CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3D',IRTFLG) 
        IF (IRTFLG .NE. 0)  GOTO 999
d156 6
a161 2
        CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3D',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
d163 6
a168 2
       CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3D',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
d171 1
a171 1
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'N',IFORM,LSD,N2,N2,
d173 5
a177 1
        IF (IRTFLG .NE. 0)  GOTO 999
d179 1
a179 1
C       STORE FOURIER XE TEMPORARILY 
d186 1
a186 1
        LSDD2 = LSD / 2
d188 1
a188 1
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'N',IFORM,LSDD2,N2,N2,
d190 6
a195 1
        IF (IRTFLG .NE. 0)  GOTO 999
d197 1
a197 1
C       STORE WEIGHT WE TEMPORARILY 
d204 14
a217 17

C       NOW XE IS READY, SYMMETRIZE IF NECESSARY
C       ADDITIONAL SYMMETRIZATION OF THE VOLUME XE IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
           ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 32F, TEMP',IER)
              GOTO 999
           ENDIF
	   CALL COP(XE,TEMP,NSAM*NSAM*NSAM)

c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,N2/2
                    XE(I,J,K)=CMPLX(0.0,0.0)
                 ENDDO
d220 1
d228 1
a228 1
	   CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
d232 7
a238 3
        CALL OPFILE(.FALSE.,FINPAT,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
d240 1
d242 1
d246 9
a254 3
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'O',IFORM,LSD,N2,N2,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
d257 3
d263 1
a263 1
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'O',IFORM,LSDD2,N2,N2,
d265 6
a270 1
        IF (IRTFLG .NE. 0) GOTO 999
d272 1
a273 1
        CALL READV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)
a274 1

d280 9
a288 11

C       TOTAL VOLUME IS READY
C       ADDITIONAL SYMMETRIZATION OF THE VOLUME TOTAL IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
	   CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,N2/2
                    XE(I,J,K)=CMPLX(0.0,0.0)
                 ENDDO
d291 2
a292 1
	   CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
d295 1
a295 1
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
d297 5
a301 1
        IF (IRTFLG .NE. 0)  GOTO 999
d304 1
d309 9
a317 12

C       XO VOLUME IS READY
C       ADDITIONAL SYMMETRIZATION OF THE VOLUME XO IN REAL SPACE 05/03/02
	IF (MAXSYM .GT. 1)  THEN
	   CALL COP(XO,TEMP,NSAM*NSAM*NSAM)

c$omp      parallel do private(i,j,k)
           DO K=1,N2
              DO J=1,N2
                 DO I=0,N2/2
                    XO(I,J,K) = CMPLX(0.0,0.0)
                 ENDDO
d320 3
a322 1
	   CALL SYMVOL(TEMP,XO,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
d325 8
a332 3
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &              MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
d338 1
a338 11
999     CONTINUE
        IF (ALLOCATED(DM))     DEALLOCATE(DM)
        IF (ALLOCATED(SM))     DEALLOCATE(SM)
        IF (ALLOCATED(XE))     DEALLOCATE(XE)
        IF (ALLOCATED(WE))     DEALLOCATE(WE)
        IF (ALLOCATED(XO))     DEALLOCATE(XO)
        IF (ALLOCATED(WO))     DEALLOCATE(WO)
        IF (ALLOCATED(TEMP))   DEALLOCATE(TEMP)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)
 
d344 2
a345 1
     &                      INUMBR,DM,NANG,SM,MAXSYM,ANGINDOC,IRTFLG)
d347 2
a348 3
        LOGICAL ::                              ANGINDOC
        LOGICAL, DIMENSION(:), ALLOCATABLE ::   RANDLIST
        REAL, DIMENSION(:,:), ALLOCATABLE ::    PROJ
a349 1
        REAL, DIMENSION(4) ::                   ANGBUF
a353 1

a355 1

a357 1

d360 1
a360 2

C       IN THIS VERSION THE ORDER OF THE BESSEL FUNCTION IS MMM=1
d366 1
a366 2

C       K=6
d369 2
a370 2
C       GENERALIZED KAISER-BESSEL WINDOW ACCORDING TO LEWITT
C       M=NS, N=N
d384 2
a385 3

C       CANNOT BE PARALLEL AS THERE ARE DATA SATEMENTS IN BESSI
cc$omp  parallel do private(i,s,x),shared(mmm)
d387 11
a397 7
	   S=REAL(I)/FLTB/N
	   IF (S.LE.AAAA)  THEN
	      X=SQRT(1.0-(S/AAAA)**2)
	      TABI(I)= SQRT(ALPHA*X)*BESI1(ALPHA*X)/B0
	  ELSE
	     TABI(I)=0.0
	  ENDIF
d400 3
a402 3
c$omp   parallel do private(i,j,k)
        DO  K=1,N2
           DO  J=1,N2
d412 1
a412 1
        ALLOCATE (PROJ(NS,NS),BI(0:N2,N),RANDLIST(NANG),STAT=IRTFLG)
d414 1
a414 1
           CALL ERRT(46,'BP 32F, PROJ...',NE)
d418 18
a435 2
	RANDLIST(1:NANG/2)      = .TRUE.
	RANDLIST(NANG/2+1:NANG) = .FALSE.
d438 5
a442 5
           CALL  RANDOM_NUMBER(HARVEST=X)
           IORD = MIN0(NANG,MAX0(1,INT(X*NANG+0.5)))
	   ITMP = RANDLIST(IORD)
	   RANDLIST(IORD) = RANDLIST(K)
	   RANDLIST(K)    = ITMP
d446 2
a447 2
#ifdef  SP_MP
	LN1 = LN+1
d449 1
a449 1
        DO K=1,NANG
d454 1
a454 1
           IF (IRTFLG .NE. 0) GOTO 9999
d457 3
a459 3
           CALL OPFILE(.FALSE.,FINPIC,INPROJ,'O',IFORM,NSAM,NROW,NSL,
     &                   MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
a461 8

           IF (.NOT. ANGINDOC) THEN
C             GET ANGLES FROM HEADER
              ANGBUF(1) = INUMBR(K)
              CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
              CALL BUILDM(INUMBR,DM,1,ANGBUF,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
           ENDIF
d467 4
a470 4
c$omp      parallel do private(i,j)
           DO J=1,N
              DO I=0,N2
                 BI(I,J) = BI(I,J)*(-1)**(I+J+1)
d475 3
a477 3
              IF (MAXSYM. GT. 1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS = MATMUL(SM(:,:,ISYM),DM(:,:,K))
d482 2
a483 2
              IF (RANDLIST(K)) THEN
	         DO JT=1,LN1
d486 12
a497 12
                    DO J=-N2+JT,N2,LN1
                       CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
                    ENDDO
                ENDDO
             ELSE
	        DO JT=1,LN1
c$omp           parallel do private(j),shared(N,N2,JT,XO,WO,BI,DMS)
                   DO J=-N2+JT,N2,LN1
                      CALL ONELINE(J,N,N2,XO,WO,BI,DMS)
                   ENDDO
                ENDDO
             ENDIF
d499 3
a501 3
             IF (RANDLIST(K)) THEN
                 DO J=-N2+1,N2
                    CALL ONELINE(J,N,N2,XE,WE,BI,DMS)
d504 2
a505 2
                 DO J=-N2+1,N2
                    CALL ONELINE(J,N,N2,XO,WO,BI,DMS)
d509 1
a509 1
C             END OF SYMMETRIES LOOP
d516 2
a517 2
c$omp   parallel sections
c$omp   section
d519 1
a519 1
c$omp   section
d521 1
a521 5
c$omp   end parallel sections

9999    IF (ALLOCATED(PROJ)) DEALLOCATE (PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE (BI)
        IF (ALLOCATED(RANDLIST)) DEALLOCATE (RANDLIST)
d523 1
a524 1

d535 6
a540 6
c       TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
        IP = (N-L)/2+MOD(L,2)
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 R(I,J,K) = BI(IP+I,IP+J,IP+K)
d545 6
a550 6

        L2  = (L/2)**2
        L2P = (L/2-1)**2
        IP  = L/2+1
	XNU = REAL(NNN)/2.
C       +REAL(mmm)
d553 2
a554 2
	RI = RIBSL(ALPHA,XNU)
C	IF (ABS(RI-RIN).GT.1.E-5)  PRINT  *,'BESSIK'
d556 9
a564 9
	WKB0 = ALPHA**XNU/RI
	QRT  = (TWOPI*AAAA)**2
        TNR  = 0.0
        M    = 0
        DO K=1,L
           DO J=1,L
              DO I=1,L
                 LR = (K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF (LR.LE.L2) THEN
d566 2
a567 2
	          IF (ABS(SIGMA).LT.1.0E-7)  THEN
	             WKB=1.0
d569 4
a572 4
C                    2PI A R > ALPHA
		     ART = SQRT(SIGMA)
C		     CALL BESSJY(ART,XNU,RI,RK,RIP,RIK)
      		     RI = RJBSL(ART, XNU)
d574 1
a574 1
	             WKB=WKB0*RI/ART**XNU
d576 4
a579 4
C                    2PI A R < ALPHA
		     ART = SQRT(ABS(SIGMA))
C		     CALL BESSIK(ART,XNU,RI,RK,RIP,RIK)
		     RI = RIBSL(ART,XNU)
d581 1
a581 1
	             WKB=WKB0*RI/ART**XNU
d584 3
a586 3
                  IF (LR.GE.L2P .AND. LR.LE.L2) THEN
                      TNR=TNR+R(I,J,K)
                      M=M+1
d592 5
a596 5
        TNR = TNR/REAL(M)
c$omp   parallel do private(i,j,k,lr)
        DO K=1,L
           DO J=1,L
              DO I=1,L
d598 1
a598 1
                 IF (LR.LE.L2) THEN
a649 1

a650 1

d653 1
a653 1
           X(K) = X(K)+Y(K)
d656 1
@


1.33
log
@put back angindoc,  fixed error handling, used opfile, & many cosmetic
@
text
@d136 1
a136 1
        CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',ITRFLG) 
d139 1
a139 1
        CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3-D',ITRFLG)
d142 1
a142 1
       CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3-D',ITRFLG)
@


1.32
log
@corrected  sym
@
text
@d1 1
a1 1
#if 1
d4 5
a8 2
C  WIW32D.F
C                                                    05/03/02
d12 2
a13 2
C *  COPYRIGHT (C)2002, P.A.Penczek
C *  University of Texas - Houston Medical School
a14 2
C *    THE CONTENTS OF THIS DOCUMENT CANNOT BE CHANGED WITHOUT WRITTEN
C *    PERMISSION OF THE AUTHOR                          *
d17 1
a17 1
C   WIW32F
d19 1
a19 1
C IMAGE_PROCESSING_ROUTINE
a20 1
C        1         2         3         4         5         6         7
d25 1
a25 1
C
d31 3
a33 2
        REAL, DIMENSION(:,:), POINTER :: ANGBUF, ANGSYM
        REAL, DIMENSION(:,:), ALLOCATABLE :: DM,SM 
d35 5
a39 2
        REAL, ALLOCATABLE, DIMENSION(:,:,:) :: WE,WO
        REAL, DIMENSION(:), ALLOCATABLE :: TEMP
a42 1
        CHARACTER*1     NULL
d45 2
a46 1
        NULL = CHAR(0)
d57 1
a57 1
2001    FORMAT(' NUMBER OF IMAGES =',I5)
d60 3
a62 2
        MAXXT = 4
        MAXYT = MAXNUM
d64 2
a65 2
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
d68 2
a69 2
        MAXXS=0
        MAXSYM=0
d72 1
a72 1
        IF(IRTFLG.NE.0)  MAXSYM=1
d76 1
a76 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ANGBUF)
           RETURN
        ENDIF
d79 1
a79 1
        CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAM,NROW,NSL,
d81 1
a81 4
        IF (IRTFLG .NE. 0) THEN 
           DEALLOCATE (ANGBUF)
           RETURN
        ENDIF
d88 7
a94 2
        ALLOCATE(DM(9,NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) CALL ERRT(46,'BP 32F, DM',IER)
d96 10
a105 5
        CALL  BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)

        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ANGBUF,DM)
           RETURN
a106 1
        DEALLOCATE(ANGBUF)
d108 1
a108 1
        IF(MAXSYM.GT.1)  THEN
d112 1
a112 2
              DEALLOCATE (DM)
              RETURN
d114 2
a115 2
           CALL  BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
d117 1
a117 1
        ELSE
d120 2
a121 2
               CALL ERRT(46,'BP 3F, SM-2nd',IER)
               DEALLOCATE (DM)
d125 2
a126 1
        ALLOCATE (XE(0:N2/2,N2,N2), STAT=IRTFLG)
d128 2
a129 3
           CALL ERRT(46,'BP 32F, XE',IER)
           DEALLOCATE(DM,SM)
           RETURN
d132 3
a134 6
        ALLOCATE (WE(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, WE',IER)
           DEALLOCATE(DM,SM,XE)
           RETURN
        ENDIF
a135 18
        ALLOCATE (XO(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, XO',IER)
           DEALLOCATE(DM,SM,XE,WE)
           RETURN
        ENDIF

        ALLOCATE (WO(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, WO',IER)
           DEALLOCATE(DM,SM,XE,WE,XO)
           RETURN
        ENDIF

        CALL  WIW32DQ
     &      (NSAM,XE,WE,XO,WO,
     &      LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM)

d137 1
a137 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d139 2
a140 6
        CALL  FILERD(FINPAT,NLETI,NULL,
     &		'RECONSTRUCTED FIRST HALF 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d142 2
a143 6
       CALL  FILERD(FINFO,NLETI,NULL,
     &		'RECONSTRUCTED SECOND HALF 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d146 1
a146 1
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'N',LSD,N2,N2,
d148 1
a148 5
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d150 1
a150 1
C STORE FOURIER XE TEMPORARILY 
d157 1
a157 1
        LSDD2=LSD/2
d159 1
a159 1
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'N',LSDD2,N2,N2,
d161 1
a161 6
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF

d163 1
a163 1
C STORE WEIGHT WE TEMPORARILY 
d170 17
a186 14
C NOW XE IS READY, SYMMETRIZE IF NECESSARY
C  Additional symmetrization of the volume XE in real space 05/03/02
	IF(MAXSYM.GT.1)  THEN
        ALLOCATE (TEMP(NSAM*NSAM*NSAM), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, TEMP',IER)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
        ENDIF
	CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
c$omp parallel do private(i,j,k)
        DO    K=1,N2
           DO    J=1,N2
              DO    I=0,N2/2
                 XE(I,J,K)=CMPLX(0.0,0.0)
a188 1
        ENDDO
d196 1
a196 1
	CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
d200 3
a202 8
        CALL OPFIL(.FALSE.,FINPAT,IOPIC,'N',NSAM,NSAM,NSAM,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF

a204 1

d208 3
a210 9
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'O',LSD,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF


a212 3
	


d216 1
a216 1
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'O',LSDD2,N2,N2,
d218 2
a219 6
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
 
d222 1
a223 1
        CLOSE(IOPIC)
d229 11
a239 9
C TOTAL VOLUME IS READY
C  Additional symmetrization of the volume TOTAL in real space 05/03/02
	IF(MAXSYM.GT.1)  THEN
	CALL COP(XE,TEMP,NSAM*NSAM*NSAM)
c$omp parallel do private(i,j,k)
        DO    K=1,N2
           DO    J=1,N2
              DO    I=0,N2/2
                 XE(I,J,K)=CMPLX(0.0,0.0)
d242 1
a242 2
        ENDDO
	CALL SYMVOL(TEMP,XE,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
d245 1
a245 1
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'N',NSAM,NSAM,NSAM,
d247 1
a247 5
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
a249 1

d254 12
a265 9
C XO VOLUME IS READY
C  Additional symmetrization of the volume XO in real space 05/03/02
	IF(MAXSYM.GT.1)  THEN
	CALL COP(XO,TEMP,NSAM*NSAM*NSAM)
c$omp parallel do private(i,j,k)
        DO    K=1,N2
           DO    J=1,N2
              DO    I=0,N2/2
                 XO(I,J,K)=CMPLX(0.0,0.0)
d268 1
a268 3
        ENDDO
	CALL SYMVOL(TEMP,XO,KLX,KNX,KLX,KNX,KLX,KNX,SM,MAXSYM)
	DEALLOCATE(TEMP)
d271 3
a273 8
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'N',NSAM,NSAM,NSAM,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF

d279 11
a289 1
        DEALLOCATE (DM, SM, XE, WE, XO, WO)
d295 1
a295 1
     &                      INUMBR,DM,NANG,SM,MAXSYM)
d297 3
a299 3

        LOGICAL, DIMENSION(:), ALLOCATABLE :: RANDLIST
        REAL, DIMENSION(:,:), ALLOCATABLE :: PROJ
d301 1
d306 1
d309 1
d312 1
d315 2
a316 1
C In this version the order of the Bessel function is mmm=1
d322 2
a323 1
C K=6
d326 2
a327 2
C Generalized Kaiser-Bessel window according to Lewitt
C M=NS, N=N
d341 3
a343 2
C  Cannot be parallel as there are DATA satements in BESSI
cc$omp parallel do private(i,s,x),shared(mmm)
d345 7
a351 11
	 S=REAL(I)/FLTB/N
	 IF(S.LE.AAAA)  THEN
	  X=SQRT(1.0-(S/AAAA)**2)
	  TABI(I)=
C(SQRT(ALPHA*X)**mmm)*BESSI(mmm,ALPHA*X)/B0
CTEMPO=
     &		SQRT(ALPHA*X)*BESI1(ALPHA*X)/B0
C	if(abs(tabi(i)-tempo).gt.1.0e-5)  print  *,'bessi',i
	 ELSE
	  TABI(I)=0.0
	 ENDIF
d354 1
a354 1
c$omp parallel do private(i,j,k)
d366 1
a366 1
        ALLOCATE (PROJ(NS,NS), STAT=IRTFLG)
d368 1
a368 1
           CALL ERRT(46,'BP 32F, PROJ',IER)
d372 2
a373 8

        ALLOCATE (BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, BI',IER)
           DEALLOCATE (PROJ)
	   RETURN
        ENDIF

a374 10
        ALLOCATE (RANDLIST(NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, RANDLIST',IER)
           DEALLOCATE (PROJ,BI)
	   RETURN
        ENDIF

	RANDLIST(1:NANG/2)=.TRUE.
	RANDLIST(NANG/2+1:NANG)=.FALSE.

d376 5
a380 5
         CALL  RANDOM_NUMBER(HARVEST=X)
         IORD = MIN0(NANG,MAX0(1,INT(X*NANG+0.5)))
	 ITMP=RANDLIST(IORD)
	 RANDLIST(IORD)=RANDLIST(K)
	 RANDLIST(K)=ITMP
d384 2
a385 2
#ifdef SP_MP
	LN1=LN+1
d387 1
a387 1
        DO    K=1,NANG
d392 1
a392 1
           IF (IRTFLG .NE. 0) RETURN
d395 3
a397 3
           CALL OPFIL(.FALSE.,FINPIC,INPROJ,'O',NSAM,NROW,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d400 8
d413 4
a416 4
c$omp parallel do private(i,j)
           DO  J=1,N
              DO  I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
d421 3
a423 3
              IF(MAXSYM.GT.1)  THEN
C  symmetries, multiply matrices
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
d428 2
a429 2
           IF (RANDLIST(K))  THEN
	    DO  JT=1,LN1
d432 12
a443 12
            DO J=-N2+JT,N2,LN1
              CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
             ENDDO
            ENDDO
           ELSE
	    DO  JT=1,LN1
c$omp parallel do private(j),shared(N,N2,JT,XO,WO,BI,DMS)
             DO J=-N2+JT,N2,LN1
              CALL  ONELINE(J,N,N2,XO,WO,BI,DMS)
             ENDDO
            ENDDO
          ENDIF
d445 3
a447 3
              IF (RANDLIST(K))  THEN
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
d450 2
a451 2
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XO,WO,BI,DMS)
d455 1
a455 1
C   END OF SYMMETRIES LOOP
d462 2
a463 2
c$omp parallel sections
c$omp section
d465 1
a465 1
c$omp section
d467 5
a471 1
c$omp end parallel sections
a472 1
        DEALLOCATE (PROJ, BI, RANDLIST)
d474 1
d485 6
a490 6
c        TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
        IP=(N-L)/2+MOD(L,2)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 R(I,J,K)=BI(IP+I,IP+J,IP+K)
d495 6
a500 6
C
        L2=(L/2)**2
        L2P=(L/2-1)**2
        IP=L/2+1
	XNU=REAL(NNN)/2.
C+REAL(mmm)
d503 2
a504 2
	RI=RIBSL(ALPHA,XNU)
C	if(abs(ri-rin).gt.1.e-5)  print  *,'bessik'
d506 9
a514 9
	WKB0=ALPHA**XNU/RI
	QRT=(TWOPI*AAAA)**2
        TNR=0.0
        M=0
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF(LR.LE.L2) THEN
d516 2
a517 2
	          IF(ABS(SIGMA).LT.1.0E-7)  THEN
	           WKB=1.0
d519 4
a522 4
C   2PI A R > ALPHA
		   ART=SQRT(SIGMA)
C		   CALL  BESSJY(ART,XNU,RI,RK,RIP,RIK)
      		   RI=RJBSL(ART, XNU)
d524 1
a524 1
	           WKB=WKB0*RI/ART**XNU
d526 4
a529 4
C   2PI A R < ALPHA
		   ART=SQRT(ABS(SIGMA))
C		   CALL  BESSIK(ART,XNU,RI,RK,RIP,RIK)
		   RI=RIBSL(ART,XNU)
d531 1
a531 1
	           WKB=WKB0*RI/ART**XNU
d534 3
a536 3
                  IF(LR.GE.L2P .AND. LR.LE.L2) THEN
                   TNR=TNR+R(I,J,K)
                   M=M+1
d542 5
a546 5
        TNR=TNR/REAL(M)
c$omp parallel do private(i,j,k,lr)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
d548 1
a548 1
                 IF(LR.LE.L2) THEN
a558 335
C
#else
C++************************************************************************
C
C  WIW32D.F                                           01/10/00
C                        ANGLES IN HEADER JULY 01 ArDean Leith
C                        OPFILE 'U'       FEB  02 ArDean Leith
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C   WIW32D
C
C IMAGE_PROCESSING_ROUTINE
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE WIW32D

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        INCLUDE 'F90ALLOC.INC'

C       DOC FILE POINTERS
        REAL, DIMENSION(:,:), POINTER ::          ANGBUF, ANGSYM
        REAL, DIMENSION(:,:), ALLOCATABLE ::      DM,SM 
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XE,XO
        REAL, ALLOCATABLE, DIMENSION(:,:,:) ::    WE,WO
        LOGICAL ::                                ANGINDOC
        CHARACTER(LEN=1) ::                       NULL

        CHARACTER*80    FINPIC,FINFO,ANGDOC,FINPAT
        COMMON /F_SPEC/ FINPAT,NLET,FINPIC

        DATA  IOPIC/98/,INPIC/99/

        NULL   = CHAR(0)
        NILMAX = NIMAX

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,INUMBR,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        MAXNUM = MAXVAL(INUMBR(1:NANG))
        CLOSE(INPIC)

C       NANG - TOTAL NUMBER OF IMAGES
        WRITE(NOUT,2001) NANG
2001    FORMAT(' NUMBER OF IMAGES =',I5)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        ANGINDOC = .TRUE.
        MAXXT    = 4
        MAXYT    = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) ANGINDOC = .FALSE.

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 0
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF (IRTFLG .NE. 0)  MAXSYM = 1

C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        MAXIM = 0
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CLOSE(INPIC)

        N2   = 2*NSAM
        LSD  = N2+2-MOD(N2,2)
        NMAT = LSD*N2*N2

        IF (ANGINDOC) THEN
        
           ALLOCATE(DM(9,NANG), STAT=IRTFLG)
           IF (IRTFLG.NE.0) GOTO 999

           CALL BUILDM(INUMBR,DM,NANG,ANGBUF(1,1),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
        
           IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        ELSE
           ALLOCATE(DM(9,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) GOTO 999
        ENDIF

        IF (MAXSYM.GT.1)  THEN
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, SM(9,MAXSYM)',IER)
              GOTO 999
           ENDIF
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)

        ELSE
           ALLOCATE(SM(1,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
               CALL ERRT(46,'BP 3F, SM(1,1)',IER)
               GOTO 999
           ENDIF
        ENDIF

        ALLOCATE(XE(0:N2/2,N2,N2),WE(0:N2/2,N2,N2),WO(0:N2/2,N2,N2),
     &            XO(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F; XE, WE, WO & XO',IER)
           GOTO 999
        ENDIF

        CALL  WIW32DQ(NSAM,XE,WE,XO,WO,
     &      LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM,SIR,ANGINDOC,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',IRTFLG) 
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3-D',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
 
        CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3-D',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'U',IFORM,LSD,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        CLOSE(IOPIC)

C       CBE AND CBO (XE & XO) ARE LSD x N2 x N2
C       CWE AND CWO (WE & WO) ARE (LSD/2) x N2 x N2
        LSDD2 = LSD/2
        IFORM = 3
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'U',IFORM,LSDD2,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)
        CLOSE(IOPIC)

        CALL NRMW2(XE,WE,N2/2,N2)
        CALL WIND2(XE,XE,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPAT,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'O',IFORM,LSD,N2,N2,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
        
        CALL READV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        CLOSE(IOPIC)

        CALL OPFILE(.FALSE.,FINFO,IOPIC,'O',IFORM,LSDD2,N2,N2,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
 
        CALL READV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)
        CLOSE(IOPIC)

C       ADD E+O
        CALL ADDADA(XE,XO,NMAT)
        CALL ADDADA(WE,WO,NMAT/2)
        CALL NRMW2(XE,WE,N2/2,N2)
        CALL WIND2(XE,XE,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

        CALL NRMW2(XO,WO,N2/2,N2)
        CALL WIND2(XO,XO,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL WRITEV(IOPIC,XO,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

 999    CONTINUE
        IF (ALLOCATED(DM))     DEALLOCATE(DM)
        IF (ALLOCATED(SM))     DEALLOCATE(SM)
        IF (ALLOCATED(XE))     DEALLOCATE(XE)
        IF (ALLOCATED(WE))     DEALLOCATE(WE)
        IF (ALLOCATED(XO))     DEALLOCATE(XO)
        IF (ALLOCATED(WO))     DEALLOCATE(WO)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)
        END

C       ---------------- WIW32DQ -------------------------------------

        SUBROUTINE  WIW32DQ(NS,XE,WE,XO,WO, LSD,N,N2,INUMBR,DM,
     &                      NANG,SM,MAXSYM,SIR,ANGINDOC,IRTFLG)

        INCLUDE 'CMLIMIT.INC'

        LOGICAL ::                              ANGINDOC
        REAL, DIMENSION(:,:), ALLOCATABLE ::    PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(4) ::                   ANGBUF
        DOUBLE PRECISION ::                     PI
        DIMENSION        WE(0:N2,N,N),WO(0:N2,N,N)
        COMPLEX          XE(0:N2,N,N),XO(0:N2,N,N)
        DIMENSION        INUMBR(NANG)
        DIMENSION        DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)

        CHARACTER*80     FINPIC,FINPAT
        COMMON  /F_SPEC/ FINPAT,NLET,FINPIC

        PARAMETER (LTAB=4999)
        COMMON  /TABS/  LN2,FLTB,TABI(0:LTAB)

        DATA  INPROJ/99/

        LN   = 5
        LN2  = LN/2
        PI   = 4.0D0*DATAN(1.0D0)
        SIG  = 3.0/PI
        SIG2 = SIG*SIG
C       SIGMA IN REAL SPACE
        SIR  = REAL(N)/(2.0*PI*SIG)

        TNR  = DSQRT(2.0D0*PI)*SIG
C       GENERATE TABLE WITH INTERPOLANTS
        FLTB = REAL(LTAB)/REAL(LN2+1)

c$omp   parallel do private(i)
        DO  I=0,LTAB
           TABI(I) = EXP(-0.5*((REAL(I)/FLTB)**2)/SIG2)/TNR
        ENDDO

c$omp   parallel do private(i,j,k)
        DO K=1,N2
           DO J=1,N2
              DO I=0,N2
                 XE(I,J,K)=CMPLX(0.0,0.0)
                 WE(I,J,K)=0.0
                 XO(I,J,K)=CMPLX(0.0,0.0)
                 WO(I,J,K)=0.0
              ENDDO
           ENDDO
        ENDDO

        ALLOCATE (PROJ(NS,NS),BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, PROJ & BI',IER)
           RETURN
        ENDIF

        DO K=1,NANG
C          print  *,' Projection #',K

C          OPEN DESIRED FILE
           CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(K),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

           MAXIM = 0
           CALL OPFILE(.FALSE.,FINPIC,INPROJ,'O',IFORM,NSAM,NROW,NSL,
     &                   MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

           DO  J=1,NS
              CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
           ENDDO
           IF (.NOT. ANGINDOC) THEN
C             GET ANGLES FROM HEADER
              ANGBUF(1) = INUMBR(K)
              CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
              CALL BUILDM(INUMBR,DM,1,ANGBUF,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 999
           ENDIF
           CLOSE(INPROJ)

           CALL PADD2(PROJ,NS,BI,LSD,N)
           INV=+1
           CALL FMRS_2(BI,N,N,INV)
c$omp      parallel do private(i,j)
           DO J=1,N
              DO I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO ISYM=1,MAXSYM
              IF (MAXSYM.GT.1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
              ELSE
                 DMS=DM(:,:,K)
              ENDIF
              IF (MOD(K,2).EQ.0)  THEN
c$omp            parallel do private(j),shared(N,N2,XE,WE,BI,DMS)
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
                 ENDDO
              ELSE
c$omp            parallel do private(j),shared(N,N2,XO,WO,BI,DMS)
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XO,WO,BI,DMS)
                 ENDDO
              ENDIF
C          END OF SYMMETRIES LOOP
           ENDDO

C       END OF PROJECTIONS LOOP
        ENDDO
a559 15
C       SYMMETRIZE BOTH VOLUMES
c$omp   parallel sections
c$omp   section
        CALL  SYMPLANE0(XE,WE,N2,N)
c$omp   section
        CALL  SYMPLANE0(XO,WO,N2,N)
c$omp   end parallel sections
        IRTFLG = 0

999     IF (ALLOCATED(PROJ)) DEALLOCATE (PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE (BI)

        END
#endif

d600 1
d602 2
a603 1
c$omp parallel do private(k)
d605 1
a605 1
           X(K)=X(K)+Y(K)
@


1.31
log
@changed ||
@
text
@d214 2
a215 2
        DO    K=1,N
           DO    J=1,N
d285 2
a286 2
        DO    K=1,N
           DO    J=1,N
d314 2
a315 2
        DO    K=1,N
           DO    J=1,N
d401 2
a402 2
        DO  K=1,N
           DO  J=1,N
d870 2
a871 2
        DO K=1,N
           DO J=1,N
a1005 1490
c................ REPLACEMENT BESSEL FUNCTION
c...............................................................................
      SUBROUTINE CALCI1(ARG,RESULT,JINT)
C--------------------------------------------------------------------
C
C This packet computes modified Bessel functions of the first kind
C   and order one, I1(X) and EXP(-ABS(X))*I1(X), for real
C   arguments X.  It contains two function type subprograms, BESI1
C   and BESEI1, and one subroutine type subprogram, CALCI1.
C   The calling statements for the primary entries are
C
C                   Y=BESI1(X)
C   and
C                   Y=BESEI1(X)
C
C   where the entry points correspond to the functions I1(X) and
C   EXP(-ABS(X))*I1(X), respectively.  The routine CALCI1 is
C   intended for internal packet use only, all computations within
C   the packet being concentrated in this routine.  The function
C   subprograms invoke CALCI1 with the statement
C          CALL CALCI1(ARG,RESULT,JINT)
C   where the parameter usage is as follows
C
C      Function                     Parameters for CALCI1
C       Call              ARG                  RESULT          JINT
C
C     BESI1(ARG)    ABS(ARG) .LE. XMAX        I1(ARG)           1
C     BESEI1(ARG)    any real ARG        EXP(-ABS(ARG))*I1(ARG) 2
C
C   The main computation evaluates slightly modified forms of
C   minimax approximations generated by Blair and Edwards, Chalk
C   River (Atomic Energy of Canada Limited) Report AECL-4928,
C   October, 1974.  This transportable program is patterned after
C   the machine-dependent FUNPACK packet NATSI1, but cannot match
C   that version for efficiency or accuracy.  This version uses
C   rational functions that theoretically approximate I-SUB-1(X)
C   to at least 18 significant decimal digits.  The accuracy
C   achieved depends on the arithmetic system, the compiler, the
C   intrinsic functions, and proper selection of the machine-
C   dependent constants.
C
C*******************************************************************
C*******************************************************************
C
C Explanation of machine-dependent constants
C
C   beta   = Radix for the floating-point system
C   maxexp = Smallest power of beta that overflows
C   XSMALL = Positive argument such that 1.0 - X = 1.0 to
C            machine precision for all ABS(X) .LE. XSMALL.
C   XINF =   Largest positive machine number; approximately
C            beta**maxexp
C   XMAX =   Largest argument acceptable to BESI1;  Solution to
C            equation: 
C               EXP(X) * (1-3/(8*X)) / SQRT(2*PI*X) = beta**maxexp
C
C
C     Approximate values for some important machines are:
C
C                          beta       maxexp       XSMALL
C
C CRAY-1        (S.P.)       2         8191       3.55E-15
C Cyber 180/855
C   under NOS   (S.P.)       2         1070       3.55E-15
C IEEE (IBM/XT,
C   SUN, etc.)  (S.P.)       2          128       2.98E-8
C IEEE (IBM/XT,
C   SUN, etc.)  (D.P.)       2         1024       5.55D-17
C IBM 3033      (D.P.)      16           63       6.95D-18
C VAX           (S.P.)       2          127       2.98E-8
C VAX D-Format  (D.P.)       2          127       6.95D-18
C VAX G-Format  (D.P.)       2         1023       5.55D-17
C
C
C                               XINF          XMAX
C
C CRAY-1        (S.P.)       5.45E+2465     5682.810
C Cyber 180/855
C   under NOS   (S.P.)       1.26E+322       745.894
C IEEE (IBM/XT,
C   SUN, etc.)  (S.P.)       3.40E+38         91.906
C IEEE (IBM/XT,
C   SUN, etc.)  (D.P.)       1.79D+308       713.987
C IBM 3033      (D.P.)       7.23D+75        178.185
C VAX           (S.P.)       1.70D+38         91.209
C VAX D-Format  (D.P.)       1.70D+38         91.209
C VAX G-Format  (D.P.)       8.98D+307       713.293
C
C*******************************************************************
C*******************************************************************
C
C Error returns
C
C  The program returns the value XINF for ABS(ARG) .GT. XMAX.
C
C
C Intrinsic functions required are:
C
C     ABS, SQRT, EXP
C
C
C  Authors: W. J. Cody and L. Stoltz
C           Mathematics and Computer Science Division
C           Argonne National Laboratory
C           Argonne, IL  60439
C
C  Latest modification: May 31, 1989
C
C--------------------------------------------------------------------
      INTEGER J,JINT
      REAL
CD    DOUBLE PRECISION
     1    A,ARG,B,EXP40,FORTY,HALF,ONE,ONE5,P,PBAR,PP,Q,QQ,REC15,
     2    RESULT,SUMP,SUMQ,TWO25,X,XINF,XMAX,XSMALL,XX,ZERO
      DIMENSION P(15),PP(8),Q(5),QQ(6)
C--------------------------------------------------------------------
C  Mathematical constants
C--------------------------------------------------------------------
      DATA ONE/1.0E0/,ONE5/15.0E0/,EXP40/2.353852668370199854E17/,
     1     FORTY/40.0E0/,REC15/6.6666666666666666666E-2/,
     2     TWO25/225.0E0/,HALF/0.5E0/,ZERO/0.0E0/
CD    DATA ONE/1.0D0/,ONE5/15.0D0/,EXP40/2.353852668370199854D17/,
CD   1     FORTY/40.0D0/,REC15/6.6666666666666666666D-2/,
CD   2     TWO25/225.0D0/,HALF/0.5D0/,ZERO/0.0D0/
C--------------------------------------------------------------------
C  Machine-dependent constants
C--------------------------------------------------------------------
      DATA XSMALL/2.98E-8/,XINF/3.4E38/,XMAX/91.906E0/
CD    DATA XSMALL/5.55D-17/,XINF/1.79D308/,XMAX/713.987D0/
C--------------------------------------------------------------------
C  Coefficients for XSMALL .LE. ABS(ARG) .LT. 15.0
C--------------------------------------------------------------------
      DATA P/-1.9705291802535139930E-19,-6.5245515583151902910E-16,
     1       -1.1928788903603238754E-12,-1.4831904935994647675E-09,
     2       -1.3466829827635152875E-06,-9.1746443287817501309E-04,
     3       -4.7207090827310162436E-01,-1.8225946631657315931E+02,
     4       -5.1894091982308017540E+04,-1.0588550724769347106E+07,
     5       -1.4828267606612366099E+09,-1.3357437682275493024E+11,
     6       -6.9876779648010090070E+12,-1.7732037840791591320E+14,
     7       -1.4577180278143463643E+15/
CD    DATA P/-1.9705291802535139930D-19,-6.5245515583151902910D-16,
CD   1       -1.1928788903603238754D-12,-1.4831904935994647675D-09,
CD   2       -1.3466829827635152875D-06,-9.1746443287817501309D-04,
CD   3       -4.7207090827310162436D-01,-1.8225946631657315931D+02,
CD   4       -5.1894091982308017540D+04,-1.0588550724769347106D+07,
CD   5       -1.4828267606612366099D+09,-1.3357437682275493024D+11,
CD   6       -6.9876779648010090070D+12,-1.7732037840791591320D+14,
CD   7       -1.4577180278143463643D+15/
      DATA Q/-4.0076864679904189921E+03, 7.4810580356655069138E+06,
     1       -8.0059518998619764991E+09, 4.8544714258273622913E+12,
     2       -1.3218168307321442305E+15/
CD    DATA Q/-4.0076864679904189921D+03, 7.4810580356655069138D+06,
CD   1       -8.0059518998619764991D+09, 4.8544714258273622913D+12,
CD   2       -1.3218168307321442305D+15/
C--------------------------------------------------------------------
C  Coefficients for 15.0 .LE. ABS(ARG)
C--------------------------------------------------------------------
      DATA PP/-6.0437159056137600000E-02, 4.5748122901933459000E-01,
     1        -4.2843766903304806403E-01, 9.7356000150886612134E-02,
     2        -3.2457723974465568321E-03,-3.6395264712121795296E-04,
     3         1.6258661867440836395E-05,-3.6347578404608223492E-07/
CD    DATA PP/-6.0437159056137600000D-02, 4.5748122901933459000D-01,
CD   1        -4.2843766903304806403D-01, 9.7356000150886612134D-02,
CD   2        -3.2457723974465568321D-03,-3.6395264712121795296D-04,
CD   3         1.6258661867440836395D-05,-3.6347578404608223492D-07/
      DATA QQ/-3.8806586721556593450E+00, 3.2593714889036996297E+00,
     1        -8.5017476463217924408E-01, 7.4212010813186530069E-02,
     2        -2.2835624489492512649E-03, 3.7510433111922824643E-05/
CD    DATA QQ/-3.8806586721556593450D+00, 3.2593714889036996297D+00,
CD   1        -8.5017476463217924408D-01, 7.4212010813186530069D-02,
CD   2        -2.2835624489492512649D-03, 3.7510433111922824643D-05/
      DATA PBAR/3.98437500E-01/
CD    DATA PBAR/3.98437500D-01/
C--------------------------------------------------------------------
      X = ABS(ARG)
      IF (X .LT. XSMALL) THEN
C--------------------------------------------------------------------
C  Return for ABS(ARG) .LT. XSMALL
C--------------------------------------------------------------------
            RESULT = HALF * X
         ELSE IF (X .LT. ONE5) THEN
C--------------------------------------------------------------------
C  XSMALL .LE. ABS(ARG) .LT. 15.0
C--------------------------------------------------------------------
            XX = X * X
            SUMP = P(1)
            DO 50 J = 2, 15
               SUMP = SUMP * XX + P(J)
   50          CONTINUE
            XX = XX - TWO25
            SUMQ = ((((XX+Q(1))*XX+Q(2))*XX+Q(3))*XX+Q(4))
     1           *XX+Q(5)
            RESULT = (SUMP / SUMQ) * X
            IF (JINT .EQ. 2) RESULT = RESULT * EXP(-X)
         ELSE IF ((JINT .EQ. 1) .AND. (X .GT. XMAX)) THEN
                  RESULT = XINF
         ELSE
C--------------------------------------------------------------------
C  15.0 .LE. ABS(ARG)
C--------------------------------------------------------------------
            XX = ONE / X - REC15
            SUMP = ((((((PP(1)*XX+PP(2))*XX+PP(3))*XX+
     1           PP(4))*XX+PP(5))*XX+PP(6))*XX+PP(7))*XX+PP(8)
            SUMQ = (((((XX+QQ(1))*XX+QQ(2))*XX+QQ(3))*XX+
     1           QQ(4))*XX+QQ(5))*XX+QQ(6)
            RESULT = SUMP / SUMQ
            IF (JINT .NE. 1) THEN
                  RESULT = (RESULT + PBAR) / SQRT(X)
               ELSE
C--------------------------------------------------------------------
C  Calculation reformulated to avoid premature overflow
C--------------------------------------------------------------------
                  IF (X .GT. XMAX-ONE5) THEN
                        A = EXP(X-FORTY)
                        B = EXP40
                     ELSE
                        A = EXP(X)
                        B = ONE
                  END IF
                  RESULT = ((RESULT * A + PBAR * A) /
     1                  SQRT(X)) * B
C--------------------------------------------------------------------
C  Error return for ABS(ARG) .GT. XMAX
C--------------------------------------------------------------------
            END IF
      END IF
      IF (ARG .LT. ZERO) RESULT = -RESULT
      RETURN
C----------- Last line of CALCI1 -----------
      END
      REAL
CD    DOUBLE PRECISION
     1    FUNCTION BESI1(X)
C--------------------------------------------------------------------
C
C This long precision subprogram computes approximate values for
C   modified Bessel functions of the first kind of order one for
C   arguments ABS(ARG) .LE. XMAX  (see comments heading CALCI1).
C
C--------------------------------------------------------------------
      INTEGER JINT
      REAL
CD    DOUBLE PRECISION
     1    X, RESULT
C--------------------------------------------------------------------
      JINT=1
      CALL CALCI1(X,RESULT,JINT)
      BESI1=RESULT
      RETURN
C---------- Last line of BESI1 ----------
      END
      REAL
CD    DOUBLE PRECISION
     1    FUNCTION BESEI1(X)
C--------------------------------------------------------------------
C
C This function program computes approximate values for the
C   modified Bessel function of the first kind of order one
C   multiplied by EXP(-ABS(X)), where EXP is the
C   exponential function, ABS is the absolute value, and X
C   is any argument.
C
C--------------------------------------------------------------------
      INTEGER JINT
      REAL
CD    DOUBLE PRECISION
     1    X, RESULT
C--------------------------------------------------------------------
      JINT=2
      CALL CALCI1(X,RESULT,JINT)
      BESEI1=RESULT
      RETURN
C---------- Last line of BESEI1 ----------
      END
c////////////////////////////////////////////////////////////////////////////
      FUNCTION  RJBSL(X,ALPHA)
      NB=INT(ALPHA)
      ALPHAT=ALPHA-REAL(NB)
      NB=NB+1
	CALL  RJBESL(X,ALPHAT,NB,OUT,NCALC)
      RJBSL=OUT
      END
	

      SUBROUTINE RJBESL(X, ALPHA, NB, OUT, NCALC)
C---------------------------------------------------------------------
C This routine calculates Bessel functions J sub(N+ALPHA) (X)
C   for non-negative argument X, and non-negative order N+ALPHA.
C
C
C  Explanation of variables in the calling sequence.
C
C   X     - working precision non-negative real argument for which
C           J's are to be calculated.
C   ALPHA - working precision fractional part of order for which
C           J's or exponentially scaled J'r (J*exp(X)) are
C           to be calculated.  0 <= ALPHA < 1.0.
C   NB  - integer number of functions to be calculated, NB > 0.
C           The first function calculated is of order ALPHA, and the
C           last is of order (NB - 1 + ALPHA).
C   B  - working precision output vector of length NB.  If RJBESL
C           terminates normally (NCALC=NB), the vector B contains the
C           functions J/ALPHA/(X) through J/NB-1+ALPHA/(X), or the
C           corresponding exponentially scaled functions.
C   NCALC - integer output variable indicating possible errors.
C           Before using the vector B, the user should check that
C           NCALC=NB, i.e., all orders have been calculated to
C           the desired accuracy.  See Error Returns below.
C
C
C*******************************************************************
C*******************************************************************
C
C  Explanation of machine-dependent constants
C
C   it     = Number of bits in the mantissa of a working precision
C            variable
C   NSIG   = Decimal significance desired.  Should be set to
C            INT(LOG10(2)*it+1).  Setting NSIG lower will result
C            in decreased accuracy while setting NSIG higher will
C            increase CPU time without increasing accuracy.  The
C            truncation error is limited to a relative error of
C            T=.5*10**(-NSIG).
C   ENTEN  = 10.0 ** K, where K is the largest integer such that
C            ENTEN is machine-representable in working precision
C   ENSIG  = 10.0 ** NSIG
C   RTNSIG = 10.0 ** (-K) for the smallest integer K such that
C            K .GE. NSIG/4
C   ENMTEN = Smallest ABS(X) such that X/4 does not underflow
C   XLARGE = Upper limit on the magnitude of X.  If ABS(X)=N,
C            then at least N iterations of the backward recursion
C            will be executed.  The value of 10.0 ** 4 is used on
C            every machine.
C
C
C     Approximate values for some important machines are:
C
C
C                            it    NSIG    ENTEN       ENSIG
C
C   CRAY-1        (S.P.)     48     15    1.0E+2465   1.0E+15
C   Cyber 180/855
C     under NOS   (S.P.)     48     15    1.0E+322    1.0E+15
C   IEEE (IBM/XT,
C     SUN, etc.)  (S.P.)     24      8    1.0E+38     1.0E+8
C   IEEE (IBM/XT,
C     SUN, etc.)  (D.P.)     53     16    1.0D+308    1.0D+16
C   IBM 3033      (D.P.)     14      5    1.0D+75     1.0D+5
C   VAX           (S.P.)     24      8    1.0E+38     1.0E+8
C   VAX D-Format  (D.P.)     56     17    1.0D+38     1.0D+17
C   VAX G-Format  (D.P.)     53     16    1.0D+307    1.0D+16
C
C
C                           RTNSIG      ENMTEN      XLARGE
C
C   CRAY-1        (S.P.)    1.0E-4    1.84E-2466   1.0E+4
C   Cyber 180/855
C     under NOS   (S.P.)    1.0E-4    1.25E-293    1.0E+4
C   IEEE (IBM/XT,
C     SUN, etc.)  (S.P.)    1.0E-2    4.70E-38     1.0E+4
C   IEEE (IBM/XT,
C     SUN, etc.)  (D.P.)    1.0E-4    8.90D-308    1.0D+4
C   IBM 3033      (D.P.)    1.0E-2    2.16D-78     1.0D+4
C   VAX           (S.P.)    1.0E-2    1.17E-38     1.0E+4
C   VAX D-Format  (D.P.)    1.0E-5    1.17D-38     1.0D+4
C   VAX G-Format  (D.P.)    1.0E-4    2.22D-308    1.0D+4
C
C*******************************************************************
C*******************************************************************
C
C  Error returns
C
C    In case of an error,  NCALC .NE. NB, and not all J's are
C    calculated to the desired accuracy.
C
C    NCALC .LT. 0:  An argument is out of range. For example,
C       NBES .LE. 0, ALPHA .LT. 0 or .GT. 1, or X is too large.
C       In this case, B(1) is set to zero, the remainder of the
C       B-vector is not calculated, and NCALC is set to
C       MIN(NB,0)-1 so that NCALC .NE. NB.
C
C    NB .GT. NCALC .GT. 0: Not all requested function values could
C       be calculated accurately.  This usually occurs because NB is
C       much larger than ABS(X).  In this case, B(N) is calculated
C       to the desired accuracy for N .LE. NCALC, but precision
C       is lost for NCALC .LT. N .LE. NB.  If B(N) does not vanish
C       for N .GT. NCALC (because it is too small to be represented),
C       and B(N)/B(NCALC) = 10**(-K), then only the first NSIG-K
C       significant figures of B(N) can be trusted.
C
C
C  Intrinsic and other functions required are:
C
C     ABS, AINT, COS, DBLE, GAMMA (or DGAMMA), INT, MAX, MIN,
C
C     REAL, SIN, SQRT
C
C
C  Acknowledgement
C
C   This program is based on a program written by David J. Sookne
C   (2) that computes values of the Bessel functions J or I of real
C   argument and integer order.  Modifications include the restriction
C   of the computation to the J Bessel function of non-negative real
C   argument, the extension of the computation to arbitrary positive
C   order, and the elimination of most underflow.
C
C  References: "A Note on Backward Recurrence Algorithms," Olver,
C               F. W. J., and Sookne, D. J., Math. Comp. 26, 1972,
C               pp 941-947.
C
C              "Bessel Functions of Real Argument and Integer Order,"
C               Sookne, D. J., NBS Jour. of Res. B. 77B, 1973, pp
C               125-132.
C
C  Latest modification: March 19, 1990
C
C  Author: W. J. Cody
C          Applied Mathematics Division
C          Argonne National Laboratory
C          Argonne, IL  60439
C
C---------------------------------------------------------------------
      INTEGER I,J,K,L,M,MAGX,N,NB,NBMX,NCALC,NEND,NSTART
      REAL               GAMMA,
CD    DOUBLE PRECISION  DGAMMA,
     1 ALPHA,ALPEM,ALP2EM,B,CAPP,CAPQ,CONV,EIGHTH,EM,EN,ENMTEN,ENSIG,
     2 ENTEN,FACT,FOUR,FUNC,GNU,HALF,HALFX,ONE,ONE30,P,PI2,PLAST,
     3 POLD,PSAVE,PSAVEL,RTNSIG,S,SUM,T,T1,TEMPA,TEMPB,TEMPC,TEST,
     4 THREE,THREE5,TOVER,TWO,TWOFIV,TWOPI1,TWOPI2,X,XC,XIN,XK,XLARGE,
     5 XM,VCOS,VSIN,Z,ZERO
      DIMENSION B(NB), FACT(25)
C---------------------------------------------------------------------
C  Mathematical constants
C
C   PI2    - 2 / PI
C   TWOPI1 - first few significant digits of 2 * PI
C   TWOPI2 - (2*PI - TWOPI) to working precision, i.e.,
C            TWOPI1 + TWOPI2 = 2 * PI to extra precision.
C---------------------------------------------------------------------
      DATA PI2, TWOPI1, TWOPI2 /0.636619772367581343075535E0,6.28125E0,
     1 1.935307179586476925286767E-3/
      DATA ZERO, EIGHTH, HALF, ONE /0.0E0,0.125E0,0.5E0,1.0E0/
      DATA TWO, THREE, FOUR, TWOFIV /2.0E0,3.0E0,4.0E0,25.0E0/
      DATA ONE30, THREE5 /130.0E0,35.0E0/
CD    DATA PI2, TWOPI1, TWOPI2 /0.636619772367581343075535D0,6.28125D0,
CD   1 1.935307179586476925286767D-3/
CD    DATA ZERO, EIGHTH, HALF, ONE /0.0D0,0.125D0,0.5D0,1.0D0/
CD    DATA TWO, THREE, FOUR, TWOFIV /2.0D0,3.0D0,4.0D0,25.0D0/
CD    DATA ONE30, THREE5 /130.0D0,35.0D0/
C---------------------------------------------------------------------
C  Machine-dependent parameters
C---------------------------------------------------------------------
      DATA ENTEN, ENSIG, RTNSIG /1.0E38,1.0E8,1.0E-2/
      DATA ENMTEN, XLARGE /1.2E-37,1.0E4/
CD    DATA ENTEN, ENSIG, RTNSIG /1.0D38,1.0D17,1.0D-4/
CD    DATA ENMTEN, XLARGE /1.2D-37,1.0D4/
C---------------------------------------------------------------------
C     Factorial(N)
C---------------------------------------------------------------------
      DATA FACT /1.0E0,1.0E0,2.0E0,6.0E0,24.0E0,1.2E2,7.2E2,5.04E3,
     1 4.032E4,3.6288E5,3.6288E6,3.99168E7,4.790016E8,6.2270208E9,
     2 8.71782912E10,1.307674368E12,2.0922789888E13,3.55687428096E14,
     3 6.402373705728E15,1.21645100408832E17,2.43290200817664E18,
     4 5.109094217170944E19,1.12400072777760768E21,
     5 2.585201673888497664E22,6.2044840173323943936E23/
CD    DATA FACT /1.0D0,1.0D0,2.0D0,6.0D0,24.0D0,1.2D2,7.2D2,5.04D3,
CD   1 4.032D4,3.6288D5,3.6288D6,3.99168D7,4.790016D8,6.2270208D9,
CD   2 8.71782912D10,1.307674368D12,2.0922789888D13,3.55687428096D14,
CD   3 6.402373705728D15,1.21645100408832D17,2.43290200817664D18,
CD   4 5.109094217170944D19,1.12400072777760768D21,
CD   5 2.585201673888497664D22,6.2044840173323943936D23/
C---------------------------------------------------------------------
C Statement functions for conversion and the gamma function.
C---------------------------------------------------------------------
      CONV(I) = REAL(I)
      FUNC(X) = GAMMA(X)
CD    CONV(I) = DBLE(I)
CD    FUNC(X) = DGAMMA(X)
C---------------------------------------------------------------------
C Check for out of range arguments.
C---------------------------------------------------------------------
      MAGX = INT(X)
      IF ((NB.GT.0) .AND. (X.GE.ZERO) .AND. (X.LE.XLARGE) 
     1       .AND. (ALPHA.GE.ZERO) .AND. (ALPHA.LT.ONE))  
     2   THEN
C---------------------------------------------------------------------
C Initialize result array to zero.
C---------------------------------------------------------------------
            NCALC = NB
            DO 20 I=1,NB
              B(I) = ZERO
   20       CONTINUE
C---------------------------------------------------------------------
C Branch to use 2-term ascending series for small X and asymptotic
C form for large X when NB is not too large.
C---------------------------------------------------------------------
            IF (X.LT.RTNSIG) THEN
C---------------------------------------------------------------------
C Two-term ascending series for small X.
C---------------------------------------------------------------------
               TEMPA = ONE
               ALPEM = ONE + ALPHA
               HALFX = ZERO
               IF (X.GT.ENMTEN) HALFX = HALF*X
               IF (ALPHA.NE.ZERO)
     1            TEMPA = HALFX**ALPHA/(ALPHA*FUNC(ALPHA))
               TEMPB = ZERO
               IF ((X+ONE).GT.ONE) TEMPB = -HALFX*HALFX
               B(1) = TEMPA + TEMPA*TEMPB/ALPEM
               IF ((X.NE.ZERO) .AND. (B(1).EQ.ZERO)) NCALC = 0
               IF (NB .NE. 1) THEN
                  IF (X .LE. ZERO) THEN
                        DO 30 N=2,NB
                          B(N) = ZERO
   30                   CONTINUE
                     ELSE
C---------------------------------------------------------------------
C Calculate higher order functions.
C---------------------------------------------------------------------
                        TEMPC = HALFX
                        TOVER = (ENMTEN+ENMTEN)/X
                        IF (TEMPB.NE.ZERO) TOVER = ENMTEN/TEMPB
                        DO 50 N=2,NB
                          TEMPA = TEMPA/ALPEM
                          ALPEM = ALPEM + ONE
                          TEMPA = TEMPA*TEMPC
                          IF (TEMPA.LE.TOVER*ALPEM) TEMPA = ZERO
                          B(N) = TEMPA + TEMPA*TEMPB/ALPEM
                          IF ((B(N).EQ.ZERO) .AND. (NCALC.GT.N))
     1                       NCALC = N-1
   50                   CONTINUE
                  END IF
               END IF
            ELSE IF ((X.GT.TWOFIV) .AND. (NB.LE.MAGX+1)) THEN
C---------------------------------------------------------------------
C Asymptotic series for X .GT. 21.0.
C---------------------------------------------------------------------
               XC = SQRT(PI2/X)
               XIN = (EIGHTH/X)**2
               M = 11
               IF (X.GE.THREE5) M = 8
               IF (X.GE.ONE30) M = 4
               XM = FOUR*CONV(M)
C---------------------------------------------------------------------
C Argument reduction for SIN and COS routines.
C---------------------------------------------------------------------
               T = AINT(X/(TWOPI1+TWOPI2)+HALF)
               Z = ((X-T*TWOPI1)-T*TWOPI2) - (ALPHA+HALF)/PI2
               VSIN = SIN(Z)
               VCOS = COS(Z)
               GNU = ALPHA + ALPHA
               DO 80 I=1,2
                 S = ((XM-ONE)-GNU)*((XM-ONE)+GNU)*XIN*HALF
                 T = (GNU-(XM-THREE))*(GNU+(XM-THREE))
                 CAPP = S*T/FACT(2*M+1)
                 T1 = (GNU-(XM+ONE))*(GNU+(XM+ONE))
                 CAPQ = S*T1/FACT(2*M+2)
                 XK = XM
                 K = M + M
                 T1 = T
                 DO 70 J=2,M
                   XK = XK - FOUR
                   S = ((XK-ONE)-GNU)*((XK-ONE)+GNU)
                   T = (GNU-(XK-THREE))*(GNU+(XK-THREE))
                   CAPP = (CAPP+ONE/FACT(K-1))*S*T*XIN
                   CAPQ = (CAPQ+ONE/FACT(K))*S*T1*XIN
                   K = K - 2
                   T1 = T
   70            CONTINUE
                 CAPP = CAPP + ONE
                 CAPQ = (CAPQ+ONE)*(GNU*GNU-ONE)*(EIGHTH/X)
                 B(I) = XC*(CAPP*VCOS-CAPQ*VSIN)
                 IF (NB.EQ.1) GO TO 300
                 T = VSIN
                 VSIN = -VCOS
                 VCOS = T
                 GNU = GNU + TWO
   80         CONTINUE
C---------------------------------------------------------------------
C If  NB .GT. 2, compute J(X,ORDER+I)  I = 2, NB-1
C---------------------------------------------------------------------
               IF (NB .GT. 2) THEN
                  GNU = ALPHA + ALPHA + TWO
                  DO 90 J=3,NB
                    B(J) = GNU*B(J-1)/X - B(J-2)
                    GNU = GNU + TWO
   90             CONTINUE
               END IF
C---------------------------------------------------------------------
C Use recurrence to generate results.  First initialize the
C calculation of P*S.
C---------------------------------------------------------------------
            ELSE
               NBMX = NB - MAGX
               N = MAGX + 1
               EN = CONV(N+N) + (ALPHA+ALPHA)
               PLAST = ONE
               P = EN/X
C---------------------------------------------------------------------
C Calculate general significance test.
C---------------------------------------------------------------------
               TEST = ENSIG + ENSIG
               IF (NBMX .GE. 3) THEN
C---------------------------------------------------------------------
C Calculate P*S until N = NB-1.  Check for possible overflow.
C---------------------------------------------------------------------
                  TOVER = ENTEN/ENSIG
                  NSTART = MAGX + 2
                  NEND = NB - 1
                  EN = CONV(NSTART+NSTART) - TWO + (ALPHA+ALPHA)
                  DO 130 K=NSTART,NEND
                     N = K
                     EN = EN + TWO
                     POLD = PLAST
                     PLAST = P
                     P = EN*PLAST/X - POLD
                     IF (P.GT.TOVER) THEN
C---------------------------------------------------------------------
C To avoid overflow, divide P*S by TOVER.  Calculate P*S until
C ABS(P) .GT. 1.
C---------------------------------------------------------------------
                        TOVER = ENTEN
                        P = P/TOVER
                        PLAST = PLAST/TOVER
                        PSAVE = P
                        PSAVEL = PLAST
                        NSTART = N + 1
  100                   N = N + 1
                           EN = EN + TWO
                           POLD = PLAST
                           PLAST = P
                           P = EN*PLAST/X - POLD
                        IF (P.LE.ONE) GO TO 100
                        TEMPB = EN/X
C---------------------------------------------------------------------
C Calculate backward test and find NCALC, the highest N such that
C the test is passed.
C---------------------------------------------------------------------
                        TEST = POLD*PLAST*(HALF-HALF/(TEMPB*TEMPB))
                        TEST = TEST/ENSIG
                        P = PLAST*TOVER
                        N = N - 1
                        EN = EN - TWO
                        NEND = MIN(NB,N)
                        DO 110 L=NSTART,NEND
                           POLD = PSAVEL
                           PSAVEL = PSAVE
                           PSAVE = EN*PSAVEL/X - POLD
                           IF (PSAVE*PSAVEL.GT.TEST) THEN
                              NCALC = L - 1
                              GO TO 190
                           END IF
  110                   CONTINUE
                        NCALC = NEND
                        GO TO 190
                     END IF
  130             CONTINUE
                  N = NEND
                  EN = CONV(N+N) + (ALPHA+ALPHA)
C---------------------------------------------------------------------
C Calculate special significance test for NBMX .GT. 2.
C---------------------------------------------------------------------
                  TEST = MAX(TEST,SQRT(PLAST*ENSIG)*SQRT(P+P))
               END IF
C---------------------------------------------------------------------
C Calculate P*S until significance test passes.
C---------------------------------------------------------------------
  140          N = N + 1
                  EN = EN + TWO
                  POLD = PLAST
                  PLAST = P
                  P = EN*PLAST/X - POLD
               IF (P.LT.TEST) GO TO 140
C---------------------------------------------------------------------
C Initialize the backward recursion and the normalization sum.
C---------------------------------------------------------------------
  190          N = N + 1
               EN = EN + TWO
               TEMPB = ZERO
               TEMPA = ONE/P
               M = 2*N - 4*(N/2)
               SUM = ZERO
               EM = CONV(N/2)
               ALPEM = (EM-ONE) + ALPHA
               ALP2EM = (EM+EM) + ALPHA
               IF (M .NE. 0) SUM = TEMPA*ALPEM*ALP2EM/EM
               NEND = N - NB
               IF (NEND .GT. 0) THEN
C---------------------------------------------------------------------
C Recur backward via difference equation, calculating (but not
C storing) B(N), until N = NB.
C---------------------------------------------------------------------
                  DO 200 L=1,NEND
                     N = N - 1
                     EN = EN - TWO
                     TEMPC = TEMPB
                     TEMPB = TEMPA
                     TEMPA = (EN*TEMPB)/X - TEMPC
                     M = 2 - M
                     IF (M .NE. 0) THEN
                        EM = EM - ONE
                        ALP2EM = (EM+EM) + ALPHA
                        IF (N.EQ.1) GO TO 210
                        ALPEM = (EM-ONE) + ALPHA
                        IF (ALPEM.EQ.ZERO) ALPEM = ONE
                        SUM = (SUM+TEMPA*ALP2EM)*ALPEM/EM
                     END IF
  200             CONTINUE
               END IF
C---------------------------------------------------------------------
C Store B(NB).
C---------------------------------------------------------------------
  210          B(N) = TEMPA
               IF (NEND .GE. 0) THEN
                  IF (NB .LE. 1) THEN
                        ALP2EM = ALPHA
                        IF ((ALPHA+ONE).EQ.ONE) ALP2EM = ONE
                        SUM = SUM + B(1)*ALP2EM
                        GO TO 250
                     ELSE
C---------------------------------------------------------------------
C Calculate and store B(NB-1).
C---------------------------------------------------------------------
                        N = N - 1
                        EN = EN - TWO
                        B(N) = (EN*TEMPA)/X - TEMPB
                        IF (N.EQ.1) GO TO 240
                        M = 2 - M
                        IF (M .NE. 0) THEN
                           EM = EM - ONE
                           ALP2EM = (EM+EM) + ALPHA
                           ALPEM = (EM-ONE) + ALPHA
                           IF (ALPEM.EQ.ZERO) ALPEM = ONE
                           SUM = (SUM+B(N)*ALP2EM)*ALPEM/EM
                        END IF
                  END IF
               END IF
               NEND = N - 2
               IF (NEND .NE. 0) THEN
C---------------------------------------------------------------------
C Calculate via difference equation and store B(N), until N = 2.
C---------------------------------------------------------------------
                  DO 230 L=1,NEND
                     N = N - 1
                     EN = EN - TWO
                     B(N) = (EN*B(N+1))/X - B(N+2)
                     M = 2 - M
                     IF (M .NE. 0) THEN
                        EM = EM - ONE
                        ALP2EM = (EM+EM) + ALPHA
                        ALPEM = (EM-ONE) + ALPHA
                        IF (ALPEM.EQ.ZERO) ALPEM = ONE
                        SUM = (SUM+B(N)*ALP2EM)*ALPEM/EM
                     END IF
  230             CONTINUE
               END IF
C---------------------------------------------------------------------
C Calculate B(1).
C---------------------------------------------------------------------
               B(1) = TWO*(ALPHA+ONE)*B(2)/X - B(3)
  240          EM = EM - ONE
               ALP2EM = (EM+EM) + ALPHA
               IF (ALP2EM.EQ.ZERO) ALP2EM = ONE
               SUM = SUM + B(1)*ALP2EM
C---------------------------------------------------------------------
C Normalize.  Divide all B(N) by sum.
C---------------------------------------------------------------------
  250          IF ((ALPHA+ONE).NE.ONE)
     1              SUM = SUM*FUNC(ALPHA)*(X*HALF)**(-ALPHA)
               TEMPA = ENMTEN
               IF (SUM.GT.ONE) TEMPA = TEMPA*SUM
               DO 260 N=1,NB
                 IF (ABS(B(N)).LT.TEMPA) B(N) = ZERO
                 B(N) = B(N)/SUM
  260          CONTINUE
            END IF
C---------------------------------------------------------------------
C Error return -- X, NB, or ALPHA is out of range.
C---------------------------------------------------------------------
         ELSE
            B(1) = ZERO
            NCALC = MIN(NB,0) - 1
      END IF
C---------------------------------------------------------------------
C Exit
C---------------------------------------------------------------------
  300 OUT=B(NB)
	RETURN
C ---------- Last line of RJBESL ----------
      END
c:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
      FUNCTION  RIBSL(X,ALPHA)
      NB=INT(ALPHA)
      ALPHAT=ALPHA-REAL(NB)
      NB=NB+1
	CALL  RIBESL(X,ALPHAT,NB,1,OUT,NCALC)
      RIBSL=OUT
      END
	
      SUBROUTINE RIBESL(X,ALPHA,NB,IZE,OUTPUT,NCALC)
C-------------------------------------------------------------------
C
C  This routine calculates Bessel functions I SUB(N+ALPHA) (X)
C  for non-negative argument X, and non-negative order N+ALPHA,
C  with or without exponential scaling.
C
C
C Explanation of variables in the calling sequence
C
C X     - Working precision non-negative real argument for which
C         I's or exponentially scaled I's (I*EXP(-X))
C         are to be calculated.  If I's are to be calculated,
C         X must be less than EXPARG (see below).
C ALPHA - Working precision fractional part of order for which
C         I's or exponentially scaled I's (I*EXP(-X)) are
C         to be calculated.  0 .LE. ALPHA .LT. 1.0.
C NB    - Integer number of functions to be calculated, NB .GT. 0.
C         The first function calculated is of order ALPHA, and the 
C         last is of order (NB - 1 + ALPHA).
C IZE   - Integer type.  IZE = 1 if unscaled I's are to calculated,
C         and 2 if exponentially scaled I's are to be calculated.
C B     - Working precision output vector of length NB.  If the routine
C         terminates normally (NCALC=NB), the vector B contains the 
C         functions I(ALPHA,X) through I(NB-1+ALPHA,X), or the
C         corresponding exponentially scaled functions.
C NCALC - Integer output variable indicating possible errors.
C         Before using the vector B, the user should check that
C         NCALC=NB, i.e., all orders have been calculated to
C         the desired accuracy.  See error returns below.
C 
C
C*******************************************************************
C*******************************************************************
C
C Explanation of machine-dependent constants
C
C   beta   = Radix for the floating-point system
C   minexp = Smallest representable power of beta
C   maxexp = Smallest power of beta that overflows
C   it     = Number of bits in the mantissa of a working precision
C            variable
C   NSIG   = Decimal significance desired.  Should be set to
C            INT(LOG10(2)*it+1).  Setting NSIG lower will result
C            in decreased accuracy while setting NSIG higher will
C            increase CPU time without increasing accuracy.  The
C            truncation error is limited to a relative error of
C            T=.5*10**(-NSIG).
C   ENTEN  = 10.0 ** K, where K is the largest integer such that
C            ENTEN is machine-representable in working precision
C   ENSIG  = 10.0 ** NSIG
C   RTNSIG = 10.0 ** (-K) for the smallest integer K such that
C            K .GE. NSIG/4
C   ENMTEN = Smallest ABS(X) such that X/4 does not underflow
C   XLARGE = Upper limit on the magnitude of X when IZE=2.  Bear
C            in mind that if ABS(X)=N, then at least N iterations
C            of the backward recursion will be executed.  The value
C            of 10.0 ** 4 is used on every machine.
C   EXPARG = Largest working precision argument that the library
C            EXP routine can handle and upper limit on the
C            magnitude of X when IZE=1; approximately 
C            LOG(beta**maxexp)
C
C
C     Approximate values for some important machines are:
C
C                        beta       minexp      maxexp       it
C
C  CRAY-1        (S.P.)    2        -8193        8191        48
C  Cyber 180/855
C    under NOS   (S.P.)    2         -975        1070        48
C  IEEE (IBM/XT,
C    SUN, etc.)  (S.P.)    2         -126         128        24
C  IEEE (IBM/XT,
C    SUN, etc.)  (D.P.)    2        -1022        1024        53
C  IBM 3033      (D.P.)   16          -65          63        14
C  VAX           (S.P.)    2         -128         127        24
C  VAX D-Format  (D.P.)    2         -128         127        56
C  VAX G-Format  (D.P.)    2        -1024        1023        53
C
C
C                        NSIG       ENTEN       ENSIG      RTNSIG
C
C CRAY-1        (S.P.)    15       1.0E+2465   1.0E+15     1.0E-4
C Cyber 180/855
C   under NOS   (S.P.)    15       1.0E+322    1.0E+15     1.0E-4
C IEEE (IBM/XT,
C   SUN, etc.)  (S.P.)     8       1.0E+38     1.0E+8      1.0E-2
C IEEE (IBM/XT,
C   SUN, etc.)  (D.P.)    16       1.0D+308    1.0D+16     1.0D-4
C IBM 3033      (D.P.)     5       1.0D+75     1.0D+5      1.0D-2
C VAX           (S.P.)     8       1.0E+38     1.0E+8      1.0E-2
C VAX D-Format  (D.P.)    17       1.0D+38     1.0D+17     1.0D-5
C VAX G-Format  (D.P.)    16       1.0D+307    1.0D+16     1.0D-4
C
C
C                         ENMTEN      XLARGE   EXPARG 
C
C CRAY-1        (S.P.)   1.84E-2466   1.0E+4    5677 
C Cyber 180/855
C   under NOS   (S.P.)   1.25E-293    1.0E+4     741
C IEEE (IBM/XT,
C   SUN, etc.)  (S.P.)   4.70E-38     1.0E+4      88  
C IEEE (IBM/XT,
C   SUN, etc.)  (D.P.)   8.90D-308    1.0D+4     709
C IBM 3033      (D.P.)   2.16D-78     1.0D+4     174
C VAX           (S.P.)   1.17E-38     1.0E+4      88
C VAX D-Format  (D.P.)   1.17D-38     1.0D+4      88
C VAX G-Format  (D.P.)   2.22D-308    1.0D+4     709
C
C*******************************************************************
C*******************************************************************
C
C Error returns
C
C  In case of an error,  NCALC .NE. NB, and not all I's are
C  calculated to the desired accuracy.
C
C  NCALC .LT. 0:  An argument is out of range. For example,
C     NB .LE. 0, IZE is not 1 or 2, or IZE=1 and ABS(X) .GE. EXPARG.
C     In this case, the B-vector is not calculated, and NCALC is
C     set to MIN0(NB,0)-1 so that NCALC .NE. NB.
C
C  NB .GT. NCALC .GT. 0: Not all requested function values could
C     be calculated accurately.  This usually occurs because NB is
C     much larger than ABS(X).  In this case, B(N) is calculated
C     to the desired accuracy for N .LE. NCALC, but precision
C     is lost for NCALC .LT. N .LE. NB.  If B(N) does not vanish
C     for N .GT. NCALC (because it is too small to be represented),
C     and B(N)/B(NCALC) = 10**(-K), then only the first NSIG-K
C     significant figures of B(N) can be trusted.
C
C
C Intrinsic functions required are:
C
C     DBLE, EXP, DGAMMA, GAMMA, INT, MAX, MIN, REAL, SQRT
C
C
C Acknowledgement
C
C  This program is based on a program written by David J.
C  Sookne (2) that computes values of the Bessel functions J or
C  I of real argument and integer order.  Modifications include
C  the restriction of the computation to the I Bessel function
C  of non-negative real argument, the extension of the computation
C  to arbitrary positive order, the inclusion of optional
C  exponential scaling, and the elimination of most underflow.
C  An earlier version was published in (3).
C
C References: "A Note on Backward Recurrence Algorithms," Olver,
C              F. W. J., and Sookne, D. J., Math. Comp. 26, 1972,
C              pp 941-947.
C
C             "Bessel Functions of Real Argument and Integer Order,"
C              Sookne, D. J., NBS Jour. of Res. B. 77B, 1973, pp
C              125-132.
C
C             "ALGORITHM 597, Sequence of Modified Bessel Functions
C              of the First Kind," Cody, W. J., Trans. Math. Soft.,
C              1983, pp. 242-245.
C
C  Latest modification: May 30, 1989
C
C  Modified by: W. J. Cody and L. Stoltz
C               Applied Mathematics Division
C               Argonne National Laboratory
C               Argonne, IL  60439
C
C-------------------------------------------------------------------
      INTEGER IZE,K,L,MAGX,N,NB,NBMX,NCALC,NEND,NSIG,NSTART
      REAL              GAMMA,
CD    DOUBLE PRECISION DGAMMA,             
     1 ALPHA,B,CONST,CONV,EM,EMPAL,EMP2AL,EN,ENMTEN,ENSIG,
     2 ENTEN,EXPARG,FUNC,HALF,HALFX,ONE,P,PLAST,POLD,PSAVE,PSAVEL,
     3 RTNSIG,SUM,TEMPA,TEMPB,TEMPC,TEST,TOVER,TWO,X,XLARGE,ZERO
      DIMENSION B(NB)
C-------------------------------------------------------------------
C  Mathematical constants
C-------------------------------------------------------------------
      DATA ONE,TWO,ZERO,HALF,CONST/1.0E0,2.0E0,0.0E0,0.5E0,1.585E0/
CD    DATA ONE,TWO,ZERO,HALF,CONST/1.0D0,2.0D0,0.0D0,0.5D0,1.585D0/
C-------------------------------------------------------------------
C  Machine-dependent parameters
C-------------------------------------------------------------------
      DATA NSIG,XLARGE,EXPARG /8,1.0E4,88.0E0/
      DATA ENTEN,ENSIG,RTNSIG/1.0E38,1.0E8,1.0E-2/
      DATA ENMTEN/4.7E-38/
CD    DATA NSIG,XLARGE,EXPARG /16,1.0D4,709.0D0/
CD    DATA ENTEN,ENSIG,RTNSIG/1.0D308,1.0D16,1.0D-4/
CD    DATA ENMTEN/8.9D-308/
C-------------------------------------------------------------------
C  Statement functions for conversion
C-------------------------------------------------------------------
      CONV(N) = REAL(N)
      FUNC(X) = GAMMA(X)
CD    CONV(N) = DBLE(N)
CD    FUNC(X) = DGAMMA(X)
C-------------------------------------------------------------------
C Check for X, NB, OR IZE out of range.
C-------------------------------------------------------------------
      IF ((NB.GT.0) .AND. (X .GE. ZERO) .AND.
     1    (ALPHA .GE. ZERO) .AND. (ALPHA .LT. ONE) .AND.
     2    (((IZE .EQ. 1) .AND. (X .LE. EXPARG)) .OR.
     3     ((IZE .EQ. 2) .AND. (X .LE. XLARGE)))) THEN
C-------------------------------------------------------------------
C Use 2-term ascending series for small X
C-------------------------------------------------------------------
            NCALC = NB
            MAGX = INT(X)
            IF (X .GE. RTNSIG) THEN
C-------------------------------------------------------------------
C Initialize the forward sweep, the P-sequence of Olver
C-------------------------------------------------------------------
                  NBMX = NB-MAGX
                  N = MAGX+1
                  EN = CONV(N+N) + (ALPHA+ALPHA)
                  PLAST = ONE
                  P = EN / X
C-------------------------------------------------------------------
C Calculate general significance test
C-------------------------------------------------------------------
                  TEST = ENSIG + ENSIG
                  IF (2*MAGX .GT. 5*NSIG) THEN
                        TEST = SQRT(TEST*P)
                     ELSE
                        TEST = TEST / CONST**MAGX
                  END IF
                  IF (NBMX .GE. 3) THEN
C-------------------------------------------------------------------
C Calculate P-sequence until N = NB-1.  Check for possible overflow.
C-------------------------------------------------------------------
                     TOVER = ENTEN / ENSIG
                     NSTART = MAGX+2
                     NEND = NB - 1
                     DO 100 K = NSTART, NEND
                        N = K
                        EN = EN + TWO
                        POLD = PLAST
                        PLAST = P
                        P = EN * PLAST/X + POLD
                        IF (P .GT. TOVER) THEN
C-------------------------------------------------------------------
C To avoid overflow, divide P-sequence by TOVER.  Calculate
C P-sequence until ABS(P) .GT. 1.
C-------------------------------------------------------------------
                           TOVER = ENTEN
                           P = P / TOVER
                           PLAST = PLAST / TOVER
                           PSAVE = P
                           PSAVEL = PLAST
                           NSTART = N + 1
   60                      N = N + 1
                              EN = EN + TWO
                              POLD = PLAST
                              PLAST = P
                              P = EN * PLAST/X + POLD
                           IF (P .LE. ONE) GO TO 60
                           TEMPB = EN / X
C-------------------------------------------------------------------
C Calculate backward test, and find NCALC, the highest N
C such that the test is passed.
C-------------------------------------------------------------------
                           TEST = POLD*PLAST / ENSIG
                           TEST = TEST*(HALF-HALF/(TEMPB*TEMPB))
                           P = PLAST * TOVER
                           N = N - 1
                           EN = EN - TWO
                           NEND = MIN0(NB,N)
                           DO 80 L = NSTART, NEND
                              NCALC = L
                              POLD = PSAVEL
                              PSAVEL = PSAVE
                              PSAVE = EN * PSAVEL/X + POLD
                              IF (PSAVE*PSAVEL .GT. TEST) GO TO 90
   80                      CONTINUE
                           NCALC = NEND + 1
   90                      NCALC = NCALC - 1
                           GO TO 120
                        END IF
  100                CONTINUE
                     N = NEND
                     EN = CONV(N+N) + (ALPHA+ALPHA)
C-------------------------------------------------------------------
C Calculate special significance test for NBMX .GT. 2.
C-------------------------------------------------------------------
                     TEST = MAX(TEST,SQRT(PLAST*ENSIG)*SQRT(P+P))
                  END IF
C-------------------------------------------------------------------
C Calculate P-sequence until significance test passed.
C-------------------------------------------------------------------
  110             N = N + 1
                     EN = EN + TWO
                     POLD = PLAST
                     PLAST = P
                     P = EN * PLAST/X + POLD
                  IF (P .LT. TEST) GO TO 110
C-------------------------------------------------------------------
C Initialize the backward recursion and the normalization sum.
C-------------------------------------------------------------------
  120             N = N + 1
                  EN = EN + TWO
                  TEMPB = ZERO
                  TEMPA = ONE / P
                  EM = CONV(N) - ONE
                  EMPAL = EM + ALPHA
                  EMP2AL = (EM - ONE) + (ALPHA + ALPHA)
                  SUM = TEMPA * EMPAL * EMP2AL / EM
                  NEND = N - NB
                  IF (NEND .LT. 0) THEN
C-------------------------------------------------------------------
C N .LT. NB, so store B(N) and set higher orders to zero.
C-------------------------------------------------------------------
                        B(N) = TEMPA
                        NEND = -NEND
                        DO 130 L = 1, NEND
  130                      B(N+L) = ZERO
                     ELSE
                        IF (NEND .GT. 0) THEN
C-------------------------------------------------------------------
C Recur backward via difference equation, calculating (but
C not storing) B(N), until N = NB.
C-------------------------------------------------------------------
                           DO 140 L = 1, NEND
                              N = N - 1
                              EN = EN - TWO
                              TEMPC = TEMPB
                              TEMPB = TEMPA
                              TEMPA = (EN*TEMPB) / X + TEMPC
                              EM = EM - ONE
                              EMP2AL = EMP2AL - ONE
                              IF (N .EQ. 1) GO TO 150
                              IF (N .EQ. 2) EMP2AL = ONE
                              EMPAL = EMPAL - ONE
                              SUM = (SUM + TEMPA*EMPAL) * EMP2AL / EM
  140                      CONTINUE
                        END IF
C-------------------------------------------------------------------
C Store B(NB)
C-------------------------------------------------------------------
  150                   B(N) = TEMPA
                        IF (NB .LE. 1) THEN
                           SUM = (SUM + SUM) + TEMPA
                           GO TO 230
                        END IF
C-------------------------------------------------------------------
C Calculate and Store B(NB-1)
C-------------------------------------------------------------------
                        N = N - 1
                        EN = EN - TWO
                        B(N)  = (EN*TEMPA) / X + TEMPB
                        IF (N .EQ. 1) GO TO 220
                        EM = EM - ONE
                        EMP2AL = EMP2AL - ONE
                        IF (N .EQ. 2) EMP2AL = ONE
                        EMPAL = EMPAL - ONE
                        SUM = (SUM + B(N)*EMPAL) * EMP2AL / EM
                  END IF
                  NEND = N - 2
                  IF (NEND .GT. 0) THEN
C-------------------------------------------------------------------
C Calculate via difference equation and store B(N), until N = 2.
C-------------------------------------------------------------------
                     DO 200 L = 1, NEND
                        N = N - 1
                        EN = EN - TWO
                        B(N) = (EN*B(N+1)) / X +B(N+2)
                        EM = EM - ONE
                        EMP2AL = EMP2AL - ONE
                        IF (N .EQ. 2) EMP2AL = ONE
                        EMPAL = EMPAL - ONE
                        SUM = (SUM + B(N)*EMPAL) * EMP2AL / EM
  200                CONTINUE
                  END IF
C-------------------------------------------------------------------
C Calculate B(1)
C-------------------------------------------------------------------
                  B(1) = TWO*EMPAL*B(2) / X + B(3)
  220             SUM = (SUM + SUM) + B(1)
C-------------------------------------------------------------------
C Normalize.  Divide all B(N) by sum.
C-------------------------------------------------------------------
  230             IF (ALPHA .NE. ZERO)
     1               SUM = SUM * FUNC(ONE+ALPHA) * (X*HALF)**(-ALPHA)
                  IF (IZE .EQ. 1) SUM = SUM * EXP(-X)
                  TEMPA = ENMTEN
                  IF (SUM .GT. ONE) TEMPA = TEMPA * SUM
                  DO 260 N = 1, NB
                     IF (B(N) .LT. TEMPA) B(N) = ZERO
                     B(N) = B(N) / SUM
  260             CONTINUE
      OUTPUT=B(NB)
                  RETURN
C-------------------------------------------------------------------
C Two-term ascending series for small X.
C-------------------------------------------------------------------
               ELSE
                  TEMPA = ONE
                  EMPAL = ONE + ALPHA
                  HALFX = ZERO
                  IF (X .GT. ENMTEN) HALFX = HALF * X
                  IF (ALPHA .NE. ZERO) TEMPA = HALFX**ALPHA /FUNC(EMPAL)
                  IF (IZE .EQ. 2) TEMPA = TEMPA * EXP(-X)
                  TEMPB = ZERO
                  IF ((X+ONE) .GT. ONE) TEMPB = HALFX * HALFX
                  B(1) = TEMPA + TEMPA*TEMPB / EMPAL
                  IF ((X .NE. ZERO) .AND. (B(1) .EQ. ZERO)) NCALC = 0
                  IF (NB .GT. 1) THEN
                     IF (X .EQ. ZERO) THEN
                           DO 310 N = 2, NB
                              B(N) = ZERO
  310                      CONTINUE
                        ELSE
C-------------------------------------------------------------------
C Calculate higher-order functions.
C-------------------------------------------------------------------
                           TEMPC = HALFX
                           TOVER = (ENMTEN + ENMTEN) / X
                           IF (TEMPB .NE. ZERO) TOVER = ENMTEN / TEMPB
                           DO 340 N = 2, NB
                              TEMPA = TEMPA / EMPAL
                              EMPAL = EMPAL + ONE
                              TEMPA = TEMPA * TEMPC
                              IF (TEMPA .LE. TOVER*EMPAL) TEMPA = ZERO
                              B(N) = TEMPA + TEMPA*TEMPB / EMPAL
                              IF ((B(N) .EQ. ZERO) .AND. (NCALC .GT. N))
     1                             NCALC = N-1
  340                      CONTINUE
                     END IF
                  END IF
            END IF
      OUTPUT=B(NB)
         ELSE
            NCALC = MIN0(NB,0)-1
      OUTPUT=-1000.
      END IF
      RETURN
C---------- Last line of RIBESL ----------
      END

      REAL FUNCTION GAMMA(X)
CD    DOUBLE PRECISION FUNCTION DGAMMA(X)
C----------------------------------------------------------------------
C
C This routine calculates the GAMMA function for a real argument X.
C   Computation is based on an algorithm outlined in reference 1.
C   The program uses rational functions that approximate the GAMMA
C   function to at least 20 significant decimal digits.  Coefficients
C   for the approximation over the interval (1,2) are unpublished.
C   Those for the approximation for X .GE. 12 are from reference 2.
C   The accuracy achieved depends on the arithmetic system, the
C   compiler, the intrinsic functions, and proper selection of the
C   machine-dependent constants.
C
C
C*******************************************************************
C*******************************************************************
C
C Explanation of machine-dependent constants
C
C beta   - radix for the floating-point representation
C maxexp - the smallest positive power of beta that overflows
C XBIG   - the largest argument for which GAMMA(X) is representable
C          in the machine, i.e., the solution to the equation
C                  GAMMA(XBIG) = beta**maxexp
C XINF   - the largest machine representable floating-point number;
C          approximately beta**maxexp
C EPS    - the smallest positive floating-point number such that
C          1.0+EPS .GT. 1.0
C XMININ - the smallest positive floating-point number such that
C          1/XMININ is machine representable
C
C     Approximate values for some important machines are:
C
C                            beta       maxexp        XBIG
C
C CRAY-1         (S.P.)        2         8191        966.961
C Cyber 180/855
C   under NOS    (S.P.)        2         1070        177.803
C IEEE (IBM/XT,
C   SUN, etc.)   (S.P.)        2          128        35.040
C IEEE (IBM/XT,
C   SUN, etc.)   (D.P.)        2         1024        171.624
C IBM 3033       (D.P.)       16           63        57.574
C VAX D-Format   (D.P.)        2          127        34.844
C VAX G-Format   (D.P.)        2         1023        171.489
C
C                            XINF         EPS        XMININ
C
C CRAY-1         (S.P.)   5.45E+2465   7.11E-15    1.84E-2466
C Cyber 180/855
C   under NOS    (S.P.)   1.26E+322    3.55E-15    3.14E-294
C IEEE (IBM/XT,
C   SUN, etc.)   (S.P.)   3.40E+38     1.19E-7     1.18E-38
C IEEE (IBM/XT,
C   SUN, etc.)   (D.P.)   1.79D+308    2.22D-16    2.23D-308
C IBM 3033       (D.P.)   7.23D+75     2.22D-16    1.39D-76
C VAX D-Format   (D.P.)   1.70D+38     1.39D-17    5.88D-39
C VAX G-Format   (D.P.)   8.98D+307    1.11D-16    1.12D-308
C
C*******************************************************************
C*******************************************************************
C
C Error returns
C
C  The program returns the value XINF for singularities or
C     when overflow would occur.  The computation is believed
C     to be free of underflow and overflow.
C
C
C  Intrinsic functions required are:
C
C     INT, DBLE, EXP, LOG, REAL, SIN
C
C
C References: "An Overview of Software Development for Special
C              Functions", W. J. Cody, Lecture Notes in Mathematics,
C              506, Numerical Analysis Dundee, 1975, G. A. Watson
C              (ed.), Springer Verlag, Berlin, 1976.
C
C              Computer Approximations, Hart, Et. Al., Wiley and
C              sons, New York, 1968.
C
C  Latest modification: October 12, 1989
C
C  Authors: W. J. Cody and L. Stoltz
C           Applied Mathematics Division
C           Argonne National Laboratory
C           Argonne, IL 60439
C
C----------------------------------------------------------------------
      INTEGER I,N
      LOGICAL PARITY
      REAL 
CD    DOUBLE PRECISION 
     1    C,CONV,EPS,FACT,HALF,ONE,P,PI,Q,RES,SQRTPI,SUM,TWELVE,
     2    TWO,X,XBIG,XDEN,XINF,XMININ,XNUM,Y,Y1,YSQ,Z,ZERO
      DIMENSION C(7),P(8),Q(8)
C----------------------------------------------------------------------
C  Mathematical constants
C----------------------------------------------------------------------
      DATA ONE,HALF,TWELVE,TWO,ZERO/1.0E0,0.5E0,12.0E0,2.0E0,0.0E0/,
     1     SQRTPI/0.9189385332046727417803297E0/,
     2     PI/3.1415926535897932384626434E0/
CD    DATA ONE,HALF,TWELVE,TWO,ZERO/1.0D0,0.5D0,12.0D0,2.0D0,0.0D0/,
CD   1     SQRTPI/0.9189385332046727417803297D0/,
CD   2     PI/3.1415926535897932384626434D0/
C----------------------------------------------------------------------
C  Machine dependent parameters
C----------------------------------------------------------------------
      DATA XBIG,XMININ,EPS/35.040E0,1.18E-38,1.19E-7/,
     1     XINF/3.4E38/
CD    DATA XBIG,XMININ,EPS/171.624D0,2.23D-308,2.22D-16/,
CD   1     XINF/1.79D308/
C----------------------------------------------------------------------
C  Numerator and denominator coefficients for rational minimax
C     approximation over (1,2).
C----------------------------------------------------------------------
      DATA P/-1.71618513886549492533811E+0,2.47656508055759199108314E+1,
     1       -3.79804256470945635097577E+2,6.29331155312818442661052E+2,
     2       8.66966202790413211295064E+2,-3.14512729688483675254357E+4,
     3       -3.61444134186911729807069E+4,6.64561438202405440627855E+4/
      DATA Q/-3.08402300119738975254353E+1,3.15350626979604161529144E+2,
     1      -1.01515636749021914166146E+3,-3.10777167157231109440444E+3,
     2        2.25381184209801510330112E+4,4.75584627752788110767815E+3,
     3      -1.34659959864969306392456E+5,-1.15132259675553483497211E+5/
CD    DATA P/-1.71618513886549492533811D+0,2.47656508055759199108314D+1,
CD   1       -3.79804256470945635097577D+2,6.29331155312818442661052D+2,
CD   2       8.66966202790413211295064D+2,-3.14512729688483675254357D+4,
CD   3       -3.61444134186911729807069D+4,6.64561438202405440627855D+4/
CD    DATA Q/-3.08402300119738975254353D+1,3.15350626979604161529144D+2,
CD   1      -1.01515636749021914166146D+3,-3.10777167157231109440444D+3,
CD   2        2.25381184209801510330112D+4,4.75584627752788110767815D+3,
CD   3      -1.34659959864969306392456D+5,-1.15132259675553483497211D+5/
C----------------------------------------------------------------------
C  Coefficients for minimax approximation over (12, INF).
C----------------------------------------------------------------------
      DATA C/-1.910444077728E-03,8.4171387781295E-04,
     1     -5.952379913043012E-04,7.93650793500350248E-04,
     2     -2.777777777777681622553E-03,8.333333333333333331554247E-02,
     3      5.7083835261E-03/
CD    DATA C/-1.910444077728D-03,8.4171387781295D-04,
CD   1     -5.952379913043012D-04,7.93650793500350248D-04,
CD   2     -2.777777777777681622553D-03,8.333333333333333331554247D-02,
CD   3      5.7083835261D-03/
C----------------------------------------------------------------------
C  Statement functions for conversion between integer and float
C----------------------------------------------------------------------
      CONV(I) = REAL(I)
CD    CONV(I) = DBLE(I)
      PARITY = .FALSE.
      FACT = ONE
      N = 0
      Y = X
      IF (Y .LE. ZERO) THEN
C----------------------------------------------------------------------
C  Argument is negative
C----------------------------------------------------------------------
            Y = -X
            Y1 = AINT(Y)
            RES = Y - Y1
            IF (RES .NE. ZERO) THEN
                  IF (Y1 .NE. AINT(Y1*HALF)*TWO) PARITY = .TRUE.
                  FACT = -PI / SIN(PI*RES)
                  Y = Y + ONE
               ELSE
                  RES = XINF
                  GO TO 900
            END IF
      END IF
C----------------------------------------------------------------------
C  Argument is positive
C----------------------------------------------------------------------
      IF (Y .LT. EPS) THEN
C----------------------------------------------------------------------
C  Argument .LT. EPS
C----------------------------------------------------------------------
            IF (Y .GE. XMININ) THEN
                  RES = ONE / Y
               ELSE
                  RES = XINF
                  GO TO 900
            END IF
         ELSE IF (Y .LT. TWELVE) THEN
            Y1 = Y
            IF (Y .LT. ONE) THEN
C----------------------------------------------------------------------
C  0.0 .LT. argument .LT. 1.0
C----------------------------------------------------------------------
                  Z = Y
                  Y = Y + ONE
               ELSE
C----------------------------------------------------------------------
C  1.0 .LT. argument .LT. 12.0, reduce argument if necessary
C----------------------------------------------------------------------
                  N = INT(Y) - 1
                  Y = Y - CONV(N)
                  Z = Y - ONE
            END IF
C----------------------------------------------------------------------
C  Evaluate approximation for 1.0 .LT. argument .LT. 2.0
C----------------------------------------------------------------------
            XNUM = ZERO
            XDEN = ONE
            DO 260 I = 1, 8
               XNUM = (XNUM + P(I)) * Z
               XDEN = XDEN * Z + Q(I)
  260       CONTINUE
            RES = XNUM / XDEN + ONE
            IF (Y1 .LT. Y) THEN
C----------------------------------------------------------------------
C  Adjust result for case  0.0 .LT. argument .LT. 1.0
C----------------------------------------------------------------------
                  RES = RES / Y1
               ELSE IF (Y1 .GT. Y) THEN
C----------------------------------------------------------------------
C  Adjust result for case  2.0 .LT. argument .LT. 12.0
C----------------------------------------------------------------------
                  DO 290 I = 1, N
                     RES = RES * Y
                     Y = Y + ONE
  290             CONTINUE
            END IF
         ELSE
C----------------------------------------------------------------------
C  Evaluate for argument .GE. 12.0,
C----------------------------------------------------------------------
            IF (Y .LE. XBIG) THEN
                  YSQ = Y * Y
                  SUM = C(7)
                  DO 350 I = 1, 6
                     SUM = SUM / YSQ + C(I)
  350             CONTINUE
                  SUM = SUM/Y - Y + SQRTPI
                  SUM = SUM + (Y-HALF)*LOG(Y)
                  RES = EXP(SUM)
               ELSE
                  RES = XINF
                  GO TO 900
            END IF
      END IF
C----------------------------------------------------------------------
C  Final adjustments and return
C----------------------------------------------------------------------
      IF (PARITY) RES = -RES
      IF (FACT .NE. ONE) RES = FACT / RES
  900 GAMMA = RES
CD900 DGAMMA = RES
      RETURN
C ---------- Last line of GAMMA ----------
      END
@


1.30
log
@ilist replaced
@
text
@d4 1
a4 1
C  WIW32F.F
a44 2
	PRINT *,'  BESSEL'

d148 1
a148 1
     &      LSD,N2,N2/2,INUMBR,DM,NANG,SM,MAXSYM,SIR)
d203 1
a203 1
        CALL WINDKB2(XE,XE,NSAM,LSD,N2,SIR)
d279 1
a279 1
        CALL  WINDKB2(XE,XE,NSAM,LSD,N2,SIR)
d308 1
a308 1
        CALL  WINDKB2(XO,XO,NSAM,LSD,N2,SIR)
d344 1
a344 1
     &                      INUMBR,DM,NANG,SM,MAXSYM,SIR)
d358 1
a358 1
        PARAMETER (LTAB=5000)
d446 3
d461 1
a461 3
           DO  J=1,NS
              CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
           ENDDO
d481 18
a499 1
c$omp parallel do private(j),shared(N,N2,XE,WE,BI,DMS)
a503 1
c$omp parallel do private(j),shared(N,N2,XO,WO,BI,DMS)
d508 1
d527 1
a527 1
        SUBROUTINE WINDKB2(BI,R,L,LSD,N,SIR)
d847 1
a847 1
        PARAMETER (LTAB=5000)
a1004 111
        END

C----------------BUILDM ---------------------------------------

       SUBROUTINE  BUILDM(INUMBR,DM,NANG,ANGBUF,IRTFLG)
C  Bulid rotation matrices from three Eulerian angles

        INCLUDE    'CMBLOCK.INC' 

        DOUBLE PRECISION  CPHI,SPHI,CTHE,STHE,CPSI,SPSI
        DOUBLE PRECISION  QUADPI,DGR_TO_RAD
        PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
        PARAMETER (DGR_TO_RAD = (QUADPI/180))
        DIMENSION   DM(9,NANG),INUMBR(NANG)
        DIMENSION   ANGBUF(4,NANG)

         DO    K=1,NANG

C          READ ANGLES FROM THE DOCUMENT FILE.
C          ORDER IN THE DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES 
C          ARE IN DEGREES! IN ANG ARRAY IT IS OTHER WAY AROUND

           ITMP   = INUMBR(K)
           IKEY   = ANGBUF(1,ITMP)

           IF (IKEY .NE. ITMP) THEN
C             MISSING KEY
              WRITE(NOUT,*) '*** MISSING ANGLE FOR IMAGE: ',ITMP
              CALL ERRT(100,'  ',NE)
              IRTFLG = 1
              RETURN
           ENDIF

           CPHI=DCOS(DBLE(ANGBUF(4,ITMP))*DGR_TO_RAD)
           SPHI=DSIN(DBLE(ANGBUF(4,ITMP))*DGR_TO_RAD)
           CTHE=DCOS(DBLE(ANGBUF(3,ITMP))*DGR_TO_RAD)
           STHE=DSIN(DBLE(ANGBUF(3,ITMP))*DGR_TO_RAD)
           CPSI=DCOS(DBLE(ANGBUF(2,ITMP))*DGR_TO_RAD)
           SPSI=DSIN(DBLE(ANGBUF(2,ITMP))*DGR_TO_RAD)

           DM(1,K)=CPHI*CTHE*CPSI-SPHI*SPSI
           DM(2,K)=SPHI*CTHE*CPSI+CPHI*SPSI
           DM(3,K)=-STHE*CPSI
           DM(4,K)=-CPHI*CTHE*SPSI-SPHI*CPSI
           DM(5,K)=-SPHI*CTHE*SPSI+CPHI*CPSI
           DM(6,K)=STHE*SPSI
           DM(7,K)=STHE*CPHI
           DM(8,K)=STHE*SPHI
           DM(9,K)=CTHE

           WRITE(NOUT,333)  K,(ANGBUF(J,ITMP),J=2,4)
333        FORMAT(' PROJECTION #',I6,
     &         '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
         ENDDO

        IRTFLG = 0
        END

C       ----------------BUILDS ---------------------------------------

        SUBROUTINE  BUILDS(DS,NANG,ANGSYM,IRTFLG)
C  Bulid rotation matrices from three Eulerian angles
C  disregard keys.

        INCLUDE    'CMBLOCK.INC' 

        DOUBLE PRECISION  CPHI,SPHI,CTHE,STHE,CPSI,SPSI
        DOUBLE PRECISION  QUADPI,DGR_TO_RAD
        PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
        PARAMETER (DGR_TO_RAD = (QUADPI/180))
        DIMENSION   DS(9,NANG),ANGSYM(4,NANG)

         DO    ITMP=1,NANG

C          READ ANGLES FROM THE DOCUMENT FILE.
C          ORDER IN THE DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES 
C          ARE IN DEGREES! IN ANG ARRAY IT IS OTHER WAY AROUND

           IKEY   = ANGSYM(1,ITMP)

           IF (IKEY .NE. ITMP) THEN
C             MISSING KEY
              WRITE(NOUT,*) '*** MISSING SYMMETRY: ',ITMP
              CALL ERRT(100,'  ',NE)
              IRTFLG = 1
              RETURN
           ENDIF
C
           CPHI=DCOS(DBLE(ANGSYM(4,ITMP))*DGR_TO_RAD)
           SPHI=DSIN(DBLE(ANGSYM(4,ITMP))*DGR_TO_RAD)
           CTHE=DCOS(DBLE(ANGSYM(3,ITMP))*DGR_TO_RAD)
           STHE=DSIN(DBLE(ANGSYM(3,ITMP))*DGR_TO_RAD)
           CPSI=DCOS(DBLE(ANGSYM(2,ITMP))*DGR_TO_RAD)
           SPSI=DSIN(DBLE(ANGSYM(2,ITMP))*DGR_TO_RAD)
C
           DS(1,ITMP)=CPHI*CTHE*CPSI-SPHI*SPSI
           DS(2,ITMP)=SPHI*CTHE*CPSI+CPHI*SPSI
           DS(3,ITMP)=-STHE*CPSI
           DS(4,ITMP)=-CPHI*CTHE*SPSI-SPHI*CPSI
           DS(5,ITMP)=-SPHI*CTHE*SPSI+CPHI*CPSI
           DS(6,ITMP)=STHE*SPSI
           DS(7,ITMP)=STHE*CPHI
           DS(8,ITMP)=STHE*SPHI
           DS(9,ITMP)=CTHE
C
           WRITE(NOUT,333)  ITMP,(ANGSYM(J,ITMP),J=2,4)
333        FORMAT(' SYMMETRY #',I6,
     &         '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
         ENDDO
C
        IRTFLG = 0
@


1.29
log
@ifdef structure corrected
@
text
@a32 1
        INTEGER, ALLOCATABLE, DIMENSION(:) :: ILIST
d45 1
a45 5
        ALLOCATE (ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, ILIST',IER)
           RETURN
        ENDIF
d47 1
a47 1
        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NANG,
d49 1
a49 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(ILIST)
           RETURN
        ENDIF
d51 1
a51 1
        MAXNUM = MAXVAL(ILIST(1:NANG))
d62 1
a62 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ILIST)
           RETURN
        ENDIF
d72 1
a72 1
        CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),IRTFLG)
a73 1
           DEALLOCATE (ILIST)
a81 1
           DEALLOCATE (ILIST)
d92 1
a92 4
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, DM',IER)
           DEALLOCATE (ILIST)
        ENDIF
d94 1
a94 1
        CALL  BUILDM(ILIST,DM,NANG,ANGBUF(1,1),IRTFLG)
d97 1
a97 1
           DEALLOCATE (ILIST,ANGBUF,DM)
d106 1
a106 1
              DEALLOCATE (ILIST,DM)
d116 1
a116 1
               DEALLOCATE (ILIST,DM)
d123 1
a123 1
           DEALLOCATE(ILIST,DM,SM)
d130 1
a130 1
           DEALLOCATE(ILIST,DM,SM,XE)
d137 1
a137 1
           DEALLOCATE(ILIST,DM,SM,XE,WE)
d144 1
a144 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO)
d150 1
a150 1
     &      LSD,N2,N2/2,ILIST,DM,NANG,SM,MAXSYM,SIR)
d154 1
a154 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d161 1
a161 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d168 1
a168 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d177 1
a177 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d194 1
a194 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d212 1
a212 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d238 1
a238 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d252 1
a252 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d269 1
a269 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d301 1
a301 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d331 1
a331 1
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
d340 1
a340 1
        DEALLOCATE (ILIST, DM, SM, XE, WE, XO, WO)
d346 1
a346 1
     &                      ILIST,DM,NANG,SM,MAXSYM,SIR)
d354 1
a354 1
        DIMENSION        ILIST(NANG)
d452 1
a452 1
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K),IRTFLG)
a626 1
        INTEGER, ALLOCATABLE, DIMENSION(:) ::     ILIST
d640 1
a640 7
        ALLOCATE (ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, ILIST',IER)
           RETURN
        ENDIF

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NANG,
d644 1
a644 1
        MAXNUM = MAXVAL(ILIST(1:NANG))
d667 1
a667 1
        CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),IRTFLG)
d685 1
a685 1
           CALL BUILDM(ILIST,DM,NANG,ANGBUF(1,1),IRTFLG)
d719 1
a719 1
     &      LSD,N2,N2/2,ILIST,DM,NANG,SM,MAXSYM,SIR,ANGINDOC,IRTFLG)
a800 1
        IF (ALLOCATED(ILIST))  DEALLOCATE (ILIST)
d813 1
a813 1
        SUBROUTINE  WIW32DQ(NS,XE,WE,XO,WO, LSD,N,N2,ILIST,DM,
d825 1
a825 1
        DIMENSION        ILIST(NANG)
d875 1
a875 1
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K),IRTFLG)
d888 1
a888 1
              ANGBUF(1) = ILIST(K)
d890 1
a890 1
              CALL BUILDM(ILIST,DM,1,ANGBUF,IRTFLG)
d993 1
a993 1
       SUBROUTINE  BUILDM(ILIST,DM,NANG,ANGBUF,IRTFLG)
d1002 1
a1002 1
        DIMENSION   DM(9,NANG),ILIST(NANG)
d1011 1
a1011 1
           ITMP   = ILIST(K)
@


1.28
log
@prompts changed
@
text
@d176 1
a176 1
	 IF (IRTFLG .NE. 0) THEN
d525 442
a1124 85
C       ------------------- WINDKB2 -------------------------------

        SUBROUTINE WINDKB2(BI,R,L,LSD,N,SIR)

        DIMENSION  R(L,L,L),BI(LSD,N,N)
	COMMON  /BESSEL_PARAM/  ALPHA,AAAA,NNN
C,mmm
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (TWOPI = 2*QUADPI)

c        TNR=1.0/(SQRT(2.0*2.0*ATAN(1.0))*SIR)*L
        IP=(N-L)/2+MOD(L,2)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 R(I,J,K)=BI(IP+I,IP+J,IP+K)
c*TNR
              ENDDO
           ENDDO
        ENDDO
C
        L2=(L/2)**2
        L2P=(L/2-1)**2
        IP=L/2+1
	XNU=REAL(NNN)/2.
C+REAL(mmm)
C	CALL  BESSIK(ALPHA,XNU,RI,RK,RIP,RIK)
	
	RI=RIBSL(ALPHA,XNU)
C	if(abs(ri-rin).gt.1.e-5)  print  *,'bessik'

	WKB0=ALPHA**XNU/RI
	QRT=(TWOPI*AAAA)**2
        TNR=0.0
        M=0
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF(LR.LE.L2) THEN
		 SIGMA=QRT*LR-ALPHA*ALPHA
	          IF(ABS(SIGMA).LT.1.0E-7)  THEN
	           WKB=1.0
	          ELSEIF(SIGMA.GT.0.0)  THEN
C   2PI A R > ALPHA
		   ART=SQRT(SIGMA)
C		   CALL  BESSJY(ART,XNU,RI,RK,RIP,RIK)
      		   RI=RJBSL(ART, XNU)
C	if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessjy',i,j,k
	           WKB=WKB0*RI/ART**XNU
	          ELSE
C   2PI A R < ALPHA
		   ART=SQRT(ABS(SIGMA))
C		   CALL  BESSIK(ART,XNU,RI,RK,RIP,RIK)
		   RI=RIBSL(ART,XNU)
C	if(abs(ri-rin)/rin.gt.1.e-5)  print  *,'bessik',i,j,k,ri,rin
	           WKB=WKB0*RI/ART**XNU
	          ENDIF
                  R(I,J,K) = R(I,J,K)/ABS(WKB)
                  IF(LR.GE.L2P .AND. LR.LE.L2) THEN
                   TNR=TNR+R(I,J,K)
                   M=M+1
                  ENDIF
                 ENDIF
              ENDDO
           ENDDO
        ENDDO
        TNR=TNR/REAL(M)
c$omp parallel do private(i,j,k,lr)
        DO  K=1,L
           DO  J=1,L
              DO  I=1,L
                 LR=(K-IP)**2+(J-IP)**2+(I-IP)**2
                 IF(LR.LE.L2) THEN
                    R(I,J,K)=R(I,J,K)-TNR
                 ELSE
                    R(I,J,K)=0.0
                 ENDIF
              ENDDO
           ENDDO
        ENDDO

        END

C
d1130 1
a1130 1
C This packet computes modified Bessel functioons of the first kind
a2614 517
#else
C++************************************************************************
C
C  WIW32D.F                                           01/10/00
C                        ANGLES IN HEADER JULY 01 ArDean Leith
C                        OPFILE 'U'       FEB  02 ArDean Leith
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C   WIW32D
C
C IMAGE_PROCESSING_ROUTINE
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE WIW32D

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        INCLUDE 'F90ALLOC.INC'

C       DOC FILE POINTERS
        REAL, DIMENSION(:,:), POINTER ::          ANGBUF, ANGSYM
        REAL, DIMENSION(:,:), ALLOCATABLE ::      DM,SM 
        INTEGER, ALLOCATABLE, DIMENSION(:) ::     ILIST
        COMPLEX, ALLOCATABLE, DIMENSION(:,:,:) :: XE,XO
        REAL, ALLOCATABLE, DIMENSION(:,:,:) ::    WE,WO
        LOGICAL ::                                ANGINDOC
        CHARACTER(LEN=1) ::                       NULL

        CHARACTER*80    FINPIC,FINFO,ANGDOC,FINPAT
        COMMON /F_SPEC/ FINPAT,NLET,FINPIC

        DATA  IOPIC/98/,INPIC/99/

        NULL   = CHAR(0)
        NILMAX = NIMAX

        ALLOCATE (ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, ILIST',IER)
           RETURN
        ENDIF

        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NANG,
     &                 'ENTER TEMPLATE FOR 2-D IMAGES',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        MAXNUM = MAXVAL(ILIST(1:NANG))
        CLOSE(INPIC)

C       NANG - TOTAL NUMBER OF IMAGES
        WRITE(NOUT,2001) NANG
2001    FORMAT(' NUMBER OF IMAGES =',I5)

C       RETRIEVE ARRAY WITH ANGLES DATA IN IT
        ANGINDOC = .TRUE.
        MAXXT    = 4
        MAXYT    = MAXNUM
        CALL GETDOCDAT('ANGLES DOC',.TRUE.,ANGDOC,77,.FALSE.,MAXXT,
     &                       MAXYT,ANGBUF,IRTFLG)
        IF (IRTFLG .NE. 0) ANGINDOC = .FALSE.

C       RETRIEVE ARRAY WITH SYMMETRIES DATA IN IT
        MAXXS  = 0
        MAXSYM = 0
        CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &                   MAXSYM,ANGSYM,IRTFLG)
        IF (IRTFLG .NE. 0)  MAXSYM = 1

C       OPEN FIRST IMAGE FILE TO DETERMINE NSAM, NROW, NSL
        CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        MAXIM = 0
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSL,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999
        CLOSE(INPIC)

        N2   = 2*NSAM
        LSD  = N2+2-MOD(N2,2)
        NMAT = LSD*N2*N2

        IF (ANGINDOC) THEN
        
           ALLOCATE(DM(9,NANG), STAT=IRTFLG)
           IF (IRTFLG.NE.0) GOTO 999

           CALL BUILDM(ILIST,DM,NANG,ANGBUF(1,1),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999
        
           IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        ELSE
           ALLOCATE(DM(9,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) GOTO 999
        ENDIF

        IF (MAXSYM.GT.1)  THEN
           ALLOCATE(SM(9,MAXSYM), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
              CALL ERRT(46,'BP 3F, SM(9,MAXSYM)',IER)
              GOTO 999
           ENDIF
           CALL BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)

        ELSE
           ALLOCATE(SM(1,1), STAT=IRTFLG)
           IF (IRTFLG.NE.0) THEN 
               CALL ERRT(46,'BP 3F, SM(1,1)',IER)
               GOTO 999
           ENDIF
        ENDIF

        ALLOCATE(XE(0:N2/2,N2,N2),WE(0:N2/2,N2,N2),WO(0:N2/2,N2,N2),
     &            XO(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F; XE, WE, WO & XO',IER)
           GOTO 999
        ENDIF

        CALL  WIW32DQ(NSAM,XE,WE,XO,WO,
     &      LSD,N2,N2/2,ILIST,DM,NANG,SM,MAXSYM,SIR,ANGINDOC,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',IRTFLG) 
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3-D',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
 
        CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3-D',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'U',IFORM,LSD,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        CLOSE(IOPIC)

C       CBE AND CBO (XE & XO) ARE LSD x N2 x N2
C       CWE AND CWO (WE & WO) ARE (LSD/2) x N2 x N2
        LSDD2 = LSD/2
        IFORM = 3
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'U',IFORM,LSDD2,N2,N2,
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)
        CLOSE(IOPIC)

        CALL NRMW2(XE,WE,N2/2,N2)
        CALL WIND2(XE,XE,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPAT,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'O',IFORM,LSD,N2,N2,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
	
        CALL READV(IOPIC,XE,LSD,N2,LSD,N2,N2)
        CLOSE(IOPIC)

        CALL OPFILE(.FALSE.,FINFO,IOPIC,'O',IFORM,LSDD2,N2,N2,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999
 
        CALL READV(IOPIC,WE,LSD/2,N2,LSD/2,N2,N2)
        CLOSE(IOPIC)

C       ADD E+O
        CALL ADDADA(XE,XO,NMAT)
        CALL ADDADA(WE,WO,NMAT/2)
        CALL NRMW2(XE,WE,N2/2,N2)
        CALL WIND2(XE,XE,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINPIC,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 999

        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

        CALL NRMW2(XO,WO,N2/2,N2)
        CALL WIND2(XO,XO,NSAM,LSD,N2,SIR)

        IFORM = 3
        CALL OPFILE(.FALSE.,FINFO,IOPIC,'U',IFORM,NSAM,NSAM,NSAM,
     &             MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 999

        CALL WRITEV(IOPIC,XO,NSAM,NSAM,NSAM,NSAM,NSAM)
        CLOSE(IOPIC)

 999    CONTINUE
        IF (ALLOCATED(ILIST))  DEALLOCATE (ILIST)
        IF (ALLOCATED(DM))     DEALLOCATE(DM)
        IF (ALLOCATED(SM))     DEALLOCATE(SM)
        IF (ALLOCATED(XE))     DEALLOCATE(XE)
        IF (ALLOCATED(WE))     DEALLOCATE(WE)
        IF (ALLOCATED(XO))     DEALLOCATE(XO)
        IF (ALLOCATED(WO))     DEALLOCATE(WO)
        IF (ASSOCIATED(ANGBUF)) DEALLOCATE(ANGBUF)
        IF (ASSOCIATED(ANGSYM)) DEALLOCATE(ANGSYM)
        END

C       ---------------- WIW32DQ -------------------------------------

        SUBROUTINE  WIW32DQ(NS,XE,WE,XO,WO, LSD,N,N2,ILIST,DM,
     &                      NANG,SM,MAXSYM,SIR,ANGINDOC,IRTFLG)

        INCLUDE 'CMLIMIT.INC'

        LOGICAL ::                              ANGINDOC
        REAL, DIMENSION(:,:), ALLOCATABLE ::    PROJ
        COMPLEX, DIMENSION(:,:), ALLOCATABLE :: BI
        REAL, DIMENSION(4) ::                   ANGBUF
        DOUBLE PRECISION ::                     PI
        DIMENSION        WE(0:N2,N,N),WO(0:N2,N,N)
        COMPLEX          XE(0:N2,N,N),XO(0:N2,N,N)
        DIMENSION        ILIST(NANG)
        DIMENSION        DM(3,3,NANG),SM(3,3,MAXSYM),DMS(3,3)

        CHARACTER*80     FINPIC,FINPAT
        COMMON  /F_SPEC/ FINPAT,NLET,FINPIC

        PARAMETER (LTAB=5000)
        COMMON  /TABS/  LN2,FLTB,TABI(0:LTAB)

        DATA  INPROJ/99/

        LN   = 5
        LN2  = LN/2
        PI   = 4.0D0*DATAN(1.0D0)
        SIG  = 3.0/PI
        SIG2 = SIG*SIG
C       SIGMA IN REAL SPACE
        SIR  = REAL(N)/(2.0*PI*SIG)

        TNR  = DSQRT(2.0D0*PI)*SIG
C       GENERATE TABLE WITH INTERPOLANTS
        FLTB = REAL(LTAB)/REAL(LN2+1)

c$omp   parallel do private(i)
        DO  I=0,LTAB
           TABI(I) = EXP(-0.5*((REAL(I)/FLTB)**2)/SIG2)/TNR
        ENDDO

c$omp   parallel do private(i,j,k)
        DO K=1,N
           DO J=1,N
              DO I=0,N2
                 XE(I,J,K)=CMPLX(0.0,0.0)
                 WE(I,J,K)=0.0
                 XO(I,J,K)=CMPLX(0.0,0.0)
                 WO(I,J,K)=0.0
              ENDDO
           ENDDO
        ENDDO

        ALLOCATE (PROJ(NS,NS),BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, PROJ & BI',IER)
           RETURN
        ENDIF

        DO K=1,NANG
C          print  *,' Projection #',K

C          OPEN DESIRED FILE
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

           MAXIM = 0
           CALL OPFILE(.FALSE.,FINPIC,INPROJ,'O',IFORM,NSAM,NROW,NSL,
     &                   MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 999

           DO  J=1,NS
              CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
           ENDDO
           IF (.NOT. ANGINDOC) THEN
C             GET ANGLES FROM HEADER
              ANGBUF(1) = ILIST(K)
              CALL LUNGETVALS(INPROJ,IAPLOC+1,3,ANGBUF(2),IRTFLG)
              CALL BUILDM(ILIST,DM,1,ANGBUF,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 999
           ENDIF
           CLOSE(INPROJ)

           CALL PADD2(PROJ,NS,BI,LSD,N)
           INV=+1
           CALL FMRS_2(BI,N,N,INV)
c$omp      parallel do private(i,j)
           DO J=1,N
              DO I=0,N2
                 BI(I,J)=BI(I,J)*(-1)**(I+J+1)
              ENDDO
           ENDDO

           DO ISYM=1,MAXSYM
              IF (MAXSYM.GT.1)  THEN
C                SYMMETRIES, MULTIPLY MATRICES
                 DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
              ELSE
                 DMS=DM(:,:,K)
              ENDIF
              IF (MOD(K,2).EQ.0)  THEN
c$omp            parallel do private(j),shared(N,N2,XE,WE,BI,DMS)
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
                 ENDDO
              ELSE
c$omp            parallel do private(j),shared(N,N2,XO,WO,BI,DMS)
                 DO  J=-N2+1,N2
                    CALL  ONELINE(J,N,N2,XO,WO,BI,DMS)
                 ENDDO
              ENDIF
C          END OF SYMMETRIES LOOP
           ENDDO

C       END OF PROJECTIONS LOOP
        ENDDO

C       SYMMETRIZE BOTH VOLUMES
c$omp   parallel sections
c$omp   section
        CALL  SYMPLANE0(XE,WE,N2,N)
c$omp   section
        CALL  SYMPLANE0(XO,WO,N2,N)
c$omp   end parallel sections
        IRTFLG = 0

999     IF (ALLOCATED(PROJ)) DEALLOCATE (PROJ)
        IF (ALLOCATED(BI))   DEALLOCATE (BI)

        END

C       ----------------SYMPLANE0 ---------------------------------------
 
        SUBROUTINE  SYMPLANE0(X,W,N2,N)

        DIMENSION  W(0:N2,N,N)
        COMPLEX  X(0:N2,N,N)

C       SYMMETRIZE PLANE 0
        DO  IZA=2,N2
           DO  IYA=2,N2
              X(0,IYA,IZA)=X(0,IYA,IZA)+CONJG(X(0,N-IYA+2,N-IZA+2))
              W(0,IYA,IZA)=W(0,IYA,IZA)+W(0,N-IYA+2,N-IZA+2)
              X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
              W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
              X(0,N-IYA+2,IZA)=X(0,N-IYA+2,IZA)+CONJG(X(0,IYA,N-IZA+2))
              W(0,N-IYA+2,IZA)=W(0,N-IYA+2,IZA)+W(0,IYA,N-IZA+2)
              X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
              W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
           ENDDO
        ENDDO

        DO  IYA=2,N2
           X(0,IYA,1)=X(0,IYA,1)+CONJG(X(0,N-IYA+2,1))
           W(0,IYA,1)=W(0,IYA,1)+W(0,N-IYA+2,1)
           X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
           W(0,N-IYA+2,1)=W(0,IYA,1)
        ENDDO

        DO  IZA=2,N2
           X(0,1,IZA)=X(0,1,IZA)+CONJG(X(0,1,N-IZA+2))
           W(0,1,IZA)=W(0,1,IZA)+W(0,1,N-IZA+2)
           X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
           W(0,1,N-IZA+2)=W(0,1,IZA)
        ENDDO

        END

C----------------ADDADA ---------------------------------------

        SUBROUTINE  ADDADA(X,Y,N)
        DIMENSION  X(N),Y(N)
c$omp   parallel do private(k)
        DO  K=1,N
           X(K)=X(K)+Y(K)
        ENDDO
        END

C----------------BUILDM ---------------------------------------

       SUBROUTINE BUILDM(ILIST,DM,NANG,ANGBUF,IRTFLG)

C      BULID ROTATION MATRICES FROM THREE EULERIAN ANGLES

        INCLUDE 'CMBLOCK.INC' 

        DOUBLE PRECISION :: CPHI,SPHI,CTHE,STHE,CPSI,SPSI
        DOUBLE PRECISION :: QUADPI,DGR_TO_RAD
        PARAMETER  (QUADPI = 3.141592653589793238462643383279502884197)
        PARAMETER  (DGR_TO_RAD = (QUADPI/180))
        DIMENSION  DM(9,NANG),ILIST(NANG)
        DIMENSION  ANGBUF(4,NANG)

         DO K=1,NANG

C          READ ANGLES FROM THE DOCUMENT FILE.
C          ORDER IN THE DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES 
C          ARE IN DEGREES! IN ANG ARRAY IT IS OTHER WAY AROUND

           ITMP   = ILIST(K)
           IKEY   = ANGBUF(1,ITMP)

           IF (IKEY .NE. ITMP) THEN
C             MISSING KEY
              CALL ERRT(102,'MISSING ANGLE FOR IMAGE',ITMP)
              IRTFLG = 1
              RETURN
           ENDIF

           CPHI=DCOS(DBLE(ANGBUF(4,ITMP))*DGR_TO_RAD)
           SPHI=DSIN(DBLE(ANGBUF(4,ITMP))*DGR_TO_RAD)
           CTHE=DCOS(DBLE(ANGBUF(3,ITMP))*DGR_TO_RAD)
           STHE=DSIN(DBLE(ANGBUF(3,ITMP))*DGR_TO_RAD)
           CPSI=DCOS(DBLE(ANGBUF(2,ITMP))*DGR_TO_RAD)
           SPSI=DSIN(DBLE(ANGBUF(2,ITMP))*DGR_TO_RAD)

           DM(1,K)=CPHI*CTHE*CPSI-SPHI*SPSI
           DM(2,K)=SPHI*CTHE*CPSI+CPHI*SPSI
           DM(3,K)=-STHE*CPSI
           DM(4,K)=-CPHI*CTHE*SPSI-SPHI*CPSI
           DM(5,K)=-SPHI*CTHE*SPSI+CPHI*CPSI
           DM(6,K)=STHE*SPSI
           DM(7,K)=STHE*CPHI
           DM(8,K)=STHE*SPHI
           DM(9,K)=CTHE
           IF (VERBOSE) THEN
              WRITE(NOUT,333)  K,(ANGBUF(J,ITMP),J=2,4)
333           FORMAT(' PROJECTION #',I7,
     &               '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
           ENDIF
         ENDDO

        IRTFLG = 0
        END

C       ----------------BUILDS ---------------------------------------

        SUBROUTINE  BUILDS(DS,NANG,ANGSYM,IRTFLG)

C       BULID ROTATION MATRICES FROM THREE EULERIAN ANGLES
C       DISREGARD KEYS.

        INCLUDE    'CMBLOCK.INC' 

        DOUBLE PRECISION  CPHI,SPHI,CTHE,STHE,CPSI,SPSI
        DOUBLE PRECISION  QUADPI,DGR_TO_RAD
        PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
        PARAMETER (DGR_TO_RAD = (QUADPI/180))
        DIMENSION   DS(9,NANG),ANGSYM(4,NANG)

         DO ITMP=1,NANG

C          READ ANGLES FROM THE DOCUMENT FILE.
C          ORDER IN THE DOCUMENT FILE IS PSI, THETA, PHI AND ANGLES 
C          ARE IN DEGREES! IN ANG ARRAY IT IS OTHER WAY AROUND

           IKEY   = ANGSYM(1,ITMP)

           IF (IKEY .NE. ITMP) THEN
C             MISSING KEY
              CALL ERRT(102,'MISSING SYMMETRY',ITMP)
              IRTFLG = 1
              RETURN
           ENDIF

           CPHI=DCOS(DBLE(ANGSYM(4,ITMP))*DGR_TO_RAD)
           SPHI=DSIN(DBLE(ANGSYM(4,ITMP))*DGR_TO_RAD)
           CTHE=DCOS(DBLE(ANGSYM(3,ITMP))*DGR_TO_RAD)
           STHE=DSIN(DBLE(ANGSYM(3,ITMP))*DGR_TO_RAD)
           CPSI=DCOS(DBLE(ANGSYM(2,ITMP))*DGR_TO_RAD)
           SPSI=DSIN(DBLE(ANGSYM(2,ITMP))*DGR_TO_RAD)

           DS(1,ITMP)=CPHI*CTHE*CPSI-SPHI*SPSI
           DS(2,ITMP)=SPHI*CTHE*CPSI+CPHI*SPSI
           DS(3,ITMP)=-STHE*CPSI
           DS(4,ITMP)=-CPHI*CTHE*SPSI-SPHI*CPSI
           DS(5,ITMP)=-SPHI*CTHE*SPSI+CPHI*CPSI
           DS(6,ITMP)=STHE*SPSI
           DS(7,ITMP)=STHE*CPHI
           DS(8,ITMP)=STHE*SPHI
           DS(9,ITMP)=CTHE

           WRITE(NOUT,333)  ITMP,(ANGSYM(J,ITMP),J=2,4)
333        FORMAT(' SYMMETRY #',I6,
     &         '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
        ENDDO

        IRTFLG = 0

        END
#endif
@


1.27
log
@*** empty log message ***
@
text
@d174 3
a176 2
        CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) THEN
d181 2
a182 1
       CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3-D',ITRFLG)
@


1.26
log
@New version with Bessel functions and symmetrization
@
text
@d1 1
a1 1
#ifdef 1
d1045 1
a1045 1
	CALL  RJBESL(X,ALPHAT,NB,1,OUT,NCALC)
@


1.25
log
@opfile 'u' not 'n'
@
text
@d1 522
d524 1733
d2772 1
a2772 1

@


1.24
log
@iaploc used
@
text
@d4 3
a6 3
C  WIW32D.F
C                                                    01/10/00
C                        ANGLES IN HEADER JULY 01 ARDEAN LEITH
d85 1
a85 1
        CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAM,NROW,NSL,
d125 1
a125 1
        ALLOCATE (XE(0:N2/2,N2,N2),WE(0:N2/2,N2,N2),WO(0:N2/2,N2,N2),
d132 1
a132 2
        CALL  WIW32DQ
     &      (NSAM,XE,WE,XO,WO,
d146 1
a146 1
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'N',LSD,N2,N2,
d157 1
a157 1
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'N',LSDD2,N2,N2,
d168 1
a168 1
        CALL OPFIL(.FALSE.,FINPAT,IOPIC,'N',NSAM,NSAM,NSAM,
d175 1
a175 1
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'O',LSD,N2,N2,
d182 1
a182 1
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'O',LSDD2,N2,N2,
d196 1
a196 1
        CALL OPFIL(.FALSE.,FINPIC,IOPIC,'N',NSAM,NSAM,NSAM,
d207 1
a207 1
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'N',NSAM,NSAM,NSAM,
d294 1
a294 1
           CALL OPFIL(.FALSE.,FINPIC,INPROJ,'O',NSAM,NROW,NSL,
@


1.23
log
@angles in header capable
@
text
@d15 1
a15 1
C *********************************************************************C **********************************************************************
d232 2
d305 1
a305 1
              CALL LUNGETVALS(INPROJ,101,3,ANGBUF(2),IRTFLG)
@


1.22
log
@cosmetic & I4 --> I7 for projection number
@
text
@d6 2
a7 7
C **********************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
d9 7
a20 1
C        1         2         3         4         5         6         7
d37 2
a41 1
        CHARACTER*1     NULL
d44 2
a45 1
        NULL = CHAR(0)
d56 2
a57 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(ILIST)
           RETURN
        ENDIF
d66 3
a68 2
        MAXXT = 4
        MAXYT = MAXNUM
d71 1
a71 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ILIST)
           RETURN
        ENDIF
d74 2
a75 2
        MAXXS=0
        MAXSYM=0
d78 1
a78 1
        IF(IRTFLG.NE.0)  MAXSYM=1
d82 1
a82 5
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ILIST)
           DEALLOCATE (ANGBUF)
           RETURN
        ENDIF
d87 1
a87 5
        IF (IRTFLG .NE. 0) THEN 
           DEALLOCATE (ILIST)
           DEALLOCATE (ANGBUF)
           RETURN
        ENDIF
d90 16
a105 17
        N2=2*NSAM
        LSD=N2+2-MOD(N2,2)
        NMAT=LSD*N2*N2

        ALLOCATE(DM(9,NANG), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, DM',IER)
           DEALLOCATE (ILIST)
        ENDIF

        CALL  BUILDM(ILIST,DM,NANG,ANGBUF(1,1),IRTFLG)

        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ILIST)
           DEALLOCATE (ANGBUF)
           DEALLOCATE (DM)
           RETURN
a106 1
        DEALLOCATE(ANGBUF)
d108 1
a108 1
        IF(MAXSYM.GT.1)  THEN
d111 2
a112 3
              CALL ERRT(46,'BP 3F, SM',IER)
              DEALLOCATE (ILIST,DM)
              RETURN
d114 2
a115 2
           CALL  BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
           DEALLOCATE(ANGSYM)
d120 2
a121 2
               CALL ERRT(46,'BP 3F, SM-2nd',IER)
               DEALLOCATE (ILIST,DM)
d125 2
a126 22
        ALLOCATE (XE(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, XE',IER)
           DEALLOCATE(ILIST,DM,SM)
           RETURN
        ENDIF

        ALLOCATE (WE(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, WE',IER)
           DEALLOCATE(ILIST,DM,SM,XE)
           RETURN
        ENDIF

        ALLOCATE (XO(0:N2/2,N2,N2), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 32F, XO',IER)
           DEALLOCATE(ILIST,DM,SM,XE,WE)
           RETURN
        ENDIF

        ALLOCATE (WO(0:N2/2,N2,N2), STAT=IRTFLG)
d128 2
a129 3
           CALL ERRT(46,'BP 32F, WO',IER)
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO)
           RETURN
d134 2
a135 1
     &      LSD,N2,N2/2,ILIST,DM,NANG,SM,MAXSYM,SIR)
d137 2
a138 5
        CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',ITRFLG) 
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d140 2
a141 5
        CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d143 2
a144 5
       CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
d149 1
a149 5
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
a150 1
 
a151 1

d156 1
a156 1
        LSDD2=LSD/2
d160 1
a160 5
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
a161 1

a162 1

d170 2
a171 7
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF

a173 1

a175 1
        IFORM = 3
d177 2
a178 8
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF


a180 3
	


a182 1
        IFORM = 3
d184 2
a185 6
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
a186 1

d188 1
d190 5
a194 6
        CLOSE(IOPIC)
C       Add E+O
        CALL  ADDADA(XE,XO,NMAT)
        CALL  ADDADA(WE,WO,NMAT/2)
        CALL  NRMW2(XE,WE,N2/2,N2)
        CALL  WIND2(XE,XE,NSAM,LSD,N2,SIR)
d196 1
d198 2
a199 6
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF
a201 1

d204 2
a205 2
        CALL  NRMW2(XO,WO,N2/2,N2)
        CALL  WIND2(XO,XO,NSAM,LSD,N2,SIR)
d207 1
d209 2
a210 7
     &             MAXIM,'DUMMY',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(4,'BP 32F',NE)
           DEALLOCATE(ILIST,DM,SM,XE,WE,XO,WO)
           RETURN
        ENDIF

a212 1

d215 10
a224 7
        DEALLOCATE (ILIST)
        DEALLOCATE(DM)
        DEALLOCATE(SM)
        DEALLOCATE(XE)
        DEALLOCATE(WE)
        DEALLOCATE(XO)
        DEALLOCATE(WO)
d229 2
a230 2
        SUBROUTINE  WIW32DQ(NS,XE,WE,XO,WO, LSD,N,N2, 
     &                      ILIST,DM,NANG,SM,MAXSYM,SIR)
d232 2
a233 2

        REAL, DIMENSION(:,:), ALLOCATABLE :: PROJ
d235 2
d241 1
d244 1
a244 1
        DOUBLE PRECISION PI
d250 5
a254 5
        LN=5
        LN2=LN/2
        PI=4.0D0*DATAN(1.0D0)
        SIG=3.0/PI
        SIG2=SIG*SIG
d256 1
a256 1
        SIR=REAL(N)/(2.0*PI*SIG)
d258 1
a258 1
        TNR=DSQRT(2.0D0*PI)*SIG
d260 1
a260 1
        FLTB=REAL(LTAB)/REAL(LN2+1)
d262 1
a262 1
c$omp parallel do private(i)
d264 1
a264 1
           TABI(I)=EXP(-0.5*((REAL(I)/FLTB)**2)/SIG2)/TNR
d267 4
a270 4
c$omp parallel do private(i,j,k)
        DO  K=1,N
           DO  J=1,N
              DO  I=0,N2
d279 1
a279 1
        ALLOCATE (PROJ(NS,NS), STAT=IRTFLG)
d281 1
a281 1
           CALL ERRT(46,'BP 32F, PROJ',IER)
d285 1
a285 9

        ALLOCATE (BI(0:N2,N), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'BP 3F, BI',IER)
           DEALLOCATE (PROJ)
        ENDIF


        DO    K=1,NANG
d290 1
a290 1
           IF (IRTFLG .NE. 0) RETURN
d294 2
a295 2
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d300 7
d312 3
a314 3
c$omp parallel do private(i,j)
           DO  J=1,N
              DO  I=0,N2
d319 3
a321 3
           DO  ISYM=1,MAXSYM
              IF(MAXSYM.GT.1)  THEN
C  symmetries, multiply matrices
d327 1
a327 1
c$omp parallel do private(j),shared(N,N2,XE,WE,BI,DMS)
d332 1
a332 1
c$omp parallel do private(j),shared(N,N2,XO,WO,BI,DMS)
d337 1
a337 1
C   END OF SYMMETRIES LOOP
d340 1
a340 1
C          END OF PROJECTIONS LOOP
d344 2
a345 2
c$omp parallel sections
c$omp section
d347 1
a347 1
c$omp section
d349 2
a350 1
c$omp end parallel sections
d352 3
a354 2
        DEALLOCATE (PROJ)
        DEALLOCATE (BI)
d398 1
a398 1
c$omp parallel do private(k)
d406 1
a406 1
       SUBROUTINE  BUILDM(ILIST,DM,NANG,ANGBUF,IRTFLG)
d412 6
a417 6
        DOUBLE PRECISION  CPHI,SPHI,CTHE,STHE,CPSI,SPSI
        DOUBLE PRECISION  QUADPI,DGR_TO_RAD
        PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
        PARAMETER (DGR_TO_RAD = (QUADPI/180))
        DIMENSION   DM(9,NANG),ILIST(NANG)
        DIMENSION   ANGBUF(4,NANG)
d419 1
a419 1
         DO    K=1,NANG
d430 1
a430 2
              WRITE(NOUT,*) '*** MISSING ANGLE FOR IMAGE: ',ITMP
              CALL ERRT(100,'  ',NE)
d476 1
a476 1
         DO    ITMP=1,NANG
d486 1
a486 2
              WRITE(NOUT,*) '*** MISSING SYMMETRY: ',ITMP
              CALL ERRT(100,'  ',NE)
d490 1
a490 1
C
d497 1
a497 1
C
d507 1
a507 1
C
d511 2
a512 2
         ENDDO
C
d514 1
@


1.21
log
@*** empty log message ***
@
text
@d24 1
a24 1
C
d27 1
d31 3
a33 3
        REAL, DIMENSION(:,:), POINTER :: ANGBUF, ANGSYM
        REAL, DIMENSION(:,:), ALLOCATABLE :: DM,SM 
        INTEGER, ALLOCATABLE, DIMENSION(:) :: ILIST
d35 1
a35 1
        REAL, ALLOCATABLE, DIMENSION(:,:,:) :: WE,WO
d484 2
a485 1
C  Bulid rotation matrices from three Eulerian angles
d487 1
a487 1
        INCLUDE    'CMBLOCK.INC' 
d529 5
a533 4

           WRITE(NOUT,333)  K,(ANGBUF(J,ITMP),J=2,4)
333        FORMAT(' PROJECTION #',I6,
     &         '; PSI=',F6.1,' THETA=',F6.1,' PHI=',F6.1)
d542 3
a544 2
C  Bulid rotation matrices from three Eulerian angles
C  disregard keys.
@


1.20
log
@adapted for dynamical memory allocation
@
text
@d294 1
a294 1
        CALL WRITEV(IOPIC,XE,NSAM,NSAM,NSAM,NSAM,NSAM)
@


1.19
log
@*** empty log message ***
@
text
@d17 3
d23 1
a23 1
	SUBROUTINE WIW32D(MAXMEM)
d26 1
a26 8

	PARAMETER       (NILMAX=99998)
	CHARACTER*80    FINPIC,FINFO,ANGDOC,FINPAT
        COMMON /F_SPEC/ FINPAT,NLET,FINPIC
	CHARACTER*1     NULL
	COMMON          BUF(1024),ILIST(NILMAX),BAF(1)
        LOGICAL         RUNTIME

a27 2
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q
d31 8
a38 32
        REAL, DIMENSION(:,:), ALLOCATABLE :: DM,SM
	DATA  IOPIC/98/,INPIC/99/
	NULL = CHAR(0)

C       N - LINEAR DIMENSION OF PROJECTIONS AND RESTORED CUBE
C       NANG - NUMBER OF ANGLES (PROJECTIONS)

 	CALL  FILERD(FINPAT,NLET,NULL,
     &	   'ENTER TEMPLATE FOR 2-D IMAGE NAME',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

 	CALL  FILERD(FINPIC,NLETI,NULL,'SELECTION DOC',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

	K      = 0
	K2     = 1
	NANG   = 0
        MAXNUM = 0 
778	LERR   = -1
	IF (NANG .EQ. NILMAX)  THEN
           WRITE(NOUT,*) '***TOO MANY IMAGES, LIST TRUNCATED'
           GOTO 779
	ENDIF
	KP1 = K + 1
	CALL UNSAV(FINPIC,K,INPIC,KP1,BUF,1,LERR,K2)
	IF (LERR .EQ. 0) THEN
	   NANG        = NANG+1
	   ILIST(NANG) = BUF(1)
	   IF (ILIST(NANG) .GT. MAXNUM) MAXNUM = ILIST(NANG)
	   K           = K+1
	   GOTO  778
	ENDIF
d40 18
a57 1
779	CLOSE(INPIC)
d60 2
a61 2
	WRITE(NOUT,2001) NANG
2001	FORMAT(' NUMBER OF IMAGES =',I5)
d68 12
a79 8
        IF (IRTFLG .NE. 0) GOTO 9998
C       Retrieve array with symmetries data in it
	MAXXS=0
	MAXSYM=0
	CALL GETDOCDAT('SYMMETRIES DOC',.TRUE.,ANGDOC,77,.TRUE.,MAXXS,
     &	                 MAXSYM,ANGSYM,IRTFLG)
	IF(IRTFLG.NE.0)  MAXSYM=1
C
d81 6
a86 2
 	CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9998
d91 36
a126 2
        IF (IRTFLG .NE. 0) GOTO 9998
	CLOSE(INPIC)
d128 7
a134 22
	N2=2*NSAM
	LSD=N2+2-MOD(N2,2)
	NMAT=LSD*N2*N2

	K_PROJ=1
	K_X=IPALIGN64(K_PROJ+NSAM*NSAM)
	K_CBE=IPALIGN64(K_X+LSD*N2)
	K_CWE=IPALIGN64(K_CBE+NMAT)
	K_CBO=IPALIGN64(K_CWE+NMAT/2)
	K_CWO=IPALIGN64(K_CBO+NMAT)
	MEMTOT=IPALIGN64(K_CWO+NMAT/2)

	IRTFLG = -9
        CALL CHKMEM(MEMTOT,BAF,MAXMEM,RUNTIME,IPQ,IRTFLG)
	IF (IRTFLG .NE. 0)  GOTO 9999
#ifdef SP_F90
        Q = > IPQ
#endif

        WRITE(NOUT,1001)  MEMTOT
1001    FORMAT(/,' 3-D FOURIER INTERPOLATION RECONSTRUCTION',/,
     &           ' YOU HAVE RESERVED MEMORY: ',I9,/)
d136 27
a162 11
	ALLOCATE(DM(9,NANG))
        CALL  BUILDM(ILIST,DM,NANG,ANGBUF(1,1),IRTFLG)
	DEALLOCATE(ANGBUF)
        IF (IRTFLG .NE. 0) GOTO 9998
	IF(MAXSYM.GT.1)  THEN
	 ALLOCATE(SM(9,MAXSYM))
         CALL  BUILDS(SM,MAXSYM,ANGSYM(1,1),IRTFLG)
	 DEALLOCATE(ANGSYM)
	ELSE
	 ALLOCATE(SM(1,1))
	ENDIF
d165 1
a165 2
     &	   (Q(K_PROJ),NSAM,
     &      Q(K_X),Q(K_CBE),Q(K_CWE),Q(K_CBO),Q(K_CWO),
d168 17
a184 5
	CALL  FILERD(FINPIC,NLETI,NULL,'RECONSTRUCTED 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) GOTO 9998

	CALL  FILERD(FINPAT,NLETI,NULL,'RECONSTRUCTED EVEN 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) GOTO 9998
a185 3
	CALL  FILERD(FINFO,NLETI,NULL,'RECONSTRUCTED ODD 3-D',ITRFLG)
        IF (IRTFLG .NE. 0) GOTO 9998

d189 8
a196 1
        IF (IRTFLG .NE. 0) GOTO 9998
d198 1
a198 5
        DO  K=1,N2*N2
	   MI = (K-1)*LSD
	   CALL WRTLIN(IOPIC,Q(K_CBE+MI),LSD,K)
        ENDDO
	CLOSE(IOPIC)
d202 1
a202 1
	LSDD2=LSD/2
d206 6
a211 1
        IF (IRTFLG .NE. 0) GOTO 9998
d213 3
a215 5
        DO   K=1,N2*N2
	   MI =(K-1)*LSD/2
	   CALL WRTLIN(IOPIC,Q(K_CWE+MI),LSD/2,K)
        ENDDO
	CLOSE(IOPIC)
d217 2
a218 2
	CALL NRMW2(Q(K_CBE),Q(K_CWE),N2/2,N2)
	CALL WIND2(Q(K_CBE),Q(K_CBE),NSAM,LSD,N2,SIR)
d223 6
a228 1
        IF (IRTFLG .NE. 0) GOTO 9998
d230 3
a232 5
	DO   K=1,NSAM*NSAM
	   MI = (K-1)*NSAM
	   CALL WRTLIN(IOPIC,Q(K_CBE+MI),NSAM,K)
        ENDDO
	CLOSE(IOPIC)
d237 6
a242 1
        IF (IRTFLG .NE. 0) GOTO 9998
d244 6
a249 5
        DO K=1,N2*N2
           MI = (K-1)*LSD
           CALL  REDLIN(IOPIC,Q(K_CBE+MI),LSD,K)
        ENDDO
	CLOSE(IOPIC)
d254 8
a261 1
        IF (IRTFLG .NE. 0) GOTO 9998
d263 1
a263 5
        DO K=1,N2*N2
           MI=(K-1)*LSD/2
           CALL REDLIN(IOPIC,Q(K_CWE+MI),LSD/2,K)
        ENDDO
	CLOSE(IOPIC)
d265 4
a268 4
	CALL  ADDADA(Q(K_CBE),Q(K_CBO),NMAT)
	CALL  ADDADA(Q(K_CWE),Q(K_CWO),NMAT/2)
	CALL  NRMW2(Q(K_CBE),Q(K_CWE),N2/2,N2)
	CALL  WIND2(Q(K_CBE),Q(K_CBE),NSAM,LSD,N2,SIR)
d272 7
a278 1
        IF (IRTFLG .NE. 0) GOTO 9998
d280 1
a280 5
        DO   K=1,NSAM*NSAM
	   MI = (K-1)*NSAM
	   CALL WRTLIN(IOPIC,Q(K_CBE+MI),NSAM,K)
        ENDDO
	CLOSE(IOPIC)
d282 2
a283 2
	CALL  NRMW2(Q(K_CBO),Q(K_CWO),N2/2,N2)
	CALL  WIND2(Q(K_CBO),Q(K_CBO),NSAM,LSD,N2,SIR)
d287 19
a305 12
        IF (IRTFLG .NE. 0) GOTO 9998

        DO K=1,NSAM*NSAM
           MI = (K-1)*NSAM
           CALL WRTLIN(IOPIC,Q(K_CBO+MI),NSAM,K)
        ENDDO
	CLOSE(IOPIC)
C
9998    DEALLOCATE(DM)
	IF (RUNTIME) CALL DEALLOCMEM_R(IPQ,IRTFLG)
9999    DEALLOCATE(SM)
	END
d309 1
a309 1
        SUBROUTINE  WIW32DQ(PROJ,NS, BI,XE,WE,XO,WO, LSD,N,N2, 
d312 5
a316 2
        DIMENSION        PROJ(NS,NS),WE(0:N2,N,N),WO(0:N2,N,N)
	COMPLEX          BI(0:N2,N),XE(0:N2,N,N),XO(0:N2,N,N)
d321 3
a323 3
	DOUBLE PRECISION PI
	PARAMETER (LTAB=5000)
	COMMON  /TABS/  LN2,FLTB,TABI(0:LTAB)
d327 5
a331 5
	LN=5
	LN2=LN/2
	PI=4.0D0*DATAN(1.0D0)
	SIG=3.0/PI
	SIG2=SIG*SIG
d333 1
a333 1
	SIR=REAL(N)/(2.0*PI*SIG)
d335 1
a335 1
	TNR=DSQRT(2.0D0*PI)*SIG
d337 1
a337 1
	FLTB=REAL(LTAB)/REAL(LN2+1)
d340 1
a340 1
	DO  I=0,LTAB
d342 2
a343 2
	ENDDO
c
d349 1
a349 1
	         WE(I,J,K)=0.0
d351 19
a369 5
	         WO(I,J,K)=0.0
	      ENDDO
	   ENDDO
	ENDDO
C
d371 1
a371 1
C	   print  *,' Projection #',K
d374 1
a374 1
	   CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K),IRTFLG)
d384 1
a384 1
	   ENDDO
d386 4
a389 4
C
	   CALL PADD2(PROJ,NS,BI,LSD,N)
	   INV=+1
	   CALL FMRS_2(BI,N,N,INV)
d392 7
a398 7
	      DO  I=0,N2
	         BI(I,J)=BI(I,J)*(-1)**(I+J+1)
	      ENDDO
	   ENDDO
C
	   DO  ISYM=1,MAXSYM
	    IF(MAXSYM.GT.1)  THEN
d400 5
a404 5
	     DMS=MATMUL(SM(:,:,ISYM),DM(:,:,K))
	    ELSE
	     DMS=DM(:,:,K)
	    ENDIF
	     IF (MOD(K,2).EQ.0)  THEN
d406 4
a409 4
	      DO  J=-N2+1,N2
	         CALL  ONELINE(J,N,N2,XE,WE,BI,DMS)
	      ENDDO
	     ELSE
d411 4
a414 4
	      DO  J=-N2+1,N2
	         CALL  ONELINE(J,N,N2,XO,WO,BI,DMS)
	      ENDDO
	     ENDIF
d416 2
a417 2
	    ENDDO
C
d426 1
a426 1
	CALL  SYMPLANE0(XO,WO,N2,N)
d428 3
d435 1
a435 1
	SUBROUTINE  SYMPLANE0(X,W,N2,N)
d438 1
a438 1
	COMPLEX  X(0:N2,N,N)
d441 2
a442 2
	DO  IZA=2,N2
	   DO  IYA=2,N2
d445 2
a446 2
	      X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
	      W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
d449 4
a452 4
	      X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
	      W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
	   ENDDO
	ENDDO
d454 1
a454 1
	DO  IYA=2,N2
d457 3
a459 3
	   X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
	   W(0,N-IYA+2,1)=W(0,IYA,1)
	ENDDO
d461 1
a461 1
	DO  IZA=2,N2
d464 10
a473 8
	   X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
	   W(0,1,N-IZA+2)=W(0,1,IZA)
	ENDDO
C
	END
C
	SUBROUTINE  ADDADA(X,Y,N)
	DIMENSION  X(N),Y(N)
d475 8
a482 6
	DO  K=1,N
	   X(K)=X(K)+Y(K)
	ENDDO
	END
C
	SUBROUTINE  BUILDM(ILIST,DM,NANG,ANGBUF,IRTFLG)
d488 3
a490 3
	DOUBLE PRECISION  QUADPI,DGR_TO_RAD
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
d506 1
a506 1
	      CALL ERRT(100,'  ',NE)
d510 1
a510 1
C
d517 1
a517 1
C
d527 1
a527 1
C
d531 2
a532 2
	 ENDDO
C
d535 4
a538 2
C
	SUBROUTINE  BUILDS(DS,NANG,ANGSYM,IRTFLG)
d545 3
a547 3
	DOUBLE PRECISION  QUADPI,DGR_TO_RAD
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
d561 1
a561 1
	      CALL ERRT(100,'  ',NE)
d586 1
a586 1
	 ENDDO
d590 1
@


1.18
log
@symmetries added
@
text
@d439 1
a439 1
           WRITE(NOUT,333)  K,(ANG(J,ITMP),J=2,4)
@


1.17
log
@getdocdat changed
@
text
@d5 1
a5 1
C                                                    11/07/98
d21 1
a21 1
C                                                    11/07/98
d36 2
a37 2
        REAL, DIMENSION(:,:), POINTER :: ANGBUF

d48 1
a48 1
 	CALL  FILERD(FINPIC,NLETi,NULL,'SELECTION DOC',IRTFLG)
d82 7
d103 1
a103 3
 	K_DM=1
	K_SS=IPALIGN64(K_DM+9*NANG)
	K_PROJ=IPALIGN64(K_SS+6*NANG)
d122 11
a132 2
        CALL  REANG(ILIST,Q(K_DM),Q(K_SS),NANG,ANGBUF(1,1),IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9998
d137 1
a137 1
     &      LSD,N2,N2/2,ILIST,Q(K_DM),NANG,NOUT,SIR)
d237 3
a239 2
9998    IF (RUNTIME) CALL DEALLOCMEM_R(IPQ,IRTFLG)
9999    DEALLOCATE(ANGBUF)
d245 1
a245 1
     &                      ILIST,DM,NANG,NOUT,SIR)
d249 2
a250 2
        DIMENSION        ILIST(NANG),DM(9,NANG)
        COMMON           BUF(1024)
d304 1
a304 1

d314 10
a323 3
c
	   IF (MOD(K,2).EQ.0)  THEN
c$omp parallel do private(j),shared(N,N2,XE,WE,BI,DM)
d325 1
a325 1
	         CALL  ONELINE(J,N,N2,XE,WE,BI,DM(1,K))
d327 2
a328 2
	   ELSE
c$omp parallel do private(j),shared(N,N2,XO,WO,BI,DM)
d330 1
a330 1
	         CALL  ONELINE(J,N,N2,XO,WO,BI,DM(1,K))
d332 4
a335 2
	   ENDIF

d392 107
@


1.16
log
@prinout removed
@
text
@a30 1
#ifdef SP_F90
d36 1
a36 9
        REAL, DIMENSION(:), POINTER :: IPANG
        REAL, DIMENSION(:), POINTER :: ANGBUF
#else
        DIMENSION       Q(1)
        POINTER         (IPQ,Q)
 
        DIMENSION       ANGBUF(1)
        POINTER         (IPANG,ANGBUF) 
#endif
d80 1
a80 1
     &                       MAXYT,IPANG,IRTFLG)
a81 4
#ifdef SP_F90
         ANGBUF = > IPANG
#endif

d117 1
a117 1
        CALL  REANG(ILIST,Q(K_DM),Q(K_SS),NANG,ANGBUF(1),IRTFLG)
d224 1
a224 1
9999    CALL DEALLOCMEM_R(IPANG,IRTFLG)
@


1.15
log
@bud in ADDADA argument fixed
@
text
@a206 1
	print  *,' read after 5'
@


1.14
log
@openmp fixed
,
@
text
@d207 1
a207 1

d210 1
a210 1
	CALL  ADDADA(Q(K_CWE),Q(K_CWO),NMAT)
a327 1

@


1.13
log
@OpenMP
@
text
@d331 6
a336 8
c$omp parallel do private(i)
        DO  I=1,2
           IF (I.EQ.1) THEN
              CALL  SYMPLANE0(XE,WE,N2,N)
           ELSE
	      CALL  SYMPLANE0(XO,WO,N2,N)
           ENDIF
        ENDDO
@


1.12
log
@f90
@
text
@d209 2
a210 8
c$doacross local(k)
	DO  K=0,NMAT-1
	   Q(K_CBE+K)=Q(K_CBE+K)+Q(K_CBO+K)
	ENDDO
c$doacross local(k)
	DO  K=0,NMAT/2-1
	   Q(K_CWE+K)=Q(K_CWE+K)+Q(K_CWO+K)
	ENDDO
d236 1
a236 1

a237 1

a238 2

        RETURN
a256 1
CNO_SAVE
d270 1
a270 1
c$doacross local(i)
d274 2
a275 2

c$doacross local(i,j,k)
d286 1
a286 1

d307 1
a307 1
c$doacross local(i,j)
d313 1
a313 1

d315 1
a315 1
c$doacross local(j),share(N,N2,XE,WE,BI,DM),mp_schedtype=simple
d320 1
a320 1
c$doacross local(j),share(N,N2,XO,WO,BI,DM),mp_schedtype=simple
d331 1
a331 1
c$doacross local(i)
a338 1

d375 9
a383 1

@


1.11
log
@bad reang call in f77
@
text
@a21 1
CNO_SAVE
d35 2
d38 1
d40 5
a44 4
        DIMENSION     Q(1)
        POINTER       (IPQ,Q) 
        DIMENSION     ANGBUF(1)
        POINTER       (IPANG,ANGBUF) 
d91 3
d122 3
d128 3
a130 7
     1           ' YOU HAVE RESERVED MEMORY: ',I9,/)
#ifdef SP_F90
        Q = >IPQ
        CALL  REANG(ILIST,Q(K_DM),Q(K_SS),NANG,IPANG,IRTFLG)
#else
        CALL  REANG(ILIST,Q(K_DM),Q(K_SS),NANG,ANGBUF,IRTFLG)
#endif
d243 1
a243 1
9998    IF (RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'BP 32F',IRTFLG)
d245 1
a245 2
9999    RUNTIME = .TRUE.
        CALL ALLOCIT(0,RUNTIME,IPANG,'WIW32D',IRTFLG)
@


1.10
log
@f90 & error recovery
@
text
@d122 3
a125 1
        CALL  REANG(ILIST,Q(K_DM),Q(K_SS),NANG,IPANG,IRTFLG)
@


1.9
log
@99998
@
text
@d87 1
a87 1
        IF (IRTFLG .NE. 0) RETURN
d90 2
a91 1
 	CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
d96 1
a96 1
        IF (IRTFLG .NE. 0) RETURN
d115 1
a115 1
	IF (IRTFLG .NE. 0)  RETURN
d123 2
a124 1
        CALL  REANG(ILIST,Q(K_DM),Q(K_SS),NANG,IPANG)
d132 1
a132 1
        IF (IRTFLG .NE. 0) GOTO 9999
d135 1
a135 1
        IF (IRTFLG .NE. 0) GOTO 9999
d138 1
a138 1
        IF (IRTFLG .NE. 0) GOTO 9999
d143 1
a143 1
        IF (IRTFLG .NE. 0) GOTO 9999
d157 1
a157 1
        IF (IRTFLG .NE. 0) GOTO 9999
d171 1
a171 1
        IF (IRTFLG .NE. 0) GOTO 9999
d182 1
a182 1
        IF (IRTFLG .NE. 0) GOTO 9999
d193 1
a193 1
        IF (IRTFLG .NE. 0) GOTO 9999
d215 1
a215 1
        IF (IRTFLG .NE. 0) GOTO 9999
d228 1
a228 1
        IF (IRTFLG .NE. 0) GOTO 9999
d236 3
a238 2
9999    IF (RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'BP 32F',IRTFLG)
        RUNTIME = .TRUE.
d241 1
@


1.8
log
@bad maxnum spelling
@
text
@d25 1
a25 1
	PARAMETER       (NILMAX=99999)
@


1.7
log
@I have no idea whether it is correct.
@
text
@d71 1
a71 1
	   IF (ILIST(NANG) .GT. MAXNUM) MAXMUM = ILIST(NANG)
@


1.6
log
@buffer 99999
@
text
@d151 1
a151 1

d153 1
a153 1
        CALL OPFIL(.FALSE.,FINFO,IOPIC,'N',LSD/2,N2,N2,
d167 1
a167 1
        CALL OPFIL(.FALSE.,FINPAT,IOPIC,'N',NSAM,NSAM,,NSAM,
d236 1
a236 1
        CALL ALLOCIT(0,RUNTIME,IPANG,'WIW3D',IRTFLG)
a237 1
        RETURN
a339 1
        RETURN
a376 1
        RETURN
@


1.5
log
@bad F_SPEC common
@
text
@d25 1
a25 1
	PARAMETER       (NILMAX=20000)
@


1.4
log
@bad maxyt value used
@
text
@a25 1
	COMMON /F_SPEC/ INPAT,NLET,FINPIC
d27 1
@


1.3
log
@used opfil, getdocdat, & cosmetic
@
text
@d57 6
a62 5
	K    = 0
	K2   = 1
	NANG = 0
778	LERR = -1
	IF (NANG.EQ.NILMAX)  THEN
d64 1
a64 1
           GOTO  779
d66 7
a72 6
	KP1 = K+1
	CALL  UNSAV(FINPIC,K,INPIC,KP1,BUF,1,LERR,K2)
	IF (LERR.EQ.0)  THEN
	   NANG=NANG+1
	   ILIST(NANG)=BUF(1)
	   K=K+1
d84 1
a84 1
        MAXYT = NANG
@


1.2
log
@OK.
@
text
@d1 19
d22 1
a22 1
	PARAMETER  (NILMAX=20000)
d24 8
a31 5
	COMMON /F_SPEC/  FINPAT,NLET,FINPIC
	CHARACTER*80  FINPIC,FINFO
	CHARACTER*80  FINPAT
	CHARACTER*1   NULL
	COMMON        DUMMY(80),BUF(1024),ILIST(NILMAX),BAF(1)
d36 1
d40 2
a42 1
        LOGICAL       RUNTIME
d45 1
a45 2
CNO_SAVE
	NULL=CHAR(0)
d47 2
a48 2
C       N - linear dimension of projections and restored cube
C       NANG - number of angles (projections)
a49 1
	IUNIT=NOUT
d52 2
d55 6
a60 4
	K=0
	K2=1
	NANG=0
778	LERR=-1
d62 1
a62 1
           WRITE(NOUT,*) '  TOO MANY IMAGES, LIST TRUNCATED'
d65 1
a65 1
	KP1=K+1
d75 2
d78 10
a87 6
2001	FORMAT('  NUMBER OF IMAGES =',i5)
C       NANG - total number of images
	CALL  FILERD(FINFO,NLET1,NULL,'ANGLES DOC',ITRFLG)
	FINFO=FINFO(1:NLET1)//'.'//DATEXC(1:3)
	OPEN(77,FILE=FINFO,STATUS='OLD')
C
d89 5
a93 5
 	CALL OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
 	IF (NF .NE. 2)  THEN
	   WRITE(NOUT,*) ' FILE NOT FOUND'
	   RETURN
	ENDIF
d95 1
a95 1
C
d99 1
a99 1
C
d110 1
a110 1
	IRTFLG=-9
d112 5
a116 4
	IF (IRTFLG.EQ.0)  THEN
	   WRITE(NOUT,1001)  MEMTOT
1001	   FORMAT(//'  3-D Fourier interpolation reconstruction',/,
     1              '   you have reserved ',I9,/)
d118 1
a118 1
         Q = >IPQ
d120 3
a122 2
	   CALL  REANG(ILIST,Q(K_DM),Q(K_SS),NANG,NOUT)
	   CALL  WIW32DQ
d124 3
a126 4
     &        Q(K_X),Q(K_CBE),Q(K_CWE),Q(K_CBO),Q(K_CWO),
     &         LSD,N2,N2/2,
     &		ILIST,Q(K_DM),NANG,NOUT,SIR)
C
d128 2
a129 1
	IF (IRTFLG.EQ.-1)  RETURN
d131 2
a132 1
	IF (IRTFLG.EQ.-1)  RETURN
d134 11
a144 12
	IF (IRTFLG.EQ.-1)  RETURN
C
C CBE and CBO (XE&XO) are LSDxN2xN2
C CWE and CWO (WE&WO) are (LSD/2)xN2xN2
C
	IFORM=3
 	CALL  OPENFB(BUF,FINPIC,IOPIC,LSD,N2,'N',NF,N2)
	IF (NF.NE.2)  RETURN
	   DO   K=1,N2*N2
	      MI=(K-1)*LSD
	      CALL  WRTLIN(IOPIC,Q(K_CBE+MI),LSD,K)
	   ENDDO
d146 13
a158 7
	IFORM=3
 	CALL  OPENFB(BUF,FINFO,IOPIC,LSD/2,N2,'N',NF,N2)
	IF (NF.NE.2)  RETURN
	   DO   K=1,N2*N2
	      MI=(K-1)*LSD/2
	      CALL  WRTLIN(IOPIC,Q(K_CWE+MI),LSD/2,K)
	   ENDDO
d160 13
a172 9
	CALL  NRMW2(Q(K_CBE),Q(K_CWE),N2/2,N2)
	CALL  WIND2(Q(K_CBE),Q(K_CBE),NSAM,LSD,N2,SIR)
	IFORM=3
 	CALL  OPENFB(BUF,FINPAT,IOPIC,NSAM,NSAM,'N',NF,NSAM)
	IF (NF.NE.2)  RETURN
	   DO   K=1,NSAM*NSAM
	      MI=(K-1)*NSAM
	      CALL  WRTLIN(IOPIC,Q(K_CBE+MI),NSAM,K)
	   ENDDO
d174 10
a183 6
C
 	CALL  OPENFB(BUF,FINPIC,IOPIC,LSD,N2,'O',NF,N2)
	   DO   K=1,N2*N2
	      MI=(K-1)*LSD
	      CALL  REDLIN(IOPIC,Q(K_CBE+MI),LSD,K)
	   ENDDO
d185 10
a194 5
 	CALL  OPENFB(BUF,FINFO,IOPIC,LSD/2,N2,'O',NF,N2)
	   DO   K=1,N2*N2
	      MI=(K-1)*LSD/2
	      CALL  REDLIN(IOPIC,Q(K_CWE+MI),LSD/2,K)
	   ENDDO
d196 2
a197 1
C  Add E+O
d200 1
a200 1
	Q(K_CBE+K)=Q(K_CBE+K)+Q(K_CBO+K)
d204 1
a204 1
	Q(K_CWE+K)=Q(K_CWE+K)+Q(K_CWO+K)
d208 9
a216 7
	IFORM=3
 	CALL  OPENFB(BUF,FINPIC,IOPIC,NSAM,NSAM,'N',NF,NSAM)
	IF (NF.NE.2)  RETURN
	   DO   K=1,NSAM*NSAM
	      MI=(K-1)*NSAM
	      CALL  WRTLIN(IOPIC,Q(K_CBE+MI),NSAM,K)
	   ENDDO
d218 1
d221 9
a229 7
	IFORM=3
 	CALL  OPENFB(BUF,FINFO,IOPIC,NSAM,NSAM,'N',NF,NSAM)
	IF (NF.NE.2)  RETURN
	   DO   K=1,NSAM*NSAM
	      MI=(K-1)*NSAM
	      CALL  WRTLIN(IOPIC,Q(K_CBO+MI),NSAM,K)
	   ENDDO
d231 6
a236 3
C
	ENDIF
        IF (RUNTIME)  CALL ALLOCIT(0,RUNTIME,IPQ,'BP 32F',IRTFLG)
d238 13
a250 13
C
        SUBROUTINE  WIW32DQ
     &  (PROJ,NS,
     &     BI,XE,WE,XO,WO,
     &	      LSD,N,N2,
     &          ILIST,DM,NANG,NOUT,SIR)
        DIMENSION  PROJ(NS,NS),WE(0:N2,N,N),WO(0:N2,N,N)
	COMPLEX  BI(0:N2,N),XE(0:N2,N,N),XO(0:N2,N,N)
        DIMENSION  ILIST(NANG),DM(9,NANG)
        COMMON     DUMMY(80),BUF(1024)
        CHARACTER*80  FINPIC,FINPAT
        COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
	DOUBLE PRECISION  PI
d253 1
a253 1
C
d256 1
a256 1
C
d262 1
a262 1
C sigma in real space
d264 1
a264 1
C
d266 1
a266 1
C Generate table with interpolants
d268 1
d271 1
a271 1
        TABI(I)=EXP(-0.5*((REAL(I)/FLTB)**2)/SIG2)/TNR
d273 1
a273 1
C
d275 9
a283 7
        DO    K=1,N
        DO    J=1,N
        DO    I=0,N2
        XE(I,J,K)=CMPLX(0.0,0.0)
	WE(I,J,K)=0.0
        XO(I,J,K)=CMPLX(0.0,0.0)
	WO(I,J,K)=0.0
d285 1
a285 3
	ENDDO
	ENDDO
c
d287 19
a305 16
C	print  *,' Projection #',K
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K),INTFLAG)
        CALL  OPENFB(BUF,FINPIC,INPROJ,NSAM,NROW,'O',NF,NSL)
        IF(NF.NE.2)  THEN
        write(nout,2032)   FINPIC
2032    FORMAT(' File not found ',A80,/,' Operation abandoned')
        RETURN
        ENDIF
        DO    J=1,NS
        CALL  REDLIN(INPROJ,PROJ(1,J),NS,J)
	ENDDO
        CLOSE(INPROJ)
C
	CALL PADD2(PROJ,NS,BI,LSD,N)
	INV=+1
	CALL FMRS_2(BI,N,N,INV)
d307 7
a313 7
        DO    J=1,N
	DO    I=0,N2
	BI(I,J)=BI(I,J)*(-1)**(I+J+1)
	ENDDO
	ENDDO
C
	IF(MOD(K,2).EQ.0)  THEN
d315 4
a318 4
	DO  J=-N2+1,N2
	CALL  ONELINE(J,N,N2,XE,WE,BI,DM(1,K))
	ENDDO
	ELSE
d320 10
a329 9
	DO  J=-N2+1,N2
	CALL  ONELINE(J,N,N2,XO,WO,BI,DM(1,K))
	ENDDO
	ENDIF
C
C  end of projections loop
	ENDDO
C
C  Symmetrize both volumes
d331 9
a339 7
	DO  I=1,2
	IF(I.EQ.1) THEN
	CALL  SYMPLANE0(XE,WE,N2,N)
	ELSE
	CALL  SYMPLANE0(XO,WO,N2,N)
	ENDIF
	ENDDO
d341 3
a343 1
C
d345 1
d348 2
a349 1
C Symmetrize plane 0
d351 10
a360 9
	DO  IYA=2,N2
        X(0,IYA,IZA)=X(0,IYA,IZA)+CONJG(X(0,N-IYA+2,N-IZA+2))
        W(0,IYA,IZA)=W(0,IYA,IZA)+W(0,N-IYA+2,N-IZA+2)
	X(0,N-IYA+2,N-IZA+2)=CONJG(X(0,IYA,IZA))
	W(0,N-IYA+2,N-IZA+2)=W(0,IYA,IZA)
        X(0,N-IYA+2,IZA)=X(0,N-IYA+2,IZA)+CONJG(X(0,IYA,N-IZA+2))
        W(0,N-IYA+2,IZA)=W(0,N-IYA+2,IZA)+W(0,IYA,N-IZA+2)
	X(0,IYA,N-IZA+2)=CONJG(X(0,N-IYA+2,IZA))
	W(0,IYA,N-IZA+2)=W(0,N-IYA+2,IZA)
d362 1
a362 1
	ENDDO
d364 4
a367 4
        X(0,IYA,1)=X(0,IYA,1)+CONJG(X(0,N-IYA+2,1))
        W(0,IYA,1)=W(0,IYA,1)+W(0,N-IYA+2,1)
	X(0,N-IYA+2,1)=CONJG(X(0,IYA,1))
	W(0,N-IYA+2,1)=W(0,IYA,1)
d369 1
d371 4
a374 4
        X(0,1,IZA)=X(0,1,IZA)+CONJG(X(0,1,N-IZA+2))
        W(0,1,IZA)=W(0,1,IZA)+W(0,1,N-IZA+2)
	X(0,1,N-IZA+2)=CONJG(X(0,1,IZA))
	W(0,1,N-IZA+2)=W(0,1,IZA)
d376 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
	SUBROUTINE WIW3D(MAXMEM)
d105 1
a105 1
 	CALL  OPENFB(BUF,FINPIC,IOPIC,LSD,N2,'UNKNOWN',NF,N2)
d113 1
a113 1
 	CALL  OPENFB(BUF,FINFO,IOPIC,LSD/2,N2,'UNKNOWN',NF,N2)
d120 1
a120 1
	CALL  NRMW2(Q(K_CBE),Q(K_CWE),LSD/2,N2)
d123 1
a123 1
 	CALL  OPENFB(BUF,FINPAT,IOPIC,LSD,N2,'UNKNOWN',NF,N2)
d131 1
a131 1
 	CALL  OPENFB(BUF,FINPIC,IOPIC,LSD,N2,'UNKNOWN',NF,N2)
d137 1
a137 1
 	CALL  OPENFB(BUF,FINFO,IOPIC,LSD/2,N2,'UNKNOWN',NF,N2)
d145 1
a145 1
	DO  K=0,LSD*N2*N2-1
d149 1
a149 1
	DO  K=0,(LSD/2)*N2*N2-1
d152 1
a152 1
	CALL  NRMW2(Q(K_CBE),Q(K_CWE),LSD/2,N2)
d155 1
a155 1
 	CALL  OPENFB(BUF,FINPIC,IOPIC,NSAM,NSAM,'UNKNOWN',NF,NSAM)
d162 1
a162 1
	CALL  NRMW2(Q(K_CBO),Q(K_CWO),LSD/2,N2)
d165 1
a165 1
 	CALL  OPENFB(BUF,FINFO,IOPIC,NSAM,NSAM,'UNKNOWN',NF,NSAM)
d252 1
d256 1
a256 1
	ELSE
d274 2
@
