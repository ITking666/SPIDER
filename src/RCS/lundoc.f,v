head	1.112;
access;
symbols
	pre_getangas:1.102
	GPL2010:1.97
	pre_GPL2010:1.96
	pre_var_equation:1.95
	pre_fftwrings:1.92
	pre_opfiles:1.88
	src:1.88
	best-code:1.88
	named-reg:1.87
	x-named-regs:1.86
	x:1.86
	v13-00:1.86
	pre_GPL:1.84
	prec_CA:1.59
	noindx:1.36
	Bproc:1.24
	oct21:1.11;
locks; strict;
comment	@c @;


1.112
date	2015.06.05.16.15.09;	author leith;	state Exp;
branches;
next	1.111;

1.111
date	2015.03.27.13.31.17;	author leith;	state Exp;
branches;
next	1.110;

1.110
date	2014.02.19.13.34.44;	author leith;	state Exp;
branches;
next	1.109;

1.109
date	2013.05.17.14.42.55;	author leith;	state Exp;
branches;
next	1.108;

1.108
date	2013.05.01.18.55.50;	author leith;	state Exp;
branches;
next	1.107;

1.107
date	2012.04.04.18.20.21;	author leith;	state Exp;
branches;
next	1.106;

1.106
date	2012.04.02.16.17.50;	author leith;	state Exp;
branches;
next	1.105;

1.105
date	2011.04.25.18.47.36;	author leith;	state Exp;
branches;
next	1.104;

1.104
date	2011.04.13.14.49.48;	author leith;	state Exp;
branches;
next	1.103;

1.103
date	2011.03.28.13.29.33;	author leith;	state Exp;
branches;
next	1.102;

1.102
date	2010.10.25.19.32.46;	author leith;	state Exp;
branches;
next	1.101;

1.101
date	2010.10.12.19.09.44;	author leith;	state Exp;
branches;
next	1.100;

1.100
date	2010.10.12.12.22.05;	author leith;	state Exp;
branches;
next	1.99;

1.99
date	2010.09.16.16.38.11;	author leith;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.31.14.44.38;	author leith;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.24.13.26.05;	author leith;	state Exp;
branches;
next	1.96;

1.96
date	2009.11.17.15.34.08;	author leith;	state Exp;
branches;
next	1.95;

1.95
date	2009.05.29.12.49.15;	author leith;	state Exp;
branches;
next	1.94;

1.94
date	2008.11.10.15.58.29;	author leith;	state Exp;
branches;
next	1.93;

1.93
date	2008.10.17.12.44.18;	author leith;	state Exp;
branches;
next	1.92;

1.92
date	2007.10.04.12.31.29;	author leith;	state Exp;
branches;
next	1.91;

1.91
date	2007.02.27.14.54.32;	author leith;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.27.14.48.42;	author leith;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.26.18.46.59;	author leith;	state Exp;
branches;
next	1.88;

1.88
date	2005.12.16.01.49.33;	author cyang;	state Exp;
branches;
next	1.87;

1.87
date	2005.12.12.15.28.20;	author leith;	state Exp;
branches;
next	1.86;

1.86
date	2005.10.17.20.27.55;	author leith;	state Exp;
branches;
next	1.85;

1.85
date	2005.10.17.18.19.27;	author leith;	state Exp;
branches;
next	1.84;

1.84
date	2005.09.27.13.41.15;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	2005.09.26.14.30.36;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	2005.07.22.18.50.38;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	2005.02.18.16.08.25;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2005.02.18.15.21.58;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2004.10.13.16.22.02;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2004.09.30.16.42.38;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	2004.09.21.17.10.27;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2004.07.20.20.01.35;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.28.15.48.45;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.11.15.46.35;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	2004.04.22.15.52.45;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	2004.04.15.15.27.05;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.01.17.14.03;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	2004.03.09.17.31.24;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2004.03.04.16.35.54;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2004.03.02.17.34.59;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2004.02.11.16.30.57;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2004.02.09.19.21.56;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2004.02.09.17.51.28;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2004.02.03.17.50.45;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2004.02.02.21.10.47;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2004.02.02.19.42.39;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2004.01.30.13.54.35;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.29.18.55.49;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2003.09.16.15.28.21;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2003.09.08.18.13.52;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2003.09.04.20.17.23;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2003.09.04.14.25.09;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2003.08.07.14.16.30;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2003.08.07.13.28.53;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2003.08.06.20.33.30;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2003.08.03.00.37.39;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2003.08.02.23.29.13;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2003.08.02.23.20.52;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2003.07.29.16.41.22;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2003.07.28.19.39.52;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.24.16.29.16;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.23.20.52.49;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.21.13.16.43;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.16.14.31.57;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.15.17.08.29;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.14.17.25.38;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.09.16.32.42;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.08.17.20.34;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.08.16.57.51;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.27.14.58.43;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.30.13.03.37;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2002.09.18.15.20.12;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.19.16.48.25;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.30.17.40.38;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.16.13.23.46;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.18.14.23.13;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.17.19.13.50;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.11.18.49.15;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.09.14.25.07;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.19.16.04.34;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.26.21.16.32;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.16.16.58.20;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.19.19.17.14;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2000.08.23.13.57.30;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.08.23.13.46.22;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.09.19.18.20;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.09.13.32.49;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.31.16.10.59;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.13.17.49.49;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.13.14.35.48;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.24.16.55.34;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.03.20.04.45;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	99.11.22.15.22.57;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	99.11.22.14.33.27;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	99.11.18.18.55.24;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	99.11.16.16.15.21;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	99.10.07.18.43.35;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	99.09.15.14.55.27;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	99.08.11.17.49.03;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	99.07.27.18.02.25;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	99.07.20.20.06.43;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	99.07.19.15.49.00;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	99.07.06.17.33.27;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	99.06.25.18.19.37;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	99.06.23.18.21.27;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	99.06.18.17.52.04;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	99.06.17.19.11.00;	author leith;	state Exp;
branches;
next	;


desc
@@


1.112
log
@ENDFILE --> EOF FOR ifor
@
text
@
C++*********************************************************************
C                NEW                              APR 1999 ARDEAN LEITH
C                ADDED FILNAMSUB TO LUNDOCPARSE   JAN 2000 ARDEAN LEITH
C                NCOL (MAX NO OF COLUMNS) ADDED   JUN 2000 BILL BAXTER
C                REMOVED CONTINUATION LINES       JUL 2000 ARDEAN LEITH
C                LUNDOCREDALL PARAMETERS          DEC 2000 ARDEAN LEITH
C                CALL INDEXTOREG                  MAR 2001 ARDEAN LEITH
C                REMOVED FILNAMSUB IN LUNDOCPARSE APR 2001 ARDEAN LEITH
C                ADDED LUNDOCREDSLI               APR 2001 ARDEAN LEITH
C                INCREASED REGISTER NUMBERS       MAY 2001 ARDEAN LEITH
C                LUNDOCREDDAT GOBACK              SEP 2002 ARDEAN LEITH
C                LUNDOCREDSEQ RETURNS MAXY        APR 2003 ARDEAN LEITH
C                LUNDOCREDSEL NGOT BUG            MAY 2003 ARDEAN LEITH
C                INCORE SUPPORT                   JUL 2003 ARDEAN LEITH
C                K WRONG IN LUNDOCPARSE           AUG 2003 ARDEAN LEITH
C                NEW DOC FILE FORMAT              FEB 2004 ARDEAN LEITH
C                LUNDOCGETCOM DLIST OVERFLOW      APR 2004 ARDEAN LEITH
C                LUNDOCGETCOM ICOUNT BUG          APR 2004 ARDEAN LEITH
C                LUNDOCREDALLI ICOUNT BUG         JUN 2004 ARDEAN LEITH
C                LUNDOCREDALLI COL OVERFLOW BUG   JUL 2005 ARDEAN LEITH
C                LUNDOCSAYHDR MYPID BUG           SEP 2005 ARDEAN LEITH
C                [] DEFAULT FOR REGS.             NOV 2005 ARDEAN LEITH
C                LUNDOCREDNXT LOCDOC ARROW BUG    FEB 2007 ARDEAN LEITH
C                NEXTKEY() ADDED, MAXICDOC=12     FEB 2007 ARDEAN LEITH
C                TOLERATES BAD ; FROM JWEB        SEP 2007 ARDEAN LEITH
C                MPI BCAST CHANGES                OCT 2008 ARDEAN LEITH
C                NEXTKEY SET TO 1                 MAY 2009 ARDEAN LEITH
C                LUNDOCPUTCOM FORMAT              NOV 2009 ARDEAN LEITH
C                MPI_SET                          NOV 2009 ARDEAN LEITH
C                VAR. SUBSTITUED IN TEXT COMMENT  AUG 2010 ARDEAN LEITH
C                COMMENT KEY > 9999               AUG 2010 ARDEAN LEITH
C                LUNDOCGETCOM   END=998           OCT 2010 ARDEAN LEITH
C                ..GETCOM: READ (LUNDOC,81        OCT 2010 ARDEAN LEITH
C                ADDED MPI BARRIER                MAR 2011 ARDEAN LEITH
C                LUNDOCINFO ; / BUG               APR 2011 ARDEAN LEITH
C                LUNDOCREDLIN ; ERRT BUG          APR 2011 ARDEAN LEITH
C                FORMAT(  1PG13.6)                APR 2011 ARDEAN LEITH
C                LUNDOCWRTDATF FORMAT             APR 2012 ARDEAN LEITH
C                LABEL 92 UNDEFINED IF NOT MPI    MAR 2015 ARDEAN LEITH
C                ENDFILE --> EOF FOR ifort        JUN 2015 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    LUNDOC
C
C    PURPOSE:    SUPPORT SUBROUTINES FOR DOCUMENT FILE HANDLING.
C     ------------------------- LUNDOCREDLIN -----------------------------
C     ------------------------- LUNDOCWRTDAT -----------------------------
C     ------------------------- LUNDOCWRTDATF ----------------------------
C     ------------------------- LUNDOCREDDAT -----------------------------
C     ------------------------- LUNDOCREDALL -----------------------------
C     ------------------------- LUNDOCREDALLI --------------------------
C     ------------------------- LUNDOCREDSLC -----------------------------
C     ------------------------- LUNDOCREDSEQ -----------------------------
C     ------------------------- LUNDOCREDSEL -----------------------------
C     ------------------------- LUNDOCREDANG -----------------------------
C     ------------------------- LUNDOCGETKEY -----------------------------
C     ------------------------- LUNDOCREDNXT -----------------------------
C     ------------------------- LUNDOCINFO -----------------------------
C     ------------------------- LUNDOCGETCOM -----------------------------
C     ------------------------- LUNDOCPUTCOM -----------------------------
C     ------------------------- LUNDOCSAYHDR -----------------------------
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

C*********************** DOCIC_INFO ******************************

        MODULE DOCIC_INFO

C          NEEDED FOR MAXNAM
           INCLUDE 'CMLIMIT.INC' 

C          ARRAY OF POINTERS TO DOCUMENT STORAGE ARRAYS
           INTEGER, PARAMETER :: MAXICDOCS = 12

           TYPE REAL_POINTER
              REAL, DIMENSION(:), POINTER :: IPT 
           END TYPE REAL_POINTER

           TYPE(REAL_POINTER), DIMENSION(MAXICDOCS) :: LOCDOC

           INTEGER, DIMENSION(MAXICDOCS) :: NUMCOLS
           INTEGER, DIMENSION(MAXICDOCS) :: NUMKEYS
           INTEGER, DIMENSION(MAXICDOCS) :: NLETOLDNAM
           INTEGER, DIMENSION(MAXICDOCS) :: NEXTKEY
           CHARACTER(LEN=MAXNAM)         :: OLDNAM(MAXICDOCS)

        END MODULE DOCIC_INFO


C     ------------------------- LUNDOCWRTDAT -----------------------------
C
C    LUNDOCWRTDAT(LUNDOC,IKEY,DLIST,NLIST,IRTFLG)
C
C    PURPOSE:    WRITE DATA FOR A SPECIFED KEY OF A DOC. FILE INTO
C                INCORE OR FILE-BASED DOC. FILE
C
C    PARAMETERS:   LUNDOC  IO UNIT                                (SENT)
C                  IKEY    NUMBER OF KEY WANTED (<0 IS COMMENTED) (RET.)
C                  DLIST   ARRAY CONTAINING NUMBERS               (RET.)
C                  NLIST   NUMBER OF ELEMENTS IN ARRAY            (SENT)
C                  IRTFLG                                         (RET.)
C
C     NOTE:    CAN NOW WRITE OUT DOC FILES WITH 100 REGISTERS
C              BUT SOME OF THE READ PGMS CAN NOT HANDLE MORE THAN 9!!
C              (FOR USE WITH 'SD C')
C
C--*********************************************************************

      SUBROUTINE LUNDOCWRTDAT(LUNDOC,IKEY,DLIST,NLIST,IRTFLG)

      USE DOCIC_INFO
      INCLUDE 'CMBLOCK.INC' 

      REAL, DIMENSION(*)          :: DLIST
      REAL, DIMENSION(:), POINTER :: IPQ

      CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

      IRTFLG = 0

C     RETURN IF NLIST == 0
      IF (NLIST <= 0) RETURN

C     IKEY IS THE KEY NUMBER.
C     NLIST IS THE NUMBER OF REGISTERS (VALUES) IN THE LINE.

      IRTFLG = 1

      IF (IKEY == 0) THEN
C        WANT TO CREATE ILLEGAL KEY NUMBER
         CALL ERRT(101,'ILLEGAL DOC. FILE KEY: 0',IDUM)
         RETURN

      ELSEIF (IKEY < 0) THEN

C        WANT TO CREATE COMMENT KEY ----------------------------------
         IF (LUNDOC <= 0) THEN
C           WANT TO CREATE COMMENT KEY IN INCORE DOC. FILE 
            CALL ERRT(101,'NO COMMENT KEYS IN IN-CORE FILES',IDUM)
            RETURN
         ENDIF

         IKEYT = -IKEY
         IF (IKEYT > 9999999) THEN
           WRITE(NOUT,90) IKEY
90         FORMAT(' *** COMMENT KEY:',I8,
     &            ' MUST BE IN RANGE -9999999...-1'/)
           CALL ERRT(101,'COMMENT KEY OUT OF RANGE -9999999 .. -1',IDUM)
           RETURN
         ELSEIF (NLIST > 9) THEN
           CALL ERRT(101,'COMMENT KEY CAN ONLY HAVE 9 REGISTERS',IDUM)
           RETURN
         ENDIF

         IF (MYPID <= 0) THEN
            WRITE(LUNDOC,91) IKEYT,NLIST,(DLIST(K),K=1,NLIST)
91          FORMAT(' ;',I8,1X,I1,1X,10000(1PG13.6,1X))
            CALL FLUSHFILE(LUNDOC)
         ENDIF

      ELSEIF (LUNDOC > 0) THEN
C        WANT TO WRITE REGULAR KEY TO DISK BASED DOC. FILE -----------

         IF (NLIST > 9 .OR. IKEY > 999999) THEN
C           MUST USE NEW FORMAT
            IF (MYPID <= 0)
     &         WRITE(LUNDOC,92) IKEY,NLIST,(DLIST(K),K=1,NLIST)
92             FORMAT(I10,' ',I4,10000(' ',1PG13.6))
         
         ELSEIF (IKEY <= 99999) THEN
C           WRITE LINE OF REGISTERS WITH KEY (I5)
            IF (MYPID <= 0) THEN
               WRITE(LUNDOC,93) IKEY,NLIST,(DLIST(K),K=1,NLIST)
93             FORMAT(I5,' ',I1,10000(' ',1PG13.6))
               IF (MYPID <= 0) CALL FLUSHFILE(LUNDOC)
            ENDIF

         ELSEIF (IKEY <= 999999) THEN
C           WRITE LINE OF REGISTERS WITH KEY (I6)
            IF (MYPID <= 0) THEN
               WRITE(LUNDOC,94) IKEY,NLIST,(DLIST(K),K=1,NLIST)
94             FORMAT(I6,' ',I1,10000(' ',1PG13.6))
               IF (MYPID <= 0) CALL FLUSHFILE(LUNDOC)
            ENDIF
         ENDIF

      ELSEIF (LUNDOC < 0) THEN
C        WANT TO WRITE REGULAR KEY TO INCORE DOC. FILE --------------

C        GET ARRAY SIZE FOR INCORE FILE (FIXED WHEN IT WAS CREATED)
         IC   = - LUNDOC
         IF (IC > MAXICDOCS) THEN
C           FILE LIST INDEX OUT OF RANGE
            CALL ERRT(102,'MAX. INCORE DOC. FILE. NUMBER',MAXICDOCS)
            RETURN
         ENDIF

         MAXX = NUMCOLS(IC)
         MAXY = NUMKEYS(IC)
         IF (NLIST > (MAXX - 1)) THEN
            WRITE(NOUT,95) NLIST
95          FORMAT('  *** NUMBER OF REGISTERS: ',I3)
            CALL ERRT(102,'REGISTER LIMIT FOR THIS INCORE FILE',MAXX-1)
            RETURN

         ELSEIF (IKEY > MAXY) THEN
            WRITE(NOUT,96) IKEY
96          FORMAT('  *** KEY:',I10)
            CALL ERRT(102,'KEY LIMIT FOR THIS INCORE FILE',MAXY)
            RETURN
         ENDIF

         IPQ       => LOCDOC(IC)%IPT
         ILOC      = (IKEY - 1) * MAXX + 1
         IPQ(ILOC) = NLIST

         DO IREG=1,NLIST
            IPQ(ILOC+IREG) = DLIST(IREG)
         ENDDO
      ENDIF

      IRTFLG = 0

      RETURN
      END




C     ------------------------- LUNDOCWRTDATF ----------------------------
C
C    LUNDOCWRTDATF(LUNDOC,IKEY,DLIST,NLIST,IRTFLG)
C
C    PURPOSE:    WRITE DATA FOR A SPECIFED KEY OF A DOC. FILE INTO
C                INCORE OR FILE-BASED DOC. FILE. USER SUPPLIES
C                LINE FORMAT.
C
C    PARAMETERS:   LUNDOC  IO UNIT                                (SENT)
C                  IKEY    NUMBER OF KEY WANTED (<0 IS COMMENTED) (RET.)
C                  DLIST   ARRAY CONTAINING NUMBERS               (RET.)
C                  NLIST   NUMBER OF ELEMENTS IN ARRAY            (SENT)
C                  FORMOUT LINE OUTPUT FORMAT                     (SENT)
C                  IRTFLG                                         (RET.)
C
C     NOTE:    CAN WRITE OUT DOC FILES WITH 100 REGISTERS
C              BUT SOME OF THE READ PGMS CAN NOT HANDLE MORE THAN 9!!
C
C--*********************************************************************

      SUBROUTINE LUNDOCWRTDATF(LUNDOC,IKEY,DLIST,NLIST,
     &                         FORMOUT,IRTFLG)

      USE DOCIC_INFO
      INCLUDE 'CMBLOCK.INC' 

      INTEGER                     :: LUNDOC,IKEY 
      REAL, DIMENSION(*)          :: DLIST
      INTEGER                     :: NLIST
      CHARACTER(LEN=*)            :: FORMOUT
      INTEGER                     :: IRTFLG
 
      REAL, DIMENSION(:), POINTER :: IPQ

      CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

      IRTFLG = 0

C     IKEY IS THE KEY NUMBER.
C     NLIST IS THE NUMBER OF REGISTERS (VALUES) IN THE LINE.

C     RETURN IF NLIST == 0
      IF (NLIST <= 0) RETURN

      IRTFLG = 1

      IF (IKEY == 0) THEN
C        WANT TO CREATE ILLEGAL KEY NUMBER
         CALL ERRT(101,'ILLEGAL DOC. FILE KEY: 0',IDUM)
         RETURN

      ELSEIF (IKEY < 0) THEN

C        WANT TO CREATE COMMENT KEY ----------------------------------
         IF (LUNDOC <= 0) THEN
C           WANT TO CREATE COMMENT KEY IN INCORE DOC. FILE 
            CALL ERRT(101,'NO COMMENT KEYS IN IN-CORE FILES',IDUM)
            RETURN
         ENDIF

         IKEYT = -IKEY
         IF (IKEYT > 9999999) THEN
           CALL ERRT(102,'COMMENT KEY OUT OF RANGE -9999999 .. -1',IKEY)
           RETURN
         ELSEIF (NLIST > 9) THEN
           CALL ERRT(101,'COMMENT KEY CAN ONLY HAVE 9 REGISTERS',IDUM)
           RETURN
         ENDIF

         IF (MYPID <= 0) THEN
            WRITE(LUNDOC,91) IKEYT,NLIST,(DLIST(K),K=1,NLIST)
91          FORMAT(' ;',I8,1X,I1,1X,10000(1PG13.6,1X))
            CALL FLUSHFILE(LUNDOC)
         ENDIF

      ELSEIF (LUNDOC > 0) THEN
C        WANT TO WRITE REGULAR KEY TO DISK BASED DOC. FILE -----------

         IF (MYPID <= 0) THEN
            WRITE(LUNDOC,FORMOUT) IKEY,NLIST,(DLIST(K),K=1,NLIST)
         
            IF (MYPID <= 0) CALL FLUSHFILE(LUNDOC)
         ENDIF

      ELSEIF (LUNDOC < 0) THEN
C        WANT TO WRITE REGULAR KEY TO INCORE DOC. FILE --------------

C        GET ARRAY SIZE FOR INCORE FILE (FIXED WHEN IT WAS CREATED)
         IC   = - LUNDOC
         IF (IC > MAXICDOCS) THEN
C           FILE LIST INDEX OUT OF RANGE
            CALL ERRT(102,'MAX. INCORE DOC. FILE. NUMBER',MAXICDOCS)
            RETURN
         ENDIF

         MAXX = NUMCOLS(IC)
         MAXY = NUMKEYS(IC)
         IF (NLIST > (MAXX - 1)) THEN
            WRITE(NOUT,95) NLIST
95          FORMAT('  *** NUMBER OF REGISTERS: ',I3)
            CALL ERRT(102,'REGISTER LIMIT FOR THIS INCORE FILE',MAXX-1)
            RETURN

         ELSEIF (IKEY > MAXY) THEN
            WRITE(NOUT,96) IKEY
96          FORMAT('  *** KEY:',I10)
            CALL ERRT(102,'KEY LIMIT FOR THIS INCORE FILE',MAXY)
            RETURN
         ENDIF

         IPQ       => LOCDOC(IC)%IPT
         ILOC      = (IKEY - 1) * MAXX + 1
         IPQ(ILOC) = NLIST

         DO IREG=1,NLIST
            IPQ(ILOC+IREG) = DLIST(IREG)
         ENDDO
      ENDIF

      IRTFLG = 0

      RETURN
      END




C     ------------------------- LUNDOCREDLIN -----------------------------
C
C    LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,DBUF,MAXX,MAXY,WANTICCOL,
C                 IKEY,ICOUNT,IRTFLG
C
C    PURPOSE:    RECOVER LINE OF  DATA FROM A DOC FILE AND RETURN IT 
C                IN DBUF, DBUF KEEPS ICOUNT IN FIRST COLUMN.
C 
C    PARAMETERS:  LUNDOC     IO UNIT                             (SENT)
C                 WANTERRT   CALLERRT FLAG                       (SENT)
C                 WARNIT     WARNIT FLAG                    (SENT/RET.)
C                 DBUF       DATA ARRAY                     (SENT/RET.)
C                 MAXX       MAX X ARRAY DIMENSION               (SENT)
C                            (NUMBER OF REGISTERS + 1)!!
C                 MAXY       MAX Y ARRAY DIMENSION               (SENT)
C                            IF ZERO DOES NOT LOAD ARRAY JUST LINE
C                 WANTICCOLC WANT ICOUNT IN DBUF                 (SENT)
C                 IKEY       KEY  RETRIEVED                      (RET.)
C                 ICOUNT     COLS. RETRIEVED                     (RET.)
C                 IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
C
C    NOTE: KEY & ICOUNT MUST BE IN FIRST 80 COL.  SHOULD HANDLE 
C          OLD FORMAT DATA OK. NO LIMIT ON ICOUNT 
C 
C--*********************************************************************

      SUBROUTINE LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,WANTICCOL,
     &                        DBUF,MAXX,MAXY,IKEY,ICOUNT,IRTFLG)

      INCLUDE 'CMBLOCK.INC' 

      INTEGER, PARAMETER       :: LENRECLIN = 80  ! ONLY NEEDS START
      REAL,DIMENSION(*)        :: DBUF
      CHARACTER(LEN=LENRECLIN) :: RECLIN
      LOGICAL                  :: WARNIT,WANTERRT,NEWFORM,WANTICCOL

      CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

      IF (MYPID <= 0) THEN
         READ(LUNDOC,84,IOSTAT=IERR) RECLIN
84       FORMAT(A)
         IF (IERR < 0) RECLIN(1:2) = '!!'
      ENDIF
#ifdef USE_MPI
      CALL BCAST_MPI('LUNDOCREDLIN','RECLIN',RECLIN,LENRECLIN,'C',
     &               ICOMM,MPIERR)
#endif 

      IKEY   = 0
      ICOUNT = 0
      IRTFLG = 0

      IF (RECLIN(1:2) == '!!') THEN
C         END OF FILE
          IRTFLG = -1
          RECLIN = ''
          RETURN
       ENDIF

C      IGNORE COMMENT LINES & COMMENT KEY LINES. 
       IF (RECLIN(2:2) == ';') RETURN
       IF (RECLIN(1:2) == '; ') RETURN  !BAD JWEB COMMENT LINE
          
       NEWFORM = .TRUE.
       READ(RECLIN,*,IOSTAT=IERR) IKEY,ICOUNT

       IF (IERR > 0) THEN
C         ERROR ON READ, TRY OLD DOC. FILE FORMAT

          READ(RECLIN,83,IOSTAT=IERR) IKEY,ICOUNT
83        FORMAT(I6,I1,10000F12.6)
          NEWFORM = .FALSE.

          IF (IERR > 0) THEN
C            ERROR ON READ USING OLD FORMAT ALSO, RETURN
             IF (WANTERRT) THEN
                NLET = lnblnkn(RECLIN)
                IF (NLET <= 0) THEN
                   CALL ERRT(101,'EMPTY DOC FILE LINE',NE)
                ELSE
                   WRITE(NOUT,94) RECLIN(1:NLET)
94                 FORMAT('  *** UNABLE TO INTERPRET DOC FILE LINE ',
     &                    'STARTING WITH: ',A)
                   CALL ERRT(100,'LUNDOCREDLIN',NE)
                ENDIF
             ENDIF
             ICOUNT = 0
             IKEY   = 0
             IRTFLG = 1
             RETURN
          ENDIF
       ENDIF

       IF (ICOUNT <= 0) THEN
           IF (MYPID <= 0)
     &         WRITE(NOUT,*)' EMPTY DOCUMENT FILE LINE SKIPPED'
           RETURN

        ELSEIF (IKEY < 0) THEN
           IF (MYPID <= 0)
     &         WRITE(NOUT,*)' CONTINUATION LINE SKIPPED IN DOC FILE'
           RETURN

        ELSEIF (IKEY == 0) THEN
C          ZERO KEY ILLEGAL, PRINT WARNING MSG. BUT CONTINUE
           IF (MYPID <= 0)
     &        WRITE(NOUT,*)' ILLEGAL KEY NUMBER: 0  SKIPPED IN DOC FILE'
           RETURN

        ELSEIF (MAXY > 0 .AND. IKEY > MAXY) THEN
C          KEY THAT WILL NOT FIT IN DBUF SENDS ERROR MSG.
           IF (WARNIT) THEN 
               IF (MYPID <= 0)  WRITE(NOUT,93) MAXY
93             FORMAT('  KEYS GREATER THAN: ',I7,' NOT RETRIEVED')
               WARNIT = .FALSE.
           ENDIF
           IKEY   = 0
           ICOUNT = 0
           RETURN
        ENDIF

C        AVOID ARRAY OVERFLOW
         ICOUNT = MIN(ICOUNT,MAXX-1)

         IF (WANTICCOL) THEN
C           FIND DBUF LOCATION POINTER
            ILOC       = (IKEY -1) * MAXX + 1
            DBUF(ILOC) = ICOUNT
         ELSE
C           FIND DLIST LOCATION POINTER
            ILOC = 0
         ENDIF

         IF (NEWFORM .AND. MYPID <= 0) THEN
C            READ REGISTERS USING NEW DOC. FILE FORMAT
             BACKSPACE(LUNDOC)
             READ(LUNDOC,*,IOSTAT=IERR)IKEYT,ICOUNTT,
     &                                 (DBUF(ILOC+I),I=1,ICOUNT)
             IF (IERR .NE. 0) THEN
C               TRY READING AGAIN USING OLD FORMAT
                BACKSPACE(LUNDOC)
                READ(LUNDOC,83,IOSTAT=IERR) IKEYT,ICOUNTT,
     &                                      (DBUF(ILOC+I),I=1,ICOUNT)
             ENDIF
         ELSEIF (.NOT. NEWFORM  .AND. MYPID <= 0) THEN
C            READ REGISTERS USING OLD DOC. FILE FORMAT
             BACKSPACE(LUNDOC)
             READ(LUNDOC,83,IOSTAT=IERR) IKEYT,ICOUNTT,
     &                                   (DBUF(ILOC+I),I=1,ICOUNT)
         ENDIF
#ifdef USE_MPI
         CALL BCAST_MPI('LUNDOCREDLIN','DBUF',DBUF(ILOC+1),
     &                  ICOUNT,'R',ICOMM)
         CALL BCAST_MPI('LUNDOCREDLIN','IERR',IERR,1,'I',ICOMM)
#endif

         IF (IERR .NE. 0) THEN
C            ERROR ON REGISTER COLS READ
             IF (WANTERRT) THEN
                IF (MYPID <= 0) WRITE(NOUT,94) RECLIN
                CALL ERRT(100,'LUNDOCREDLIN',NE)
                RETURN
             ENDIF
             IKEY   = 0
             ICOUNT = 0
             IRTFLG = 1
             RETURN
         ENDIF

         END

C     ------------------------- LUNDOCREDDAT -----------------------------
C
C    LUNDOCREDDAT(LUNDOC,IKEY,DLIST,NMAX,ICOUNT,TILLEND,GOBACK,IRTFLG)
C
C    PURPOSE:    RECOVER A SPECIFED KEY FROM A DOC FILE.
C                WORKS ON INCORE AND FILE BASED DOC. FILES.
C
C    PARAMETERS:   LUNDOC  IO UNIT                               (SENT)
C                  IKEY    NUMBER OF KEY WANTED (<0 IS COMMENTED)(RET.)
C                  DLIST   ARRAY CONTAINING REGISTER NUMBERS     (RET.)
C                  NMAX    MAX DLIST ARRAY DIMENSION             (SENT)
C                  ICOUNT  NUMBER OF ELEMENTS IN ARRAY           (RET.)
C                  TILLEND KEEP READING TILL EOF EVEN IF FOUND   (SENT.)
C                  GOBACK  REWIND AND READ AGAIN IF NOT FOUND    (SENT)
C                  IRTFLG  1=ERROR                               (RET.)
C                          2=NOT FOUND                           (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDDAT(LUNDOC,IKEY,DLIST,NMAX,ICOUNT,
     &                        TILLEND,GOBACK,IRTFLG)

      USE DOCIC_INFO
      INCLUDE 'CMBLOCK.INC'

      REAL                        :: DLIST(NMAX)
      LOGICAL                     :: TILLEND,GOBACK,FIRST
      LOGICAL                     :: WANTERRT,WARNIT
      REAL, POINTER               :: IPQ(:)

      REAL                        :: DLISTT(NMAX)

      IRTFLG   = 1

      IF (IKEY < 0) THEN
C        WANT A COMMENTED KEY
         ICOUNT = NMAX
         CALL LUNDOCGETCOM(LUNDOC,IKEY,DLIST,ICOUNT,TILLEND,IRTFLG)
         RETURN

      ELSEIF (IKEY == 0) THEN
C        THIS IS ILLEGAL KEY, SOUND WARNING
         WRITE(NOUT,90) 
90       FORMAT('  WARNING; RETRIEVING ILLEGAL KEY NUMBER: 0')

      ELSEIF (LUNDOC < 0) THEN
C        WANT TO READ REGULAR KEY FROM INCORE DOC. FILE

C        GET ARRAY SIZE FOR INCORE FILE (FIXED WHEN IT WAS CREATED)
         IC   = - LUNDOC
         IF (IC > MAXICDOCS) THEN
C           FILE LIST INDEX OUT OF RANGE
            CALL ERRT(102,'MAX. INCORE DOC. FILE. NUMBER',MAXICDOCS)
            RETURN
         ENDIF

C        FIND HIGHEST KEY NUMBER IN THE INCORE DOC. FILE
         MAXY   = NUMKEYS(IC)
         MAXXIC = NUMCOLS(IC) 

         IF (IKEY > MAXY) THEN
            WRITE(NOUT,96) IKEY
96          FORMAT('  *** KEY:',I10)
            CALL ERRT(102,'KEY LIMIT FOR THIS INCORE FILE',MAXY)
            RETURN
         ENDIF

         IPQ     => LOCDOC(IC)%IPT
         ILOC    = (IKEY - 1) * MAXXIC + 1

C        MAKE SURE DLIST DOES NOT OVERFLOW
         ICOUNT  = IPQ(ILOC)
         ICOUNT  = MIN(NUMCOLS(IC)-1,ICOUNT,NMAX)

         IF (ICOUNT > 0) THEN
c           THIS KEY USED IN INCORE DOC. FILE

            DO IREG=1,ICOUNT
               DLIST(IREG) = IPQ(ILOC+IREG)
            ENDDO
       
            IRTFLG = 0
         ELSE
            IRTFLG = 2
         ENDIF
         RETURN
      ENDIF

      ICOUNT   = 0
      FIRST    = .TRUE.
      WARNIT   = .TRUE.
      WANTERRT = .FALSE.

      DO
C        READ NEXT LINE FROM DOC FILE
         CALL LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,.FALSE.,
     &                     DLISTT,NMAX+1,0,IKEYT,ICOUNTT,IRTFLG)

         IF (IRTFLG < 0) THEN
C           END OF FILE
            IF (ICOUNT == 0 .AND. GOBACK .AND. FIRST) THEN
C              DID NOT FIND KEY, REWIND AND TRY AGAIN
               REWIND(LUNDOC)
               FIRST = .FALSE.
               CYCLE
            ENDIF

C           REPOSISTION LOCATION
            IF (TILLEND) REWIND(LUNDOC)

C           RETURN 2 ON EOF IF DID NOT FIND KEY
            IRTFLG = 2
            IF (ICOUNT > 0) IRTFLG = 0
            RETURN

         ELSEIF (IRTFLG > 0) THEN
C           ERROR RETRIEVING ARRAY
            RETURN
         ENDIF

         IF (IKEY == IKEYT) THEN
C           FOUND DESIRED KEY, MAY HAVE DUPLICATES OF KEY
            ICOUNT = ICOUNTT
            DLIST  = DLISTT

C           IF "TILLEND", KEEP READING TILL EOF
            IF (TILLEND) CYCLE
            RETURN
         ENDIF
      ENDDO 

      END

C     ------------------------- LUNDOCREDALL -----------------------------
C
C    LUNDOCREDALL(LUNDOC,DBUF,MAXX,MAXY,WANTERRT,NGOT,IRTFLG)
C
C    PURPOSE:    RECOVER ALL DATA FROM A DOC FILE AND RETURN IT IN DBUF
C                DBUF KEEPS KEY IN FIRST COLUMN.
C 
C    PARAMETERS:  LUNDOC     IO UNIT                             (SENT)
C                 DBUF       DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                 MAXX       MAX X ARRAY DIMENSION               (SENT)
C                            (NUMBER OF REGISTERS + 1)!!
C                 MAXY       MAX Y ARRAY DIMENSION               (SENT)
C                 WANTERRT   CALLERRT FLAG                       (SENT)
C                 NGOT       MAX. KEY # RETRIEVED                (RET.)
C                 IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDALL(LUNDOC,DBUF,MAXX,MAXY,WANTERRT,
     &                        NGOT,IRTFLG)

      INCLUDE 'CMBLOCK.INC' 

      REAL,DIMENSION(MAXX,MAXY) :: DBUF
      LOGICAL                   :: WARNIT,WANTERRT

      CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

      IF (LUNDOC < 0) THEN
C        RECOVER FROM INCORE DOC FILE
         IC = -LUNDOC
         CALL LUNDOCREDALLI(IC,DBUF,MAXX,MAXY,NGOTX,NGOT,IRTFLG)
         RETURN
      ENDIF

      IRTFLG = 1
      NGOT   = 0
      WARNIT = .TRUE.

C     CLEAR DBUF RETURNED ANSWER BUFFER KEY NUMBERS
      DBUF(1,:) = 0.0

C     WILL LOOP UNTIL IT RETURNS EOF OR UNTIL ERROR
      DO
         CALL LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,.TRUE.,
     &                     DBUF,MAXX,MAXY,IKEY,ICOUNT,IRTFLG)

         IF (IRTFLG < 0) THEN
C           FINISHED READING FILE
            IRTFLG = 0
#ifdef USE_MPI
            !if (mypid <=0) write(6,*) 'End of doc file, mpi barrier'
            CALL MPI_BARRIER(ICOMM,MPIERR)
#endif
            RETURN

         ELSEIF (IRTFLG > 0) THEN
C           ERROR RETRIEVING ARRAY
            RETURN
         ENDIF

         IF (ICOUNT > 0 .AND. 
     &       (ICOUNT +2) <= MAXX .AND.
     &        IKEY <= MAXY) THEN
C            ZERO REMAINING VALUES IN REGISTER LIST FOR THIS LINE
             DBUF(ICOUNT+2:MAXX,IKEY) = 0.0
         ENDIF
         NGOT = MAX(NGOT,IKEY)
      ENDDO 

      END


C     ------------------------- LUNDOCREDALLI -----------------------------
C
C    LUNDOCREDALLI(IC,DBUF,MAXX,MAXY,IGOX,IENDX,NGOTX,NGOTY,IRTFLG)
C
C    PURPOSE:     RECOVER DATA FROM INCORE DOC FILE AND RETURN 
C                 IT IN DBUF. FIRST COLUMN IN DBUF IS KEY INUSE FLAG.
C                
C    PARAMETERS:  IC         IC UNIT                             (SENT)
C                 DBUF       DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                 MAXX       MAX X ARRAY DIMENSION               (SENT)
C                            (NUMBER OF REGISTERS + 1)!!
C                 MAXY       MAX Y ARRAY DIMENSION               (SENT)
C                 NGOTX      MAX. REG # RETRIEVED                (RET.)
C                 NGOTY      MAX. KEY # RETRIEVED                (RET.)
C                 IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
C
C--*********************************************************************

       SUBROUTINE LUNDOCREDALLI(IC,DBUF,MAXX,MAXY,NGOTX,NGOTY,IRTFLG)

       USE DOCIC_INFO

       INCLUDE 'CMBLOCK.INC' 

       REAL,DIMENSION(MAXX,MAXY)   :: DBUF
       REAL, DIMENSION(:), POINTER :: IPQ

       IRTFLG = 1

       IF (IC > MAXICDOCS) THEN
C         FILE LIST INDEX OUT OF RANGE
          CALL ERRT(102,'MAX. INCORE DOC. FILE. NUMBER',MAXICDOCS)
          RETURN
       ENDIF

C      FIND HIGHEST KEY NUMBER IN THE INCORE DOC. FILE
       MAXYIC = NUMKEYS(IC)
       MAXXIC = NUMCOLS(IC) 

       NGOTX = MIN(MAXX-1,MAXXIC-1)
       WRITE(NOUT,91) NGOTX 
91     FORMAT('  Number of incore registers recovered: ',I10)

       NGOTY  = MIN(MAXY,MAXYIC)
       WRITE(NOUT,90) NGOTY 
90     FORMAT('  Number of incore keys recovered: ',I10)

       IPQ       => LOCDOC(IC)%IPT
       ILOCD     = 0

       DO IKEY = 1,NGOTY
          DO ICOL = 1,NGOTX+1
             ILOCI           = (IKEY - 1) * MAXXIC + ICOL
             DBUF(ICOL,IKEY) = IPQ(ILOCI)
          ENDDO 
  
          IF ((NGOTX+1) < MAXX) THEN
C            FILL REST OF DBUF LINE WITH ZEROS
             DBUF(NGOTX+1:MAXX, IKEY) = 0.0
          ENDIF
       ENDDO

       IF (NGOTY < MAXY) THEN
C         FILL REST OF DBUF WITH ZEROS
          DBUF(1:MAXX, NGOTY+1:MAXY) = 0.0
       ENDIF

       IRTFLG = 0
       RETURN

       END


C     ------------------------- LUNDOCREDANG -----------------------------
C
C    LUNDOCREDANG(LUNDOC,DLIST,MAXY,NGOTY,MAXGOTY,IRTFLG)
C
C    PURPOSE:    RECOVER COLUMNS 1-3 OF DOC FILE AS REAL NUMBERS. IN
C                AN ARRAY. RETURNS NUMBER OF FILLED KEYS AND HIGHEST 
C                KEY THAT IS FILLED.
C                
C    PARAMETERS: LUNDOC     I/O UNIT                            (SENT)
C                DLIST      DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                MAXY       ARRAY DIMENSION                     (SENT)
C                NGOTY      NUMBER OF FILLED KEYS IN LIST       (RET.)
C                MAXGOTY    HIGHEST FILLED KEY IN LIST          (RET.)
C                IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDANG(LUNDOC,DLIST,MAXY,NGOTY,MAXGOTY,IRTFLG)

      CALL LUNDOCREDSLC(LUNDOC,.FALSE.,IDUM,DLIST, 3,MAXY,
     &    .TRUE.,.FALSE.,1,3, 1,MAXY, NGOTY,MAXGOTY,IRTFLG)

      RETURN
      END



C     ------------------------- LUNDOCREDSEL -----------------------------
C
C    LUNDOCREDSEL(LUNDOC,ILIST,MAXY,NGOTY,MAXGOTY,IRTFLG)
C
C    PURPOSE:    RECOVER COLUMN 1 OF DOC FILE AS INTEGER NUMBERS IN
C                AN ARRAY. RETURNS NUMBER OF FILLED KEYS AND HIGHEST 
C                KEY THAT WAS FILLED.
C                
C    PARAMETERS: LUNDOC     I/O UNIT                            (SENT)
C                ILIST      DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                MAXY       ARRAY DIMENSION                     (SENT)
C                NGOTY      NUMBER OF FILLED KEYS IN LIST       (RET.)
C                MAXGOTY    HIGHEST FILLED KEY IN LIST          (RET.)
C                IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDSEL(LUNDOC,ILIST,MAXY,NGOTY,MAXGOTY,IRTFLG)

      CALL LUNDOCREDSLC(LUNDOC,.TRUE.,ILIST,DUM,1,MAXY,
     &    .FALSE.,.FALSE. ,1,1, 1,MAXY,NGOTY,MAXGOTY,IRTFLG)

      RETURN
      END


C     ------------------------- LUNDOCREDSEQ -----------------------------
C
C    LUNDOCREDSEQ(LUNDOC,DLIST,MAXX,MAXY,IWANTY,NGOTY,IRTFLG)
C
C    PURPOSE:    RECOVER COLUMN 1..MAXX  DOC FILE AS REAL NUMBERS IN
C                AN ARRAY. RETURNS NUMBER OF FILLED KEYS.  ARRAY 
C                RECOVERS ALL KEYS EVEN IF DUPLICATED.
C                
C    PARAMETERS: LUNDOC     I/O UNIT                            (SENT)
C                DLIST      DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                MAXX,MAXY  ARRAY DIMENSION                     (SENT)
C                NGOTY      NUMBER OF FILLED KEYS IN DLIST      (RET.)
C                IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDSEQ(LUNDOC,DLIST,MAXX,MAXY,IWANTY,
     &                        NGOTY,IRTFLG)

      CALL LUNDOCREDSLC(LUNDOC,.FALSE.,IDUM,DLIST,MAXX,MAXY,
     &    .FALSE.,.FALSE. ,1,MAXX, 1,IWANTY, NGOTY,MAXGOTY,IRTFLG)

      RETURN
      END




C     ------------------------- LUNDOCREDSLC -----------------------------
C
C    LUNDOCREDSLC(LUNDOC,USEINT,ILIST,DLIST,MAXX,MAXY,
C             KEEPKEYS, ERRSKIP,IGOX,IENDX, IGOY,IENDY, 
C             NGOTY,MAXGOTY,IRTFLG)
C
C    PURPOSE:    RECOVER SLICE OF SPECIFED KEYS AND REGISTERS FROM AN
C                INCORE DOC FILE AND RETURNS SLICE IN LIST OR DLIST. 
C                SELECTS WHETHER REGISTER CONTENTS ARE RETURNED AS 
C                INTEGERS OR REAL, AND WHETHER TO KEEP KEYS AS
C                INDICES OR JUST RECOVER SEQUENTIALLY IGNORING KEYS.
C                
C    PARAMETERS: LUNDOC     FILE I/O UNIT                       (SENT)
C                USEINT     SELECTS ILIST OR DLIST              (SENT)
C                ILIST      DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                DLIST      DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                MAXX       ARRAY DIMENSION                     (SENT)
C                MAXY       ARRAY DIMENSION                     (SENT)
C                KEEPKEYS   KEEPS KEYS AS INDICES               (SENT)
C                ERRSKIP    WARN IF KEY MISSING                 (SENT)
C                IGOX       STARTING REG.                       (SENT)
C                IENDX      ENDING REG.                         (SENT)
C                IGOY       STARTING KEY                        (SENT)
C                IENDY      ENDING KEY                          (SENT)
C                NGOTY      NUMBER OF FILLED KEYS IN LIST       (RET.)
C                MAXGOTY    HIGHEST FILLED KEY IN LIST          (RET.)
C                IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDSLC(LUNDOC,USEINT,ILIST,DLIST,MAXX,MAXY,
     &    KEEPKEYS,ERRSKIP,IGOX,IENDX, IGOY,IENDY, NGOTY,MAXGOTY,IRTFLG)

      USE DOCIC_INFO

      INCLUDE 'CMBLOCK.INC' 

      INTEGER,DIMENSION(MAXX,MAXY) :: ILIST
      REAL,DIMENSION(MAXX,MAXY)    :: DLIST
      REAL, DIMENSION(MAXX)        :: PLIST
      LOGICAL                      :: USEINT,KEEPKEYS,ERRSKIP
      LOGICAL                      :: WANTERRT,WARNIT
      REAL, DIMENSION(:), POINTER  :: IPQ
 
      CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

      IRTFLG    = 1
      NGOTX     = IENDX - IGOX + 1
      MAXGOTY   = 0
      NWANTY    = IENDY - IGOY + 1
      NGOTY     = 0

      IF (LUNDOC < 0) THEN
C        RECOVER SLICE FROM INCORE DOC FILE --------------------------
         IC = -LUNDOC
      
         IF (IC > MAXICDOCS) THEN
C           FILE LIST INDEX OUT OF RANGE
            CALL ERRT(102,'MAX. INCORE DOC. FILE. NUMBER',MAXICDOCS)
            RETURN
         ENDIF

C        FIND HIGHEST KEY NUMBER IN THE INCORE DOC. FILE
         MAXXIC = NUMCOLS(IC) 
         MAXYIC = NUMKEYS(IC)
         IPQ    => LOCDOC(IC)%IPT

         IENDYNOW = MIN(IENDY,MAXYIC)
         IF (IGOX > IENDX .OR. IENDX > (MAXXIC-1)) THEN
            CALL ERRT(102,'HIGHEST AVAILABLE INCORE REGISTER',MAXXIC-1)
            RETURN

         ELSEIF (IGOY > IENDYNOW) THEN
            CALL ERRT(102,'HIGHEST AVAILABLE INCORE KEY',MAXYIC)
            RETURN
         ENDIF

         DO IKEY = IGOY,IENDYNOW
            ILOCIC = (IKEY - 1) * MAXXIC + 1
            ICOUNT = IPQ(ILOCIC)

            IF (.NOT. KEEPKEYS) THEN
C              DO NOT SAVE MT LINE
               IF (ICOUNT <= 0) CYCLE

C              STORE CONSECUTIVELY
               NGOTY = NGOTY + 1
               IKEYT = NGOTY

               MAXGOTY = MAX(MAXGOTY,IKEY)
            ELSE
               NGOTY = NGOTY + 1
               IF (ERRSKIP .AND. ICOUNT <= 0) THEN
                  CALL ERRT(102,'MISSING KEY',IKEYT)
                  RETURN
               ENDIF
               IKEYT   = IKEY
               MAXGOTY = IKEY
            ENDIF

            IF (USEINT) THEN
               ILIST(IGOX:IENDX,IKEYT) = IPQ(ILOCIC+1:ILOCIC+NGOTX)
            ELSE
               DLIST(IGOX:IENDX,IKEYT) = IPQ(ILOCIC+1:ILOCIC+NGOTX)
            ENDIF
         ENDDO

      ELSE
C        RECOVER SLICE FROM FILE BASED DOC FILE -----------------------

         WARNIT   = .FALSE.
         WANTERRT = .TRUE.
         DO
C           READ NEXT LINE FROM DOC FILE
            CALL LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,.FALSE.,
     &                     PLIST,MAXX+1,0,IKEY,ICOUNT,IRTFLG)

            IF (IRTFLG < 0) THEN
C              END OF FILE
               GOTO 999

            ELSEIF (IRTFLG > 0) THEN
C              ERROR RETRIEVING ARRAY
               RETURN
            ENDIF

            IF (ICOUNT > 0 .AND.
     &         (IKEY >= IGOY .AND. IKEY <= IENDY)) THEN
C              ONLY RETRIEVE REGISTERS FROM KEYS: IGOY...IENDY
               MAXGOTY = MAX(MAXGOTY,IKEY)
               NGOTY   = NGOTY + 1
               IF (.NOT. KEEPKEYS) IKEY = NGOTY

               IF (USEINT) THEN
                  ILIST(1:NGOTX,IKEY) = PLIST(IGOX:IENDX)
               ELSE
                  DLIST(1:NGOTX,IKEY) = PLIST(IGOX:IENDX)
               ENDIF
            ENDIF
         ENDDO
      ENDIF

999   IF (MYPID <= 0) THEN
         WRITE(NOUT,91) NGOTY 
91       FORMAT('  NUMBER OF KEYS RECOVERED: ',I7)
      ENDIF

      IF (KEEPKEYS .AND. ERRSKIP .AND. NGOTY < NWANTY) THEN
         CALL ERRT(102,'MISSING KEYS',NWANTY - NGOTY)
      ENDIF

      IRTFLG = 0
      RETURN

      END


C     ------------------------- LUNDOCGETKEY -----------------------------
C
C    LUNDOCGETKEY(LUNDOC,DBUF,MAXX,MAXY,IKEY,PLIST,NLIST,IRTFLG)
C
C    PURPOSE:    RECOVERS SPECIFIC LINE (KEY) FROM DBUF. DBUF HAS 
C                BEEN RECOVERED FROM DOC FILE PRIOR TO CALLING THIS
C                SUBROUTINE.
C
C    PARAMETERS:  LUNDOC  IO UNIT                                (SENT)
C                 DBUF    DATA ARRAY                             (RET.)
C                 MAXX    MAX X ARRAY DIMENSION                  (SENT)
C                 MAXY    MAX Y ARRAY DIMENSION                  (SENT)
C                 PLIST   LIST OF VALUES                         (RET.)
C                 NLIST   NUMBER OF VALUES IN PLIST          (SENT/RET.)
C                 WANTERRT  CALLERRT FLAG                        (SENT)
C                 IRTFLG  1=ERROR, 0 = NORMAL                    (RET.)
C
C--*********************************************************************


      SUBROUTINE LUNDOCGETKEY(LUNDOC,DBUF,MAXX,MAXY,IKEY,PLIST,NLIST,
     &                        WANTERRT,IRTFLG)

      INCLUDE 'CMBLOCK.INC' 

      DIMENSION         DBUF(*),PLIST(*)
      LOGICAL        :: WANTERRT

      CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

      IRTFLG = 1
      IF (IKEY > MAXY) THEN
C        KEY NOT FOUND IN DBUF
         IF (MYPID <= 0) WRITE(NOUT,90) IKEY
90       FORMAT('  *** KEY:',I7,'  NOT FOUND')
         IF (WANTERRT) CALL ERRT(100,'LUNDOCGETKEY',IDUM)
         RETURN

      ELSEIF (IKEY <= 0) THEN
         IF (MYPID <= 0) WRITE(NOUT,91) IKEY
91       FORMAT('  *** INVALID DOC FILE KEY REQUESTED: ',I7,/)
         IF (WANTERRT) CALL ERRT(100,'LUNDOCGETKEY',IDUM)
         RETURN
      ENDIF

C     FIND DBUF LOCATION POINTER
      ILOC = (IKEY - 1) * MAXX + 1

      NLISTGOT = DBUF(ILOC)
      IF (NLISTGOT <= 0) THEN
C        KEY NOT FOUND IN DBUF
         IF (WANTERRT) CALL ERRT(102,'EMPTY LINE FOR DOC FILE KEY',IKEY)
         RETURN
      ENDIF

      NLIST = MIN(NLIST,NLISTGOT)
      DO I = 1,NLIST
         PLIST(I) = DBUF(ILOC + I) 
      ENDDO
    
      IRTFLG = 0
      RETURN

      END

C     ------------------------- LUNDOCREDNXT -----------------------------
C
C    LUNDOCREDNXT(LUNDOC,IKEY,DLIST,NMAXDL,UNUSED,ICOUNT,IRTFLG)
C
C    PURPOSE:    SUBROUTINE TO RECOVER NEXT KEY LINE FROM A DOC FILE
C
C    PARAMETERS:  LUNDOC  IO UNIT                                (SENT)
C                 IKEY    NUMBER OF KEY                          (RET.)
C                 DLIST   ARRAY CONTAINING NUMBERS               (RET.)
C                 NMAXDL  MAX DLIST ARRAY DIMENSION              (SENT)
C                 UNUSED  UNUSED                                 (---)
C                 ICOUNT  NUMBER OF ELEMENTS RETURNED IN DLIST   (RET.)
C                 IRTFLG  1=ERROR                                (RET.)
C                         2=EOF                                  (RET.)
C
C   CALLER:       UNSDAL
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDNXT(LUNDOC,IKEY,DLIST,NMAXDL,
     &                        UNUSED,ICOUNT,IRTFLG)

      USE DOCIC_INFO

      INCLUDE 'CMBLOCK.INC'

      REAL, DIMENSION(*)          :: DLIST
      REAL, DIMENSION(:), POINTER :: IPQ
      LOGICAL                     :: WARNIT,WANTERRT

      ICOUNT = 0
      IKEY   = 0
      IRTFLG = 1

      IF (LUNDOC < 0) THEN
C        INCORE DOC FILE
         NIC    =  -LUNDOC
         IPQ    => LOCDOC(NIC)%IPT 
         MAXY   =  NUMKEYS(NIC)
         MAXXIC =  NUMCOLS(NIC) 
         IKEY   =  NEXTKEY(NIC)
         !write(6,*) ' lundoc; looking for: ',ikey

         DO WHILE (IKEY > 0 .AND. IKEY <= MAXY) 
            ILOC   = (IKEY - 1) * MAXXIC + 1
C           FIND NUMBER OF REGS. FOR THIS KEY
            ICOUNT = IPQ(ILOC)

            IF (ICOUNT > 0) THEN
C              FOUND FILLED KEY, MAKE SURE DLIST DOES NOT OVERFLOW
               ICOUNT = MIN(ICOUNT,NMAXDL)
C              FILL DLIST
               DO I= 1,ICOUNT
                  DLIST(I) = IPQ(ILOC+I)
               ENDDO
               NEXTKEY(NIC) = IKEY + 1  ! NEXT KEY TO BE CHECKED
               IRTFLG       = 0
               RETURN
            ENDIF
            IKEY = IKEY + 1
         ENDDO

         NEXTKEY(NIC) = 1         ! FOR SETTING IKEY ON NEXT ACCESS
         !write(6,*) ' lundoc; set nextkey(',nic,'): 1'
         IRTFLG       = 2
         RETURN
      ENDIF

C     REGULAR DOC FILE
      WARNIT   = .FALSE.
      WANTERRT = .FALSE.
      DO
C        READ NEXT LINE FROM DOC FILE
         CALL LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,.FALSE.,
     &                     DLIST,NMAXDL+1,0,IKEY,ICOUNT,IRTFLG)

         IF (IRTFLG < 0) THEN
C           END OF FILE, RETURN 2=NOT FOUND
            IRTFLG = 2
            RETURN

         ELSEIF (IRTFLG > 0) THEN
C           ERROR RETRIEVING PLIST FOR NEXT KEY
            RETURN
         ENDIF

         IF (ICOUNT > 0) THEN
C           HAVE RETRIEVED PLIST FOR NEXT KEY
            IRTFLG = 0
            RETURN
         ENDIF
      ENDDO

      END



C     ------------------------- LUNDOCINFO -----------------------------
C
C  LUNDOCINFO(NDOC,MAXKEYT,MAXREGT,KEYSINUSE,SAYIT,IRTFLG)
C
C  PURPOSE:  DETERMINES MAXKEY AND MAXREG INSIDE A DOCUMENT FILE. 
C
C  PARAMETERS:
C         NDOC          LOGICAL UNIT FOR DOC FILE                 (SENT)
C         MAXKEYT       NUMBER OF HIGHEST KEY                 (RETURNED)
C         MAXREGT       MAX. NUMBER OF REGISTERS PER LINE     (RETURNED)
C                       (THIS IS 1 LESS THAN COLS. NEEDED FOR
C                       RECOVERY WITH UNSDAL, ETC.)
C         KEYSINUSE     NUMBER OF USED KEYS                   (RETURNED)
C         SAYIT         FLAG TO ECHO NUMBERS                  (SENT)
C         IRTFLG        ERROR FLAG (O IS NORMAL RETURN)       (RETURNED)
C     
C--*********************************************************************

        SUBROUTINE LUNDOCINFO(NDOC,MAXKEYT,MAXREGT,KEYSINUSE,
     &                         SAYIT,IRTFLG)

        USE DOCIC_INFO

        INCLUDE 'CMBLOCK.INC' 

        INTEGER             :: NDOC,MAXKEYT,MAXREGT,KEYSINUSE,IRTFLG
        LOGICAL             :: SAYIT

        REAL, POINTER       :: IPQ(:)
        CHARACTER(LEN=80)   :: RECLIN  ! ONLY NEEDS START
        INTEGER             :: ICOMM,MYPID,MPIERR,NLET,IC,I

        INTEGER             :: lnblnk
        LOGICAL             :: EOF

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

        IRTFLG = 1

        IF (NDOC < 0) THEN
C         INCORE DOC. FILE ----------------------------------------

C         GET ARRAY SIZE FOR INCORE FILE (FIXED WHEN IT WAS CREATED)
          IC   = - NDOC
          IF (IC > MAXICDOCS) THEN
C            FILE LIST INDEX OUT OF RANGE
             CALL ERRT(102,'MAX. INCORE DOC. FILE. NUMBER',MAXICDOCS)
             RETURN
          ENDIF

C         FIND NUMBER OF REGISTERS 
          MAXCOLS = NUMCOLS(IC) 
          MAXREGT = MAXCOLS - 1
          MAXKEYS = NUMKEYS(IC)

C         FIND HIGHEST KEY NUMBER IN USE
          IPQ  => LOCDOC(IC)%IPT
 
          DO I = 1,MAXKEYS
             ILOC   = (I - 1) * MAXCOLS + 1
             ICOUNT = IPQ(ILOC)
             IF (ICOUNT > 0) THEN
                 MAXKEYT   = I
                 MAXREGT   = ICOUNT
                 KEYSINUSE = I
             ENDIF
          ENDDO
          IRTFLG = 0
          RETURN
        ENDIF

C       REGULAR DOC. FILE ----------------------------------------

C       WANT TO FIND MAXIMUM KEY & REGISTER NUMBER IN USE 

        MAXKEYT   = 0
        MAXREGT   = 0
        KEYSINUSE = 0

        DO WHILE (.TRUE.)

#ifdef USE_MPI
           IF (MYPID <= 0) THEN
              READ(NDOC,'(A80)',END=100,IOSTAT=IER) RECLIN

              IF (RECLIN(2:2) == ';' .OR. 
     &            RECLIN(1:2) == '; ' ) THEN
C                COMMENT LINE
                 CYCLE
              ENDIF

              BACKSPACE(NDOC)   ! REREAD LINE
              READ(NDOC,*,END=100,IOSTAT=IER) RECLIN

              EOF = .TRUE.    
              READ(NDOC,*,END=100,IOSTAT=IER) NKEY,NREGPLINE
              EOF = .FALSE.
           ENDIF

            
 100       CALL BCAST_MPI('LUNDOCINFO','EOF',EOF,1,'L',ICOMM)
           CALL BCAST_MPI('LUNDOCINFO','IER',IER,1,'I',ICOMM)
           IF (EOF) GOTO 799

           CALL BCAST_MPI('LUNDOCINFO','NKEY',NKEY,1,'I',ICOMM)
           CALL BCAST_MPI('LUNDOCINFO','NREGPLINE',NREGPLINE,1,
     &                    'I',ICOMM)
#else
           READ(NDOC,'(A80)',END=799,IOSTAT=IER) RECLIN
           IF (RECLIN(2:2) == ';' .OR. 
     &         RECLIN(1:2) == '; ') THEN
C             COMMENT LINE
              CYCLE
           ENDIF

           NLET = lnblnk(RECLIN)
           IF (NLET <= 0) THEN
C              BLANK LINE
               WRITE(NOUT,92) 
               CYCLE
           ENDIF

           BACKSPACE(NDOC)   ! REREAD LINE
           READ(NDOC,*,END=799,IOSTAT=IER) NKEY,NREGPLINE
           !write(6,*) 'ier,nkey,nregpline:',ier, nkey,nregpline,maxregt 
           
#endif

           IF (IER < 0) THEN
C             EOF ON READ
              EXIT

           ELSEIF (IER > 0) THEN
C             ERROR ON READ, TRY OLD DOC. FILE FORMAT
              BACKSPACE(NDOC)

              IF (MYPID <= 0) THEN
                 READ(NDOC,83,IOSTAT=IER) NKEY,NREGPLINE
              ENDIF
83            FORMAT(I6,I1)

#ifdef USE_MPI
              CALL BCAST_MPI('LUNDOCINFO','NKEY',NKEY,1,'I',ICOMM)
              CALL BCAST_MPI('LUNDOCINFO','NREGPLINE',NREGPLINE,1,
     &                       'I',ICOMM)
              CALL BCAST_MPI('LUNDOCINFO','IER',IER,1,'I',ICOMM)
#endif
           ENDIF

92        FORMAT('  WARNING; SKIPPING EMPTY LINE IN DOC FILE')
          IF (IER == 0) THEN
C             NOT A COMMENT LINE AND READS KEY & ICOUNT OK
              IF (NKEY < 0) THEN
                 WRITE(NOUT,90) 
90               FORMAT('  WARNING; CONTINUATION LINE IN DOC FILE')

              ELSEIF (NKEY == 0)THEN
                 WRITE(NOUT,91) 
91               FORMAT('  *** SKIPPING ILLEGAL KEY:0  IN DOC FILE')

              ELSEIF (NKEY > 0 .AND.  NREGPLINE == 0) THEN
                 WRITE(NOUT,92) 

              ELSE
C                REGULAR REGISTER LINE
                 IF (NKEY      > MAXKEYT) MAXKEYT = NKEY
                 IF (NREGPLINE > MAXREGT) MAXREGT = NREGPLINE
                 KEYSINUSE = KEYSINUSE + 1
              ENDIF

           ENDIF
        ENDDO

799     IF (SAYIT .AND. MYPID <= 0) then
              WRITE(NOUT,97) MAXREGT,KEYSINUSE,MAXKEYT
97         FORMAT('  Doc file has:',I4,'  registers and:',I6,
     &            ' keys,  Highest key in use:',I6,/)
        ENDIF

        IF (MYPID <= 0) REWIND(NDOC)

        IRTFLG = 0

        END



C     ------------------------- LUNDOCGETCOM -----------------------------
C
C    LUNDOCGETCOM(LUNDOC,IKEY,PLIST,NLIST,TILLEND,IRTFLG)
C
C    PURPOSE:    GET A SPECIFIED COMMENT KEY FROM FILE
C
C    PARAMETERS: NDOC    IO UNIT                                (SENT)
C                IKEY    COMMENT KEY WANTED (<0)                (SENT)
C                ILIST   ARRAY CONTAINING VALUES                (RET.)
C                NLIST   NUMBER OF ELEMENTS IN ARRAY       (SENT/RET.)
C                        MAX. MUST BE PROVIDED FROM CALLER
C                TILLEND FLAG TO KEEP READING TILL END          (SENT)
C                IRTFLG                                         (RET.)
C
C--*********************************************************************

        SUBROUTINE LUNDOCGETCOM(LUNDOC,IKEY,PLIST,NLIST,TILLEND,IRTFLG)

        INCLUDE 'CMBLOCK.INC' 

        REAL               :: PLIST(*)
        CHARACTER(LEN=180) :: RECLIN
        LOGICAL            :: TILLEND
        LOGICAL            :: ERRFILE, EOF

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

C       SET ERROR RETURN FLAG
        IRTFLG = 1

        IKEYA  = ABS(IKEY)
        IF (NLIST <= 0) THEN
           CALL ERRT(101,'*** NUMBER OF REGISTERS NOT SPECIFIED',NE)
           RETURN

        ELSEIF (IKEY > 0) THEN
           CALL ERRT(101,'*** DID NOT REQUEST COMMENT KEY',NE)
           RETURN

        ELSEIF (IKEY > 9999999) THEN
           CALL ERRT(102,'ILLEGAL COMMENT KEY NUMBER',IKEY)
           RETURN
        ENDIF

        ICOUNT = 0

C -------------------------------------------------------

C       READ NEXT LINE FROM DOC FILE
#ifdef USE_MPI
10      CONTINUE   
        IF (MYPID == 0) THEN
           ERRFILE = .TRUE.
           EOF     = .TRUE.
           READ (LUNDOC,81,ERR=100,END=200) RECLIN
81         FORMAT(A120)
           ERRFILE = .FALSE.
           EOF     = .FALSE. 
        ENDIF

100     CALL BCAST_MPI('LUNDOCGETCOM','ERRFILE',ERRFILE,1,'L',ICOMM)
        IF (ERRFILE) GOTO 998

200     CALL BCAST_MPI('LUNDOCGETCOM','EOF',EOF,1,'L',ICOMM)
        IF (EOF) GOTO 997

        CALL BCAST_MPI('LUNDOCGETCOM','RECLIN',RECLIN,180,'C',ICOMM)

#else
10      READ (LUNDOC,81,ERR=998,END=997) RECLIN
81      FORMAT(A)
#endif

        IF (RECLIN(2:2) == ';' .OR. RECLIN(1:2) == '; ' )THEN
C          COMMENT LINE FOUND, CHECK FOR COMMENTED KEY WITH ERR
           READ(RECLIN(3:),*,IOSTAT=IERR) KEYGOT,ICOUNTT
           IF (IERR .NE. 0) GOTO 10        ! NOT A COMMENT KEY LINE

C          MAKE SURE PLIST DOES NOT OVERFLOW
           ICOUNTT = MIN(ICOUNTT,NLIST)
           KEYGOTA = ABS(KEYGOT)

           IF (ICOUNTT > 0 .AND. KEYGOTA == IKEYA) THEN
C             READ THE COMMENT KEY DATA INTO PLIST
CCCC              READ(RECLIN(3:),*,ERR=50,END=998)IKEYDUM,ICOUNTDUM,
              READ(RECLIN(3:),*,ERR=50)IKEYDUM,ICOUNTDUM,
     &                                (PLIST(K),K=1,ICOUNTT)
              ICOUNT = ICOUNTT
           ENDIF

           IF (KEYGOTA == IKEYA .AND. .NOT. TILLEND) GOTO 997
        ENDIF

C       READ NEXT LINE OF DOC FILE
50      GOTO 10

C ---------------------------------------------------------------

997     IF (ICOUNT <= 0) THEN
C          END OF DOCUMENT FILE FOUND WITHOUT COMMENT KEY
           CALL ERRT(102,'COMMENT KEY NOT FOUND',IKEYA)
           RETURN
        
        ELSEIF (ICOUNT < NLIST) THEN
C          UNDERFLOW

           WRITE(NOUT,90) NLIST,ICOUNT
90         FORMAT('  *** WANTED: ',I3,' REGISTERS BUT ONLY GOT: ',I4/)
           CALL ERRT(100,'LUNDOCGETCOM',NE)
           NLIST  = ICOUNT
           RETURN

        ENDIF
        NLIST  = ICOUNT
        IRTFLG = 0

998     RETURN
        END


C     ------------------------- LUNDOCPUTCOM -----------------------------
C
C    LUNDOCPUTCOM(LUNDOC,COMMENT,IRTFLG)
C
C    PURPOSE:    PUT A TEXT COMMENT IN DOC. FILE (NOT A COMMENT KEY)
C
C    PARAMETERS: LUNDOC    DOC FILE I/O UNIT                      (SENT)
C                COMMENT   TEXT COMMENT                           (SENT)
C                IRTFLG    ERROR RETURN FLAG                      (RET.)
C
C--*********************************************************************

        SUBROUTINE LUNDOCPUTCOM(LUNDOC,COMMENT,IRTFLG)

        CHARACTER(LEN=*)  :: COMMENT

        INTEGER           :: LUNDOC,IRTFLG,ICOMM,MYPID,MPIERR,NC

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

        IF (LUNDOC <= 0) RETURN

        IF (MYPID <= 0) THEN
           NC = lnblnkn(COMMENT)

           WRITE(LUNDOC,94) COMMENT(1:NC)
94         FORMAT(' ; ',A)
        ENDIF

        END


C     ------------------------- LUNDOCSAYHDR -----------------------------
C
C    LUNDOCSAYHDR(LUNDOC,LUNPUT,IRTFLG)
C
C    PURPOSE:    SUBROUTINE TO ECHO FIRST ENT LINE FROM A DOC FILE
C
C    PARAMETERS:   LUNDOC  DOC FILE IO UNIT                      (SENT)
C    PARAMETERS:   LUNPUT  OUTPUT IO UNIT                        (SENT)
C                  IRTFLG                                        (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCSAYHDR(LUNDOC,LUNPUT,IRTFLG)

        CHARACTER *120 RECLIN

#ifdef USE_MPI
        include 'mpif.h'
        LOGICAL  :: EOF, ERRFILE

        ICOMM   = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
        MYPID = -1
#endif

        IRTFLG = 1
        IF (LUNDOC <= 0) RETURN

C -------------------------------------------------------
        
C       READ NEXT LINE FROM DOC FILE
#ifdef USE_MPI
10      IF (MYPID == 0) THEN
           ERRFILE = .TRUE.
           EOF     = .TRUE.
           READ (LUNDOC,81,ERR=100,END=100) RECLIN
           ERRFILE = .FALSE.
           EOF     = .FALSE.
        ENDIF

100     CALL BCAST_MPI('LUNDOCSAYHDR','EOF',EOF,1,'L',ICOMM)
        CALL BCAST_MPI('LUNDOCSAYHDR','ERRFILE',ERRFILE,1,'L',ICOMM)
        IF (EOF .OR. ERRFILE) GOTO 999

        CALL BCAST_MPI('LUNDOCSAYHDR','RECLIN',RECLIN,120,'C',ICOMM)
#else
10      READ (LUNDOC,81,ERR=999,END=999) RECLIN
#endif
81      FORMAT(A120)

        IF (RECLIN(2:2) == ';' .OR. RECLIN(1:2) == '; ')THEN
C          COMMENT LINE FOUND
           ILEN = LNBLNKN(RECLIN)
           IF (MYPID <= 0) WRITE(LUNPUT,*) RECLIN(1:ILEN)
           IRTFLG = 0
           GOTO 999
        ENDIF

C       READ NEXT LINE OF DOC FILE, UTIL WE GET COMMENT
        GOTO 10

C ---------------------------------------------------------------

999     IF (MYPID <= 0) REWIND(LUNDOC)
        RETURN
        END


@


1.111
log
@format 92 missing with  cpp options
@
text
@d41 1
d1263 1
d1324 1
a1324 1
              ENDFILE = .TRUE.    
d1326 1
a1326 1
              ENDFILE = .FALSE.
d1330 1
a1330 1
 100       CALL BCAST_MPI('LUNDOCINFO','ENDFILE',ENDFILE,1,'L',ICOMM)
d1332 1
a1332 1
           IF (ENDFILE) GOTO 799
d1440 1
d1470 1
a1470 1
           ENDFILE = .TRUE.
d1474 1
a1474 1
           ENDFILE = .FALSE. 
d1480 2
a1481 2
200     CALL BCAST_MPI('LUNDOCGETCOM','ENDFILE',ENDFILE,1,'L',ICOMM)
        IF (ENDFILE) GOTO 997
d1584 1
d1587 2
a1588 1
        LOGICAL ENDFILE, ERRFILE
d1594 1
d1604 1
a1604 1
           ENDFILE = .TRUE.
d1607 1
a1607 1
           ENDFILE = .FALSE.
d1610 1
a1610 1
100     CALL BCAST_MPI('LUNDOCSAYHDR','ENDFILE',ENDFILE,1,'L',ICOMM)
d1612 1
a1612 1
        IF (ENDFILE .OR. ERRFILE) GOTO 999
@


1.110
log
@NUMBER OF KEYS RECOVERED uppercased
@
text
@d40 1
d46 1
a46 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
a1346 1
92             FORMAT('  WARNING; SKIPPING EMPTY LINE IN DOC FILE')
d1377 1
@


1.109
log
@'  EMPTY DOC...
@
text
@d1053 1
a1053 1
91       FORMAT('  Number of keys recovered: ',I7)
@


1.108
log
@error with gfort in lundocinfo  if blank line
@
text
@d473 1
a473 1
     &         WRITE(NOUT,*)'  EMPTY DOCUMENT FILE LINE SKIPPED'
d478 1
a478 1
     &         WRITE(NOUT,*)'  CONTINUATION LINE SKIPPED IN DOC FILE'
@


1.107
log
@Doc file has:  msg shorter than before
@
text
@d91 1
a91 1
	   INCLUDE 'CMLIMIT.INC' 
d121 1
a121 1
C	           NLIST   NUMBER OF ELEMENTS IN ARRAY            (SENT)
a135 1
      CHARACTER(LEN=1)            :: ALIST
d143 1
a143 1
      IF (NLIST .LE. 0) RETURN
d150 1
a150 1
      IF (IKEY .EQ. 0) THEN
d155 1
a155 1
      ELSEIF (IKEY .LT. 0) THEN
d158 1
a158 1
         IF (LUNDOC .LE. 0) THEN
d165 1
a165 1
         IF (IKEYT .GT. 9999999) THEN
d171 1
a171 1
         ELSEIF (NLIST .GT. 9) THEN
d176 1
a176 1
         IF (MYPID .LE. 0) THEN
d182 1
a182 1
      ELSEIF (LUNDOC .GT. 0) THEN
d185 1
a185 1
         IF (NLIST .GT. 9 .OR. IKEY .GT. 999999) THEN
d187 1
a187 1
            IF (MYPID .LE. 0)
d191 1
a191 1
         ELSEIF (IKEY .LE. 99999) THEN
d193 1
a193 1
            IF (MYPID .LE. 0) THEN
d196 1
a196 1
               IF (MYPID .LE. 0) CALL FLUSHFILE(LUNDOC)
d199 1
a199 1
         ELSEIF (IKEY .LE. 999999) THEN
d201 1
a201 1
            IF (MYPID .LE. 0) THEN
d204 1
a204 1
               IF (MYPID .LE. 0) CALL FLUSHFILE(LUNDOC)
d208 1
a208 1
      ELSEIF (LUNDOC .LT. 0) THEN
d213 1
a213 1
         IF (IC .GT. MAXICDOCS) THEN
d221 1
a221 1
         IF (NLIST .GT. (MAXX - 1)) THEN
d227 1
a227 1
         ELSEIF (IKEY .GT. MAXY) THEN
d262 2
a263 2
C	           NLIST   NUMBER OF ELEMENTS IN ARRAY            (SENT)
C	           FORMOUT LINE OUTPUT FORMAT                     (SENT)
a282 1
      CHARACTER(LEN=1)            :: ALIST
d305 1
a305 1
         IF (LUNDOC .LE. 0) THEN
d329 1
a329 1
         IF (MYPID .LE. 0) THEN
d332 1
a332 1
            IF (MYPID .LE. 0) CALL FLUSHFILE(LUNDOC)
d340 1
a340 1
         IF (IC .GT. MAXICDOCS) THEN
d416 1
a416 1
      IF (MYPID .LE. 0) THEN
d419 1
a419 1
         IF (IERR .LT. 0) RECLIN(1:2) = '!!'
d430 1
a430 1
      IF (RECLIN(1:2) .EQ. '!!') THEN
d438 2
a439 2
       IF (RECLIN(2:2) .EQ. ';') RETURN
       IF (RECLIN(1:2) .EQ. '; ') RETURN  !BAD JWEB COMMENT LINE
d444 1
a444 1
       IF (IERR .GT. 0) THEN
d451 1
a451 1
          IF (IERR .GT. 0) THEN
d455 1
a455 1
                IF (NLET .LE. 0) THEN
d471 2
a472 2
       IF (ICOUNT .LE. 0) THEN
           IF (MYPID .LE. 0)
d476 2
a477 2
        ELSEIF (IKEY .LT. 0) THEN
           IF (MYPID .LE. 0)
d481 1
a481 1
        ELSEIF (IKEY .EQ. 0) THEN
d483 1
a483 1
           IF (MYPID .LE. 0)
d487 1
a487 1
        ELSEIF (MAXY .GT. 0 .AND. IKEY .GT. MAXY) THEN
d490 1
a490 1
               IF (MYPID .LE. 0)  WRITE(NOUT,93) MAXY
d511 1
a511 1
         IF (NEWFORM .AND. MYPID .LE. 0) THEN
d522 1
a522 1
         ELSEIF (.NOT. NEWFORM  .AND. MYPID .LE. 0) THEN
d537 1
a537 1
                IF (MYPID .LE. 0) WRITE(NOUT,94) RECLIN
d560 3
a562 3
C	           ICOUNT  NUMBER OF ELEMENTS IN ARRAY           (RET.)
C	           TILLEND KEEP READING TILL EOF EVEN IF FOUND   (SENT.)
C	           GOBACK  REWIND AND READ AGAIN IF NOT FOUND    (SENT)
d574 2
a575 3
      REAL,DIMENSION(NMAX)        :: DLIST
      CHARACTER(LEN=80)           :: RECLIN
      LOGICAL                     :: TILLEND,GOBACK,FIRST,NEWFORM
d577 1
a577 1
      REAL, DIMENSION(:), POINTER :: IPQ
d579 1
a579 1
      REAL,DIMENSION(NMAX)        :: DLISTT
d583 1
a583 1
      IF (IKEY .LT. 0) THEN
d589 1
a589 1
      ELSEIF (IKEY .EQ. 0) THEN
d594 1
a594 1
      ELSEIF (LUNDOC .LT. 0) THEN
d599 1
a599 1
         IF (IC .GT. MAXICDOCS) THEN
d609 1
a609 1
         IF (IKEY .GT. MAXY) THEN
d623 1
a623 1
         IF (ICOUNT .GT. 0) THEN
d647 1
a647 1
         IF (IRTFLG .LT. 0) THEN
d649 1
a649 1
            IF (ICOUNT .EQ. 0 .AND. GOBACK .AND. FIRST) THEN
d661 1
a661 1
            IF (ICOUNT .GT. 0) IRTFLG = 0
d664 1
a664 1
         ELSEIF (IRTFLG .GT. 0) THEN
d669 1
a669 1
         IF (IKEY .EQ. IKEYT) THEN
d710 1
a710 1
      IF (LUNDOC .LT. 0) THEN
d729 1
a729 1
         IF (IRTFLG .LT. 0) THEN
d733 1
a733 1
            !if (mypid .le.0) write(6,*) 'End of doc file, mpi barrier'
d738 1
a738 1
         ELSEIF (IRTFLG .GT. 0) THEN
d743 3
a745 3
         IF (ICOUNT .GT. 0 .AND. 
     &       (ICOUNT +2) .LE. MAXX .AND.
     &        IKEY .LE. MAXY) THEN
d784 1
a784 1
       IF (IC .GT. MAXICDOCS) THEN
d811 1
a811 1
          IF ((NGOTX+1) .LT. MAXX) THEN
d817 1
a817 1
       IF (NGOTY .LT. MAXY) THEN
a951 1
      CHARACTER(LEN=80)            :: RECLIN
d961 1
a961 1
      IF (LUNDOC .LT. 0) THEN
d965 1
a965 1
         IF (IC .GT. MAXICDOCS) THEN
d977 1
a977 1
         IF (IGOX .GT. IENDX .OR. IENDX .GT. (MAXXIC-1)) THEN
d981 1
a981 1
         ELSEIF (IGOY .GT. IENDYNOW) THEN
d992 1
a992 1
               IF (ICOUNT .LE. 0) CYCLE
d1001 1
a1001 1
               IF (ERRSKIP .AND. ICOUNT .LE. 0) THEN
d1026 1
a1026 1
            IF (IRTFLG .LT. 0) THEN
d1030 1
a1030 1
            ELSEIF (IRTFLG .GT. 0) THEN
d1036 1
a1036 1
     &         (IKEY .GE. IGOY .AND. IKEY .LE. IENDY)) THEN
d1051 1
a1051 1
999   IF (MYPID .LE. 0) THEN
d1056 1
a1056 1
      IF (KEEPKEYS .AND. ERRSKIP .AND. NGOTY .LT. NWANTY) THEN
d1097 1
a1097 1
      IF (IKEY .GT. MAXY) THEN
d1099 1
a1099 1
	 IF (MYPID .LE. 0) WRITE(NOUT,90) IKEY
d1104 2
a1105 2
      ELSEIF (IKEY .LE. 0) THEN
	 IF (MYPID .LE. 0) WRITE(NOUT,91) IKEY
d1115 1
a1115 1
      IF (NLISTGOT .LE. 0) THEN
d1142 1
a1142 1
C	          ICOUNT  NUMBER OF ELEMENTS RETURNED IN DLIST   (RET.)
d1165 1
a1165 1
      IF (LUNDOC .LT. 0) THEN
d1174 1
a1174 1
         DO WHILE (IKEY .GT. 0 .AND. IKEY .LE. MAXY) 
d1179 1
a1179 1
            IF (ICOUNT .GT. 0) THEN
d1207 1
a1207 1
         IF (IRTFLG .LT. 0) THEN
d1212 1
a1212 1
         ELSEIF (IRTFLG .GT. 0) THEN
d1253 8
a1260 4
        LOGICAL                     :: SAYIT
        REAL, DIMENSION(:), POINTER :: IPQ
        CHARACTER(LEN=80)           :: RECLIN
        LOGICAL                     :: ENDFILE
d1266 1
a1266 1
        IF (NDOC .LT. 0) THEN
d1271 1
a1271 1
          IF (IC .GT. MAXICDOCS) THEN
d1288 1
a1288 1
             IF (ICOUNT .GT. 0) THEN
d1309 1
a1309 1
           IF (MYPID .LE. 0) THEN
d1311 3
a1313 2
              IF (RECLIN(2:2) .EQ. ';' .OR. 
     &            RECLIN(1:2) .EQ. '; ' ) THEN
d1336 2
a1337 2
           IF (RECLIN(2:2) .EQ. ';' .OR. 
     &         RECLIN(1:2) .EQ. '; ') THEN
d1342 8
d1352 2
d1356 1
a1356 1
           IF (IER .LT. 0) THEN
d1360 1
a1360 1
           ELSEIF (IER .GT. 0) THEN
d1364 1
a1364 1
              IF (MYPID .LE. 0) THEN
d1368 1
d1377 1
a1377 1
          IF (IER .EQ. 0) THEN
d1379 1
a1379 1
              IF (NKEY .LT. 0) THEN
d1383 1
a1383 1
              ELSEIF (NKEY .EQ. 0)THEN
d1387 1
a1387 1
              ELSEIF (NKEY .GT. 0 .AND.  NREGPLINE .EQ. 0) THEN
a1388 1
92               FORMAT('  WARNING; SKIPPING EMPTY LINE IN DOC FILE')
d1392 2
a1393 2
                 IF (NKEY      .GT. MAXKEYT) MAXKEYT = NKEY
                 IF (NREGPLINE .GT. MAXREGT) MAXREGT = NREGPLINE
d1407 1
a1409 1
        RETURN            
d1423 1
a1423 1
C	         NLIST   NUMBER OF ELEMENTS IN ARRAY       (SENT/RET.)
d1425 1
a1425 1
C	         TILLEND FLAG TO KEEP READING TILL END          (SENT)
d1432 1
a1432 1
	INCLUDE 'CMBLOCK.INC' 
d1434 1
a1434 1
	REAL               :: PLIST(*)
a1436 1
        LOGICAL            :: ENDFILE, ERRFILE
d1441 1
a1441 1
	IRTFLG = 1
d1444 1
a1444 1
	IF (NLIST .LE. 0) THEN
d1446 1
a1446 1
	   RETURN
d1448 1
a1448 1
        ELSEIF (IKEY .GT. 0) THEN
d1450 1
a1450 1
	   RETURN
d1452 1
a1452 1
        ELSEIF (IKEY .GT. 9999999) THEN
d1454 1
a1454 1
	   RETURN
d1464 1
a1464 1
        IF (MYPID .EQ. 0) THEN
d1482 1
a1482 1
10	READ (LUNDOC,81,ERR=998,END=997) RECLIN
d1486 1
a1486 1
        IF (RECLIN(2:2) .EQ. ';' .OR. RECLIN(1:2) .EQ. '; ' )THEN
d1495 1
a1495 1
           IF (ICOUNTT .GT. 0 .AND. KEYGOTA .EQ. IKEYA) THEN
d1503 1
a1503 1
           IF (KEYGOTA .EQ. IKEYA .AND. .NOT. TILLEND) GOTO 997
d1511 1
a1511 1
997     IF (ICOUNT .LE. 0) THEN
d1516 1
a1516 1
        ELSEIF (ICOUNT .LT. NLIST) THEN
d1518 1
d1520 1
a1520 1
90	   FORMAT('  *** WANTED: ',I3,' REGISTERS BUT ONLY GOT: ',I4/)
d1530 1
a1530 1
	END
d1553 1
a1553 1
        IF (LUNDOC .LE. 0) RETURN
d1555 1
a1555 1
        IF (MYPID .LE. 0) THEN
d1562 1
a1562 1
	END
d1589 1
a1589 1
        IF (LUNDOC .LE. 0) RETURN
d1595 1
a1595 1
10      IF (MYPID .EQ. 0) THEN
d1598 1
a1598 1
	   READ (LUNDOC,81,ERR=100,END=100) RECLIN
d1613 1
a1613 1
        IF (RECLIN(2:2) .EQ. ';' .OR. RECLIN(1:2) .EQ. '; ')THEN
d1616 1
a1616 1
           IF (MYPID .LE. 0) WRITE(LUNPUT,*) RECLIN(1:ILEN)
d1626 1
a1626 1
999     IF (MYPID .LE. 0) REWIND(LUNDOC)
@


1.106
log
@added LUNDOCWRTDATF FORMAT
@
text
@d1389 1
a1389 1
799     IF (SAYIT .AND. MYPID .LE. 0) then
d1391 2
a1392 2
97         FORMAT('  Doc file contains: ',I4,'  registers and: ',I6,
     &            ' keys,  highest key in use: ',I6,/)
d1395 1
a1395 1
        IF (MYPID .LE. 0) REWIND(NDOC)
@


1.105
log
@LUNDOCREDLIN ; ERRT BUG, FORMAT(  1PG13.6)
@
text
@d39 1
d45 1
a45 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d68 1
d110 1
d248 131
@


1.104
log
@LUNDOCINFO ; / BUG
@
text
@d37 2
d176 1
a176 1
91          FORMAT(' ;',I8,1X,I1,1X,10000(1PG12.5,1X))
d187 1
a187 1
92             FORMAT(I10,' ',I4,10000(' ',1PG12.5))
d193 1
a193 1
93             FORMAT(I5,' ',I1,10000(' ',1PG12.5))
d201 1
a201 1
94             FORMAT(I6,' ',I1,10000(' ',1PG12.5))
d322 9
a330 3
                WRITE(NOUT,94) RECLIN
94              FORMAT('  *** UNABLE TO INTERPRET DOC FILE LINE: ',A)
                CALLERRT(100,'LUNDOCREDLIN',NE)
@


1.103
log
@added mpi barrier
@
text
@d5 1
a5 1
C                NCOL (MAX NO OF COLUMNS) ADDED   JUN 2000 BB
d36 1
d1115 1
a1115 1
        LOGICAL    ::                  SAYIT
d1117 4
a1121 8
#ifdef USE_MPI
        include 'mpif.h'
        LOGICAL ENDFILE
        ICOMM   = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
        MYPID = -1
#endif
d1165 1
d1168 10
d1182 2
d1192 8
d1284 1
d1286 1
a1286 8
#ifdef USE_MPI
      include 'mpif.h'
      LOGICAL ENDFILE, ERRFILE
      ICOMM   = MPI_COMM_WORLD
      CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
      MYPID = -1
#endif
@


1.102
log
@..GETCOM: READ (LUNDOC,81 strange 64 bit bug
@
text
@d35 1
d41 1
a41 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d568 2
d590 1
a590 1
C           END OF FILE
d592 4
@


1.101
log
@READ(RECLIN(3:),*,ERR=50)IKEYDUM
@
text
@d34 1
d1256 1
a1256 1
	DIMENSION          :: PLIST(*)
d1311 2
a1312 1
10	READ (LUNDOC,'A',ERR=998,END=997) RECLIN
a1314 1

d1342 1
a1342 3
           WRITE(NOUT,91) IKEYA
91	   FORMAT('  *** COMMENT KEY: ',I3,' NOT FOUND')
           CALL ERRT(100,'LUNDOCGETCOM',NE)
@


1.100
log
@END=998)IKEYDUM,ICOUNTDUM,
@
text
@d1325 3
a1327 2
              READ(RECLIN(3:),*,ERR=50,END=998)IKEYDUM,ICOUNTDUM,
     &                                        (PLIST(K),K=1,ICOUNTT)
@


1.99
log
@missing 81 in mpi code for format
@
text
@a1 1

d33 2
d1325 2
a1326 2
              READ(RECLIN(3:),*,ERR=50,END=998)(IKEYDUM,ICOUNTDUM,
     &                                        PLIST(K),K=1,ICOUNTT)
@


1.98
log
@comment keys longer
@
text
@d1295 1
@


1.97
log
@GPL_2010
@
text
@d32 2
d157 1
a157 1
         IF (IKEYT .GT. 999) THEN
d159 3
a161 2
90         FORMAT(' *** COMMENT KEY:',I5,' MUST BE IN RANGE -999...-1'/)
           CALL ERRT(101,'LUNDOCWRTDAT',IDUM)
d170 1
a170 1
91          FORMAT(' ;',I3,1X,I1,1X,10000(1PG12.5,1X))
d1254 4
a1257 3
	DIMENSION       PLIST(*)
        CHARACTER *180  RECLIN
        LOGICAL         TILLEND
d1279 2
a1280 3
        ELSEIF (IKEY .GT. 999) THEN
	   WRITE(NOUT,*) '*** ILLEGAL COMMENT KEY NUMBER: ',IKEY
           CALL ERRT(100,'LUNDOCGETCOM',NE)
d1308 1
a1308 1
10	READ (LUNDOC,81,ERR=998,END=997) RECLIN
d1310 1
a1310 1
81      FORMAT(A180)
d1314 2
a1315 2
           READ(RECLIN(1:80),82,ERR=50) KEYGOT,ICOUNTT
82         FORMAT(2X,I4,I1)
d1322 3
a1324 2
C             READ THE DATA INTO PLIST
              READ(RECLIN(8:120),*,ERR=50,END=998)(PLIST(K),K=1,ICOUNTT)
d1363 1
a1363 1
C    PURPOSE:    GET A SPECIFIED COMMENT KEY FROM FILE
d1365 3
a1367 3
C    PARAMETERS: LUNDOC  IO UNIT                                (SENT)
C                COMMENT                                        (SENT)
C                IRTFLG                                         (RET.)
d1373 3
a1375 1
        CHARACTER *(*)  COMMENT
d1382 3
a1384 2
           NCHAR = LNBLNKN(COMMENT)
           WRITE(LUNDOC,94) COMMENT(1:NCHAR)
a1387 3
        IRTFLG = 0

        RETURN
@


1.96
log
@LUNDOCPUTCOM FORMAT, MPI_SET
@
text
@d33 4
a36 2
C=* This file is part of:                                              * C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
d47 1
a47 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a48 1
C=*                                                                    *
@


1.95
log
@NEXTKEY
@
text
@d30 2
d33 4
a36 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
d38 1
a38 6
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d43 1
a43 1
C=* This program is distributed in the hope that it will be useful,    *
d49 1
a49 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
a57 1
C     ------------------------- LUNDOCPUTCOM -----------------------------
d69 1
d127 1
a127 7
#ifdef USE_MPI
      include 'mpif.h'
      ICOMM   = MPI_COMM_WORLD
      CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
      MYPID = -1
#endif
d271 2
a272 7
#ifdef USE_MPI
      include 'mpif.h'
      ICOMM  = MPI_COMM_WORLD
      CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
      MYPID = -1
#endif
d801 1
a801 7
#ifdef USE_MPI
      include 'mpif.h'
      ICOMM   = MPI_COMM_WORLD
      CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
      MYPID = -1
#endif
d941 2
a942 7
#ifdef USE_MPI
      include 'mpif.h'
      ICOMM   = MPI_COMM_WORLD
      CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
      MYPID = -1
#endif
d1369 2
a1370 7
#ifdef USE_MPI
        include 'mpif.h'
        ICOMM   = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
        MYPID = -1
#endif
d1374 5
a1378 2
        IF (MYPID .LE. 0) WRITE(LUNDOC,94) COMMENT
94      FORMAT(' ; ',A)
a1383 2


@


1.94
log
@READ(LUNDOC  bug
@
text
@d29 1
d32 1
a32 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d1006 1
a1006 1
C    LUNDOCREDNXT(LUNDOC,IKEY,DLIST,NMAX,ICOUNT,IRTFLG)
d1013 3
a1015 3
C                 NMAX    MAX DLIST ARRAY DIMENSION              (SENT)
C                 IGO     NEXT KEY TO BE USED                    (RET.)
C	          ICOUNT  NUMBER OF ELEMENTS IN ARRAY            (RET.)
d1023 2
a1024 1
      SUBROUTINE LUNDOCREDNXT(LUNDOC,IKEY,DLIST,NMAX,IGO,ICOUNT,IRTFLG)
a1031 1
      CHARACTER(LEN=180)          :: RECLIN
d1045 1
d1054 1
a1054 1
               ICOUNT = MIN(ICOUNT,NMAX)
d1059 1
a1059 2
               IGO          = IKEY + 1  ! NEXT KEY TO BE CHECKED
               NEXTKEY(NIC) = IGO
d1065 3
a1067 2
         IGO          = 0         ! RETURN VALUE
         NEXTKEY(NIC) = 0
d1078 1
a1078 1
     &                     DLIST,NMAX+1,0,IKEY,ICOUNT,IRTFLG)
@


1.93
log
@mpi changes
@
text
@d275 1
a275 1
      INTEGER, PARAMETER       :: LENRECLIN = 120
d337 1
a337 1
           IF (MYPID .LT. 1)
d342 1
a342 1
           IF (MYPID .LT. 1)
d348 1
a348 1
           IF (MYPID .LT. 1)
d355 1
a355 1
               IF (MYPID .LT. 1)  WRITE(NOUT,93) MAXY
d365 1
a365 1
         ICOUNT     = MIN(ICOUNT,MAXX-1)
d376 5
a380 5

         IF (NEWFORM) THEN
C            READ REGISTERS NOW USING NEW DOC. FILE FORMAT
             READ(RECLIN,*,IOSTAT=IERR)IKEYT,ICOUNTT,
     &                                (DBUF(ILOC+I),I=1,ICOUNT)
d383 3
a385 1
                NEWFORM = .FALSE.
d387 1
a387 3
         ENDIF

         IF (.NOT. NEWFORM) THEN
d389 2
a390 1
             READ(RECLIN,83,IOSTAT=IERR) IKEYT,ICOUNTT,
d393 5
@


1.92
log
@TOLERATES BAD COMMENT FROM JWEB
@
text
@d28 1
a131 1
      MPIERR = 0 
d185 1
a185 1
92          FORMAT(I10,' ',I4,10000(' ',1PG12.5))
d275 4
a278 3
      REAL,DIMENSION(*)    :: DBUF
      CHARACTER(LEN=80)    :: RECLIN
      LOGICAL              :: WARNIT,WANTERRT,NEWFORM,WANTICCOL
a281 1
      MPIERR = 0
d289 2
a290 1
84       FORMAT(A80)
d293 2
a294 10
      CALL MPI_BCAST(RECLIN,80,MPI_CHARACTER,0,ICOMM,MPIERR)
      IF (MPIERR .NE. 0) THEN
         WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST RECLIN '
         STOP
      ENDIF
      CALL MPI_BCAST(IERR,1,MPI_INTEGER,0,ICOMM,MPIERR)
      IF (MPIERR .NE. 0) THEN
         WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST MPIERR '
         STOP
      ENDIF
d301 1
a301 1
      IF (IERR .LT. 0) THEN
d304 1
d337 2
a338 1
           WRITE(NOUT,*) '  EMPTY DOCUMENT FILE LINE SKIPPED'
d342 2
a343 1
           WRITE(NOUT,*) '  CONTINUATION LINE SKIPPED IN DOC FILE'
d347 4
a350 3
C           KEY THAT WILL NOT FIT IN DBUF SENDS ERROR MSG.
            WRITE(NOUT,*)' ILLEGAL KEY NUMBER: 0  SKIPPED IN DOC FILE'
            RETURN
d353 3
a355 3
C           KEY THAT WILL NOT FIT IN DBUF SENDS ERROR MSG.
            IF (WARNIT) THEN 
               WRITE(NOUT,93) MAXY
d358 5
a362 5
            ENDIF
            IKEY   = 0
            ICOUNT = 0
            RETURN
         ENDIF
a375 2
C        REREAD THE INPUT LINE
         IF (MYPID .LE. 0) BACKSPACE(LUNDOC)
d378 3
a380 28
C            TRY NEW DOC. FILE FORMAT
             IF (MYPID .LE. 0) THEN
                READ(LUNDOC,*,IOSTAT=IERR)IKEYT,ICOUNTT,
     &                                    (DBUF(ILOC+I),I=1,ICOUNT)
             ENDIF
#ifdef USE_MPI
             CALL MPI_BCAST(IKEYT,1,MPI_INTEGER,0,ICOMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST IKEYT '
                STOP
             ENDIF
             CALL MPI_BCAST(ICOUNTT,1,MPI_INTEGER,0,ICOMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST IKEYT '
                STOP
             ENDIF
             CALL MPI_BCAST(DBUF(ILOC+1),ICOUNT,MPI_REAL,0,ICOMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST DBUF '
                STOP
             ENDIF
             CALL MPI_BCAST(IERR,1,MPI_INTEGER,0,ICOMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST IERR '
                STOP
             ENDIF
#endif
C            IF ERROR ON READ, TRY OLD DOC. FILE FORMAT
a382 1
                IF (MYPID .LE. 0) BACKSPACE(LUNDOC)
d388 3
a390 27
C            TRY OLD DOC. FILE FORMAT
             IF (MYPID .LE. 0) THEN
                READ(LUNDOC,83,IOSTAT=IERR) IKEYT,ICOUNTT,
     &                                      (DBUF(ILOC+I),I=1,ICOUNT)
             ENDIF
#ifdef USE_MPI
             CALL MPI_BCAST(IKEYT,1,MPI_INTEGER,0,ICOMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST IKEYT '
                STOP
             ENDIF
             CALL MPI_BCAST(ICOUNTT,1,MPI_INTEGER,0,ICOMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST IKEYT '
                STOP
             ENDIF
             CALL MPI_BCAST(DBUF(ILOC+1),ICOUNT,MPI_REAL,0,ICOMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST DBUF '
                STOP
             ENDIF
             CALL MPI_BCAST(IERR,1,MPI_INTEGER,0,ICOMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST IERR '
                STOP
             ENDIF
#endif
d396 1
a396 1
                WRITE(NOUT,94) RECLIN
a810 1
      MPIERR  = 0
a956 1
      MPIERR  = 0
a1122 1
        INTEGER MYPID, ICOMM, MPIERR
a1124 1
        MPIERR = 0
d1178 2
a1179 10
 100       CALL MPI_BCAST(ENDFILE,1,MPI_LOGICAL,0,ICOMM,MPIERR) 
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'LUNDOCINFO: FAILED TO BCAST ENDFILE '
              STOP
           ENDIF
           CALL MPI_BCAST(IER,1,MPI_INTEGER,0,ICOMM,MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'LUNDOCINFO: FAILED TO BCAST IER '
              STOP
           ENDIF
d1181 4
a1184 11
C
           CALL MPI_BCAST(NKEY,1,MPI_INTEGER,0,ICOMM,MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'LUNDOCINFO: FAILED TO BCAST NKEY '
              STOP
           ENDIF
           CALL MPI_BCAST(NREGPLINE,1,MPI_INTEGER,0,ICOMM,MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'LUNDOCINFO: FAILED TO BCAST NREGPLINE '
              STOP
           ENDIF
d1202 4
a1205 15
              CALL MPI_BCAST(NKEY,1,MPI_INTEGER,0,ICOMM,MPIERR)
              IF (MPIERR .NE. 0) THEN
                 WRITE(0,*) 'LUNDOCINFO: FAILED TO BCAST NKEY '
                 STOP
              ENDIF
              CALL MPI_BCAST(NREGPLINE,1,MPI_INTEGER,0,ICOMM,MPIERR)
              IF (MPIERR .NE. 0) THEN
                 WRITE(0,*) 'LUNDOCINFO: FAILED TO BCAST NREGPLINE '
                 STOP
              ENDIF
              CALL MPI_BCAST(IER,1,MPI_INTEGER,0,ICOMM,MPIERR)
              IF (MPIERR .NE. 0) THEN
                 WRITE(0,*) 'LUNDOCINFO: FAILED TO BCAST IER '
                 STOP
              ENDIF
a1271 1
      INTEGER MYPID, ICOMM, MPIERR
a1273 1
      MPIERR = 0 
d1311 2
a1312 6
C
100     CALL MPI_BCAST(ERRFILE,1,MPI_LOGICAL,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'LUNDOCGETCOM: FAILED TO BCAST ERRFILE'
           STOP
        ENDIF
d1315 1
a1315 5
200     CALL MPI_BCAST(ENDFILE,1,MPI_LOGICAL,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'LUNDOCGETCOM: FAILED TO BCAST ENDFILE'
           STOP
        ENDIF
d1317 3
a1319 6
C
        CALL MPI_BCAST(RECLIN,180,MPI_CHARACTER,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'LUNDOCGETCOM: FAILED TO BCAST RECLIN'
           STOP
        ENDIF
a1387 1
        INTEGER MYPID, ICOMM, MPIERR
a1388 1
        MPIERR = 0 
d1411 1
a1411 1
C    PURPOSE:    SUBROUTINE TO ECHO FIRST COMMENT LINE FROM A DOC FILE
a1425 1
        MPIERR  = 0
d1437 1
a1437 2
10      CONTINUE 
        IF (MYPID .EQ. 0) THEN
d1444 3
a1446 10
100     CALL MPI_BCAST(ENDFILE,1,MPI_LOGICAL,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'LUNDOCSAYHDR: FAILED TO BCAST ENDFILE'
           STOP
        ENDIF
        CALL MPI_BCAST(ERRFILE,1,MPI_LOGICAL,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'LUNDOCSAYHDR: FAILED TO BCAST ERRFILE'
           STOP
        ENDIF
d1448 2
a1449 6
C
        CALL MPI_BCAST(RECLIN,120,MPI_CHARACTER,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'LUNDOCSAYHDR: FAILED TO BCAST RECLIN'
           STOP
        ENDIF
@


1.91
log
@added nextkey() for UD SEL
@
text
@d27 1
d280 1
a280 1
      ICOMM   = MPI_COMM_WORLD
d289 1
d294 1
a294 1
         WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST RECLINE '
d299 1
a299 1
         WRITE(0,*) 'LUNDOCREDLIN: FAILED TO BCAST IERR '
a302 1
84    FORMAT(A80)
d316 1
d1423 1
a1423 1
        IF (RECLIN(2:2) .EQ. ';')THEN
d1568 1
a1568 1
        IF (RECLIN(2:2) .EQ. ';')THEN
@


1.90
log
@increased maxicdoc, added nextkey()
@
text
@d26 1
a26 1
C                LUNDOCREDNXT LOCDOC ARROW BUG    FEB 2007 ARDEAN LEITH
@


1.89
log
@UD SEL support
@
text
@d26 1
d83 1
a83 1
           INTEGER, PARAMETER :: MAXICDOCS = 10
d91 5
a95 4
           INTEGER,DIMENSION(MAXICDOCS) :: NUMCOLS
           INTEGER,DIMENSION(MAXICDOCS) :: NUMKEYS
           CHARACTER(LEN=MAXNAM)        :: OLDNAM(MAXICDOCS)
           INTEGER,DIMENSION(MAXICDOCS) :: NLETOLDNAM
d1062 1
a1062 1
C                 IGO     ?                                      (?)
d1092 1
a1092 1
         IKEY   =  IGO
d1106 3
a1108 2
               IGO    = IKEY + 1
               IRTFLG = 0
d1113 3
a1115 2
         IGO    = 0
         IRTFLG = 2
@


1.88
log
@sync write to stdout for MPI
@
text
@d25 1
a25 1
C
d28 1
a28 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d1086 5
a1090 5
         NIC    = -LUNDOC
         IPQ    = LOCDOC(NIC)%IPT 
         MAXY   = NUMKEYS(NIC)
         MAXXIC = NUMCOLS(NIC) 
         IKEY   = IGO
d1092 1
a1092 1
         DO WHILE (IKEY .LE. MAXY) 
d1099 1
a1099 1
               ICOUNT = MAX(ICOUNT,NMAX)
d1104 2
a1105 1
               IGO = IKEY + 1
@


1.87
log
@native named registers
@
text
@d1006 8
d1018 1
a1018 1
	 WRITE(NOUT,90) IKEY
d1024 1
a1024 1
	 WRITE(NOUT,91) IKEY
@


1.86
log
@GPL License fixed
@
text
@d24 1
a69 1
C     ------------------------- LUNDOCPARSE -----------------------------
a1314 101
C     ------------------------- LUNDOCPARSE -----------------------------
C
C    LUNDOCPARSE(CCHAR,COMOUT,IKEY,ILIST,ICOUNT,IRTFLG)
C
C    PURPOSE:    SUBROUTINE TO PARSE X10,10,X11,4 TYPE LINE WHERE
C                VALUES AFTER THE FIRST ARE ALL REFERENCES TO REGISTERS
C                AND ARE RETURNED IN ILIST AS RAW REGISTER NUMBERS 
C                (NOT INCREMENTED BY ONE FOR USE WITH PARAM YET)
C
C    PARAMETERS:   CCHAR   INPUT LINE                             (SENT)
C                  COMOUT  COMMENT INDICATOR                      (RET.)
C                  IKEY    NUMBER OF FIRST VALUE IN CCHAR         (RET.)
C                  ILIST   ARRAY REGISTER LIST                    (RET.)
C                  NMAX    MAX LENGTH OF ARRAY REGISTER LIST      (SENT)
C	           ICOUNT   NUMBER OF ELEMENTS IN ARRAY           (RET.)
C                  IRTFLG                                         (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCPARSE(CCHAR,COMOUT,IKEY,ILIST,NMAX,NLIST,IRTFLG)

      INCLUDE 'CMBLOCK.INC'

      DIMENSION      ILIST(*)
      CHARACTER *(*) CCHAR   
      CHARACTER * 1  CTEMP
      LOGICAL        COMOUT,ISCHAR       


C       PARSE REGISTER LINE, CHECK FOR ',' OR 'X' ---------------------
       
        IRTFLG = 1
        COMOUT = .FALSE.

C       CHECK IF FIRST ENTRY IS A REGISTER, INTEGER, OR COMMENT /
        ILEN = LNBLNKN(CCHAR)

C       FIND FIRST NON-BLANK, NON-COMMA CHAR IN CCHAR
        K = VERIFY(CCHAR(1:ILEN),', ')
        IF (K .LE. 0) THEN
           WRITE(NOUT,90) CCHAR(1:ILEN)
90         FORMAT('  *** UNABLE TO PARSE REGISTER LINE: ',A)
	   CALL ERRT(100,'LUNDOCPARSE',NE)
	   RETURN
        ENDIF

        CTEMP  = CCHAR(K:K)

        IF (CTEMP .EQ. '/') THEN
C          JUST WANT TO PUT A COMMENT IN THE DOC FILE.
           COMOUT = .TRUE.
           IRTFLG = 0
           RETURN

	ELSEIF (CTEMP .EQ. 'X') THEN
C         FIRST ENTRY IS A REGISTER. PUT REGISTER CONTENTS IN IKEY
          
C         FIND THE REGISTER NUMBER
          CALL REGPARSE(CCHAR(K:),IREG,IGOR,IGO,.TRUE.,IER)
          IF (IER .NE. 0) THEN
	     WRITE(NOUT,90) CCHAR(1:ILEN)
	     CALL ERRT(100,'LUNDOCPARSE',NE)
             RETURN
          ENDIF

C         PUT REGISTER CONTENTS IN IKEY, PARAM IS IREG + 1 !!
C         IKEY = PARAM(IREG+1)
          CALL REG_GET(IREG,FKEY,.TRUE.,IERR)
	  IKEY = FKEY
          IGO  = IGO + K + 1

	ELSEIF (ISCHAR(CTEMP)) THEN
C          FIRST ENTRY IS A OLD DO LOOP INDEX, PUT ITS VALUE INTO IKEY.
           CALL INDEXTOREG(CTEMP,.TRUE.,IDUM,IKEY)
           IGO = K + 2

        ELSE
C          FIRST ENTRY IS A ,NUMBER. SO PUT THE NUMBER IN IKEY.
           NCHAR = INDEX(CCHAR(K:),',') - 1
           READ(CCHAR(K:K+NCHAR-1),*,IOSTAT=IER) IKEY

           IF (IER .NE. 0) THEN
	      WRITE(NOUT,90) CCHAR(1:ILEN)
	      CALL ERRT(100,'LUNDOCPARSE',NE)
              RETURN
           ENDIF
           IGO = K + NCHAR + 1
        ENDIF

        IF (IKEY .EQ. 0) THEN
	   CALL ERRT(101,'*** INVALID KEY NUMBER: 0',NE)
	   RETURN
        ENDIF

C       FIND THE DATA REGISTER NUMBER(S) (NOT ASDJUSTED BY +1)
        CALL CHKSTR(CCHAR(IGO:ILEN),ILEN-IGO+1,'IT',ILIST,DUM,NMAX,
     &               NLIST,IRTFLG)
        IF (IRTFLG .NE. 0) CALL ERRT(16,'LUNDOCPARSE',NE)
         
        RETURN
        END
@


1.85
log
@HRI GPL License used
@
text
@a3 1
C++************************************************************************
a25 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d29 1
a29 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a48 6

C * COPYRIGHT (C)1985, 2005. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.84
log
@removed debug output
@
text
@d3 1
d28 24
@


1.83
log
@LUNDOCSAYHDR MYPID BUG
@
text
@d110 1
a110 2
      INTEGER MYPID, COMM, MPIERR
      COMM   = MPI_COMM_WORLD
d112 1
a112 1
      CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d260 1
a260 2
      INTEGER MYPID, COMM, MPIERR
      COMM   = MPI_COMM_WORLD
d262 1
a262 1
      CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d271 1
a271 1
      CALL MPI_BCAST(RECLIN,80,MPI_CHARACTER,0,COMM,MPIERR)
d276 1
a276 1
      CALL MPI_BCAST(IERR,1,MPI_INTEGER,0,COMM,MPIERR)
d368 1
a368 1
             CALL MPI_BCAST(IKEYT,1,MPI_INTEGER,0,COMM,MPIERR)
d373 1
a373 1
             CALL MPI_BCAST(ICOUNTT,1,MPI_INTEGER,0,COMM,MPIERR)
d378 1
a378 1
             CALL MPI_BCAST(DBUF(ILOC+1),ICOUNT,MPI_REAL,0,COMM,MPIERR)
d383 1
a383 1
             CALL MPI_BCAST(IERR,1,MPI_INTEGER,0,COMM,MPIERR)
d404 1
a404 1
             CALL MPI_BCAST(IKEYT,1,MPI_INTEGER,0,COMM,MPIERR)
d409 1
a409 1
             CALL MPI_BCAST(ICOUNTT,1,MPI_INTEGER,0,COMM,MPIERR)
d414 1
a414 1
             CALL MPI_BCAST(DBUF(ILOC+1),ICOUNT,MPI_REAL,0,COMM,MPIERR)
d419 1
a419 1
             CALL MPI_BCAST(IERR,1,MPI_INTEGER,0,COMM,MPIERR)
d844 3
a846 4
      INTEGER MYPID, COMM, MPIERR
      COMM   = MPI_COMM_WORLD
      MPIERR = 0
      CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d1148 1
a1148 1
        INTEGER MYPID, COMM, MPIERR
d1150 1
a1150 1
        COMM   = MPI_COMM_WORLD
d1152 1
a1152 1
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
a1197 2
          rewind(ndoc)

d1205 1
a1205 1
 100       CALL MPI_BCAST(ENDFILE,1,MPI_LOGICAL,0,COMM,MPIERR) 
d1210 1
a1210 1
           CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
d1217 1
a1217 1
           CALL MPI_BCAST(NKEY,1,MPI_INTEGER,0,COMM,MPIERR)
d1222 1
a1222 1
           CALL MPI_BCAST(NREGPLINE,1,MPI_INTEGER,0,COMM,MPIERR)
d1228 1
a1228 5
        write(6,*) 'READING: NKEY,NREGPLINE'
C           READ(NDOC,*,END=799,IOSTAT=IER) NKEY,NREGPLINE
           READ(NDOC,*,IOSTAT=IER) NKEY,NREGPLINE
        write(6,*) 'IER: ',IER,NKEY,NREGPLINE

a1232 1
              write(6,*) 'EOF ON READ'
a1237 1
        write(6,*) 'IER: backspaced '
a1242 2
        write(6,*) 're IER: ',IER,NKEY,NREGPLINE

d1244 1
a1244 1
              CALL MPI_BCAST(NKEY,1,MPI_INTEGER,0,COMM,MPIERR)
d1249 1
a1249 1
              CALL MPI_BCAST(NREGPLINE,1,MPI_INTEGER,0,COMM,MPIERR)
d1254 1
a1254 1
              CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
d1270 1
a1270 1
91               FORMAT('  *** SKIPPING ILLEGAL KEY: 0  IN DOC FILE')
d1426 1
a1426 1
      INTEGER MYPID, COMM, MPIERR
d1428 1
a1428 1
      COMM   = MPI_COMM_WORLD
d1430 1
a1430 1
      CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d1468 1
a1468 1
100     CALL MPI_BCAST(ERRFILE,1,MPI_LOGICAL,0,COMM,MPIERR)
d1475 1
a1475 1
200     CALL MPI_BCAST(ENDFILE,1,MPI_LOGICAL,0,COMM,MPIERR)
d1482 1
a1482 1
        CALL MPI_BCAST(RECLIN,180,MPI_CHARACTER,0,COMM,MPIERR)
d1555 2
a1556 2
        INTEGER MYPID, COMM, MPIERR
        COMM   = MPI_COMM_WORLD
d1558 1
a1558 1
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
a1590 1

d1594 2
a1595 2
        ICOMM  = MPI_COMM_WORLD
        MPIERR = 0
a1599 1

@


1.82
log
@lundocredalli overflow bug fixed
@
text
@d23 1
d1201 2
d1233 5
a1237 1
           READ(NDOC,*,END=799,IOSTAT=IER) NKEY,NREGPLINE
d1242 1
d1248 1
d1254 2
d1283 1
a1283 1
91               FORMAT('  *** SKIPPING ILLEGAL KEY:0  IN DOC FILE')
d1604 1
a1606 1
        INTEGER MYPID, COMM, MPIERR
d1608 1
a1608 1
        COMM   = MPI_COMM_WORLD
d1610 3
a1612 1
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d1614 1
d1630 1
a1630 1
100     CALL MPI_BCAST(ENDFILE,1,MPI_LOGICAL,0,COMM,MPIERR)
d1635 1
a1635 1
        CALL MPI_BCAST(ERRFILE,1,MPI_LOGICAL,0,COMM,MPIERR)
d1642 1
a1642 1
        CALL MPI_BCAST(RECLIN,120,MPI_CHARACTER,0,COMM,MPIERR)
@


1.81
log
@ overlength line 1270
@
text
@d4 1
a4 1
C                NEW                              APR   99 ARDEAN LEITH
d6 4
a9 4
C                NCOL (MAX NO OF COLUMNS) ADDED   JUNE  00 BB
C                REMOVED CONTINUATION LINES       JULY  00 ARDEAN LEITH
C                LUNDOCREDALL PARAMETERS          DEC   00 ARDEAN LEITH
C                CALL INDEXTOREG                  MAR   01 ARDEAN LEITH
d22 1
d26 1
a26 1
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
d41 1
d683 2
a684 2
       NGOTX = MIN(MAXX,MAXXIC-1)
       WRITE(NOUT,91) NGOTX-1 
@


1.80
log
@*** empty log message ***
@
text
@d1270 1
a1270 1
91               FORMAT('  *** SKIPPING ILLEGAL KEY:0  LINE IN DOC FILE')
@


1.79
log
@IF (MYPID .LE. 0) duplicated
@
text
@d197 1
a197 1
95          FORMAT(' *** NUMBER OF REGISTERS: ',I3)
d203 1
a203 1
96          FORMAT(' *** KEY:',I10)
d310 1
a310 1
94              FORMAT(' *** UNABLE TO INTERPRET DOC FILE LINE: ',A)
d485 1
a485 1
90       FORMAT(' WARNING; RETRIEVING ILLEGAL KEY NUMBER: 0')
d504 1
a504 1
96          FORMAT(' *** KEY:',I10)
d683 1
a683 1
91     FORMAT(' Number of incore registers recovered: ',I10)
d687 1
a687 1
90     FORMAT(' Number of incore keys recovered: ',I10)
d994 1
a994 1
90       FORMAT(' *** KEY:',I7,'  NOT FOUND')
d1000 1
a1000 1
91       FORMAT(' *** INVALID DOC FILE KEY REQUESTED: ',I7,/)
d1270 1
a1270 1
91               FORMAT(' *** SKIPPING ILLEGAL KEY:0  LINE IN DOC FILE')
d1339 1
a1339 1
90         FORMAT(' *** UNABLE TO PARSE REGISTER LINE: ',A)
d1518 1
a1518 1
91	   FORMAT(' *** COMMENT KEY: ',I3,' NOT FOUND')
d1525 1
a1525 1
90	   FORMAT(' *** WANTED: ',I3,' REGISTERS BUT ONLY GOT: ',I4/)
@


1.78
log
@mpi
@
text
@d153 1
a153 1
            IF (MYPID .LE. 0) CALL FLUSHFILE(LUNDOC)
@


1.77
log
@ouput line formating for: Number of incore ...
@
text
@d107 4
a110 3
      integer mypid, comm, ierr
      comm = MPI_COMM_WORLD
      call MPI_COMM_RANK(comm, mypid, ierr)
d112 1
a112 1
      mypid = -1
d153 1
a153 1
            IF (MYPID .EQ. 0) CALL FLUSHFILE(LUNDOC)
d161 2
a162 1
            WRITE(LUNDOC,92) IKEY,NLIST,(DLIST(K),K=1,NLIST)
d170 1
a170 1
               IF (MYPID .EQ. 0) CALL FLUSHFILE(LUNDOC)
d178 1
a178 1
               IF (MYPID .EQ. 0) CALL FLUSHFILE(LUNDOC)
d256 9
d266 15
a280 1
      READ(LUNDOC,84,IOSTAT=IERR) RECLIN
a303 1

d358 1
a358 1
         BACKSPACE(LUNDOC)
d362 26
a387 2
             READ(LUNDOC,*,IOSTAT=IERR)IKEYT,ICOUNTT,
     &                                 (DBUF(ILOC+I),I=1,ICOUNT)
d391 1
a391 1
                BACKSPACE(LUNDOC)
d398 26
a423 2
             READ(LUNDOC,83,IOSTAT=IERR) IKEYT,ICOUNTT,
     &                                   (DBUF(ILOC+I),I=1,ICOUNT)
d683 1
a683 1
91     FORMAT('  Number of incore registers recovered: ',I10)
d687 1
a687 1
90     FORMAT('  Number of incore keys recovered: ',I10)
d843 4
a846 3
      integer mypid, comm, ierr
      comm = MPI_COMM_WORLD
      call MPI_COMM_RANK(comm, mypid,  IERR)
d848 1
a848 1
      mypid = -1
d1148 5
a1152 3
        integer mypid, comm, ierr
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid,  IERR)
d1154 1
a1154 1
        mypid = -1
d1199 29
d1229 1
d1239 3
a1241 1
              READ(NDOC,83,IOSTAT=IER) NKEY,NREGPLINE
d1243 17
d1286 1
a1286 1
799     IF (SAYIT .AND. mypid .le. 0) then
d1292 1
a1292 1
        REWIND(NDOC)
d1424 10
d1458 30
d1489 1
d1553 9
d1565 1
a1565 1
        WRITE(LUNDOC,94) COMMENT
d1593 5
a1597 3
        integer mypid, comm, ierr
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid, ierr)
d1605 29
a1633 1
10	READ (LUNDOC,81,ERR=999,END=999) RECLIN
d1639 1
a1639 7
#ifdef USE_MPI
           if (mypid .eq. 0) then
              WRITE(LUNPUT,*) RECLIN(1:ILEN)
           endif
#else
           WRITE(LUNPUT,*) RECLIN(1:ILEN)
#endif
d1649 1
a1649 1
999     REWIND(LUNDOC)
@


1.76
log
@undefined LONDOC & NOUT fixed
@
text
@d611 1
a611 1
91     FORMAT(' Number of incore registers recovered: ',I10)
d615 1
a615 1
90     FORMAT(' Number of incore keys recovered: ',I10)
@


1.75
log
@lundocredalli bug
@
text
@d99 1
d988 1
a988 1
         NIC    = -LONDOC
@


1.74
log
@1 file only failed in lundocredlin
@
text
@d21 1
d593 1
a593 1
       REAL,DIMENSION(*) ::          DBUF
d620 3
a622 4
          DO IREG = 1,NGOTX
             ILOCI       = (IKEY - 1) * MAXXIC + IREG
             ILOCD       = ILOCD + 1
             DBUF(ILOCD) = IPQ(ILOCI)
d625 3
a627 6
          IF (NGOTX .LT. MAXX) THEN
C            FILL REST OF LINE WITH ZEROS
             DO IREG = NGOTX,MAXX
                ILOCD       = ILOCD + 1
                DBUF(ILOCD) = 0.0
             ENDDO
d631 1
a631 1
       IF (ILOCD .LT. (MAXY*MAXX)) THEN
d633 1
a633 3
          DO K = ILOCD,MAXY*MAXX
             DBUF(K) = 0.0
          ENDDO
@


1.73
log
@lundocgetcom bug
@
text
@d233 1
d307 1
a307 1
        ELSEIF (MAXY .GT. 1 .AND. IKEY .GT. MAXY) THEN
d462 1
d464 1
a464 1
     &                     DLISTT,NMAX+1,1,IKEYT,ICOUNTT,IRTFLG)
d849 1
d851 1
a851 1
     &                     PLIST,MAXX+1,1,IKEY,ICOUNT,IRTFLG)
d1024 1
d1026 1
a1026 1
     &                     DLIST,NMAX+1,1,IKEY,ICOUNT,IRTFLG)
@


1.72
log
@lundocgetcom retrieval bug
@
text
@d20 1
d1339 1
@


1.71
log
@lundocgetcom plist overflow
@
text
@d1329 1
a1329 1
82         FORMAT(2X,I4,I1,10000F12.6)
d1337 1
a1337 2
              READ(RECLIN(1:120),82,ERR=50,END=998) 
     &            IDUM,ICOUNT,(PLIST(K),K=1,ICOUNTT)
@


1.70
log
@bad zeroing in lundocredall
@
text
@d19 1
d1338 1
a1338 1
     &            IDUM,ICOUNT,(PLIST(K),K=1,ICOUNT)
@


1.69
log
@bug in lundocredall (stops after 5 keys)
@
text
@d552 3
a554 2
         IF (ICOUNT .GT. 0 .AND. ICOUNT .LT. (MAXX-1) .AND.
     &       IKEY .LE. MAXY) THEN
d556 1
a556 1
             DBUF(ICOUNT+1:MAXX,IKEY) = 0.0
@


1.68
log
@bad lundocredall results for single line doc file
@
text
@d555 1
a555 1
             DBUF(IKEY,ICOUNT+1:MAXX ) = 0.0
@


1.67
log
@NMAX error in lundocrednxt & lundocreddat
@
text
@d218 1
a218 1
C    LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,DBUF,MAXX,MAXY,
d222 1
a222 1
C                IN DBUF DBUF KEEPS KEY IN FIRST COLUMN.
d231 1
d241 1
a241 1
      SUBROUTINE LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,
d248 1
a248 1
      LOGICAL              :: WARNIT,WANTERRT,NEWFORM
d319 1
a319 1
         IF (MAXY .GT. 1) THEN
d459 1
a459 1
         CALL LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,
d520 2
a521 2
      REAL,DIMENSION(*)    :: DBUF
      LOGICAL              :: WARNIT,WANTERRT
d535 1
a535 3
      DO  I=1, MAXX * MAXY, MAXX
         DBUF(I) = 0.0
      ENDDO
d539 1
a539 1
         CALL LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,
d554 2
a555 8
C           ZERO REMAINING VALUES IN REGISTER LIST FOR THIS LINE

C           FIND DBUF LOCATION POINTER
            ILOC= (IKEY -1) * MAXX + 1

            DO I = ICOUNT + 1,MAXX-1
               DBUF(ILOC+I) = 0.0
            ENDDO
d844 1
a844 1
            CALL LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,
d1018 1
a1018 1
         CALL LUNDOCREDLIN(LUNDOC,WANTERRT,WARNIT,
@


1.66
log
@lundocreddat bug
@
text
@d422 1
d432 1
a432 1
         ILOC    = (IKEY - 1) * MAXX + 1
d992 6
a997 4
         NIC  = -LONDOC
         IPQ  = LOCDOC(NIC)%IPT 
         MAXY = NUMKEYS(NIC)
         IKEY = IGO
d1000 1
a1000 1
            ILOC   = (IKEY - 1) * MAXREG + 1
d1021 1
d1026 1
a1026 1
     &                     DLIST,MAXX+1,1,IKEY,ICOUNT,IRTFLG)
d1029 1
a1029 1
C           END OF FILE
d1034 1
a1034 1
C           ERROR RETRIEVING PLIST
d1039 1
a1039 1
C           HAVE RETRIEVED PLIST
@


1.65
log
@lundocinfo new fmt. bug
@
text
@d394 2
d458 1
a458 1
     &                     DLIST,NMAX+1,1,IKEYT,ICOUNTT,IRTFLG)
d485 1
@


1.64
log
@format for lundoc still had runons
@
text
@d1123 1
a1123 1
           IF (IERR .LT. 0) THEN
d1127 1
a1127 1
           ELSEIF (IERR .GT. 0) THEN
d1131 1
a1131 1
              READ(NDOC,83,IOSTAT=IERR) NKEY,NREGPLINE
@


1.63
log
@(1PG12.5),' ') always on write
@
text
@d157 1
a157 1
92          FORMAT(I10,' ',I4,' ',10000(1PG12.5),' ')
d163 1
a163 1
93             FORMAT(I5,' ',I1,' ',10000(1PG12.5),' ')
d171 1
a171 1
94             FORMAT(I6,' ',I1,' ',10000(1PG12.5),' ')
@


1.62
log
@new file format
@
text
@d160 1
a160 1
C           WRITE FIRST LINE OF REGISTERS WITH KEY (I5)
d163 1
a163 1
93             FORMAT(I5,' ',I1,' ',10000(1PG11.4),' ')
d168 1
a168 1
C           WRITE FIRST LINE OF REGISTERS WITH KEY (I6)
d172 1
a172 2
               ELSE
              IF (MYPID .EQ. 0) CALL FLUSHFILE(LUNDOC)
@


1.61
log
@>10 reg
@
text
@d18 2
d32 1
a97 1
      INTEGER, PARAMETER          :: NCOL = 200
d106 2
d110 2
a112 1
      IRTFLG = 0
a116 1
      ALIST = CHAR(NLIST+48)
d120 3
a122 2
      IF (NLIST .GT. NCOL) THEN 
         CALL ERRT(101,'NO CONTINUATION LINES IN DOC FILES NOW',IDUM)
d125 1
a125 4
      ELSEIF (IKEY .EQ. 0) THEN
C        WANT TO CREATE ILLEGAL KEY NUMBER
         CALL ERRT(101,'CAN NOT CREATE DOC. FILE KEY: 0',IDUM)
         RETURN
d127 1
a127 2
      ELSEIF (IKEY .LT. 0 .AND. LUNDOC .GT. 0) THEN
C        WANT TO CREATE COMMENT KEY IN DISK DOC. FILE ----------------
d140 3
d145 5
a149 9
#ifdef USE_MPI
         if (mypid .eq. 0) then
            WRITE(LUNDOC,91) IKEYT,ALIST,(DLIST(K),K=1,NLIST)
            call flushfile(LUNDOC)
         endif
#else
         WRITE(LUNDOC,91) IKEYT,ALIST,(DLIST(K),K=1,NLIST)
#endif
91       FORMAT(' ;',I3,' ',A1,10000(1PG12.5))
d154 12
a165 5
         IF (IKEY .GT. 999999) THEN
            WRITE(NOUT,92) IKEY
92          FORMAT(' *** KEY:',I10,' MUST BE < 1000000'/)
            CALL ERRT(100,'LUNDOCWRTDAT',IDUM)
            RETURN
d167 9
a175 11
         ELSEIF (IKEY .LT. 100000) THEN
C           WRITE FIRST LINE OF REGISTERS  (I5)
#ifdef USE_MPI
            if (mypid .eq. 0) then
            WRITE(LUNDOC,93) IKEY,ALIST,(DLIST(K),K=1,NLIST)
            call flushfile(LUNDOC)
            endif
#else
            WRITE(LUNDOC,93) IKEY,ALIST,(DLIST(K),K=1,NLIST)
#endif
93          FORMAT(I5,1X,A1,10000(1PG12.5))
a176 12
         ELSE
C           WRITE FIRST LINE OF REGISTERS (I6)
#ifdef USE_MPI
            if (mypid .eq. 0) then
            WRITE(LUNDOC,94) IKEY,ALIST,(DLIST(K),K=1,NLIST)
            call flushfile(LUNDOC)
            endif
#else
            WRITE(LUNDOC,94) IKEY,ALIST,(DLIST(K),K=1,NLIST)
#endif
94          FORMAT(I6,A1,10000(1PG12.5))
         ENDIF
d217 146
d389 4
a392 3
      REAL,DIMENSION(NMAX)        ::  DLIST(*)
      CHARACTER(LEN=180)          ::  RECLIN
      LOGICAL                     ::  TILLEND,GOBACK,FIRST
a393 1
      CHARACTER                   :: CCOUNTT,CDUM
d450 17
a466 3
      ICOUNT = 0
      FIRST  = .TRUE.
C     ---------------------------------------------------------------
d468 2
a469 2
10    READ(LUNDOC,80,END=999,ERR=998) RECLIN
80    FORMAT(A180)
d471 4
a474 2
C     IGNORE COMMENT LINES (COMMENT KEYS ARE PROCESSED ABOVE). 
      IF (RECLIN(2:2) .EQ. ';') GOTO 10
d476 4
a479 12
      READ(RECLIN,82,END=998,ERR=998) IKEYT,CCOUNTT       
82    FORMAT(I6,A1,10000F12.6)
      ICOUNTT = ICHAR(CCOUNTT) - 48

C     KEEP READING TILL KEY PROCESSED OR EOF
      IF (IKEYT .LT. 0) THEN
         WRITE(NOUT,91) 
91       FORMAT(' WARNING; CONTINUATION LINE SKIPPED IN DOC FILE')

      ELSEIF (IKEYT .EQ. IKEY) THEN
C        MAY HAVE DUPLICATES OF KEY SO MUST ZERO ICOUNT AGAIN HERE
         ICOUNT = 0
d481 3
a483 2
C        MAKE SURE DLIST DOES NOT OVERFLOW
         ICOUNT = MIN(ICOUNTT,NMAX)
d485 3
a487 4
         IF (ICOUNT .GT. 0) THEN
C           VALUES WILL FIT IN DLIST
            READ(RECLIN,82,END=998,ERR=998) IDUM,CDUM,
     &                         (DLIST(J),J=1,ICOUNT)
d489 1
a489 17
      ENDIF

C     IF "TILLEND' OR IKEY NOT FOUND, KEEP READING TILL EOF
      IF (ICOUNT .EQ. 0 .OR. TILLEND) GOTO 10

      IF (ICOUNT .EQ. 0 .AND. GOBACK .AND. FIRST) THEN
C        REWIND AND START AGAIN
         REWIND(LUNDOC)
         FIRST = .FALSE.
         GOTO 10
      ENDIF

C     ---------------------------------------------------------------

      IRTFLG = 0
998   IF (TILLEND) REWIND(LUNDOC)
      RETURN
a490 6

C     RETURN 2 ON EOF ONLY IF DID NOT FIND KEY
999   IRTFLG = 2
      IF (ICOUNT .GT. 0) IRTFLG = 0
      RETURN

a492 1

d516 2
a517 4
      DIMENSION          DBUF(*)
      CHARACTER(LEN=180) :: RECLIN
      CHARACTER(LEN=1)   :: CCOUNTT,CDUM
      LOGICAL            :: WARNIT,WANTERRT
a534 3
      MAXXM1  = MAXX - 1
      WARNIT  = .TRUE.

d536 3
a538 1
C     ---------------------------------------------------------------
d540 4
a543 2
11    READ(LUNDOC,80,END=997,ERR=998) RECLIN
80    FORMAT(A180)
d545 4
a548 2
C     IGNORE COMMENT LINES & COMMENT KEY LINES. 
      IF (RECLIN(2:2) .EQ. ';') GOTO 11
d550 3
a552 4
      READ(RECLIN,82,END=998,ERR=998) IKEYT,CCOUNTT         
82    FORMAT(I6,A1,10000F12.6)
      ICOUNTT = ICHAR(CCOUNTT) - 48
      ICOUNT  = MIN(ICOUNTT,MAXXM1)
d554 2
a555 4
      IF (ICOUNT .LE. 0) THEN
         WRITE(NOUT,90) 
90       FORMAT(' WARNING; EMPTY DOCUMENT FILE LINE SKIPPED')
         GOTO 11
d557 3
a559 17
       ELSEIF (IKEYT .LT. 0) THEN
         WRITE(NOUT,91) 
91       FORMAT(' WARNING; CONTINUATION LINE SKIPPED IN DOC FILE')
         GOTO 11

       ELSEIF (IKEYT .EQ. 0) THEN
C        KEY THAT WILL NOT FIT IN DBUF SENDS ERROR MSG.
         WRITE(NOUT,92) 
92       FORMAT(' ILLEGAL KEY NUMBER: 0 NOT RETRIEVED')
         GOTO 11

      ELSEIF (IKEYT .GT. MAXY) THEN
C        KEY THAT WILL NOT FIT IN DBUF SENDS ERROR MSG.
         IF (WARNIT) THEN 
            WRITE(NOUT,93) MAXY
93          FORMAT('  KEYS GREATER THAN: ',I7,' NOT RETRIEVED')
            WARNIT = .FALSE.
d561 2
a562 21
         GOTO 11
       ENDIF

C      FIND DBUF LOCATION POINTER
       ILOC       = (IKEYT -1) * MAXX + 1
       DBUF(ILOC) = ICOUNT
         
       READ(RECLIN,82,END=998,ERR=998) IDUM,CDUM,
     &                 (DBUF(J),J=ILOC+1,ILOC+ICOUNT)

      IF (IKEYT .GT. 0 .AND. ICOUNT .LT. MAXXM1) THEN
C        ZERO REMAINING VALUES IN REGISTER LIST FOR THIS LINE
         DO I = ICOUNT + 1,MAXX-1
             DBUF(ILOC+I) = 0.0
         ENDDO
      ENDIF
      NGOT = MAX(NGOT,IKEYT)

      GOTO 11 

C     ----------------------------------------------------------------
a563 8
997   IRTFLG = 0
998   IF (IRTFLG .NE. 0 .AND. WANTERRT) THEN
         WRITE(NOUT,94) RECLIN
94       FORMAT(' **** UNABLE TO INTERPRET DOC FILE LINE: ', A)
         CALLERRT(100,'LUNDOCREDALL',NE)
      ENDIF
      RETURN

a763 2
      INTEGER, PARAMETER           :: NCOL = 200

d766 1
a766 1
      REAL, DIMENSION(NCOL)        :: PLIST
d768 1
d770 2
a771 3
      CHARACTER(LEN=180)           :: RECLIN
      CHARACTER(LEN=1)             :: CCOUNTT,CDUM

d845 14
a858 2
C        LOOP UNTIL EOF  REACHED
         DO WHILE (.TRUE.)
d860 6
a865 2
            READ(LUNDOC,80,END=999) RECLIN
80          FORMAT(A)
d867 4
a870 25
C           IGNORE COMMENT LINES 
            IF (RECLIN(2:2) .EQ. ';') CYCLE
       
            READ(RECLIN,82) IKEYT,CCOUNTT       
82          FORMAT(I6,A1,10000F12.6)
            ICOUNT = ICHAR(CCOUNTT) - 48

            READ(RECLIN,82,END=999,IOSTAT=IER)IKEY,CDUM,
     &                                     (PLIST(J),J=1,ICOUNT)

            IF (IER .EQ. 0) THEN
C              IGNORES COMMENT LINES & COMMENT KEY LINES

               IF (ICOUNT > 0 .AND.
     &            (IKEY .GE. IGOY .AND. IKEY .LE. IENDY)) THEN
C                 ONLY RETRIEVE REGISTERS FROM KEYS: IGOY...IENDY
                  MAXGOTY = MAX(MAXGOTY,IKEY)
                  NGOTY   = NGOTY + 1
                  IF (.NOT. KEEPKEYS) IKEY = NGOTY

                  IF (USEINT) THEN
                     ILIST(1:NGOTX,IKEY) = PLIST(IGOX:IENDX)
                  ELSE
                     DLIST(1:NGOTX,IKEY) = PLIST(IGOX:IENDX)
                  ENDIF
a953 2


d964 1
a980 1
      CHARACTER                   :: CCOUNTT,CDUM
d982 1
d1011 3
a1013 2
         IGO = 0
         GOTO 999
d1016 5
a1020 3
      DO WHILE (ICOUNT .LE. 0)
         READ(LUNDOC,80,END=999,IOSTAT=IER) RECLIN
80       FORMAT(A)
d1022 4
a1025 17
C        IGNORE COMMENT LINES 
         IF (RECLIN(2:2) .EQ. ';') CYCLE
       
         READ(RECLIN,82,END=999,IOSTAT=IER) IKEYT,CCOUNTT
82       FORMAT(I6,A1,10000F12.6)
         ICOUNTT = ICHAR(CCOUNTT) - 48

         IF (IER .EQ. 0) THEN
C           NOT A COMMENT LINE

            IF (IKEYT .LE. 0) THEN
               WRITE(NOUT,91) IKEY
91             FORMAT(' *** WARNING, DOC. FILE HAS BAD KEY: ',I7)

            ELSEIF (ICOUNTT .LE. 0) THEN
               WRITE(NOUT,92) 
92             FORMAT(' *** WARNING; SKIPPING EMPTY LINE IN DOC FILE')
d1027 4
a1030 3
            ELSE
C             REGULAR REGISTER LINE, PROHIBIT OVERFLOW
              ICOUNT = MIN(ICOUNTT,NMAX)
d1032 5
a1036 6
              BACKSPACE(LUNDOC)
              READ(LUNDOC,80,END=999,IOSTAT=IER) RECLIN
              READ(RECLIN,82,IOSTAT=IER)IKEY,CDUM,
     &                                     (DLIST(J),J=1,ICOUNT)
           ENDIF
        ENDIF
a1038 8
      IRTFLG = 0
      RETURN


C     RETURN 2 ON EOF
999   IRTFLG = 2
      RETURN

d1076 2
d1122 13
a1134 2
           READ(NDOC,81,END=799,IOSTAT=IER) NKEY,NREGPLINE
81         FORMAT(I6,I1)
d1136 2
a1137 2
           IF (IER .EQ. 0) THEN
C             NOT A COMMENT LINE
d1140 1
a1140 1
90               FORMAT(' WARNING; CONTINUATION LINE IN DOC FILE')
d1148 1
a1148 1
92               FORMAT(' WARNING; SKIPPING EMPTY LINE IN DOC FILE')
d1160 1
a1160 4
799     IF (SAYIT) THEN

#ifdef USE_MPI
           if (mypid .eq. 0) then
a1161 4
           endif
#else
           WRITE(NOUT,97) MAXREGT,KEYSINUSE,MAXKEYT
#endif
@


1.60
log
@cosmetic output
@
text
@d250 3
a252 3
      REAL,DIMENSION(NMAX) ::  DLIST(*)
      CHARACTER(LEN=120)   ::  RECLIN
      LOGICAL              ::  TILLEND,GOBACK,FIRST
d254 1
d316 1
a316 1
80    FORMAT(A120)
d321 3
a323 2
      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT       
82    FORMAT(I6,I1,10000F12.6)
d339 1
a339 1
            READ(RECLIN,82,END=998,ERR=998) IDUM,IDUM,
d393 2
a394 1
      CHARACTER(LEN=120) :: RECLIN
d420 1
a420 1
80    FORMAT(A120)
d425 3
a427 2
      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT         
82    FORMAT(I6,I1,10000F12.6)
d460 1
a460 1
       READ(RECLIN,82,END=998,ERR=998) IDUM,IDUM,
d511 1
a511 1
      REAL, DIMENSION(:), POINTER :: IPQ
d690 3
d698 2
d769 11
a779 1
            READ(LUNDOC,82,END=999,IOSTAT=IER)IKEY,ICOUNT,
a780 1
82          FORMAT(I6,I1,10000F12.6)
d801 2
a802 3
#ifdef USE_MPI
 999  continue
      if (mypid .eq. 0) then
d804 2
a805 5
      endif
#else
999   WRITE(NOUT,91) NGOTY 
#endif
91    FORMAT('  Number of keys recovered: ',I7)
d908 3
d943 9
a951 2
         READ(LUNDOC,82,END=999,IOSTAT=IER) IKEYT,ICOUNTT
82       FORMAT(I6,I1,10000F12.6)
d969 2
a970 1
              READ(LUNDOC,82,END=999,IOSTAT=IER)IKEY,IDUM,
d1235 1
a1235 1
        CHARACTER *120  RECLIN
d1262 1
a1262 1
81      FORMAT(A120)
d1266 1
a1266 1
           READ(RECLIN(1:80),82,ERR=50,END=997) KEYGOT,ICOUNTT
@


1.59
log
@mpi
@
text
@d446 1
a446 1
93          FORMAT(' KEYS GREATER THAN: ',I7,' NOT RETRIEVED')
@


1.58
log
@mpi
@
text
@d103 1
a103 1
      call MPI_COMM_RANK(comm, mypid,  IERR)
d144 1
d165 1
d177 1
d625 1
a625 1
C                NGOTY      NUMBER OF FILLED KEYS IN DLIST       (RET.)
a685 1

a688 1
c
d690 1
a690 3
      call MPI_COMM_RANK(comm, mypid, ierr)
#else
      mypid = -1
d783 8
a790 2

999   IF (mypid .LE. 0) WRITE(NOUT,91) NGOTY 
d1329 6
a1334 1

d1347 5
d1353 1
@


1.57
log
@doc ren bug in lundocredslc call
@
text
@d684 10
d785 1
a785 1
999   WRITE(NOUT,91) NGOTY 
@


1.56
log
@mpi
@
text
@d613 1
a613 1
C    LUNDOCREDSEQ(LUNDOC,DLIST,MAXX,MAXY,NGOTY,IRTFLG)
d627 2
a628 1
      SUBROUTINE LUNDOCREDSEQ(LUNDOC,DLIST,MAXX,MAXY,NGOTY,IRTFLG)
a629 1
      IWANTY = MAXY
@


1.55
log
@icountt bug
@
text
@d99 7
d141 5
d147 1
d161 5
d167 1
d172 5
d178 1
d976 6
d1054 5
d1060 1
@


1.54
log
@ier on lundocreednxt wrong
@
text
@d292 1
a292 1
      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNT       
d905 1
a905 1
              READ(LUNDOC,82,END=999,IOSTAT=IER)IKEY,ICOUNT,
@


1.53
log
@IGO  = IGO + K + 1 in lundocparse
@
text
@d292 1
a292 1
      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT        
d364 1
a364 1
      LOGICAL ::            WARNIT,WANTERRT
d396 1
a397 2
      ICOUNT = MIN(ICOUNTT,MAXXM1)

a853 1
 
d889 1
a889 1
         IF (IER .NE. 0) THEN
d905 1
a905 1
              READ(LUNDOC,82,END=999,IOSTAT=IER)IKEY,ICOUNTT,
@


1.52
log
@doc ren bug
@
text
@d17 1
a17 1
C
a1054 1

d1105 1
a1105 1
          IGO  = IGO + 2
@


1.51
log
@icound inj lundocredslc wrong!!
@
text
@d734 2
a735 2
               IF (ICOUNT >0 .AND.
     &            IKEY .GE. IGOY .AND. IKEY .LE. IENDY) THEN
d1009 1
a1009 1
              ELSEIF (NREGPLINE .EQ. 0)THEN
d1015 1
a1015 1
                 IF (NKEY       .GT. MAXKEYT) MAXKEYT = NKEY
@


1.50
log
@error in lundocredslc
r
@
text
@d734 2
a735 5
               IF (ICOUNT .LT. 1) THEN
                  CALL ERRT(102,'MISSING REGISTER(S) FOR KEY',IKEY)
                  RETURN

               ELSEIF (IKEY .GE. IGOY .AND. IKEY .LE. IENDY) THEN
@


1.49
log
@updates for IC use, nCOL > 100
@
text
@d734 1
a734 1
               IF (ICOUNT .LT. IENDX) THEN
@


1.48
log
@fixed
@
text
@d94 3
a96 3
      REAL, DIMENSION(*)  ::         DLIST
      INTEGER, PARAMETER  ::         NCOL = 50
      CHARACTER(LEN=1) ::            ALIST
d135 1
a135 1
91       FORMAT(' ;',I3,' ',A1,50(1PG12.5))
d149 1
a149 1
93          FORMAT(I5,1X,A1,50(1PG12.5))
d154 1
a154 1
94          FORMAT(I6,A1,50(1PG12.5))
d293 1
a293 1
82    FORMAT(I6,I1,9F12.6)
d395 1
a395 1
82    FORMAT(I6,I1,9F12.6)
d652 1
a652 1
      INTEGER, PARAMETER   ::         NCOL = 100
d655 4
a658 4
      REAL,DIMENSION(MAXX,MAXY) ::    DLIST
      REAL, DIMENSION(NCOL) ::        PLIST
      LOGICAL             ::          USEINT,KEEPKEYS,ERRSKIP
      REAL, DIMENSION(:), POINTER ::  IPQ
d693 1
a693 1
            IKEYT  = IKEY
d697 1
a697 1
               IF (IPQ(ILOCIC) .LE. 0) CYCLE
d706 1
a706 1
               IF (ERRSKIP .AND. ILIST(1,IKEYT) .LE. 0) THEN
d710 1
d715 1
a715 1
               ILIST(IGOX:IENDX,IKEYT) = IPQ(ILOCIC:ILOCIC+NGOTX-1)
d717 1
a717 1
               DLIST(IGOX:IENDX,IKEYT) = IPQ(ILOCIC:ILOCIC+NGOTX-1)
d729 1
a729 1
82          FORMAT(I6,I1,100F12.6)
d741 2
a742 4
                  NGOTY     = NGOTY + 1
                  IF (.NOT. KEEPKEYS) THEN
                     IKEY = NGOTY
                  ENDIF
d755 1
a755 1
91    FORMAT(' Number of keys recovered: ',I7)
d757 2
a758 3
      IF (KEEPKEYS .and. ERRSKIP .AND. NGOTY .LT. NWANTY) THEN
         MISSING = NWANTY - NGOTY
         CALL ERRT(102,'MISSING KEYS',MISSING)
d892 1
a892 1
82       FORMAT(I6,I1,100F12.6)
d1010 1
a1010 1
91               FORMAT('*** SKIPPING ILLEGAL KEY:0  LINE IN DOC FILE')
d1196 1
a1196 1
82         FORMAT(2X,I4,I1,9F12.6)
@


1.47
log
@removed LUNDOCREDANGS (defective)
@
text
@d681 3
a683 2
         IF (IGOX .LT. IENDX .OR. IENDX .GT. (MAXXIC-1)) THEN
            CALL ERRT(102,'REGISTER(S) OUTSIDE INCORE AREA',IENDX)
d686 2
a687 2
         ELSEIF (IGOY .LT. IENDY .OR. IENDY .GT. MAXYIC) THEN
            CALL ERRT(102,'KEY(S) OUTSIDE INCORE AREA',IENDY)
d691 1
a691 1
         DO IKEY = IGOY,IENDY
d710 1
d1029 4
a1032 3
           WRITE(NOUT,97) MAXREGT, MAXKEYT,KEYSINUSE
97         FORMAT(' Doc file contains: ',I3,'  registers and: ',I7,
     &            ' keys,  with: ',I7,' keys in use',/)
@


1.46
log
@*** empty log message ***
@
text
@a558 26
C     ------------------------- LUNDOCREDANGS -----------------------------
C
C    LUNDOCREDANGS(LUNDOC,ILIST,DLIST,MAXY,NGOTY,MAXGOTY,IRTFLG)
C
C    PURPOSE:    RECOVER COLUMNS 1-3 OF DOC FILE AS REAL NUMBERS. IN
C                AN ARRAY. RETURNS NUMBER OF FILLED KEYS AND HIGHEST 
C                KEY THAT IS FILLED.
C                
C    PARAMETERS: LUNDOC     I/O UNIT                            (SENT)
C                ILIST      SELECTION LIST                      (SENT)
C                DLIST      DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                MAXY       ARRAY Y DIMENSION (LINES)           (SENT)
C                NGOTY      NUMBER OF FILLED KEYS IN LIST       (RET.)
C                MAXGOTY    HIGHEST FILLED KEY IN LIST          (RET.)
C                IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDANGS(LUNDOC,ILIST,DLIST,MAXY,
     &                        NGOTY,MAXGOTY,IRTFLG)

      CALL LUNDOCREDSLC(LUNDOC,.TRUE.,ILIST,DLIST, 3,MAXY,
     &    .TRUE.,.TRUE.,1,3, 1,MAXY, NGOTY,MAXGOTY,IRTFLG)

      RETURN
      END
@


1.45
log
@lowercased
@
text
@d559 27
d731 1
a731 1
               IF (ERRSKIP .AND. ILIST(1,IKEYT) .NE. IKEYT) THEN
@


1.44
log
@sdocic changes
@
text
@d496 1
a496 1
91     FORMAT(' NUMBER OF INCORE REGISTERS RECOVERED: ',I10)
d500 1
a500 1
90     FORMAT('NUMBER OF INCORE KEYS RECOVERED: ',I10)
d753 1
a753 1
91    FORMAT('NUMBER OF KEYS RECOVERED: ',I7)
d1027 2
a1028 2
97         FORMAT('  DOC FILE CONTAINS: ',I3,'  REGISTERS AND: ',I7,
     &            ' KEYS,  WITH: ',I7,' KEYS IN USE',/)
@


1.43
log
@icount changed
@
text
@d67 1
d980 3
a982 2
                 MAXKEYT = I
                 MAXREGT = ICOUNT
d985 1
a985 1

d993 2
a994 2
        MAXKEYT = 0
        MAXREGT = 0
@


1.42
log
@sd ic related changes
@
text
@d603 1
d605 1
a605 1
     &    .FALSE.,.FALSE. ,1,MAXX, 1,99999999, NGOTY,MAXGOTY,IRTFLG)
d616 2
a617 1
C             KEEPKEYS, ERRSKIP,IGOX,IENDX, IGOY,IENDY, NGOTY,IRTFLG)
@


1.41
log
@*** empty log message ***
@
text
@d64 1
a64 1
           INTEGER,DIMENSION(MAXICDOCS) :: NUMREGS
d166 1
a166 1
         MAXX = NUMREGS(IC)
d265 1
a265 1
         ICOUNT  = MIN(NUMREGS(IC),ICOUNT,NMAX)
d426 1
a426 1
       DBUF(ILOC) = IKEYT
d491 1
a491 1
       MAXXIC = NUMREGS(IC) 
d493 1
a493 1
       NGOTX = MIN(MAXX,MAXXIC)
d673 1
a673 1
         MAXXIC = NUMREGS(IC) 
d776 1
d783 1
a783 1
      SUBROUTINE LUNDOCGETKEY(LUNDOC,DBUF,MAXX,MAXY,IKEY,PLIST,
d789 1
a789 1
      LOGICAL           WANTERRT
a799 1
C        INVALID KEY 
d809 2
a810 2
      IKEYT = DBUF(ILOC)
      IF (IKEYT .NE. IKEY) THEN
d812 1
a812 2
	 WRITE(NOUT,90) IKEY
         IF (WANTERRT) CALL ERRT(100,'LUNDOCGETKEY',IDUM)
d816 2
a817 1
      DO I = 1,MAXX-1
a862 1
         MAXX = NUMREGS(NIC)
d926 1
a926 1
C  LUNDOCINFO(NDOC,MAXKEYT,MAXREGT,KEYUSED,SAYIT,IRTFLG)
d936 1
a936 1
C         KEYUSED       NUMBER OF USED KEYS                   (RETURNED)
d942 2
a943 1
        SUBROUTINE LUNDOCINFO(NDOC,MAXKEYT,MAXREGT,KEYUSED,SAYIT,IRTFLG)
d966 3
a968 1
          MAXREGT = NUMREGS(IC)
d973 2
a974 2
          DO I = 1,NUMKEYS(IC)
             ILOC   = (I - 1) * MAXX + 1
d976 4
a979 1
             IF (ICOUNT .GT. 0) MAXKEYT = I
d991 1
a991 1
        KEYUSED = 0
d997 1
a997 1
           IF (IER .NE. 0) THEN
d1015 1
a1015 1
                 KEYUSED = KEYUSED + 1
d1022 2
a1023 2
           WRITE(NOUT,97) MAXREGT, MAXKEYT,KEYUSED
97         FORMAT('  DOC FILE CONTAINS: ',I2,'  REGISTERS AND: ',I7,
@


1.40
log
@spelling
@
text
@d55 1
a55 1
C          ARRAY OF POINTERS TO DOCUMENT STORAGES
d66 1
a66 1
           CHARACTER(LEN=MAXNAM)        ::  OLDNAM(MAXICDOCS)
a67 2
           INTEGER                      :: LASTKEY 

d183 1
a183 2

         IPQ(ILOC) = IKEY
d260 3
d264 2
a265 1
         ICOUNT = MIN(NUMREGS(IC),NMAX)
d267 2
a268 6
         IPQ       => LOCDOC(IC)%IPT
         ILOC      = (IKEY - 1) * MAXX + 1
         KEYGOT    = IPQ(ILOC)

         IF (KEYGOT .EQ. IKEY) THEN
c           KEY AVAILABLE IN INCORE DOC. FILE
a275 1
            ICOUNT = 0
d565 1
a565 1
C                KEY THAT IS FILLED.
d587 1
a587 1
C    LUNDOCREDSEQ(LUNDOC,ILIST,MAXX,MAXY,NGOTY,MAXGOTY,IRTFLG)
d589 3
a591 3
C    PURPOSE:    RECOVER COLUMN 1 OF DOC FILE AS INTEGER NUMBERS IN
C                AN ARRAY. RETURNS NUMBER OF FILLED KEYS AND HIGHEST 
C                KEY THAT IS FILLED.
d594 1
a594 1
C                ILIST      DATA ARRAY (MUST ALREADY EXIST)     (RET.)
d596 1
a596 1
C                NGOTY      NUMBER OF FILLED KEYS IN LIST       (RET.)
d692 1
a692 1
               IF (IPQ(ILOCIC) .NE. IKEY) CYCLE
d846 3
a848 1
      SUBROUTINE LUNDOCREDNXT(LUNDOC,IKEY,DLIST,NMAX,ICOUNT,IRTFLG)
d852 2
a853 1
      REAL, DIMENSION(*) ::   DLIST
d860 25
a884 2
         CALL ERRT(102,'INCORE FILES NOT SUPPORTED IN LUNDOCREDNXT',NE)
         RETURN
d973 2
a974 2
             KEYGOT = IPQ(ILOC)
             IF (KEYGOT  .EQ. IKEY) MAXKEYT = KEYGOT
@


1.39
log
@incore support for opendoc, etc.
@
text
@d48 1
d50 22
d156 1
a156 1

d227 1
d263 1
a263 1
 C       MAKE SURE DLIST DOES NOT OVERFLOW
d482 2
a483 1
       REAL,DIMENSION(*) ::  DBUF
d583 1
a583 1
     &    .FALSE.,.FALSE. ,1,1, 1,MAXY,NGOTY,MAXGOTY.IRTFLG)
d608 1
a608 1
     &    .FALSE.,.FALSE. ,1,MAXX, 1,99999999, NGOTY,MAXGOTY.IRTFLG)
d646 1
a646 1
     &    KEEPKEYS,ERRSKIP,IGOX,IENDX, IGOY,IENDY, NGOTY,MAXGOTY.IRTFLG)
d658 1
d927 2
a928 1
        LOGICAL    ::     SAYIT
d967 1
a967 1
           READ(RECLIN,81,END=799,IOSTAT=IER) NKEY,NREGPLINE
@


1.38
log
@lundocredsel ngot bug
@
text
@d2 1
d4 1
a4 1
C                NEW APRIL 99 ARDEAN LEITH
d6 2
a7 2
C                NCOL (MAX NO OF COLUMNS) ADDED   JUNE 00  BB
C                REMOVED CONTINUATION LINES       JULY 00  ARDEAN LEITH
d16 1
d34 1
a34 1
C     ------------------------- LUNDOCREDSLI -----------------------------
d45 1
d53 2
a54 1
C    PURPOSE:    SUBROUTINE TO WRITE A SPECIFED KEY OF A DOC FILE
d62 2
a63 2
C     NOTE:    CAN NOW WRITE OUT DOC FILES WITH 50 REGISTERS
C              BUT NONE OF THE READ PGMS CAN YET HANDLE MORE THAN 9!!
d70 1
a70 1
      INCLUDE 'CMBLOCK.INC'
d72 4
a75 3
      DIMENSION      DLIST(*)
      PARAMETER      (NCOL = 50)
      CHARACTER      ALIST
d84 1
d92 2
a93 2
C        BAD KEY OUTPUT DESIRED
         CALL ERRT(101,'CAN NOT CREATE DOCUMENT FILE KEY: 0',IDUM)
d96 8
a103 2
      ELSEIF (IKEY .LT. 0) THEN
C        COMMENT KEY DESIRED
d106 4
a109 4
            WRITE(NOUT,90) IKEY
90          FORMAT(' *** COMMENT KEY:',I5,' MUST BE < 1000'/)
            CALL ERRT(100,'LUNDOCWRTDAT',IDUM)
            RETURN
d115 2
a116 2
      ELSE
C        WANT TO WRITE REGULAR KEY
d125 1
a125 1
C           WRITE FIRST LINE OF REGISTERS
d130 1
a130 1
C           WRITE FIRST LINE OF REGISTERS
d134 24
d159 9
d169 1
d180 2
a181 1
C    PURPOSE:    SUBROUTINE TO RECOVER A SPECIFED KEY FROM A DOC FILE
d185 1
a185 1
C                  DLIST   ARRAY CONTAINING NUMBERS              (RET.)
d191 1
a191 1
C                          2=NOTFOUND                            (RET.)
d198 1
d217 42
d317 1
d323 2
a324 1
C                
d342 9
a350 2
      CHARACTER *120     RECLIN
      LOGICAL            WARNIT,WANTERRT
d433 2
a434 1
C     ------------------------- LUNDOCREDSLI -----------------------------
d436 1
a436 1
C    LUNDOCREDSLI(LUNDOC,DBUF,MAXY,WANTERRT,IREG,IGO,IEND,NGOT,IRTFLG)
d438 2
a439 3
C    PURPOSE:    RECOVER KEY SLICE OF ONE SPECIFED REGISTER FROM A 
C                OPEN DOC FILE AND RETURN IT IN DBUF. ASSUMES KEYS
C                ARE SORTED!!
d441 8
a448 9
C    PARAMETERS: LUNDOC     IO UNIT                             (SENT)
C                ILIST      DATA ARRAY (MUST ALREADY EXIST)     (RET.)
C                MAXY       ARRAY DIMENSION                     (SENT)
C                WANTERRT   CALLERRT FLAG                       (SENT)
C                IREG       REGISTER NUMBER WANTED              (SENT)       
C                IGO        STARTING KEY                        (SENT)
C                IEND       ENDING KEY                          (SENT)
C                NGOT       NUMBER OF KEYS RETRIEVED            (RET.)
C                IRTFLG     1=ERROR, 0 = NORMAL                 (RET.)
d452 1
a452 2
      SUBROUTINE LUNDOCREDSLI(LUNDOC,ILIST,MAXY,WANTERRT,IREG,IGO,IEND,
     &                        NGOT,IRTFLG)
d454 1
a454 1
      INCLUDE 'CMBLOCK.INC' 
d456 1
a456 1
      PARAMETER          (NCOL = 9)
d458 1
a458 4
      INTEGER,DIMENSION(*) ::     ILIST
      REAL, DIMENSION(NCOL) :: DLIST
      CHARACTER(LEN=120)  ::   RECLIN
      LOGICAL             ::   WANTERRT
d460 1
a460 2
      IRTFLG = 1
      NGOT   = 0
d462 5
a466 2
C     WILL LOOP UNTIL IT RETURNS EOF OR UNTIL ERROR OR KEY IEND REACHED
C     ---------------------------------------------------------------
d468 30
a497 2
11    READ(LUNDOC,80,END=999,ERR=998) RECLIN
80    FORMAT(A120)
d499 6
a504 2
C     IGNORE COMMENT LINES & COMMENT KEY LINES. 
      IF (RECLIN(2:2) .EQ. ';') GOTO 11
d506 2
a507 2
      READ(RECLIN,82,END=999,ERR=998) IKEYT,ICOUNT         
82    FORMAT(I6,I1,9F12.6)
d509 1
a509 10
C     ONLY RETRIEVE REGISTER FROM KEYS: IGO...IEND
      IF (IKEYT .LT. IGO) GOTO 11
      IF (IKEYT .GT. IEND) GO TO 999
 
      IF (ICOUNT .LE. IREG) THEN
         WRITE(NOUT,90) IKEYT
90       FORMAT(' WARNING; EMPTY DOCUMENT FILE LINE SKIPPED FOR KEY: ',
     &          I7)
         GOTO 11
      ENDIF
a510 2
C     RETRIEVE REGISTER: IREG
      READ(RECLIN,82,END=998,ERR=998) IDUM,IDUM,(DLIST(J),J=1,IREG)
d512 16
a527 8
C     PUT REG IN DBUF(NGOT)
      NGOT = NGOT + 1
      IF (NGOT .GT. MAXY) THEN
         WRITE(NOUT,95) MAXY
95       FORMAT(' **** PGM ERROR, DBUF OVERFLOW: ',I7)
         IF (WANTERRT) CALLERRT(100,'LUNDOCREDSLI',NE)
         RETURN
      ENDIF
d529 1
a529 4
C     INTEGER CONVERSION!!!!
      ILIST(NGOT) = DLIST(IREG)
         
      GOTO 11 
d531 2
a532 1
C     ----------------------------------------------------------------
a533 3
998   WRITE(NOUT,94) RECLIN
94    FORMAT(' **** UNABLE TO INTERPRET DOC FILE LINE: ', A)
      IF (WANTERRT) CALLERRT(100,'LUNDOCREDSLI',NE)
d535 1
a535 3
 
999   IRTFLG = 0
      RETURN
a536 1
      END
d538 1
a538 1
C     ------------------------- LUNDOCREDSEQ -----------------------------
d540 1
a540 1
C    LUNDOCREDSEQ(LUNDOC,DBUF,MAXX,MAXY,WANTERRT,IRTFLG)
d542 3
a544 4
C    PURPOSE:    RECOVER ALL DATA FROM A DOC FILE AND RETURN IT IN DBUF
C                RECOVERS SEQUENTIALLY, NOT BY KEY!!!  SO THIS CAN BE
C                USED FOR DOC FILES WITH REPEATED KEYS WHEN YOU DO NOT
C                WISH TO LOSE THE REPEATED DATA E.G. 'DOC REN' 
d546 6
a551 6
C    PARAMETERS:  LUNDOC  IO UNIT                                (SENT)
C                 DBUF    DATA ARRAY                             (RET.)
C                 MAXX    MAX X ARRAY DIMENSION                  (SENT)
C                 MAXY    MAX Y ARRAY DIMENSION             (SENT/RET.)
C                 WANTERRT    CALLERRT FLAG                      (SENT)
C                 IRTFLG  1=ERROR, 0 = NORMAL                    (RET.)
d555 1
a555 1
      SUBROUTINE LUNDOCREDSEQ(LUNDOC,DBUF,MAXX,MAXY,WANTERRT,IRTFLG)
d557 2
a558 1
      INCLUDE 'CMBLOCK.INC' 
d560 2
a561 3
      DIMENSION         DBUF(*)
      CHARACTER *120    RECLIN
      LOGICAL           WANTERRT
a562 3
      IRTFLG = 1
      IY     = 0
      MAXYT  = 0
d564 15
a578 2
C     WILL LOOP UNTIL IT RETURNS EOF OR UNTIL ERROR
C     ---------------------------------------------------------------
d580 1
a580 2
11    READ(LUNDOC,80,END=997,ERR=998) RECLIN
80    FORMAT(A120)
d582 2
a583 2
C     IGNORE COMMENT LINES & COMMENT KEY LINES. 
      IF (RECLIN(2:2) .EQ. ';') GOTO 11
d585 2
a586 2
      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT         
82    FORMAT(I6,I1,9F12.6)
a587 1
      ICOUNT = MIN(ICOUNTT,MAXX)
a588 4
      IF (ICOUNT .LE. 0) THEN
         WRITE(NOUT,90) 
90       FORMAT(' EMPTY DOCUMENT FILE LINE SKIPPED')
         GOTO 11
a589 10
      ELSEIF (IKEYT .LT. 0) THEN
        WRITE(NOUT,91) 
91      FORMAT(' WARNING; CONTINUATION LINE SKIPPED IN DOC FILE')
        GOTO 11

      ELSEIF (IKEYT .EQ. 0) THEN
C       ILLEGAL KEY, SOUND WARNING
        WRITE(NOUT,92) 
92      FORMAT(' WARNING; RETRIEVED LINE WITH ILLEGAL KEY NUMBER: 0')
      ENDIF
d591 28
a618 3
C     FIND DBUF LOCATION POINTER
      IY   = IY + 1
      ILOC = (IY - 1) * MAXX + 1
d620 2
a621 11
      IF (IY .GT. MAXY) THEN
C        ROW OVERFLOW
         WRITE(NOUT,93) MAXY
93       FORMAT(' KEYS GREATER THAN: ',I7,' NOT RETRIEVED')
         IRTFLG = 2
         MAXY   = IY - 1
         RETURN
      ENDIF
         
      READ(RECLIN,82,END=998,ERR=998) IDUM,IDUM,
     &                 (DBUF(J),J=ILOC,ILOC+ICOUNT-1)
d623 1
a623 6
      IF (ICOUNT .LT. MAXX) THEN
C        ZERO REMAINING VALUES IN REGISTER LIST FOR THIS LINE
         DO I = ICOUNT,MAXX-1
             DBUF(ILOC+I) = 0.0
         ENDDO
      ENDIF
d625 1
a625 1
      GOTO 11 
d627 1
a627 1
C     ----------------------------------------------------------------
d629 20
a648 2
997   IRTFLG = 0
      MAXY   = IY
d650 4
a653 6
998   IF (IRTFLG .NE. 0 .AND. WANTERRT)THEN
         WRITE(NOUT,94) RECLIN
94       FORMAT(' **** UNABLE TO INTERPRET DOC FILE LINE: ', A)
         CALLERRT(100,'LUNDOCREDSEQ',NE)
      ENDIF
      RETURN
d655 3
a657 1
      END
d659 4
a662 16
C     ------------------------- LUNDOCREDSEL -----------------------------
C
C    LUNDOCREDSEL(LUNDOC,ILIST,MAXX,MAXY,NGOT,WANTERRT,IRTFLG)
C
C    PURPOSE:    RECOVER ALL DATA FROM A DOC FILE COLUMN: 1 ASSUMING
C                THAT IT IS INTEGER LISTING AND RETURN IT ILIST DBUF
C                RECOVES SEQUENTIALLY, NOT BY KEY!!!
C                
C    PARAMETERS:  LUNDOC  IO UNIT                                (SENT)
C                 DBUF    DATA ARRAY                             (RET.)
C                 MAXY    MAX ARRAY DIMENSION FOR ILIST          (SENT)
C                 NGOT    NUMBER OF VALUES IN ILIST              (RET.)
C                 WANTERRT    CALLERRT FLAG                      (SENT)
C                 IRTFLG  1=ERROR, 0 = NORMAL                    (RET.)
C
C--*********************************************************************
d664 27
a690 1
      SUBROUTINE LUNDOCREDSEL(LUNDOC,ILIST,MAXY,NGOT,WANTERRT,IRTFLG)
d692 2
a693 1
      INCLUDE 'CMBLOCK.INC' 
d695 2
a696 3
      DIMENSION         ILIST(*)
      LOGICAL           WANTERRT
      REAL, ALLOCATABLE, DIMENSION(:) :: DBUF
d698 27
a724 10
      NGOT   = 0
      ICOL   = 2
      MAXX   = 2
      LENT   = MAXX * MAXY
      ALLOCATE(DBUF(LENT),STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN
         WRITE(NOUT,*)' UNABLE TO ALLOCATE DBUF  IN LUNDOCREDSEL'
         CALL ERRT(100,'LUNDOCREDSEL',NDUM)
         IRTFLG = 1
         RETURN
d726 7
a732 6
     
C     GET FIRST 2 COLUMNS FROM THE DOC FILE IN DBUF
      CALL LUNDOCREDALL(LUNDOC,DBUF,MAXX,MAXY,WANTERRT,NMAX,IRTFLG)
      IF (IRTFLG .NE. 0) THEN
          DEALLOCATE(DBUF)
          RETURN
a734 11
C     EXTRACT NUMBERS IN FIRST REGISTERS FROM USED KEYS (AS INTEGER)
      DO I = 0,NMAX-1
         ILOC = I * MAXX + 1
         IF (DBUF(ILOC) .GT. 0) THEN
C           KEY IS USED
            NGOT        = NGOT + 1
            ILIST(NGOT) = DBUF(ILOC+1)
         ENDIF
      END DO

      DEALLOCATE(DBUF)
d737 1
a805 2


d828 2
a829 3
      DIMENSION       DLIST(*)
      CHARACTER *120  RECLIN

d831 1
d834 3
a836 27
C     WILL LOOP UNTIL IT RETURNS EOF OR UNTIL A KEY IS FOUND
C     ---------------------------------------------------------------

10    READ(LUNDOC,80,END=999,ERR=998) RECLIN
80    FORMAT(A120)

C     IGNORE COMMENT LINES. 
      IF (RECLIN(2:2) .EQ. ';') GOTO 10

      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT         
82    FORMAT(I6,I1,9F12.6)

      IF (IKEYT .LT. 0) THEN
         WRITE(NOUT,90) 
90       FORMAT(' WARNING; CONTINUATION LINE SKIPPED IN DOC FILE')
         GOTO 10

      ELSEIF (IKEYT .EQ. 0) THEN
C        ILLEGAL KEY, SOUND WARNING
         WRITE(NOUT,91) 
91       FORMAT('*** BAD KEY: 0 IN SELECTION FILE: ')
         GOTO 10

      ELSEIF (ICOUNTT .LE. 0) THEN
         WRITE(NOUT,92) 
92       FORMAT(' EMPTY DOCUMENT FILE LINE SKIPPED')
         GOTO 10
d839 25
a863 10
      ICOUNT = MIN(ICOUNTT,NMAX)
      IF (ICOUNT .GT. 0) THEN
C        DLIST CAN HOLD REGISTER VALUES
         READ(RECLIN,82,END=998,ERR=998) IDUM,IDUM,
     &                         (DLIST(J),J=1,ICOUNT)

C        RECORD KEY READ
         IKEY = IKEYT
      ENDIF

a864 2
C     ----------------------------------------------------------------

d866 1
a866 1
998   RETURN
a875 96
C     ------------------------- LUNDOCREDANG -----------------------------
C
C    LUNDOCREDANG(LUNDOC,ANGBUF,MAXX,MAXY,WANTERRT,NGOT,IRTFLG)
C
C    PURPOSE:    RECOVER ANGLE DATA FROM A DOC FILE AND RETURN IT IN 
C                ANGBUF, EACH ANGLE IS RETRIEVED INTO RESPECTIVE KEY,
C                THUS ANGBUF DOES NOT HAVE KEY NUMBER IN FIRST COL.!!!!
C                
C    PARAMETERS:  LUNDOC  IO UNIT                                (SENT)
C                 ANGBUF  DATA ARRAY                             (RET.)
C                 MAXX    MAX X ARRAY DIMENSION ( < 7)           (SENT)
C                 MAXY    MAX Y ARRAY DIMENSION                  (SENT)
C                 WANTERRT    CALLERRT FLAG                      (SENT)
C                 NGOT        MAX KEY RETRIEVED                  (RET.)
C                 IRTFLG      1=ERROR, 0 = NORMAL                (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDANG(LUNDOC,ANGBUF,MAXX,MAXY,WANTERRT,
     &                        NGOT,IRTFLG)

      INCLUDE 'CMBLOCK.INC' 

      REAL, DIMENSION(MAXX,MAXY) :: ANGBUF
      CHARACTER *120  ::            RECLIN
      LOGICAL  ::                   WARNIT,WARNIT2,WANTERRT

      IRTFLG  = 1
      WARNIT   = .TRUE.
      WARNIT2  = .TRUE.
      NGOT     = 0

C     WILL LOOP UNTIL IT RETURNS EOF OR UNTIL ERROR
C     ---------------------------------------------------------------

10    READ(LUNDOC,80,END=997,ERR=998) RECLIN
80    FORMAT(A120)

C     IGNORE COMMENT LINES & COMMENT KEY LINES. 
      IF (RECLIN(2:2) .EQ. ';') GOTO 10

      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNT         
82    FORMAT(I6,I1,9F12.6)

      IF (IKEYT .GT. MAXY) THEN
C        KEY THAT WILL NOT FIT IN ANGBUF SENDS ERROR MSG.
         IF (WARNIT) THEN 
            WRITE(NOUT,90) MAXY
90          FORMAT(' KEYS GREATER THAN: ',I7,' NOT RETRIEVED')
            WARNIT = .FALSE.
         ENDIF
         GOTO 10

      ELSEIF (IKEYT .EQ. 0) THEN
C        ILLEGAL KEY THAT WILL NOT FIT IN ANGBUF SENDS ERROR MSG.
         WRITE(NOUT,91) 
91       FORMAT(' ILLEGAL KEY NUMBER: 0 NOT RETRIEVED')
         GOTO 10

      ELSEIF (IKEYT .LT. 0) THEN
         WRITE(NOUT,92) 
92       FORMAT(' WARNING; CONTINUATION LINE SKIPPED IN DOC FILE')
         GOTO 10
      ENDIF
       
      ICOUNT = MIN(ICOUNT,MAXX)  
      READ(RECLIN,82,END=998,ERR=998) IDUM,IDUM,
     &              (ANGBUF(J,IKEYT),J=1,ICOUNT)

      IF (ICOUNT .LT. MAXX) THEN
         IF (WARNIT2) THEN 
            WRITE(NOUT,93) MAXX
93          FORMAT(' DID NOT GET ',I4,' VALUES FROM ONE OR MORE LINES')
            WARNIT2 = .FALSE.
         ENDIF

C        ZERO REMAINING VALUES IN REGISTER LIST FOR THIS LINE
         DO I = ICOUNT + 1,MAXX
             ANGBUF(IKEYT,J) = 0.0
         ENDDO
      ENDIF
      NGOT = MAX(NGOT,IKEYT)

      GOTO 10 

C     ----------------------------------------------------------------

997   IRTFLG = 0
998   IF (IRTFLG .NE. 0 .AND. WANTERRT) THEN
         WRITE(NOUT,94) RECLIN
94       FORMAT(' **** UNABLE TO INTERPRET DOC FILE LINE: ', A)
         CALLERRT(100,'LUNDOCREDANG',NE)
      ENDIF
      RETURN

      END
d879 1
a879 1
C  LUNDOCINFO(NDOC,MAXKEYT,MAXREGT,SAYIT,KEYUSED,IRTFLG)
d897 2
d901 1
a901 2
        CHARACTER *120  RECLIN
        LOGICAL         SAYIT
d905 30
a934 1
C       WANT TO FIND MAXIMUM KEY & REGISTER NUMBER 
d939 3
a941 3
C       READING LOOP ----------------------------------------
 10        READ (NDOC,80,END=799) RECLIN
 80        FORMAT(A120)
d943 20
a962 5
C          SKIP PLAIN COMMENTS & COMMENT KEYS
           IF (RECLIN(2:2) .EQ. ';') GOTO 10

           READ(RECLIN,81,ERR=999) NKEY,NREGPLINE
81         FORMAT(I6,I1)
a963 17
           IF (NKEY .LT. 0) THEN
              WRITE(NOUT,90) 
90            FORMAT(' WARNING; CONTINUATION LINE SKIPPED IN DOC FILE')

           ELSEIF (NKEY .EQ. 0)THEN
              WRITE(NOUT,91) 
91            FORMAT('*** SKIPPING ILLEGAL KEY:0  LINE IN DOC FILE')

           ELSEIF (NREGPLINE .EQ. 0)THEN
              WRITE(NOUT,92) 
92            FORMAT(' WARNING; SKIPPING EMPTY LINE IN DOC FILE')

           ELSE
C             REGULAR REGISTER LINE
              IF (NKEY       .GT. MAXKEYT) MAXKEYT = NKEY
              IF (NREGPLINE .GT. MAXREGT) MAXREGT = NREGPLINE
              KEYUSED = KEYUSED + 1
d965 1
a965 3

           GOTO 10
C       LOOP UNTIL END -------------------------------------
a974 4
        RETURN

999     WRITE(NOUT,*) '*** ERROR READING DOC FILE LINE: ',RECLIN
        CALL ERRT(100,'LUNDOCINFO',NE)
a978 5





d1195 2
d1225 1
@


1.37
log
@LUNDOCREDSEQ RETURNS MAXY APR 2003
@
text
@d14 1
d565 1
a565 1
      DO I = 0,NMAX
@


1.36
log
@lundocredddat parameter added
@
text
@d13 1
d432 1
a432 1
C                 MAXY    MAX Y ARRAY DIMENSION                  (SENT)
d448 1
d489 1
d508 2
@


1.35
log
@output msg formatting
@
text
@d12 1
d16 1
a16 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d27 1
a36 1
C     ------------------------- LUNDOCPARSE -----------------------------
d39 1
a39 1
C     ------------------------- LUNDOCPUTCOM -----------------------------
d130 1
a130 1
C    LUNDOCREDDAT(LUNDOC,IKEY,DLIST,NMAX,ICOUNT,TILLEND,IRTFLG)
d140 1
d147 1
a147 1
     &                        TILLEND,IRTFLG)
d151 3
a153 3
      DIMENSION       DLIST(*)
      CHARACTER *120  RECLIN
      LOGICAL         TILLEND
d170 1
a170 1

d204 7
d214 2
a215 1
998   RETURN
@


1.34
log
@typos fixed
@
text
@d875 1
a875 1
97         FORMAT(' DOC FILE CONTAINS: ',I2,'  REGISTERS AND: ',I7,
@


1.33
log
@lundocwrtdat now will write 50 registers / line
@
text
@d227 1
a227 1
C                 NGOT       MAX. REGISTER # RETRIEVED           (RET.)
d1002 1
a1002 1
C    PURPOSE:    GET A SPECIFIED COMMAND KEY FROM FILE
d1005 1
a1005 1
C                IKEY    COMMAND KEY WANTED (<0)                (SENT)
d1098 1
a1098 1
C    PURPOSE:    GET A SPECIFIED COMMAND KEY FROM FILE
@


1.32
log
@lundocredsli ilist is integer!
@
text
@d11 1
d55 4
d66 2
a67 1
      PARAMETER      (NCOL = 9)
d75 1
a75 1

d97 2
a98 2
         WRITE(LUNDOC,91) IKEYT,NLIST,(DLIST(K),K=1,NLIST)
91       FORMAT(' ;',I3,' ',I1,9(1PG12.5))
d111 2
a112 2
            WRITE(LUNDOC,93) IKEY,NLIST,(DLIST(K),K=1,NLIST)
93          FORMAT(I5,1X,I1,9(1PG12.5))
d116 2
a117 2
            WRITE(LUNDOC,94) IKEY,NLIST,(DLIST(K),K=1,NLIST)
94          FORMAT(I6,I1,9(1PG12.5))
@


1.31
log
@added lundocredsli
@
text
@d343 1
a343 1
      REAL,DIMENSION(*) ::     ILIST
d386 1
@


1.30
log
@comment added
@
text
@d10 1
d27 1
d216 1
a216 1
C                 DBUF       DATA ARRAY                          (RET.)
d312 86
@


1.29
log
@rdpr simplification for symbolic parameters & variable subs.
@
text
@d13 1
a13 1
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
d216 1
@


1.28
log
@CALL INDEXTOREG instead of function.
@
text
@d3 7
a9 6
C                  NEW APRIL 99 ARDEAN LEITH
C                  ADDED FILNAMSUB TO LUNDOCPARSE JAN 2000 ARDEAN LEITH
C                  NCOL (MAX NO OF COLUMNS) ADDED JUNE 00  BB
C                  REMOVED CONTINUATION LINES     JULY 00  ARDEAN LEITH
C                  LUNDOCREDALL PARAMETERS        DEC   00 ARDEAN LEITH
C                  CALL INDEXTOREG                MAR   01 ARDEAN LEITH
a834 7

        ILEFBRAK = INDEX(CCHAR(1:ILEN),'{')
        IF (ILEFBRAK .GT. 0) THEN
C          SUBSTITUTE FOR {***X??) OR {---X??} IN STRING1
           CALL FILNAMSUB(CCHAR(1:ILEN),ILEN,.FALSE.,FDUM,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ENDIF
@


1.27
log
@indextoreg parameters
@
text
@d8 1
d10 8
a17 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d878 2
a879 2
           IKEY = INDEXTOREG(CTEMP,.TRUE.,IDUM)
           IGO  = K + 2
@


1.26
log
@lundocredang did not set ngot!
@
text
@d878 1
a878 1
           IKEY = INDEXTOREG(CTEMP,IDUM)
@


1.25
log
@lundocredall & opendoc parameters changed
@
text
@a694 1
         NGOT = MAX(NGOT,IKEYT)
d696 1
@


1.24
log
@typos
@
text
@d5 4
a8 2
C                  NCOL (MAX NO OF COLUMNS) ADDED JUNE 00 BB
C                  REMOVED CONTINUATION LINES     JULY 00 ArDean Leith
d208 1
a208 1
C    LUNDOCREDALL(LUNDOC,DBUF,MAXX,MAXY,WANTERRT,IRTFLG)
d212 7
a218 6
C    PARAMETERS:  LUNDOC  IO UNIT                                (SENT)
C                 DBUF    DATA ARRAY                             (RET.)
C                 MAXX    MAX X ARRAY DIMENSION                  (SENT)
C                 MAXY    MAX Y ARRAY DIMENSION                  (SENT)
C                 WANTERRT    CALLERRT FLAG                      (SENT)
C                 IRTFLG  1=ERROR, 0 = NORMAL                    (RET.)
d222 2
a223 1
      SUBROUTINE LUNDOCREDALL(LUNDOC,DBUF,MAXX,MAXY,WANTERRT,IRTFLG)
d232 1
d296 1
d409 1
a409 1
C    LUNDOCREDSEL(LUNDOC,ILIST,MAXX,NGOTWANTERRT,IRTFLG)
d445 1
a445 1
      CALL LUNDOCREDALL(LUNDOC,DBUF,MAXX,MAXY,WANTERRT,IRTFLG)
d452 1
a452 1
      DO I = 0,MAXY-1
d617 1
a617 1
C    LUNDOCREDANG(LUNDOC,ANGBUF,MAXX,MAXY,WANTERRT,IRTFLG)
d620 1
a620 1
C                ANGBUF, EACH ANGLE IS RETRIEVED INTO REPSPECTIVE KEY,
d628 2
a629 1
C                 IRTFLG  1=ERROR, 0 = NORMAL                    (RET.)
d633 2
a634 1
      SUBROUTINE LUNDOCREDANG(LUNDOC,ANGBUF,MAXX,MAXY,WANTERRT,IRTFLG)
d645 1
d695 1
@


1.23
log
@added 1pg12.5 , added lundoclputcom
@
text
@d87 1
a87 1
91       FORMAT(' ;',I3,' ',I1,1P9G12)
d101 1
a101 1
93          FORMAT(I5,1X,I1,1P9G12.5)
d106 1
a106 1
94          FORMAT(I6,I1,1P9G12
d441 1
a441 1
          DEALLOCATE(DBUF))
@


1.22
log
@for reg_set in parsing
@
text
@d32 1
d78 2
a79 1
         IF (IKEY .GT. 999) THEN
d86 2
a87 2
         WRITE(LUNDOC,91) IKEY,NLIST,(DLIST(K),K=1,NLIST)
91       FORMAT(' ;',I3,' ',I1,9G12.5)
d101 1
a101 1
93          FORMAT(I5,1X,I1,9G12.5)
d106 1
a106 1
94          FORMAT(I6,I1,6G12.5)
d440 4
a443 1
      IF (IRTFLG .NE. 0) RETURN
d994 27
d1025 1
a1025 1
C    PURPOSE:    SUBROUTINE TO ECHO FIRST HEADER LINE FROM A DOC FILE
@


1.21
log
@do not adjust reg numbers by +1
@
text
@d827 8
a834 4
   	DO K = 1,ILEN
           CTEMP = CCHAR(K:K)
	   IF (CTEMP .NE. ',' .AND. CTEMP .NE. ' ') GOTO 15
        ENDDO
d836 1
a836 4
	WRITE(NOUT,90) CCHAR(1:ILEN)
90      FORMAT(' *** UNABLE TO PARSE REGISTER LINE: ',A)
	CALL ERRT(100,'LUNDOCPARSE',NE)
	RETURN
a837 3
15      ICLAST = IC
        COMOUT = .FALSE.

d848 1
a848 4
          NCHAR = INDEX(CCHAR(K+2:),',')
          READ(CCHAR(K+1:K+NCHAR),*,IOSTAT=IER) IREG
8000      FORMAT(I5)
           
d854 1
d856 4
a859 2
	  IKEY = PARAM(IREG+1)
          IGO  = K + NCHAR + 2
d864 1
a864 1
           IGO      = K + 2
@


1.20
log
@removed continuation lines
@
text
@d886 2
a887 2
C       FIND THE DATA REGISTER NUMBER(S)
        CALL CHKSTR(CCHAR(IGO:ILEN),ILEN-IGO+1,'IR',ILIST,DUM,NMAX,
@


1.19
log
@lundocredseq altered
@
text
@d5 2
a6 1
C
d55 1
d62 1
a62 1
C     ICOUNT IS THE NUMBER OF REGISTERS (VALUES) IN THE LINE.
a64 3
      IGO    = 1
      LEFT   = NLIST
      ICOUNT = MIN0(LEFT,6)
d66 3
a68 7
      IF (IKEY .LT. 0) THEN
C       COMMENT KEY DESIRED
        IF (IKEY .GT. 999) THEN
           WRITE(NOUT,90) IKEY
90         FORMAT(' *** COMMENT KEY:',I5,' MUST BE < 1000'/)
           CALL ERRT(100,'LUNDOCWRTDAT',IDUM)
           RETURN
d70 4
a73 5
        ELSEIF (NLIST .GT. 6) THEN 
C          CONTINUATION LINES NOT SUPPORTED FOR COMMENT KEYS
           CALL ERRT(101,'COMMENT KEYS CAN NOT HAVE CONTINUATIONS',IDUM)
           RETURN
        ENDIF
d75 8
a82 2
        WRITE(LUNDOC,92) IKEY,ICOUNT,(DLIST(K),K=1,ICOUNT)
92      FORMAT(' ;',I3,' ',I1,6G12.5)
d84 2
a85 4
      ELSEIF (IKEY .EQ. 0) THEN
C       BAD KEY OUTPUT DESIRED
        CALL ERRT(101,'CAN NOT CREATE DOCUMENT FILE KEY: 0',IDUM)
        RETURN
d88 1
a88 9
C       WANT TO WRITE REGULAR KEY

        ICOUNTT = MIN(7,LEFT)
           
        IF (IKEY .GT. 999999) THEN
           WRITE(NOUT,93) IKEY
93         FORMAT(' *** KEY:',I10,' MUST BE < 1000000'/)
           CALL ERRT(100,'LUNDOCWRTDAT',IDUM)
           RETURN
d90 15
a104 4
        ELSEIF (IKEY .LT. 100000) THEN
C          WRITE FIRST LINE OF REGISTERS
           WRITE(LUNDOC,94) IKEY,ICOUNTT,(DLIST(K),K=1,ICOUNT)
94         FORMAT(I5,1X,I1,6G12.5)
d106 1
a106 20
        ELSE
C          WRITE FIRST LINE OF REGISTERS
           WRITE(LUNDOC,95) IKEY,ICOUNTT,(DLIST(K),K=1,ICOUNT)
95         FORMAT(I6,I1,6G12.5)

        ENDIF

C       NOW WRITE ANY CONTINUATION LINES
20      IGO    = IGO + ICOUNT
        LEFT   = NLIST - IGO + 1
        ICOUNT = MIN0(LEFT,6)

        IF (LEFT .GT. 0) THEN
C         CONTINUATION LINE OF REGISTERS PRESENT
          ICOUNTT = MIN(7,LEFT)
          WRITE(LUNDOC,96) ICOUNTT,(DLIST(K),K=IGO,IGO+ICOUNT-1)
96        FORMAT('  -99 ',I1,6G12.5)
C         LOOP OVER ALL REMAINING LINES
          IF (LEFT .GT. 6) GOTO 20
        ENDIF
a107 1

d136 3
a138 3
      DIMENSION      DLIST(*)
      CHARACTER *80  RECLIN
      LOGICAL        TILLEND,NEEDMORE
d143 1
a143 1
C        WANT A COMMENTED KEY, THEY DO NOT HAVE CONTINUATIONS SO USE NMAX
d147 1
d150 2
a151 2
         WRITE(NOUT,91) 
91       FORMAT(' WARNING; RETRIEVING ILLEGAL KEY NUMBER: 0')
d154 1
a154 3
      ICOUNT   = 0
C     INITIALIZE CONTINUATION LINE FLAG
      NEEDMORE = .FALSE.
d159 1
a159 1
80    FORMAT(A80)
d164 2
a165 2
      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT         
82    FORMAT(I6,I1,6F12.6)
d168 3
a170 3
      IF (IKEYT .EQ. IKEY .OR. (NEEDMORE .AND. IKEYT .EQ. -99)) THEN
C        MAY HAVE DUPLICATES OF KEY SO MUST ZERO ICOUNT HERE
         IF (.NOT. NEEDMORE) ICOUNT = 0
d172 4
d177 1
a177 1
         INEW   = MIN(ICOUNTT,6,(NMAX-ICOUNT))
d179 1
a179 1
         IF (INEW .GT. 0) THEN
d182 1
a182 3
     &                         (DLIST(J),J=ICOUNT+1,ICOUNT+INEW)
C           RECORD NUMBER OF VALUES READ
            ICOUNT = ICOUNT + INEW
a183 3
         NEEDMORE =  (ICOUNTT .GT. 6)
      ELSE
         NEEDMORE =  .FALSE.
d187 1
a187 1
      IF (ICOUNT .EQ. 0 .OR. NEEDMORE .OR. TILLEND) GOTO 10
a216 1

d221 3
a223 3
      DIMENSION         DBUF(*)
      CHARACTER *80     RECLIN
      LOGICAL           WARNIT,WANTERRT
a238 2
10    ICOUNT  = 0

d240 1
a240 1
80    FORMAT(A80)
d246 13
a258 1
82    FORMAT(I6,I1,6F12.6)
d260 5
a264 12
      INEW = MIN(ICOUNTT,6,(MAXXM1-ICOUNT))
      IF (INEW .GT. 0) THEN
C        DBUF CAN HOLD THESE REGISTER VALUES

         IF (IKEYT .GT. MAXY) THEN
C          KEY THAT WILL NOT FIT IN DBUF SENDS ERROR MSG.
           IF (WARNIT) THEN 
              WRITE(NOUT,90) MAXY
90            FORMAT(' KEYS GREATER THAN: ',I7,' NOT RETRIEVED')
              WARNIT = .FALSE.
           ENDIF
           GOTO 10
d266 6
a271 5
         ELSEIF (IKEYT .EQ. 0) THEN
C          KEY THAT WILL NOT FIT IN DBUF SENDS ERROR MSG.
           WRITE(NOUT,91) 
91         FORMAT(' ILLEGAL KEY NUMBER: 0 NOT RETRIEVED')
           GOTO 10
d273 2
d276 3
a278 5
         IF (IKEYT .GT. 0) THEN
C           THIS IS NOT A CONTINUATION KEY, FIND DBUF LOCATION POINTER
            ILOC       = (IKEYT -1) * MAXX + 1
            DBUF(ILOC) = IKEYT
         ENDIF
d280 2
a281 2
         READ(RECLIN,82,END=998,ERR=998) IDUM,IDUM,
     &                 (DBUF(J),J=ILOC+ICOUNT+1,ILOC+ICOUNT+INEW)
d283 1
a283 6
C        RECORD NUMBER OF VALUES READ
         ICOUNT = ICOUNT + INEW 
      ENDIF

      IF (IKEYT .GT. 0 .AND. 
     &    ICOUNT .LT. MAXXM1 .AND. ICOUNTT .LE. 6) THEN
a289 2
C     SEE IF CONTINUATION PRESENT ON NEXT LINE
      IF (ICOUNTT .LE. 6) GOTO 10
d296 2
a297 2
         WRITE(NOUT,92) RECLIN
92       FORMAT(' **** UNABLE TO INTERPRET DOC FILE LINE: ', A)
d311 1
a311 3
C                WISH TO LOSE THE REAPEATED DATA E.G. 'DOC REN'.  ONLY
C                RECOVERS REGISTERS IN DBUF (NOT KEY #'S). WILL HALT
C                WHEN MAXY LINES RETRIEVED. CALLED BY FILTDOC ALSO. 
d316 1
a316 1
C                 MAXY    MAX Y ARRAY DIMENSION              (SENT/RET)
d327 1
a327 1
      CHARACTER *80     RECLIN
d333 1
a333 1
C     WILL LOOP UNTIL IT RETURNS EOF OR UNTIL ERROR OR READS MAXY LINES
d337 1
a337 1
80    FORMAT(A80)
d342 4
a345 2
      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNT         
82    FORMAT(I6,I1,6F12.6)
d348 2
a349 1
C        IGNORE ANY BLANK LINES. 
d352 4
a355 4
      ELSEIF (ICOUNT .GT. 6) THEN
         WRITE(NOUT,*) ' *** CONTINUATION KEYS NOT ALLOWED'
         IF (WANTERRT) CALLERRT(100,'LUNDOCREDSEQ',NE)
         RETURN
d357 4
a360 4
      ELSEIF (IKEYT .LE. 0) THEN
C        THIS IS ILLEGAL KEY, SOUND WARNING
         WRITE(NOUT,91) IKEYT
91       FORMAT(' WARNING; RETRIEVED ILLEGAL KEY NUMBER: ',I8)
d367 8
d376 1
a376 1
     &               (DBUF(J),J=ILOC,ILOC+ICOUNT-1)
d385 1
a385 2
C     LOOPS UNTIL MAXY
      IF (IY .LT. MAXY) GOTO 11
d390 3
a392 3
998   IF (IRTFLG .NE. 0 .AND. WANTERRT) THEN
         WRITE(NOUT,92) RECLIN
92       FORMAT(' **** UNABLE TO INTERPRET DOC FILE LINE: ', A)
a394 1
      MAXY = IY
a454 77
C     ------------------------- LUNDOCREDSELOLD-----------------------------
C              no longer in use!!!!!!!!!!!!!!!!
C    LUNDOCREDSEL(LUNDOC,ILIST,MAXX,NGOTWANTERRT,IRTFLG)
C
C    PURPOSE:    RECOVER ALL DATA FROM A DOC FILE COLUMN: 1 ASSUMING
C                THAT IT IS INTEGER LISTING AND RETURN IT ILIST DBUF
C                RECOVES SEQUENTIALLY, NOT BY KEY!!!
C                
C    PARAMETERS:  LUNDOC  IO UNIT                                (SENT)
C                 DBUF    DATA ARRAY                             (RET.)
C                 MAXY    MAX ARRAY DIMENSION FOR ILIST          (SENT)
C                 NGOT    NUMBER OF VALUES IN ILIST              (RET.)
C                 WANTERRT    CALLERRT FLAG                      (SENT)
C                 IRTFLG  1=ERROR, 0 = NORMAL                    (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCREDSELOLD(LUNDOC,ILIST,MAXY,NGOT,WANTERRT,IRTFLG)

      INCLUDE 'CMBLOCK.INC' 

      DIMENSION         ILIST(*)
      CHARACTER *80     RECLIN
      LOGICAL           WANTERRT

      IRTFLG = 1
      NGOT   = 0

C     WILL LOOP UNTIL IT RETURNS EOF OR UNTIL ERROR
C     ---------------------------------------------------------------

11    READ(LUNDOC,80,END=997,ERR=998) RECLIN
80    FORMAT(A80)

C     IGNORE COMMENT LINES & COMMENT KEY LINES. 
      IF (RECLIN(2:2) .EQ. ';') GOTO 11

      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT, DBUF        
82    FORMAT(I6,I1,6F12.6)

      IF (IKEYT .LT. 0) THEN
C        THIS IS A CONTINUATION KEY, SKIP IT
         GOTO 11

      ELSEIF (IKEYT .EQ. 0) THEN
C        THIS IS ILLEGAL KEY, SOUND WARNING
         WRITE(NOUT,90) 
90       FORMAT('*** BAD KEY IN SELECTION FILE: 0')
         GOTO 998

      ELSEIF (DBUF .LT. 1.0) THEN
         WRITE(NOUT,91) IKEYT,DBUF
91       FORMAT('*** SELECTION FILE KEY: ',I7', HAS BAD FILE NUMBER: ',
     &          G10.3)
         GOTO 998
      ENDIF

      IF ((NGOT + 1) .GT. MAXY) THEN
C        ILIST OVERFLOW
         WRITE(NOUT,92) MAXY
92       FORMAT(' KEYS GREATER THAN: ',I7,' NOT RETRIEVED')
         GOTO 997
      ENDIF

      NGOT        = NGOT + 1
      ILIST(NGOT) = DBUF

C     LOOP TILL EOF OR ILIST IS FULL
      GOTO 11 

C     ----------------------------------------------------------------

997   IRTFLG = 0
998   IF (IRTFLG .NE. 0 .AND. WANTERRT) CALLERRT(100,'LUNDOCREDSEQ',NE)
      RETURN

      END
d545 2
a546 2
      DIMENSION      DLIST(*)
      CHARACTER *80  RECLIN
d548 2
a549 2
      ICOUNT       = 0
      IRTFLG       = 1
d555 1
a555 1
80    FORMAT(A80)
d561 12
a572 1
82    FORMAT(I6,I1,6F12.6)
d574 3
a576 4
      IF (IKEYT .EQ. 0) THEN
C        THIS IS ILLEGAL KEY, SOUND WARNING
         WRITE(NOUT,90) IKEYT
90       FORMAT('*** BAD KEY IN SELECTION FILE: ',I7)
d580 2
a581 2
      INEW = MIN(ICOUNTT,6,(NMAX-ICOUNT))
      IF (INEW .GT. 0) THEN
d584 1
a584 4
     &                         (DLIST(J),J=ICOUNT+1,ICOUNT+INEW)

C        RECORD NUMBER OF VALUES READ
         ICOUNT = ICOUNT + INEW 
d587 1
a587 1
         IF (IKEYT .GT. 0) IKEY = IKEYT
a589 2
C     SEE IF CONTINUATION PRESENT ON NEXT LINE
      IF (ICOUNTT .GT. 6) GOTO  10
d626 1
a626 1
      CHARACTER *80  ::             RECLIN
a629 1

d637 1
a637 1
80    FORMAT(A80)
d643 1
a643 1
82    FORMAT(I6,I1,6F12.6)
d661 2
a662 3
C        THIS IS A CONTINUATION KEY, FIND ANGBUF LOCATION POINTER
         WRITE(NOUT,93)IKEYT 
93       FORMAT(' CONTINUATION LINE NOT RETRIEVED FOR KEY:',I7)
d666 1
a666 1
      ICOUNT = MIN(ICOUNT,6,MAXX)  
d672 2
a673 2
            WRITE(NOUT,94) MAXX
94          FORMAT(' DID NOT GET ',I4,' VALUES FROM ONE OR MORE LINES')
d689 2
a690 2
         WRITE(NOUT,92) RECLIN
92       FORMAT(' **** UNABLE TO INTERPRET DOC FILE LINE: ', A)
d719 1
a719 1
        CHARACTER *80   RECLIN
d731 1
a731 1
 80        FORMAT(A80)
d736 16
a751 1
           IF (RECLIN(3:3) .NE. '-')THEN
d753 1
a753 11
              READ(RECLIN,81,ERR=999) NKEY,NREGPLINE
              NREGPLINE = MIN(NREGPLINE,6)
              IF (NKEY .EQ. 0) THEN
                 WRITE(NOUT,*) 
     &               '*** DOC FILE HAS BLANK LINE OR KEY: 0'
CCC              CALL ERRT(100,'LUNDOCINFO',NE)
CCC              RETURN
                 KEYUSED = KEYUSED - 1
              ENDIF
         
              IF (NKEY      .GT. MAXKEYT) MAXKEYT = NKEY
a755 7
           ELSE
C             CONTINUATION LINE FOR PREVIOUS KEY
              READ(RECLIN,81,ERR=999) NKEY,NREGPLINE2
81            FORMAT(I6,I1)
              NREGPLINE2 = MIN(NREGPLINE2,6)
              NREGPLINE  = NREGPLINE + NREGPLINE2 
              IF (NREGPLINE .GT. MAXREGT) MAXREGT = NREGPLINE
d916 1
a916 1
        CHARACTER *80   RECLIN
d943 1
a943 1
81      FORMAT(A80)
d948 1
a948 1
82         FORMAT(2X,I4,I1,6F12.6)
d951 1
a951 1
           ICOUNTT = MIN(ICOUNTT,6,NLIST)
d956 1
a956 1
              READ(RECLIN(1:80),82,ERR=50,END=998) 
d1005 1
a1005 1
        CHARACTER *80 RECLIN
d1013 1
a1013 1
81      FORMAT(A80)
a1030 40

#ifdef NEVER
C     ------------------------- LUNDOCOLD -----------------------------
C
C    LUNDOCOLD(LUNDOC,DOCNAM,ASKNAME,IRTFLG)
C
C    PURPOSE:    SUBROUTINE TO OPEN EXISTING DOC FILE
C
C    PARAMETERS:   LUNDOC  DOC FILE IO UNIT                      (SENT)
C                  IRTFLG                                        (RET.)
C
C--*********************************************************************

      SUBROUTINE LUNDOCOLD(DOCNAM,LUNDOC,ASKNAME,IRTFLG)

      INCLUDE 'CMBLOCK.INC'

c     PARAMETER        (NUMLUNS = 100)
c     CHARACTER *81    LUNFILNAM(NUMLUNS)
c     COMMON /LUNARF/  LUNFILNAM

      CHARACTER *(*)   DOCNAM
      LOGICAL          ASKNAME,ADDEXT,APPEND,NEWFILE,ISOLD,WRTMSG                

      APPEND = .FALSE.
      ISOLD  = .TRUE.
      WRTMSG = .FALSE.
      ADDEXT = (INDEX(DOCNAM,'.') .LE. 0)
  
      CALL OPENDOC(DOCNAM,ADDEXT,NLET,LUNDOC,ASKNAME,
     &            ISOLD,APPEND,.FALSE.,NEWFILE,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

c     LUNFILNAM(LUNDOC) = DOCNAM

      RETURN
      END


#endif
@


1.18
log
@lundocredseq alstered
@
text
@d338 1
a338 1
C                WHEN MAXY LINES RETRIEVED. 
d360 1
a360 1
C     WILL LOOP UNTIL IT RETURNS EOF OR UNTIL ERROR
a362 2
10    ICOUNT  = 0

d369 1
a369 1
      READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT         
d372 18
a389 23
      INEW = MIN(ICOUNTT,6,(MAXX-ICOUNT))
      IF (INEW .GT. 0) THEN
C        DBUF CAN HOLD THESE REGISTER VALUES
         IY = IY + 1
         IF (IY .GT. MAXY) THEN
C           ROW OVERFLOW
            WRITE(NOUT,90) MAXY
90          FORMAT(' KEYS GREATER THAN: ',I7,' NOT RETRIEVED')
            RETURN
         ENDIF

         IF (IKEYT .GT. 0) THEN
C           THIS IS NOT A CONTINUATION KEY, FIND DBUF LOCATION POINTER
            ILOC = (IY - 1) * MAXX + 1

         ELSEIF (IKEYT .EQ. 0) THEN
C           THIS IS ILLEGAL KEY, SOUND WARNING
            WRITE(NOUT,91) 
91          FORMAT(' WARNING; RETRIEVED ILLEGAL KEY NUMBER: 0')
         ENDIF
         
         READ(RECLIN,82,END=998,ERR=998) IDUM,IDUM,
     &                 (DBUF(J),J=ILOC+ICOUNT,ILOC+ICOUNT+INEW-1)
d391 2
a392 3
C        RECORD NUMBER OF VALUES READ
         ICOUNT = ICOUNT + INEW 
      ENDIF
d394 1
a394 1
      IF (ICOUNT .LT. MAXX .AND. ICOUNTT .LE. 6) THEN
d401 2
a402 4
C     SEE IF CONTINUATION PRESENT ON NEXT LINE
      IF (ICOUNTT .LE. 6) GOTO 10
C     LOOP UNTIL MAXY
      IF (IY .LE. MAXY) GOTO 11
d407 1
a407 1
998   IF (IRTFLG .NE. 0 .AND. WANTERRT)THEN
@


1.17
log
@added lundocredang
@
text
@d335 4
a338 2
C                USED FOR DOC FILES WITH REPEATED KEYS WHEN YOU DOD NOT
C                WISH TO LOSE THE REAPEATED DATA E.G. 'DOC REN' 
d343 1
a343 1
C                 MAXY    MAX Y ARRAY DIMENSION                  (SENT)
d411 2
a412 1
      GOTO 11 
d422 1
@


1.16
log
@added filnamsub to lundocparse
@
text
@d24 1
d695 96
@


1.15
log
@comment key test changed
@
text
@d3 2
a5 2
C LUNDOC.F                                     NEW APRIL 99 ARDEAN LEITH
C
d33 1
a33 1
C
d822 7
@


1.14
log
@comment keys do not have to be negative now
@
text
@d918 1
d927 1
a927 1
        ELSEIF (IKEY .LT. -999) THEN
a932 1
        IKEYA  = ABS(IKEY)
d953 1
a953 1
     &            KEYGOTD,ICOUNT,(PLIST(K),K=1,ICOUNT)
@


1.13
log
@lundocrddat bug for ud s after continuation
@
text
@d932 1
a932 1
        IKEYT  = ABS(IKEY)
d948 1
d950 1
a950 1
           IF (ICOUNTT .GT. 0 .AND. KEYGOT .EQ. IKEY) THEN
d953 1
a953 1
     &            KEYGOT,ICOUNT,(PLIST(K),K=1,ICOUNT)
d956 1
a956 1
           IF (KEYGOT .EQ. IKEY .AND. .NOT. TILLEND) GOTO 997
d966 1
a966 1
           WRITE(NOUT,91) IKEYT
@


1.12
log
@comment key recovery fixed
@
text
@d201 3
a204 1
      NEEDMORE =  (ICOUNTT .GT. 6)
@


1.11
log
@nlist gt 6
@
text
@d944 2
a945 2
C          MAKE SURE DLIST DOES NOT OVERFLOW
           ICOUNT = MIN(ICOUNTT,6,NLIST)
d947 2
a948 2
           IF (ICOUNT .GT. 0) THEN
C             READ THE DATA
d950 1
a950 1
     &            KEYGOT,ICOUNTT,(PLIST(K),K=1,ICOUNT)
@


1.10
log
@loop index converted to register
@
text
@d74 1
a74 1
        ELSEIF (NLIST .GE. 6) THEN 
@


1.9
log
@lundeocredsel now uses lundocredall and handles duplicated
keys better
@
text
@d858 3
a860 4
C          FIRST ENTRY IS A DO LOOP INDEX, PUT ITS VALUE INTO IKEY.
           IDX    = ICHAR(CTEMP) - 64
           IKEY   = IALPHA(IDX)
           IGO    = K + 2
@


1.8
log
@added traps for blank lines and key:0
@
text
@d317 5
a321 1
998   IF (IRTFLG .NE. 0 .AND. WANTERRT) CALLERRT(100,'LUNDOCREDALL',NE)
d331 3
a333 1
C                RECOVES SEQUENTIALLY, NOT BY KEY!!!
d411 5
a415 1
998   IF (IRTFLG .NE. 0 .AND. WANTERRT) CALLERRT(100,'LUNDOCREDSEQ',NE)
d438 56
@


1.7
log
@added lundocgetsel
@
text
@d83 5
d281 1
d302 2
a303 1
      IF (ICOUNT .LT. MAXXM1 .AND. ICOUNTT .LE. 6) THEN
d522 7
d532 1
a532 1
      ILOC = (IKEY -1) * MAXX + 1
d595 7
d673 8
d808 5
@


1.6
log
@catch key=0 problems
@
text
@d19 11
d393 78
@


1.5
log
@comments added
@
text
@d142 2
d149 4
a154 1
      IRTFLG   = 1
d265 5
d359 5
d387 1
a387 1
998   IF (IRTFLG .NE. 0 .AND. WANTERRT) CALLERRT(100,'LUNDOCREDALL',NE)
d396 3
a398 1
C    PURPOSE:    RECOVERS SPECIFIC LINE (KEY) FROM A DOC FILE
@


1.4
log
@*** empty log message ***
@
text
@d294 1
a294 1
C     ------------------------- LUNDOCREDALL -----------------------------
d381 1
a381 1
C    PURPOSE:    SUBROUTINE TO RECOVER ALL DATA FROM A DOC FILE
d449 2
a501 28

#ifdef NEVER
      INEW   = MIN(INEW,(NMAX-ICOUNT)

      IF ((ICOUNT + INEW) .GT. NMAX) THEN
C        DLIST WOULD OVERFLOW!!!, IGNORE EXTRAS, DO NOT GIVE ERROR
         INEW = NMAX - ICOUNT
      ENDIF

30       READ(LUNDOC,80,END=999,ERR=998) RECLIN

C        IGNORE CONTINUATION IF NO ROOM IN DLIST. 
         IF (ICOUNT .GE. NMAX) GOTO 30

C        IGNORE ANY INTERVENING COMMENT LINES (SHOULD NOT BE ANY!). 
C        IGNORE CONTINUATION IF NO ROOM IN DLIST. 
         IF (RECLIN(2:2) .EQ. ';') GOTO 30

         READ(RECLIN,82,END=998,ERR=998) IKEYT,ICOUNTT         
         IF (IKEYT .NE. -99) THEN
            WRITE(NOUT,92) RECLIN
92          FORMAT(' *** BAD CONTINUATION LINE: ',A/)
            CALL ERRT(100,'LUNDOCREDNXT',IDUM)
            RETURN
         ENDIF
         GOTO 20
      ENDIF
#endif
@


1.3
log
@added redseq
@
text
@d126 1
a126 1
C	           ICOUNT  NUMBER OF ELEMENTS IN ARRAY       (SENT?RET.)
d144 1
a144 1
         ICOUNT = MIN(NMAX,ICOUNT)
d531 1
a531 1
C  LUNDOCINFO(NDOC,MAXKEYT,MAXREGT,SAYIT,IRTFLG)
d541 2
d762 1
a762 1
           READ(RECLIN(1:80),82,ERR=50,END=997) KEYGOT,ICOUNT
d765 2
a766 3
C          READ THE DATA
           READ(RECLIN(1:80),82,ERR=50,END=998) 
     &          KEYGOT,ICOUNT,(PLIST(K),K=1,ICOUNT)
d768 6
d796 1
@


1.2
log
@added lundocredall
@
text
@a232 1
      IRTFLG  = 1
d294 83
d545 1
a545 1
        SUBROUTINE LUNDOCINFO(NDOC,MAXKEYT,MAXREGT,SAYIT,IRTFLG)
d557 1
d572 1
d586 1
a586 1
           WRITE(NOUT,97) MAXREGT, MAXKEYT
d588 1
a588 1
     &            ' KEYS',/)
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
C LUNDOC.F                                        NEW APRIL 99 ARDEAN LEITH
d199 154
d507 1
d695 1
a695 1
           CALL ERRT(100,'DOCCOM',NE)
d790 2
@
