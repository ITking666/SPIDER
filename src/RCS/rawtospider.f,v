head	1.66;
access;
symbols
	pre_mrcs:1.66
	healthdept_2018:1.66
	pre_getangas:1.63
	GPL2010:1.63
	pre_GPL2010:1.62
	pre_var_equation:1.62
	pre_fftwrings:1.60
	pre_opfiles:1.58
	src:1.58
	best-code:1.58
	named-reg:1.58
	x-named-regs:1.57
	x:1.57
	v13-00:1.56
	pre_GPL:1.54
	prec_CA:1.51
	noindx:1.45
	Bproc:1.37
	oct21:1.32
	last77:1.29;
locks; strict;
comment	@c @;


1.66
date	2018.10.03.14.34.13;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.12.19.13.17;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2012.04.16.18.27.35;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2010.06.24.13.26.38;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.22.13.29.18;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2008.12.19.15.27.03;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2007.08.02.13.45.12;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.30.16.13.40;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2005.12.12.15.28.45;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2005.11.15.21.51.05;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2005.10.17.20.05.19;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2005.10.17.18.00.25;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2004.04.15.14.13.08;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2004.04.05.14.55.50;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2004.04.05.14.47.53;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.03.17.00.41;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2003.02.28.21.15.48;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.28.20.42.17;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.19.20.51.49;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2003.01.28.21.10.35;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.24.19.53.34;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.06.20.13.29;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2002.03.29.19.53.17;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.14.14.22.55;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.11.14.07.55;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.05.14.03.58;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.04.19.00.54;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.04.18.41.48;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.14.14.22.23;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.25.13.59.52;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.14.13.21.57;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.12.18.45.25;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.02.19.27.21;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2000.01.27.15.12.01;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	99.10.04.15.44.54;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	99.09.13.16.27.38;	author pawel;	state Exp;
branches;
next	1.30;

1.30
date	99.04.15.15.13.39;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	99.03.26.16.18.30;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	99.03.25.20.09.23;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	99.03.25.14.07.16;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	99.03.16.17.50.42;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	99.02.22.16.51.41;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	99.02.19.18.44.26;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	99.02.16.16.06.25;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	99.02.08.21.06.10;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	98.10.29.18.48.07;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	98.10.27.13.59.28;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	98.10.26.20.54.28;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	98.04.07.15.46.32;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	98.04.07.14.19.18;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	98.01.27.17.09.49;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	97.12.10.16.59.13;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	97.11.07.20.07.44;	author hedget;	state Exp;
branches;
next	1.13;

1.13
date	97.10.28.14.46.55;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	97.07.18.16.47.15;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	97.07.14.18.22.02;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	97.04.17.15.53.32;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	96.11.20.17.09.25;	author liy;	state Exp;
branches;
next	1.8;

1.8
date	96.10.31.17.29.24;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	96.10.31.17.22.00;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	96.07.12.14.44.32;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	95.08.11.17.30.35;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	95.07.25.15.44.12;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	95.07.07.21.19.35;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.09.38;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.51.54;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.66
log
@email_health_dept
@
text
@
C++*************************************************************************
C
C  RAWTOSPIDER.F   -- CREATED               JUL 95 ARDEAN LEITH
C                     ADDED -32           APRIL 00 ARDEAN LEITH
C                     REWRITTEN           JUNE  01 ARDEAN LEITH
C                     ALTERED             MAR   02 ARDEAN LEITH
C                     RETURNED IOSTAT     JAN   03 ARDEAN LEITH
C                     QUESTION ORDER      FEB   03 ARDEAN LEITH
C                     RDPR PARAMETERS     04/14/05 ARDEAN LEITH
C                     -33 CORRECTED       07/30/07 ARDEAN LEITH
C                     64 ADDED            07/30/07 ARDEAN LEITH
C                     NPIX8               12/18/08 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  RAWTOSPIDER(LUNOLD,LUNNEW,IRTFLG)
C
C  PURPOSE:  CONVERTS "RAW" INTEGER TO SPIDER FORMAT
C  copyemi,copymrc,copyfromnik
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

       SUBROUTINE RAWTOSPIDER(LUNOLD,LUNNEW,IRTFLG)

       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       COMMON           BUFRAW(NBUFSIZ)

       CHARACTER(LEN=MAXNAM) :: FILOLD,FILNEW,PROMPT

       CHARACTER(LEN=1)      :: CDUM,ANS,NULL
       LOGICAL               :: FOLD,FLIP
       LOGICAL               :: BIGENDARCH,BIGENDED
       INTEGER * 8           :: NPIX8
 
       NULL = CHAR(0)

C      GET FILENAME FOR EXISTING RAW IMAGE FILE
       CALL FILERD(FILOLD,NLET,DATEXC,'EXISTING RAW~9',IRTFLG)
       IF (IRTFLG .NE. 0) RETURN

C      GET INPUT MODE NOW
       MODE = 8
       CALL RDPRI1S(MODE,NOT_USED,
     &       'BITS / PIXEL IN INPUT IMAGE (8, 16 OR 32)',IRTFLG)
       IF (IRTFLG .NE. 0) RETURN

       MODEA = ABS(MODE)
       IF (MODEA .EQ. 33) MODEA = 32
       IF (MODEA .EQ. 65) MODEA = 64

       IF (MODEA .NE. 8  .AND. 
     &     MODEA .NE. 16 .AND. 
     &     MODEA .NE. 32 .AND.
     &     MODEA .NE. 64) THEN
          CALL ERRT(100,'MUST BE (8,16,32,-32,33,64,-64, OR 65)!',NE)
          RETURN
       ENDIF

        NSLICE = 1
        NSAM   = -1
        CALL RDPRI3S(NSAM,NROW,NSLICE,NOT_USED,
     &               'COLUMNS, ROWS, & SLICES',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

22     IOFFSET = 0
       CALL RDPRI1S(IOFFSET,NOT_USED,
     &             'HEADER BYTES TO BE SKIPPED',IRTFLG)
       IF (IRTFLG .NE. 0) GOTO 9999

       IF ( MODEA .EQ. 16 .OR. MODEA .EQ. 64) THEN
23         ISIGB   = 1
           CALL RDPRI1S(ISIGB,NOT_USED,
     &        'MOST SIGNIFICANT BYTE (1 OR 2)',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
           IF (ISIGB .NE. 1 .AND. ISIGB .NE. 2) THEN
              CALL ERRT(16,'RAWTOSPIDER',NE)
              GOTO 23
           ENDIF

C          GET CURRENT ARCHITECTURE ENDED-NESS
           BIGENDARCH = BIGENDED(0)

           FLIP = .TRUE.
           IF ((ISIGB .EQ. 1 .AND. BIGENDARCH) .OR. 
     &         (ISIGB .EQ. 2 .AND. .NOT. BIGENDARCH)) FLIP = .FALSE. 

           CALL RDPRMC(ANS,NCHAR,.TRUE.,'FOLD NEGATIVES? (N/Y)',
     &                 CDUM,IRTFLG)
           IF (IRTFLG .EQ. -1) GOTO 23
           FOLD = (ANS .EQ. 'Y')
       ENDIF

C      CODE IS INVOLVED IF HEADER IS NOT SAME WORD LENGTH AS DATA

C      OPEN NEW OUTPUT SPIDER IMAGE FILE WITH SPECIFIED SIZE
       IFORM  = 1
       IF (NSLICE .GT. 1) IFORM = 3
       MAXIM = 0 
       CALL OPFILEC(0,.TRUE.,FILNEW,LUNNEW,'U',IFORM,NSAM,NROW,NSLICE,
     &              MAXIM,'NEW SPIDER IMAGE',.FALSE.,IRTFLG)
       IF (IRTFLG .EQ. -1) GOTO 22
       IF (IRTFLG .NE. 0) GOTO 9999

       NPIX8 = NSAM * NROW 
       NPIX8 = NPIX8 * NSLICE

       IOFFMOD2 = MOD(IOFFSET,2)
       IOFFMOD4 = MOD(IOFFSET,4)

C      OPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. 
       LENOPEN = NSAM * (MODEA / 8)
       IF (MODEA .EQ. 33) LENOPEN = NSAM * (32 / 8)
       CALL OPAUXFILE(.FALSE.,FILOLD,CHAR(0),LUNOLD,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
       IF (IRTFLG .NE. 0) GOTO 9999

       IF (MODE .EQ. 8) THEN
C         FOR 8 BIT RAW INTEGER INPUT 
          CALL RAW8TOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,.TRUE.,
     &                   LENOPEN,BUFRAW,IRTFLG)
       
       ELSEIF (MODE .EQ. 16 .AND. IOFFMOD2 .EQ. 0) THEN
C         16 BIT RAW INTEGER WITH HEADER LENGTH DIVISABLE BY TWO
          FOLD = .NOT. FOLD
          CALL RAW16TOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,FLIP,
     &                   FOLD,LENOPEN,BUFRAW,IRTFLG)

       ELSEIF (MODEA .EQ. 32) THEN
C         COPY/AND ALTER BYTE ORDER OF 32 BIT RAW FLOATING POINT IMAGES

          NFLIP = 0
          IF (MODE .EQ. -32) NFLIP = -1  ! INVERTS BYTES
          IF (MODE .EQ. -33) NFLIP =  1  ! FLIPS BYTES WITHIN WORDS
          IF (MODE .EQ.  33) NFLIP =  2  ! FLIPS BYTES & WORDS

          CALL RAW32TOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,
     &                    NFLIP,LENOPEN,BUFRAW,IRTFLG)

       ELSEIF (MODEA .EQ. 64 .OR. MODEA .EQ. 65) THEN
C         COPY/AND ALTER BYTE ORDER OF 32 BIT RAW INTEGER IMAGES

          NFLIP = 0
          IF (MODE .EQ. -64)  NFLIP = -1  ! INVERTS BYTES
          IF (MODE .EQ. -65)  NFLIP =  1  ! FLIPS BYTES WITHIN WORDS
          IF (MODE .EQ.  65)  NFLIP =  2  ! FLIPS BYTES & WORDS

          FOLD = .NOT. FOLD
          CALL RAW32INTTOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,
     &                    NFLIP,FOLD,LENOPEN,IRTFLG)

       ELSE
C         OTHER RAW IMAGE FORMATS OR CONVERSIONS (SLOW)

C         OPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. = 1 BYTE
          CLOSE(LUNOLD)
          LENOPEN = 1
          CALL OPAUXFILE(.FALSE.,FILOLD,CHAR(0),LUNOLD,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

          CALL RAWTOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,
     &                 MODE,FOLD,FLIP,ISIGB,IRTFLG)
       ENDIF


9999   CLOSE(LUNOLD)
       CLOSE(LUNNEW)

       RETURN
       END
     


C ------------------------- RAW8TOSPI -------------------------------

       SUBROUTINE RAW8TOSPI(LUNRAW,LUNSPI,NSAM,NPIX8,IOFFSET,FOLD,
     &                      LENOPEN,BUFRAW,IRTFLG)

C      FOR 8 BIT INPUT DATA

       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       COMMON /IOBUF/  BUFSPI(NBUFSIZ)

       INTEGER * 8 :: NPIX8,NEED8,IGOT8,NT8
       INTEGER *1  :: BUFRAW(LENOPEN)
       LOGICAL     :: FOLD

       IRECRAW = 0
       IRECSPI = 0
       LOCSPI  = 0
       IGOT8   = 0
       LOCRAW  = LENOPEN 

C      NEED8 IS NUMBER OF BYTE VALUES TO BE READ INCLUDING HEADER
       NEED8 = NPIX8 + IOFFSET

       DO WHILE (IGOT8 .LT. NEED8)
C         PROCESS EACH BYTE VALUE IN HEADER AND IMAGE
          LOCRAW = LOCRAW + 1

          IF (LOCRAW .GT. LENOPEN) THEN
C            NEED TO READ NEW RECORD FROM RAW INPUT FILE
             NVAL    = LENOPEN
             NT8     = NEED8 - IGOT8 
             IF (NT8 .LT. NVAL) NVAL = NT8
             IRECRAW = IRECRAW + 1
             CALL REDLIN8(LUNRAW,BUFRAW,NVAL,IRECRAW,IRTFLG)

             IF (IRTFLG .NE. 0 .AND. IRTFLG .NE. 253) THEN
                WRITE(NOUT,90) IRTFLG,IRECRAW,NVAL
90              FORMAT('*** IO ERROR: ',I5,' RECORD: ',I6,' NVAL: ',I6)
                CALL ERRT(101,'READING FILE',IDUM)
                RETURN
             ENDIF

             LOCRAW = 1
          ENDIF

          IGOT8 = IGOT8 + 1
          IF (IGOT8 .GT. IOFFSET) THEN
C            WANT THIS RAW VALUE FOR AN OUTPUT PIXEL

             LOCSPI = LOCSPI + 1

             IVAL   = BUFRAW(LOCRAW)
             IF (IVAL .LT. 0 .AND. FOLD) THEN
                BUFSPI(LOCSPI) = 256 + IVAL
             ELSE
                BUFSPI(LOCSPI) = IVAL
             ENDIF

             IF (LOCSPI .GE. NSAM) THEN
C               PUT OUT COMPLETED SPIDER RECORD
                IRECSPI = IRECSPI + 1
                CALL WRTLIN(LUNSPI,BUFSPI,NSAM,IRECSPI)
                LOCSPI = 0
             ENDIF
          ENDIF

      ENDDO

      IF (LOCSPI .GT. 0) THEN
C        PUT OUT UNFINISHED SPIDER RECORD
         IRECSPI = IRECSPI + 1
         NVAL    = MIN(NSAM,LOCSPI)
         CALL WRTLIN(LUNSPI,BUF,NVAL,IRECSPI)
      ENDIF

      RETURN
      END

C ------------------------- RAW16TOSPI ----------------------------------

       SUBROUTINE RAW16TOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,FLIP,
     &                      FOLD,LENOPEN,INBUFB,IRTFLG)

C      FOR 16 BIT INPUT DATA

       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       COMMON /IOBUF/  BUF(NBUFSIZ)

       INTEGER * 8 :: NPIX8,NEED8,IGOT8,NT8
       INTEGER *1  :: INBUFB(LENOPEN)
       LOGICAL     :: FOLD,FLIP

       INTEGER *2  :: I2VAL
       INTEGER *1  :: I1VAL(2)
       EQUIVALENCE     (I2VAL,I1VAL)
 
       IF (MOD(LENOPEN,2) .NE. 0) THEN
          CALL ERRT(102,'PGM ERROR, LENOPEN MUST BE EVEN',LENOPEN)
          RETURN
       ELSEIF (MOD(IOFFSET,2) .NE. 0) THEN
          CALL ERRT(102,'PGM ERROR, OFFSET MUST BE EVEN',IOFFSET)
          RETURN
       ENDIF

       IRECRAW = 0
       IRECSPI = 0
       ILOCSPI = 0
       IRECSPI = 0
       IGOT8   = 0
       ILOCRAW = LENOPEN

C      NEED8 IS NUMBER OF BYTE VALUES TO BE READ INCLUDING HEADER
       NEED8 = NPIX8 * 2  
       NEED8 = NEED8 + IOFFSET 

       DO WHILE (IGOT8 .LT. NEED8)
          ILOCRAW = ILOCRAW + 2
          IF (ILOCRAW .GT. LENOPEN) THEN
C            NEED TO READ NEW RECORD FROM INPUT
             NVAL    = LENOPEN
             NT8     = NEED8 - IGOT8 
             IF (NT8 .LT. NVAL) NVAL = NT8

             IRECRAW = IRECRAW + 1
             CALL REDLIN8(LUNOLD,INBUFB,NVAL,IRECRAW,IRTFLG)

             IF (IRTFLG .NE. 0 .AND. IRTFLG .NE. 253) THEN
                WRITE(NOUT,90) IRTFLG,IRECRAW,NVAL
90              FORMAT('*** IO ERROR: ',I5,' RECORD: ',I6,' NVAL: ',I6)
                CALL ERRT(101,'READING FILE',IDUM)
                RETURN
             ENDIF
             ILOCRAW = 1
          ENDIF

          IF (IGOT8 .GT. IOFFSET) THEN
C            WANT THIS VALUE FOR AN OUTPUT PIXEL

             IF (FLIP) THEN
                I1VAL(2) = INBUFB(ILOCRAW)
                I1VAL(1) = INBUFB(ILOCRAW+1)
             ELSE
                I1VAL(1) = INBUFB(ILOCRAW)
                I1VAL(2) = INBUFB(ILOCRAW+1)
             ENDIF

             ILOCSPI = ILOCSPI + 1
             IF (FOLD .AND. (I2VAL .LT. 0)) THEN
                BUF(ILOCSPI) = 65536 + I2VAL
             ELSE
                BUF(ILOCSPI) = I2VAL
             ENDIF

             IF (ILOCSPI .GE. NSAM) THEN
C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + 1
                CALL WRTLIN(LUNNEW,BUF,NSAM,IRECSPI)
                ILOCSPI = 0
             ENDIF
          ENDIF
          IGOT8 = IGOT8 + 2

      ENDDO

      IF (ILOCSPI .GT. 0) THEN
C        PUT OUT COMPLETED RECORD
         IRECSPI = IRECSPI + 1
         NVAL    = MIN(NSAM,ILOCSPI)
         CALL WRTLIN(LUNNEW,BUF,NSAM,IRECSPI)
      ENDIF

      RETURN
      END


C------------------------- RAW32TOSPI ----------------------------------

       SUBROUTINE RAW32TOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,
     &                       NFLIP,LENOPEN,INBUFB,IRTFLG)

C      FOR 32 BIT INPUT DATA

       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       COMMON /IOBUF/  BUF(NBUFSIZ)

       INTEGER * 8  :: NPIX8,NEED8,IGOT8,NT8
        LOGICAL     :: FLIP
       INTEGER *1      INBUFB(LENOPEN)

       REAL *4         R4VAL
       INTEGER *4      I4VAL
       INTEGER *2      I2VAL(4)
       INTEGER *1      I1VAL(4)
       EQUIVALENCE     (R4VAL,I1VAL)
       EQUIVALENCE     (I4VAL,I1VAL)
       EQUIVALENCE     (I2VAL,I1VAL)
 
C      PREVENT NaN ERROR IN DEBUG MODE
       I4VAL     = 0

       IF (MOD(LENOPEN,4) .NE. 0) THEN
          CALL ERRT(102,'PGM ERROR, LENOPENNOT DIVISABLE BY 4!',LENOPEN)
          RETURN
       ENDIF

       IRECRAW = 0
       IRECSPI = 0
       ILOCSPI = 0
       IRECSPI = 0
       IGOT8    = 0
       ILOCRAW = LENOPEN + 1
       LOCB    = 0
       IBYTE   = 0

C      NEED8 IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
       NEED8 = NPIX8 * 4 
       NEED8 = NEED8 + IOFFSET

       DO WHILE (IGOT8 .LT. NEED8)
          ILOCRAW = ILOCRAW + 1
          IF (ILOCRAW .GT. LENOPEN) THEN
C            NEED TO READ NEW RECORD FROM INPUT
             NVAL    = LENOPEN
             NT8     = NEED8 - IGOT8 
             IF (NT8 .LT. NVAL) NVAL = NT8

             IRECRAW = IRECRAW + 1
             CALL REDLIN8(LUNOLD,INBUFB,NVAL,IRECRAW,IRTFLG)

             IF (IRTFLG .NE. 0 .AND. IRTFLG .NE. 253) THEN
                WRITE(NOUT,90) IRTFLG,IRECRAW,NVAL
90              FORMAT('*** IO ERROR: ',I5,' RECORD: ',I6,' NVAL: ',I6)
                CALL ERRT(101,'READING FILE',IDUM)
                RETURN
             ENDIF

             ILOCRAW = 1
          ENDIF
C         IGOT8 POINTS TO CURRENT BYTE IN INPUT FILE
          IGOT8 = IGOT8 + 1

          IF (IGOT8 .GT. IOFFSET) THEN
C            WANT THIS VALUE FOR AN OUTPUT PIXEL
             IBYTE = IBYTE + 1

             IF (NFLIP .EQ. 0) THEN
C               NO FLIP
                I1VAL(IBYTE) = INBUFB(ILOCRAW)

             ELSEIF (NFLIP .EQ. -1) THEN
C               INVERT BYTE ORDER
                I1VAL(5-IBYTE) = INBUFB(ILOCRAW)

             ELSEIF (NFLIP .EQ. 1) THEN
C               FLIP BYTES WITHIN WORDS
                IF (IBYTE .EQ. 1) THEN
                   I1VAL(2) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 2) THEN
                   I1VAL(1) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 3) THEN
                   I1VAL(4) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 4) THEN
                   I1VAL(3) = INBUFB(ILOCRAW)
                ENDIF

             ELSEIF (NFLIP .EQ. 2) THEN
C               FLIP BYTES AND WORDS
                IF (IBYTE .EQ. 1) THEN
                   I1VAL(3) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 2) THEN
                   I1VAL(4) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 3) THEN
                   I1VAL(1) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 4) THEN
                   I1VAL(2) = INBUFB(ILOCRAW)
                ENDIF
             ENDIF

             IF (IBYTE .EQ. 4) THEN
C               TIME TO OUTPUT THE BYTES
                ILOCSPI      = ILOCSPI + 1
                BUF(ILOCSPI) = R4VAL
                IBYTE        = 0
#ifdef NEVER
                IF ((ILOCSPI .LE. 4) .AND. IRECSPI .EQ. 1) THEN
                   WRITE(6,*) 'ILOCSPI : ',ILOCSPI,' I1VALS: ',
     &                 I1VAL(1),I1VAL(2),I1VAL(3),I1VAL(4)
                   WRITE(6,*) 'I2VAL: ',I2VAL(1),I2VAL(2)
                   WRITE(6,*) 'R4VAL: ',R4VAL
                   WRITE(6,*) 'I4VAL: ',I4VAL
                   WRITE(6,*) ' '
                ENDIF
#endif
             ENDIF

             IF (ILOCSPI .GE. NSAM) THEN
C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + 1
                CALL WRTLIN(LUNNEW,BUF,NSAM,IRECSPI)
                ILOCSPI = 0

             ENDIF
          ENDIF
      ENDDO

      IF (ILOCSPI .GT. 0) THEN
C        PUT OUT REMAINING RECORD
         IRECSPI = IRECSPI + 1
         CALL WRTLIN(LUNNEW,BUF,NSAM,IRECSPI)
      ENDIF

      RETURN
      END

C dd if=avg000.dat of=tes032.dat count=16384 bs=1
C tail +1025c avg000.dat > tes032.dat

#ifdef NEVER
             if (icount .le. 1) THEN
               write(6,*) 'inbufb(',ILOCRAW,'): ',inbufb(ILOCRAW)
               it = ilocin + 1
               write(6,*) 'inbufb(',it,'): ',inbufb(it)
               write(6,*) 'i1val(1):  ', i1val(1),' i1val(2): ',i1val(2)
               write(6,*) 'i1val(3):  ', i1val(3),' i1val(4): ',i1val(4)
               write(6,*) 'i4val: ',i4val

c               write(6,*) '  buf(',ilocout,'): ',buf(ilocout)
c               write(6,*) 'i2val(1):  ', i2val(1),' i2val(2): ',i2val(2)
c               write(6,*) 'ilocin: ', ilocin,' ilocout: ',ilocout
c               write(6,*) 'recin:  ', irecin,' irow: ',irow
               write(6,*) ' -------------',icount
               icount = icount + 1
             endif
#endif



C------------------------- RAW32INTTOSPI ----------------------------------

       SUBROUTINE RAW32INTTOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,
     &                       NFLIP,FOLD,LENOPEN,IRTFLG)

C      FOR 32 BIT INTEGER INPUT DATA (SOME OF THIS IS PROBABLY 
C      REDUNDANT AND NOT NECESSARY!! al

       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       INTEGER * 8  :: NPIX8,NEED8,IGOT8,NT8
       REAL         :: RBUF(NBUFSIZ)
       LOGICAL      :: FOLD                    

       INTEGER *1   :: INBUFB(LENOPEN)

       INTEGER *4   :: I4VAL
       INTEGER *1   :: I1VAL(4)
       EQUIVALENCE (I4VAL,I1VAL)
 
C      PREVENT NaN ERROR IN DEBUG MODE
       I4VAL     = 0

       IF (MOD(LENOPEN,4) .NE. 0) THEN
          CALL ERRT(102,'PGM ERROR, LENOPENNOT DIVISABLE BY 4!',LENOPEN)
          RETURN
       ENDIF

       IRECRAW = 0
       IRECSPI = 0
       ILOCSPI = 0
       IRECSPI = 0
       IGOT8   = 0
       ILOCRAW = LENOPEN + 1
       LOCB    = 0
       IBYTE   = 0

C      NEED8 IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
       NEED8 = NPIX8 * 4 
       NEED8 = NEED8 + IOFFSET

       DO WHILE (IGOT8 .LT. NEED8)
          ILOCRAW = ILOCRAW + 1
          IF (ILOCRAW .GT. LENOPEN) THEN
C            NEED TO READ NEW RECORD FROM INPUT
             NVAL    = LENOPEN
             NT8     = NEED8 - IGOT8 
             IF (NT8 .LT. NVAL) NVAL = NT8
             IRECRAW = IRECRAW + 1
             CALL REDLIN8(LUNOLD,INBUFB,NVAL,IRECRAW,IRTFLG)

             IF (IRTFLG .NE. 0 .AND. IRTFLG .NE. 253) THEN
                WRITE(NOUT,90) IRTFLG,IRECRAW,NVAL
90              FORMAT('*** IO ERROR: ',I5,' RECORD: ',I6,' NVAL: ',I6)
                CALL ERRT(101,'READING FILE',IDUM)
                RETURN
             ENDIF

             ILOCRAW = 1
          ENDIF
C         IGOT8 POINTS TO CURRENT BYTE IN INPUT FILE
          IGOT8 = IGOT8 + 1

          IF (IGOT8 .GT. IOFFSET) THEN
C            WANT THIS VALUE FOR AN OUTPUT PIXEL
             IBYTE = IBYTE + 1

             IF (NFLIP .EQ. 0) THEN
C               NO FLIP  (64)
                I1VAL(IBYTE) = INBUFB(ILOCRAW)

             ELSEIF (NFLIP .EQ. -1) THEN
C               INVERT BYTE ORDER   (-64)
                I1VAL(5-IBYTE) = INBUFB(ILOCRAW)

             ELSEIF (NFLIP .EQ. 1) THEN
C               FLIP BYTES WITHIN WORDS   (65)
                IF (IBYTE .EQ. 1) THEN
                   I1VAL(2) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 2) THEN
                   I1VAL(1) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 3) THEN
                   I1VAL(4) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 4) THEN
                   I1VAL(3) = INBUFB(ILOCRAW)
                ENDIF

             ELSEIF (NFLIP .EQ. 2) THEN
C               FLIP BYTES AND WORDS   (-65)
                IF (IBYTE .EQ. 1) THEN
                   I1VAL(3) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 2) THEN
                   I1VAL(4) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 3) THEN
                   I1VAL(1) = INBUFB(ILOCRAW)
                ELSEIF (IBYTE .EQ. 4) THEN
                   I1VAL(2) = INBUFB(ILOCRAW)
                ENDIF
             ENDIF


             IF (IBYTE .EQ. 4) THEN
C               TIME TO OUTPUT THE BYTES
                ILOCSPI       = ILOCSPI + 1
                IF (FOLD .AND. (I4VAL .LT. 0)) THEN
#if defined (SP_GFORTRAN)
                   RBUF(ILOCSPI) = 2.0**32 + I4VAL
#else
                   RBUF(ILOCSPI) = 2**32 + I4VAL
#endif
                ELSE
                   RBUF(ILOCSPI) = I4VAL
                ENDIF
                IBYTE         = 0
             ENDIF


             IF (ILOCSPI .GE. NSAM) THEN
C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + 1
                CALL WRTLIN(LUNNEW,RBUF,NSAM,IRECSPI)
                ILOCSPI = 0
             ENDIF
          ENDIF
      ENDDO

      IF (ILOCSPI .GT. 0) THEN
C        PUT OUT REMAINING RECORD
         IRECSPI = IRECSPI + 1
         CALL WRTLIN(LUNNEW,RBUF,NSAM,IRECSPI)
      ENDIF

      RETURN
      END

C ------------------------- RAWTOSPI ----------------------------------

       SUBROUTINE RAWTOSPI(LUNOLD,LUNNEW,NSAM,NPIX8,IOFFSET,
     &                     MODE,FOLD,FLIP,ISIGB,IRTFLG)

       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       COMMON /IOBUF/  FBUF(NBUFSIZ)

       INTEGER * 8      :: NPIX8,NBYTES8
       CHARACTER(LEN=1) :: CINBUF
c       EQUIVALENCE     (CINBUF,I1BUF)

       REAL *4         F4BUF
       INTEGER * 1     I1BUF(4)
       EQUIVALENCE     (F4BUF,I1BUF)

       LOGICAL  ::     FOLD,FLIP
       INTEGER * 1     I1VAL(4)
       INTEGER * 4     I4VAL
       EQUIVALENCE     (I4VAL,I1VAL(1))
       EQUIVALENCE     (FVAL,I1VAL(1))
 

C      CLEAN THE BUFFER, THIS ASSUMES THE INTENSITIES IN THE RAW IMAGE 
C      ARE ALL POSITIVE NUMBERS				---- liy
       DO I = 1, 4
	  I1VAL(I) = 0
       ENDDO

C      ILOCSPI IS POINTER TO CURRENT NUMBER OF IMAGE VALUES OUTPUT TO
C      CURRENT OUTPUT RECORD
       ILOCSPI = 0

C      IRECSPI IS NUMBER OF CURRENT OUTPUT RECORD
       IRECSPI   = 0

C      BYTE POINTER FOR 16 & 32 BIT INPUT
       IBITE  = 0

       NBYTES8 = NPIX8 * ABS(MODE)
       NBYTES8 = NBYTES8 / 8

#if  defined (SP_NT) || defined (__osf__) || defined (__linux__) 
C      MUST ADJUST BYTE ORDER IN I4VAL
       LOC1 = 1
       LOC2 = 2
#else
       LOC1 = 3
       LOC2 = 4
#endif

       IF (IOFFSET .GT. 0) THEN
C         SKIP HEADER OFFSET

          DO ILOC = 1,IOFFSET
C            THE (1) IS ESSENTIAL ON THESE READS
             READ(LUNOLD,REC=ILOC,IOSTAT=IRTFLG) I1BUF(1)
             IF (IRTFLG .NE. 0) THEN
                WRITE(NOUT,90) IRTFLG,ILOC
90              FORMAT('*** ERROR: (',I5,
     &                 ') READING HEADER BYTE: ',I4)
                CALL ERRT(100,'RAWTOSPI',NE)
                RETURN
             ENDIF
          ENDDO
       ENDIF

C      DEC 08 possible overflow of iloc for large nbytes8???? al
       DO ILOC =  IOFFSET + 1,IOFFSET + NBYTES8
          READ(LUNOLD,REC=ILOC,IOSTAT=IRTFLG) I1BUF(1)

          IF (IRTFLG .NE. 0) THEN
             WRITE(NOUT,91) IRTFLG, ILOC - IOFFSET
91           FORMAT('*** ERROR: (',I5,') READING IMAGE BYTE: ',I8)
             CALL ERRT(100,'RAWTOSPI',NE)
             RETURN
          ENDIF

          IF (MODE .EQ. 8) THEN
C            INPUT IS 8 BIT ------------------------------- 8 BIT IN
C            CONVERT TO 32 BIT FLOATING POINT 
             ILOCSPI = ILOCSPI + 1
             IVAL    = I1BUF(1)
             IF (IVAL .LT. 0) IVAL = 256 + IVAL
             FBUF(ILOCSPI) = IVAL

          ELSE IF (MODE .EQ. 16) THEN
C            INPUT IS 16 BIT ----------------------------- 16 BIT IN
C            CONVERT TO 32 BIT FLOATING POINT 
             IBITE = IBITE + 1
             IF (ISIGB .EQ. 1 .AND. IBITE .EQ. 1) THEN
                I1VAL(LOC1) = I1BUF(1)
             ELSE IF (ISIGB .EQ. 1 .AND. IBITE .EQ. 2) THEN
                I1VAL(LOC2) = I1BUF(1)
             ELSE IF (IBITE .EQ. 1) THEN
                I1VAL(LOC2) = I1BUF(1)
             ELSE IF (IBITE .EQ. 2) THEN
                 I1VAL(LOC1) = I1BUF(1)
             ENDIF                 
             IF (IBITE .EQ. 2) THEN
C               PUT OUT COMPLETED VALUE
                IF (FOLD) THEN
                   IF (I4VAL .LE. 32767) THEN
                      I4VAL = I4VAL + 32768
                   ELSE
                      I4VAL = I4VAL - 32768
                   ENDIF
                ENDIF
                ILOCSPI       = ILOCSPI + 1
                FBUF(ILOCSPI) = I4VAL
                IBITE         = 0
             ENDIF

          ELSE IF (MODE .EQ. 32) THEN
C            INPUT IS 32 BIT ---------------------------- 32 BIT IN
C            CONVERT TO 32 BIT FLOATING POINT 
             IBITE        = IBITE + 1
             IF (FLIP) THEN
                I1VAL(5 - IBITE) = I1BUF(1)
             ELSE
                I1VAL(IBITE) = I1BUF(1)
             ENDIF

             IF (IBITE .GE. 4) THEN
C               PUT OUT COMPLETED VALUE
                ILOCSPI       = ILOCSPI + 1
                FBUF(ILOCSPI) = FVAL
                IBITE         = 0
             ENDIF

         ENDIF

         IF (ILOCSPI .EQ. NSAM) THEN
C           PUT OUT COMPLETED RECORD
            IRECSPI = IRECSPI + 1
            CALL WRTLIN(LUNNEW,FBUF,NSAM,IRECSPI)
            ILOCSPI = 0
         ENDIF
      ENDDO

      IF (ILOCSPI .GT. 0) THEN
C        PUT OUT COMPLETED RECORD
         IRECSPI = IRECSPI + 1
         CALL WRTLIN(LUNNEW,FBUF,NSAM,IRECSPI)
      ENDIF

C     SET NO ERROR FLAG
      IRTFLG = 0

      RETURN
      END

@


1.65
log
@enter
@
text
@d20 1
a20 1
C=* Email: spider@@wadsworth.org                                        *
@


1.64
log
@#if defined (SP_GFORTRAN)  RBUF(ILOCSPI) = 2.0**32 + I4VAL
@
text
@d67 1
a67 1
     &       'ENTER BITS / PIXEL IN INPUT IMAGE (8, 16 OR 32)',IRTFLG)
d85 1
a85 1
     &               'ENTER COLUMNS, ROWS, & SLICES',IRTFLG)
d90 1
a90 1
     &             'ENTER HEADER BYTES TO BE SKIPPED',IRTFLG)
d96 1
a96 1
     &        'ENTER MOST SIGNIFICANT BYTE (1 OR 2)',IRTFLG)
@


1.63
log
@GPL_2010
@
text
@d646 3
d650 1
@


1.62
log
@integer 8
@
text
@a14 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d16 5
a20 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d22 1
a22 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d27 1
a27 1
C=* This program is distributed in the hope that it will be useful,    *
d29 1
a29 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a30 1
C=*                                                                    *
d32 1
a32 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.61
log
@npix8
@
text
@d213 1
a213 1
       INTEGER * 8 :: NPIX8,NEED8,IGOT8
d232 3
a234 1
             NVAL    = MIN(LENOPEN,NEED8-IGOT8)
d252 1
a252 1
             LOCSPI         = LOCSPI + 1
d254 1
a254 1
             IVAL = BUFRAW(LOCRAW)
a270 3
          write(6,*) ' locspi:' ,locspi


d293 1
a293 1
       INTEGER * 8 :: NPIX8,NEED8,IGOT8
d317 2
a318 1
       NEED8 = NPIX8 * 2 + IOFFSET 
d324 4
a327 1
             NVAL    = MIN(LENOPEN,NEED8-IGOT8)
d392 1
a392 1
       INTEGER * 8  :: NPIX8,NEED8,IGOT8
d422 2
a423 1
       NEED8 = NPIX8 * 4 + IOFFSET
d429 4
a432 1
             NVAL    = MIN(LENOPEN,NEED8-IGOT8)
d507 1
d555 1
a555 1
       INTEGER * 8  :: NPIX8,NEED8,IGOT8
d577 1
a577 1
       IGOT8    = 0
d583 2
a584 1
       NEED8 = NPIX8 * 4 + IOFFSET
d590 3
a592 1
             NVAL    = MIN(LENOPEN,NEED8-IGOT8)
d717 2
a718 1
       NBYTES8 = NPIX8 * (ABS(MODE) / 8)
@


1.60
log
@bad filerd ~9
@
text
@d13 1
d16 1
a16 1
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d43 1
d60 1
d131 2
a132 1
       NPIX = NSAM * NROW * NSLICE
d146 1
a146 1
          CALL RAW8TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,.TRUE.,
d152 1
a152 1
          CALL RAW16TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,FLIP,
d163 1
a163 1
          CALL RAW32TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,
d175 1
a175 1
          CALL RAW32INTTOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,
d188 1
a188 1
          CALL RAWTOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,
d203 1
a203 1
       SUBROUTINE RAW8TOSPI(LUNRAW,LUNSPI,NSAM,NPIX,IOFFSET,FOLD,
d213 3
a215 2
       INTEGER *1      BUFRAW(LENOPEN)
       LOGICAL         FOLD
d220 1
a220 1
       IGOT    = 0
d223 2
a224 2
C      NEED IS NUMBER OF BYTE VALUES TO BE READ INCLUDING HEADER
       NEED = NPIX + IOFFSET
d226 1
a226 1
       DO WHILE (IGOT .LT. NEED)
d232 1
a232 1
             NVAL    = MIN(LENOPEN,NEED-IGOT)
d246 2
a247 2
          IGOT = IGOT + 1
          IF (IGOT .GT. IOFFSET) THEN
d269 3
d284 1
a284 1
       SUBROUTINE RAW16TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,FLIP,
d294 3
a296 2
       INTEGER *1      INBUFB(LENOPEN)
       LOGICAL         FOLD,FLIP
d298 2
a299 2
       INTEGER *2      I2VAL
       INTEGER *1      I1VAL(2)
d314 1
a314 1
       IGOT    = 0
d317 2
a318 2
C      NEED IS NUMBER OF BYTE VALUES TO BE READ INCLUDING HEADER
       NEED = NPIX * 2 + IOFFSET 
d320 1
a320 1
       DO WHILE (IGOT .LT. NEED)
d324 1
a324 1
             NVAL    = MIN(LENOPEN,NEED-IGOT)
d337 1
a337 1
          IF (IGOT .GT. IOFFSET) THEN
d362 1
a362 1
          IGOT = IGOT + 2
d379 1
a379 1
       SUBROUTINE RAW32TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,
d389 2
a390 1
       LOGICAL ::      FLIP
d413 1
a413 1
       IGOT    = 0
d418 2
a419 2
C      NEED IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
       NEED = NPIX * 4 + IOFFSET
d421 1
a421 1
       DO WHILE (IGOT .LT. NEED)
d425 1
a425 1
             NVAL    = MIN(LENOPEN,NEED-IGOT)
d438 2
a439 2
C         IGOT POINTS TO CURRENT BYTE IN INPUT FILE
          IGOT = IGOT + 1
d441 1
a441 1
          IF (IGOT .GT. IOFFSET) THEN
d538 1
a538 1
       SUBROUTINE RAW32INTTOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,
d547 1
d569 1
a569 1
       IGOT    = 0
d574 2
a575 2
C      NEED IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
       NEED = NPIX * 4 + IOFFSET
d577 1
a577 1
       DO WHILE (IGOT .LT. NEED)
d581 1
a581 1
             NVAL    = MIN(LENOPEN,NEED-IGOT)
d594 2
a595 2
C         IGOT POINTS TO CURRENT BYTE IN INPUT FILE
          IGOT = IGOT + 1
d597 1
a597 1
          IF (IGOT .GT. IOFFSET) THEN
d667 1
a667 1
       SUBROUTINE RAWTOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,
d675 2
a676 1
       CHARACTER(LEN=1) ::    CINBUF
d706 1
a706 1
       NBYTES = NPIX * (ABS(MODE) / 8)
d733 2
a734 1
       DO ILOC =  IOFFSET + 1,IOFFSET + NBYTES
@


1.59
log
@64 and -33 fixec
@
text
@d62 1
a62 1
       CALL FILERD(FILOLD,NLET,DATEXC,'EXISTING RAW',IRTFLG)
@


1.58
log
@native named registers
@
text
@d11 2
d15 1
a15 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d51 1
a51 2
       CHARACTER(LEN=MAXNAM) ::   FILOLD,FILNEW
       COMMON /COMMUN/ FILOLD,FILNEW
d53 1
a53 1
       COMMON           BUFRAW(NBUFSIZ)
a54 1
       CHARACTER(LEN=MAXNAM) :: PROMPT
d56 2
a57 3
       LOGICAL               :: FOLD,FLIP,STRIP
       LOGICAL               :: BIGENDARCH,BIGENDED,GETANS
       LOGICAL               :: UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI
d62 1
a62 10
       UPPER     = .FALSE.
       SAYPRMT   = .TRUE.
       WANTSUB   = .TRUE.
       SAYANS    = .FALSE.
       ENDATSEMI = .TRUE.
       GETANS    = .TRUE.
       STRIP     = .TRUE.

       CALL RDPR('EXISTING RAW FILE',NLET,FILOLD,GETANS,
     &            UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI,STRIP,IRTFLG)
d65 1
a65 2
       K = VERIFY(FILOLD(1:NLET),'81632-3')

d67 1
a67 11
       IF (K .NE. 0) THEN
C         THIS IS A FILENAME

C         PROCESS FILOLD TO GET EXISTING RAW IMAGE FILE NAME
          PROMPT = '~' // FILOLD(:NLET) // '~9' // CHAR(0)
          CALL FILERD(FILOLD,NLET,DATEXC,PROMPT,IRTFLG)
          IF (IRTFLG .NE. 0) RETURN

C         INPUT MODE NOW
          PROMPT = 'ENTER BITS / PIXEL IN INPUT IMAGE (8, 16 OR 32)'
          CALL RDPRI1S(MODE,NOT_USED,
d69 1
a69 1
          IF (IRTFLG .NE. 0) RETURN
d71 3
a73 10
       ELSE
C         FILOLD IS A MODE (OLDSTYLE INPUT), PROCESS MODE INPUT
          PROMPT = '~' // FILOLD
          CALL RDPRI1S(MODE,NOT_USED,PROMPT,IRTFLG)
          IF (IRTFLG .NE. 0) RETURN

C         THIS IS A MODE (OLDSTYLE INPUT), GET A FILENAME
          CALL FILERD(FILOLD,NLET,DATEXC,'EXISTING RAW',IRTFLG)
          IF (IRTFLG .NE. 0) RETURN
       ENDIF
d75 5
a79 4
       MODEA = ABS(MODE)
       IF (MODEA .NE. 8 .AND. MODEA .NE. 16 .AND. MODEA .NE. 32 .AND.
     &     MODEA .NE. 33) THEN
          CALL ERRT(100,'BITS / PIXEL MUST BE (8,16,32,-32 OR 33)!',NE)
d94 1
a94 1
       IF (MODE .EQ. 16) THEN
d114 1
a114 2
           FOLD = (ANS .EQ. 'Y') 

a141 1

d155 3
a157 6
C         MODE -32 REVERSES BYTES
          IF (MODE .EQ. -32) NFLIP = -1
C         MODE 33 FLIPS BYTES & WORDS
          IF (MODE .EQ.  33) NFLIP = 2
C         MODE -33 FLIPS BYTES 
          IF (MODE .EQ.  33) NFLIP = 2
d161 13
a195 151
C ------------------------- RAWTOSPI ----------------------------------

       SUBROUTINE RAWTOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,
     &                     MODE,FOLD,FLIP,ISIGB,IRTFLG)

       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       COMMON /IOBUF/  FBUF(NBUFSIZ)

       CHARACTER(LEN=1) ::    CINBUF
c       EQUIVALENCE     (CINBUF,I1BUF)

       REAL *4         F4BUF
       INTEGER * 1     I1BUF(4)
       EQUIVALENCE     (F4BUF,I1BUF)

       LOGICAL  ::     FOLD,FLIP
       INTEGER * 1     I1VAL(4)
       INTEGER * 4     I4VAL
       EQUIVALENCE     (I4VAL,I1VAL(1))
       EQUIVALENCE     (FVAL,I1VAL(1))
 

C      CLEAN THE BUFFER, THIS ASSUMES THE INTENSITIES IN THE RAW IMAGE 
C      ARE ALL POSITIVE NUMBERS				---- liy
       DO I = 1, 4
	  I1VAL(I) = 0
       ENDDO

C      ILOCSPI IS POINTER TO CURRENT NUMBER OF IMAGE VALUES OUTPUT TO
C      CURRENT OUTPUT RECORD
       ILOCSPI = 0

C      IRECSPI IS NUMBER OF CURRENT OUTPUT RECORD
       IRECSPI   = 0

C      BYTE POINTER FOR 16 & 32 BIT INPUT
       IBITE  = 0

       NBYTES = NPIX * (ABS(MODE) / 8)

#if  defined (SP_NT) || defined (__osf__) || defined (__linux__) 
C      MUST ADJUST BYTE ORDER IN I4VAL
       LOC1 = 1
       LOC2 = 2
#else
       LOC1 = 3
       LOC2 = 4
#endif

       IF (IOFFSET .GT. 0) THEN
C         SKIP HEADER OFFSET

          DO ILOC = 1,IOFFSET
C            THE (1) IS ESSENTIAL ON THESE READS
             READ(LUNOLD,REC=ILOC,IOSTAT=IRTFLG) I1BUF(1)
             IF (IRTFLG .NE. 0) THEN
                WRITE(NOUT,90) IRTFLG,ILOC
90              FORMAT('*** ERROR: (',I5,
     &                 ') READING HEADER BYTE: ',I4)
                CALL ERRT(100,'RAWTOSPI',NE)
                RETURN
             ENDIF
          ENDDO
       ENDIF

       DO ILOC =  IOFFSET + 1,IOFFSET + NBYTES
          READ(LUNOLD,REC=ILOC,IOSTAT=IRTFLG) I1BUF(1)

          IF (IRTFLG .NE. 0) THEN
             WRITE(NOUT,91) IRTFLG, ILOC - IOFFSET
91           FORMAT('*** ERROR: (',I5,') READING IMAGE BYTE: ',I8)
             CALL ERRT(100,'RAWTOSPI',NE)
             RETURN
          ENDIF

          IF (MODE .EQ. 8) THEN
C            INPUT IS 8 BIT ------------------------------- 8 BIT IN
C            CONVERT TO 32 BIT FLOATING POINT 
             ILOCSPI = ILOCSPI + 1
             IVAL    = I1BUF(1)
             IF (IVAL .LT. 0) IVAL = 256 + IVAL
             FBUF(ILOCSPI) = IVAL

          ELSE IF (MODE .EQ. 16) THEN
C            INPUT IS 16 BIT ----------------------------- 16 BIT IN
C            CONVERT TO 32 BIT FLOATING POINT 
             IBITE = IBITE + 1
             IF (ISIGB .EQ. 1 .AND. IBITE .EQ. 1) THEN
                I1VAL(LOC1) = I1BUF(1)
             ELSE IF (ISIGB .EQ. 1 .AND. IBITE .EQ. 2) THEN
                I1VAL(LOC2) = I1BUF(1)
             ELSE IF (IBITE .EQ. 1) THEN
                I1VAL(LOC2) = I1BUF(1)
             ELSE IF (IBITE .EQ. 2) THEN
                 I1VAL(LOC1) = I1BUF(1)
             ENDIF                 
             IF (IBITE .EQ. 2) THEN
C               PUT OUT COMPLETED VALUE
                IF (FOLD) THEN
                   IF (I4VAL .LE. 32767) THEN
                      I4VAL = I4VAL + 32768
                   ELSE
                      I4VAL = I4VAL - 32768
                   ENDIF
                ENDIF
                ILOCSPI       = ILOCSPI + 1
                FBUF(ILOCSPI) = I4VAL
                IBITE         = 0
             ENDIF

          ELSE IF (MODE .EQ. 32) THEN
C            INPUT IS 32 BIT ---------------------------- 32 BIT IN
C            CONVERT TO 32 BIT FLOATING POINT 
             IBITE        = IBITE + 1
             IF (FLIP) THEN
                I1VAL(5 - IBITE) = I1BUF(1)
             ELSE
                I1VAL(IBITE) = I1BUF(1)
             ENDIF

             IF (IBITE .GE. 4) THEN
C               PUT OUT COMPLETED VALUE
                ILOCSPI       = ILOCSPI + 1
                FBUF(ILOCSPI) = FVAL
                IBITE         = 0
             ENDIF

         ENDIF

         IF (ILOCSPI .EQ. NSAM) THEN
C           PUT OUT COMPLETED RECORD
            IRECSPI = IRECSPI + 1
            CALL WRTLIN(LUNNEW,FBUF,NSAM,IRECSPI)
            ILOCSPI = 0
         ENDIF
      ENDDO

      IF (ILOCSPI .GT. 0) THEN
C        PUT OUT COMPLETED RECORD
         IRECSPI = IRECSPI + 1
         CALL WRTLIN(LUNNEW,FBUF,NSAM,IRECSPI)
      ENDIF

C     SET NO ERROR FLAG
      IRTFLG = 0

      RETURN
      END

d435 5
a439 1
             IF (NFLIP .EQ. -1) THEN
d447 1
a447 1
                ELSEIF (IBYTE .eq. 2) THEN
d449 1
a449 1
                ELSEIF (IBYTE .eq. 3) THEN
d454 1
d459 1
a459 1
                ELSEIF (IBYTE .eq. 2) THEN
d461 1
a461 1
                ELSEIF (IBYTE .eq. 3) THEN
a465 3
             ELSE
C               NO FLIP
                I1VAL(IBYTE) = INBUFB(ILOCRAW)
d524 281
@


1.57
log
@named register support
@
text
@d56 1
a56 1
       LOGICAL               :: FOLD,FLIP
d69 1
a70 1
COLD   CALL RDPR('EXISTING RAW FILE',NLET,FILOLD,.FALSE.,.TRUE.,IRTFLG)
d72 1
a72 1
     &            UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI, IRTFLG)
@


1.56
log
@GPL License fixed
@
text
@d2 1
a2 1
C++*********************************************************************
d4 7
a10 6
C  RAWTOSPIDER.F   -- CREATED            JUL 95 ARDEAN LEITH
C                     ADDED -32        APRIL 00 ARDEAN LEITH
C                     REWRITTEN        JUNE  01 ARDEAN LEITH
C                     ALTERED          MAR   02 ARDEAN LEITH
C                     RETURNED IOSTAT  JAN   03 ARDEAN LEITH
C                     QUESTION ORDER   FEB   03 ARDEAN LEITH
d57 2
a58 1
       LOGICAL               :: BIGENDARCH,BIGENDED
d63 10
a72 1
       CALL RDPR('EXISTING RAW FILE',NLET,FILOLD,.FALSE.,.TRUE.,IRTFLG)
@


1.55
log
@HRI GPL License used
@
text
@a2 1
C++*************************************************************************
a10 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d14 1
a14 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a33 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.54
log
@.ext bug
@
text
@d2 1
d13 24
@


1.53
log
@typo
@
text
@d54 1
a54 1
          PROMPT = '~' // FILOLD // '~9' // CHAR(0)
@


1.52
log
@~9 for allowing extension
@
text
@d54 1
a54 1
          PROMPT = '~' // FILOLD // ~9 // CHAR(0)
@


1.51
log
@*** empty log message ***
@
text
@d54 1
a54 2
          IRTFLG = 9
          PROMPT = '~' // FILOLD
@


1.50
log
@*** empty log message ***
@
text
@d62 1
a62 1
     &           'ENTER BITS / PIXEL IN INPUT IMAGE (8, 16 OR 32)',IRTFLG)
@


1.49
log
@order of questions changed
@
text
@d44 1
a44 1
10     CALL RDPR('EXISTING RAW',NLET,FILOLD,.FALSE.,.TRUE.,IRTFLG)
d50 1
a50 1
       IF (K .EQ. 0) THEN
d61 2
a62 1
          CALL RDPRI1S(MODE,NOT_USED,PROMPT,IRTFLG)
d83 1
a83 7
C      GET FILENAME FOR EXISTING RAW IMAGE FILE
10     IRTFLG = 9
       CALL FILERD(FILOLD,NLET,DATEXC,'EXISTING RAW',IRTFLG)
       IF (IRTFLG .EQ. -1) GOTO 8
       IF (IRTFLG .NE. 0) RETURN

20      NSLICE = 1
a91 1
       IF (IRTFLG .EQ. -1) GOTO 20
d98 1
a98 1
           IF (IRTFLG .EQ. -1) GOTO 22
@


1.48
log
@opfilec
@
text
@d9 1
a9 1
C
d36 4
a39 3
       CHARACTER(LEN=1) :: CDUM,ANS,NULL
       LOGICAL          :: FOLD,FLIP
       LOGICAL          :: BIGENDARCH,BIGENDED
d43 31
a73 4
8      MODE = 8
       CALL RDPRI1S(MODE,NOT_USED,
     &    'ENTER BITS / PIXEL IN INPUT IMAGE (8, 16 OR 32)',IRTFLG)
       IF (IRTFLG .EQ. -1) RETURN
d91 2
a92 7
     &               'ENTER COLUMNS, ROWS & SLICES',IRTFLG)
        IF (IRTFLG .EQ. -1) THEN
           GOTO 10
        ELSEIF (IRTFLG .NE. 0 .OR. NSAM .LE. 0 .OR. NROW .LE. 0) THEN
           CALL ERRT(101,'NSAM, NROW & NSLICE MUST BE > 0',IDUM)
           GOTO 9999
        ENDIF
@


1.47
log
@SP_LINUX --> __linux__.
@
text
@a33 1
 
d107 2
a108 2
       CALL OPFIL(.TRUE.,FILNEW,LUNNEW,'U',NSAM,NROW,NSLICE,
     &            MAXIM,'NEW SPIDER IMAGE',.FALSE.,IRTFLG)
@


1.46
log
@redlin8 returns irtflg
@
text
@d214 1
a214 1
#if  defined (SP_NT) || defined (__osf__) || defined (SP_LINUX) 
@


1.45
log
@fixed
@
text
@d4 5
a8 4
C  RAWTOSPIDER.F   -- CREATED JUL 95     ARDEAN LEITH
C                     ADDED -32 APRIL 00 ARDEAN LEITH
C                     REWRITTEN JUNE  01 ARDEAN LEITH
C                     ALTERED  MAR    02 ARDEAN LEITH
d358 4
a361 4
             IF (IRTFLG .NE. 0) THEN
                WRITE(NOUT,90) IRECRAW,NVAL
90              FORMAT('*** ERROR READING RECORD: ',I6,'  NVAL: ',I6)
                CALL ERRT(101,'IO ERROR READING FILE',IDUM)
d364 1
d446 4
a449 4
             IF (IRTFLG .NE. 0) THEN
                WRITE(NOUT,90) IRECRAW,NVAL
90              FORMAT('*** ERROR READING RECORD: ',I6,'  NVAL: ',I6)
                CALL ERRT(101,'IO ERROR READING FILE',IDUM)
d546 4
a549 4
             IF (IRTFLG .NE. 0) THEN
                WRITE(NOUT,90) IRECRAW,NVAL
90              FORMAT('*** ERROR READING RECORD: ',I6,'  NVAL: ',I6)
                CALL ERRT(101,'IO ERROR READING FILE',IDUM)
d552 1
@


1.44
log
@*** empty log message ***
@
text
@d90 1
a90 1
           FLIP = .FALSE.
d92 1
a92 1
     &         (ISIGB .EQ. 2 .AND. .NOT. BIGENDARCH)) FLIP = .TRUE. 
d132 1
a132 1

d453 1
a453 1
          IF (IGOT .GE. IOFFSET) THEN
d464 5
a468 3
             IF (FOLD) THEN
               IF (I1VAL(1) .LT. 0) I1VAL(1) = 256 + I1VAL(1)
               IF (I1VAL(2) .LT. 0) I1VAL(2) = 256 + I1VAL(2)
a469 3

             ILOCSPI      = ILOCSPI + 1
             BUF(ILOCSPI) = I2VAL
@


1.43
log
@bug in 16 bit convertor
@
text
@d11 1
a11 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d31 1
a31 1
       COMMON /COMMUN/  FILOLD,FILNEW
d33 1
d38 1
d87 7
a93 1
           FOLD = .FALSE.
d97 1
a97 1
           IF (ANS .EQ. 'Y' .OR. ANS .EQ. 'y') FOLD = .TRUE.
d133 1
a133 1
          CALL RAW16TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,ISIGB,
d142 4
a145 4
C         MODE 33 fLIPS BYTES & WORDS
          IF (MODE .eq.  33) NFLIP = 2
C         MODE -33 fLIPS BYTES 
          IF (MODE .eq.  33) NFLIP = 2
a221 1

d401 1
a401 1
       SUBROUTINE RAW16TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,ISIGB,
d412 1
a412 1
       LOGICAL         FOLD
d414 3
a416 3
       INTEGER *4      I4VAL
       INTEGER *1      I1VAL(4)
       EQUIVALENCE     (I4VAL,I1VAL)
a417 2
       I4VAL     = 0

d419 1
a419 1
          CALL ERRT(101,'PGM ERROR, LENOPEN MUST BE EVEN!',NE)
d422 1
a422 1
          CALL ERRT(101,'PGM ERROR, OFFSET MUST BE EVEN!',NE)
a425 9
#if  defined (SP_NT) || defined (__osf__) || defined (SP_LINUX) 
C      MUST ADJUST BYTE ORDER IN I4VAL
       LOC1 = 1
       LOC2 = 2
#else
       LOC1 = 3
       LOC2 = 4
#endif

a431 1
       icount = 0
d456 3
a458 3
             IF (ISIGB .EQ. 1) THEN
                I1VAL(LOC1) = INBUFB(ILOCRAW)
                I1VAL(LOC2) = INBUFB(ILOCRAW+1)
d460 2
a461 2
                I1VAL(LOC2) = INBUFB(ILOCRAW)
                I1VAL(LOC1) = INBUFB(ILOCRAW+1)
d463 1
d465 2
a466 5
                IF (I4VAL .LE. 32767) THEN
                   I4VAL = I4VAL + 32768
                ELSE
                   I4VAL = I4VAL - 32768
                ENDIF
d468 1
d470 1
a470 2
             BUF(ILOCSPI) = I4VAL

@


1.42
log
@nloop,iloop_removed
@
text
@d359 2
a360 1
          IF (IGOT .GE. IOFFSET) THEN
a379 1
          IGOT = IGOT + 1
d421 9
d486 1
a487 1
          IGOT = IGOT + 2
d493 1
a493 1
         NVAL = MIN(NSAM,ILOCSPI)
@


1.41
log
@bugs fixed
@
text
@d41 1
a41 1
       CALL RDPRI1S(MODE,NLOOP,ILOOP,
d60 1
a60 1
        CALL RDPRI3S(NSAM,NROW,NSLICE,NLOOP,ILOOP,
d70 1
a70 1
       CALL RDPRI1S(IOFFSET,NLOOP,ILOOP,
d77 1
a77 1
           CALL RDPRI1S(ISIGB,NLOOP,ILOOP,
@


1.40
log
@*** empty log message ***
@
text
@d54 1
a54 1
       CALL FILERD(FILOLD,NLET,NULL,'EXISTING RAW',IRTFLG)
d109 7
a118 6
C         OPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. 
          LENOPEN = NSAM * (MODE / 8)
          CALL OPAUXFILE(.FALSE.,FILOLD,CHAR(0),LUNOLD,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

a124 6
C         OPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. 
          LENOPEN = NSAM * (MODE / 8)
          CALL OPAUXFILE(.FALSE.,FILOLD,CHAR(0),LUNOLD,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999

a130 5
C         OPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. 
          LENOPEN = NSAM * (MODE / 8)
          CALL OPAUXFILE(.FALSE.,FILOLD,CHAR(0),LUNOLD,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
          IF (IRTFLG .NE. 0) GOTO 9999
d144 2
a145 1
C         OPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. 
@


1.39
log
@added changes
@
text
@d7 1
a90 5
       ELSEIF (MODEA .EQ. 32 .OR. MODEA .EQ. 33) THEN
C          SET FLIP FOR MODE 32
           FLIP = .FALSE.
           IF (MODE.EQ. -32 .OR. MODEA .EQ. 33) FLIP = .TRUE.
           IF (MODEA .EQ. 33) MODE = 32
d133 1
a133 1
       ELSEIF (MODEA .EQ. 32 .AND. IOFFMOD4 .EQ. 0) THEN
d141 7
d149 2
a150 2
          CALL RAW32TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,MODE,
     &                    FLIP,LENOPEN,BUFRAW,IRTFLG)
@


1.38
log
@speeded up
@
text
@d34 2
a35 2
       CHARACTER        CDUM,ANS
       LOGICAL          FOLD
d37 1
a37 1
C      GET FILENAME FOR EXISTING RAW IMAGE FILE
d43 1
d45 1
a45 1
       IF (MODE .NE. 8 .AND. MODE .NE. 16 .AND. MODEA .NE. 32 .AND.
d47 1
a47 1
          CALL ERRT(100,'BITS / PIXEL MUST BE (8,16,32, OR -32)!',NE)
d51 3
a53 3
10     LENOPEN = -1
       CALL OPAUXFILE(.TRUE.,FILOLD,DATEXC,LUNOLD,LENOPEN,'O',
     &                 'EXISTING RAW',.TRUE.,IRTFLG)
a61 1
           CLOSE(LUNOLD)
d75 2
a76 3
           ISIGB   = 1

23         CALL RDPRI1S(ISIGB,NLOOP,ILOOP,
d90 5
d116 2
a117 5
C         CLOSE RAW FILE 
          CLOSE(LUNOLD)

C         REOPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. 
          LENOPEN = NSAM 
d126 1
a126 5
C         FOR 16 BIT RAW INTEGER INPUT WITH HEADER LENGTH DIVISABLE 
C         BY TWO

C         CLOSE RAW FILE 
          CLOSE(LUNOLD)
d128 2
a129 2
C         REOPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. 
          LENOPEN = NSAM * 2
d140 2
a141 5
C         CLOSE RAW FILE 
          CLOSE(LUNOLD)

C         REOPEN RAW FILE AS DIRECT ACCESS, UNFORMATTED REC. 
          LENOPEN = NSAM * 4
d147 1
a147 1
     &                    LENOPEN,BUFRAW,IRTFLG)
d149 7
a155 1
C         OTHER RAW IMAGE FORMATS OR CONVERSIONS
d157 2
a158 2
          CALL RAWTOSPI(LUNOLD,LUNNEW,NSAM,NPIX,
     &              MODE,FOLD,IOFFSET,ISIGB,IRTFLG)
d171 2
a173 3
       SUBROUTINE RAWTOSPI(LUNOLD,LUNNEW,NSAM,NPIX,
     &                     MODE,FOLD,IOFFSET,ISIGB,IRTFLG)

d179 6
a184 3
       CHARACTER *1    CINBUF
       INTEGER * 1     INBUF
       EQUIVALENCE     (CINBUF,INBUF)
d186 1
a186 1
       LOGICAL         FOLD
d192 1
d219 2
d223 1
d225 2
a226 2
             READ(LUNOLD,80,REC=ILOC,IOSTAT=IRTFLG) CINBUF
80           FORMAT(A)
d238 1
a238 1
          READ(LUNOLD,80,REC=ILOC,IOSTAT=IRTFLG) CINBUF
d251 1
a251 1
             IVAL    = INBUF
d260 1
a260 1
                I1VAL(LOC1) = INBUF
d262 1
a262 1
                I1VAL(LOC2) = INBUF
d264 1
a264 1
                I1VAL(LOC2) = INBUF
d266 1
a266 1
                 I1VAL(LOC1) = INBUF
d286 5
a290 1
             I1VAL(IBITE) = INBUF
a426 9
#if  defined (SP_NT) || defined (__osf__) || defined (SP_LINUX) 
C      MUST ADJUST BYTE ORDER IN I4VAL
       LOC1 = 1
       LOC2 = 2
#else
       LOC1 = 3
       LOC2 = 4
#endif

d496 3
a498 2
        
C ------------------------- RAW32TOSPI ----------------------------------
d500 2
a501 2
       SUBROUTINE RAW32TOSPI(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,IMODE,
     &                      LENOPEN,INBUFB,IRTFLG)
d510 1
d514 2
a517 1
       INTEGER *4      I4VAL
d519 1
d525 1
a525 1
          CALL ERRT(101,'PGM ERROR, LENOPEN MUST BE DIVISABLE BY 4!',NE)
a526 3
       ELSEIF (MOD(IOFFSET,4) .NE. 0) THEN
          CALL ERRT(101,'PGM ERROR, OFFSET MUST BE DIVISABLE BY 4!',NE)
          RETURN
d532 1
a532 1
       IRECSPI    = 0
d536 1
d542 1
a542 1
          ILOCRAW = ILOCRAW + 4
d557 2
a559 2
          IGOT = IGOT + 4

d562 1
d564 26
a589 10
             IF (IMODE .EQ. -32) THEN
                I1VAL(4) = INBUFB(ILOCRAW)
                I1VAL(3) = INBUFB(ILOCRAW+1)
                I1VAL(2) = INBUFB(ILOCRAW+2)
                I1VAL(1) = INBUFB(ILOCRAW+3)
             ELSEIF (IMODE .EQ. -33) THEN
                I1VAL(3) = INBUFB(ILOCRAW)
                I1VAL(4) = INBUFB(ILOCRAW+1)
                I1VAL(1) = INBUFB(ILOCRAW+2)
                I1VAL(2) = INBUFB(ILOCRAW+3)
d591 2
a592 4
                I1VAL(1) = INBUFB(ILOCRAW)
                I1VAL(2) = INBUFB(ILOCRAW+1)
                I1VAL(3) = INBUFB(ILOCRAW+2)
                I1VAL(4) = INBUFB(ILOCRAW+3)
d595 16
a610 2
             ILOCSPI      = ILOCSPI + 1
             BUF(ILOCSPI) = R4VAL
@


1.37
log
@added -32 endedness convertor
@
text
@d6 1
d10 1
a10 1
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
d19 1
a19 1
C  PURPOSE:  CONVERTS RAW INTEGER IMAGES TO SPIDER FORMAT
a20 1
C        0         2         3         4         5         6         7     
d27 1
d29 1
a29 1
       CHARACTER * 81   FILOLD,FILNEW
d32 2
d107 13
d121 8
a128 2
       IF (MODE .EQ. 16 .AND. IOFFMOD2 .EQ. 0) THEN
C         FOR 16 BIT INPUT WITH HEADER LENGTH DIVISABLE BY TWO
d131 1
a131 1
C         REOPEN FILE AS DIRECT ACCESS, UNFORMATTED REC. 
d137 5
a141 2
          CALL RAWTOSPIT(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,ISIGB,
     &                   FOLD,IRTFLG)
d143 1
a143 2
       ELSEIF (MODE .EQ. -32 .OR. MODE .EQ. -32) THEN
C         TO ALTER BYTE ORDER OF 32 BIT FLOATING POINT IMAGES
d146 1
a146 1
C         REOPEN FILE AS DIRECT ACCESS, UNFORMATTED REC. 
d151 3
a153 1
          CALL RAWTOSPII(LUNOLD,LUNNEW,NSAM,NPIX,MODE,IOFFSET,IRTFLG)
d155 1
d190 1
a190 1
C      CLEAN THE BUFFER, THIS ASSUMED THE INTENSITIES IN THE RAW IMAGE 
d196 1
a196 1
C      ILOCOUT IS POINTER TO CURRENT NUMBER OF IMAGE VALUES OUTPUT TO
d198 1
a198 1
       ILOCOUT = 0
d200 2
a201 2
C      IROW IS NUMBER OF CURRENT OUTPUT RECORD
       IROW   = 0
d244 1
a244 1
             ILOCOUT = ILOCOUT + 1
d247 1
a247 1
             FBUF(ILOCOUT) = IVAL
d271 2
a272 2
                ILOCOUT       = ILOCOUT + 1
                FBUF(ILOCOUT) = I4VAL
d284 2
a285 2
                ILOCOUT       = ILOCOUT + 1
                FBUF(ILOCOUT) = FVAL
d291 1
a291 1
         IF (ILOCOUT .EQ. NSAM) THEN
d293 3
a295 3
            IROW = IROW + 1
            CALL WRTLIN(LUNNEW,FBUF,NSAM,IROW)
            ILOCOUT = 0
d299 1
a299 1
      IF (ILOCOUT .GT. 0) THEN
d301 2
a302 2
         IROW = IROW + 1
         CALL WRTLIN(LUNNEW,FBUF,NSAM,IROW)
d311 2
a312 1
C ------------------------- RAWTOSPIT ----------------------------------
d314 2
d317 1
a317 2
       SUBROUTINE RAWTOSPIT(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,ISIGB,
     &                      FOLD,IRTFLG)
d322 1
a322 1
       COMMON /IOBUF/  BUF(NBUFSIZ)
d324 1
a324 2
       INTEGER *1      INBUFB(NBUFSIZ)
       COMMON          INBUF
d327 32
d360 27
a386 3
c       INTEGER *4      I4VAL
c       INTEGER *2      I2VAL(2)
c       EQUIVALENCE     (I4VAL,I2VAL)
d388 1
a388 1
c       INTEGER *2      I2VAL
d390 13
d409 8
d426 6
a431 8
       IRECIN    = 0
       IRECOUT   = 0
       ILOCOUT   = 0
       IROW      = 0
       IGOT      = 0
       IOFFSETD2 = IOFFSET / 2
       NSAMT2    = NSAM * 2
       ILOCIN    = NSAMT2 + 1
d434 2
a435 2
C      NEED IS NUMBER OF I*2 VALUES TO BE READ INCLUDING HEADER
       NEED     = NPIX + IOFFSET / 2
d438 2
a439 2
          ILOCIN = ILOCIN + 2
          IF (ILOCIN .GT. NSAMT2) THEN
d441 3
a443 3
             NVAL   = MIN(NSAM,NEED-IGOT)
             IRECIN = IRECIN + 1
             CALL REDLIN8(LUNOLD,INBUFB,NVAL*2,IRECIN,IRTFLG)
d446 1
a446 1
                WRITE(NOUT,90) IRECIN,NVAL
d451 1
a451 1
             ILOCIN = 1
d454 1
a454 1
          IF (IGOT .GE. IOFFSETD2) THEN
d458 2
a459 2
                I1VAL(LOC1) = INBUFB(ILOCIN)
                I1VAL(LOC2) = INBUFB(ILOCIN+1)
d461 2
a462 2
                I1VAL(LOC2) = INBUFB(ILOCIN)
                I1VAL(LOC1) = INBUFB(ILOCIN+1)
d471 2
a472 2
             ILOCOUT      = ILOCOUT + 1
             BUF(ILOCOUT) = I4VAL
a473 17
#ifdef NEVER
             if (icount .le. 1) THEN
               write(6,*) 'inbufb(',ILOCIN,'): ',inbufb(ILOCIN)
               it = ilocin + 1
               write(6,*) 'inbufb(',it,'): ',inbufb(it)
               write(6,*) 'i1val(1):  ', i1val(1),' i1val(2): ',i1val(2)
               write(6,*) 'i1val(3):  ', i1val(3),' i1val(4): ',i1val(4)
               write(6,*) 'i4val: ',i4val

c               write(6,*) '  buf(',ilocout,'): ',buf(ilocout)
c               write(6,*) 'i2val(1):  ', i2val(1),' i2val(2): ',i2val(2)
c               write(6,*) 'ilocin: ', ilocin,' ilocout: ',ilocout
c               write(6,*) 'recin:  ', irecin,' irow: ',irow
               write(6,*) ' -------------',icount
               icount = icount + 1
             endif
#endif
d475 1
a475 1
             IF (ILOCOUT .GE. NSAM) THEN
d477 3
a479 3
                IROW = IROW + 1
                CALL WRTLIN(LUNNEW,BUF,NSAM,IROW)
                ILOCOUT = 0
d482 2
a483 1
          IGOT = IGOT + 1
d486 1
a486 1
      IF (ILOCOUT .GT. 0) THEN
d488 3
a490 2
         IROW = IROW + 1
         CALL WRTLIN(LUNNEW,BUF,NSAM,IROW)
d496 1
a496 2
C dd if=avg000.dat of=tes032.dat count=16384 bs=1
C tail +1025c avg000.dat > tes032.dat
d498 2
a499 1
C ------------------------- RAWTOSPII ----------------------------------
d501 1
a501 2
       SUBROUTINE RAWTOSPII(LUNOLD,LUNNEW,NSAM,NPIX,
     &                      MODE,IOFFSET,IRTFLG)
d508 1
a508 2
       INTEGER *1      INBUFB(NBUFSIZ)
       COMMON          INBUFB
d513 2
d516 10
a525 8
       IRECIN    = 0
       IRECOUT   = 0
       ILOCOUT   = 0
       IROW      = 0
       IGOT      = 0
       NSAMT4    = NSAM * 4
       ILOCIN    = NSAMT4 + 1
       LOCB      = 0
d527 7
a533 1
       icount = 0
d536 1
a536 1
       NEED     = NPIX * 4 + IOFFSET
d539 2
a540 2
          ILOCIN = ILOCIN + 1
          IF (ILOCIN .GT. NSAMT4) THEN
d542 3
a544 3
             NVAL   = MIN(NSAMT4,NEED-IGOT)
             IRECIN = IRECIN + 1
             CALL REDLIN8(LUNOLD,INBUFB,NVAL,IRECIN,IRTFLG)
d547 1
a547 1
                WRITE(NOUT,90) IRECIN,NVAL
d552 1
a552 1
             ILOCIN = 1
d554 2
a555 1
          IGOT = IGOT + 1
a558 1
             LOCB        = LOCB + 1
d560 10
a569 2
             IF (MODE .EQ. -32) THEN
                I1VAL(5-LOCB) = INBUFB(ILOCIN)
d571 4
a574 1
                I1VAL(LOCB)   = INBUFB(ILOCIN)
d577 2
a578 5
             IF (LOCB .GE. 4) THEN
                ILOCOUT      = ILOCOUT + 1
                BUF(ILOCOUT) = R4VAL
                LOCB         = 0
             ENDIF
d580 1
a580 1
             IF (ILOCOUT .GE. NSAM) THEN
d582 3
a584 3
                IROW = IROW + 1
                CALL WRTLIN(LUNNEW,BUF,NSAM,IROW)
                ILOCOUT = 0
d589 4
a592 4
      IF (ILOCOUT .GT. 0) THEN
C        PUT OUT COMPLETED RECORD
         IROW = IROW + 1
         CALL WRTLIN(LUNNEW,BUF,NSAM,IROW)
d597 22
@


1.36
log
@defined ))
@
text
@d4 2
a5 1
C  RAWTOSPIDER.FOR -- CREATED JUL 95 al
d40 4
a43 2
       IF (MODE .NE. 8 .AND. MODE .NE. 16 .AND. MODE .NE. 32) THEN
          CALL ERRT(100,'BITS / PIXEL MUST BE (8,16,OR 32)!',NE)
a101 3
       INMODE = 1
       IF (MODE .EQ. 16) INMODE = 2
       IF (MODE .EQ. 32) INMODE = 4
d105 2
a106 2
       IF (INMODE .EQ. 2 .AND. IOFFMOD2 .EQ. 0) THEN
C         FOR 16 BIT INPUT WITH HEADER LENGTH DIVIABLE BY TWO
d117 11
d131 1
a131 1
     &              INMODE,FOLD,IOFFSET,ISIGB,IRTFLG)
d146 1
a146 1
     &                     INMODE,FOLD,IOFFSET,ISIGB,IRTFLG)
d179 1
a179 1
       NBYTES = NPIX * INMODE
d214 1
a214 1
          IF (INMODE .EQ. 1) THEN
d222 1
a222 1
          ELSE IF (INMODE .EQ. 2) THEN
d249 1
a249 1
          ELSE IF (INMODE .EQ. 4) THEN
d411 82
@


1.35
log
@SP_LINUX
@
text
@d170 1
a170 1
#if  defined (SP_NT) || defined (__osf__)) || defined (SP_LINUX) 
@


1.34
log
@osf bug fiexed & speedup on 16 bit input for others
@
text
@d170 1
a170 1
#if  defined (SP_NT) || defined (__osf__) 
d301 1
a301 1
#if  defined (SP_NT) || defined (__osf__) 
@


1.33
log
@bug in igot < need
@
text
@a102 5
#if  defined (SP_NT) || defined (__osf__) || defined (SP_SUN4)
       CALL RAWTOSPI(LUNOLD,LUNNEW,NSAM,NPIX,
     &              INMODE,FOLD,IOFFSET,ISIGB,IRTFLG)
       
#else
d105 2
a106 2
       IF (ISIGB .EQ. 1 .AND. INMODE .EQ. 2 .AND. .NOT. FOLD .AND.
     &     IOFFMOD2 .EQ. 0) THEN
d115 2
a116 1
          CALL RAWTOSPIT(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,IRTFLG)
d118 1
a121 1
#endif
d170 1
a170 1
#ifdef SP_NT
d276 2
a277 1
       SUBROUTINE RAWTOSPIT(LUNOLD,LUNNEW,NSAM,NPIX,IOFFSET,IRTFLG)
d286 1
d288 1
d301 9
d342 15
a356 2
             I1VAL(3)     = INBUFB(ILOCIN)
             I1VAL(4)     = INBUFB(ILOCIN+1)
d366 4
d371 2
a372 5
               write(6,*) '  buf(',ilocout,'): ',buf(ilocout)
               write(6,*) ' i4val: ',i4val
 
               write(6,*) 'ilocin: ', ilocin,' ilocout: ',ilocout
               write(6,*) 'recin:  ', irecin,' irow: ',irow
@


1.32
log
@fast code for scanner activated
@
text
@d315 1
a315 1
       DO WHILE (IGOT .LE. NEED)
d339 1
d354 1
@


1.31
log
@*** empty log message ***
@
text
@d44 2
a45 2
C      OPEN FILE AS DIRECT ACCESS, FORMATTED, REC. LENGTH = 1
10     CALL OPAUXFILE(.TRUE.,FILOLD,DATEXC,LUNOLD,-1,'O',
d102 2
d106 21
d273 96
@


1.30
log
@rdpr1s
@
text
@d119 1
a120 1
       PARAMETER       (NBUFSIZ = 17008)
@


1.29
log
@for dec f90
@
text
@d36 1
a36 1
       CALL RDPRIS(MODE,NDUM,NLOOP,ILOOP,
d40 1
a40 1
          CALL ERRT(100,' BITS / PIXEL MUST BE (8,16,OR 32)!',NE)
d71 1
a71 1
23         CALL RDPRIS(ISIGB,NDUM,NLOOP,ILOOP,
@


1.28
log
@removed irecint
@
text
@a31 1
       INTEGER          IARRAY(3)
d35 2
a36 2
8      INMODE = 8
       CALL RDPRIS(INMODE,NDUM,NLOOP,ILOOP,
d39 2
a40 2
       IF (INMODE .NE. 8 .AND. INMODE .NE. 16 .AND.INMODE .NE. 32)THEN
          CALL ERRT(100,' INMODE MUST BE (8,16,OR 32)!',NE)
d44 2
a45 3
C      OPEN FILE AS DIRECT ACCESS, UNFORMATTED, REC. LENGTH = 64 BYTES
10     LENREC = 64
       CALL OPAUXFILE(.TRUE.,FILOLD,DATEXC,LUNOLD,LENREC,'O',
d50 10
a59 21
20      INUM = 3
        CALL RDPRAI(IARRAY,3,INUM,1,32000,
     &     'ENTER COLUMNS, ROWS & SLICES',CDUM,IRTFLG)
        IF (IRTFLG .EQ. -1) GOTO 10
         
        IF (INUM .LT. 1) THEN
           CALL ERRT(31,'RAWTOSPIDER',NE)
           GOTO 20
        ELSE
           NSAM = IARRAY(1)
           IF (INUM .LT. 2) THEN
              NROW = NSAM
              NSLICE = 1
           ELSE
              NROW = IARRAY(2)
              IF (INUM .LT. 3) THEN
                 NSLICE = 1
              ELSE
                 NSLICE = IARRAY(3)
              ENDIF
           ENDIF
d63 4
a66 6
       CALL RDPRIS(IOFFSET,NDUM,NLOOP,ILOOP,
     &    'ENTER HEADER BYTES TO BE SKIPPED',IRTFLG)
       IF (IRTFLG .EQ. -1) THEN
           CLOSE(LUNOLD)
           GOTO 20
       ENDIF
d68 1
a68 5
       IF (INMODE .EQ. 8) THEN
           IDIV = 1

       ELSE IF (INMODE .EQ. 16) THEN
           IDIV    = 2
a84 2
       ELSEIF (INMODE .EQ. 32) THEN
           IDIV    = 4
d98 5
a102 2
       NBYTES = NSAM * NROW * NSLICE * IDIV + IOFFSET
       CALL RAWTOSPI(LUNOLD,LENREC,LUNNEW,NSAM,NBYTES,
d115 1
a115 1
       SUBROUTINE RAWTOSPI(LUNOLD,LENREC,LUNNEW,NSAM,NBYTES,
a118 1
CNO_SAVE
d123 3
a125 2
       INTEGER * 1     INBUF(1)
       COMMON          INBUF
a127 1

a132 3
C      CURRENT INPUT RECORD 
       IRECIN = 1

d139 2
a140 5
C      IBITENOW IS POINTER TO CURRENT NUMBER OF IMAGE BYTES OUTPUT
       IBITENOW = 0

C      ILOCIN IS POINTER TO CURRENT INPUT BUFFER POSITION
       ILOCIN  = LENREC
d143 1
a143 1
C      IROW IS NUMBER OF OUTPUT RECORD
d149 1
d159 5
a163 10
       DO WHILE (IBITENOW .LT. NBYTES)

C        POINT TO CURRENT INPUT BUFFER VALUE
         ILOCIN = ILOCIN + 1

         IF (ILOCIN .GT. LENREC) THEN
C            READ NEXT RECORD FROM INPUT FILE (AS BYTES)
             NVALS = MIN(LENREC,(NBYTES-IBITENOW))

             CALL REDREC8(LUNOLD,INBUF,NVALS,IRECIN,IRTFLG)
d165 4
a168 2
                WRITE(NOUT,*) '*** ERROR READING RECORD:',IRECIN
                CALL ERRT(100,'RAWTOSPIDER',NE)
d171 2
a172 3
             IRECIN = IRECIN + 1
             ILOCIN   = 1
         ENDIF
d174 2
a175 2
C        POINT TO CURRENT CUMULATIVE PIXEL
         IBITENOW = IBITENOW + 1
d177 35
a211 31
         IF (IBITENOW .GT. IOFFSET) THEN
C           AFTER HEADER
            IF (INMODE .EQ. 8) THEN
C               INPUT IS 8 BIT ------------------------------- 8 BIT IN
C               CONVERT TO 32 BIT FLOATING POINT 
                ILOCOUT = ILOCOUT + 1
                IVAL = INBUF(ILOCIN)
                IF (IVAL .LT. 0) IVAL = 256 + IVAL
                FBUF(ILOCOUT) = IVAL

            ELSE IF (INMODE .EQ. 16) THEN
C               INPUT IS 16 BIT ----------------------------- 16 BIT IN
C               CONVERT TO 32 BIT FLOATING POINT 
                IBITE = IBITE + 1
                IF (ISIGB .EQ. 1 .AND. IBITE .EQ. 1) THEN
                   I1VAL(LOC1) = INBUF(ILOCIN)
                ELSE IF (ISIGB .EQ. 1 .AND. IBITE .EQ. 2) THEN
                   I1VAL(LOC2) = INBUF(ILOCIN)
                ELSE IF (IBITE .EQ. 1) THEN
                   I1VAL(LOC2) = INBUF(ILOCIN)
                ELSE IF (IBITE .EQ. 2) THEN
                    I1VAL(LOC1) = INBUF(ILOCIN)
                ENDIF                 
                IF (IBITE .EQ. 2) THEN
C                  PUT OUT COMPLETED VALUE
                   IF (FOLD) THEN
                      IF (I4VAL .LE. 32767) THEN
                         I4VAL = I4VAL + 32768
                      ELSE
                         I4VAL = I4VAL - 32768
                      ENDIF
a212 3
                   ILOCOUT       = ILOCOUT + 1
                   FBUF(ILOCOUT) = I4VAL
                   IBITE         = 0
d214 4
d219 12
a230 10
            ELSE IF (INMODE .EQ. 32) THEN
C               INPUT IS 32 BIT ---------------------------- 32 BIT IN
C               CONVERT TO 32 BIT FLOATING POINT 
                IBITE        = IBITE + 1
                I1VAL(IBITE) = INBUF(ILOCIN)
                IF (IBITE .GE. 4) THEN
                   ILOCOUT       = ILOCOUT + 1
                   FBUF(ILOCOUT) = FVAL
                   IBITE      = 0
                ENDIF
d232 1
a232 1
            ENDIF
d234 5
a238 6
            IF (ILOCOUT .EQ. NSAM) THEN
C               PUT OUT COMPLETED RECORD
                IROW = IROW + 1
                CALL WRTLIN(LUNNEW,FBUF,NSAM,IROW)
                ILOCOUT = 0
             ENDIF
@


1.27
log
@recin needed
@
text
@d121 1
a121 1
     &                 INMODE,FOLD,IOFFSET,ISIGB,IRTFLG)
d134 1
a134 1
     &                     IRECINT,INMODE,FOLD,IOFFSET,ISIGB,IRTFLG)
d152 2
a153 2
C      CURRENT INPUT RECORD (IRECIN) MAY BE CONSTANT
       IRECIN = IRECINT
@


1.26
log
@cosmetic
@
text
@d134 1
a134 1
     &                     INMODE,FOLD,IOFFSET,ISIGB,IRTFLG)
d152 2
a173 2
C      CURRENT INPUT RECORD
       IRECIN = 1
@


1.25
log
@bad
@
text
@d6 8
a13 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1995, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
@


1.24
log
@*** empty log message ***
@
text
@d32 1
a32 1
       LOGICAL          EX,FOLD
d46 3
a48 1
10     CALL OPAUXFILE(.TRUE.,FILOLD,DATEXC,LUNOLD,64,'O',
a111 1
C      32 BIT REAL SPIDER IMAGE OUTPUT
d140 5
a144 3
       COMMON           INBUF,FBUF
       INTEGER * 1      INBUF(64)
       DIMENSION        FBUF(16000)
d146 1
a146 1
       LOGICAL          FOLD
d148 4
a151 4
       INTEGER * 1      I1VAL(4)
       INTEGER * 4      I4VAL
       EQUIVALENCE      (I4VAL,I1VAL(1))
       EQUIVALENCE      (FVAL,I1VAL(1))
d160 7
a166 5
C      NGOT IS POINTER TO CURRENT NUMBER OF IMAGE BYTES OUTPUT
       NGOT   = 0
C      NLOC IS POINTER TO CURRENT INPUT BUFFER POSITION
       NLOC   = LENREC
       NPUT   = 0
d169 1
d172 1
d184 1
a184 1
       DO WHILE (NGOT .LT. NBYTES)
d187 1
a187 1
         NLOC = NLOC + 1
d189 1
a189 1
         IF (NLOC .GT. LENREC) THEN
d191 1
a191 1
             LENREC = MIN(LENREC,(NBYTES-NGOT))
d193 1
a193 1
             CALL REDREC8(LUNOLD,INBUF,LENREC,IRECIN,IRTFLG)
d200 1
a200 1
             NLOC   = 1
d204 1
a204 1
         NGOT = NGOT + 1
d206 1
a206 1
         IF (NGOT .GT. IOFFSET) THEN
d211 2
a212 2
                NPUT = NPUT + 1
                IVAL = INBUF(NLOC)
d214 1
a214 1
                FBUF(NPUT) = IVAL
d221 1
a221 1
                   I1VAL(LOC1) = INBUF(NLOC)
d223 1
a223 1
                   I1VAL(LOC2) = INBUF(NLOC)
d225 1
a225 1
                   I1VAL(LOC2) = INBUF(NLOC)
d227 1
a227 1
                    I1VAL(LOC1) = INBUF(NLOC)
d238 3
a240 3
                   NPUT       = NPUT + 1
                   FBUF(NPUT) = I4VAL
                   IBITE      = 0
d246 2
a247 2
                IBITE = IBITE + 1
                I1VAL(IBITE) = INBUF(NLOC)
d249 3
a251 3
                   NPUT = NPUT + 1
                   FBUF(NPUT) = FVAL
                   IBITE = 0
d256 1
a256 1
            IF (NPUT .EQ. NSAM) THEN
d260 1
a260 1
                NPUT = 0
d265 1
a265 1
      IF (NPUT .GT. 0) THEN
@


1.23
log
@changed lenopenfile parameter to bytes
@
text
@a25 2
CNO_SAVE

d28 2
a29 2
       CHARACTER * 81   FILOLD,FILNEW,EXTEN
       COMMON /COMMUN/  FILOLD,FILNEW,EXTEN
d31 1
a31 1
       CHARACTER        NULL,CDUM,ANS
a34 1
       NULL = CHAR(0)
d41 2
a42 17

C      ACCEPT EXTENSION FROM INPUT 
10     IRTFLG = 9
       EXTEN  = NULL

       IF (INMODE .EQ. 8) THEN
          CALL FILERD(FILOLD,NLETU,EXTEN,'EXISTING 8-BIT RAW',IRTFLG)

       ELSE IF (INMODE .EQ. 16) THEN
          CALL FILERD(FILOLD,NLETU,EXTEN,'EXISTING 16-BIT RAW',IRTFLG)

       ELSE IF (INMODE .EQ. 32) THEN
          CALL FILERD(FILOLD,NLETU,EXTEN,'EXISTING 32-BIT RAW',IRTFLG)

       ELSE
          WRITE(NOUT,*) '*** PGM ERROR, INMODE MUST BE (8,16,OR 32)!'
          CALL ERRT(100,'RAWTOSPIDER',NE)
a44 15
       IF (IRTFLG .NE. 0) GOTO 8

C      SEE IF RAW DATA FILE EXISTS
       IF (EXTEN(1:1) .EQ. NULL) THEN
           CALL FILCAN(FILOLD,NLETO,NULL,NULL,FILOLD,DATEXC,IRTFLG)
       ENDIF
       INQUIRE(FILE=FILOLD,IOSTAT=IOERR,EXIST=EX)
       IRTFLG = 1

       IF (.NOT. EX) THEN
C         ERROR -- FILE DOES NOT EXIST
          WRITE(NOUT,90) FILOLD
90        FORMAT(' *** NOT FOUND: ',A)
          CALL ERRT(100,'RAWTOSPIDER',NE)
          RETURN
d46 4
a49 7
       ELSEIF (IOERR .NE. 0) THEN
C         ERROR FINDING FILE
          WRITE(NOUT,91) FILOLD
91        FORMAT(' *** INQUIRY ERROR FOR: ',A)
          CALL ERRT(100,'RAWTOSPIDER',NE)
          RETURN
       ENDIF
a108 16
C      OPEN THE EXISTING RAW FILE, WITH 64 BYTE RECORD LENGTH
C      USE FUNCTION TO COMPUTE RECORD LENGTH
       LENOPN = LENOPENFILE(64)
       LENREC = 64

       OPEN(LUNOLD,FILE=FILOLD,STATUS='OLD',IOSTAT=IOERR,
     &      FORM='UNFORMATTED',ACCESS='DIRECT',RECL=LENOPN)

       IF (IOERR .NE. 0) THEN
C         ERROR FINDING/OPENING FILE
          WRITE(NOUT,92) FILOLD
92        FORMAT(' *** ERROR OPENING: ',A)
          CALL ERRT(100,'RAWTOSPIDER',NE)
          RETURN
       ENDIF

d112 2
a113 1
       IF (NSLICE .GT. 1) IFORM = 3 
d115 1
a115 1
     &            IDUM,'NEW SPIDER IMAGE',.FALSE.,IRTFLG)
a142 1
       CHARACTER        NULL
d150 1
a150 1
       NULL = CHAR(0)
@


1.22
log
@used lenopenfile
@
text
@d147 1
a147 1
       LENOPN = LENOPENFILE(16)
@


1.21
log
@fixed for NT
@
text
@d145 3
a147 1
C      OPEN THE EXISTING RAW FILE
d149 1
a149 5
       LENOPN = 64
#ifdef __osf__
C      RECORD LENGTH IS IN 4-BYTE WORDS
       LENOPN = LENOPN / 4 
#endif 
@


1.20
log
@removed redrec8.f
@
text
@d221 1
a221 1
       IRECIN         = 1
d223 8
d268 1
a268 1
                   I1VAL(3) = INBUF(NLOC)
d270 1
a270 1
                   I1VAL(4) = INBUF(NLOC)
d272 1
a272 1
                   I1VAL(4) = INBUF(NLOC)
d274 1
a274 1
                    I1VAL(3) = INBUF(NLOC)
@


1.19
log
@used redrec
@
text
@a318 17
      SUBROUTINE REDREC8(LUN,LBUF,NB,NREC,IRTFLG)

      LOGICAL * 1   LBUF(NB)

      READ(LUN,REC=NREC,IOSTAT=IERR) LBUF

      IF (IERR .NE. 0) THEN
         WRITE(NOUT,*) '*** ERROR:',IERR, ' READING INPUT RECORD:',I
         CALL ERRT(100,'REDREC8',NE)
         IRTFLG = 1
         RETURN
      ENDIF

      IRTFLG = 0
      RETURN
      END

@


1.18
log
@bug on definitions
@
text
@a27 28
#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------

C       USE INLINE BUFFER COMMON AREA
        USE INLN_INFO

C     ----------- F90 SPECIFIC CODE ENDS ------------------

#else
 
C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------

#ifdef SP_ALLOC
C      RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
#if defined(SP_SUN4) || defined(SP_NT)
        INTEGER * 4     LOCLUN
#else
        INTEGER * 8     LOCLUN
#endif
#else
C      NON-RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
       INTEGER * 4     LOCLUN
#endif
       LOGICAL USEINLN
       COMMON /LUNARB/  LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
C     ----------- F77 SPECIFIC CODE ENDS ------------------
#endif

a29 3
       COMMON /LUNARA/  LUNARA(100),LUNSTK(100)

 
d149 1
a161 2
       LUNARA(LUNOLD) = 0
       LUNSTK(LUNOLD) = 0
a162 10
#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------
       NULLIFY(LOCLUN(LUNOLD)%IPT)
C     ----------- F90 SPECIFIC CODE ENDS ---------------------
#else
C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------
       LOCLUN(LUNOLD) = 0
C     ----------- F77 SPECIFIC CODE ENDS ---------------------
#endif

d193 1
a193 1
       INTEGER * 1      INBUF(64000)
d231 2
a232 1
             CALL REDLIN8(LUNOLD,INBUF,LENREC,IRECIN,IRTFLG)
d234 1
a234 1
                WRITE(NOUT,*) '*** ERROR READING INPUT AT NGOT:',NGOT
d318 17
@


1.17
log
@f90 changes
@
text
@a50 1

@


1.16
log
@used INteger instead of integer *8 for pointers in nt
@
text
@a25 1
       INCLUDE 'CMBLOCK.INC'
d28 12
d42 2
a43 2
#ifdef SP_NT
       INTEGER LOCLUN
d45 1
a45 1
       INTEGER * 8     LOCLUN
d54 5
d195 7
d203 2
@


1.15
log
@moved IFORM from OPFIL call
@
text
@d31 3
d35 1
d40 1
@


1.14
log
@modifications for f90 compatiblity
@
text
@d181 1
a181 1
     &            IFORM,'NEW SPIDER IMAGE',.FALSE.,IRTFLG)
@


1.13
log
@dummy for f90
@
text
@a22 1
#ifdef SP_F90
a23 18
       SUBROUTINE RAWTOSPIDER

       COMMON /UNITS/LUNC,NIN,NOUT

       WRITE(NOUT,*) 'DUMMY CALL: rawtospider'
       RETURN
       END

       SUBROUTINE RAWTOSPI

       COMMON /UNITS/LUNC,NIN,NOUT

       WRITE(NOUT,*) 'DUMMY CALL: rawtospi'
       RETURN
       END

#else

d48 1
a48 2
       DATA NULL/0/

d90 1
a90 1
       ELSEIF (IOERR) THEN
d165 1
a165 1
       IF (IOERR) THEN
d206 1
a206 1
       LOGICAL   * 1    INBUF(64000)
d217 1
a217 2
       DATA NULL/0/

a329 2

#endif
@


1.12
log
@needed loclun set for raw open file
@
text
@d23 1
d25 18
d351 3
@


1.11
log
@changed to work on osf
@
text
@d29 10
a38 3
       COMMON           INBUF,OUTBUF,FBUF
       LOGICAL   * 1    INBUF(64000),OUTBUF(64000)
       DIMENSION        FBUF(16000)
d40 1
d42 1
a42 4
       COMMON /COMMUN/  FILOLD,FILNEW

       COMMON /IOERR/   IERR
       COMMON /LUNARA/  LUNARA(100)
a45 1

a46 5
       INTEGER          INMODE
       INTEGER * 1      I1VAL(4)
       INTEGER * 4      I4VAL
       EQUIVALENCE      (I4VAL,I1VAL(1))
       EQUIVALENCE      (FVAL,I1VAL(1))
d48 1
a48 1
       DATA NULL/0/,MININT/-9999999/,MAXINT/9999999/
a49 6
C	CLEAN THE BUFFER, THIS ASSUMED THE INTENSITIES IN THE RAW IMAGE 
C	ARE ALL POSITIVE NUMBERS				---- liy
	DO I = 1, 4
	    I1VAL(I) = 0
	ENDDO

a121 5

C      32 BIT REAL SPIDER IMAGE OUTPUT
       IFORM  = 1
       IF (NSLICE .GT. 1) IFORM = 3 

a129 1
       IRECLEN = 64
d161 1
a161 1
       LENOPN = LENOPN / 64 
d173 3
d178 4
a181 1
 30    CALL OPFIL(.TRUE.,FILNEW,LUNNEW,'U',NSAM,NROW,NSLICE,
d184 28
a211 1
       IF (IRTFLG .NE. 0) GOTO 999
d213 6
a218 2
C      SET REDLIN ERROR TO NONE
       IERR = 0
d220 6
a225 1
       NBYTES = NSAM * NROW * NSLICE * IDIV + IOFFSET
d229 1
a229 1
       NLOC   = IRECLEN
d236 1
a236 2
       IRECIN       = 1
       LUNARA(LUNOLD) = 0
d243 1
a243 1
         IF (NLOC .GT. IRECLEN) THEN
d245 2
a246 2
             IRECLEN = MIN(IRECLEN,(NBYTES-NGOT))
             CALL REDLIN8(LUNOLD,INBUF,IRECLEN,IRECIN)
d250 1
a250 1
                GOTO 999
a325 3

999   CLOSE(LUNOLD)
      CLOSE(LUNNEW)
@


1.10
log
@changed buffer lengths
@
text
@d16 1
a16 1
C  RAWTOSPIDER(LUNOLD,LUNNEW,OUTMODE,LDUMMY,IRTFLG)
d18 1
a18 1
C  PURPOSE:  CONVERTS VARIOUS RAW IMAGES TO SPIDER IMAGE
d24 1
a24 1
       SUBROUTINE RAWTOSPIDER(LUNOLD,LUNNEW,OUTMODE,LDUMMY,IRTFLG)
d43 1
a43 1
       INTEGER          INMODE,OUTMODE
d66 1
a66 1
       EXTEN = NULL
a71 5
          IF (OUTMODE .EQ. 8) THEN
             WRITE(NOUT,*) '*** CAN NOT CONVERT 16 BIT TO 8 BIT!'
             CALL ERRT(100,'RAWTOSPIDER',NE)
             RETURN
          ENDIF
a74 5
          IF (OUTMODE .EQ. 8) THEN
             WRITE(NOUT,*) '*** CAN NOT CONVERT 32 BIT TO 8 BIT!'
             CALL ERRT(100,'RAWTOSPIDER',NE)
             RETURN
          ENDIF          
d78 1
a78 1
          WRITE(NOUT,*) '*** MUST BE (8,16,OR 32)!'
d130 3
a132 8
       IF (OUTMODE .EQ. 8) THEN
C          8 BIT INTEGER SPIDER IMAGE OUTPUT
           IFORM  = 8

       ELSEIF (OUTMODE .EQ. 32) THEN
C          32 BIT REAL SPIDER IMAGE OUTPUT
           IFORM  = 1
           IF (NSLICE .GT. 1) IFORM = 3 
a133 6
       ELSE
           WRITE(NOUT,*) '*** UNIMPLEMENTED OUTPUT MODE!'
           CALL ERRT(100,'RAWTOSPIDER',NE)
           RETURN
       ENDIF

d142 1
a143 1
           IRECLEN = NSAM
d147 3
a149 3
           IRECLEN = 2 * NSAM
           IDIV  = 2
           ISIGB = 1
d165 1
a165 2
          IRECLEN = 4 * NSAM
          IDIV    = 4
d170 8
a177 4
C      OPEN THE EXISTING RAW FILE (USE NSAM FOR RECORD LENGTH AS
C      THE LENGTH IS KNOWN TO BE AT LEAST NSAM)
       OPEN(LUNOLD,FILE=FILOLD,ACCESS='DIRECT',IOSTAT=IOERR,
     &       STATUS='OLD',RECL=IRECLEN)
a186 3
C      DO NOT OFFSET INPUT IMAGE READING
       LUNARA(LUNOLD) = 0
       
d204 1
a204 3
C      IROWIN IS NUMBER OF INPUT RECORD
       IROWIN = 0
C      BYTE POINTER FOR 16 BIT INPUT
d206 3
a216 1
             IROWIN = IROWIN + 1
d218 2
a219 2
             CALL REDLIN8(LUNOLD,INBUF,IRECLEN,IROWIN)
             IF (IERR .EQ. 1) THEN
a222 4
             ELSEIF (IERR .EQ. 2) THEN
                WRITE(NOUT,*) '*** INPUT FILE ENDS ON VOXEL:',NGOT
                CALL ERRT(100,'RAWTOSPIDER',NE)
                GOTO 999
d224 2
a225 1
             NLOC = 1
d235 5
a239 11
                IF (OUTMODE .EQ. 8) THEN
C                  WANT 8 BIT INTEGER SPIDER IMAGE ---------- 8 BIT OUT
                   NPUT = NPUT + 1
                   OUTBUF(NPUT) = INBUF(NLOC)
                ELSE
C                  CONVERT TO 32 BIT FLOATING POINT ------- 32 BIT OUT
                   NPUT = NPUT + 1
                   IVAL = INBUF(NLOC)
                   IF (IVAL .LT. 0) IVAL = 256 + IVAL
                   FBUF(NPUT) = IVAL
                ENDIF
d243 1
a243 1
C               CONVERT TO 32 BIT FLOATING POINT ----------- 32 BIT OUT
d270 1
a270 1
C               CONVERT TO 32 BIT FLOATING POINT ----------- 32 BIT OUT
d284 1
a284 5
                IF (OUTMODE .EQ. 8) THEN
                   CALL WRTLIN8(LUNNEW,OUTBUF,NSAM,IROW)
                ELSE
                   CALL WRTLIN(LUNNEW,FBUF,NSAM,IROW)
                ENDIF
d291 3
a293 7
C         PUT OUT COMPLETED RECORD
          IROW = IROW + 1
          IF (OUTMODE .EQ. 8) THEN
             CALL WRTLIN8(LUNNEW,OUTBUF,NSAM,IROW)
          ELSE
             CALL WRTLIN(LUNNEW,FBUF,NSAM,IROW)
          ENDIF
@


1.9
log
@fixed SPIDER file doesnot have correct fmin-fmax values
@
text
@d30 2
a31 2
       LOGICAL   * 1    INBUF(40000),OUTBUF(40000)
       DIMENSION        FBUF(40000)
@


1.8
log
@would not accept SPIDER extensions adding
@
text
@d44 1
a44 1
       LOGICAL * 1      I1VAL(4)
d50 6
@


1.7
log
@can use non-spider extension
@
text
@d60 2
@


1.6
log
@added fold negatives question
@
text
@d27 1
d33 1
a33 1
       CHARACTER * 81   FILOLD,FILNEW
d57 5
a61 3
 
10     IF (INMODE .EQ. 8) THEN
          CALL FILERD(FILOLD,NLETU,NULL,'EXISTING 8-BIT RAW',IRTFLG)
d69 1
a69 1
          CALL FILERD(FILOLD,NLETU,NULL,'EXISTING 16-BIT RAW',IRTFLG)
d77 1
a77 1
          CALL FILERD(FILOLD,NLETU,NULL,'EXISTING 32-BIT RAW',IRTFLG)
d87 3
a89 1
       CALL FILCAN(FILOLD,NLETO,NULL,NULL,FILOLD,DATEXC,IRTFLG)
@


1.5
log
@fval undefined
@
text
@a25 1
#ifdef SP_UNIX
a26 3
#else
       INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
d38 2
a39 2
       CHARACTER        NULL
       LOGICAL          EX
d153 1
d165 7
d273 7
@


1.4
log
@fixed 16 bit - number converter bug
@
text
@d50 1
@


1.3
log
@added new capabilities
@
text
@d48 3
a50 4
       INTEGER * 2      I2VAL
       EQUIVALENCE      (I2VAL,I1VAL(1))
       EQUIVALENCE      (FVAL,I1VAL(1))
  
d258 1
a258 1
                   I1VAL(1) = INBUF(NLOC)
d260 1
a260 3
                   I1VAL(2) = INBUF(NLOC)
                ELSE IF (IBITE .EQ. 1) THEN
                   I1VAL(2) = INBUF(NLOC)
d262 3
a264 1
                    I1VAL(2) = INBUF(NLOC)
d269 1
a269 1
                   FBUF(NPUT) = I2VAL
@


1.2
log
@cpp_lines_added
@
text
@d4 1
a4 1
C  RAWTOSPIDER.FOR -- CREATED DEC 93 al
d8 1
a8 1
C *  COPYRIGHT (C)1981,1993, WADSWORTH CENTER FOR LABORATORIES AND         *
d16 1
a16 1
C  RAWTOSPIDER(LUNO,LUNN,MODE,NORMIT,IRTFLG)
d18 1
a18 1
C  PURPOSE:  CONVERTS 8 BIT RAW IMAGE TO SPIDER IMAGE
d24 1
a24 1
       SUBROUTINE RAWTOSPIDER(LUNO,LUNN,MODE,NORMIT,IRTFLG)
d32 3
a34 1
       COMMON           FBUFN,I1BUF
d40 1
a40 1
       COMMON /LUNARA/ LUNARA(100),LASLAB
a44 3
       REAL             FBUFN(8000)
       LOGICAL   * 1    I1BUF(32000)
       DOUBLE PRECISION DAV,DAV2,DTOP,FNALL,DTEMP
d46 7
d54 1
d56 23
a78 1
       DATA NULL/0/,MININT/-9999999/,MAXINT/9999999/
d80 6
a85 3
C      GET FILENAME FOR EXISTING 8 BIT RAW IMAGE FILE
10     CALL FILERD(FILOLD,NLETU,NULL,'EXISTING 8-BIT RAW',IRTFLG)
       IF (IRTFLG .NE. 0) RETURN
d113 1
a113 1
           CALL ERRT(31,'COPYRAW',NE)
d131 1
a131 1
       IF (MODE .EQ. 8) THEN
d135 1
a135 1
       ELSEIF (MODE .EQ. 32) THEN
d141 1
a141 1
           WRITE(NOUT,*) '*** UNIMPLEMENTED MODE!'
d146 28
a173 3
C      OPEN THE EXISTING RAW FILE
       OPEN(LUNO,FILE=FILOLD,ACCESS='DIRECT',IOSTAT=IOERR,
     &       STATUS='OLD',RECL=NSAM)
d175 5
d181 1
a181 1
C         ERROR FINDING FILE
d188 5
a192 5
C      DO NOT OFFSET IMAGE READ/WRITE
       LUNARA(LUNO) = 0

C      OPEN NEW SPIDER IMAGE FILE WITH SPECIFIED SIZE
 30    CALL OPFIL(.TRUE.,FILNEW,LUNN,'U',NSAM,NROW,NSLICE,
d194 2
a195 7
       IF (IRTFLG .EQ. -1) GOTO 20
       IF (IRTFLG .NE. 0) RETURN
        
       IMIN  = MAXINT
       IMAX  = MININT
       DAV   = 0.0
       DAV2  = 0.0
d200 23
a222 5
       DO IROW = 1,NROW*NSLICE     

C            READ RECORD FROM 8 BIT INPUT FILE
             CALL REDLIN8(LUNO,I1BUF,NSAM,IROW)

d224 1
a224 1
                WRITE(NOUT,*) '*** ERROR READING RAW FILE'
d226 1
a226 1
                RETURN
d228 1
a228 1
                WRITE(NOUT,*) '*** INPUT FILE ENDS ON RECORD:',IROW
d230 1
a230 1
                RETURN
d232 2
d235 2
a236 2
             IF (MODE .EQ. 8) THEN
C               WANT 8 BIT INTEGER SPIDER IMAGE ------------------ 8 BIT
d238 14
a251 12
                IF (NORMIT) THEN
                   DO  I = 1,NSAM
                     IVAL = I1BUF(I)
                     IF (IVAL .LT. 0) IVAL = 256 + IVAL
                     IF (IVAL .LT. IMIN) THEN
                       IMIN = IVAL
                     ELSEIF (IVAL .GT. IMAX) THEN
                       IMAX = IVAL
                     ENDIF
                   ENDDO
                   DAV  = DAV  + IVAL
                   DAV2 = DAV2 + IVAL * IVAL
d254 19
a272 2
C               WRITE OUT THE 8 BIT RECORD
                CALL WRTLIN8(LUNN,I1BUF,NSAM,IROW)
d274 10
a283 20
             ELSE
C               CONVERT TO 32 BIT FLOATING POINT ---------------- 32 BIT
                DO  I = 1,NSAM
                  IVAL = I1BUF(I)
                  IF (IVAL .LT. 0) IVAL = 256 + IVAL

                  IF (NORMIT) THEN
                     IF (IVAL .LT. IMIN) THEN
                       IMIN = IVAL
                     ELSEIF (IVAL .GT. IMAX) THEN
                       IMAX = IVAL
                     ENDIF
                     DAV  = DAV  + IVAL
                     DAV2 = DAV2 + IVAL * IVAL
                  ENDIF
                  FBUFN(I) = IVAL
                ENDDO

C               WRITE OUT THE FULL 32 BIT RECORD
                CALL WRTLIN(LUNN,FBUFN,NSAM,IROW)
a285 1
       ENDDO
d287 10
a296 22
       IF (NORMIT) THEN

C        PLACE LABEL IN UNIX SPIDER FILE
         FMAX  = IMAX
         FMIN  = IMIN
         FNALL = NSAM * NROW * NSLICE
         AV    = DAV / FNALL

         DTOP  = DAV2 - DAV * DAV / FNALL
         IF (DTOP .LT. 0.0) THEN
C           SQRT OF NEGATIVE NUMBER
            WRITE(NOUT,*) '*** SQRT(',DTOP,') IMPOSSIBLE' 
            DTEMP = DAV * DAV / FNALL
            WRITE(NOUT,*) '*** DAV2: ',DAV2,'DAV*DAV/FNALL:',DTEMP 
            CALL ERRT(31,'RAWTOSPIDER',NE)
            RETURN

         ELSEIF (FNALL .EQ. 1.0) THEN
C           DIVISION BY ZERO
            WRITE(NOUT,*) '*** FNALL(',FNALL,') GIVES DIV. BY 0' 
            CALL ERRT(31,'RAWTOSPIDER',NE)
            RETURN
d298 1
a298 2

         SIG   = DSQRT( DTOP / DBLE(FNALL-1.0))
d300 8
a307 5
C        PLACE NORM. CONSTANTS IN HEADER
         CALL SETPRM(LUNN,NSAM,NROW,FMAX,FMIN,AV,'U')

         WRITE(NOUT,94) IMIN,IMAX
94       FORMAT(' NEW IMAGE DENSITY RANGE: ',I6,'...',I6,/)
a309 3
      CLOSE(LUNO)
      CLOSE(LUNN)

d313 3
d319 2
@


1.1
log
@Initial revision
@
text
@d26 3
d30 1
@
