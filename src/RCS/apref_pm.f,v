head	1.84;
access;
symbols
	pre_getangas:1.73
	GPL2010:1.68
	pre_GPL2010:1.67
	pre_var_equation:1.67
	pre_fftwrings:1.62
	pre_opfiles:1.59
	src:1.59
	best-code:1.59
	x-named-regs:1.59
	x:1.59
	v13-00:1.59
	pre_GPL:1.57
	prec_CA:1.48
	noindx:1.40
	Bproc:1.22
	oct21:1.12
	last77:1.8;
locks; strict;
comment	@c @;


1.84
date	2015.04.30.13.16.19;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	2015.04.28.15.32.36;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	2015.04.24.14.05.25;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.09.17.36.15;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.18.13.18.44;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2012.01.18.13.37.42;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2012.01.11.14.48.19;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	2011.12.02.14.34.54;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2011.04.14.14.46.27;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2011.02.17.13.22.34;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	2011.02.16.20.22.05;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	2011.02.08.16.57.43;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	2011.01.21.16.04.03;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	2010.10.12.18.32.08;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	2010.07.13.18.17.17;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2010.06.29.18.24.18;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2010.06.24.13.25.29;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.02.13.27.42;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2008.11.25.15.47.31;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2008.06.03.15.27.01;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2008.05.20.16.41.00;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2008.05.19.12.02.33;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2008.04.08.13.48.14;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2008.03.19.12.36.59;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2008.03.19.12.11.33;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2005.10.17.20.48.32;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2005.10.17.18.38.56;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.23.15.35.02;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.09.16.45.56;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.07.14.35.08;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2004.08.18.15.54.58;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2004.08.18.14.54.36;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2004.06.30.16.31.05;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2004.03.31.15.10.27;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2004.03.25.18.49.55;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.18.14.48.32;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.12.12.46.35;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.05.20.02.37;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2003.09.02.14.55.34;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2003.08.27.16.00.11;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.27.14.48.47;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.07.18.54.04;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.23.20.52.27;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.19.21.31.50;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.20.20.38.37;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.17.20.35.06;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.11.14.08.05;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.22.20.56.46;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.14.21.28.30;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.19.18.43.10;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.09.16.57.27;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.17.13.25.56;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.12.19.53.55;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.11.12.42.40;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.05.16.31.42;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.24.18.18.04;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.06.14.53.50;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.26.19.04.11;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.17.20.00.18;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.17.19.36.43;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.31.17.34.33;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.28.13.53.17;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.11.19.24.58;	author pawel;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.04.20.57.28;	author bimal;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.12.19.23.00;	author bimal;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.28.16.34.58;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.01.16.03.05;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.01.15.54.01;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.24.19.23.38;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.27.15.56.47;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	99.12.03.20.33.22;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	99.10.25.18.22.33;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	99.10.20.21.31.17;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	99.08.06.19.32.56;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	99.08.05.21.04.50;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	99.04.16.14.11.56;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	99.03.25.20.09.03;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	99.03.19.14.58.15;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	99.03.01.18.48.14;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	99.03.01.14.33.11;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	98.12.03.16.56.35;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	98.11.30.19.20.12;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	98.11.02.20.39.57;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.10.31.19.45.49;	author pawel;	state Exp;
branches;
next	;


desc
@AP RN - calling program
@


1.84
log
@F == -999 WANT MIRCC NOT RO
mircc from getangas
@
text
@ 
C++********************************************************************
C
C    APREF_PM.F
C                   ADDED APSHIFT                 NOV 03 ARDEAN LEITH
C                   AP_END                        FEB 04 ARDEAN LEITH
C                   CROSRNG_E SPEEDS UP           AUG 04 ARDEAN LEITH
C                   AP_END CALL HAS PARLIST       OCT 04 ARDEAN LEITH
C                   CCROT STATISTICS              FEB 05 ARDEAN LEITH
C                   APRINGS_ONE                   MAR 05 ARDEAN LEITH
C                   CROSRNG_E REWRITE             MAR 08 ARDEAN LEITH
C                   IREFLIST VAR. NAME            MAR 08 ARDEAN LEITH
C                   FMRS_PLAN                     MAR 08 ARDEAN LEITH
C                   APRINGS_ONE_NEW               MAR 08 ARDEAN LEITH
C                   AP_END REDO                   NOV 08 ARDEAN LEITH
C                   AP_STAT_ADD                   NOV 08 ARDEAN LEITH
C                   ANGDIF EXPDIR BUG             MAR 09 ARDEAN LEITH
C                   CROSRNG_2, TT REMOVED         JUN 10 ARDEAN LEITH
C                   AP_STAT NBORDER               OCT 10 ARDEAN LEITH
C                   RENAMED FROM DSGR_PM          JAN 11 ARDEAN LEITH
C                   ROTFIRST                      FEB 11 ARDEAN LEITH
C                   MAKE_CLOSE_LIST, GETANGAS     FEB 11 ARDEAN LEITH
C                   AP_GETDATA USED               NOV 11 ARDEAN LEITH
C                   FBS_WANTED                    JAN 12 ARDEAN LEITH
C                   ANGINHEADER BUG               APR 15 ARDEAN LEITH
C                   AP_STAT_R USED                APR 15 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  APREF_PM
C
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SAMPLE IMAGES  'AP REF'
C           USED WHEN: CTYPE == 'T' OR
C           (CIRCREF_IN_CORE AND NUMBER OF THREADS > 1 AND
C           NUMBER OF EXP IMAGES > NUMBER OF THREADS).  THIS OCCURS
C           ALMOST ALWAYS ON MULTIPORCESSOR MACHINES EXCEPT WHEN 
C           USING A SINGLE EXP. IMAGE. 
C
C  ORDER OF PROCESSING:
C 1 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN CIRCREF.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 2 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_E. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULT IS ALREADY CORRECT.
C
C PARAMETERS:
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NUMREF              NO. OF IMAGES                     (INPUT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NUMEXP              NO. OF IMAGES                     (INPUT)
C       NX,NY               ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
C       EXPANGDOC           EXP. ANGLES FILE NAME             (INPUT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
C
C  OPERATIONS:  'AP REF'
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE APREF_PM(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
     &             NX,NY,ANGDIFTHR,RANGE,
     &             NRING,LCIRC,NUMR,CIRCREF,
     &             MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &             REFPAT,EXPPAT,CKMIRROR,CTYPE,
     &             ROTFIRST,ISHRANGE,LUNDOC,FBS_WANTED)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER                     :: NUMREF,NUMEXP
	INTEGER                     :: IREFLIST(NUMREF) 
	INTEGER                     :: IEXPLIST(NUMEXP) 
        INTEGER                     :: NX,NY
	REAL                        :: ANGDIFTHR,RANGE
        INTEGER                     :: NRING,LCIRC
        INTEGER                     :: NUMR(3,NRING)
	REAL                        :: CIRCREF(LCIRC,NUMREF)
        CHARACTER (LEN=1)           :: MODE
        CHARACTER (LEN=*)           :: REFANGDOC,EXPANGDOC,SCRFILE
        INTEGER*8, INTENT(IN)       :: FFTW_PLANS(*)
        CHARACTER (LEN=*)           :: REFPAT,EXPPAT
        LOGICAL                     :: CKMIRROR
        CHARACTER (LEN=*)           :: CTYPE
        LOGICAL                     :: ROTFIRST
        INTEGER                     :: ISHRANGE,LUNDOC
        LOGICAL                     :: FBS_WANTED,FIRST,FIRSTCC

C       ALLOCATABLE ARRAYS
	REAL,    ALLOCATABLE        :: EXPBUF(:,:,:)
	REAL,    ALLOCATABLE        :: AVI(:),SIGI(:)
	REAL,    ALLOCATABLE        :: CCLIST(:) 
	REAL,    ALLOCATABLE        :: RANGNLIST(:) 
	INTEGER, ALLOCATABLE        :: NPROJ(:)
	INTEGER, ALLOCATABLE        :: ILIST(:) 
	LOGICAL, ALLOCATABLE        :: MIRLIST(:) 
	REAL,    ALLOCATABLE        :: TMPBUF(:,:)

        INTEGER *8                  :: IPLAN ! STRUCTURE POINTER

        CHARACTER (LEN=1)           :: NULL = CHAR(0)
        LOGICAL                     :: CIRCREF_IN_CORE
        LOGICAL                     :: MIRRORNEW
        LOGICAL                     :: GOTREFANG,GOTEXPANG
        LOGICAL,PARAMETER           :: ANGINHEADER = .FALSE.

C       AUTOMATIC ARRAYS
	REAL                        :: DLIST(6)
	REAL                        :: ANGEXP(8,NUMEXP)
	REAL                        :: EXPDIR(3,NUMEXP)
	REAL                        :: REFDIR(3,NUMREF) 
	REAL                        :: ANGREF(3,NUMREF)

        INTEGER, PARAMETER          :: NLISTMAX = 15
        REAL                        :: PARLIST(NLISTMAX) 

	REAL, PARAMETER             :: QUADPI = 3.14159265358979323846
	REAL, PARAMETER             :: DGR_TO_RAD = (QUADPI/180)

        INTEGER                     :: NBORDER = 0       ! UNUSED
        INTEGER                     :: NSUBPIX = 0       ! UNUSED

        INTEGER, PARAMETER          :: INPIC   = 77
        INTEGER, PARAMETER          :: INANG   = 78
        INTEGER, PARAMETER          :: LUNRING = 50

C       FIND NUMBER OF OMP THREADS 
        CALL GETTHREADS(NUMTH) 

	RANGECOS = COS(RANGE*DGR_TO_RAD)

C       MAKE EXPBUF BIG ENOUGH FOR ALL THREADS
        MWANTX = NX * NY * NUMTH

	ALLOCATE(EXPBUF(NX,NY,NUMTH), 
     &           AVI(NUMTH),
     &           SIGI(NUMTH),
     &           ILIST(NUMTH),
     &           CCLIST(NUMTH),
     &           RANGNLIST(NUMTH),
     &           NPROJ(NUMTH),
     &           MIRLIST(NUMTH),
     &           STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = MWANTX + 7*NUMTH 
           CALL ERRT(46,'EXPBUF...',MWANT)
           GOTO 9999
        ENDIF
        IF (ROTFIRST) THEN
	   ALLOCATE(TMPBUF(NX,NY), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APREF_PM; TMPBUF',NX*NY)
              GOTO 9999
           ENDIF
           IF (FBS_WANTED) THEN
            WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH FBS INTERPOLATION'
           ELSE
           WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH QUAD INTERPOLATION'
           ENDIF
        ENDIF 

C       DUMMY CALL TO INITIALIZE REV. FFTW3 PLAN FOR USE WITHIN OMP ||
 	CALL FMRS_PLAN(.FALSE.,DUM,NX,NY,1, 1, -1, IPLAN, IRTFLG)
 	CALL FMRS_PLAN(.FALSE.,DUM,NX,NY,1, 1, +1, IPLAN, IRTFLG)

C       ZERO DLIST ARRAY
	DLIST = 0.0

C       GET REF PROJ. ANGLES FROM DOC FILE  OR IMAGE HEADER (IF WANTED)
C       CONVERT REF ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
        CALL AP_GETANGAS(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                   INPIC,INANG,3,ANGREF,GOTREFANG,NGOTREF,
     &                   .TRUE.,REFDIR,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       GET EXP PROJ. ANGLES FROM DOC FILE  OR IMAGE HEADER (IF WANTED)
C       CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
        IRTFLG = -8999   ! WANT CC MIR NOT CCROT
        CALL AP_GETANGAS(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                   INPIC,INANG,8,ANGEXP,GOTEXPANG,NGOTPAR,
     &                  .TRUE.,EXPDIR,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        ! NEED EXISTING ALIGN FILE FOR CC DIFFERENCES
        FIRST   = (NGOTPAR == 0)        ! FIRST FILE, NO DIFFERENCES

        ! NEED EXISTING CC CONTAINING ALIGN FILE FOR CC DIFFERENCES
        FIRSTCC = ANGEXP(8,1) ==  1.0 .OR. 
     &            ANGEXP(8,1) == -1.0 

        !write(6,*) 'angexp:',angexp(:,1), firstcc


C       READ REF IMAGES INTO REF RINGS (CIRCREF) ARRAY 
        CIRCREF_IN_CORE = .TRUE.

        CALL APRINGS_NEW(IREFLIST,NUMREF, NX,NY,
     &               NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &               REFPAT,INPIC,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C       INITIALIZE CC STATISTICS
        CALL AP_STAT_ADD_R(-1,ANGDIF,ANGDIFTHR, IBIGANGDIF,ANGDIFAVG,
     &               CC,CCLAS,CCAVG,IMPROVCC,CCIMPROV,IWORSECC,CCWORSE)


        DO IEXPT=1,NUMEXP,NUMTH
C         LOOP OVER ALL EXPERIMENTAL (SAMPLE) IMAGES

C         LOAD NUMTH EXPERIMENTAL IMAGES INTO ARRAY EXPBUF
          IEND = MIN(NUMEXP,IEXPT+NUMTH-1)

          IF (ROTFIRST) THEN
C            WANT TO ROTATE/SHIFT EXP IMAGES WHEN READING THEM
	     CALL AP_GETDATA_RTSQ(IEXPLIST,NUMEXP,
     &                        NX,NY, NX,NY, 0.0,
     &                        NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                        ANGINHEADER, ANGEXP, 
     &                        .TRUE.,TMPBUF,EXPBUF,
     &                        .TRUE.,AVI,SIGI,FBS_WANTED,IRTFLG)
          ELSE
	     CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                       NX,NY, NX,NY, 0.0,
     &                       NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                       .TRUE., EXPBUF,
     &                       .TRUE.,AVI,SIGI, IRTFLG)
          ENDIF
          IF (IRTFLG .NE. 0) GOTO 9999

C         FIND CLOSEST MATCHING REFERENCE IMAGE FOR EACH EXP. IMAGE
c$omp     parallel do private(IEXP,IT)
	  DO IEXP=IEXPT,IEND
             IT  = IEXP-IEXPT+1
	     CALL APREF_2(EXPBUF(1,1,IT),NX,NY,NUMR,NRING,
     &              MODE,CIRCREF,LCIRC,NUMREF,
     &              REFDIR,EXPDIR(1,IEXP),RANGECOS,
     &	            ILIST(IT),CCLIST(IT),RANGNLIST(IT),MIRLIST(IT),
     &              NPROJ(IT),CKMIRROR,FFTW_PLANS,IRTFLG)
	  ENDDO

C         LOOP OVER CURRENT SET OF EXPERIMENTAL (SAMPLE) IMAGES
          DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)

C            IT POINTS TO CURRENT EXP. IMAGE IN THE SUBLIST
             IT = IEXP - IEXPT + 1

C            ILIST(IT) IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
             IREF      = ILIST(IT)

             IF (IREF <= 0) THEN
C               NO NEARBY REFERENCE IMAGE
                IMGREF = 0
C               IREFT IS FOR REFDIR INDEX
                IREFT  = 1
             ELSE
                IMGREF = IREFLIST(IREF)
C               IREFT IS FOR REFDIR INDEX
                IREFT  = IREF
             ENDIF
  
             IMGEXP    = IEXPLIST(IEXP)
             CCROT     = CCLIST(IT)
             RANGNEW   = RANGNLIST(IT)
             MIRRORNEW = MIRLIST(IT) 
             PEAKV     = 0.0
             XSHNEW    = 0.0
             YSHNEW    = 0.0

             IF (IMGREF > 0 .AND. ISHRANGE > 0) THEN
C               DETERMINE SHIFT PARAMETERS FOR EXP. IMAGE IN EXPBUF 
                NXP = 2*NX+2
                NYP = 2*NY

                CALL APSHIFT(INPIC,  REFPAT,IMGREF,
     &                 NX,NY, NXP,NYP,
     &                 EXPBUF(1,1,IT),AVI(IT),SIGI(IT), ISHRANGE,
     &                 RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,PEAKV,IRTFLG)
                IF (IRTFLG .NE. 0) RETURN
             ENDIF

C            AP_END WRITES ALIGNMENT PARAMETERS TO DOC FILE 
             CALL AP_END(IEXP,IMGEXP,IMGREF, 
     &            ANGREF(1,IREFT),REFDIR(1,IREFT),
     &            ANGEXP(1,IEXP),EXPDIR(1,IEXP),ISHRANGE,
     &            GOTREFANG, NGOTPAR, CCROT,PEAKV,
     &            RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,REFPAT,
     &            NPROJ(IT), CTYPE, LUNDOC,PARLIST)

C           WRITE ALIGNMENT DATA TO IMAGE HEADER
            CALL AP_END_HEAD(IMGEXP,EXPPAT,INPIC,PARLIST,8,IRTFLG)

            CALL AP_STAT_ADD_R(NGOTPAR,
     &            PARLIST(10),ANGDIFTHR,IBIGANGDIF,ANGDIFAVG,
     &            PEAKV,ANGEXP(8,IEXP),CCAVG,
     &            IMPROVCC,CCIMPROV,IWORSECC,CCWORSE ,FIRSTCC)
          ENDDO
       ENDDO

      IF (LUNDOC > 0) THEN
C         SAVE CC & ANGULAR DISPLACEMENT STATISTICS IN DOC FILE

          CALL AP_STAT_R(NUMEXP,ANGDIFTHR,IBIGANGDIF,ANGDIFAVG, 
     &                   CCAVG,IMPROVCC,CCIMPROV, IWORSECC,CCWORSE,
     &                   FIRST,FIRSTCC, LUNDOC)
 
       ENDIF

9999   IF (ALLOCATED(EXPBUF))    DEALLOCATE(EXPBUF)
       IF (ALLOCATED(AVI))       DEALLOCATE(AVI)
       IF (ALLOCATED(SIGI))      DEALLOCATE(SIGI)
       IF (ALLOCATED(ILIST))     DEALLOCATE(ILIST)
       IF (ALLOCATED(CCLIST))    DEALLOCATE(CCLIST)
       IF (ALLOCATED(RANGNLIST)) DEALLOCATE(RANGNLIST)
       IF (ALLOCATED(MIRLIST))   DEALLOCATE(MIRLIST)
       IF (ALLOCATED(NPROJ))     DEALLOCATE(NPROJ)
       IF (ALLOCATED(TMPBUF))    DEALLOCATE(TMPBUF)

       END



C++************************** APREF_2 **********************************


	SUBROUTINE APREF_2(XIM,NX,NY, NUMR,NRING,MODE,
     &		         CIRCREF,LCIRC,NUMREF,
     &                   REFDIR,EXPDIR,RANGECOS,
     &                   IMGREFL,CCROT,RANGNEW,MIRNEW,NPROJ,
     &                   CKMIRROR,FFTW_PLANS,IRTFLG)

C       NOTE: RUNS WITHIN OMP PARALLEL SECTION OF CODE!
        INCLUDE 'MAKE_CLOSE_LIST.INC'  

        REAL                    :: XIM(NX,NY)
        INTEGER                 :: NUMR(3,NRING)
	CHARACTER (LEN=1)       :: MODE
	REAL                    :: CIRCREF(LCIRC,NUMREF)
	REAL                    :: REFDIR(3,NUMREF)
	REAL                    :: EXPDIR(3)
	REAL                    :: RANGECOS 
	LOGICAL                 :: CKMIRROR,ONLYMIRROR
	LOGICAL                 :: MIRNEW,LIMITRANGE
	LOGICAL                 :: ISMIRRORED
        LOGICAL                 :: USE_UN,USE_MIR
        INTEGER *8              :: FFTW_PLANS(*)

	DOUBLE PRECISION        :: CCROTD,TOTMIN
        INTEGER, POINTER        :: LCG(:)

C       ALLOCATABLE ARRAYS
        REAL, ALLOCATABLE       :: CIRCEXP(:)


        MAXRIN     = NUMR(3,NRING) - 2

        ALLOCATE(CIRCEXP(LCIRC),  STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'APREF_2; CIRCEXP',LCIRC)
           RETURN
        ENDIF

        WR         = 0.0
        NPROJ      = NUMREF
        LIMITRANGE = (RANGECOS < 1.0)
        NULLIFY(LCG)  ! FOR INTEL COMPILER

C       IF LIMITRANGE, LIST CLOSE REF. IMAGES, RETURNS: NPROJ
        CALL MAKE_CLOSE_LIST(NUMREF,LIMITRANGE,
     &                       REFDIR,EXPDIR,
     &                       RANGECOS, .TRUE., 
     &                       LCG, NPROJ, IRTFLG)

        IF (NPROJ <= 0) THEN
C          NO REF. IMAGE WITHIN COMPARISON ANGLE
           IMGREFL = 0 
           CCROT   = -1.0
           RANGNEW = 0.0
           MIRNEW  = .FALSE.
           RETURN
        ENDIF
    
C       CALCULATE DIMENSIONS FOR NORMALIZING IN APRINGS_ONE
	CNS2 = NX/2+1
	CNR2 = NY/2+1

C       EXTRACT EXP. IMAGE RINGS, NORMALIZE & FFT THEM
        CALL APRINGS_ONE_NEW(NX,NY, CNS2,CNR2, XIM, .FALSE.,
     &                       MODE,NUMR,NRING,LCIRC, WR,FFTW_PLANS,
     &                       CIRCEXP,IRTFLG)
    
        CCROTD  = -1.0D20
        IMGREFL = 0
      
        DO IMIL=1,NPROJ
           IMI = IMIL
           IF (LIMITRANGE) IMI = ABS(LCG(IMIL))

           IF (CKMIRROR .AND. LIMITRANGE) THEN
C              ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
               USE_UN  = (LCG(IMIL) >= 0)
               USE_MIR = (LCG(IMIL) < 0)
           ELSE
C              SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
               USE_UN  = .TRUE.
               USE_MIR = CKMIRROR
           ENDIF

C          CHECK MIRRORED/ NON-MIRRORED POSITION
           CALL CROSRNG_2(CIRCREF(1,IMI),CIRCEXP,
     &                    LCIRC,NRING, MAXRIN,NUMR,
     &                    .FALSE.,FFTW_PLANS(1),
     &                    USE_UN,USE_MIR,
     &                    ISMIRRORED,  TOTMIN,TOT)

           IF (TOTMIN >= CCROTD)  THEN
C             GOOD MATCH WITH TOTA (MIRRORED OR NOT)  POSITION 
              CCROTD  = TOTMIN
              RANGNEW = TOT
              MIRNEW  =  ISMIRRORED
              IMGREFL = IMI
           ENDIF

       ENDDO !END OF: DO IMIL=1,NPROJ
          
       IF (MODE == 'F')  THEN
           RANGNEW = (RANGNEW-1.0) / MAXRIN*360.0
       ELSE
           RANGNEW = (RANGNEW-1.0) / MAXRIN*180.0
       ENDIF

       CCROT = CCROTD
       IF (ASSOCIATED(LCG))    DEALLOCATE(LCG)
       NULLIFY(LCG)
       IF (ALLOCATED(CIRCEXP)) DEALLOCATE(CIRCEXP)

       END

#ifdef DEBUGD
        NR     = NUMR(1,NRING)     ! OUTER RING NUMBER
        MAXRIN = NUMR(3,NRING)

        write(88,*) ' DEBUG OUTPUT FROM APREF_PM'
        write(88,902) NR,MAXRIN
902     format(' OUTER RING NUMBER: ',I10,' RING LENGTH:',I10)
        do i = 1, nring
           write(88,901) NUMR(1,I),NUMR(2,I),NUMR(3,I)
901        format(3i10)
        enddo
#endif

@


1.83
log
@AP_STAT_R USED
@
text
@d134 1
a134 1
	REAL                        :: ANGEXP(9,NUMEXP)
a154 1

d203 1
d205 1
a205 1
     &                   INPIC,INANG,9,ANGEXP,GOTEXPANG,NGOTPAR,
d209 8
a216 2
        ! FIRST CC FILE HAS NO CC DIFFERENCES
        FIRST   = NGOTPAR == 0        ! FIRST FILE, NO DIFFERENCES
a217 2
        FIRSTCC = ANGEXP(9,1) ==  1.0 .OR. 
     &            ANGEXP(9,1) == -1.0 
a228 4
cc        CALL  AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
cc     &                   CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
cc     &                   CCROTIMPROV,IWORSECCROT,CCROTWORSE)

d230 1
a230 1
     &               CC,CCLAS,CCAVG,IMPRVCC,CCIMPRV,IWORSECC,CCWORSE)
d320 1
a320 1
     &            PEAKV,ANGEXP(9,IEXP),CCAVG,
a326 3

          !write(6,*) 'ANGEXP(9,1):::',  ANGEXP(:,1)
          !write(6,*) 'ANGEXP(9,2):::',  ANGEXP(:,2)
@


1.82
log
@undefined anginheader
@
text
@d26 1
d54 5
d75 1
a75 1
C       NSAM,NROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
a81 2
C  USED WHEN: (CIRCREF_IN_CORE && NUMTH.GT.1 && NUMEXP.GT.NUMTH) .OR. 
C          CTYPE .EQ. 'T' )
d87 1
a87 1
     &             NSAM,NROW,ANGDIFTHR,RANGE,
d99 1
a99 1
        INTEGER                     :: NSAM,NROW
d112 1
a112 1
        LOGICAL                     :: FBS_WANTED
d134 1
a134 1
	REAL                        :: ANGEXP(8,NUMEXP)
a154 12
#ifdef DEBUGD
        NR     = NUMR(1,NRING)     ! OUTER RING NUMBER
        MAXRIN = NUMR(3,NRING)

        write(88,*) ' DEBUG OUTPUT FROM APREF_PM'
        write(88,902) NR,MAXRIN
902     format(' OUTER RING NUMBER: ',I10,' RING LENGTH:',I10)
        do i = 1, nring
           write(88,901) NUMR(1,I),NUMR(2,I),NUMR(3,I)
901        format(3i10)
        enddo
#endif
d159 1
a159 1
        MWANTX = NSAM * NROW * NUMTH
d161 1
a161 1
	ALLOCATE(EXPBUF(NSAM,NROW,NUMTH), 
d176 1
a176 1
	   ALLOCATE(TMPBUF(NSAM,NROW), STAT=IRTFLG)
d178 1
a178 1
              CALL ERRT(46,'APREF_PM; TMPBUF',NSAM*NROW)
d189 2
a190 2
 	CALL FMRS_PLAN(.FALSE.,DUM,NSAM,NROW,1, 1, -1, IPLAN, IRTFLG)
 	CALL FMRS_PLAN(.FALSE.,DUM,NSAM,NROW,1, 1, +1, IPLAN, IRTFLG)
d205 1
a205 1
     &                   INPIC,INANG,8,ANGEXP,GOTEXPANG,NGOTPAR,
d209 6
d218 1
a218 1
        CALL APRINGS_NEW(IREFLIST,NUMREF, NSAM,NROW,
d224 8
a231 4
C       INITIALIZE CCROT STATISTICS
        CALL  AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
     &                   CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                   CCROTIMPROV,IWORSECCROT,CCROTWORSE)
d242 1
a242 1
     &                        NSAM,NROW, NSAM,NROW, 0.0,
d249 1
a249 1
     &                       NSAM,NROW, NSAM,NROW, 0.0,
d260 1
a260 1
	     CALL APREF_2(EXPBUF(1,1,IT),NSAM,NROW,NUMR,NRING,
d276 1
a276 1
             IF (IREF .LE. 0) THEN
d295 1
a295 1
             IF (IMGREF .GT. 0 .AND. ISHRANGE .GT. 0) THEN
d297 2
a298 2
                NSAMP = 2*NSAM+2
                NROWP = 2*NROW
d301 1
a301 1
     &                 NSAM,NROW, NSAMP,NROWP,
d315 2
a316 7
C            WRITE ALIGNMENT DATA TO IMAGE HEADER
             CALL AP_END_HEAD(IMGEXP,EXPPAT,INPIC,PARLIST,8,IRTFLG)

             CALL AP_STAT_ADD(NGOTPAR,CCROT,PARLIST(10),
     &                    ANGDIFTHR,ANGEXP(8,IEXP),
     &                    CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                    CCROTIMPROV,IWORSECCROT,CCROTWORSE)
d318 4
d325 11
a335 8
      IF (LUNDOC .GT. 0) THEN
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS
          CALL AP_STAT(NUMEXP,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,
     &                 NBORDER,NSUBPIX,LUNDOC)
      ENDIF
d354 1
a354 1
	SUBROUTINE APREF_2(XIM,NSAM,NROW, NUMR,NRING,MODE,
d363 1
a363 1
        REAL                    :: XIM(NSAM,NROW)
a382 2
        MAXRIN     = NUMR(3,NRING)
#ifdef SP_LIBFFTW3
a383 1
#endif
d393 1
a393 1
        LIMITRANGE = (RANGECOS .LT. 1.0)
d402 1
a402 1
        IF (NPROJ .LE. 0) THEN
d412 2
a413 2
	CNS2 = NSAM/2+1
	CNR2 = NROW/2+1
d416 1
a416 1
        CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, XIM, .FALSE.,
d429 2
a430 2
               USE_UN  = (LCG(IMIL) .GE. 0)
               USE_MIR = (LCG(IMIL) .LT. 0)
d444 1
a444 1
           IF (TOTMIN .GE. CCROTD)  THEN
d454 1
a454 1
       IF (MODE .EQ. 'F')  THEN
d467 12
@


1.81
log
@NULLIFY(LCG)  ! FOR INTEL COMPILER
@
text
@d25 1
d31 1
a31 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d126 1
a126 1
        LOGICAL                     :: ANGINHEADER
@


1.80
log
@fbs_wanted shud be logical
@
text
@d392 1
d459 1
a459 1
       IF (ASSOCIATED(LCG))     DEALLOCATE(LCG)
@


1.79
log
@added rtsq call msg.
@
text
@d106 2
a107 1
        INTEGER                     :: ISHRANGE,LUNDOC,FBS_WANTED
@


1.78
log
@FBS_WANTED
@
text
@d187 5
@


1.77
log
@ap_getdats --> ap_getdata
@
text
@d24 1
d86 1
a86 1
     &             ROTFIRST,ISHRANGE,LUNDOC)
d106 1
a106 1
        INTEGER                     :: ISHRANGE,LUNDOC
d237 1
a237 1
     &                        .TRUE.,AVI,SIGI,IRTFLG)
@


1.76
log
@IF (ASSOCIATED(LCG))
@
text
@d23 1
d231 2
a232 1
	     CALL AP_GETDATS_RTSQ(IEXPLIST,NUMEXP,NSAM,NROW,
d235 2
a236 1
     &                        TMPBUF,EXPBUF,AVI,SIGI,IRTFLG)
d238 5
a242 3
	     CALL AP_GETDATS(IEXPLIST,NUMEXP,NSAM,NROW,
     &                        NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                        EXPBUF,AVI,SIGI, IRTFLG)
@


1.75
log
@MAKE_CLOSE_LIST, GETANGAS
@
text
@d446 1
a446 1
       IF (ALLOCATED(LCG))     DEALLOCATE(LCG)
@


1.74
log
@MAKE_CLOSE_LIST, GETANGAS
@
text
@d72 1
a72 1
C  OPERATIONS:  'AP MD', 'AP REF', 'AP RD', 'AP RN'
d339 1
a339 1
     &                   SA,TA,RANGECOS,
d350 2
a351 2
	REAL                    :: SA(3,NUMREF)
	REAL                    :: TA(3)
d383 1
a383 1
     &                       TA,SA,
@


1.73
log
@rotfirst added, ap_getdat_rtsq
@
text
@d4 19
a22 18
C    AP_REF_PM.F
C                       ADDED APSHIFT              NOV 03 ARDEAN LEITH
C                       AP_END                     FEB 04 ARDEAN LEITH
C                       CROSRNG_E SPEEDS UP        AUG 04 ARDEAN LEITH
C                       AP_END CALL HAS PARLIST    OCT 04 ARDEAN LEITH
C                       CCROT STATISTICS           FEB 05 ARDEAN LEITH
C                       APRINGS_ONE                MAR 05 ARDEAN LEITH
C                       CROSRNG_E REWRITE          MAR 08 ARDEAN LEITH
C                       IREFLIST VAR. NAME         MAR 08 ARDEAN LEITH
C                       FMRS_PLAN                  MAR 08 ARDEAN LEITH
C                       APRINGS_ONE_NEW            MAR 08 ARDEAN LEITH
C                       AP_END REDO                NOV 08 ARDEAN LEITH
C                       AP_STAT_ADD                NOV 08 ARDEAN LEITH
C                       ANGDIF EXPDIR BUG          MAR 09 ARDEAN LEITH
C                       CROSRNG_2, TT REMOVED      JUN 10 ARDEAN LEITH
C                       AP_STAT NBORDER            OCT 10 ARDEAN LEITH
C                       RENAMED FROM DSGR_PM       JAN 11 ARDEAN LEITH
C                       ROTFIRST                   FEB 11 ARDEAN LEITH
d46 1
a46 1
C  AP_REF_PM
d79 1
a79 1
        SUBROUTINE AP_REF_PM(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
d121 1
a121 1
        LOGICAL                     :: GOTREFANG
d151 1
a151 1
        write(88,*) ' DEBUG OUTPUT FROM AP_REF_PM'
d160 1
a160 2
C       THIS ALTERS RANGE!
	RANGE  = COS(RANGE*DGR_TO_RAD)
d182 1
a182 1
              CALL ERRT(46,'AP_REF_PM; TMPBUF',NSAM*NROW)
d194 6
a199 13
        GOTREFANG = .FALSE.
        IF (CTYPE(1:2) .NE. 'MD') THEN
C          GET REF. PROJ. ANGLES (ANGREF) FROM DOC. FILE (REFANGDOC) OR
C          IMAGE FILE (REFPAT) HEAD 
	   CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                    INPIC,INANG,3,ANGREF,NGOTREF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
           GOTREFANG = .TRUE.

C          CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF
d201 6
a206 15
        NGOTPAR = 0
        IF (EXPANGDOC .NE. NULL) THEN
C          LOAD EXP. PROJ. ANGLES & ALIGNMENT PARAMETERS (ANGEXP) 
C          FROM DOC. FILE (EXPANGDOC) 

           CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                       INPIC,INANG,8,ANGEXP,NGOTPAR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
	   CALL AP_GETSATA(ANGEXP,EXPDIR,8,NUMEXP,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
       ELSE
           ANGEXP = 0.0
       ENDIF
d208 1
a208 1
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
d245 1
a245 1
	     CALL AP_REF_2(EXPBUF(1,1,IT),NSAM,NROW,NUMR,NRING,
d247 1
a247 1
     &              REFDIR,EXPDIR(1,IEXP),RANGE,
d334 1
a334 1
C++************************** AP_REF_2 **********************************
d337 1
a337 1
	SUBROUTINE AP_REF_2(XIM,NSAM,NROW, NUMR,NRING,MODE,
d339 1
a339 1
     &                   SA,TA,RANGE,
d344 1
d352 1
a352 1
	REAL                    :: RANGE 
d360 1
a364 2
C       AUTOMATIC ARRAYS
        INTEGER                 :: LCG(NUMREF)
d373 1
a373 1
           CALL ERRT(46,'AP_REF_2; CIRCEXP',LCIRC)
d379 1
a379 1
        LIMITRANGE = (RANGE .LT. 1.0)
d381 13
a393 27
        IF (LIMITRANGE) THEN
C          DETERMINE WHICH ONES ARE TO BE COMPARED
           NPROJ = 0
           DO IMI=1,NUMREF
C             ABS - DIRECTIONS AT 180 DEGREES ARE THE SAME (MIRRORED)
C             DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED
              DT =    (TA(1) * SA(1,IMI) + 
     &                 TA(2) * SA(2,IMI) +
     &                 TA(3) * SA(3,IMI))
              DTABS = ABS(DT) 

              IF (DTABS .GE. RANGE)  THEN
C                EITHER MIRRORED OR NON-MIRRORED IS WITHIN RANGE
                 NPROJ      = NPROJ + 1
                 LCG(NPROJ) = IMI
                 IF (DT .LT. 0) LCG(NPROJ) = -IMI
              ENDIF
           ENDDO

           IF (NPROJ .LE. 0) THEN
C             NO REF. IMAGE WITHIN COMPARISON ANGLE
              IMGREFL = 0 
	      CCROT   = -1.0
              RANGNEW = 0.0
              MIRNEW  = .FALSE.
              RETURN
           ENDIF
a395 1

d424 4
a427 4
     &                          LCIRC,NRING, MAXRIN,NUMR,
     &                          .FALSE.,FFTW_PLANS(1),
     &                          USE_UN,USE_MIR,
     &                          ISMIRRORED,  TOTMIN,TOT)
d446 3
a448 1
       IF (ALLOCATED(CIRCEXP))     DEALLOCATE(CIRCEXP)
@


1.72
log
@renamed
@
text
@d21 1
d27 1
a27 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d82 2
a83 1
     &             REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,LUNDOC)
d88 16
a103 10
	INTEGER, DIMENSION(NUMREF)             :: IREFLIST 
	INTEGER, DIMENSION(NUMEXP)             :: IEXPLIST 
        INTEGER, DIMENSION(3,NRING)            :: NUMR
	REAL, DIMENSION(LCIRC,NUMREF)          :: CIRCREF

        CHARACTER(LEN=1)                       :: MODE,NULL
        CHARACTER (LEN=*)                      :: REFPAT,EXPPAT,SCRFILE
        CHARACTER (LEN=*)                      :: REFANGDOC,EXPANGDOC
        LOGICAL                                :: CKMIRROR
        CHARACTER (LEN=*)                      :: CTYPE
d106 16
a121 14
	REAL,    ALLOCATABLE, DIMENSION(:,:,:) :: EXPBUF
	REAL,    ALLOCATABLE, DIMENSION(:)     :: AVI,SIGI
	REAL,    ALLOCATABLE, DIMENSION(:)     :: CCLIST 
	REAL,    ALLOCATABLE, DIMENSION(:)     :: RANGNLIST 
	INTEGER, ALLOCATABLE, DIMENSION(:)     :: NPROJ
	INTEGER, ALLOCATABLE, DIMENSION(:)     :: ILIST 
	LOGICAL, ALLOCATABLE, DIMENSION(:)     :: MIRLIST 
	!integer, allocatable, dimension(:)     :: iptr

        INTEGER *8                             :: IPLAN !STRUCTURE POIN

        LOGICAL                                :: CIRCREF_IN_CORE
        LOGICAL                                :: MIRRORNEW
        LOGICAL                                :: GOTREFANG
d124 18
a141 17
	REAL, DIMENSION(6)                     :: DLIST
	REAL, DIMENSION(8,NUMEXP)              :: ANGEXP
	REAL, DIMENSION(3,NUMEXP)              :: EXPDIR
	REAL, DIMENSION(3,NUMREF)              :: REFDIR,ANGREF 

        INTEGER, PARAMETER                     :: NLISTMAX = 15
        REAL                                   :: PARLIST(NLISTMAX) 

	REAL, PARAMETER  :: QUADPI     = 3.14159265358979323846
	REAL, PARAMETER  :: DGR_TO_RAD = (QUADPI/180)

        INTEGER          :: NBORDER = 0       ! UNUSED
        INTEGER          :: NSUBPIX = 0       ! UNUSED

	DATA  INPIC/77/,INANG/78/,LUNRING/50/

        NULL   = CHAR(0)
d179 7
d244 11
a254 3
	  CALL AP_GETDATS(IEXPLIST,NUMEXP,NSAM,NROW,
     &                   NUMTH,EXPPAT,INPIC, IEXPT,IEND,
     &                   EXPBUF,AVI,SIGI, IRTFLG)
d265 1
a265 1
     &              NPROJ(IT),CKMIRROR,FFTW_PLANS)
d316 4
a319 1
             CALL  AP_STAT_ADD(NGOTPAR,CCROT,PARLIST(10),
d344 1
d357 1
a357 1
     &                   CKMIRROR,FFTW_PLANS)
d361 12
a372 12
        REAL, DIMENSION(NSAM,NROW)             :: XIM
        INTEGER, DIMENSION(3,NRING)            :: NUMR
	CHARACTER(LEN=1)                       :: MODE
	REAL, DIMENSION(LCIRC,NUMREF)          :: CIRCREF
	REAL, DIMENSION(3,NUMREF)              :: SA
	REAL, DIMENSION(3)                     :: TA 
	REAL                                   :: RANGE 
	LOGICAL                                :: CKMIRROR,ONLYMIRROR
	LOGICAL                                :: MIRNEW,LIMITRANGE
	LOGICAL                                :: ISMIRRORED
        LOGICAL                                :: USE_UN,USE_MIR
        INTEGER *8                             :: FFTW_PLANS(*)
d374 1
a374 1
	DOUBLE PRECISION                       :: CCROTD,TOTMIN
d377 1
a377 1
        REAL, ALLOCATABLE                      :: CIRCEXP(:)
d380 1
a380 1
        INTEGER, DIMENSION(NUMREF)             :: LCG
a392 1

d406 1
a406 1
              DTABS =  ABS(DT) 
@


1.71
log
@AP_STAT NBORDER
@
text
@d4 1
a4 1
C    DSGR_PM.F
d20 1
d44 1
a44 1
C  DSGR_PM
d77 1
a77 1
        SUBROUTINE DSGR_PM(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
d120 1
a120 1
        REAL, DIMENSION(NLISTMAX)              :: PARLIST
d139 1
a139 1
        write(88,*) ' DEBUG OUTPUT FROM DSGR_PM'
d235 1
a235 1
	     CALL DSGR_2(EXPBUF(1,1,IT),NSAM,NROW,NUMR,NRING,
d320 1
a320 1
C++************************** DSGR_2 **********************************
d323 1
a323 1
	SUBROUTINE DSGR_2(XIM,NSAM,NROW, NUMR,NRING,MODE,
d346 3
a350 1
        REAL, DIMENSION(LCIRC)                 :: CIRCEXP
d357 7
d448 1
@


1.70
log
@LCG(IRR) bug
@
text
@d19 1
d121 5
a125 2
	PARAMETER (QUADPI = 3.14159265358979323846)
	PARAMETER (DGR_TO_RAD =   (QUADPI/180))
d302 2
a303 1
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
@


1.69
log
@CROSRNG_2, TT REMOVED
@
text
@d401 2
a402 2
               USE_UN  = (LCG(IRR) .GE. 0)
               USE_MIR = (LCG(IRR) .LT. 0)
@


1.68
log
@GPL_2010
@
text
@d18 2
d42 1
a42 5
C   DSGR_PM(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
C           NSAM,NROW,NR,LENTT,RANGE,
C           NRING,LCIRC,NUMR,CIRCREF,
C           MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
C           REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,LUNDOC)
d76 1
a76 1
     &             NSAM,NROW,ANGDIFTHR,LENTT,RANGE,
a80 5
#ifdef SP_LIBFFTW3
        USE TYPE_KINDS      
        INTEGER(KIND=I_8)                      :: IPLAN !STRUCTURE POINTER 
#endif

d105 2
a110 2
	DOUBLE PRECISION                       :: TOTMIN_DUM

a112 1
	DOUBLE PRECISION, DIMENSION(LENTT)     :: TT
d128 1
a128 9
        CALL GETTHREADS(NUMTH)

#ifdef SP_LIBFFT
         IF (LENTT .GT. 15) THEN
C            CREATE TT FOR SGI FFT USE
             CALL DZFFT1DUI(LENTT-15,TT)
         ENDIF
#endif
 
d231 1
a231 1
     &              MODE,CIRCREF,LCIRC,NUMREF,TT,LENTT,
d318 1
a318 1
     &		         CIRCREF,LCIRC,NUMREF,TT,LENTT,
a328 1
	DOUBLE PRECISION, DIMENSION(LENTT)     :: TT
d334 2
a335 1
	LOGICAL                                :: MIRRORED
d338 1
a338 1
	DOUBLE PRECISION                       :: CCROTD,TOTMIN,TOTMIR
a343 2
        !integer, dimension(lcirc/2)            :: iptr

d399 4
a402 9
           IF ((CKMIRROR .AND. LIMITRANGE)  .OR.
     &         (.NOT. CKMIRROR)) THEN
              IF (.NOT. CKMIRROR) MIRRORED = .FALSE. 
              IF (LIMITRANGE)     MIRRORED = (LCG(IMIL) .LT. 0) 

C             CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	      CALL CROSRNG_EP_NEW(CIRCREF(1,IMI),CIRCEXP,LCIRC,
     &                          NRING,MAXRIN,NUMR, TOTMIN,TOT,
     &                          TT,MIRRORED, FFTW_PLANS(1))
d404 3
a406 5
C             CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS
              CALL CROSRNG_MSP_NEW(CIRCREF(1,IMI),CIRCEXP,
     &                         LCIRC,NRING,
     &	                       MAXRIN,NUMR, TOTMIN,TOT, TOTMIR,TMT, 
     &                         TT, FFTW_PLANS(1))
d409 7
d420 1
a420 1
              MIRNEW  =  (LIMITRANGE .AND. (LCG(IMIL) .LT. 0)) 
d424 1
a424 14
           IF (CKMIRROR .AND. .NOT. LIMITRANGE) THEN 
C             HAVE TO COMPARE WITH MIRRORED POSITION 
              IF (TOTMIR .GE. CCROTD .AND. 
     &            TOTMIR .GT. TOTMIN) THEN
C                GOOD MATCH WITH MIRRORED POSITION 
                 CCROTD  = TOTMIR
                 RANGNEW = TMT
                 MIRNEW  = .TRUE.
                 IMGREFL = IMI
              ENDIF
           ENDIF

C      END OF: DO IMIL=1,NPROJ
       ENDDO
a434 54



cXXXXXXXXXXXXXXXXXXXXX  UNUSED BELOW HERE   XXXXXXXXXXXXXXXXXXXXXXXXXXX



#ifdef NEVER
	allocate(iptr(lcirc/2),stat=irtflg)
	if (irtflg .ne. 0) then
           call errt(46,'iptr...',lcirc/2)
           goto 9999
        endif
c       load iptr with location in q
        do i=1,nring
           igo  = (numr(2,i)/2) + 1
           nval = numr(3,i)
           j    = 1
           do iloc=igo,igo+(nval/2)-1
              iptr(iloc) = j
              j          = j + 1
           enddo
ccc        write(6,*) ' iptr(',igo,'): ',iptr(igo),igo,nval
        enddo


            write(6,*) ' calling crosrng_e  OK'
 	      call crosrng_e(circref(1,imi),circexp,lcirc,nring,
     &	                         maxrin,numr, totmin,tot, 
     &                           tt, .false.)
 	      call crosrng_new_e(circref(1,imi),circexp,lcirc,nring,
     &	                         maxrin,numr, totmin,tot, 
     &                           tt, .false.)
              igot = 1
              do i=1,lcirc,2
                 circs(igot)   = circref(i,imi)
                 circs(igot+1) = circref(i+1,imi)
                 circs(igot+2) = circexp(i)
                 circs(igot+3) = circexp(i+1)
                 igot          = igot + 4
              enddo

	      call crosrng_new_e2(circs,lcirc,nring,
     &	                     maxrin,numr, totmin,tot, 
     &                       tt, .false.)

 	   call crosrng_new_c(circref(1,imi),circexp,lcircd2,nring,
     &	                     maxrin,numr, totmin,tot, 
     &                       tt, .false.,iptr)




#endif
@


1.67
log
@angdif  bug from expdir()
@
text
@a18 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
d20 5
a24 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d26 1
a26 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d31 1
a31 1
C=* This program is distributed in the hope that it will be useful,    *
d33 1
a33 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a34 1
C=*                                                                    *
d36 1
a36 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.66
log
@ apstat,mpi
@
text
@d16 2
a17 1
C                        AP_STAT_ADD               NOV 08 ARDEAN LEITH
d20 1
a20 1
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d300 1
a300 1
     &            ANGEXP(1,IEXP),EXPDIR,ISHRANGE,
@


1.65
log
@LCG(IMIL) .LT. 0
@
text
@d15 2
d50 1
a50 1
C           REFERENCE IMAGES WITH SAMPLE IMAGES
d60 1
a60 1
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
d74 2
d106 2
a107 1
	REAL,    ALLOCATABLE, DIMENSION(:,:,:) :: XBUF
d165 1
a165 1
C       MAKE XBUF BIG ENOUGH FOR ALL THREADS
d168 3
a170 1
	ALLOCATE(XBUF(NSAM,NROW,NUMTH), 
d178 2
a179 2
           MWANT = MWANTX + 5*NUMTH 
           CALL ERRT(46,'XBUF...',MWANT)
d229 4
a232 8
C       INITIALIZE CCROT STATISTICS        
        CCROTAVG    = 0.0
        IMPROVCCROT = 0
        CCROTIMPROV = 0.0
        IWORSECCROT = 0
        CCROTWORSE  = 0.0
        ANGDIFAVG   = 0.0
        IBIGANGDIF  = 0
d237 1
a237 1
C         LOAD NUMTH EXPERIMENTAL IMAGES INTO ARRAY XBUF
d242 1
a242 1
     &                   XBUF, IRTFLG)
d245 1
d249 1
a249 1
	     CALL DSGR_2(XBUF(1,1,IT),NSAM,NROW,NUMR,NRING,
d259 2
a260 1
             IT = IEXP-IEXPT+1
d266 4
a269 4
C                NO NEARBY REFERENCE IMAGE
                 IMGREF = 0
C                IREFT IS FOR REFDIR INDEX
                 IREFT  = 1
d271 3
a273 3
                 IMGREF = IREFLIST(IREF)
C                IREFT IS FOR REFDIR INDEX
                 IREFT  = IREF
d284 13
d299 9
a307 9
     &            ANGEXP(1,IEXP), EXPDIR(1,IEXP),ISHRANGE,
     &            GOTREFANG, NGOTPAR,NSAM,NROW,CCROT,PEAKV,
     &            RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &            NPROJ(IT), CTYPE, XBUF,LUNDOC,PARLIST)

             CCROTAVG = CCROTAVG + CCROT

             IF (NGOTPAR .GE. 8) THEN
C               COMPILE CCROT CHANGE STATISTICS
a308 15
                ANGDIF = PARLIST(10)
                IF (ANGDIF .GT. ANGDIFTHR)IBIGANGDIF = IBIGANGDIF + 1
  
                CCROTLAS  = ANGEXP(8,IEXP)
                ANGDIFAVG = ANGDIFAVG + PARLIST(10)

                CCROTAVG = CCROTAVG + CCROT
                IF (CCROT .GE. CCROTLAS) THEN
                   IMPROVCCROT = IMPROVCCROT + 1
                   CCROTIMPROV = CCROTIMPROV + CCROT
                ELSE
                   IWORSECCROT = IWORSECCROT + 1
                   CCROTWORSE  = CCROTWORSE + CCROT
                ENDIF
              ENDIF
d320 3
a322 1
9999   IF (ALLOCATED(XBUF))      DEALLOCATE(XBUF)
@


1.64
log
@bad FMRS_PLAN(NSAM, call
@
text
@d418 1
a418 1
              IF (LIMITRANGE)     MIRRORED = (LCG(IRR) .LT. 0) 
@


1.63
log
@FFTW3 plan changes, FFTW aprings
@
text
@d176 4
a230 4
C       DUMMY CALL TO INITIALIZE REV. FFTW3 PLAN FOR USE WITHIN OMP ||
 	CALL FMRS_PLAN(NSAM,NROW,1, 1, -1, IPLAN, IRTFLG)
 	CALL FMRS_PLAN(NSAM,NROW,1, 1, +1, IPLAN, IRTFLG)

@


1.62
log
@reverted to pre aprings change
@
text
@d11 4
a14 1
C
d17 1
a17 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d41 1
a41 1
C   DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d44 1
a44 1
C           MODE, REFANGDOC,EXPANGDOC,SCRFILE,
d46 4
a49 1

d51 1
a51 2
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
d55 1
a55 1
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
d61 4
a64 4
C       ILIST               LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NIMA                NO. OF IMAGES                     (INPUT)
C       ILIP                LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NIDI                NO. OF IMAGES                     (INPUT)
a72 1
C
d76 1
a76 1
        SUBROUTINE DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d79 1
a79 1
     &             MODE, REFANGDOC,EXPANGDOC,SCRFILE,
d82 5
d90 2
a91 2
	INTEGER, DIMENSION(NIMA)               :: ILIST 
	INTEGER, DIMENSION(NIDI)               :: ILIP 
d93 1
a93 1
	REAL, DIMENSION(LCIRC,NIMA)            :: CIRCREF
d106 1
a106 1
	INTEGER, ALLOCATABLE, DIMENSION(:)     :: IREFLIST 
d108 1
d114 2
d119 3
a121 3
	REAL, DIMENSION(8,NIDI)                :: ANGEXP
	REAL, DIMENSION(3,NIDI)                :: EXPDIR
	REAL, DIMENSION(3,NIMA)                :: REFDIR,ANGREF 
d129 1
a129 1
	DATA  INPIC/77/,INANG/78/,NSCF/50/
d138 1
d143 2
d148 9
d161 1
a161 1
        MWANTX = NSAM*NROW*NUMTH
d164 1
a164 1
     &           IREFLIST(NUMTH),
d183 1
a183 1
	   CALL AP_GETANGA(ILIST,NIMA,0,REFANGDOC,REFPAT,
d189 1
a189 1
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NIMA,IRTFLG)
d198 1
a198 1
           CALL AP_GETANGA(ILIP,NIDI,0,EXPANGDOC,EXPPAT,
d203 1
a203 1
	   CALL AP_GETSATA(ANGEXP,EXPDIR,8,NIDI,IRTFLG)
d212 2
a213 3
        CALL APRINGS(ILIST,NIMA,
     &               NSAM,NROW,NDUM,NDUM,
     &               NRING,LCIRC,NUMR,MODE, 
d215 1
a215 1
     &               NSCF,SCRFILE,IRTFLG)
d227 5
a231 1
        DO IEXPT=1,NIDI,NUMTH
d235 1
a235 1
          IEND = MIN(NIDI,IEXPT+NUMTH-1)
d237 1
a237 1
	  CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,
d246 1
a246 1
     &              MODE,MAXRIN,CIRCREF,LCIRC,NIMA,TT,LENTT,
d248 2
a249 2
     &	            IREFLIST(IT),CCLIST(IT),RANGNLIST(IT),MIRLIST(IT),
     &              NPROJ(IT),CKMIRROR)
d253 1
a253 1
          DO IEXP=IEXPT,MIN(NIDI,IEXPT+NUMTH-1)
d257 2
a258 2
C            IREFLIST(IT) IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
             IREF      = IREFLIST(IT)
d266 1
a266 1
                 IMGREF = ILIST(IREF)
d271 1
a271 1
             IMGEXP    = ILIP(IEXP)
d286 2
d309 1
a309 1
       IF (NGOTPAR .GE. 8 .AND. LUNDOC .GT. 0) THEN
d311 1
a311 1
          CALL AP_STAT(NIDI,ANGDIFTHR,IBIGANGDIF,
d318 1
a318 1
       IF (ALLOCATED(IREFLIST))  DEALLOCATE(IREFLIST)
d330 3
a332 2
	SUBROUTINE DSGR_2(XIM,NSAM,NROW,NUMR,NRING,MODE,MAXRIN,
     &		         CIRCREF,LCIRC,NIMA,TT,LENTT,
d334 4
a337 1
     &                   IMGREFL,CCROT,RANGNEW,MIRNEW,NPROJ,CKMIRROR)
d342 1
a342 1
	REAL, DIMENSION(LCIRC,NIMA)            :: CIRCREF
d344 1
a344 1
	REAL, DIMENSION(3,NIMA)                :: SA
d350 1
d355 1
a355 1
        INTEGER, DIMENSION(NIMA)               :: LCG
d358 9
a366 1
        NPROJ      = 0
d368 1
d371 2
a372 1
           DO IMI=1,NIMA
a395 2
        ELSE
           NPROJ = NIMA
d398 5
d404 3
a406 3
	CALL APRINGS_ONE(NSAM,NROW,0.0,
     &                   XIM,CIRCEXP,MODE,NUMR,NRING,LCIRC,
     &                  IRTFLG)
d408 1
a408 1
         CCROTD  = -1.0D20
d410 1
a410 1
       
d415 15
a429 18
           IF (CKMIRROR) THEN
              IF (LIMITRANGE) THEN
                 MIRRORED = (LCG(IMIL) .LT. 0) 
C                CHECK EITHER MIRRORED OR NON-MIRRORED POSITION 
	         CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,LCIRC,NRING,
     &		                MAXRIN,NUMR, TOTMIN,TOT,
     &                          TT,MIRRORED)
              ELSE

C                CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS
                 CALL CROSRNG_MS(CIRCREF(1,IMI),CIRCEXP,LCIRC,NRING,
     &	               MAXRIN,NUMR, TOTMIN,TOT, TOTMIR,TMT, TT)
              ENDIF
	   ELSE
C             DO NOT EVEN CHECK MIRRORED POSITION
	      CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,LCIRC,NRING,
     &	                     MAXRIN,NUMR, TOTMIN,TOT, 
     &                       TT, .FALSE.)
d454 1
a454 1
           
d465 55
@


1.61
log
@aprings_one call typo
@
text
@d11 1
a11 3
C                       CROSRNG_E REWRITE          MAR 08 ARDEAN LEITH
C                       IREFLIST VAR. NAME         MAR 08 ARDEAN LEITH
C                       FMRS_PLAN                  MAR 08 ARDEAN LEITH
d14 1
a14 1
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d38 1
a38 1
C   DSGR_PM(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
d43 1
a43 4
C
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SAMPLE IMAGES
C
d56 4
a59 4
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NUMREF              NO. OF IMAGES                     (INPUT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NUMEXP              NO. OF IMAGES                     (INPUT)
d68 1
d72 1
a72 1
        SUBROUTINE DSGR_PM(IREFLIST,NUMREF,IEXPLIST,NUMEXP,
a77 5
#ifdef SP_LIBFFTW3
        USE TYPE_KINDS      
        INTEGER(KIND=I_8)                      :: IPLAN !STRUCTURE POINTER 
#endif

d81 2
a82 2
	INTEGER, DIMENSION(NUMREF)             :: IREFLIST 
	INTEGER, DIMENSION(NUMEXP)             :: IEXPLIST 
d84 1
a84 1
	REAL, DIMENSION(LCIRC,NUMREF)          :: CIRCREF
d97 1
a97 1
	INTEGER, ALLOCATABLE, DIMENSION(:)     :: ILIST 
a98 1
	!integer, allocatable, dimension(:)     :: iptr
a103 2
	DOUBLE PRECISION                       :: TOTMIN_DUM

d107 3
a109 3
	REAL, DIMENSION(8,NUMEXP)              :: ANGEXP
	REAL, DIMENSION(3,NUMEXP)              :: EXPDIR
	REAL, DIMENSION(3,NUMREF)              :: REFDIR,ANGREF 
a125 1
C            CREATE TT FOR SGI FFT USE
a132 10
#ifdef DEBUGD
        write(88,*) ' DEBUG OUTPUT FROM DSGR_PM'
        write(88,902) NR,MAXRIN
902     format(' OUTER RING NUMBER: ',I10,' RING LENGTH:',I10)
        do i = 1, nring
           write(88,901) NUMR(1,I),NUMR(2,I),NUMR(3,I)
901        format(3i10)
        enddo
#endif

d140 1
a140 1
     &           ILIST(NUMTH),
d159 1
a159 1
	   CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
d165 1
a165 1
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
d174 1
a174 1
           CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
d179 1
a179 1
	   CALL AP_GETSATA(ANGEXP,EXPDIR,8,NUMEXP,IRTFLG)
d188 1
a188 1
        CALL APRINGS(IREFLIST,NUMREF,
d204 1
a204 6
C       DUMMY CALL TO INITIALIZE REV. FFTW3 PLAN FOR USE WITHIN OMP ||
 	CALL FMRS_PLAN(MAXRIN,1, 1, 1, -1, IPLAN, IRTFLG)
 	CALL FMRS_PLAN(NSAM,NROW,1, 1, -1, IPLAN, IRTFLG)
 	CALL FMRS_PLAN(NSAM,NROW,1, 1, +1, IPLAN, IRTFLG)

        DO IEXPT=1,NUMEXP,NUMTH
d208 1
a208 1
          IEND = MIN(NUMEXP,IEXPT+NUMTH-1)
d210 1
a210 1
	  CALL AP_GETDATS(IEXPLIST,NUMEXP,NSAM,NROW,
d219 1
a219 1
     &              MODE,MAXRIN,CIRCREF,LCIRC,NUMREF,TT,LENTT,
d221 1
a221 1
     &	            ILIST(IT),CCLIST(IT),RANGNLIST(IT),MIRLIST(IT),
d226 1
a226 1
          DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
d230 2
a231 2
C            ILIST(IT) IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
             IREF      = ILIST(IT)
d239 1
a239 1
                 IMGREF = IREFLIST(IREF)
d244 1
a244 1
             IMGEXP    = IEXPLIST(IEXP)
d280 1
a280 1
      IF (NGOTPAR .GE. 8 .AND. LUNDOC .GT. 0) THEN
d282 1
a282 1
          CALL AP_STAT(NUMEXP,ANGDIFTHR,IBIGANGDIF,
d289 1
a289 1
       IF (ALLOCATED(ILIST))     DEALLOCATE(ILIST)
a300 1

d302 1
a302 1
     &		         CIRCREF,LCIRC,NUMREF,TT,LENTT,
a305 2
C       NOTE: RUNS WITHIN OMP PARALLEL SECTION OF CODE!

d309 1
a309 1
	REAL, DIMENSION(LCIRC,NUMREF)          :: CIRCREF
d311 1
a311 1
	REAL, DIMENSION(3,NUMREF)              :: SA
d321 1
a321 1
        INTEGER, DIMENSION(NUMREF)             :: LCG
a323 2
        !integer, dimension(lcirc/2)            :: iptr

d328 1
a328 1
           DO IMI=1,NUMREF
d353 1
a353 1
           NPROJ = NUMREF
d357 3
a359 3
        CALL APRINGS_ONE(NSAM,NROW,0.0,
     &               XIM,CIRCEXP,MODE,NUMR,NRING,LCIRC,
     &               IRTFLG)
d361 1
a361 1
        CCROTD  = -1.0D20
d363 1
a363 1
      
d376 1
d379 1
a379 1
     &	                       MAXRIN,NUMR, TOTMIN,TOT, TOTMIR,TMT, TT)
d383 4
a386 4
 	      CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,LCIRC,NRING,
     &	                         MAXRIN,NUMR, TOTMIN,TOT, 
     &                           TT, .FALSE.)
          ENDIF
d410 1
a410 1
          
a420 96


cXXXXXXXXXXXXXXXXXXXXX  UNUSED BELOW HERE   XXXXXXXXXXXXXXXXXXXXXXXXXXX



#ifdef NEVER
	allocate(iptr(lcirc/2),stat=irtflg)
	if (irtflg .ne. 0) then
           call errt(46,'iptr...',lcirc/2)
           goto 9999
        endif
c       load iptr with location in q
        do i=1,nring
           igo  = (numr(2,i)/2) + 1
           nval = numr(3,i)
           j    = 1
           do iloc=igo,igo+(nval/2)-1
              iptr(iloc) = j
              j          = j + 1
           enddo
ccc        write(6,*) ' iptr(',igo,'): ',iptr(igo),igo,nval
        enddo


            write(6,*) ' calling crosrng_e  OK'
 	      call crosrng_e(circref(1,imi),circexp,lcirc,nring,
     &	                         maxrin,numr, totmin,tot, 
     &                           tt, .false.)
 	      call crosrng_new_e(circref(1,imi),circexp,lcirc,nring,
     &	                         maxrin,numr, totmin,tot, 
     &                           tt, .false.)
              igot = 1
              do i=1,lcirc,2
                 circs(igot)   = circref(i,imi)
                 circs(igot+1) = circref(i+1,imi)
                 circs(igot+2) = circexp(i)
                 circs(igot+3) = circexp(i+1)
                 igot          = igot + 4
              enddo

	      call crosrng_new_e2(circs,lcirc,nring,
     &	                     maxrin,numr, totmin,tot, 
     &                       tt, .false.)

 	   call crosrng_new_c(circref(1,imi),circexp,lcircd2,nring,
     &	                     maxrin,numr, totmin,tot, 
     &                       tt, .false.,iptr)



C--*********************************************************************

        SUBROUTINE  APPLYWS_TWO(CIRC1,CIRC2,CIRCS,LCIRC,NUMR,
     &                         WR,NRING,MAXRIN)

        INTEGER    :: NUMR(3,NRING) 
        REAL       :: CIRC(LCIRC),WR(NRING)
        REAL       :: CIRCS(2*LCIRC)

        DO I=1,NRING
           IGO       = NUMR(2,I)
           NVAL      = NUMR(3,I)
           IGOM1     = IGO - 1

           WT        = WR(I)

           IOUT          = 2 * IGO - 1
c          CIRC(IGO)     = CIRC(IGO)  * WT
           CIRCS(IOUT)   = CIRC1(IGO) * WT
           CIRCS(IOUT+1) = CIRC2(IGO)

           IF (NVAL .EQ. MAXRIN)  THEN
C             CIRC(IGO+1)   = CIRC(IGO+1)  * WT
              CIRCS(IOUT+2) = CIRC1(IGO+1) * WT
              CIRCS(IOUT+3) = CIRC2(IGO+1) 
           ELSE
C             CIRC(IGO+1)   = CIRC(IGO+1)  * WT * 0.5
              CIRCS(IOUT+2) = CIRC1(IGO+1) * WT * 0.5
              CIRCS(IOUT+3) = CIRC2(IGO+1)  
           ENDIF

           DO J=3,NVAL
              JC            = J + IGOM1
              IOUT          = 2 * J - 1
C             CIRC(JC)      = CIRC(JC)  * WT
              CIRCS(IOUT)   = CIRC1(JC) * WT
              CIRCS(IOUT+1) = CIRC2(JC)
           ENDDO
        ENDDO

        END

#endif


@


1.60
log
@ crosrng calls
@
text
@d390 3
a392 3
        CALL APRINGS(NSAM,NROW,0.0,
     &                   XIM,CIRCEXP,MODE,NUMR,NRING,LCIRC,
     &                  IRTFLG)
@


1.59
log
@GPL License fixed
@
text
@d11 3
a13 1
C
d16 1
a16 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d40 1
a40 1
C   DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d45 4
a48 1

d61 4
a64 4
C       ILIST               LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NIMA                NO. OF IMAGES                     (INPUT)
C       ILIP                LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NIDI                NO. OF IMAGES                     (INPUT)
a72 1
C
d76 1
a76 1
        SUBROUTINE DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d82 5
d90 2
a91 2
	INTEGER, DIMENSION(NIMA)               :: ILIST 
	INTEGER, DIMENSION(NIDI)               :: ILIP 
d93 1
a93 1
	REAL, DIMENSION(LCIRC,NIMA)            :: CIRCREF
d106 1
a106 1
	INTEGER, ALLOCATABLE, DIMENSION(:)     :: IREFLIST 
d108 1
d114 2
d119 3
a121 3
	REAL, DIMENSION(8,NIDI)                :: ANGEXP
	REAL, DIMENSION(3,NIDI)                :: EXPDIR
	REAL, DIMENSION(3,NIMA)                :: REFDIR,ANGREF 
d138 1
d146 10
d163 1
a163 1
     &           IREFLIST(NUMTH),
d182 1
a182 1
	   CALL AP_GETANGA(ILIST,NIMA,0,REFANGDOC,REFPAT,
d188 1
a188 1
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NIMA,IRTFLG)
d197 1
a197 1
           CALL AP_GETANGA(ILIP,NIDI,0,EXPANGDOC,EXPPAT,
d202 1
a202 1
	   CALL AP_GETSATA(ANGEXP,EXPDIR,8,NIDI,IRTFLG)
d211 1
a211 1
        CALL APRINGS(ILIST,NIMA,
d227 6
a232 1
        DO IEXPT=1,NIDI,NUMTH
d236 1
a236 1
          IEND = MIN(NIDI,IEXPT+NUMTH-1)
d238 1
a238 1
	  CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,
d247 1
a247 1
     &              MODE,MAXRIN,CIRCREF,LCIRC,NIMA,TT,LENTT,
d249 1
a249 1
     &	            IREFLIST(IT),CCLIST(IT),RANGNLIST(IT),MIRLIST(IT),
d254 1
a254 1
          DO IEXP=IEXPT,MIN(NIDI,IEXPT+NUMTH-1)
d258 2
a259 2
C            IREFLIST(IT) IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
             IREF      = IREFLIST(IT)
d267 1
a267 1
                 IMGREF = ILIST(IREF)
d272 1
a272 1
             IMGEXP    = ILIP(IEXP)
d308 1
a308 1
       IF (NGOTPAR .GE. 8 .AND. LUNDOC .GT. 0) THEN
d310 1
a310 1
          CALL AP_STAT(NIDI,ANGDIFTHR,IBIGANGDIF,
d317 1
a317 1
       IF (ALLOCATED(IREFLIST))  DEALLOCATE(IREFLIST)
d329 1
d331 1
a331 1
     &		         CIRCREF,LCIRC,NIMA,TT,LENTT,
d335 2
d340 1
a340 1
	REAL, DIMENSION(LCIRC,NIMA)            :: CIRCREF
d342 1
a342 1
	REAL, DIMENSION(3,NIMA)                :: SA
d352 1
a352 1
        INTEGER, DIMENSION(NIMA)               :: LCG
d355 2
d361 1
a361 1
           DO IMI=1,NIMA
d386 1
a386 1
           NPROJ = NIMA
d390 1
a390 1
	CALL APRINGS_ONE(NSAM,NROW,0.0,
d394 1
a394 1
         CCROTD  = -1.0D20
d396 1
a396 1
       
a408 1

d411 1
a411 1
     &	               MAXRIN,NUMR, TOTMIN,TOT, TOTMIR,TMT, TT)
d415 4
a418 4
	      CALL CROSRNG_E(CIRCREF(1,IMI),CIRCEXP,LCIRC,NRING,
     &	                     MAXRIN,NUMR, TOTMIN,TOT, 
     &                       TT, .FALSE.)
           ENDIF
d442 1
a442 1
           
d453 96
@


1.58
log
@HRI GPL License used
@
text
@a12 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d16 1
a16 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a35 6

C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.57
log
@removed windowing in getdats call
@
text
@d14 24
@


1.56
log
@APRINGS_ONE AP_STAT
@
text
@d193 1
a193 1
	  CALL AP_GETDATS(ILIP,NIDI,NSAM,NROW,NSAM,NROW,
@


1.55
log
@AP_END CALL HAS DUMLIST
@
text
@d8 3
a10 1
C                       AP_END CALL HAS DUMLIST    OCT 04 ARDEAN LEITH
d22 3
a24 3
C           LSAM,LROW,NR,LENTT,RANGE,
C           NRING,LCIRC,NUMR,BFC,
C           MODE, REFANGDOC,EXPANGDOC,
d30 1
a30 1
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
d43 1
a43 1
C       LSAM,LROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
d56 3
a58 3
     &             LSAM,LROW,NR,LENTT,RANGE,
     &             NRING,LCIRC,NUMR,BFC,
     &             MODE, REFANGDOC,EXPANGDOC,
d64 10
a73 10
	INTEGER, DIMENSION(NIMA)            :: ILIST 
	INTEGER, DIMENSION(NIDI)            :: ILIP 
        INTEGER, DIMENSION(3,NRING)         :: NUMR
	REAL, DIMENSION(LCIRC,NIMA)         :: BFC

        CHARACTER(LEN=1)                    :: MODE,NULL
        CHARACTER (LEN=*)                   :: REFPAT,EXPPAT
        CHARACTER (LEN=*)                   :: REFANGDOC,EXPANGDOC
        LOGICAL                             :: CKMIRROR
        CHARACTER (LEN=*)                   :: CTYPE
d76 10
a85 9
	REAL,    ALLOCATABLE, DIMENSION(:)  :: XBUF
	REAL,    ALLOCATABLE, DIMENSION(:)  :: CCLIST 
	REAL,    ALLOCATABLE, DIMENSION(:)  :: RANGNLIST 
	INTEGER, ALLOCATABLE, DIMENSION(:)  :: NPROJ
	INTEGER, ALLOCATABLE, DIMENSION(:)  :: IREFLIST 
	LOGICAL, ALLOCATABLE, DIMENSION(:)  :: MIRLIST 

        LOGICAL                             :: BFC_IN_CORE,MIRRORNEW
        LOGICAL                             :: GOTREFANG
d88 5
a92 4
	DOUBLE PRECISION, DIMENSION(LENTT)  :: TT
	REAL, DIMENSION(7,NIDI)             :: ANGEXP
	REAL, DIMENSION(3,NIDI)             :: EXPDIR
	REAL, DIMENSION(3,NIMA)             :: REFDIR,ANGREF 
d94 2
a95 2
        INTEGER, PARAMETER                  :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)           :: DUMLIST
d104 10
d115 2
d119 2
a120 3
C       FIND DIVAS, NUMTH, NSAM, & NROW
	CALL APMASTER_1(MODE,DIVAS,NR,NUMTH,LSAM,LROW,NSAM,NROW,
     &                   TT,LENTT)
d122 1
a122 4
C       MAKE XBUF AT LEAST LSAM*LROW FOR USE BY AP_SHIFTS
        MWANTX = MAX((NSAM*NROW*NUMTH),(LSAM*LROW))

	ALLOCATE(XBUF(MWANTX), 
d130 1
a130 1
           MWANT = MWANTX + 5*NUMTH
d158 1
a158 1
     &                       INPIC,INANG,7,ANGEXP,NGOTPAR,IRTFLG)
d161 2
a162 2
C          CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	   CALL AP_GETSATA(ANGEXP,EXPDIR,7,NIDI,IRTFLG)
d168 2
a169 2
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (BFC) ARRAY 
        BFC_IN_CORE = .TRUE.
d172 1
a172 1
     &               LSAM,LROW,NSAM,NROW,
d174 2
a175 2
     &               REFPAT,INPIC,BFC,BFC_IN_CORE,
     &               NSCF,NULL,IRTFLG)
d178 9
d190 2
d193 1
a193 3
C         LOAD WINDOWS FROM EXPERIMENTAL IMAGES INTO ARRAY XBUF
          IEND = MIN(NIDI,IEXPT+NUMTH-1)
	  CALL AP_GETDATS(ILIP,NIDI,LSAM,LROW,NSAM,NROW,
d198 2
a199 2
c$omp     parallel do private(IEXP,IT,IGO)
	  DO IEXP=IEXPT,MIN(NIDI,IEXPT+NUMTH-1)
d201 2
a202 3
             IGO = (IT - 1) * (NSAM * NROW) + 1
	     CALL DSGR_2(XBUF(IGO),NSAM,NROW,NUMR,NRING,
     &              MODE,MAXRIN,BFC,LCIRC,NIMA,TT,LENTT,
a205 1

d238 1
a238 1
     &            GOTREFANG, NGOTPAR,LSAM,LROW,CCROT,PEAKV,
d240 20
a259 1
     &            NPROJ(IT), CTYPE, XBUF,LUNDOC,DUMLIST)
d263 8
d276 1
d284 2
a285 3

	SUBROUTINE DSGR_2(X,NSAM,NROW,NUMR,NRING,MODE,MAXRIN,
     &		         BFC,LCIRC,NIMA,TT,LENTT,
d289 1
a289 1
        REAL, DIMENSION(NSAM,NROW)             :: X
d292 1
a292 1
	REAL, DIMENSION(LCIRC,NIMA)            :: BFC
a303 1
        REAL, DIMENSION(LCIRC)                 :: CIROLD
d305 1
d339 6
a344 11
C       NORMALIZE IMAGE VALUES OVER VARIANCE RANGE
        CALL NORMASS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                 NUMR,NUMR(1,NRING))

C       INTERPOLATION INTO POLAR COORDINATES
        CALL ALRQS(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE)

C       FOURIER TRANSFORM OF EXP. IMAGE RINGS
        CALL FRNGS(CIROLD,LCIRC,NUMR,NRING)

        CCROTD  = -1.0D20
d355 1
a355 1
	         CALL CROSRNG_E(BFC(1,IMI),CIROLD,LCIRC,NRING,
a357 2

cc                write(6,*) 'imi, totmin, tot:' ,imi,totmin,tot,LCG(IMIL)
d361 1
a361 1
                 CALL CROSRNG_MS(BFC(1,IMI),CIROLD,LCIRC,NRING,
d366 1
a366 1
	      CALL CROSRNG_E(BFC(1,IMI),CIROLD,LCIRC,NRING,
@


1.54
log
@bug in lcg index
@
text
@d8 1
d90 3
d221 1
a221 1
     &            NPROJ(IT), CTYPE, XBUF,LUNDOC)
@


1.53
log
@CROSRNG_E SPEEDS Up
@
text
@d308 1
a308 1
                 MIRRORED = (LCG(IRR) .LT. 0) 
d314 1
a314 1
c                write(6,*) imi, totmin, tot:' ,imi,totmin,tot
d332 1
a332 1
              MIRNEW  =  (LIMITRANGE .AND. (LCG(IRR) .LT. 0)) 
@


1.52
log
@cut out normass.f
@
text
@d7 2
d18 6
d32 1
a32 1
C     USING CROSRNG_DS. 
d249 1
d264 4
a267 1
              DT = ABS(TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI))
d269 1
a269 1
              IF (DT .GE. RANGE)  THEN
d273 1
d304 1
a304 1
           IF (LIMITRANGE) IMI = LCG(IMIL) 
d307 28
a334 3
C             CHECK BOTH NON-MIRRORED & MIRRORED POSITIONS
              CALL CROSRNG_MS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	            MAXRIN,NUMR, TOTMIN,TOT, TOTMIR,TMT, TT)
d336 2
a345 12
	   ELSE
C             DO NOT EVEN CHECK MIRRORED POSITION
	      CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                       MAXRIN,NUMR, TOTMIN,TOT, TT)
           ENDIF

           IF (TOTMIN .GE. CCROTD)  THEN
C             GOOD MATCH WITH NON-MIRRORED POSITION 
              CCROTD  = TOTMIN
              RANGNEW = TOT
              MIRNEW  = .FALSE.
              IMGREFL = IMI
@


1.51
log
@cosmetic
@
text
@a332 53

C++************************************************************************
C
C NORMASS.F
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C
C SERIALLY NORMALIZES X BY VARIANCE
C
C  NOTE   :    FOR PARALLEL USE NORMAS INSTEAD al Sept 01
C                                                                      *
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************

        SUBROUTINE  NORMASS(X,NS1,NS2,NR1,NR2,IR1,IR2)

        DIMENSION  X(NS1:NS2,NR1:NR2)
        REAL*8     AV,VR,VRINV

        I1SQ = IR1 * IR1
        I2SQ = IR2 * IR2
        AV   = 0.0
        VR   = 0.0
        N    = 0

        DO J=NR1,NR2
           JSQ = J * J
           DO I=NS1,NS2
              IR = JSQ + I*I
              IF (IR .GE. I1SQ .AND. IR .LE. I2SQ)  THEN
	         N  = N  + 1
                 AV = AV + X(I,J)
                 VR = VR + X(I,J)*X(I,J)
              ENDIF
           ENDDO
        ENDDO

        AV    = AV/N
        VR    = DSQRT((VR-N*AV*AV) / (N-1))
        VRINV = 1.0 / VR

        X  = (X - AV) * VRINV

        END
@


1.50
log
@minor changes
@
text
@d294 1
a294 1
C             CHECK NON-MIRRORED & MIRRORED POSITIONS
@


1.49
log
@AP SH, AP REF major changes
@
text
@d41 2
a42 1
C--************************************************************************
d68 1
a68 1
	INTEGER, ALLOCATABLE, DIMENSION(:)  :: NIMALCG
d102 1
a102 1
     &           NIMALCG(NUMTH),
d106 1
a106 1
           MWANT = MWANTX + 4*NUMTH
a146 1

d173 1
a173 1
     &              NIMALCG(IT),CKMIRROR)
d209 1
a209 1
     &            NIMALCG(IT), CTYPE, XBUF,LUNDOC)
d229 1
a229 1
     &                   IMGREFL,CCROT,RANGNEW,MIRNEW,NIMALCG,CKMIRROR)
d240 1
a240 1
	LOGICAL                                :: MIRNEW
d248 3
a250 3
        NIMALCG = 0
        IEND    = NIMA
        IF (RANGE .LT. 1.0) THEN
d259 2
a260 2
                 NIMALCG      = NIMALCG + 1
                 LCG(NIMALCG) = IMI
d264 1
a264 1
           IF (NIMALCG .LE. 0) THEN
d272 2
a273 1
           IEND = NIMALCG
a274 8
           do i = 1,iend
           if (lcg(i) .lt. 1 .or. lcg(i) .gt. nima) then
               write(6,*) 'after lcg'
               write(6,*) 'bad lcg(',i,'): ',lcg(i)
               stop
           endif
           enddo

a278 8
           do i = 1,iend
           if (lcg(i) .lt. 1 .or. lcg(i) .gt. nima) then
               write(6,*) 'after NORMASS'
               write(6,*) 'bad lcg(',i,'): ',lcg(i)
            stop
           endif
           enddo

a281 7
           do i = 1,iend
           if (lcg(i) .lt. 1 .or. lcg(i) .gt. nima) then
           write(6,*) 'after ALRQS '
               write(6,*) 'bad lcg(',i,'): ',lcg(i)
           stop
            endif
           enddo
a282 1

a285 9
           do i = 1,iend
           if (lcg(i) .lt. 1 .or. lcg(i) .gt. nima) then
           write(6,*) 'after FRNGS '
               write(6,*) 'bad lcg(',i,'): ',lcg(i)
           stop
            endif
           enddo


d289 1
a289 1
        DO IMIL=1,IEND
d291 1
a291 1
           IF (NIMALCG .GT. 0) IMI = LCG(IMIL) 
a294 9

           if (imi .lt. 1 .or. imi .gt. nima) then
              write(6,*) 'calling,IEND,IMI,IMIL,LCG(IMIL):',
     &                            IEND,IMI,IMIL,LCG(IMIL)
              stop
           endif 



d320 1
a320 1
C      END OF: DO IMIL=1,IEND
@


1.48
log
@ctype(1:2) needed
@
text
@d2 1
a2 1
C++************************************************************************
d5 10
a14 10
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
d27 14
d46 2
a47 2
     &             MODE, REFANG,EXPANG,
     &             REFPAT,EXPPAT,MIRROR,CTYPE)
a51 2
        PARAMETER (NLIST=8)

d57 1
a57 1
        CHARACTER(LEN=1)                    :: MODE
d59 2
a60 2
        CHARACTER (LEN=*)                   :: REFANG,EXPANG
        LOGICAL                             :: MIRROR
d63 7
a69 2
	REAL, ALLOCATABLE, DIMENSION(:,:,:) :: X
	REAL, ALLOCATABLE, DIMENSION(:,:)   :: DLIST 
d71 2
a72 1
        LOGICAL                             :: BFC_IN_CORE
d76 3
a78 2
	REAL, DIMENSION(3,NIMA)             :: SA 
	REAL, DIMENSION(3,NIDI)             :: TA
d80 1
a80 1
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
d83 3
a85 1
	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/
d94 10
a103 1
	ALLOCATE(X(NSAM,NROW,NUMTH), DLIST(NLIST,NUMTH),STAT=IRTFLG)
d105 3
a107 3
            MWANT = NSAM*NROW*NUMTH + NLIST*NUMTH
            CALL ERRT(46,'X...',MWANT)
            GOTO 9999
d113 13
a125 1
        CALL REG_GET_USED(NSEL_USED)
d127 4
a130 8
        LQ   = LROW/2+1
        LR1  = (NROW-1)/2
        LR2  = LQ+LR1
        LR1  = LQ-LR1
        LQ   = LSAM/2+1
        LS1  = (NSAM-1)/2
        LS2  = LQ+LS1
        LS1  = LQ-LS1
d132 2
a133 4
        IF (CTYPE(1:2) .NE. 'MD') THEN
C          READ REF. ANGLES AND CONVERT TO SA (UNITARY DIRECTIONAL VECTORS.
	   CALL AP_GETANG(ILIST,NIMA,0,REFANG,REFPAT,
     &                    INPIC,INANG,SA,IRTFLG)
d136 2
a137 3
C          READ EXP. ANGLES IMAGES AND CONVERT TO TA (UNITARY DIRECTIONAL VECTOR
	   CALL AP_GETANG(ILIP,NIDI,0,EXPANG,EXPPAT,
     &                    INPIC,INANG,TA,IRTFLG)
d139 2
d143 1
a143 1
C       READ REFERNCE IMAGES INTO REFERENCE RINGS (BFC) ARRAY 
d145 2
d151 1
a151 1
     &               NSCF,SCRFILE,IRTFLG)
d154 2
a155 2
        DO ITIT=1,NIDI,NUMTH
C         LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES
d157 6
a162 6
C         LOAD WINDOW FROM SAMPLE IMAGES INTO ARRAY X
          IEND = MIN(NIDI,ITIT+NUMTH-1)
	  CALL AP_GETDAT(ILIP,NIMA,LSAM,LROW,NSAM,NROW,
     &                   NUMTH,EXPPAT,INPIC, ITIT,IEND,
     &                   LR1,LR2,LS1,LS2, X,
     &                   IRTFLG)
d165 10
a174 9
C         NORMALIZE UNDER THE MASK
c$omp     parallel do private(ITI,IT)
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             IT = ITI-ITIT+1

	     CALL DSGR_2(X(1,1,IT),NSAM,NROW,NUMR,NRING,
     &          MODE,MAXRIN,BFC,LCIRC,NIMA,TT,LENTT,
     &          SA,TA(1,ITI),RANGE,
     &	        DLIST(2,IT), DLIST(3,IT), DLIST(4,IT),MIRROR,CTYPE)
d177 2
d180 1
a180 36
C         OUTPUT (IN DLIST POSITION IS INCREASED BY 1, NO.1 IS THE KEY).
C          2 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          3 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          4 - PSI ANGLE. (IN=PLANE ROTATION)
C          5 - SX SHIFT  PERMANENTLY SET TO ZERO (KEEP 'AP MQ' FORMAT)
C          6 - SY SHIFT  PERMANENTLY SET TO ZERO (KEEP 'AP MQ' FORMAT)
C          7 - INPUT IMAGE NUMBER.
C          8 -  ANGULAR CHANGE.

          DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             IT = ITI-ITIT+1

C            DLIST(2,IT IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
C                 (<0 IF MIRRORED, 0 IF NONE )

             IMI    = INT(DLIST(2,IT))
             IMIABS = ABS(IMI)

             DLIST(2,IT) = 0.0
             IF (IMIABS .NE. 0) THEN
C                SAVE NUMBER OF MOST SIMILAR REF. IMAGE 
                 DLIST(2,IT) = ILIST(IMIABS)

C                SET NUMBER <0 IF MIRRORED
                 IF (IMI .LT. 0) DLIST(2,IT) = -DLIST(2,IT) 

                 IF (CTYPE(1:2) .NE. 'MD') THEN
                    ANGT        = ABS(TA(1,ITI)*SA(1,IMIABS) +
     &                                TA(2,ITI)*SA(2,IMIABS) +
     &                                TA(3,ITI)*SA(3,IMIABS))
                    ANGT        = MIN(1.0,ANGT)
                    DLIST(8,IT) = ACOS(ANGT) / DGR_TO_RAD
                 ENDIF
             ELSE
                 IF (CTYPE(1:2) .NE. 'MD') DLIST(8,IT) = -1.0
             ENDIF
d182 2
a183 1
             DLIST(7,IT) = ILIP(ITI)
d185 5
a189 6
             IF (NSEL_USED .GT. 0) THEN
C               OUTPUT TO REGISTERS NOT TO DOC FILE
                CALL REG_SET_NSEL(1,5,DLIST(2,IT),DLIST(3,IT),
     &                     DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),IRTFLG)
                CALL REG_SET_NSEL(6,2,DLIST(7,IT),DLIST(8,IT),
     &                            0.0 ,0.0, 0.0,IRTFLG)
d191 3
a193 2
C               OUTPUT TO TO DOC FILE
                CALL LUNDOCWRTDAT(NDOC,ITI,DLIST(2,IT),NLIST-1,IRTFLG)
d195 15
d213 5
a217 4
9999   CLOSE(NDOC)

       IF (ALLOCATED(X))     DEALLOCATE(X)
       IF (ALLOCATED(DLIST)) DEALLOCATE(DLIST)
d223 1
a224 19
C++************************************************************************
C
C  DSGR_2.F
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C  DSGR_2
C
C  NOTE: CALLED INSIDE A PARALLEL LOOP
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
d229 1
a229 1
     &                   DLIST2,DLIST3,DLIST4,MIRROR,CTYPE)
d231 10
a240 10
        REAL, DIMENSION(NSAM,NROW)               :: X
        INTEGER, DIMENSION(3,NRING)              :: NUMR
	CHARACTER(LEN=1)                         :: MODE
	REAL, DIMENSION(LCIRC,NIMA)              :: BFC
	DOUBLE PRECISION, DIMENSION(LENTT)       :: TT
	REAL, DIMENSION(3,NIMA)                  :: SA
	REAL, DIMENSION(3)                       :: TA 
	REAL                                     :: RANGE 
	LOGICAL                                  :: MIRROR
        CHARACTER (LEN=*)                        :: CTYPE
d242 1
a242 1
	DOUBLE PRECISION                         :: EAV,TOTMIN,TOTMIR
d245 2
a246 2
        REAL, DIMENSION(LCIRC)                   :: CIROLD
        INTEGER, DIMENSION(NIMA)                 :: LCG
d248 3
a250 2
        IEND = NIMA
        IF (CTYPE(1:2) .NE. 'MD') THEN
a251 1
	   NIMALCG = 0
d254 1
d256 1
d258 1
d263 1
d265 5
a269 3
              DLIST2 = 0.0
	      DLIST3 = -1.0
              DLIST4 = 0.0
d274 19
a293 2
        CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                 NUMR,NUMR(1,NRING))
d295 1
d297 8
d306 1
d309 8
a316 1
        EAV = -1.0D20
d318 3
d323 10
a332 1
           IF (CTYPE(1:2) .NE. 'MD') IMI = LCG(IMIL)
d334 2
a335 2
           IF (MIRROR) THEN
C             CHECK MIRROR POSITION ALSO AT THIS TIME
d337 1
a337 1
     &	            MAXRIN,NUMR,TOTMIN,TOT,TOTMIR,TMT,TT)
d339 7
a345 11
              IF (TOTMIN.GE.EAV .AND. TOTMIN.GT.TOTMIR) THEN
C                NON-MIRRORED POSITION IS BETTER
                 EAV    = TOTMIN
                 DLIST2 = IMI
                 DLIST4 = TOT

              ELSEIF (TOTMIR .GE. EAV)  THEN
C                MIRRORED POSITION IS BETTER
                 EAV    = TOTMIR
                 DLIST2 = -IMI
                 DLIST4 = TMT
d348 1
a348 1
C             DO NOT CHECK MIRROR POSITION
d350 9
a358 6
     &	                       MAXRIN,NUMR,TOTMIN,TOT,TT)
              IF (TOTMIN .GE. EAV)  THEN
                  EAV    = TOTMIN
                  DLIST2 = IMI
                  DLIST4 = TOT
              ENDIF
d360 2
d365 1
a365 1
           DLIST4 = (DLIST4-1.0) / MAXRIN*360.0
d367 1
a367 1
           DLIST4 = (DLIST4-1.0) / MAXRIN*180.0
d369 2
a370 1
       DLIST3 = EAV
d374 53
@


1.47
log
@IMIABS ON SA( bug
@
text
@d274 1
a274 1
           IF (CTYPE .NE. 'MD') IMI = LCG(IMIL)
@


1.46
log
@ap rewrite
@
text
@d165 3
a167 3
                    ANGT        = ABS(TA(1,ITI)*SA(1,IMIT) +
     &                                TA(2,ITI)*SA(2,IMIT) +
     &                                TA(3,ITI)*SA(3,IMIT))
@


1.45
log
@ap rewrite, ctype bug
@
text
@d121 3
a123 3
     &                       NUMTH,EXPPAT,INPIC, ITIT,IEND,
     &                       LR1,LR2,LS1,LS2, X,
     &                       IRTFLG)
d255 1
a255 2
              DLIST2   = 0.0
              DLIST4   = 0.0
d257 2
d263 1
a263 1
           CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
d266 1
a266 1
           CALL ALRQS(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE)
d268 1
a268 1
           CALL FRNGS(CIROLD,LCIRC,NUMR,NRING)
d270 1
a270 1
           EAV = -1.0D20
d272 3
a274 3
           DO IMIL=1,IEND
              IMI = IMIL
              IF (CTYPE .EQ. 'MD') IMI = LCG(IMIL)
d276 3
a278 3
              IF (MIRROR) THEN
C                CHECK MIRROR POSITION ALSO AT THIS TIME
                 CALL CROSRNG_MS(BFC(1,IMI),CIROLD,LCIRC,NRING,
d281 15
a295 15
                 IF (TOTMIN.GE.EAV .AND. TOTMIN.GT.TOTMIR) THEN
C                   NON-MIRRORED POSITION IS BETTER
                    EAV    = TOTMIN
                    DLIST2 = IMI
                    DLIST4 = TOT

                 ELSEIF (TOTMIR .GE. EAV)  THEN
C                   MIRRORED POSITION IS BETTER
                    EAV    = TOTMIR
                    DLIST2 = -IMI
                    DLIST4 = TMT
                 ENDIF
	      ELSE
C                DO NOT CHECK MIRROR POSITION
	         CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
d297 4
a300 5
                 IF (TOTMIN .GE. EAV)  THEN
                     EAV    = TOTMIN
                     DLIST2 = IMI
                     DLIST4 = TOT
	         ENDIF
d302 2
a303 1
          ENDDO
d305 6
a310 5
	  IF (MODE .EQ. 'F')  THEN
             DLIST4 = (DLIST4-1.0) / MAXRIN*360.0
          ELSE
             DLIST4 = (DLIST4-1.0) / MAXRIN*180.0
	 ENDIF
d312 1
a312 3
	 DLIST3 = EAV

      END
@


1.44
log
@rewrite
@
text
@d243 1
a243 1
        IF (CTYPE .NE. 'MD') THEN
@


1.43
log
@new caller
@
text
@d30 4
a33 4
     &             NSAM,NROW,LSAM,LROW,RANGE,
     &             NRING,LCIRC,NUMR,MODE,NUMTH,
     &             REFANG,EXPANG,OUTANG,SUCCESS,
     &             REFPAT,EXPPAT)
d39 5
a43 4
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD =   (QUADPI/180))
        INTEGER                   NUMR(3,NRING)
	DIMENSION                 ILIST(NIMA),ILIP(NIDI)
a45 1
	CHARACTER (LEN=MAXNAM)              :: FILNAM
d48 3
a50 1
        CHARACTER (LEN=*)                   :: OUTANG
d52 3
a54 2
	REAL, ALLOCATABLE, DIMENSION(:,:)   :: BFC,DLIST,SA,TA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(: ) :: TT
d57 3
a59 2
        DIMENSION  BUFIN(LSAM)
	DIMENSION  WR(NRING)
d61 2
a62 8

	LOGICAL  SUCCESS

#ifndef SP_32
        INTEGER *8       IASK8,IOK
#else
        INTEGER *4       IASK8,IOK
#endif
d69 3
a71 23
C       RINGWE RETURNS WR
        CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H')  THEN
            WR    = WR*0.5
            DIVAS = 180.0
        ELSE
            DIVAS = 360.0
        ENDIF

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',MAXRIN+15)
           RETURN
        ENDIF
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',1)
           RETURN
        ENDIF
#endif
d73 1
a73 2
	ALLOCATE(X(NSAM,NROW,NUMTH),SA(3,NIMA),
     &          TA(3,NIDI),DLIST(NLIST,NUMTH),STAT=IRTFLG)
d75 1
a75 1
            MWANT = NSAM*NROW*NUMTH + 3*NIMA + 3*NIDI + NLIST*NUMTH
a82 21
C       FLAG TO OPEN OUTPUT DOC FILE
        NRUN  = 0

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          ALLOCATION FAILED, RETURN & USE SLOW METHOD
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   SUCCESS = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT ('--- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &             ' WILL TRY DSGR_P NOW ') 
           GOTO 9999
        ENDIF

        IASK8 = (LCIRC * NIMA + NIMA * 3 + NIDI * 3 + NSAM * NROW)*4
        CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

        SUCCESS = .TRUE.
        WRITE(NOUT,92) LCIRC,NIMA
92      FORMAT ('--- ALLOCATED: BFC(',I8,' X ',I8,'),  IN DSGR_PM') 

d94 5
a98 1
        CALL FLUSHRESULTS()
d100 5
a104 45
C       READ REF. ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
        DO  IMI=1,NIMA
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING REFERENCE PROJECTION ANGLE',IMI)
              GOTO 9999
           ENDIF
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
        ENDDO
        CLOSE(INANG)

C       READ THE ANGLES FOR ITI EXPERIMENTAL (SAMPLE) IMAGES
	DO  ITI=1,NIDI
	   CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',ITI)
              GOTO 9999
           ENDIF
           TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
	ENDDO
	CLOSE(INANG)

	DO ITIT=1,NIMA,NUMTH
	   DO K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
              NLET = 0
              CALL FILGET(REFPAT,FILNAM,NLET,ILIST(K1),INTFLAG)
	      MAXIM = 0
	      CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0)  GOTO 9999

	      DO K2=LR1,LR2
                 CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	         DO K3=LS1,LS2
                    X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
	         ENDDO
	      ENDDO
	      CLOSE(INPIC)
	  ENDDO
d106 8
a113 5
C         NORMALIZE UNDER THE MASK
c$omp     parallel do private(K1)
	  DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
	    CALL NORMAS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                 NUMR,NUMR(1,NRING))
d115 2
a116 6
	    CALL ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
     &		       BFC(1,K1),LCIRC,NRING,MODE)
	    CALL FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	    CALL APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
	  ENDDO
       ENDDO
d118 7
a124 18
       DO ITIT=1,NIDI,NUMTH
C         LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             NLET = 0
             CALL FILGET(EXPPAT,FILNAM,NLET,ILIP(ITI),INTFLAG)
	     MAXIM = 0
	     CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
             IF (IRTFLG .NE. 0)  GOTO 9999

             DO K2=LR1,LR2
                CALL REDLIN(INPIC,BUFIN,LSAM,K2)
                   DO K3=LS1,LS2
                      X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1) = BUFIN(K3)
	           ENDDO
    	     ENDDO
	     CLOSE(INPIC)
	  ENDDO
d127 1
a127 1
c$omp     parallel do private(ITI)
d129 6
a134 4
	     CALL DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,
     &             MODE,MAXRIN,BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	           DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),
     &             DLIST(4,ITI-ITIT+1))
d137 10
a146 5
C         DLIST(2) = IDI
C         DLIST(3) = EAV
C         DLIST(4) = ANGMOR(RANG,MODE)
C         DLIST 5&6  PERMANENTLY SET TO ZERO (KEEP SAME FORMAT AS
C         AP MQ COMMAND)
d148 23
a170 9
             DLIST(1,ITI-ITIT+1) = ITI
             IF (DLIST(2,ITI-ITIT+1) .GT. 0.0)  THEN
                 IDIT                = ILIST(INT(DLIST(2,ITI-ITIT+1)))
                 DLIST(2,ITI-ITIT+1) = IDIT
                 ANGT                = ABS(TA(1,ITI)*SA(1,IDIT)+
     &                                     TA(2,ITI)*SA(2,IDIT) +
     &                                     TA(3,ITI)*SA(3,IDIT))
                 ANGT                = MIN(1.0,ANGT)
                 DLIST(8,ITI-ITIT+1) = ACOS(ANGT) / DGR_TO_RAD
d172 1
a172 1
                 DLIST(8,ITI-ITIT+1) = -1.0
d174 2
a175 1
             DLIST(7,ITI-ITIT+1) = ILIP(ITI)
a178 1
                IT = ITI-ITIT+1
d180 3
a182 3
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),IRTFLG)
                CALL REG_SET_NSEL(6,2,DLIST(7,IT),
     &              DLIST(8,IT),0.0 ,0.0, 0.0,IRTFLG)
d185 1
a185 3
                CALL SAVDN1(NDOC,OUTANG,DLIST(1,ITI-ITIT+1),NLIST,
     &                      NRUN,0)
                NRUN = 1
d190 1
a190 2
       CALL  SAVDC
       CLOSE(NDOC)
a191 3
9999   IF (ALLOCATED(BFC))   DEALLOCATE(BFC)
       IF (ALLOCATED(TA))    DEALLOCATE(TA)
       IF (ALLOCATED(SA))    DEALLOCATE(SA)
a193 1
       IF (ALLOCATED(TT))    DEALLOCATE(TT)
a198 351
C++************************************************************************
C
C    DSGR_P.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_DS. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
C
C--************************************************************************

         SUBROUTINE DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,NUMR,
     &          MODE,ASK,REFANG,EXPANG,OUTANG,SCRFILE,
     &          REFPAT,EXPPAT)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NLIST=8)
        INTEGER                NUMR(3,NRING)
	DOUBLE PRECISION       EAV
	DIMENSION              ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
	CHARACTER (LEN=MAXNAM) :: FILNAM
        CHARACTER (LEN=*) ::      REFPAT,EXPPAT,REFANG,EXPANG
        CHARACTER (LEN=*) ::      OUTANG,SCRFILE

C       AUTOMATIC ARRAYS
        DIMENSION         BUFIN(LSAM)
	DIMENSION         WR(NRING)

	REAL, ALLOCATABLE, DIMENSION(:,:)  ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:)    ::  TOT,CIRC,CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TT,TOTMIN

#ifndef SP_32
        INTEGER *8       IASK8,IOK
#else
        INTEGER *4       IASK8,IOK
#endif

	CHARACTER(LEN=1) ::   MODE,ASK,NULL
	LOGICAL          ::   IN_CORE

	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

        NULL  = CHAR(0)

C       ZERO DLIST ARRAY
	DLIST = 0.0

C       FLAG TO OPEN OUTPUT DOC FILE
        NRUN  = 0

        MAXRIN = NUMR(3,NRING)
	RANGE  = COS(RANGE*DGR_TO_RAD)

C       RINGWE RETURNS WR
        CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H')  THEN
            WR    = WR*0.5
            DIVAS = 180.0
        ELSE
            DIVAS = 360.0
        ENDIF

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',MAXRIN+15)
           RETURN
        ENDIF
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',1)
           RETURN
        ENDIF
#endif

        ALLOCATE(TOT(NIMA),TOTMIN(NIMA),X(NSAM,NROW),CIRC(LCIRC),
     &           CIROLD(LCIRC),SA(3,NIMA),LCG(NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = 6 * NIMA + NSAM * NROW + 2 * LCIRC
           CALL  ERRT(46,'TOT,....',MWANT)
           GOTO 9999
        ENDIF

	IN_CORE = .TRUE.

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          GWP - I HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
	      CALL  ERRT(46,'AP RN, BFC',IER)
	      GOTO 9999
	   ENDIF
           IN_CORE = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT (' --- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &               ' USING TEMPORARY FILE INSTEAD') 
#ifdef SP_MP
           WRITE(NOUT,*) ' SETTING OMP THREADS: 2'
           CALL SETTHREADS(2)
#endif
        ELSE

           IASK8 = (LCIRC * NIMA + NIMA * 6 + LCIRC * 2 + NSAM * NROW)*4
           CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

           WRITE(NOUT,91) LCIRC,NIMA
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), IN DSGR_P ') 
  	ENDIF

        CALL FLUSHRESULTS()

        CALL REG_GET_USED(NSEL_USED)

        LQ  = LROW/2+1
        LR1 = (NROW-1)/2
        LR2 = LQ+LR1
        LR1 = LQ-LR1
        LQ  = LSAM/2+1
        LS1 = (NSAM-1)/2
        LS2 = LQ+LS1
        LS1 = LQ-LS1

C       READ  ANGLES AND CONVERT THEM TO UNITARY DIRECTIONAL VECTORS.
	DO  IMI=1,NIMA
	   CALL UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING REFERENCE PROJECTION ANGLE',IMI)
              GOTO 9999
           ENDIF
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
	ENDDO
	CLOSE(INANG)

	IF (ASK .EQ. 'Y')  GOTO  7751

	IF (ASK.EQ.'W' .OR. .NOT.IN_CORE) THEN
C          OPEN(NSCF,FILE=SCRFILE,STATUS='UNKNOWN',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'U',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF

	DO   K1=1,NIMA
C          OPEN REFERENCE PROJECTIONS
           NLET = 0
           CALL  FILGET(REFPAT,FILNAM,NLET,ILIST(K1),INTFLAG)
	   MAXIM = 0
	   CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

	   DO K2=LR1,LR2
              CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	      DO K3=LS1,LS2
                 X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	      ENDDO
	   ENDDO
	   CLOSE(INPIC)

C          NORMALIZE UNDER THE MASK
           CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))

	   CALL ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)

	   IF (ASK.EQ.'W'.OR..NOT.IN_CORE)  WRITE(NSCF)  CIRC
           IF (IN_CORE) THEN
c$omp         parallel do private(i)
              DO I=1,LCIRC
                 BFC(I,K1) = CIRC(I)
              ENDDO
           ENDIF
	ENDDO

	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)
7751    CONTINUE
        IF (.NOT. IN_CORE .OR. ASK.EQ.'Y') THEN
C          OPEN(NSCF,FILE='scratch.file',STATUS='OLD',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'O',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF

        IF (ASK .EQ. 'Y')  THEN
            DO  J=1,NIMA
               READ(NSCF) (BFC(I,J),I=1,LCIRC)
            ENDDO
            CLOSE(NSCF)
        ENDIF

        DO ITI=1,NIDI
C         OPEN EXPERIMENTAL (SAMPLE) IMAGES
          NLET = 0
          CALL FILGET(EXPPAT,FILNAM,NLET,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
          IF (IRTFLG .NE. 0)  GOTO 9999

          DO K2=LR1,LR2
             CALL REDLIN(INPIC,BUFIN,LSAM,K2)
             DO K3=LS1,LS2
                X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	     ENDDO
    	  ENDDO
	  CLOSE(INPIC)

C         READ THE ANGLES FOR THIS EXPERIMENTAL (SAMPLE) IMAGE
	  CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',ITI)
              GOTO 9999
           ENDIF
          TA(1) = COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2) = SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3) = COS(BUFIN(2)*DGR_TO_RAD)

C         NORMALIZE UNDER THE MASK
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))
	  CALL ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
	  CALL FRNG(CIROLD,LCIRC,NUMR,NRING)

C         DETERMINE WHICH ONES ARE TO BE COMPARED
	  NIMALCG = 0
          DO   IMI=1,NIMA
C             ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                   (- DO NOT CHECK MIRRORED)
              DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	      IF (DT .GE. RANGE)  THEN
	         NIMALCG      = NIMALCG+1
	         LCG(NIMALCG) = IMI
	      ELSE
	         TOTMIN(IMI)  = -1.0D20
	      ENDIF
	  ENDDO
          EAV = -1.0D20
	  IF (NIMALCG.GT.0) THEN
             IF (IN_CORE) THEN
c$omp           parallel do private(imil,imi)
                DO IMIL=1,NIMALCG
	           IMI = LCG(IMIL)
	           CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ENDDO
             ELSE
             REWIND  NSCF
             DO IMI=1,NIMA
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT
C                    (- DO NOT CHECK MIRRORED)
                DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	        IF (DT .GE. RANGE)  THEN
                   READ(NSCF)  CIRC
                   CALL CROSRNG_DS(CIRC,CIROLD,LCIRC,NRING,
     &	                     MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ELSE
                   READ(NSCF)
	           TOTMIN(IMI) = -1.0D20
	        ENDIF
	     ENDDO
          ENDIF

          DO IMI=1,NIMA
             IF (TOTMIN(IMI) .GE. EAV)  THEN
                EAV  = TOTMIN(IMI)
                IDI  = ILIST(IMI)
                RANG = TOT(IMI)
	     ENDIF
	  ENDDO

          DLIST(2) = IDI
          DLIST(3) = EAV
          RANG     = (RANG-1) / MAXRIN * DIVAS
          DLIST(4) = RANG
C         DLIST 5&6  SET TO ZERO (KEEPS SAME FORMAT AS 'AP MQ')
          IDIT     = ABS(IDI)
          ANGT     = ABS(TA(1)*SA(1,IDIT)+TA(2)*SA(2,IDIT) +
     &                   TA(3)*SA(3,IDIT))
          ANGT     = MIN(1.0,ANGT)
          DLIST(8) = ACOS(ANGT) / DGR_TO_RAD
	 ELSE
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REF. PROJECTIONS	
            DLIST(2) = 0.0
            DLIST(3) = -1.0
            DLIST(4) = 0.0
            DLIST(8) = -1.0
	 ENDIF

         DLIST(1) = ITI
         DLIST(7) = ILIP(ITI)

         IF (NSEL_USED .GT. 0) THEN
C           OUTPUT TO REGISTER NOT TO DOC FILE
            CALL REG_SET_NSEL(1,5,DLIST(2),DLIST(3),DLIST(4),
     &                  DLIST(5),DLIST(6),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(7),DLIST(8),0.0,0.0,0.0,IRTFLG)
         ELSE
C           OUTPUT TO TO DOC FILE
            CALL SAVDN1(NDOC,OUTANG,DLIST,NLIST, NRUN,0)
            NRUN = 1
         ENDIF
      ENDDO

      CALL  SAVDC
      CLOSE(NDOC)
      CLOSE(INANG)

9999  IF (.NOT.IN_CORE)  CLOSE(NSCF)
      DEALLOCATE(BFC)
      DEALLOCATE(LCG)
      DEALLOCATE(SA)
      DEALLOCATE(CIROLD)
      DEALLOCATE(CIRC)
      DEALLOCATE(X)
      DEALLOCATE(TOTMIN)
      DEALLOCATE(TOT)
      DEALLOCATE(TT)
a199 4
      END



d202 1
a202 1
C    DSGR_SA.F
d206 1
a206 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d211 1
a211 1
C *********************************************************************C **************************************************************************
d213 1
a213 10
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_DS. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
d215 3
d220 15
a234 12
         SUBROUTINE DSGR_SA(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,NUMR,
     &          MODE,ASK,OUTANG,SCRFILE,
     &          REFPAT,EXPPAT)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NLIST=8)
d236 1
a236 7
        INTEGER           NUMR(3,NRING)
	DOUBLE PRECISION  EAV
	DIMENSION         ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)

	CHARACTER (LEN=MAXNAM) :: FILNAM
        CHARACTER (LEN=*) ::      REFPAT,EXPPAT
        CHARACTER (LEN=*) ::      OUTANG,SCRFILE
d239 2
a240 2
        DIMENSION         BUFIN(LSAM)
	DIMENSION         WR(NRING)
d242 18
a259 108
	REAL, ALLOCATABLE, DIMENSION(:,:)  ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:)    ::  TOT,CIRC,CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TOTMIN,TT

#ifndef SP_32
        INTEGER *8       IASK8,IOK
#else
        INTEGER *4       IASK8,IOK
#endif

	CHARACTER(LEN=1) ::   MODE,ASK,NULL
	LOGICAL          ::   IN_CORE

	DATA  INPIC/77/,NDOC/55/,NSCF/50/

        NULL  = CHAR(0)

C       ZERO DLIST ARRAY
	DLIST = 0.0

C       FLAG TO OPEN OUTPUT DOC FILE ON FIRST CALL
        NRUN   = 0

        MAXRIN = NUMR(3,NRING)
	RANGE  = COS(RANGE*DGR_TO_RAD)

C       RINGWE RETURNS WR
	CALL RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H')  THEN
           WR    = WR*0.5
           DIVAS = 180.0
        ELSE
           DIVAS = 360.0
        ENDIF

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',MAXRIN+15)
           RETURN
        ENDIF
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'TT',1)
           RETURN
        ENDIF
#endif

	ALLOCATE(TOT(NIMA),TOTMIN(NIMA),X(NSAM,NROW),CIRC(LCIRC),
     &           CIROLD(LCIRC),SA(3,NIMA),LCG(NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
            MWANT = NSAM*NROW + 6*NIMA + 3*NIDI + 2*LCIRC
            CALL ERRT(46,'X...',MWANT)
            GOTO 9999
        ENDIF

	IN_CORE = .TRUE.

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          GWP - I HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
	       CALL  ERRT(46,'BFC',LCIRC)
	       GOTO 9999
	   ENDIF
           IN_CORE = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT (' --- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &               ' USING TEMPORARY FILE INSTEAD') 
#ifdef SP_MP
           WRITE(NOUT,*) '  SETTING OMP THREADS: 2'
           CALL SETTHREADS(2)
#endif
        ELSE

           IASK8 = (LCIRC * NIMA + NIMA * 6 + LCIRC * 2 + NSAM * NROW)*4
           CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

           WRITE(NOUT,91) LCIRC,NIMA
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), IN DSGR_P ') 
  	ENDIF

        CALL REG_GET_USED(NSEL_USED)

        LQ  = LROW/2+1
        LR1 = (NROW-1)/2
        LR2 = LQ+LR1
        LR1 = LQ-LR1
        LQ  = LSAM/2+1
        LS1 = (NSAM-1)/2
        LS2 = LQ+LS1
        LS1 = LQ-LS1


        CALL FLUSHRESULTS()

	IF (ASK .EQ. 'Y')  GOTO  7751

	IF (ASK.EQ.'W' .OR. .NOT.IN_CORE) THEN
C          OPEN(NSCF,FILE=SCRFILE,STATUS='UNKNOWN',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'U',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
a261 32
	DO   K1=1,NIMA
C          READ REFERENCE IMAGES
           NLET = 0
           CALL FILGET(REFPAT,FILNAM,NLET,ILIST(K1),INTFLAG)
	   MAXIM = 0
	   CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &                 LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999

	   DO K2=LR1,LR2
              CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	      DO K3=LS1,LS2
                 X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	      ENDDO
	   ENDDO

C          READ ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
           ITLOC = IAPLOC + 1
           CALL LUNGETVALS(INPIC,ITLOC,4,BUFIN,IRTFLG)
           IF (IRTFLG .NE. 0)   GOTO 9999

           IF (BUFIN(4) .LE. 0) THEN
	      CALL ERRT(102,'NO ANGLES IN REF. PROJECTION',K1)
	       GOTO 9999
           ENDIF
           SA(1,K1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,K1)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,K1)=COS(BUFIN(2)*DGR_TO_RAD)	

	   CLOSE(INPIC)

C          NORMALIZE UNDER THE MASK
d263 1
a263 14
     &                NUMR,NUMR(1,NRING))

	   CALL ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)

	   IF (ASK.EQ.'W'.OR..NOT.IN_CORE) WRITE(NSCF) CIRC
           IF (IN_CORE)  THEN
c$omp         parallel do private(i)
              DO I=1,LCIRC
                 BFC(I,K1) = CIRC(I)
              ENDDO
           ENDIF
	ENDDO
d265 1
a265 1
	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)
d267 1
a267 6
7751    CONTINUE
        IF (.NOT. IN_CORE .OR. ASK.EQ.'Y') THEN
          CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'O',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF
d269 1
a269 37
        IF (ASK .EQ. 'Y') THEN
            DO J=1,NIMA
               READ(NSCF) (BFC(I,J),I=1,LCIRC)
            ENDDO
            CLOSE(NSCF)
        ENDIF

        DO ITI=1,NIDI
C         READ EXPERIMENTAL IMAGES
          NLET = 0
          CALL FILGET(EXPPAT,FILNAM,NLET,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
          IF (IRTFLG .NE. 0)   GOTO 9999

          DO K2=LR1,LR2
             CALL REDLIN(INPIC,BUFIN,LSAM,K2)
             DO K3=LS1,LS2
                X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	     ENDDO
    	  ENDDO

C         READ THE ANGLES FOR ITI EXPERIMENTAL IMAGES
          CALL LUNGETVALS(INPIC,IAPLOC+1,4,BUFIN,IRTFLG)
          IF (IRTFLG .NE. 0)   GOTO 9999
	  CLOSE(INPIC)

          IF (BUFIN(4) .LE. 0) THEN
	     CALL ERRT(102,'NO ANGLES IN EXP. IMAGE',ITI)
	      GOTO 9999
          ENDIF

C         CONVERT TO UNITARY DIRECTIONAL VECTORS.
          TA(1) = COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2) = SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3) = COS(BUFIN(2)*DGR_TO_RAD)
d271 21
a291 15
C         NORMALIZE UNDER THE MASK
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))
	  CALL ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
	  CALL FRNG(CIROLD,LCIRC,NUMR,NRING)

C         DETERMINE WHICH ONES ARE TO BE COMPARED
	  NIMALCG = 0
          DO IMI=1,NIMA
C             ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                   (- DO NOT CHECK MIRRORED)
              DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	      IF (DT.GE.RANGE)  THEN
	         NIMALCG      = NIMALCG+1
	         LCG(NIMALCG) = IMI
d293 15
a307 48
	         TOTMIN(IMI)  = -1.0D20
	      ENDIF
	  ENDDO
          EAV = -1.0D20
	  IF (NIMALCG.GT.0)  THEN
             IF (IN_CORE)  THEN
c$omp           parallel do private(imil,imi)
                DO IMIL=1,NIMALCG
	           IMI=LCG(IMIL)
	           CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ENDDO
             ELSE
             REWIND  NSCF
             DO IMI=1,NIMA
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT
C                    (- DO NOT CHECK MIRRORED)
                DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	        IF (DT.GE.RANGE)  THEN
                   READ(NSCF)  CIRC
                   CALL CROSRNG_DS(CIRC,CIROLD,LCIRC,NRING,
     &	                  MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ELSE
                   READ(NSCF)
	           TOTMIN(IMI) = -1.0D20
	        ENDIF
	     ENDDO
          ENDIF

          DO IMI=1,NIMA
             IF (TOTMIN(IMI) .GE. EAV)  THEN
                EAV  = TOTMIN(IMI)
                IDI  = ILIST(IMI)
                RANG = TOT(IMI)
	     ENDIF
	  ENDDO

          DLIST(2) = IDI
          DLIST(3) = EAV
          RANG     = (RANG-1)/MAXRIN*DIVAS
          DLIST(4) = RANG
C         DLIST 5&6 ARE PERMANENTLY SET TO ZERO (THIS KEEPS THE
C         SAME FORMAT AS 'AP MQ' OPERATION)
	 ELSE
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REFERENCE PROJECTIONS	
            DLIST(2) = 0.0
            DLIST(3) = -1.0
            DLIST(4) = 0.0
d310 1
a310 29
         DLIST(1) = ITI
         DLIST(7) = ILIP(ITI)

         IF (NSEL_USED .GT. 0) THEN
C           OUTPUT TO REGISTER NOT TO DOC FILE
            CALL REG_SET_NSEL(1,5,DLIST(2),DLIST(3),DLIST(4),
     &                       DLIST(5),DLIST(6),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(7),DLIST(8),0.0,0.0,0.0,IRTFLG)

          ELSE
C           OUTPUT TO DOC FILE
            CALL SAVDN1(NDOC,OUTANG,DLIST,NLIST, NRUN,0)
            NRUN = 1
         ENDIF
      ENDDO
      CALL SAVDC
      CLOSE(NDOC)


      IF (.NOT.IN_CORE) CLOSE(NSCF)

9999  IF(ALLOCATED(BFC))    DEALLOCATE(BFC)
      IF(ALLOCATED(LCG))    DEALLOCATE(LCG)
      IF(ALLOCATED(SA))     DEALLOCATE(SA)
      IF(ALLOCATED(CIRC))   DEALLOCATE(CIRC)
      IF(ALLOCATED(X))      DEALLOCATE(X)
      IF(ALLOCATED(TOTMIN)) DEALLOCATE(TOTMIN)
      IF(ALLOCATED(TOT))    DEALLOCATE(TOT)
      IF(ALLOCATED(TT))     DEALLOCATE(TT)
a313 77

C++************************************************************************
C
C    DSGR2D.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C--************************************************************************

	SUBROUTINE  DSGR2D(X,NSAM,NROW,NUMR,NRING,MODE,MAXRIN,
     &		BFC,LCIRC,NIMA,TT,SA,TA,RANGE,
     &		DLIST2,DLIST3,RANG)

	CHARACTER*1      MODE
	DOUBLE PRECISION EAV,TOTMIN
        INTEGER          NUMR(3,NRING)
	DIMENSION X(NSAM,NROW),BFC(LCIRC,NIMA),SA(3,NIMA),TA(3)
	REAL, ALLOCATABLE, DIMENSION(:)    ::  CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG

	ALLOCATE(CIROLD(LCIRC),LCG(NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, CIRCOLD,LCG',IER)

C       DETERMINE WHICH ONES ARE TO BE COMPARED
	NIMALCG = 0
        DO IMI=1,NIMA
C          ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                (- DO NOT CHECK MIRRORED)
           DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	   IF (DT .GE. RANGE)  THEN
	      NIMALCG      = NIMALCG+1
	      LCG(NIMALCG) = IMI
	   ENDIF
	ENDDO

	IF (NIMALCG.GT.0) THEN
	   CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                  NUMR,NUMR(1,NRING))
	   CALL ALRQS(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE)
	   CALL FRNGS(CIROLD,LCIRC,NUMR,NRING)
           EAV = -1.0D20
           DO IMIL=1,NIMALCG
	      IMI = LCG(IMIL)
	      CALL  CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                       MAXRIN,NUMR,TOTMIN,TOT,TT)
              IF (TOTMIN .GE. EAV)  THEN
                 EAV  = TOTMIN
                 IDI  = IMI
                 RANG = TOT
	      ENDIF
	   ENDDO

	   IF (MODE.EQ.'F')  THEN
              RANG = (RANG-1.0)/MAXRIN*360.0
           ELSE
              RANG = (RANG-1.0)/MAXRIN*180.0
	   ENDIF
	   DLIST2 = IDI
	   DLIST3 = EAV
	ELSE
           RANG   = 0.0
	   DLIST2 = 0.0
	   DLIST3 = -1.0
	ENDIF

	DEALLOCATE(LCG)
	DEALLOCATE(CIROLD)

	END
@


1.42
log
@error msg for unfound angles wrong
@
text
@d1 1
a1 200

C++************************************************************************
C
C DSGR.F            'AP RN'
C                   CAN OUTPUT TO REGISTERS NOW   MAY 01 ARDEAN LEITH
C                   CAN GET ANGLES FROM HEADER    JUN 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C                   SAVDN1 + SAVD BUG             JAN 02 ArDean Leith
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   UNSAV LOOP IMPROVED           SEP 02 ARDEAN LEITH
C                   ADDED ANG. DIFFERENCE         OCT 02 ARDEAN LEITH
C                   OPFILEC                       FEB  03 ARDEAN LEITH
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C    DSGR(MODE)                                 10/21/99
C
C    DISTANCES BETWEEN PROJECTIONS.
C    BUFFER ON THE DISK IN THE 'SCRATCH.FILE'
C    SWITCHES BETWEEN "IN CORE" AND "ON DISK" VERSION,
C    SCRATCH.FILE PRODUCED IN EITHER CASE ...
C    RESTRICTED ANGULAR SEARCH RANGE.
C    DO NOT CHECK MIRRORED ORIENTATIONS..
C
C--************************************************************************

         SUBROUTINE DSGR(MODE)

	 PARAMETER  (NILMAX=99998)

         INCLUDE 'CMLIMIT.INC'
         INCLUDE 'CMBLOCK.INC'

         CHARACTER*80      FIPROJ,FINPAT,FINPIC,REFANG,EXPANG
         COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP

	 INTEGER, ALLOCATABLE, DIMENSION(:,:) ::  NUMR
	 INTEGER, ALLOCATABLE, DIMENSION(:)   ::  ILIST,ILIP
         CHARACTER (LEN=MAXNAM) ::  ASK,SCRFILE,OUTANG
         CHARACTER(LEN=1)    ::     MODE,NULL
	 LOGICAL      ::            SUCCESS

         DATA  INPIC/77/

         NULL = CHAR(0)

	 ALLOCATE(ILIST(NILMAX),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, ILIST',IER)
            RETURN
         ENDIF 

C       ASK FOR DATA FILE
	CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NIMA,
     &     'ENTER TEMPLATE FOR 2-D REFERENCE IMAGES',IRTFLG)
	IF (IRTFLG .NE. 0) GOTO 9999

C       NIMA - TOTAL NUMBER OF IMAGES
        IF (NIMA .GT. 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT('  Number of reference images: ',I7)
        ELSE
           CALL ERRT(101,'No reference images!',IDUM)
           GOTO 9999
        ENDIF

C       GET FIRST REFERENCE IMAGE TO DETERMINE DIMS
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999
        CLOSE(INPIC)

        CALL RDPRMI(MR,NR,NOT_USED,'FIRST AND LAST RING')

	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	   CALL ERRT(31,'AP RN',NE)
	   GOTO 9999
	ENDIF

        CALL  RDPRMI(ISKIP,NDUMP,NOT_USED,'SKIP')
        ISKIP = MAX0(1,ISKIP)
        CALL  FILERD(REFANG,NREFA,NULL,
     &		'REFERENCE IMAGES ANGLES DOCUMENT',IRTFLG)
C        FILERD WILL RETURN IRTFLG=1 IF "*"

C        ACCEPT EXTENSION IF FILE IS NAMED
         IRTFLG = 9
         CALL FILERD(ASK,NA,NULL,
     &         'SCRATCH FILE EXISTS (Y/N/W/NAME)?~',IRTFLG)
         IF (IRTFLG .NE. 0)  THEN
             CALL ERRT(101,'FILE NAME NOT ENTERED',NE)
             GOTO 9999
         ENDIF

         SCRFILE = 'scratch.file'
         IF (NA .GT. 1) THEN
            SCRFILE = ASK
            ASK     = 'N'
         ENDIF

         NRING=0
         DO I=MR,NR,ISKIP
            NRING = NRING+1
	 ENDDO

	 ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, NUMR',IER)
            GOTO 9999
         ENDIF

         NRING = 0
         DO I=MR,NR,ISKIP
            NRING = NRING+1
            NUMR(1,NRING) = I
	 ENDDO

C        CALCULATION OF ACTUAL DIMENSION OF AN IMAGE TO BE INTERPOLATED
C        2*(NO.OF RINGS)+(0'TH ELEMENT)+2*(MARGIN OF 1)

         NRA  = MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1,2*NR+3)
         LSAM = NSAM
         LROW = NROW
         NSAM = NRA
         NROW = NRA
         CALL ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN = NUMR(3,NRING)

	 ALLOCATE(ILIP(NILMAX),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, ILIP',IER)
            GOTO 9999
         ENDIF

C        IMAGES TO BE ALIGNED
	 CALL FILELIST(.TRUE.,INPIC,FIPROJ,NLEP,ILIP,NILMAX,NIDI,
     &     'ENTER TEMPLATE FOR IMAGE SERIES TO BE ALIGNED',IRTFLG)
	 IF (IRTFLG .NE. 0) GOTO 9999

         WRITE(NOUT,2002) NIDI
2002     FORMAT('  Number of experimental images: ',I6)

         CALL  FILERD(EXPANG,NEXPA,NULL,
     &		'EXPERIMENTAL IMAGES ANGLES DOCUMENT',IRTFLG)

	 CALL  RDPRM(RANGE,NOT_USED,'RANGE OF ANGULAR SEARCH')
C        NIDI - NUMBER OF EXPERIMENTAL IMAGES 

C        FIND NUMBER OF OMP THREADS
         CALL GETTHREADS(NUMTH)

         CALL REG_GET_USED(NSEL_USED)

         IF (NSEL_USED .LE. 0) THEN
            CALL  FILERD(OUTANG,NOUTANG,NULL,
     &		        'OUTPUT ANGLES DOCUMENT',IRTFLG)
         ENDIF

         IF (REFANG(1:1) .EQ. '*') THEN
C           'SMALLANGLE' MODIFICATIONS WITH INLINE ANGLES

            CALL DSGR_SA(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,OUTANG,SCRFILE)
         ELSE

            SUCCESS = .FALSE.
	    IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
               CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &            NSAM,NROW,LSAM,LROW,RANGE,
     &            NRING,LCIRC,MAXRIN,NUMR,
     &            MODE,NUMTH,REFANG,EXPANG,OUTANG,SUCCESS)
	    ENDIF

	    IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &         NSAM,NROW,LSAM,LROW,RANGE,
     &         NRING,LCIRC,MAXRIN,NUMR,
     &         MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)
         ENDIF

9999     IF (ALLOCATED(ILIP))  DEALLOCATE(ILIP)
	 IF (ALLOCATED(NUMR))  DEALLOCATE(NUMR)
	 IF (ALLOCATED(ILIST)) DEALLOCATE(ILIST)

         WRITE (NOUT,2600)
2600     FORMAT (/ ' ',72('-')//,
     &             ' ','END OF COMPUTATION',//,
     &             ' ',72('-')/)
         END

d29 5
a33 4
        SUBROUTINE  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,MODE,NUMTH,
     &          REFANG,EXPANG,OUTANG,SUCCESS)
d40 12
a51 7
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        INTEGER           NUMR(3,NRING)
	DIMENSION         ILIST(NIMA),ILIP(NIDI)
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
        CHARACTER (LEN=MAXNAM) ::  OUTANG
        CHARACTER*1       MODE
a56 3
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  X
	REAL, ALLOCATABLE, DIMENSION(:,:) ::   BFC,DLIST,SA,TA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT
d59 7
d68 11
a78 3
	RANGE = COS(RANGE*DGR_TO_RAD)
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE.EQ.'H')  WR=WR*0.5
d82 4
a85 1
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
d89 4
a92 1
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
a93 2
	ALLOCATE(DLIST(NLIST,NUMTH),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, DLIST',IER)
d95 8
d105 1
a108 3
	ALLOCATE(X(NSAM,NROW,NUMTH),SA(3,NIMA),TA(3,NIDI),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP MD, X',IER)

d116 1
a116 1
     &               ' WILL TRY DSGR_P NOW ') 
d138 3
a140 1
C       READ THE ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
d146 1
a146 1
              RETURN
d160 1
a160 1
              RETURN
d170 2
a171 2

              CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
d173 1
a173 1
	      CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d175 1
a175 1
              IF (IRTFLG .NE. 0)  RETURN
d202 2
a203 1
             CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d205 1
a205 1
	     CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d207 1
a207 1
             IF (IRTFLG .NE. 0)  RETURN
a264 1
       DEALLOCATE(BFC)
d266 6
a271 5
9999   DEALLOCATE(TA)
       DEALLOCATE(SA)
       DEALLOCATE(X)
       DEALLOCATE(DLIST)
       DEALLOCATE(TT)
d276 1
d306 3
a308 2
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)
d316 6
a321 6
        INTEGER           NUMR(3,NRING)
	DOUBLE PRECISION  EAV
	DIMENSION         ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG,SCRFILE
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
        CHARACTER (LEN=MAXNAM) ::  OUTANG
d331 1
d351 2
a352 1
	RANGE = COS(RANGE*DGR_TO_RAD)
d354 2
a355 1
	CALL RINGWE(WR,NUMR,NRING,MAXRIN)
d357 2
a358 2
           WR    = WR*0.5
           DIVAS = 180.0
d360 1
a360 1
           DIVAS = 360.0
d362 1
d366 1
a366 1
           CALL  ERRT(46,'AP RN, TT',IER)
d373 1
a373 1
           CALL  ERRT(46,'AP RN, TT',IER)
d377 2
a378 1
	ALLOCATE(TOT(NIMA),TOTMIN(NIMA),X(NSAM,NROW),CIRC(LCIRC),
d381 3
a383 2
           CALL  ERRT(46,'AP RN, TOT,....',IER)
           RETURN
d395 1
a395 1
	      RETURN
d401 4
d414 2
a426 3
#ifdef SP_MP
        IF (.NOT.IN_CORE) CALL SETTHREADS(2)
#endif
d433 1
a433 1
              RETURN
d447 1
a447 1
           IF (IRTFLG .NE. 0)  RETURN
d452 2
a453 1
           CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
d455 1
a455 1
	   CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d457 1
a457 1
           IF (IRTFLG .NE. 0) RETURN
d490 1
a490 1
           IF (IRTFLG .NE. 0)  RETURN
d502 2
a503 1
          CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d505 1
a505 1
	  CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d507 1
a507 1
          IF (IRTFLG .NE. 0)  RETURN
d522 1
a522 1
              RETURN
d618 1
a618 5
#ifdef SP_MP
      IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
#endif

      IF (.NOT.IN_CORE)  CLOSE(NSCF)
d632 1
d661 3
a663 2
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,OUTANG,SCRFILE)
d675 4
a678 3
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,SCRFILE
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
        CHARACTER (LEN=MAXNAM) ::  OUTANG
d687 2
a688 1
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TT,TOTMIN
d706 1
a706 1
        NRUN  = 0
d708 2
a709 1
	RANGE = COS(RANGE*DGR_TO_RAD)
d711 1
d723 1
a723 1
           CALL  ERRT(46,'AP RN, TT',IER)
d730 1
a730 1
           CALL  ERRT(46,'AP RN, TT',IER)
d734 1
d738 3
a740 2
           CALL  ERRT(46,'AP RN, TOT,....',IER)
           RETURN
d751 2
a752 2
	      CALL  ERRT(46,'AP RN, BFC',IER)
	      RETURN
d758 4
d782 2
a783 4
#ifdef SP_MP
        IF (.NOT.IN_CORE) WRITE(NOUT,*) ' SETTING OMP THREADS: 2'
        IF (.NOT.IN_CORE) CALL SETTHREADS(2)
#endif
d791 1
a791 1
           IF (IRTFLG .NE. 0) RETURN
d796 2
a797 1
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
d799 1
a799 1
	   CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d801 1
a801 1
           IF (IRTFLG .NE. 0) RETURN
d813 1
a813 1
           IF (IRTFLG .NE. 0)  RETURN
d817 1
a817 1
	      RETURN
d848 1
a848 1
           IF (IRTFLG .NE. 0) RETURN
d860 2
a861 1
          CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d863 1
a863 1
	  CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
d865 1
a865 1
          IF (IRTFLG .NE. 0)  RETURN
d876 1
a876 1
          IF (IRTFLG .NE. 0)  RETURN
d881 1
a881 1
	     RETURN
a972 3
#ifdef SP_MP
      IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
#endif
d975 9
a983 9
      DEALLOCATE(BFC)
      DEALLOCATE(LCG)
      DEALLOCATE(SA)
      DEALLOCATE(CIROLD)
      DEALLOCATE(CIRC)
      DEALLOCATE(X)
      DEALLOCATE(TOTMIN)
      DEALLOCATE(TOT)
      DEALLOCATE(TT)
@


1.41
log
@opfilec
@
text
@d149 2
a150 2
        WRITE(NOUT,2002) NIDI
2002    FORMAT('  Number of experimental images: ',I6)
d308 1
d317 1
a317 1
          SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
d323 1
a323 1
C       READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
d328 1
a328 1
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',IMI)
d369 1
d471 1
a471 1
         SUBROUTINE  DSGR_P(ILIST,NIMA,ILIP,NIDI,
d608 1
d657 1
d672 1
a672 1
C         READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
d676 1
a676 1
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',IMI)
@


1.40
log
@register returns changed
@
text
@d12 1
d77 1
a77 1
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d341 1
a341 1
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d371 1
a371 1
	     CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d608 1
a608 1
	   CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d656 1
a656 1
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d943 1
a943 1
	   CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d1006 1
a1006 1
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
@


1.39
log
@added angular change to output file
@
text
@d415 4
a418 4
                CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2,IT),
     &              DLIST(3,IT),DLIST(4,IT),DLIST(5,IT),IRTFLG)
                CALL REG_SET_NSEL(6,3,DLIST(6,IT),
     &              DLIST(7,IT),DLIST(8,IT),0.0,0.0,IRTFLG)
d733 1
a733 1
          RANG     = (RANG-1)/MAXRIN*DIVAS
d754 3
a756 4
            CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2),
     &                  DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,3,DLIST(6),DLIST(7),DLIST(8),
     &                  0.0,0.0,IRTFLG)
d763 1
d1102 3
a1104 4
            CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2),
     &          DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,3,DLIST(6),DLIST(7),DLIST(8),
     &          0.0,0.0,IRTFLG)
@


1.38
log
@nloop,iloop_removed
@
text
@d4 1
a4 1
C DSGR.F
d10 2
d15 1
a15 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d67 1
a67 1
2001       FORMAT(' Number of reference images: ',I6)
d149 1
a149 1
2002    FORMAT(' Number of experimental images: ',I6)
d235 1
a235 1
        PARAMETER (NLIST=7)
a307 2
        K2A  = 1
        LERR = -1
d309 5
a313 13
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
           IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,
     &                      3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL ERRT(102,'REF. PROJECTION ANGLE NOT FOUND',
     &                      ILIST(IMI))
                 RETURN
              ENDIF
              K2A=1
d315 1
a315 1
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
a321 3
        K2A  = 1
        LERR = -1

d323 5
a327 12
	   CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	   IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL  ERRT(102,
     &                'EXPER. PROJECTION ANGLE NOT FOUND',ILIP(ITI))
                 RETURN
              ENDIF
              K2A=1
d398 12
a409 3
             DLIST(1,ITI-ITIT+1)=ITI
             IF (DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &           ILIST(INT(DLIST(2,ITI-ITIT+1)))
d411 1
d417 2
a418 2
                CALL REG_SET_NSEL(6,2,DLIST(6,IT),
     &              DLIST(7,IT),0.0,0.0,0.0,IRTFLG)
d478 1
a478 1
        PARAMETER  (NLIST=7)
d509 1
a581 2
	K2A=1
        LERR = -1
d583 6
a588 14
	   CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
           IF (LERR .NE. 0) THEN
                LERR = -1
		K2A  = 0
                CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,
     &                      LERR,K2A)
                IF (LERR .NE. 0) THEN
		   CLOSE(INANG)
	           CALL  ERRT(100,
     &             'ANGLE FOR REFERENCE PROJECTION NOT FOUND',NE)
		   RETURN
		ENDIF
		K2A = 1
            ENDIF
d628 1
a628 1
           IF (IN_CORE)  THEN
d647 1
a647 1
               READ(NSCF)  (BFC(I,J),I=1,LCIRC)
d668 6
a673 13
	  CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
          IF (LERR .NE. 0) THEN
             LERR = -1
             K2A  = 0
             CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
             IF (LERR .NE. 0) THEN
		CLOSE(INANG)
	        CALL  ERRT(100,
     &               'ANGLE FOR EXPERIMENTAL PROJECTION NOT FOUND',NE)
		RETURN
	     ENDIF
             K2A = 1
          ENDIF
d690 1
a690 1
	      IF (DT.GE.RANGE)  THEN
d697 4
a700 4
          EAV=-1.0D20
	  IF (NIMALCG.GT.0)  THEN
             IF (IN_CORE)  THEN
c$omp parallel do private(imil,imi)
d702 1
a702 1
	           IMI=LCG(IMIL)
d712 1
a712 1
	        IF (DT.GE.RANGE)  THEN
d715 1
a715 1
     &	                  MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
d735 6
a740 2
C         DLIST 5&6 ARE PERMANENTLY SET TO ZERO (THIS IS TO KEEP 
C         SAME FORMAT AS 'AP MQ' COMMAND)
d742 1
a742 1
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REFERENCE PROJECTIONS	
d746 1
d755 3
a757 2
     &          DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(6),DLIST(7),0.0,0.0,0.0,IRTFLG)
d822 1
a822 1
        PARAMETER (NLIST=7)
d1104 2
a1105 1
            CALL REG_SET_NSEL(6,2,DLIST(6),DLIST(7),0.0,0.0,0.0,IRTFLG)
d1182 1
a1182 1
           DO   IMIL=1,NIMALCG
@


1.37
log
@prompts
@
text
@d79 1
a79 1
        CALL RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
d86 1
a86 1
        CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
d152 1
a152 1
	 CALL  RDPRM(RANGE,NLOOP,ILOOP,'RANGE OF ANGULAR SEARCH')
@


1.36
log
@outang savd & savdn1 both used bug fixed
@
text
@d9 1
d89 1
a89 1
     &		'REFERENCE PROJECTIONS ANGLES DOCUMENT',IRTFLG)
d143 1
a143 1
     &      'ENTER TEMPLATE FOR 2-D EXPERIMENTAL PROJECTIONS',IRTFLG)
d147 1
a147 1
2002    FORMAT(' Number of experimental projections: ',I6)
d150 1
a150 1
     &		'EXPERIMENTAL PROJECTIONS ANGLES DOCUMENT',IRTFLG)
@


1.35
log
@bad refang on 2nd expang unsav fixed
@
text
@d8 1
a776 1
            CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
a1124 1
            CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
@


1.34
log
@normass --> normas
@
text
@d687 1
a687 1
             CALL  UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
@


1.33
log
@iaploc  usage changed
@
text
@d7 1
d57 1
a57 1
     &     'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS',IRTFLG)
d61 6
a66 3
        IF (NIMA .LE. 0)  THEN
            CALL ERRT(101,'NO IMAGES!',IDUM)
            GOTO 9999
d69 1
a69 3
        WRITE(NOUT,2001) NIMA
2001    FORMAT(' NUMBER OF IMAGES =',I6)

a74 1

d90 9
a98 2
       	 CALL RDPRMC(ASK,NA,.TRUE.,
     &               'SCRATCH FILE EXISTS (Y/N/W/NAME)?',NULL,IRT)
d141 1
a141 1
     &   'ENTER TEMPLATE FOR 2-D EXPERIMENTAL PROJECTIONS NAME',IRTFLG)
d144 3
d191 3
a193 1
2600     FORMAT (/,' ',27('-'),'END OF COMPUTATION',25('-')/)
d372 1
a372 1
	    CALL NORMASS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
d1194 1
a1194 1
	   CALL NORMASS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
@


1.32
log
@activated dsgr_sa inline header angle code
@
text
@d929 1
d958 2
a959 1
           CALL LUNGETVALS(INPIC,IAPLOC+1,3,BUFIN,IRTFLG)
@


1.31
log
@typo
@
text
@d87 1
d147 7
a153 6
         IF (NSEL_USED .GT. 0) THEN
C           'SMALLANGLE' MODIFICATIONS
	    CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &         NSAM,NROW,LSAM,LROW,RANGE,
     &         NRING,LCIRC,MAXRIN,NUMR,
     &         MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)
d155 4
a159 3

            CALL  FILERD(OUTANG,NOUTANG,NULL,
     &		'OUTPUT ANGLES DOCUMENT',IRTFLG)
@


1.30
log
@angles in header in dsgr_sa routine added
@
text
@d15 1
a15 1
C *********************************************************************C **************************************************************************
@


1.29
log
@added register output (usefull for AP RN with smallangles)
@
text
@d6 1
d8 8
a15 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
d40 1
a40 1
         CHARACTER (LEN=MAXNAM) ::  ASK,SCRFILE
d137 1
d139 1
a139 1
C        NIDI - NUMBER OF IMAGES TO CHECK DISTANCES
d143 22
a164 9
 
	 IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
            CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,NUMTH,NOUT,REFANG,EXPANG,SUCCESS)
	 ELSE
	    SUCCESS = .FALSE.
	 ENDIF
d166 1
a166 1
	 IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
d169 2
a170 1
     &         MODE,ASK,NUMTH,NOUT,REFANG,EXPANG,SCRFILE)
d210 1
a210 1
     &          NOUT,REFANG,EXPANG,SUCCESS)
d212 3
d222 1
d227 2
a231 1
	DIMENSION  WR(NRING)
d253 2
d411 3
a413 1
                CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
d461 4
a464 1
     &          MODE,ASK,NUMTH,NOUT,REFANG,EXPANG,SCRFILE)
d474 1
d496 2
d499 3
d553 1
a553 1
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), ') 
d761 2
d786 345
@


1.28
log
@SP_32 for NT
@
text
@d5 1
d162 1
a162 3
2600     FORMAT (/ ' ',72('-'),//,
     &             ' ', 'END OF COMPUTATION',//,
     &             ' ',72('-')/)
d255 2
d380 11
a390 1
             CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
d523 2
d719 10
a728 1
         CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
@


1.27
log
@allocation checks added
@
text
@d445 5
a449 1
	INTEGER * 8      :: IASK8,IOK
@


1.26
log
@typo '
@
text
@a4 1
C  needs improved error handling especially for deallocation on error!!
d31 1
d39 3
a41 3
         CHARACTER*80      ASK,SCRFILE
         CHARACTER*1       MODE,NULL
	 LOGICAL           SUCCESS
d129 2
a130 2
C       IMAGES TO BE ALIGNED
	CALL FILELIST(.TRUE.,INPIC,FIPROJ,NLEP,ILIP,NILMAX,NIDI,
d132 1
a132 1
	IF (IRTFLG .NE. 0) GOTO 9999
d141 3
a143 3

	IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
           CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d147 3
a149 3
	ELSE
	   SUCCESS = .FALSE.
	ENDIF
d151 1
a151 1
	IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
d249 3
d253 2
d297 1
a297 1
              CALL UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
d445 1
d447 2
a448 2
	CHARACTER*1  MODE,ASK,NULL
	LOGICAL      IN_CORE
d485 1
d500 4
@


1.25
log
@cosmetic & better msgs. about alloc progress
@
text
@d271 1
a271 1
                 CALL ERRT(102,REF. PROJECTION ANGLE NOT FOUND',
@


1.24
log
@named scratch file, and used opauxfile & cosmetic
@
text
@d60 1
a60 1
            CALL ERRT(101,'NO IMAGES !',IDUM)
d142 1
a142 1
	IF (NUMTH.GT.1.AND.NIDI.GT.NUMTH.AND.ASK.EQ.'N')  THEN
d151 1
a151 1
	IF (.NOT.SUCCESS) CALL  DSGR_P(ILIST,NIMA,ILIP,NIDI,
d161 1
a161 1
2600     FORMAT (/ ' ',80('-'),//,
d163 1
a163 1
     &             ' ',80('-')/)
d166 223
d390 1
d405 10
a414 10
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
d426 1
a426 1
        INTEGER  NUMR(3,NRING)
d428 1
a428 1
	DIMENSION  ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
d433 2
a434 2
        DIMENSION  BUFIN(LSAM)
	DIMENSION  WR(NRING)
d450 1
a450 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
d481 1
a481 1
C          GWP - I HAVE TO FIX THE ALLOCATION HERE
d489 7
a495 1
	ENDIF
d516 1
a516 1
		K2A=0
d525 1
a525 1
		K2A=1
d561 3
a563 3
	   CALL  ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL  FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL  APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
d567 1
a567 1
c$omp parallel do private(i)
d569 1
a569 1
                 BFC(I,K1)=CIRC(I)
d619 3
a621 3
          TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
d626 2
a627 2
	  CALL  ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
	  CALL  FRNG(CIROLD,LCIRC,NUMR,NRING)
d630 1
a630 1
	  NIMALCG=0
d634 1
a634 1
              DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
d636 2
a637 2
	         NIMALCG=NIMALCG+1
	         LCG(NIMALCG)=IMI
d639 1
a639 1
	         TOTMIN(IMI)=-1.0D20
d646 1
a646 1
                DO   IMIL=1,NIMALCG
d653 1
a653 1
             DO    IMI=1,NIMA
d668 1
a668 1
          DO   IMI=1,NIMA
d689 2
a690 2
         DLIST(1)=ITI
         DLIST(7)=ILIP(ITI)
a714 214
C++************************************************************************
C
C    DSGR_PM.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C--************************************************************************

        SUBROUTINE  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,MODE,NUMTH,
     &          NOUT,REFANG,EXPANG,SUCCESS)

C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C

        PARAMETER  (NLIST=7)
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        INTEGER  NUMR(3,NRING)
	DIMENSION  ILIST(NIMA),ILIP(NIDI)
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
	CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
        CHARACTER*1  MODE
C       AUTOMATIC ARRAYS
        DIMENSION  BUFIN(LSAM)
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  X
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  BFC,DLIST,SA,TA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT
	DIMENSION  WR(NRING)

	LOGICAL  SUCCESS
	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

	RANGE=COS(RANGE*DGR_TO_RAD)
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE.EQ.'H')  WR=WR*0.5

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
#endif
	ALLOCATE(DLIST(NLIST,NUMTH),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, DLIST',IER)

C       ZERO DLIST ARRAY
	DLIST = 0.0

	ALLOCATE(X(NSAM,NROW,NUMTH),SA(3,NIMA),TA(3,NIDI),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP MD, X',IER)

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG.EQ.0) THEN
	   SUCCESS = .TRUE.

           LQ=LROW/2+1
           LR1=(NROW-1)/2
           LR2=LQ+LR1
           LR1=LQ-LR1
           LQ=LSAM/2+1
           LS1=(NSAM-1)/2
           LS2=LQ+LS1
           LS1=LQ-LS1
C          READ THE ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
	   K2A=1
           LERR = -1
	   DO  IMI=1,NIMA
	     CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	     IF (LERR .NE. 0) THEN
                LERR = -1
		K2A  = 0
                CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,
     &                      3,LERR,K2A)
                IF (LERR .NE. 0) THEN
		   CLOSE(INANG)
	           CALL ERRT(100,
     &                'ANGLE FOR REFERENCE PROJECTION NOT FOUND',NE)
		   RETURN
                ENDIF
                K2A=1
            ENDIF
            SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
            SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
            SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
	ENDDO
	CLOSE(INANG)

C       READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
	K2A  = 1
        LERR = -1
	DO  ITI=1,NIDI
	   CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	   IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL  ERRT(100,
     &                'ANGLE FOR EXPERIMENTAL PROJECTION NOT FOUND',NE)
                 RETURN
              ENDIF
              K2A=1
           ENDIF
           TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
	ENDDO
	CLOSE(INANG)

	DO ITIT=1,NIMA,NUMTH
	   DO K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)

              CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN

	      DO K2=LR1,LR2
                 CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	         DO K3=LS1,LS2
                    X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
	         ENDDO
	      ENDDO
	      CLOSE(INPIC)
	  ENDDO

C         NORMALIZE UNDER THE MASK
c$omp parallel do private(K1)
	  DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
	  CALL NORMASS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                 NUMR,NUMR(1,NRING))

	  CALL ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
     &		BFC(1,K1),LCIRC,NRING,MODE)
	  CALL FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	  CALL APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
	  ENDDO
       ENDDO

       DO ITIT=1,NIDI,NUMTH
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	     MAXIM = 0
	     CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
             IF (IRTFLG .NE. 0)  RETURN

             DO K2=LR1,LR2
                CALL REDLIN(INPIC,BUFIN,LSAM,K2)
                   DO K3=LS1,LS2
                     X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1) = BUFIN(K3)
	           ENDDO
    	        ENDDO
	        CLOSE(INPIC)
	     ENDDO

C            NORMALIZE UNDER THE MASK
c$omp parallel do private(ITI)
	     DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
	        CALL DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,
     &             MODE,MAXRIN,BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	           DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),
     &             DLIST(4,ITI-ITIT+1))
	     ENDDO

C            DLIST(2) = IDI
C            DLIST(3) = EAV
C            DLIST(4) = ANGMOR(RANG,MODE)
C            DLIST 5&6  PERMANENTLY SET TO ZERO (KEEP SAME FORMAT AS
C            AP MQ COMMAND)
             DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
                DLIST(1,ITI-ITIT+1)=ITI
                IF (DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &             ILIST(INT(DLIST(2,ITI-ITIT+1)))
                DLIST(7,ITI-ITIT+1) = ILIP(ITI)
                CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
	     ENDDO
	  ENDDO
          CALL  SAVDC
          CLOSE(NDOC)
	  DEALLOCATE(BFC)
       ELSE
          SUCCESS=.FALSE.
       ENDIF

       DEALLOCATE(TA)
       DEALLOCATE(SA)
       DEALLOCATE(X)
       DEALLOCATE(DLIST)
       DEALLOCATE(TT)
       END
@


1.23
log
@error trapping on alloc & much cosmetic
@
text
@d38 4
a41 3
	 INTEGER, ALLOCATABLE, DIMENSION(:) ::  ILIST,ILIP
         CHARACTER*1  MODE,ASK,NULL
	 LOGICAL      SUCCESS
d55 1
a55 1
     &     'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS NAME',IRTFLG)
d87 7
a93 2
      	CALL RDPRMC(ASK,NA,.TRUE.,
     &	   'SCRATCH FILE EXISTS (Y/N/W)?',NULL,IRT)
d97 1
a97 1
            NRING=NRING+1
d106 1
a106 1
         NRING=0
d108 2
a109 2
            NRING=NRING+1
            NUMR(1,NRING)=I
d115 5
a119 5
         NRA=MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1,2*NR+3)
         LSAM=NSAM
         LROW=NROW
         NSAM=NRA
         NROW=NRA
d154 1
a154 1
     &         MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
d191 1
a191 1

d197 1
a197 1
     &          MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
d205 1
a205 1
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
d217 1
a217 1
	CHARACTER*1  MODE,ASK
d222 1
d228 2
a229 2
           WR=WR*0.5
           DIVAS=180.0
d231 1
a231 1
           DIVAS=360.0
d235 4
a238 1
	IF (IRTFLG .NE. 0) CALL  ERRT(46,'AP RN, TT',IER)
d242 4
a245 1
	IF (IRTFLG .NE. 0) CALL  ERRT(46,'AP RN, TT',IER)
d267 8
a274 8
        LQ=LROW/2+1
        LR1=(NROW-1)/2
        LR2=LQ+LR1
        LR1=LQ-LR1
        LQ=LSAM/2+1
        LS1=(NSAM-1)/2
        LS2=LQ+LS1
        LS1=LQ-LS1
d305 6
a310 2
	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) OPEN(NSCF,FILE='scratch.file',
     &     STATUS='UNKNOWN',FORM='UNFORMATTED')
d317 1
a317 1
           IF (IRTFLG .NE. 0)  RETURN
d346 7
a352 3
        IF (.NOT.IN_CORE .OR. ASK.EQ.'Y')
     &         OPEN(NSCF,FILE='scratch.file',
     &             STATUS='OLD',FORM='UNFORMATTED')
d375 1
a375 1
C         Read the angles for ITI experimental projection
d424 2
a425 2
C               ABS - directions at 180 degrees are different
C                    (- do not check mirrored)
d429 1
a429 1
                   CALL CROSRNG_DS (CIRC,CIROLD,LCIRC,NRING,
d453 1
a453 1
C           Projection is outside of RANGE of all the reference projections	
d470 1
a470 1
C     CLOSE(NSCF,DISPOSE='DELETE')
@


1.22
log
@H
@
text
@d5 1
d17 2
a18 1
C    DSGR                                 10/21/99
d22 3
a24 15
C     SCRATCH.FILE PRODUCED IN EITHER CASE ...
C     RESTRICTED ANGULAR SEARCH RANGE.
C     DO NOT CHECK MIRRORED ORIENTATIONS..
C
C     SUBROUTINE DSGR(MAXMEM)
C     SUBROUTINE  DSGR_P(BUF,ILIST,NILMAX,ILIP,NIDI,NIDI,
C     SUBROUTINE  NORMAS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C     SUBROUTINE  ALPRBS
C     SUBROUTINE  ALRQ
C     SUBROUTINE  CROSRNG_DS
C     SUBROUTINE  FRNG(CIRC,LCIRC,NUMR,NRING)
C     SUBROUTINE PRB1D(B,NPOINT,POS)
C     SUBROUTINE  FFTR_D(X,NV)
C     SUBROUTINE  FFTC_D(BR,BI,LN,KS)
C     FUNCTION  LOG2(N)
d31 1
d33 2
d36 1
a36 3
         CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
         INTEGER  MAXRIN
         CHARACTER*1  MODE,ASK,NULL
d39 3
a41 1
	 LOGICAL  SUCCESS
d43 2
a44 1
         NULL=CHAR(0)
d46 5
a50 1
	ALLOCATE(ILIST(NILMAX))
a52 1

d55 1
a55 1
	IF (IRTFLG .NE. 0) RETURN
d58 7
a64 7
         IF(NIMA.GT.0)  THEN
            WRITE(NOUT,2001) NIMA
2001        FORMAT('  NUMBER OF IMAGES =',I5)
         ELSE
            WRITE(NOUT,*)  '  NO IMAGES !'
            RETURN
         ENDIF
d66 3
a68 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d70 1
a70 1
         IF(IRTFLG.NE.0)  RETURN
d72 1
a72 1
         CLOSE(INPIC)
d74 1
a74 1
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
d78 1
a78 1
	   RETURN
d81 4
a84 18

         CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
         ISKIP=MAX0(1,ISKIP)
         CALL  FILERD(REFANG,NREFA,NULL,
     &		'Reference projections angles document',IRTFLG)
C
C     NA=1
C     CALL  RDPRMC(ASK,NA,.TRUE.,'(F)ULL OR (H)ALF CIRCLE',NULL,IRT)
C     IF(ASK.EQ.'F')  THEN
C         MODE='F'
C     ELSEIF(ASK.EQ.'H')  THEN
C        MODE='H'
C     ELSE
C        RETURN
C     ENDIF
C     CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
C     & 'Precision of peak location (0..100)$')
C     JACUP=MAX0(0,MIN0(100,JACUP))
d86 1
a86 1
      	CALL  RDPRMC(ASK,NA,.TRUE.,
d90 1
a90 1
         DO    I=MR,NR,ISKIP
d93 1
d95 5
a99 1
	 IF(IRTFLG.NE.0) CALL ERRT(46,'AP RN, NUMR',IER)
d101 3
a103 3
         DO    I=MR,NR,ISKIP
          NRING=NRING+1
          NUMR(1,NRING)=I
d105 4
a108 4
C
C Calculation of actual dimension of an image to be interpolated
C 2*(No.of rings)+(0'th element)+2*(margin of 1)
C
d114 2
a115 2
         CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)
d117 5
a121 1
	 ALLOCATE(ILIP(NILMAX))
d126 1
a126 1
	IF (IRTFLG.NE.0) RETURN
d142 1
a142 1
	   SUCCESS=.FALSE.
d145 9
a153 9
	IF (.NOT.SUCCESS) 
     &   CALL  DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &      NSAM,NROW,LSAM,LROW,RANGE,
     &      NRING,LCIRC,MAXRIN,NUMR,
     &      MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
C
	 DEALLOCATE(ILIP)
	 DEALLOCATE(NUMR)
	 DEALLOCATE(ILIST)
d175 11
d195 2
a196 3
         PARAMETER  (NLIST=7)
         INTEGER  MAXRIN
         INTEGER  NUMR(3,NRING)
d199 1
d201 2
a202 2
	CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
C Automatic arrays
d204 4
a207 2
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:) ::  TOT,CIRC,CIROLD
d209 1
a209 2
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT,TOTMIN
	DIMENSION  WR(NRING)
d212 2
a213 1
	LOGICAL  IN_CORE
d216 3
a218 14
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C
	DLIST=0.0
	RANGE=COS(RANGE*DGR_TO_RAD)
C
d220 1
a220 1
        IF(MODE.EQ.'H')  THEN
d228 1
a228 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d232 1
a232 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d234 8
a241 14
	ALLOCATE(TOT(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TOT',IER)
	ALLOCATE(TOTMIN(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TOTMIN',IER)
	ALLOCATE(X(NSAM,NROW),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, X',IER)
	ALLOCATE(CIRC(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRC',IER)
	ALLOCATE(CIROLD(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRCOLD',IER)
	ALLOCATE(SA(3,NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, SA',IER)
	ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, LCG',IER)
d243 9
a251 12
	IF (IRTFLG.NE.0) THEN
C         GWP - I HAVE TO FIX THE ALLOCATION HERE
          IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	  ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	  IF (IRTFLG.NE.0) THEN
	     CALL  ERRT(46,'AP RN, BFC',IER)
	     RETURN
	  ELSE
	     IN_CORE=.FALSE.
	  ENDIF
	ELSE
	  IN_CORE=.TRUE.
d254 8
a261 8
         LQ=LROW/2+1
         LR1=(NROW-1)/2
         LR2=LQ+LR1
         LR1=LQ-LR1
         LQ=LSAM/2+1
         LS1=(NSAM-1)/2
         LS2=LQ+LS1
         LS1=LQ-LS1
d266 1
a266 1
C  Read the angles and convert them to unitary directional vectors.
d270 2
a271 2
	CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
d274 7
a280 5
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for reference projection not found',NE)
		RETURN
d284 3
a286 3
        SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
d289 4
a292 4
C
	IF(ASK.EQ.'Y')  GOTO  7751
C
	IF(ASK.EQ.'W'.OR..NOT.IN_CORE) OPEN(NSCF,FILE='scratch.file',
d294 1
a294 1
C
d296 3
a298 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d300 20
a319 24
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
2032       FORMAT(' File not found ',A80,/,' Operation abandoned')
           RETURN
          ENDIF
	 DO    K2=LR1,LR2
          CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	  DO    K3=LS1,LS2
            X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
	  ENDDO
	 ENDDO
	 CLOSE(INPIC)
C
C  Normalize under the mask
C
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &       NUMR,NUMR(1,NRING))
C
	  CALL  ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	  CALL  FRNG(CIRC,LCIRC,NUMR,NRING)
	  CALL  APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
C
	  IF(ASK.EQ.'W'.OR..NOT.IN_CORE)  WRITE(NSCF)  CIRC
          IF(IN_CORE)  THEN
d321 4
a324 4
           DO I=1,LCIRC
            BFC(I,K1)=CIRC(I)
           ENDDO
          ENDIF
d326 4
a329 3
	IF(ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)
7751     CONTINUE
         IF(.NOT.IN_CORE.OR.ASK.EQ.'Y')
d331 2
a332 2
     &        STATUS='OLD',FORM='UNFORMATTED')
         IF(ASK.EQ.'Y')  THEN
d334 1
a334 1
             READ(NSCF)  (BFC(I,J),I=1,LCIRC)
d336 5
a340 5
           CLOSE(NSCF)
         ENDIF
C
         DO  ITI=1,NIDI
          CALL  FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d344 7
a350 9
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FIPROJ
           RETURN
          ENDIF
          DO    K2=LR1,LR2
           CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
            DO    K3=LS1,LS2
             X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
	    ENDDO
d353 6
a358 6
C
C  Read the angles for ITI experimental projection
	 CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
                LERR = -1
		K2A=0
d360 1
a360 1
                IF (LERR.NE.0) THEN
d362 2
a363 2
	 CALL  ERRT(100,
     &         'Angle for experimental projection not found',NE)
d365 8
a372 7
		ENDIF
		K2A=1
            ENDIF
         TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
         TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
         TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
C  Normalize under the mask
d374 1
a374 1
     &      NUMR,NUMR(1,NRING))
d377 14
a390 12
C Determine which ones are to be compared
	   NIMALCG=0
           DO   IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
         DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	    IF(DT.GE.RANGE)  THEN
	     NIMALCG=NIMALCG+1
	     LCG(NIMALCG)=IMI
	    ELSE
	     TOTMIN(IMI)=-1.0D20
	    ENDIF
	   ENDDO
d392 2
a393 2
	 IF(NIMALCG.GT.0)  THEN
          IF(IN_CORE)  THEN
d395 20
a414 21
            DO   IMIL=1,NIMALCG
	     IMI=LCG(IMIL)
	     CALL  CROSRNG_DS
     &		(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	    ENDDO
          ELSE
           REWIND  NSCF
           DO    IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	    IF(DT.GE.RANGE)  THEN
             READ(NSCF)  CIRC
             CALL  CROSRNG_DS
     &        (CIRC,CIROLD,LCIRC,NRING,
     &	MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	    ELSE
             READ(NSCF)
	     TOTMIN(IMI)=-1.0D20
	    ENDIF
	   ENDDO
d416 1
a416 1
C
d418 4
a421 4
             IF(TOTMIN(IMI).GE.EAV)  THEN
                EAV=TOTMIN(IMI)
                IDI=ILIST(IMI)
                RANG=TOT(IMI)
d424 7
a430 7
C .....................................................................
          DLIST(2)=IDI
          DLIST(3)=EAV
          RANG=(RANG-1)/MAXRIN*DIVAS
          DLIST(4)=RANG
C DLIST 5&6 are permanently set to zero (this is to keep same format as
C  AP MQ command)
d432 4
a435 4
C Projection is outside of RANGE of all the reference projections	
          DLIST(2)=0.0
          DLIST(3)=-1.0
          DLIST(4)=0.0
d437 8
a444 7
          DLIST(1)=ITI
          DLIST(7)=ILIP(ITI)
          CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
	 ENDDO
         CALL  SAVDC
         CLOSE(NDOC)
	 CLOSE(INANG)
d447 1
a447 1
	 IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
d449 30
a478 12
C        close(nscf,dispose='delete')
         IF(.NOT.IN_CORE)  CLOSE(NSCF)
	 DEALLOCATE(BFC)
	 DEALLOCATE(LCG)
	 DEALLOCATE(SA)
	 DEALLOCATE(CIROLD)
	 DEALLOCATE(CIRC)
	 DEALLOCATE(X)
	 DEALLOCATE(TOTMIN)
	 DEALLOCATE(TOT)
	 DEALLOCATE(TT)
         END
d484 13
d505 1
a505 1
C Automatic arrays
d514 1
a514 12
C
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C
d517 2
a518 1
        IF(MODE.EQ.'H')  WR=WR*0.5
d521 1
a521 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d525 1
a525 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d528 8
a535 9
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, DLIST',IER)
	DLIST=0.0
C
	ALLOCATE(X(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MD, X',IER)
	ALLOCATE(SA(3,NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, SA',IER)
	ALLOCATE(TA(3,NIDI),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TA',IER)
d537 17
a553 17
	IF(IRTFLG.EQ.0) THEN
	   SUCCESS=.TRUE.
C
         LQ=LROW/2+1
         LR1=(NROW-1)/2
         LR2=LQ+LR1
         LR1=LQ-LR1
         LQ=LSAM/2+1
         LS1=(NSAM-1)/2
         LS2=LQ+LS1
         LS1=LQ-LS1
C  Read the angles and convert them to unitary directional vectors.
	K2A=1
        LERR = -1
	DO  IMI=1,NIMA
	CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
d555 10
a564 8
		K2A=0
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for reference projection not found',NE)
		RETURN
		ENDIF
		K2A=1
d566 3
a568 3
        SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
d571 3
a573 3
C
C  Read the angles for ITI experimental projection
	K2A=1
d576 16
a591 15
	CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
                LERR = -1
		K2A=0
             CALL  UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for experimental projection not found',NE)
		RETURN
		ENDIF
		K2A=1
            ENDIF
        TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
d594 3
a596 3
C
	DO   ITIT=1,NIMA,NUMTH
	 DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
d598 3
a600 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d602 9
a610 9
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
2032       FORMAT(' File not found ',A80,/,' Operation abandoned')
           RETURN
          ENDIF
	 DO    K2=LR1,LR2
          CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	  DO    K3=LS1,LS2
            X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
a611 5
	 ENDDO
	 CLOSE(INPIC)
	ENDDO

C  Normalize under the mask
d613 1
d615 1
a615 1
	 DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
d617 3
a619 3
     &       NUMR,NUMR(1,NRING))
C
	  CALL  ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
d621 10
a630 11
	  CALL  FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	  CALL  APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
C
	ENDDO
	 ENDDO
C
         DO  ITIT=1,NIDI,NUMTH
	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
          CALL  FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d632 12
a643 14
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
           RETURN
          ENDIF
          DO    K2=LR1,LR2
           CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
            DO    K3=LS1,LS2
             X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1)=BUFIN(K3)
	    ENDDO
    	  ENDDO
	  CLOSE(INPIC)
	 ENDDO
C
C  Normalize under the mask
d645 19
a663 4
	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
	CALL  DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,MODE,MAXRIN,
     &    BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	  DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),DLIST(4,ITI-ITIT+1))
d665 27
a691 26
C .....................................................................
C          DLIST(2)=IDI
C          DLIST(3)=EAV
C          DLIST(4)=ANGMOR(RANG,MODE)
C DLIST 5&6 are permanently set to zero (this is to keep same format as
C  AP MQ command)
 	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
           DLIST(1,ITI-ITIT+1)=ITI
	   IF(DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &		ILIST(INT(DLIST(2,ITI-ITIT+1)))
           DLIST(7,ITI-ITIT+1)=ILIP(ITI)
           CALL  SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
	  ENDDO
	 ENDDO
         CALL  SAVDC
         CLOSE(NDOC)
	 DEALLOCATE(BFC)
	ELSE
	   SUCCESS=.FALSE.
	ENDIF
	 DEALLOCATE(TA)
	 DEALLOCATE(SA)
	 DEALLOCATE(X)
	 DEALLOCATE(DLIST)
	 DEALLOCATE(TT)
         END
d693 2
d698 2
a699 1
	CHARACTER*1  MODE
d701 1
a701 1
         INTEGER  NUMR(3,NRING)
d703 1
a703 1
	REAL, ALLOCATABLE, DIMENSION(:) ::  CIROLD
d705 14
a718 14
	ALLOCATE(CIROLD(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRCOLD',IER)
	ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, LCG',IER)
C
C Determine which ones are to be compared
	NIMALCG=0
        DO   IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	 IF(DT.GE.RANGE)  THEN
	  NIMALCG=NIMALCG+1
	  LCG(NIMALCG)=IMI
	 ENDIF
d720 25
a744 25
	IF(NIMALCG.GT.0) THEN
	CALL NORMASS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &      NUMR,NUMR(1,NRING))
	CALL  ALRQS(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE)
	CALL  FRNGS(CIROLD,LCIRC,NUMR,NRING)
        EAV=-1.0D20
        DO   IMIL=1,NIMALCG
	 IMI=LCG(IMIL)
	  CALL  CROSRNG_DS
     &		(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	   MAXRIN,NUMR,TOTMIN,TOT,TT)
          IF(TOTMIN.GE.EAV)  THEN
           EAV=TOTMIN
           IDI=IMI
           RANG=TOT
	  ENDIF
	ENDDO
C
	 IF(MODE.EQ.'F')  THEN
          RANG=(RANG-1.0)/MAXRIN*360.0
         ELSE
          RANG=(RANG-1.0)/MAXRIN*180.0
	 ENDIF
	 DLIST2=IDI
	 DLIST3=EAV
d746 3
a748 3
         RANG=0.0
	 DLIST2=0.0
	 DLIST3=-1.0
d750 1
d753 1
@


1.21
log
@*** empty log message ***
@
text
@d38 1
a38 1
         SUBROUTINE DSGR
d93 1
a93 1
         MODE='F'
d226 6
d443 1
a443 1
          RANG=(RANG-1)/MAXRIN*360.0
d512 1
d718 5
a722 1
         RANG=(RANG-1)/MAXRIN*360.0
@


1.20
log
@no message for small 1st ring
@
text
@d34 1
a34 1
C     FUNCTION  LOG2_P(N)
@


1.19
log
@used setthreads
@
text
@d84 1
a84 5
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
@


1.18
log
@associated --> allocated
@
text
@d275 1
a275 1
C
d277 1
a277 1
	IF(.NOT.IN_CORE) call  omp_set_num_threads(2)
d432 5
a436 5
           IF(TOTMIN(IMI).GE.EAV)  THEN
            EAV=TOTMIN(IMI)
            IDI=ILIST(IMI)
            RANG=TOT(IMI)
	   ENDIF
d458 1
d460 1
a460 1
	IF(.NOT.IN_CORE) call  omp_set_num_threads(NUMTH)
d462 1
a462 1
C     close(nscf,dispose='delete')
@


1.17
log
@added assciated to gwp changes
@
text
@d255 1
a255 1
          IF (ASSOCIATED(BFC)) DEALLOCATE(BFC)
@


1.16
log
@DEALLOCATE ADDED BY GWP
@
text
@d253 3
a255 3
	IF(IRTFLG.NE.0) THEN
C         GWP - I have to fix the allocation here
          DEALLOCATE(BFC)
d257 3
a259 3
	  IF(IRTFLG.NE.0) THEN
	   CALL  ERRT(46,'AP RN, BFC',IER)
	   RETURN
d261 1
a261 1
	   IN_CORE=.FALSE.
d264 1
a264 1
	 IN_CORE=.TRUE.
d266 1
a266 1
C
@


1.15
log
@Used getthreads & cosmetic
@
text
@d254 2
@


1.14
log
@ # continue char fails on NT f90
@
text
@d1 1
d16 1
a16 1
C   DSGR                                 10/21/99
d21 2
a22 2
C  Restricted angular search range.
C  Do not check mirrored orientations..
d51 1
a51 1
C
d53 3
a55 3
C
C  ASK FOR DATA FILE
C
d57 1
a57 1
     &   'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS NAME',IRTFLG)
d59 2
a60 1
C  NIMA - total number of images
d62 2
a63 2
          WRITE(NOUT,2001) NIMA
2001      FORMAT('  Number of images =',I5)
d65 2
a66 2
          WRITE(NOUT,*)  '  No images !'
          RETURN
d68 1
a68 1
C
d73 2
a74 4
         IF(IRTFLG.NE.0)  THEN
          CALL ERRT(4,'AP RN ',NE)
          RETURN
         ENDIF
d76 1
a76 1
C
d78 1
a78 1
C
d80 2
a81 2
	 CALL ERRT(31,'AP RN',NE)
	 RETURN
d83 1
d108 2
a109 2
     &	'SCRATCH FILE EXISTS (Y/N/W)?',NULL,IRT)
C
d112 1
a112 1
          NRING=NRING+1
d114 2
a115 2
	ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL ERRT(46,'AP RN, NUMR',IER)
d132 1
a132 1
C
d134 2
a135 2
C
C  images to be aligned
d138 2
a139 1
	IF(IRTFLG.NE.0) RETURN
d141 9
a149 16
     &		'Experimental projections angles document',IRTFLG)
	 CALL  RDPRM(RANGE,NLOOP,ILOOP,'Range of angular search')
C  NIDI - number of images to check distances
C
#ifdef SP_MP
c$omp parallel private(np)
	np = OMP_GET_NUM_THREADS()
c$omp single
	NUMTH=np
c$omp end single
c$omp end parallel
#else
	NUMTH=1
#endif
	IF(NUMTH.GT.1.AND.NIDI.GT.NUMTH.AND.ASK.EQ.'N')  THEN
         CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d154 1
a154 1
	 SUCCESS=.FALSE.
d156 2
a157 1
	IF(.NOT.SUCCESS) 
d167 3
a169 2
2600     FORMAT (/ ' ',80('-')//' ',
     &          'END OF COMPUTATION',//' ',80('-')/)
d171 2
d175 1
a175 1
C $$ DSGR_P.FOR
a186 3
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d193 1
d210 1
a210 1
C
a211 1
	INTEGER  OMP_GET_NUM_THREADS
d214 1
a214 1
C
d490 1
a490 2
C
	INTEGER  OMP_GET_NUM_THREADS
d601 1
a601 1
C
d603 1
a603 1
C
@


1.13
log
@negative mirror
@
text
@d3 1
a3 1
C $$ DSGR.FOR
a14 5
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************

         SUBROUTINE DSGR

a22 1
C
d35 5
a39 1
	PARAMETER  (NILMAX=99998)
d122 1
a122 1
C 2*(# of rings)+(0'th element)+2*(margin of 1)
d172 1
a172 1
     #          'END OF COMPUTATION',//' ',80('-')/)
@


1.12
log
@*** empty log message ***
@
text
@d20 1
a20 1
C   DSGR                                 10/30/98
a27 7
C    WHEN IN THE OUTPUT DOCUMENT FILE N POINTS TO I+NIMA,
C    WHERE NIMA IS NUMBER OF REFERENCE PROJECTIONS,
C    THEN THE REFERENCE PROJECTION HAS TO BE MIRRORED
C    AND ITS EULERIAN ANGLES MODIFIED AS FOLLOWS:
C    I      :      THETA       PHI
C    I+NIMA :     180-THETA  180+PHI
C    AND PSI FROM THE OUTPUT DOCUMENT FILE  ->  180+PSI.
a282 2
c find max element on  ILIST
	MAXIMA=MAXVAL(ILIST)
d451 1
a451 1
          DLIST(2)=-1.0
a543 3

c find max element on  ILIST
	MAXIMA=MAXVAL(ILIST)
d647 1
a647 1
     &    BFC,LCIRC,NIMA,MAXIMA,TT,SA,TA(1,ITI),RANGE,
d676 1
a676 3



d678 1
a678 1
     &		BFC,LCIRC,NIMA,MAXIMA,TT,SA,TA,RANGE,
d724 1
a724 1
	 DLIST2=-1.0
@


1.11
log
@psi changed
@
text
@d353 1
a353 1
	 ENDDO
d384 1
a384 1
	CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
d391 2
a392 1
	CALL  ERRT(100,'Angle for experimental projection not found',NE)
d397 3
a399 3
        TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
d409 1
a409 1
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
d425 1
a425 1
     &	MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
d447 1
a447 1
            IDI=IMI
d670 2
d733 3
a735 3
        RANG=(RANG-1)/MAXRIN*360.0
	DLIST2=IDI
	DLIST3=EAV
d737 3
a739 3
        RANG=0.0
	DLIST2=-1.0
	DLIST3=-1.0
@


1.10
log
@F90 version
@
text
@a453 1
          IF(RANG.GT.0.0)  RANG=360.0-RANG
a730 1
        IF(RANG.GT.0.0)  RANG=360.0-RANG
@


1.9
log
@*** empty log message ***
@
text
@d18 1
a18 1
         SUBROUTINE DSGR(MAXMEM)
d20 1
a20 1
C   DSFR                                 10/31/98
d25 1
a25 1
C  Restricted angular search range
d37 1
a37 1
C     SUBROUTINE  DSGR_S(BUF,ILIST,NILMAX,ILIP,NIPMAX,NIDI,
d41 1
a41 2
C     SUBROUTINE  CROSRNG
C     SUBROUTINE  CROSRMG
a45 1
C     FUNCTION  ANGMR(RKK,MODE)
d47 3
a49 16

	PARAMETER  (NILMAX=21000,NIPMAX=99998)
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
	INCLUDE 'CMBLOCK.INC'
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: BFC

#else
         DIMENSION BFC(1)
         POINTER   (IPQ,BFC) 
#endif
         LOGICAL         RUNTIME
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),ILIP(NIPMAX),Q(1)
d54 3
a56 2
         LOGICAL  IN_CORE
         EQUIVALENCE  (Q,NUMR)
d59 3
a61 1

d64 1
a64 2
         NMAX=NILMAX
         CALL  FILSEQP(FINPAT,NLET,ILIST,NMAX,NIMA,
d66 1
d68 8
a75 1

d77 6
a82 4
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
         IF (NF.NE.2)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND'
            RETURN
d85 1
d89 2
a90 2
	CALL ERRT(31,'OR 2',NE)
	RETURN
d101 1
a114 1
         JACUP=0
d120 8
a127 2
         NRING=NRING+1
         NUMR(1,NRING)=I
d129 1
a129 1

d139 6
a144 2
         NMAX=NIPMAX
         CALL  FILSEQP(FIPROJ,NLEP,ILIP,NMAX,NIDI,
d146 1
a151 29
C
C   memory division
C     NUMR        1
C     CIRC        2
C A: X                 3
C    BUFIN             4
C    WORK              5
C          B:
C             CIROLD   4
C             TEMP     6
C             TOTMIN   61
C             TOT      63
C             TT       65
C             WR       66
C             K_SA
C             BFC      7
C
         MAXRIN=NUMR(3,NRING)
         K1=1
         K2=IPALIGN64(K1+3*NRING)
         K7=IPALIGN64(K2+LCIRC)
         K3A=K7
         K41A=IPALIGN64(K3A+NSAM*NROW)
         K4A=IPALIGN64(K41A+LSAM)
         K5A=K4A
         K3B=K5A
         K4B=K3B
         K5B=IPALIGN64(K4B+LCIRC)
         K6B=K5B
d153 6
a158 1
        K61=K6B
d160 1
a160 3
C  have to add 2 due to libfft
C  have to add 2 due to libfft
        K61=IPALIGN64(K6B+(MAXRIN+2)*4)
d162 39
d202 41
a242 4
         K62=IPALIGN64(K61+2*NIMA)
         K63=IPALIGN64(K62)
         K64=IPALIGN64(K63+NIMA)
         K65=IPALIGN64(K64)
d244 3
a246 1
         K66=IPALIGN64(K65+(LCIRC+15)*2)
d248 41
a288 1
         K66=K65
d290 183
a472 9
	K_SA=IPALIGN64(K66+NRING)
         K_LCG=IPALIGN64(K_SA+3*NIMA)
         K7B=IPALIGN64(K_LCG+NIMA)
        MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K7B)
	MEMBUF=LCIRC*NIMA
        CALL ALLOCIT(MEMBUF,RUNTIME,IPQ,'DSFS',IRTFLG)
	IF(MEMTOT.LE.MAXMEM.AND.RUNTIME)  THEN
#ifdef SP_F90
         BFC = >IPQ
d474 46
d521 9
a529 8
            WRITE (NOUT,2500)  MAXMEM , MEMTOT
2500        FORMAT (/,'  Alignment of projections, in-core version.',
     #              /,'  Memory: available ',I8,',  required ',I8,/)
            IN_CORE=.TRUE.
        ELSE
            IF(MEMTOT .LE. MAXMEM)  THEN
#ifdef SP_F90
            BFC = >IPQ
d531 40
a570 9
               WRITE (NOUT,2501)  MAXMEM , MEMTOT
2501           FORMAT (/,
     #'  Alignment of projections, on-disk version (scratch.file used).'
     #   ,/,'  Memory: available ',I8,',  required ',I8,/)
              IN_CORE=.FALSE.
            ELSE
               IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'AP RN',IRTFLG)
               CALL  ERRT(45,'AP RN',NE)
               RETURN
d572 30
a601 1
        ENDIF
d603 82
a684 11
         CALL  DSGR_S(BUF,ILIST,NILMAX,ILIP,NIPMAX,NIDI,
     &      NSAM,NROW,LSAM,LROW,NIMA,
     &      NRING,LCIRC,MAXRIN,JACUP,NUMR,RANGE,
     &      Q(K2),Q(K3A),Q(K41A),Q(K4B),Q(K_SA),Q(K_LCG),
     &      Q(K6B),Q(K61),Q(K63),Q(K65),Q(K66),
     &          BFC(1),
     &   MODE,ASK,IN_CORE,NOUT,REFANG,EXPANG)
        IF(RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'AP RN',IRTFLG)
         WRITE (NOUT,2600)
2600     FORMAT (/ ' ',80('-')//' ',
     #          'END OF COMPUTATION',//' ',80('-')/)
d686 57
@


1.8
log
@*** empty log message ***
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=99998)
d53 1
a53 1
         INCLUDE 'CMBLOCK.INC'
d89 10
@


1.7
log
@*** empty log message ***
@
text
@d216 1
a216 1
     &          BFC,
@


1.6
log
@*** empty log message ***
@
text
@a53 1
#ifdef SP_ALLOC
a63 1
#endif
a71 1
CNO_SAVE
a181 1
#ifdef SP_ALLOC
a188 5
#else
        K8B=IPALIGN64(K7B+LCIRC*NIMA)
        MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K8B)
        IF (MEMTOT.LE.MAXMEM)  THEN
#endif
d194 2
a195 7
         ELSE
#ifdef SP_ALLOC
            K8B=K8B-LCIRC*NIMA
            MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K8B)
#endif
            IF (MEMTOT .LE. MAXMEM)  THEN
#ifdef SP_ALLOC
a198 1
#endif
d205 2
a206 4
#ifdef SP_ALLOC
               IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'DSFS',IRTFLG)
#endif
               WRITE(NOUT,*)  '  Sorry, not enough memory !'
d208 2
a209 2
           ENDIF
         ENDIF
a215 1
#ifdef SP_ALLOC
a216 3
#else
     &          Q(K7B),
#endif
a217 1
#ifdef SP_ALLOC
a218 1
#endif
@


1.5
log
@ff
@
text
@d51 2
a69 1
         INTEGER  NUMR(3,480)
@


1.4
log
@99998
@
text
@d67 2
a68 2
         INTEGER*2  MAXRIN
         INTEGER*2  NUMR(3,480)
d154 1
a154 1
         K2=IPALIGN64(K1+(3*NRING+1)/2)
@


1.3
log
@buffer 99999
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=99999)
d185 1
a185 1
        MEMTOT=NILMAX+1200+MAX0(K5A,K7B)
d194 1
a194 1
        MEMTOT=NILMAX+1200+MAX0(K5A,K8B)
d205 1
a205 1
            MEMTOT=NILMAX+1200+MAX0(K5A,K8B)
@


1.2
log
@TEMP fixed
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=20000)
@


1.1
log
@Initial revision
@
text
@d167 3
a169 1
        K61=IPALIGN64(K6B+MAXRIN*4)
@
