head	1.87;
access;
symbols
	pre_getangas:1.73
	GPL2010:1.65
	pre_GPL2010:1.64
	pre_var_equation:1.64
	pre_fftwrings:1.64
	pre_opfiles:1.64
	src:1.64
	best-code:1.64
	x-named-regs:1.61
	x:1.61
	v13-00:1.61
	pre_GPL:1.59
	prec_CA:1.45
	noindx:1.31
	Bproc:1.21
	oct21:1.12;
locks; strict;
comment	@c @;


1.87
date	2016.04.27.15.57.28;	author leith;	state Exp;
branches;
next	1.86;

1.86
date	2014.12.10.15.27.52;	author leith;	state Exp;
branches;
next	1.85;

1.85
date	2014.03.17.18.38.16;	author leith;	state Exp;
branches;
next	1.84;

1.84
date	2014.03.17.18.14.25;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	2014.01.12.19.39.07;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	2013.11.13.15.34.06;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	2013.09.16.12.44.18;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2013.05.17.14.43.55;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2013.04.22.17.51.03;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2012.04.30.12.43.19;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	2012.04.27.18.46.38;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2012.04.11.15.19.20;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2011.04.14.16.02.35;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	2011.03.14.14.54.04;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	2011.01.20.17.36.22;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	2011.01.06.17.52.35;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	2010.12.31.14.25.19;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	2010.12.20.19.46.58;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2010.12.20.19.20.55;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2010.11.23.15.17.22;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2010.11.08.18.33.49;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2010.10.27.14.45.21;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.24.13.25.27;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2006.01.23.18.21.50;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2006.01.23.17.02.51;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2005.12.13.19.16.11;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2005.10.17.20.21.30;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2005.10.17.18.14.01;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2005.07.29.16.08.35;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2005.06.06.22.46.05;	author cyang;	state Exp;
branches;
next	1.57;

1.57
date	2005.06.03.18.23.12;	author cyang;	state Exp;
branches;
next	1.56;

1.56
date	2004.11.19.17.26.35;	author cyang;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.26.16.32.20;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2004.09.30.16.42.41;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2004.07.20.20.10.59;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.20.20.06.25;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.22.19.20.31;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.24.14.19.58;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.17.20.02.49;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.05.14.23.36;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.23.13.49.52;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.31.15.50.58;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.26.15.03.35;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.04.20.17.16;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.04.14.02.14;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.03.16.58.07;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.07.15.06.10;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.03.00.37.25;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.29.19.46.46;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.28.20.02.28;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.15.17.09.05;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.15.13.52.13;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.08.17.07.20;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.08.16.54.45;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.08.16.19.01;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.13.16.40.22;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.23.16.37.40;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.24.15.03.31;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.11.14.08.09;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.13.17.00.21;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.18.13.10.05;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.07.15.24.30;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.07.15.21.01;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.07.14.21.49;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.19.19.49.30;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.13.18.30.03;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.07.14.31.28;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.24.15.17.49;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.14.12.48.55;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.21.16.09.16;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.21.16.08.05;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	99.11.30.19.51.39;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	99.11.10.18.24.49;	author pawel;	state Exp;
branches;
next	1.14;

1.14
date	99.11.10.16.46.49;	author pawel;	state Exp;
branches;
next	1.13;

1.13
date	99.10.22.13.53.55;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	99.10.21.13.43.04;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	99.10.19.13.31.11;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	99.09.21.17.40.53;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	99.08.20.19.27.07;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	99.07.14.19.21.37;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	99.06.23.18.21.07;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	99.06.17.19.12.04;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	99.04.12.13.02.51;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	99.04.07.13.56.25;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	99.04.05.19.04.51;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	99.04.05.16.36.42;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	99.03.30.17.39.35;	author leith;	state Exp;
branches;
next	;


desc
@@


1.87
log
@added 'DOC SLICE'
@
text
@
C ++********************************************************************
C
C DOCS1 NEW                                      JUN  1999 ARDEAN LEITH
C       ADDED 'DOC RAN'                          AUG  1999 ARDEAN LEITH
C       USED LUNDOCWRTDAT                        AUG  1999 ARDEAN LEITH
C       ADDED 'DOC AND'                          SEPT 1999 ARDEAN LEITH
C       ADDED 'DOC SPLIT'                        OCT  1999 ARDEAN LEITH
C       OPENDOC PARAMETERS                       DEC  2000 ARDEAN LEITH
C       'DOC TOMINESET' ADDED                    JUN  2001 ARDEAN LEITH
C       CLOSED NDOCOUT IN ROUTINES               JUL  2001 ARDEAN LEITH
C       'DOC COM' ADDED                          DEC  2001 ARDEAN LEITH
C       'DOC COM' BUG                            MAY  2002 ARDEAN LEITH
C       'DOC COM' FILE NAME BUG                  SEP  2002 ARDEAN LEITH
C       'DOC COM' MAXY BUF                       JUN  2003 ARDEAN LEITH
C       INCORE OPENDOC                           JUL  2003 ARDEAN LEITH
C       MPI                                      OCT  2003 CHAO YANG
C       'DOC RAN' BUG                            JAN  2004 ARDEAN LEITH
C       'DOC OLD' ADDED                          FEB  2004 ARDEAN LEITH
C       'DOC AND' BUG                            FEB  2004 ARDEAN LEITH
C       'DOC MIR' KEYCOL BUG                     OCT  2004 ARDEAN LEITH
C       'DOC KEY' ADDED                          JUL  2005 ARDEAN LEITH
C       'DOC BOOT' ADDED                         JAN  2006 ARDEAN LEITH
C       'DOC SORT' REVERSE ORDER                 OCT  2010 ARDEAN LEITH
C       'DOC TOMINESET' REMOVED                  NOV  2010 ARDEAN LEITH
C       'DOC SORT A' APPEND OK                   NOV  2010 ARDEAN LEITH
C       'DOC STAT'                               NOV  2010 ARDEAN LEITH
C       'DOC ME' EMPTY DOC FILE BUG              DEC  2010 ARDEAN LEITH
C        other ops still need empty doc file traps!
C        'ME') KEYCOL = 1 BUG                    JAN  2010 ARDEAN LEITH 
C        MOVED 'SUB' and 'AND' TO DOCSUB         JAN  2010 ARDEAN LEITH 
C        MPI ERROR IN  DOCCREATE                 MAR  2011 ARDEAN LEITH 
C        UNIQUE IN 'DOC SORT'                    APR  2012 ARDEAN LEITH 
C        UNIQUE IN 'AT IT' BUG                   SEP  2013 ARDEAN LEITH 
C       'DOC SEP' ADDED                          MAR  2014 ARDEAN LEITH
C       'DOC PLOT' ADDED                         DEC  2014 ARDEAN LEITH
C       'DOC SLI' ADDED                          APR  2016 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2016  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C                                                                       
C  DOCS1(MAXDIM)
C                                                                 
C  PURPOSE: MANIPULATES DOCUMENT FILES.
C   
C  NOTE: TSWITCH SAYS THIS IS A 2 LETTER OP
C                                                                    
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

	SUBROUTINE DOCS1(MAXDIM)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        INTEGER, INTENT(IN)          :: MAXDIM
 	CHARACTER(LEN=MAXNAM)        :: DOCNAM
 	CHARACTER(LEN=1)             :: NULL = CHAR(0)
        REAL, ALLOCATABLE            :: DLIST(:)

        INCLUDE 'F90ALLOC.INC'
        REAL,  POINTER               :: DOCBUF(:,:)

        INTEGER, PARAMETER           :: NDOCIN  = 70
        INTEGER, PARAMETER           :: LUNPLOT = 80

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

        IF (FCHAR(4:5) == 'CR') THEN
C          CREATE NEW DOC FILE ------------------------- 'DOC CREATE'

           CALL DOCCREATE(MAXDIM)
           RETURN

        ELSEIF (FCHAR(4:5) == 'SH') THEN
C          SHUFFLE OLD DOC FILE ------------------------- DOC SHUFFLE'
C          (ALSO CALLED "SD SHUFFLE")
           CALL SHUFFLEDOC(MAXDIM)
           RETURN

        ELSEIF (FCHAR(4:5) == 'OL') THEN
C          COPY TO  OLD DOC FILE ------------------------ DOC COPY'
           CALL DOCDOWN()
           RETURN

        ELSEIF(FCHAR(4:5) == 'CO') THEN
C          COMBINE A SERIES OF INPUT DOC. FILES --------- DOC COMBINE'
           CALL DOCCOMBINE()
           RETURN

        ELSEIF(FCHAR(4:5) == 'SE') THEN
C          SEPARATE A SERIES OF INPUT DOC. FILES -------- DOC SEPARATE'
           CALL DOCSEPARATE()
           RETURN

        ELSEIF(FCHAR(4:5) == 'PL') THEN
C          GNUPLOT REGISTER CONTENTS  -------------------- 'DOC PLOT'

           CALL DPROFD_GPL(NDOCIN,LUNPLOT)
           RETURN
        ENDIF

C       OPEN EXISTING DOC FILE
C       MAXX IS 1 + NUM OF REGISTERS SINCE DOCBUF CONTAINS KEY ALSO
        MAXX    = 0
        MAXY    = 0
        NDOCINT = NDOCIN

C       DOC RENUMBER NEEDS SEQUENTIAL READ OF LINES NOT BY KEY
        IF (FCHAR(4:5) == 'RE') NDOCINT = -NDOCIN

        CALL GETDOCDAT('INPUT DOCUMENT',.TRUE.,DOCNAM,
     &                 NDOCINT,.TRUE.,MAXX, MAXY,DOCBUF,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        NLIST = MAX(MAXX,1)
        ALLOCATE(DLIST(NLIST), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'DOCS1; DLIST',NLIST)
           GOTO 9995
        ENDIF

        IF (FCHAR(4:5) == 'RA') THEN
C          CREATE RANDOM SELECTED DOC FILE ------------------ 'DOC RAN'
           CALL DOCRAN(MAXX, MAXY, DOCBUF(1,1), DLIST)

        ELSEIF (FCHAR(4:5) == 'BO') THEN
C          CREATE RANDOM SELECTED BOOTSTRAP DOC FILE -------- 'DOC BOOT'
           CALL DOCBOOT(MAXX, MAXY, DOCBUF(1,1), DLIST)

        ELSEIF (FCHAR(4:5) == 'RE') THEN
C          RENUMBER DOC FILE --------------------------------- 'DOC RE'
           CALL DOCRENUMBER(MAXX, MAXY, DOCBUF(1,1), DLIST)

        ELSEIF (FCHAR(4:5) == 'KE') THEN
C          REKEY DOC FILE ----------------------------------- 'DOC KEY'
           CALL DOCREKEY(MAXX, MAXY, DOCBUF(1,1), DLIST)

        ELSEIF (FCHAR(4:5) == 'AN' .OR.
     &          FCHAR(4:5) == 'SU') THEN
C          SUBTRACT DOC FILE -------------------------------- 'DOC SUB'
C          AND DOC FILE      -------------------------------- 'DOC AND'
           CALL DOCSUB(MAXX, MAXY, DOCBUF(1,1), DLIST,NLIST)

        ELSE
C          OTHER DOC FILE OPS--------------------------------- 'DOC ??'
C          SINCE DLIST MAY VARY IT IS NOT USED HERE
           CALL DOCSDO(MAXX, MAXY, DOCBUF(1,1))

        ENDIF

C       DEALLOCATE DOC. FILE MEMORY
9995    IF (ASSOCIATED(DOCBUF)) DEALLOCATE(DOCBUF)

C       DEALLOCATE DLIST MEMORY
        IF (ALLOCATED(DLIST))  DEALLOCATE(DLIST)

        RETURN
        END


C       --------------------- DOCSDO ----------------------------------

C       SORT THE INPUT DOC FILE-------------------------------- 'AT IT'
C       SORT THE INPUT DOC FILE----------------------------- 'DOC SORT'
C       MIRROR THE INPUT DOC FILE------------------------- 'DOC MIRROR'
C       MERGE THE TWO INPUT DOC FILES---------------------- 'DOC MERGE'
C       STATISTICS FROM DOC FILES -------------------------- 'DOC STAT'

	SUBROUTINE DOCSDO(MAXX, MAXY, DOCBUF)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

	CHARACTER(LEN=MAXNAM)        :: DOCNAM2,DOCNAM3
	CHARACTER(LEN=1)             :: NULL = CHAR(0)
	CHARACTER(LEN=MAXNAM)        :: ANSW
        LOGICAL                      :: NEWFILE,ERRI2,RENUMBER

        REAL                         :: DOCBUF(MAXX*MAXY)
        REAL,    ALLOCATABLE         :: SORTED(:),SORTED2(:)
        REAL,    ALLOCATABLE         :: DLIST(:)
        INTEGER, ALLOCATABLE         :: KEYLIST(:)

        INCLUDE 'F90ALLOC.INC'
        REAL, POINTER                :: DOCBUF2(:,:)
	CHARACTER(LEN=80)            :: PROMPT
        LOGICAL                      :: SENDIT,REP_KEY,UNIQUE
        LOGICAL                      :: REVERSE
        INTEGER                      :: NEEDINC
        INTEGER                      :: NILMAX
        LOGICAL                      :: APPENDOK,MESSAGE

        INTEGER, PARAMETER           :: NDOCIN2  = 71
        INTEGER, PARAMETER           :: NDOCOUT  = 72
        INTEGER, PARAMETER           :: NDOCOUT2 = 73

C       SPACE FOR COMMON NUMERICAL LIST FROM CMLIMIT
        NILMAX = NIMAX

        IF (FCHAR(4:5) == 'SO') THEN
C                    12345678901234567890123456789012345678901234567890123456789
           PROMPT  ='COLUMN TO BE SORTED BY (0 IS KEY) (<0 TO REVERSE)' 
           NLETP    = 49
           RENUMBER = .TRUE.

        ELSEIF (FCHAR(4:5) == 'IT') THEN
           REVERSE = .FALSE.

        ELSEIF (FCHAR(4:5) == 'MI') THEN
           PROMPT   = 'COLUMN TO BE MIRRORED (0 IS KEY)' 
           NLETP    = 32
           RENUMBER = .FALSE.

        ELSEIF (FCHAR(4:5) == 'ME') THEN
           PROMPT   = 'COLUMN TO BE MERGED BY (0 IS KEY)'
           NLETP    = 35
           RENUMBER = .FALSE.

C          MERGE USES 2 INPUT DOC. FILES
C          MAXX2 IS 1 + NUM OF REGISTERS SINCE DOCBUF CONTAINS KEY ALSO
           MAXX2  = 0
           MAXY2  = 0
           CALL GETDOCDAT('SECOND INPUT DOCUMENT',.TRUE.,DOCNAM2,
     &                  NDOCIN2,.TRUE.,MAXX2, MAXY2,DOCBUF2,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

         ELSEIF (FCHAR(4:5) == 'SL') THEN
           PROMPT   = 'FIRST AND LAST RETAINED KEYS'
           NLETP    = 35

         ELSEIF (FCHAR(4:5) == 'ST') THEN
           PROMPT   = 'COLUMN TO BE ANALYZED (0 IS KEY)' 
           NLETP    = 40
        ENDIF

        IF (FCHAR(4:5) .NE. 'ST') THEN
C          OPEN OUTPUT DOCUMENT FILE
           CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9997

           APPENDOK = (FCHAR(4:9) == 'SORT A')
           MESSAGE  = .NOT. APPENDOK
           CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,NICDOCOUT,.FALSE.,
     &                  ' ',.FALSE.,APPENDOK,MESSAGE,NEWFILE,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9997
        ENDIF

        IF (FCHAR(4:5) == 'SO' .OR. 
     &      FCHAR(4:5) == 'MI' .OR.
     &      FCHAR(4:5) == 'ME') THEN
C          SORT THE INPUT DOC FILE------------------------- 'DOC SORT'
C          MIRROR THE INPUT DOC FILE----------------------- 'DOC MIRROR'
C          MERGE THE TWO INPUT DOC FILES------------------- 'DOC MERGE'

11         CALL RDPRI1S(KEYCOL,NOT_USED,PROMPT(1:NLETP),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9997

           REVERSE = (KEYCOL < 0)
           IF (FCHAR(4:5) .NE. 'ME') KEYCOL = ABS(KEYCOL)

           IF (FCHAR(4:5) == 'ME' .AND. MAXX > 0 )    THEN
              IF (ERRI2(KEYCOL,IDUM,1,-1,MAXX-1,0,0))   GOTO 11
           ELSEIF (MAXX > 0 .AND. MAXY > 0)             THEN
              IF (ERRI2(KEYCOL,IDUM,1, 0,MAXX-1,0,0))   GOTO 11
           ENDIF

           IF (FCHAR(4:5) == 'SO') THEN
              CALL RDPRMC(ANSW,NLET,.TRUE.,
     &       'COMPRESS & RENUMBER KEYS? (Y/N), REMOVE DUPLICATES (Y/N)',
     &       NULL,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9997
              CALL SSUPCAS(ANSW)
              RENUMBER = (ANSW(1:1) .NE. 'N')
              UNIQUE   = ( NLET > 1 .AND. INDEX(ANSW(2:),'Y') > 0)

           ELSEIF (RENUMBER) THEN
              CALL RDPRMC(ANSW,NLET,.TRUE.,
     &                 'COMPRESS & RENUMBER KEYS? (Y/N)',NULL,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9997
              CALL SSUPCAS(ANSW)
              RENUMBER = (ANSW .NE. 'N')
           ENDIF

        ELSEIF (FCHAR(4:5) == 'IT') THEN
           KEYCOL   = 1
           RENUMBER = .TRUE.
           UNIQUE   = .TRUE.

        ELSEIF (FCHAR(4:5) == 'SP') THEN
           CALL FILERD(DOCNAM2,NLET,NULL,'SECOND OUTPUT DOCUMENT',IRT)
           IF (IRT .NE. 0) RETURN

           CALL OPENDOC(DOCNAM2,.TRUE.,NLET,NDOCOUT2,NICDOCOUT2,.FALSE.,
     &                  ' ',.FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ENDIF

         IF (FCHAR(4:5) == 'SO' .AND. KEYCOL == 0) THEN
C          NO NEED TO SORT LIST ----------------------------- 'DOC SORT'
           NVAL   = MAXX - 1
           NEWKEY = 0

           DO IROW = 1,MAXY
               ILOC   = (IROW - 1) * MAXX + 1
               ICOUNT = DOCBUF(ILOC)
               IF (ICOUNT > 0) THEN
                  IF (RENUMBER) THEN
C                    RENUMBER THE KEYS
                     NEWKEY = NEWKEY + 1
                  ELSE
                     NEWKEY = IROW
                  ENDIF
C                 PUSH VALUES INTO OUTPUT DOC. FILE
                  CALL LUNDOCWRTDAT(NICDOCOUT,NEWKEY,
     &                           DOCBUF(ILOC+1),NVAL,IRTFLG)
               ENDIF
           ENDDO
           GOTO 9990

        ELSEIF ((FCHAR(4:5) == 'ME') .AND. 
     &          ((KEYCOL  <  0) .OR.
     &           (MAXX  < 1 .OR. MAXY  < 1) .OR. 
     &           (MAXX2 < 1 .OR. MAXY2 < 1))) THEN
C          NO NEED TO SORT LISTS -------------------------- 'DOC MERGE'

           IF ((MAXX  < 1 .OR. MAXY  < 1) .AND. 
     &         (MAXX2 < 1 .OR. MAXY2 < 1)) THEN
                 ! OK   CALL ERRT(102,'EMPTY DOC. FILES',NDUM)
                 GOTO 9990
           ENDIF

           MAXXT = MAX(MAXX,MAXX2)

           ALLOCATE(DLIST(MAXXT+1),STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'DLIST',MAXXT)
              GOTO 9990
           ENDIF

C          MERGING ALL KEYS
           KEYNEW = 0

C          MAKE SURE ALL REGISTERS ARE ZEROED IN OUTPUT
           NVAL = MAX(MAXX,MAXX2) - 1
           DO IREG = 1,NVAL
              DLIST(IREG) = 0.0
           ENDDO

           IF (MAXX > 0 .AND. MAXY > 0) THEN 
C             COPY VALUES FROM FIRST FILE
              DO IKEYT = 1,MAXY
                 ICOUNT = DOCBUF((IKEYT - 1) * MAXX + 1)
                 IF (ICOUNT > 0 ) THEN
C                   KEY EXISTS PUSH DLIST FROM FILE 1 INTO OUTPUT FILE
                    DO IREG = 1,MAXX
                       DLIST(IREG) = DOCBUF((IKEYT - 1) * MAXX + IREG)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    KEYNEW = KEYNEW + 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DLIST(2),
     &                                NVAL,IRTFLG)
                 ENDIF
              ENDDO
           ENDIF

           IF (MAXX2 > 0 .AND. MAXY2 > 0) THEN 
C             COPY VALUES FROM SECOND FILE
              DO IKEYT = 1,MAXY2
                 ICOUNT  = DOCBUF2(1,IKEYT)
                 IF (ICOUNT > 0) THEN
C                   KEY EXISTS, PUSH DLIST FROM FILE 2 INTO OUTPUT FILE
                    DO IREG = 1,MAXX2
                       DLIST(IREG) = DOCBUF2(IREG,IKEYT)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    KEYNEW = KEYNEW + 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DLIST(2),
     &                                NVAL,IRTFLG)
                 ENDIF
              ENDDO
           ENDIF
           GOTO 9990
     
        ELSEIF (FCHAR(4:5) == 'SO' .OR.
     &          FCHAR(4:5) == 'MI' .OR.
     &          FCHAR(4:5) == 'ME' .OR.
     &          FCHAR(4:5) == 'IT') THEN
C          NEED ONE OR MORE SORTED LISTS

C          SPLIT THE INPUT DOC FILE------------------------- 'DOC SPLIT'
C          SORT THE INPUT DOC FILE------------------------------ 'AT IT'
C          SORT THE INPUT DOC FILE--------------------------- 'DOC SORT'
C          MIRROR THE INPUT DOC FILE----------------------- 'DOC MIRROR'
C          MERGE THE TWO INPUT DOC FILES-------------------- 'DOC MERGE'

           ALLOCATE(SORTED(MAXY),STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'SORTED IN DOCS1',MAXY)
              GOTO 9997
           ENDIF

C          SORTED RETURNS LIST OF KEYS SORTED BY USING VALUE IN KEYCOL
           CALL SORTIT(DOCBUF,MAXX,MAXY,KEYCOL,SORTED,
     &                 IKEYS,.TRUE.,UNIQUE,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9995

           IF (FCHAR(4:5) == 'ME') THEN
C             SORT THE SECOND LIST OF KEYS BUT RETURN VALUES IN SORTED2
              ALLOCATE(SORTED2(MAXY2),STAT=IRTFLG)
              IF (IRTFLG .NE. 0) THEN
                 CALL ERRT(46,'SORTED IN DOCS1',MAXY2)
                 GOTO 9995
              ENDIF

C             RETURN SORTED LIST OF VALUES IN KEYCOL
              REP_KEY = (FCHAR(4:5) == 'ME')
              UNIQUE  = .FALSE. 
              CALL SORTIT(DOCBUF2(1,1),MAXX2,MAXY2,KEYCOL,SORTED2,
     &                    IKEYS2,REP_KEY,UNIQUE,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9995
          ENDIF
        ENDIF

        NLIST = MAXX
        IF (FCHAR(4:5) == 'MI') NLIST = MAX(2,KEYCOL+1)
        IF (FCHAR(4:5) == 'ME') NLIST = MAX(MAXX,MAXX2)
 
        ALLOCATE(DLIST(NLIST),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'DLIST IN DOCS1',NLIST)
           GOTO 9995
        ENDIF

        IF (FCHAR(4:5) == 'ST') THEN
C          DOC FILE COL STATISTICS--------------------------- 'DOC STAT'

           CALL RDPRI1S(KEYCOL,NOT_USED,PROMPT(1:NLETP),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9997
 
           IF (KEYCOL > MAXX) THEN
              CALL ERRT(102,'MAX. COL. IN DOC. FILE',MAXX)
              GOTO 9995
           ENDIF

           IREG = KEYCOL + 1    ! DOCBUF COLUMN
           NGOT = 0
           VMIN =  HUGE(VMIN)
           VMAX = -HUGE(VMIN)
           VSUM = 0.0
           VSQ  = 0.0

           DO KEY=1,MAXY
              NREGS = DOCBUF((KEY - 1) * MAXX + 1) 
              !write(6,*) nregs,DOCBUF((KEY - 1) * MAXX + IREG)
 
              IF (NREGS > 0 .AND. KEYCOL <= NREGS) THEN
                 VAL  = DOCBUF((KEY - 1) * MAXX + IREG)
                 VMIN = MIN(VMIN,VAL)
                 VMAX = MAX(VMAX,VAL)
                 VSUM = VSUM + VAL
                 VSQ  = VSQ  + VAL * VAL
                 NGOT = NGOT + 1
              ENDIF
           ENDDO

           IF (NGOT <= 0) THEN
              CALL ERRT(102,'NO VALUES IN COL.',KEYCOL)
              GOTO 9995
           ELSE
              VAVG = VSUM / FLOAT(NGOT)

              VSIG = 0.0
              VTOP  = VSQ - VSUM * VSUM / FLOAT(NGOT)
              IF (NGOT > 1) VSIG = SQRT(VTOP / FLOAT(NGOT - 1))    
           ENDIF

          WRITE(NOUT,90) KEYCOL,NGOT,VMIN,VMAX,VSUM,VAVG,VSIG
90        FORMAT('  COLUMN:', I2,
     &           '  VALUES:', I6,
     &           '  MIN:',    1PG10.3,
     &           '  MAX:',    1PG10.3,
     &           '  SUM:',    1PG12.5,
     &           '  AVG:',    1PG12.5,
     &           '  SIG:',    1PG12.5)

          CALL REG_SET_NSEL(1,5,FLOAT(NGOT),VMIN,VMAX,VSUM,VAVG,IRTFLG)
          CALL REG_SET_NSEL(6,6,VSIG,IRTFL)

        ELSEIF (FCHAR(4:5) == 'SO' .OR. FCHAR(4:5) == 'IT') THEN
C          SORT THE INPUT DOC FILE--------------------------- 'DOC SORT'
C          SORT THE INPUT DOC FILE--------------------------- 'AT IT'  
           NEWKEY = 0

           I1    = 1
           I2    = IKEYS
           ISTEP = 1
           IF (REVERSE) THEN
C             DESCENDING ORDER
              I1    = IKEYS
              I2    = 1
              ISTEP = -1
           ENDIF

           DO IROW = I1,I2,ISTEP
               IKEY = SORTED(IROW)
               IF (RENUMBER) THEN
C                 RENUMBER THE KEY COLUMN
                  NEWKEY   = NEWKEY + 1
                  IKEYT    = NEWKEY
               ELSE
C                 KEEP ORIGINAL KEYS 
                  IKEYT    = IKEY
               ENDIF
               DO ICOL = 2,MAXX
                  DLIST(ICOL) = DOCBUF((IKEY - 1) * MAXX + ICOL)
               ENDDO

C              PUSH DLIST INTO DOC. FILE
               NVAL  = MAXX - 1
               CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),NVAL,IRTFLG)

           ENDDO

        ELSEIF (FCHAR(4:5) == 'SP') THEN
C          SPLIT THE INPUT DOC FILE------------------------- 'DOC SPLIT'
           NVAL    = MAXX - 1
           NEWKEY1 = 0
           NEWKEY2 = 0
           DO IY = 1,MAXY,2
               KEY1 = DOCBUF((IY-1) * MAXX + 1)
               IF (KEY1 > 0) THEN
C                 PUSH KEY INTO FIRST FILE
                  DO ICOL = 2,MAXX
                     DLIST(ICOL) = DOCBUF((IY - 1) * MAXX + ICOL)
                  ENDDO
                  NEWKEY1 = NEWKEY1 + 1
C                 PUSH DLIST INTO FIRST DOC. FILE
                  CALL LUNDOCWRTDAT(NICDOCOUT,NEWKEY1,DLIST(2),
     &                              NVAL,IRTFLG)
               ENDIF

               IF (IY  <  MAXY) THEN
C                 PUSH NEXT KEY INTO SECOND FILE
                  KEY2 = DOCBUF((IY) * MAXX + 1)
                  IF (KEY2 > 0) THEN
                     DO ICOL = 2,MAXX
                        DLIST(ICOL) = DOCBUF((IY) * MAXX + ICOL)
                     ENDDO
                     NEWKEY2 = NEWKEY2 + 1
                     CALL LUNDOCWRTDAT(NICDOCOUT2,NEWKEY2,DLIST(2),
     &                                 NVAL,IRTFLG)
                 ENDIF
              ENDIF
           ENDDO

        ELSEIF (FCHAR(4:5) == 'SL') THEN
C          SLICE THE INPUT DOC FILE------------------------- 'DOC SLICE'

           NVAL = NILMAX
           CALL RDPRAI(INUMBR,NILMAX,NVAL,0,0,
     &          'KEYS TO PLACE IN NEW DOC FILE','F',IRTFLG)
           IF (IRTFLG == -1) GOTO 9995

           NEWKEY1 = 0

           DO I = 1,NVAL
              IY = INUMBR(I)

              IF (IY <= 0 .OR. IY > MAXY) THEN
                 CALL ERRT(102,'BAD KEY',IY)
                 GOTO 9995
              ENDIF

              KEY1 = DOCBUF((IY-1) * MAXX + 1)

C             PUSH KEY INTO SLICE FILE
              DO ICOL = 2,MAXX
                 DLIST(ICOL) = DOCBUF((IY - 1) * MAXX + ICOL)
              ENDDO

              NEWKEY1 = NEWKEY1 + 1
C             PUSH DLIST INTO FIRST DOC. FILE
              CALL LUNDOCWRTDAT(NICDOCOUT,NEWKEY1,DLIST(2),
     &                              MAXX-1,IRTFLG)
           ENDDO

        ELSEIF (FCHAR(4:5) == 'MI') THEN
C          'MIRRORING'  VALUES IN COLUMN: KEYCOL --------- 'DOC MIRROR'

           IF (KEYCOL == 0) THEN
C             MIRROR BY KEY EXISTANCE (NOT REGISTER CONTENTS)
              DLIST(2) = 1.0
              DO IKEY = 1,MAXY
                 IGOT = DOCBUF((IKEY - 1) * MAXX + 1)
                 IF (IGOT <= 0) THEN
C                   NONEXISTANT KEY, PUSH 1.0 INTO DOC. FILE
                    CALL LUNDOCWRTDAT(NICDOCOUT,IKEY,
     &                                DLIST(2),1,IRTFLG)
                 ENDIF
              ENDDO
              GOTO 9990
           ENDIF

           NEWKEY  = 0
           IKEY    = SORTED(1)
           LASTVAL = DOCBUF((IKEY - 1) * MAXX + KEYCOL + 1)

C          NO SENSE TO OTHER MISSING DOC COLUMNS ??
           DO I = 1,NLIST
              DLIST(I) = 0.0
           ENDDO

           DO IROW = 1,IKEYS
              IKEY = SORTED(IROW)
              IVAL = DOCBUF((IKEY - 1) * MAXX + KEYCOL + 1)
              IF (IVAL > (LASTVAL-1)) THEN
                 DO IT=LASTVAL+1,IVAL-1
C                   FILL IN MISSING VALUES FROM KEY COLUMN
                    NEWKEY   = NEWKEY + 1

C                   KEYS ARE RENUMBERED IF NOT FILLING FIRST COL.
                    DLIST(KEYCOL+1) = IT

C                   PUSH DLIST INTO DOC. FILE
                    NVAL  = NLIST - 1
                    IKEYT = NEWKEY
                    CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
     &                                NVAL,IRTFLG)
                 ENDDO
              ENDIF
              LASTVAL = IVAL
           ENDDO
  
        ELSEIF (FCHAR(4:5) == 'ME') THEN
C          MERGING  VALUES IN COLUMN: KEYCOL -------------- 'DOC MERGE'

           MAXXT = MAX(MAXX,MAXX2)

           IF (KEYCOL == 0) THEN
C             MERGING BY KEY
              MAXYT = MAX(MAXY,MAXY2)

              DO KEYT = 1,MAXYT
                 ICOUNT1 = 0
                 IF (KEYT <= MAXY) 
     &              ICOUNT1 = DOCBUF((KEYT - 1) * MAXX + 1)
                 ICOUNT2 = 0

                 IF (KEYT <= MAXY2) 
     &               ICOUNT2 = DOCBUF2(1,KEYT)

                 IF (KEYT <= MAXY .AND. ICOUNT1 > 0 .AND. 
     &              ICOUNT2 == 0) THEN
C                   KEY1 EXISTS AND KEY2 DOES NOT EXIST, PUSH DLIST 
C                   FROM FILE 1 INTO OUTPUT FILE
                    DO IREG = 1,MAXX
                       DLIST(IREG) = DOCBUF((KEYT - 1) * MAXX + IREG)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    NVAL  = MAXX - 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,KEYT,DLIST(2),
     &                                NVAL,IRTFLG)

                 ELSEIF (KEYT <= MAXY2 .AND. ICOUNT2 .NE. 0) THEN
C                   KEY2 EXISTS, PUSH DLIST FROM FILE 2 INTO OUTPUT FILE
                    DO IREG = 1,MAXX2
                       DLIST(IREG) = DOCBUF2(IREG,KEYT)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    NVAL  = MAXX2 - 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,KEYT,DLIST(2),
     &                                NVAL,IRTFLG)

                 ENDIF
              ENDDO

           ELSE                    
C             MERGING BY COLUMN OTHER THAN KEY
              KEYNEW = 0

C             POINT TO NEXT VALUE IN SORTED LIST FROM FILE 1
              IGO1     = 1
              KEY1     = SORTED(IGO1)
              VALNEXT1 = DOCBUF((KEY1 - 1) * MAXX + KEYCOL + 1)

C             POINT TO NEXT VALUE IN SORTED LIST FROM FILE 2
              IGO2     = 1
              KEY2     = SORTED2(IGO2)
              VALNEXT2 = DOCBUF2( KEYCOL + 1, KEY2)
             
C             FIND OUTPUT VALUES
              MAXKEYS = MAX(IKEYS,IKEYS2)

              DO WHILE (IGO1 <= IKEYS .OR. IGO2 <= IKEYS2)

C                FIND KEY FOR THIS SORTED VALUE FROM FIRST FILE
                 IF (IGO1 > IKEYS .AND. IGO2 <= IKEYS2) THEN
C                   FILE 1 FINISHED BUT STILL IN LIST FROM FILE 2 
C                   POINT TO NEXT VALUE IN SORTED LIST FROM FILE 2
                    KEY2 = SORTED2(IGO2)

C                   SAVE VALUES FROM FILE 2
                    NVAL   = MAXX2 - 1
                    KEYNEW = KEYNEW + 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DOCBUF2(2,KEY2),
     &                                NVAL,IRTFLG)

C                   INCREMENT IGO2
                    IGO2 = IGO2 + 1

                 ELSEIF (IGO1 <= IKEYS .AND. IGO2 > IKEYS2) THEN
C                   FILE 2 FINISHED BUT STILL IN LIST FROM FILE 1 
                    KEY1     = SORTED(IGO1)
                    DO IREG = 1,MAXX
                       DLIST(IREG) = DOCBUF((KEY1 - 1) * MAXX + IREG)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    NVAL  = MAXX - 1
                    KEYNEW = KEYNEW + 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DLIST(2),
     &                                NVAL,IRTFLG)

C                   INCREMENT IGO1
                    IGO1 = IGO1 + 1

                 ELSEIF (IGO1 <= IKEYS) THEN
C                   STILL IN LIST FROM FILE 1 AND FILE 2

                    IF (VALNEXT1  <  VALNEXT2)THEN
C                      NOT IN FILE 2, SAVE VALUES FROM FILE 1
                       DO IREG = 1,MAXX
                          DLIST(IREG) = DOCBUF((KEY1 - 1) * MAXX + IREG)
                       ENDDO

C                      PUSH DLIST INTO DOC. FILE
                       NVAL   = MAXX - 1
                       KEYNEW = KEYNEW + 1
                       CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DLIST(2),
     &                                NVAL,IRTFLG)

C                      INCREMENT IGO1
                       IGO1 = IGO1 + 1
                       IF (IGO1 <= IKEYS) THEN
                          KEY1     = SORTED(IGO1)
                          VALNEXT1 = DOCBUF((KEY1 - 1)*MAXX+KEYCOL + 1)
                       ENDIF

                    ELSEIF (VALNEXT1 == VALNEXT2) THEN
C                      SAME KEYCOL VALUES IN BOTH, SAVE VALUES FROM  2

                       NVAL   = MAXX2 - 1
                       KEYNEW = KEYNEW + 1
                       CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,
     &                                DOCBUF2(2,KEY2),NVAL,IRTFLG)

C                      INCREMENT IGO1
                       IGO1 = IGO1 + 1
                       IF (IGO1 <= IKEYS) THEN
                          KEY1     = SORTED(IGO1)
                          VALNEXT1 = DOCBUF((KEY1 - 1)*MAXX+KEYCOL + 1)
                       ENDIF
C                      INCREMENT IGO2
                       IGO2 = IGO2 + 1
                       IF (IGO2 <= IKEYS2) THEN
                          KEY2     = SORTED2(IGO2)
                          VALNEXT2 = DOCBUF2(KEYCOL + 1, KEY2)
                       ENDIF

                    ELSE
C                      VALNEXT1 IS > VALNEXT2,    
C                      UPDATE VALNEXT2, SAVING ANY PASSED VALUES FROM 2
                       NEEDINC = 1
                       DO IGO2T = IGO2,IKEYS2
                          KEY2     = SORTED2(IGO2T)
                          VALNEXT2 = DOCBUF2(KEYCOL +1,KEY2)

                          IF (VALNEXT1 .GE. VALNEXT2) THEN
C                            SAVE VALUES FROM FILE 2, KEEP GOING if >

                             NVAL   = MAXX - 1
                             KEYNEW = KEYNEW + 1
                             CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,
     &                                DOCBUF2(2,KEY2),NVAL,IRTFLG)
                          ELSE
C                            POINT TO THIS VALUES IN SORTED LIST FROM #2
                             NEEDINC = 0
                             EXIT
                          ENDIF
                       ENDDO   !DO IGO2T = IGO2,IKEYS2

C                      INCREMENT IGO2
                       IGO2     = IGO2T + NEEDINC
                       IF (IGO2 <= IKEYS2) THEN
                          KEY2     = SORTED2(IGO2)
                          VALNEXT2 = DOCBUF2(KEYCOL +1,KEY2)
                       ENDIF

                    ENDIF   !   VALNEXT1 IS > VALNEXT2
                 ENDIF !   IF (IGO1 <= IKEYS)
              ENDDO
           ENDIF

        ENDIF

C       CLOSE THE OUTPUT DOC. FILE(S)
9990    CLOSE(NDOCOUT)
        CLOSE(NDOCOUT2)

C       DEALLOCATE ALLOCATABLE ARRAYS
9995    IF (ALLOCATED(DLIST))   DEALLOCATE(DLIST)
        IF (ALLOCATED(SORTED2)) DEALLOCATE(SORTED2)
        IF (ALLOCATED(SORTED))  DEALLOCATE(SORTED)
        CLOSE(NDOCIN2)

C       DEALLOCATE DOC. FILE MEMORY
9997    IF (FCHAR(4:5) == 'ME') THEN
C          USED TWO INPUT DOC FILES
           IF (ASSOCIATED(DOCBUF2)) DEALLOCATE(DOCBUF2)
        ENDIF

9999    RETURN
	END


C       ----------------------- SORTIT --------------------------------

        SUBROUTINE SORTIT(DOCBUF,MAXX,MAXY,KEYCOL,SORTED,
     &                    IKEYS,RET_KEY,UNIQUE,IRTFLG)

        REAL, DIMENSION(MAXX,MAXY), INTENT(IN)  :: DOCBUF
        REAL, DIMENSION(MAXY), INTENT(INOUT)    :: SORTED
        INTEGER,INTENT(IN)                      :: MAXX,MAXY,KEYCOL
        LOGICAL,INTENT(IN)                      :: RET_KEY,UNIQUE
        INTEGER,INTENT(OUT)                     :: IKEYS,IRTFLG

        REAL, DIMENSION(MAXY)                   :: RDUM,RKEYARAY

C       TRANSFER DATA TO SORT INPUT ARRAYS
        IKEYS    = 0
        KEYCOLP1 = KEYCOL + 1

        DO IROW = 1, MAXY
           IF (DOCBUF(1,IROW) > 0) THEN
C             KEY IS USED
              IKEYS = IKEYS + 1

              IF (RET_KEY) THEN
C                RETURN THE KEY NUMBER IN SORTED
                 SORTED(IKEYS) = IROW
              ELSE
C                RETURN THE VALUE IN SORTED
                 SORTED(IKEYS) = DOCBUF(KEYCOLP1,IROW)
              ENDIF

C             SORT BY THE VALUE IN COLUMN: KEYCOL
              RKEYARAY(IKEYS)  = DOCBUF(KEYCOLP1,IROW)
              RDUM(IKEYS)      = 0.0
           ENDIF
        ENDDO

C       SORT BY VALUE IN RKEYARAY, ONLY INTERESTED IN SORTED
        CALL SORT(RKEYARAY,RDUM,SORTED,IKEYS)

        IF (UNIQUE) THEN
C          ONLY WANT UNIQUE VALUES FROM COLUMN: KEYCOL
           IKEYSNEW = 0
C          INITIALIZE DLAST TO ENUSRE KEEPING FIRST VALUE IN KEYCOL
           IT       = SORTED(1)
           DLAST    = DOCBUF(KEYCOLP1,IT) + 1000

           DO I = 1,IKEYS
              IT  = SORTED(I)
              VAL = DOCBUF(KEYCOLP1,IT)
              IF (VAL .NE. DLAST) THEN
C                VAL IS NOT SAME AS PREVIOUS VALUE IN KEYCOL, KEEP IT
                 IKEYSNEW         = IKEYSNEW + 1
                 SORTED(IKEYSNEW) = IT
                 DLAST            = VAL
              ENDIF
           ENDDO
           IKEYS = IKEYSNEW
        ENDIF
        IRTFLG = 0

        RETURN
        END
 
C       ----------------------- DOCCREATE ----------------------------

	SUBROUTINE DOCCREATE(MAXDIM)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        INTEGER,INTENT(IN)               :: MAXDIM
	CHARACTER(LEN=MAXNAM)            :: DOCNAM3
	CHARACTER(LEN=1)                 :: NULL
        LOGICAL                          :: ERRI2
        REAL,ALLOCATABLE                 :: DLIST(:)

        INTEGER, DIMENSION(1)            :: ILIST
        COMMON   ILIST

        INTEGER, PARAMETER                ::  NDOCOUT = 72

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

	NULL = CHAR(0)

C       CREATE OUTPUT DOC FILE ------------------------- 'DOC CREATE'

        CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,NICDOCOUT,.FALSE.,' ',
     &                     .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

10      CALL RDPRI1S(KEYCOL,NOT_USED,
     &               'REGISTER TO BE FILLED (0 IS KEY)',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
        IF (ERRI2(KEYCOL,IDUM,1,0,6,0,0)) GOTO 10

        NUMB = MAXDIM
        CALL RDPRAI(ILIST,MAXDIM,NUMB,1,MAXDIM,'NUMBERS',
     &                 NULL,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        NLIST = MAX(KEYCOL,1)
        ALLOCATE(DLIST(NLIST),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'DLIST IN DOCCREATE',NLIST)
           RETURN
        ENDIF

C       FILL UNUSED COLUMNS WITH ZERO'S
        DO I = 1, NLIST
           DLIST(I) = 0.0
        ENDDO

C       IF FILLING KEYS PUT A 1.0 IN FIRST REGISTER COL.
        IF (KEYCOL == 0) DLIST(1) = 1.0

        DO I=1,NUMB
           IF (KEYCOL <= 0) THEN
              IKEY          = ILIST(I)
           ELSE
              IKEY          = I
              DLIST(KEYCOL) = ILIST(I)
           ENDIF

C          PUSH DLIST INTO DOC. FILE
           CALL LUNDOCWRTDAT(NICDOCOUT,IKEY,DLIST,NLIST,IRTFLG)
        ENDDO

        IF (ALLOCATED(DLIST)) DEALLOCATE(DLIST)

#ifdef USE_MPI
        IF (MYPID == 0) THEN
           CALL FLUSHFILE(NICDOCOUT)
           CLOSE(NICDOCOUT)
        ENDIF
        CALL MPI_BARRIER(ICOMM,IERR)
#else
        IF (MYPID <= 0) CLOSE(NDOCOUT)
#endif

        RETURN
        END


C       ----------------------- DOCRAN --------------------------------

	SUBROUTINE DOCRAN(MAXX, MAXY, DOCBUF, DLIST)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

	CHARACTER(LEN=MAXNAM)             :: DOCNAM3
	CHARACTER(LEN=1)                  :: NULL

        REAL                              :: DOCBUF(MAXX*MAXY)
        REAL                              :: DLIST(MAXX)
        INTEGER, ALLOCATABLE              :: KEYLIST(:)
        LOGICAL                           :: NEWFILE

        INTEGER, PARAMETER                ::  NDOCOUT = 71

	NULL = CHAR(0)

C       RANDOMLY SAMPLE THE INPUT DOC FILE---------------- 'DOC RAN'

        CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,NICDOCOUT,.FALSE.,' ',
     &                     .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        CALL RDPRM1S(PERCENT,NOT_USED,'PERCENT WANTED',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        IF (MAXX <= 0 .OR. MAXY <= 0) GOTO 9999

        ALLOCATE(KEYLIST(MAXY),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'KEYLIST IN DOCS1',MAXY)
           RETURN
        ENDIF

        IGOT = 0
        DO IKEY = 1,MAXY
C           KEYS MAY NOT BE CONSECUTIVE SO MUST MAKE A LIST
            ILOC = (IKEY - 1) * MAXX + 1
            IF (DOCBUF(ILOC) > 0) THEN
               IGOT          = IGOT + 1
               KEYLIST(IGOT) = IKEY
            ENDIF
        ENDDO

C       FIND NUMBER OF NEEDED KEYS
        NEEDED = PERCENT * IGOT * 0.01
        IRAN   = 0
        NLIST  = MAXX - 1
        DO
          IF (IRAN .GE. NEEDED) EXIT

          IRAN = IRAN + 1
C         CREATE RANDOM IVAL IN RANGE 0...IGOT-1
          CALL RANDOM_NUMBER(OUT)

          IVAL    = 1.5 + OUT * FLOAT(IGOT-1)
          IKEY    = KEYLIST(IVAL)

          DO ICOL = 2,MAXX
             DLIST(ICOL-1) = DOCBUF((IKEY - 1) * MAXX + ICOL)
          ENDDO

C         PUSH DLIST INTO DOC. FILE
          CALL LUNDOCWRTDAT(NICDOCOUT,IKEY,DLIST,NLIST,IRTFLG)

C         SELECT RANDOMLY WITHOUT DUPLICATION OF SELECTED VALUES
          KEYLIST(IVAL) = KEYLIST(IGOT)
          IGOT          = IGOT - 1
        ENDDO

C       DEALLOCATE ALLOCATABLE ARRAYS
        IF (ALLOCATED(KEYLIST)) DEALLOCATE(KEYLIST)
 
9999    CLOSE(NDOCOUT)

	END

C       ----------------------- DOCRENUMBER --------------------------

	SUBROUTINE DOCRENUMBER(MAXX, MAXY, DOCBUF, DLIST)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        INTEGER, INTENT(IN)               :: MAXX,MAXY
        REAL, DIMENSION(MAXX*MAXY)        :: DOCBUF
        REAL, DIMENSION(MAXX)             :: DLIST
	CHARACTER(LEN=MAXNAM)             :: DOCNAM3
	CHARACTER(LEN=1)                  :: NULL
        LOGICAL                           :: NEWFILE

        INTEGER, PARAMETER                ::  NDOCOUT = 72

	NULL = CHAR(0)

C       ------------- RENUMBER THE INPUT DOC FILE-------- 'DOC RENUMBER'

        CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,NICDOCOUT,.FALSE.,' ',
     &                     .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       DOC REN OPERATION USES NON-STANDARD DOCBUF (WITHOUT KEYS)
C       HAVING LISTING OF ALL LINES IN THE DOC FILE IN ORDER
C       write(6,*) 'maxx,maxy:',maxx,maxy

        IF (MAXX <= 0 .OR. MAXY <= 0) GOTO 9999
           
        NLIST = MAXX

        DO IKEY = 1,MAXY
            DO ICOL = 1,MAXX
               DLIST(ICOL) = DOCBUF((IKEY - 1) * MAXX + ICOL)
            ENDDO

C           PUSH DLIST INTO DOC. FILE
            CALL LUNDOCWRTDAT(NICDOCOUT,IKEY,DLIST,NLIST,IRTFLG)
        ENDDO

9999    CLOSE(NDOCOUT)

	END

C       -------------RE KEY THE INPUT DOC FILE --------------- 'DOC KEY'

	SUBROUTINE DOCREKEY(MAXX, MAXY, DOCBUF, DLIST)

        IMPLICIT NONE
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        INTEGER, INTENT(IN)   :: MAXX,MAXY
        REAL                  :: DOCBUF(MAXX,MAXY)
        REAL                  :: DLIST(MAXX)
	CHARACTER(LEN=MAXNAM) :: DOCNAM3

        LOGICAL               :: ADDEXT,GETNAME
        LOGICAL               :: ISOLD,APPEND,MESSAGE,NEWFILE
        INTEGER               :: IRTFLG, NLET, NICDOCOUT, NLIST 
        INTEGER               :: NEWKEY, IKEY, ICOUNT, ICOL, ICOUNTLAS        

        INTEGER, PARAMETER    :: NDOCOUT = 72

        ADDEXT  = .TRUE.
        GETNAME = .TRUE.
        ISOLD   = .FALSE.
        APPEND  = .FALSE.
        MESSAGE = .TRUE.
        IRTFLG  = -8         ! NO IC USE

        CALL OPENDOC(DOCNAM3,ADDEXT,NLET,NDOCOUT,NICDOCOUT,GETNAME,
     &           'RE-KEYED OUTPUT DOCUMENT',ISOLD,APPEND,MESSAGE,
     &            NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
 
C       write(6,*) 'maxx,maxy:',maxx,maxy
        IF (MAXX <= 0 .OR. MAXY <= 0) GOTO 9999

C       COPY ONE OR MORE OTHER REGISTERS TO OUTPUT
        NLIST  = MAXX
        IF (FCHAR(8:8) == 'O') NLIST = 1

        NEWKEY = 0
        DO IKEY = 1,MAXY

C          DOCBUF HAS ICOUNT IN FIRST COL
           ICOUNT = DOCBUF(1,IKEY)

           IF (ICOUNT > 0) THEN
C             GOT VALID DOC FILE DATA LINE

C             PUT KEY IN FIRST COL OF OUTPUT DOC FILE
              DLIST(1) = IKEY

C             COPY NLIST INPUT DOC FILE COLUMNS
              DO ICOL = 2,NLIST
                  DLIST(ICOL) = DOCBUF(ICOL,IKEY)
              ENDDO

C             PUSH DLIST INTO OUTPUT DOC. FILE
              NEWKEY = NEWKEY + 1
              CALL LUNDOCWRTDAT(NICDOCOUT,NEWKEY,DLIST,NLIST,IRTFLG)

              ICOUNTLAS = ICOUNT
           ENDIF
        ENDDO
 
9999    CLOSE(NDOCOUT)

	END



C       ----------------------- DOCCOMBINE --------------------------

	SUBROUTINE DOCCOMBINE()

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:,:), POINTER      :: DOCBUF
	CHARACTER(LEN=MAXNAM)              :: FILPAT,DOCNAM1,DOCNAM3
        LOGICAL                            :: NEWFILE

        INTEGER, PARAMETER                ::  NDOCIN  = 70
        INTEGER, PARAMETER                ::  NDOCIN2 = 71
        INTEGER, PARAMETER                ::  NDOCOUT = 72

C       COMBINE THE INPUT DOC FILES -------------------- 'DOC COMBINE'

C       SPACE FOR DOC FILE LIST FROM CMLIMIT
        NILMAX = NIMAX

C       ASK FOR DOC FILE LIST
        CALL FILELIST(.TRUE.,NDOCIN2,FILPAT,NLETP,INUMBR,NILMAX,NFILE,
     &      'TEMPLATE FOR DOC. FILE SERIES',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        IF (NFILE > 0)  THEN
           WRITE(NOUT,2001) NFILE
2001       FORMAT('  Number of document files to be combined: ',I0)
        ELSE
           CALL ERRT(101,'No document files entered!',IER)
           GOTO 9999
        ENDIF

        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,NICDOCOUT,.TRUE.,
     &       'OUTPUT DOCUMENT',.FALSE.,.TRUE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        IKEYNOW = 0

        DO IFILE = 1,NFILE
C          DOC COM OPERATION USES STANDARD DOCBUF (WITH KEYS)

C          MAKE DOC FILE NAME
           CALL FILGET(FILPAT,DOCNAM1,NLETP,INUMBR(IFILE),IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
           CALL FILNAMANDEXT(DOCNAM1,DATEXC,DOCNAM1,NLET,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
 
           MAXX = 0
           MAXY = 0
           CALL GETDOCDAT(' ',.FALSE.,DOCNAM1,
     &                 NDOCIN,.TRUE.,MAXX, MAXY,DOCBUF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           NLIST = MAXX - 1

           DO IKEY = 1,MAXY
              ICOUNT = DOCBUF(1,IKEY)
              IF (ICOUNT > 0) THEN
C                KEY EXISTS, PUSH LINE INTO COMBINED DOC. FILE
                 IKEYNOW = IKEYNOW + 1
                 CALL LUNDOCWRTDAT(NICDOCOUT,IKEYNOW,DOCBUF(2,IKEY),
     &                             NLIST,IRTFLG)
              ENDIF
           ENDDO
           CLOSE(NDOCIN)

C          DEALLOCATE DOC. FILE MEMORY
           IF (ASSOCIATED(DOCBUF)) DEALLOCATE(DOCBUF)
        ENDDO

9999    CLOSE(NDOCOUT)
        CLOSE(NDOCIN)

C       DEALLOCATE DOC. FILE MEMORY
        IF (ASSOCIATED(DOCBUF)) DEALLOCATE(DOCBUF)

        RETURN
	END



C       ----------------------- DOCDOWN ----------------------------

	SUBROUTINE DOCDOWN()

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

	CHARACTER(LEN=MAXNAM)             :: DOCNAM
	CHARACTER(LEN=160)                :: RECLIN
        REAL, DIMENSION(9)                :: DLIST
        LOGICAL                           :: WARNIT,NEWFORM


	DATA NDOCINT,NDOCOUTT/70,72/

        WARNIT = .TRUE.

C       OPEN INPUT DOC. FILE
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOCINT,NDOCIN,.TRUE.,
     &           'INPUT DOCUMENT',.TRUE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       OPEN OUTPUT DOC. FILE
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOCOUTT,NDOCOUT,.TRUE.,
     &          'OUTPUT DOCUMENT',.FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        DO
          READ(NDOCIN,84,IOSTAT=IERR) RECLIN
84        FORMAT(A160)

          IF (IERR  <  0) THEN
C             END OF FILE
              GOTO 9999
           ENDIF

          IF (RECLIN(2:2) == ';') THEN
              WRITE(NDOCOUT,90,IOSTAT=IERR) RECLIN
90            FORMAT(A)
             
              CYCLE
          ENDIF

          NEWFORM = .TRUE.
          READ(RECLIN,*,IOSTAT=IERR) IKEY,ICOUNT

          IF (IERR > 0) THEN
C            ERROR ON READ, TRY OLD DOC. FILE FORMAT
             READ(RECLIN,83,IOSTAT=IERR) IKEY,ICOUNT
83           FORMAT(I6,I1,10000F12.6)

             NEWFORM = .FALSE.

             IF (IERR > 0) THEN
C               ERROR ON READ USING OLD FORMAT ALSO, RETURN
                WRITE(NOUT,91) RECLIN
91              FORMAT(' *** UNABLE TO INTERPRET DOC FILE LINE: ',A)
                CALLERRT(100,'DOCCOPY',NE)
                GOTO 9999
             ENDIF
          ENDIF

          IF (ICOUNT <= 0) THEN
              WRITE(NOUT,*) ' EMPTY DOCUMENT FILE LINE SKIPPED'
              CYCLE

          ELSEIF (IKEY  <  0) THEN
              WRITE(NOUT,*) ' CONTINUATION LINE SKIPPED IN DOC FILE'
              CYCLE

          ELSEIF (IKEY == 0) THEN
C            KEY THAT WILL NOT FIT IN DBUF SENDS ERROR MSG.
             WRITE(NOUT,*)' SKIPPED ILLEGAL KEY NUMBER: 0 IN DOC FILE'
             CYCLE

          ELSEIF (IKEY > 999999) THEN
C            KEY THAT WILL NOT FIT IN OLD DOC FILE SENDS ERROR MSG.
             IF (WARNIT) THEN
                WRITE(NOUT,93) IKEY
93              FORMAT('  ** KEY: ',I9,'  NOT RETRIEVED')
                WARNIT = .FALSE.
             ENDIF

          ELSEIF (ICOUNT > 9) THEN
C            KEY THAT WILL NOT FIT IN OLD DOC FILE SENDS ERROR MSG.
             IF (WARNIT) THEN
                WRITE(NOUT,*) ' ** REGISTERS > 9 NOT RETRIEVED'
                WARNIT = .FALSE.
             ENDIF
             ICOUNT = 9
          ENDIF

          BACKSPACE(NDOCINT)
          IF (NEWFORM) THEN
C            TRY NEW DOC. FILE FORMAT
             READ(NDOCIN,*,IOSTAT=IERR)IKEYT,ICOUNTT,
     &                                 (DLIST(I),I=1,ICOUNT)
C            IF ERROR ON READ, TRY OLD DOC. FILE FORMAT
             IF (IERR .NE. 0) THEN
C               TRY READING AGAIN USING OLD FORMAT
                BACKSPACE(NDOCINT)
                NEWFORM = .FALSE.
             ENDIF
          ENDIF
          IF (.NOT. NEWFORM) THEN
C            TRY OLD DOC. FILE FORMAT
             READ(NDOCIN,83,IOSTAT=IERR) IKEYT,ICOUNTT,
     &                                   (DLIST(I),I=1,ICOUNT)
          ENDIF

          IF (IERR == 0) THEN
             IF (IKEY <= 99999) THEN
                WRITE(NDOCOUT,95)IKEY,ICOUNT,(DLIST(I),I=1,ICOUNT)
95              FORMAT(I5,' ',I1,9G12.3)
             ELSE
                WRITE(NDOCOUT,96)IKEY,ICOUNT,(DLIST(I),I=1,ICOUNT)
96              FORMAT(I6,I1,9G12.3)
             ENDIF
          ENDIF
       ENDDO

9999   CLOSE(NDOCIN)
       CLOSE(NDOCOUT)

       END


C       ----------------------- DOCBOOT --------------------------------

	SUBROUTINE DOCBOOT(MAXX, MAXY, DOCBUF, DLIST)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC' 

	CHARACTER(LEN=MAXNAM)              :: DOCNAM3
	CHARACTER(LEN=1)                   :: NULL

        REAL                               :: DOCBUF(MAXX*MAXY)
        REAL                               :: DLIST(MAXX)
        INTEGER, ALLOCATABLE               :: KEYLIST(:)
        INTEGER, ALLOCATABLE               :: KEYLISTOUT(:)
        LOGICAL                            :: NEWFILE

        INTEGER, PARAMETER                 ::  NDOCOUT = 71

	NULL = CHAR(0)

C       RANDOMLY SAMPLE THE INPUT DOC FILE---------------- 'DOC BOOT'

        CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,NICDOCOUT,.FALSE.,' ',
     &                     .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN


c        CALL RDPRI1S(IWANT,NOT_USED,
c     &               'NUMBER OF SELECTIONS WANTED',IRTFLG)
c        IF (IRTFLG .NE. 0) RETURN
 
        IF (MAXX <= 0 .OR. MAXY <= 0) GOTO 9999

        ALLOCATE(KEYLIST(MAXY),KEYLISTOUT(MAXY),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'DOCS1; KEYLIST',2*MAXY)
           RETURN
        ENDIF

        IGOT = 0
        DO IKEY = 1,MAXY
C           KEYS MAY NOT BE CONSECUTIVE SO MUST MAKE A LIST
            ILOC = (IKEY - 1) * MAXX + 1
            IF (DOCBUF(ILOC) > 0) THEN
C              KEY IS IN USE
               IGOT          = IGOT + 1
               KEYLIST(IGOT) = IKEY
            ENDIF
        ENDDO
        IWANT = IGOT

C       SELECT IWANT ENTRIES RANDOMLY WITH POSSIBLE DUPLICATION 
C       OF THE SELECTED ENTRIES
        DO IRAN = 1,IWANT

C         CREATE RANDOM IVAL IN RANGE 1...IGOT
          CALL RANDOM_NUMBER(OUT)

          IVAL             = MIN(IGOT,MAX(1,INT(OUT*IGOT+0.5)))
          KEYLISTOUT(IRAN) = KEYLIST(IVAL)
        ENDDO

C       MAKE LIST OF THE VALUES IN COL 1 FOR THE SELECTED ENTRIES
        DO I = 1,IWANT
           IKEY       = KEYLISTOUT(I)
           KEYLIST(I) = DOCBUF((IKEY - 1) * MAXX + 2)
        ENDDO

C       SORT KEYS ORDERING KEYLIST BY VALUES IN FIRST COLUMN
        CALL SORTINT(KEYLIST, KEYLISTOUT, IWANT)

        NLIST  = MAXX - 1
        DO I = 1,IWANT

          IKEY = KEYLISTOUT(I)
          DO ICOL = 2,MAXX
             DLIST(ICOL-1) = DOCBUF((IKEY - 1) * MAXX + ICOL)
          ENDDO

C         PUSH DLIST INTO DOC. FILE WITH RENUMBERING OF KEYS
          CALL LUNDOCWRTDAT(NICDOCOUT,I,DLIST,NLIST,IRTFLG)
        ENDDO

C       DEALLOCATE ALLOCATABLE ARRAYS
        IF (ALLOCATED(KEYLIST))    DEALLOCATE(KEYLIST)
        IF (ALLOCATED(KEYLISTOUT)) DEALLOCATE(KEYLISTOUT)
 
9999    CLOSE(NDOCOUT)

	END

@


1.86
log
@added 'doc plot'
@
text
@d37 1
d43 1
a43 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d160 2
a161 2
C          SUBTRACT DOC FILE ------------------------------- 'DOC SUB'
C          AND DOC FILE      ------------------------------- 'DOC AND'
d210 1
d217 3
d247 4
d341 1
a341 1
     &          ((KEYCOL .LT. 0) .OR.
d513 1
a513 1
C          SORT THE INPUT DOC FILE--------------------------- 'AT IT'  '
d564 1
a564 1
               IF (IY .LT. MAXY) THEN
d578 31
d754 1
a754 1
                    IF (VALNEXT1 .LT. VALNEXT2)THEN
d1311 1
a1311 1
          IF (IERR .LT. 0) THEN
d1346 1
a1346 1
          ELSEIF (IKEY .LT. 0) THEN
d1407 1
a1407 1
C       ----------------------- DOCBOOT--------------------------------
@


1.85
log
@doc key   added one paramter
@
text
@d36 1
d82 2
a83 1
        INTEGER, PARAMETER           :: NDOCIN = 70
d112 6
@


1.84
log
@doc separate, ><
@
text
@d569 1
a569 1
                 IF (IGOT .LE. 0) THEN
d619 1
a619 1
                 IF (KEYT .LE. MAXY) 
d623 1
a623 1
                 IF (KEYT .LE. MAXY2) 
d626 1
a626 1
                 IF (KEYT .LE. MAXY .AND. ICOUNT1 > 0 .AND. 
d639 1
a639 1
                 ELSEIF (KEYT .LE. MAXY2 .AND. ICOUNT2 .NE. 0) THEN
d670 1
a670 1
              DO WHILE (IGO1 .LE. IKEYS .OR. IGO2 .LE. IKEYS2)
d673 1
a673 1
                 IF (IGO1 > IKEYS .AND. IGO2 .LE. IKEYS2) THEN
d687 1
a687 1
                 ELSEIF (IGO1 .LE. IKEYS .AND. IGO2 > IKEYS2) THEN
d703 1
a703 1
                 ELSEIF (IGO1 .LE. IKEYS) THEN
d720 1
a720 1
                       IF (IGO1 .LE. IKEYS) THEN
d735 1
a735 1
                       IF (IGO1 .LE. IKEYS) THEN
d741 1
a741 1
                       IF (IGO2 .LE. IKEYS2) THEN
d770 1
a770 1
                       IF (IGO2 .LE. IKEYS2) THEN
d776 1
a776 1
                 ENDIF !   IF (IGO1 .LE. IKEYS)
d922 1
a922 1
           IF (KEYCOL .LE. 0) THEN
d942 1
a942 1
        IF (MYPID .LE. 0) CLOSE(NDOCOUT)
d1083 1
d1087 22
a1108 14
        INTEGER, INTENT(IN)               :: MAXX,MAXY
        REAL, DIMENSION(MAXX,MAXY)        :: DOCBUF
        REAL, DIMENSION(MAXX)             :: DLIST
	CHARACTER(LEN=MAXNAM)             :: DOCNAM3
	CHARACTER(LEN=1)                  :: NULL
        LOGICAL                           :: NEWFILE

        INTEGER, PARAMETER                ::  NDOCOUT = 72

	NULL = CHAR(0)

C       ------------ RE-KEY THE INPUT DOC FILE---------------- 'DOC KEY'

        CALL FILERD(DOCNAM3,NLET,NULL,'RE-KEYED OUTPUT DOCUMENT',IRTFLG)
d1110 1
a1110 5

        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,NICDOCOUT,.FALSE.,' ',
     &                     .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

d1114 1
a1114 1
C       DOCBUF HAS ICOUNT IN FIRST COL
d1116 1
d1120 2
d1123 1
d1130 2
a1131 2
C             COPY ALL MAXX INPUT DOC FILE COLUMNS
              DO ICOL = 2,MAXX
d1294 1
a1294 1
          IF (ICOUNT .LE. 0) THEN
d1343 1
a1343 1
             IF (IKEY .LE. 99999) THEN
d1446 1
a1446 1
        IF (ALLOCATED(KEYLIST)) DEALLOCATE(KEYLIST)
@


1.83
log
@center
@
text
@d35 1
d41 1
a41 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d85 1
a85 1
        IF (FCHAR(4:5) .EQ. 'CR') THEN
d91 1
a91 1
        ELSEIF (FCHAR(4:5) .EQ. 'SH') THEN
d97 1
a97 1
        ELSEIF (FCHAR(4:5) .EQ. 'OL') THEN
d102 1
a102 1
        ELSEIF(FCHAR(4:5) .EQ. 'CO') THEN
d106 5
d120 1
a120 1
        IF (FCHAR(4:5) .EQ. 'RE') NDOCINT = -NDOCIN
d133 1
a133 1
        IF (FCHAR(4:5) .EQ. 'RA') THEN
d137 1
a137 1
        ELSEIF (FCHAR(4:5) .EQ. 'BO') THEN
d141 1
a141 1
        ELSEIF (FCHAR(4:5) .EQ. 'RE') THEN
d145 1
a145 1
        ELSEIF (FCHAR(4:5) .EQ. 'KE') THEN
d149 2
a150 2
        ELSEIF (FCHAR(4:5) .EQ. 'AN' .OR.
     &          FCHAR(4:5) .EQ. 'SU') THEN
d207 1
a207 1
        IF (FCHAR(4:5) .EQ. 'SO') THEN
d213 1
a213 1
        ELSEIF(FCHAR(4:5) .EQ. 'IT') THEN
d216 1
a216 1
        ELSEIF(FCHAR(4:5) .EQ. 'MI') THEN
d221 1
a221 1
        ELSEIF(FCHAR(4:5) .EQ. 'ME') THEN
d234 1
a234 1
         ELSEIF (FCHAR(4:5) .EQ. 'ST') THEN
d244 1
a244 1
           APPENDOK = (FCHAR(4:9) .EQ. 'SORT A')
d251 3
a253 3
        IF (FCHAR(4:5) .EQ. 'SO' .OR. 
     &      FCHAR(4:5) .EQ. 'MI' .OR.
     &      FCHAR(4:5) .EQ. 'ME') THEN
d264 1
a264 1
           IF (FCHAR(4:5) .EQ. 'ME' .AND. MAXX > 0 )    THEN
d270 1
a270 1
           IF (FCHAR(4:5) .EQ. 'SO') THEN
d287 1
a287 1
        ELSEIF (FCHAR(4:5) .EQ. 'IT') THEN
d292 1
a292 1
        ELSEIF (FCHAR(4:5) .EQ. 'SP') THEN
d301 1
a301 1
         IF (FCHAR(4:5) .EQ. 'SO' .AND. KEYCOL .EQ. 0) THEN
d309 1
a309 1
               IF (ICOUNT .GT. 0) THEN
d323 1
a323 1
        ELSEIF ((FCHAR(4:5) .EQ. 'ME') .AND. 
d389 4
a392 4
        ELSEIF (FCHAR(4:5) .EQ. 'SO' .OR.
     &          FCHAR(4:5) .EQ. 'MI' .OR.
     &          FCHAR(4:5) .EQ. 'ME' .OR.
     &          FCHAR(4:5) .EQ. 'IT') THEN
d412 1
a412 1
           IF (FCHAR(4:5) .EQ. 'ME') THEN
d421 1
a421 1
              REP_KEY = (FCHAR(4:5) .EQ. 'ME')
d430 2
a431 2
        IF (FCHAR(4:5) .EQ. 'MI') NLIST = MAX(2,KEYCOL+1)
        IF (FCHAR(4:5) .EQ. 'ME') NLIST = MAX(MAXX,MAXX2)
d439 1
a439 1
        IF (FCHAR(4:5) .EQ. 'ST') THEN
d494 1
a494 1
        ELSEIF (FCHAR(4:5) .EQ. 'SO' .OR. FCHAR(4:5) .EQ. 'IT') THEN
d529 1
a529 1
        ELSEIF (FCHAR(4:5) .EQ. 'SP') THEN
d536 1
a536 1
               IF (KEY1 .GT. 0) THEN
d550 1
a550 1
                  IF (KEY2 .GT. 0) THEN
d561 1
a561 1
        ELSEIF (FCHAR(4:5) .EQ. 'MI') THEN
d564 1
a564 1
           IF (KEYCOL .EQ. 0) THEN
d590 1
a590 1
              IF (IVAL .GT. (LASTVAL-1)) THEN
d608 1
a608 1
        ELSEIF (FCHAR(4:5) .EQ. 'ME') THEN
d613 1
a613 1
           IF (KEYCOL .EQ. 0) THEN
d626 2
a627 2
                 IF (KEYT .LE. MAXY .AND. ICOUNT1 .GT. 0 .AND. 
     &              ICOUNT2 .EQ. 0) THEN
d673 1
a673 1
                 IF (IGO1 .GT. IKEYS .AND. IGO2 .LE. IKEYS2) THEN
d687 1
a687 1
                 ELSEIF (IGO1 .LE. IKEYS .AND. IGO2 .GT. IKEYS2) THEN
d725 1
a725 1
                    ELSEIF (VALNEXT1 .EQ. VALNEXT2) THEN
d793 1
a793 1
9997    IF (FCHAR(4:5) .EQ. 'ME') THEN
d820 1
a820 1
           IF (DOCBUF(1,IROW) .GT. 0) THEN
d919 1
a919 1
        IF (KEYCOL .EQ. 0) DLIST(1) = 1.0
d936 1
a936 1
        IF (MYPID .EQ. 0) THEN
d992 1
a992 1
            IF (DOCBUF(ILOC) .GT. 0) THEN
d1115 1
a1115 1
           IF (ICOUNT .GT. 0) THEN
d1199 1
a1199 1
              IF (ICOUNT .GT. 0) THEN
d1259 1
a1259 1
          IF (RECLIN(2:2) .EQ. ';') THEN
d1269 1
a1269 1
          IF (IERR .GT. 0) THEN
d1276 1
a1276 1
             IF (IERR .GT. 0) THEN
d1293 1
a1293 1
          ELSEIF (IKEY .EQ. 0) THEN
d1298 1
a1298 1
          ELSEIF (IKEY .GT. 999999) THEN
d1306 1
a1306 1
          ELSEIF (ICOUNT .GT. 9) THEN
d1333 1
a1333 1
          IF (IERR .EQ. 0) THEN
d1396 1
a1396 1
            IF (DOCBUF(ILOC) .GT. 0) THEN
@


1.82
log
@output line formatting
@
text
@d896 1
a896 1
        CALL RDPRAI(ILIST,MAXDIM,NUMB,1,MAXDIM,'ENTER NUMBERS',
d1157 1
a1157 1
     &      'ENTER TEMPLATE FOR DOC. FILE SERIES',IRTFLG)
@


1.81
log
@UNIQUE IN 'AT IT' BUG
@
text
@d1160 1
a1160 1
        IF (NFILE .GT. 0)  THEN
d1162 1
a1162 1
2001       FORMAT(' Number of document files to be combined: ',I6)
@


1.80
log
@'  EMPTY DOC...
@
text
@d34 1
d40 1
a40 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
a263 2
           UNIQUE = (FCHAR(4:5) .EQ. 'IT')

d284 1
@


1.79
log
@FCHAR(4:5) .EQ. 'IT'   needed: REVERSE = .FALSE.
@
text
@d1280 1
a1280 1
              WRITE(NOUT,*) '  EMPTY DOCUMENT FILE LINE SKIPPED'
d1284 1
a1284 1
              WRITE(NOUT,*) '  CONTINUATION LINE SKIPPED IN DOC FILE'
@


1.78
log
@doc sort unique
@
text
@d206 3
@


1.77
log
@revereted to previous UNIQUE = (FCHAR(4:5) .EQ. 'IT') not for sort
@
text
@d33 1
d180 1
a180 1
	CHARACTER(LEN=1)             :: ANSW
d244 1
a244 1
C          SORT THE INPUT DOC FILE--------------------------- 'DOC SORT'
d246 1
a246 1
C          MERGE THE TWO INPUT DOC FILES-------------------- 'DOC MERGE'
d260 12
a271 1
           IF (RENUMBER) THEN
a397 1
           UNIQUE = (FCHAR(4:5) .EQ. 'IT')
@


1.76
log
@UNIQUE IN 'DOC SORT'.
@
text
@a32 1
C        UNIQUE IN 'DOC SORT'                    APR  2012 ARDEAN LEITH 
d386 1
a386 2
           UNIQUE = (FCHAR(4:5) .EQ. 'IT' .OR.
     &               FCHAR(4:5) .EQ. 'SO')
@


1.75
log
@IF (ASSOCIATED(DOCBUF
@
text
@d4 6
a9 6
C DOCS1 NEW                                      JUNE 99   ARDEAN LEITH
C       ADDED 'DOC RAN'                          AUG 99    ARDEAN LEITH
C       USED LUNDOCWRTDAT                        AUG 99    ARDEAN LEITH                                                                 *
C       ADDED 'DOC AND'                          SEPT 99   ARDEAN LEITH
C       ADDED 'DOC SPLIT'                        OCT 99    ARDEAN LEITH
C       OPENDOC PARAMETERS                       DEC 2000  ARDEAN LEITH
d33 1
d39 1
a39 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d387 2
a388 1
           UNIQUE = (FCHAR(4:5) .EQ. 'IT')
@


1.74
log
@MPI ERROR IN  DOCCREATE
@
text
@d155 1
a155 1
9995    IF (ALLOCATED(DOCBUF)) DEALLOCATE(DOCBUF)
d775 1
a775 1
           IF (ALLOCATED(DOCBUF2)) DEALLOCATE(DOCBUF2)
@


1.73
log
@moved 'SUB' and 'AND' to: docsub.f
@
text
@d32 1
d920 1
a920 1
        CALL MPI_BARRIER(COMM,IERR)
@


1.72
log
@FCHAR(4:5) .NE. 'ME') KEYCOL = ABS(KEYCOL) bug
@
text
@d31 2
d37 1
a37 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
a99 1

d117 5
a121 7
        NLIST = MAXX
        IF (NLIST > 0) THEN
           ALLOCATE(DLIST(NLIST),STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'DLIST IN DOCS1',NLIST)
              GOTO 9995
           ENDIF
d140 6
a168 2
C       SUBTRACT THE 2ND INPUT DOC FILE----------------- 'DOC SUBTRACT'
C       AND CONTENTS OF TWO DOC FILES ----------------------- 'DOC AND'
a221 26
        ELSEIF(FCHAR(4:5) .EQ. 'SU') THEN
           PROMPT   = 'COLUMN TO BE SUBTRACTED BY (0 IS KEY)' 
           NLETP    = 40
           RENUMBER = .FALSE.

C          SUBTRACT USES 2 INPUT DOC. FILES
C          MAXX2 IS 1 + NUM OF REGISTERS SINCE DOCBUF CONTAINS KEY ALSO
           MAXX2  = 0
           MAXY2  = 0
           CALL GETDOCDAT('SECOND INPUT DOCUMENT',.TRUE.,DOCNAM2,
     &                  NDOCIN2,.TRUE.,MAXX2, MAXY2,DOCBUF2,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

        ELSEIF (FCHAR(4:5) .EQ. 'AN') THEN
           PROMPT   = 'COLUMN TO BE CHECKED (0 IS KEY)' 
           NLETP    = 40
           RENUMBER = .FALSE.

C          AND USES 2 INPUT DOC. FILES
C          MAXX2 IS 1 + NUM OF REGISTERS SINCE DOCBUF CONTAINS KEY ALSO
           MAXX2  = 0
           MAXY2  = 0
           CALL GETDOCDAT('SECOND INPUT DOCUMENT',.TRUE.,DOCNAM2,
     &                  NDOCIN2,.TRUE.,MAXX2, MAXY2,DOCBUF2,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

d241 1
a241 3
     &      FCHAR(4:5) .EQ. 'ME' .OR. 
     &      FCHAR(4:5) .EQ. 'SU' .OR.
     &      FCHAR(4:5) .EQ. 'AN' ) THEN
a244 2
C          SUBTRACT THE 2ND INPUT DOC FILE--------------- 'DOC SUBTRACT'
C          AND THE INPUT DOC FILES --------------------------- 'DOC AND'
d252 4
a255 6
           IF (FCHAR(4:5) .EQ. 'ME') THEN
              IF (MAXX > 0) THEN
                 IF (ERRI2(KEYCOL,IDUM,1,-1,MAXX-1,0,0)) GOTO 11
              ENDIF
           ELSE
              IF (ERRI2(KEYCOL,IDUM,1, 0,MAXX-1,0,0)) GOTO 11
d305 1
a305 1
C          NO NEED TO SORT LISTS ------------------------- 'DOC MERGE'
d309 1
a309 1
                 CALL ERRT(102,'EMPTY DOC. FILES',NDUM)
d366 5
a370 5

        ELSEIF (FCHAR(4:5) .EQ. 'SO' .OR. FCHAR(4:5) .EQ. 'MI' .OR.
     &          FCHAR(4:5) .EQ. 'ME' .OR. FCHAR(4:5) .EQ. 'SU' .OR.
     &          FCHAR(4:5) .EQ. 'IT' .OR. 
     &          FCHAR(4:5) .EQ. 'AN' .AND. KEYCOL .GT. 0) THEN
a377 2
C          SUBTRACT THE 2ND INPUT DOC FILE--------------- 'DOC SUBTRACT'
C          AND THE INPUT DOC FILES --------------------------- 'DOC AND'
d391 1
a391 16
           IF (FCHAR(4:5) .EQ. 'SU' .OR. FCHAR(4:5) .EQ. 'ME') THEN
C             SORT THE SECOND LIST OF KEYS BUT RETURN VALUES IN SORTED2
              ALLOCATE(SORTED2(MAXY2),STAT=IRTFLG)
              IF (IRTFLG .NE. 0) THEN
                 CALL ERRT(46,'SORTED IN DOCS1',MAXY2)
                 GOTO 9995
              ENDIF

C             RETURN SORTED LIST OF VALUES IN KEYCOL
              REP_KEY = (FCHAR(4:5) .EQ. 'ME')
              UNIQUE  = .FALSE. 
              CALL SORTIT(DOCBUF2(1,1),MAXX2,MAXY2,KEYCOL,SORTED2,
     &                    IKEYS2,REP_KEY,UNIQUE,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9995

          ELSEIF (FCHAR(4:5) .EQ. 'AN') THEN
a758 204
        ELSEIF (FCHAR(4:5) .EQ. 'SU') THEN
C          VALUES IN FIRST FILE KEYCOL BUT NOT IN 2ND: ------- 'DOC SUB.'

           IF (KEYCOL .EQ. 0) THEN
C             EXCLUSIVE SUBTRACTING BY KEY
              DO IKEYT = 1,MAXY
                 ICOUNT1 = DOCBUF((IKEYT - 1) * MAXX + 1)
                 IF (ICOUNT1 .GT. 0 .AND. IKEYT .LE. MAXY2) THEN
C                   KEY EXISTS IN FIRST FILE, CHECK EXISTANCE IN 2ND
                     
                    ICOUNT2 = DOCBUF2(1,IKEYT)
                    IF (ICOUNT2 .EQ. 0) THEN
C                      NEED TO KEEP THIS KEY
                       DO IREG = 1,MAXX
                          DLIST(IREG) = DOCBUF((IKEYT - 1) *MAXX +IREG)
                       ENDDO

C                      PUSH DLIST INTO DOC. FILE
                       NVAL  = MAXX - 1
                       CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
     &                                NVAL,IRTFLG)
                    ENDIF

                 ELSEIF (ICOUNT1 .GT. 0) THEN
C                   KEY EXISTS IN FIRST FILE, 2ND FILE FINISHED
                     
                    DO IREG = 1,MAXX
                       DLIST(IREG) = DOCBUF((IKEYT - 1) * MAXX + IREG)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    NVAL  = MAXX - 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
     &                                NVAL,IRTFLG)
                 ENDIF
              ENDDO

           ELSE                    
C             SUBTRACTING BY COLUMN OTHER THAN KEY
C             POINT TO NEXT VALUE IN SORTED LIST FROM FILE 2
              IGO2     = 1
              VALNEXT2 = SORTED2(IGO2)
             
C             FIND OUTPUT VALUES
              DO IK = 1,IKEYS
C                FIND VALUE IN KEYCOL OF FIRST DOC. FILE

C                FIND KEY FOR THIS SORTED VALUE FROM FIRST FILE
                 KEY1 = SORTED(IK)
C                FIND SORTED VALUE FROM FIRST FILE
                 VAL1 = DOCBUF((KEY1 - 1) * MAXX + KEYCOL + 1)

                 SENDIT = .TRUE.
                 IF (IGO2 .GT. IKEYS2) THEN
C                   VALUE DOES NOT EXIST IN FILE 2 (ALL FILE 2'S DONE)
                    SENDIT = .TRUE.

                 ELSE
C                   MUST CHECK TO SEE IF VALUE EXISTS IN FILE 2
                    IF (VAL1 .LT. VALNEXT2) THEN
C                      VALUE 1 IS BELOW NEXT VALUE 2, SAVE THIS LINE
                       SENDIT = .TRUE.

                    ELSEIF (VAL1 .EQ. VALNEXT2 .AND.
     &                      IGO2 .LE. IKEYS2) THEN
C                      VALUE 1 = NEXT VALUE 2, MUST INCREASE IGO2
                       SENDIT   = .FALSE.
                       IGO2     = IGO2 + 1
                       IF (IGO2 .LE. IKEYS2) VALNEXT2 = SORTED2(IGO2)

                    ELSEIF (VAL1 .GT. VALNEXT2 .AND.
     &                      IGO2 .LT. IKEYS2) THEN
C                      VALUE 1 > NEXT VALUE 2, MUST INCREASE VALNEXT2
                       SENDIT = .TRUE.
                       DO IGO2T = IGO2+1,IKEYS2
                          IF (VAL1 .EQ. SORTED2(IGO2T)) THEN
C                            KEEP GOING TILL VALUE 2 > 
                             SENDIT = .FALSE.
                          ELSEIF (VAL1 .LT. SORTED2(IGO2T)) THEN
C                            POINT TO THIS VALUES IN SORTED LIST FROM #2
                             IGO2     = IGO2T
                             VALNEXT2 = SORTED2(IGO2)
                             EXIT
                         ENDIF
                       ENDDO
                    ENDIF                    
                 ENDIF

                 IF (SENDIT) THEN
C                   VALUE FROM KEYCOL NOT IN 2'ND DOC. FILE
C                   PUT LINE FROM FIRST DOC. FILE INTO OUTPUT FILE
                    DO IREG = 1,MAXX
                       DLIST(IREG) = DOCBUF((KEY1 - 1) * MAXX + IREG)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    NVAL  = MAXX - 1
                    IKEYT = KEY1
                    CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
     &                                NVAL,IRTFLG)
                 ENDIF
              ENDDO
           ENDIF

        ELSEIF (FCHAR(4:5) .EQ. 'AN') THEN
C          VALUES IN FIRST FILE KEYCOL AND ALSO IN 2ND: ------ 'DOC AND'

           IF (KEYCOL .EQ. 0) THEN
C             'ANDING' BY KEY
              DO KEYT = 1,MAXY
                 ICOUNT1 = DOCBUF((KEYT - 1) * MAXX + 1)
                 IF (ICOUNT1 .NE. 0 .AND. KEYT .LE. MAXY2) THEN
C                   KEY EXISTS IN FIRST FILE, CHECK EXISTANCE IN 2ND
                     
                    ICOUNT2 = DOCBUF2(1,KEYT)
                    IF (ICOUNT2 .GT. 0) THEN
C                      NEED TO KEEP THIS KEY
                       DO IREG = 1,MAXX
                          DLIST(IREG) = DOCBUF((KEYT - 1) * MAXX + IREG)
                       ENDDO

C                      PUSH DLIST INTO DOC. FILE
                       NVAL  = MAXX - 1
                       CALL LUNDOCWRTDAT(NICDOCOUT,KEYT,DLIST(2),
     &                                NVAL,IRTFLG)
                    ENDIF

                 ELSEIF (KEY1 .NE. 0) THEN
C                   KEY EXISTS IN FIRST FILE, 2ND FILE FINISHED, QUIT
                    EXIT
                 ENDIF
              ENDDO

           ELSE                    
C             'ANDING' BY COLUMN OTHER THAN KEY
C             POINT TO NEXT VALUE IN SORTED LIST FROM FILE 2
              IGO2     = 1
              VALNEXT2 = SORTED2(IGO2)
              VALSENT  = MIN(SORTED(1),SORTED2(1)) - 1.0
              IKEYNOW  = 0

C             FIND OUTPUT VALUES
              DO IK = 1,IKEYS
C                FIND VALUE IN KEYCOL OF FIRST DOC. FILE

C                FIND KEY FOR THIS SORTED VALUE FROM FIRST FILE
                 KEY1 = SORTED(IK)

C                FIND SORTED VALUE FROM FIRST FILE
                 VAL1 = DOCBUF((KEY1 - 1) * MAXX + KEYCOL + 1)

                 SENDIT = .FALSE.
                 IF (IGO2 .GT. IKEYS2) THEN
C                   VALUE DOES NOT EXIST IN FILE 2 (ALL FILE 2'S DONE)
                    EXIT

                 ELSE
C                   MUST CHECK TO SEE IF VALUE EXISTS IN FILE 2
                    IF (VAL1 .LT. VALNEXT2) THEN
C                      VALUE 1 IS BELOW NEXT VALUE 2, DO NOT SAVE
                       SENDIT = .FALSE.

                    ELSEIF (VAL1 .EQ. VALNEXT2 .AND.
     &                      IGO2 .LE. IKEYS2) THEN
C                      VALUE 1 = NEXT VALUE 2, MUST INCREASE IGO2
                       SENDIT   = VALSENT .NE. VAL1
                       IGO2     = IGO2 + 1
                       IF (IGO2 .LE. IKEYS2) VALNEXT2 = SORTED2(IGO2)

                    ELSEIF (VAL1 .GT. VALNEXT2 .AND.
     &                      IGO2 .LT. IKEYS2) THEN
C                      VALUE 1 > NEXT VALUE 2, MUST INCREASE VALNEXT2
                       SENDIT = .FALSE.
                       DO IGO2T = IGO2+1,IKEYS2
                          IF (VAL1 .EQ. SORTED2(IGO2T)) THEN
C                            KEEP GOING TILL VALUE 2 > 
                             SENDIT = .TRUE.
                          ELSEIF (VAL1 .LE. SORTED2(IGO2T)) THEN
C                            POINT TO THIS VALUES IN SORTED LIST FROM #2
                             IGO2     = IGO2T
                             VALNEXT2 = SORTED2(IGO2)
                             EXIT
                         ENDIF
                       ENDDO
                    ENDIF                    
                 ENDIF

                 IF (SENDIT) THEN
C                   VALUE FROM KEYCOL ALSO IN 2'ND DOC. FILE
C                   PUT LINE FROM FIRST DOC. FILE INTO OUTPUT FILE
                    DO IREG = 1,MAXX
                       DLIST(IREG) = DOCBUF((KEY1 - 1) * MAXX + IREG)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    NVAL    = MAXX - 1
                    IKEYNOW = IKEYNOW + 1
                    IF (KEYCOL .GT. 0) IKEYNOW = KEY1
                    CALL LUNDOCWRTDAT(NICDOCOUT,IKEYNOW,DLIST(2),
     &                                NVAL,IRTFLG)
                    VALSENT = DLIST(KEYCOL+1)
                 ENDIF
              ENDDO
           ENDIF
d772 1
a772 3
9997    IF (FCHAR(4:5) .EQ. 'ME' .OR. 
     &      FCHAR(4:5) .EQ. 'SU' .OR.
     &      FCHAR(4:5) .EQ. 'AN' ) THEN
@


1.71
log
@MT doc file ok for some more ops
@
text
@d30 1
a218 1

d262 4
a265 2
        IF (FCHAR(4:5) .EQ. 'SO' .OR. FCHAR(4:5) .EQ. 'MI' .OR.
     &      FCHAR(4:5) .EQ. 'ME' .OR. FCHAR(4:5) .EQ. 'SU' .OR.
a275 1
             
d277 1
a277 1
           KEYCOL  = ABS(KEYCOL)
d312 1
@


1.70
log
@mt merge file trap .
@
text
@a125 5
           IF (MAXX < 1 .OR. MAXY < 1) THEN
              CALL ERRT(102,'EMPTY DOC. FILE',NDUM)
              GOTO 9995
           ENDIF

a129 4
           IF (MAXX < 1 .OR. MAXY < 1) THEN
              CALL ERRT(102,'EMPTY DOC. FILE',NDUM)
              GOTO 9995
           ENDIF
a133 4
           IF (MAXX < 1 .OR. MAXY < 1) THEN
              CALL ERRT(102,'EMPTY DOC. FILE',NDUM)
              GOTO 9995
           ENDIF
a137 4
           IF (MAXX < 1 .OR. MAXY < 1) THEN
              CALL ERRT(102,'EMPTY DOC. FILE',NDUM)
              GOTO 9995
           ENDIF
d1110 1
a1110 1
	DATA NDOCOUT/72/
d1193 1
a1193 1
	DATA NDOCOUT/71/
d1209 2
d1256 1
a1256 1
        CLOSE(NDOCOUT)
a1257 1
        RETURN
d1274 1
a1274 1
	DATA NDOCOUT/72/
a1281 1
C       write(6,*) 'maxx,maxy:',maxx,maxy
d1289 4
d1304 1
a1304 1
        CLOSE(NDOCOUT)
a1305 1
        RETURN
d1322 1
a1322 1
	DATA NDOCOUT/72/
a1329 1
C         write(6,*) 'maxx,maxy:',maxx,maxy
d1335 3
d1363 1
a1363 1
        CLOSE(NDOCOUT)
a1364 1
        RETURN
d1381 3
a1383 1
	DATA NDOCIN,NDOCIN2,NDOCOUT/70,71,72/
d1589 4
a1592 4
        REAL, DIMENSION(MAXX*MAXY)         :: DOCBUF
        REAL, DIMENSION(MAXX)              :: DLIST
        INTEGER, ALLOCATABLE, DIMENSION(:) :: KEYLIST
        INTEGER, ALLOCATABLE, DIMENSION(:) :: KEYLISTOUT
d1595 1
a1595 1
	DATA NDOCOUT/71/
d1613 1
d1617 1
a1617 1
           CALL ERRT(46,'KEYLIST IN DOCS1',2*MAXY)
a1664 2


d1669 1
a1669 1
        CLOSE(NDOCOUT)
a1670 1
        RETURN
@


1.69
log
@mt doc file bug fixed for 'DOC MERGE'
@
text
@d91 1
a91 1
C          COPY TO  OLD DOC FILE ------------------------- DOC COPY'
d324 1
a324 1
        IF (FCHAR(4:5) .EQ. 'SO' .AND. KEYCOL .EQ. 0) THEN
d345 4
a348 3
        ELSEIF ((FCHAR(4:5) .EQ. 'ME' .AND. KEYCOL .LT. 0) .OR.
     &          (MAXX  < 1 .OR. MAXY  < 1) .OR. 
     &          (MAXX2 < 1 .OR. MAXY2 < 1)) THEN
@


1.68
log
@'DOC STAT' added
@
text
@d28 2
a29 1
C
d66 4
a69 4
        INTEGER, INTENT(IN)               :: MAXDIM
 	CHARACTER(LEN=MAXNAM)             :: DOCNAM
 	CHARACTER(LEN=1)                  :: NULL
        REAL, ALLOCATABLE                 :: DLIST(:)
d72 1
a72 1
        REAL,  POINTER                    :: DOCBUF(:,:)
d74 1
a74 1
        INTEGER, PARAMETER                :: NDOCIN = 70
d116 6
a121 4
        ALLOCATE(DLIST(NLIST),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'DLIST IN DOCS1',NLIST)
           GOTO 9995
d123 1
d126 5
d135 4
d143 4
d151 4
d165 1
a165 1
9995    DEALLOCATE(DOCBUF)
d168 1
a168 1
        IF (ALLOCATED(DLIST)) DEALLOCATE(DLIST)
d190 2
a191 1
	CHARACTER(LEN=1)             :: NULL,ANSW
d207 3
a209 3
 	DATA NDOCIN2,NDOCOUT,NDOCOUT2/71,72,73/

	NULL = CHAR(0)
d235 1
a264 1

d296 3
a298 1
               IF (ERRI2(KEYCOL,IDUM,1,-1,MAXX-1,0,0)) GOTO 11
d300 1
a300 1
              IF (ERRI2(KEYCOL,IDUM,1,0,MAXX-1,0,0)) GOTO 11
d345 3
a347 1
        ELSEIF (FCHAR(4:5) .EQ. 'ME' .AND. KEYCOL .LT. 0)THEN
d349 7
d373 13
a385 12
C          COPY VALUES FROM FIRST FILE
           DO IKEYT = 1,MAXY
              ICOUNT   = DOCBUF((IKEYT - 1) * MAXX + 1)
              IF (ICOUNT .GT. 0 )THEN
C                KEY EXISTS PUSH DLIST FROM FILE 1 INTO OUTPUT FILE
                 DO IREG = 1,MAXX
                    DLIST(IREG) = DOCBUF((IKEYT - 1) * MAXX + IREG)
                 ENDDO

C                PUSH DLIST INTO DOC. FILE
                 KEYNEW = KEYNEW + 1
                 CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DLIST(2),
d387 3
a389 2
              ENDIF
           ENDDO
d391 13
a403 12
C          COPY VALUES FROM SECOND FILE
           DO IKEYT = 1,MAXY2
              ICOUNT  = DOCBUF2(1,IKEYT)
              IF (ICOUNT .GT. 0 )THEN
C                KEY EXISTS, PUSH DLIST FROM FILE 2 INTO OUTPUT FILE
                 DO IREG = 1,MAXX2
                    DLIST(IREG) = DOCBUF2(IREG,IKEYT)
                 ENDDO

C                PUSH DLIST INTO DOC. FILE
                 KEYNEW = KEYNEW + 1
                 CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DLIST(2),
d405 3
a407 2
              ENDIF
           ENDDO
@


1.67
log
@'DOC SORT A' APPEND, mineset removed
@
text
@d27 1
d161 1
d226 1
a226 1
        ELSEIF(FCHAR(4:5) .EQ. 'AN') THEN
d238 5
d245 11
a255 9
C       OPEN OUTPUT DOCUMENT FILE
        CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9997

        APPENDOK = (FCHAR(4:9) .EQ. 'SORT A')
        MESSAGE  = .NOT. APPENDOK
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,NICDOCOUT,.FALSE.,' ',
     &                     .FALSE.,APPENDOK,MESSAGE,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9997
d441 51
d493 4
a496 1
        IF (FCHAR(4:5) .EQ. 'SO' .OR. FCHAR(4:5) .EQ. 'IT') THEN
d783 1
a783 1
C          VLUES IN FIRST FILE KEYCOL BUT NOT IN 2ND: ------- 'DOC SUB.'
a985 2


d999 2
a1000 1
9997    IF (FCHAR(4:5) .EQ. 'ME' .OR. FCHAR(4:5) .EQ. 'SU' .OR.
d1003 1
a1003 1
           DEALLOCATE(DOCBUF2)
@


1.66
log
@'DOC SORT ' REVERSE ORDER
@
text
@d10 3
a12 3
C       ADDED 'DOC TOMINESET'                    JUNE 2001 ARDEAN LEITH
C       CLOSED NDOCOUT IN ROUTINES               JULY 2001 ARDEAN LEITH
C       ADDED 'DOC COM'                          DEC  2001 ARDEAN LEITH
d19 1
a19 1
C       ADDED 'DOC OLD'                          FEB  2004 ARDEAN LEITH
d23 4
a26 2
C       'DOC BOOT ' ADDED                        JAN  2006 ARDEAN LEITH
C       'DOC SORT ' REVERSE ORDER                OCT  2010 ARDEAN LEITH
d53 3
a55 1
C                                                                       
a89 1

a92 6
        ELSEIF (FCHAR(4:6) .EQ. 'MIN') THEN
C          CREATE MINESET INPUT FILE --------------------- DOC MINE'

           CALL DOCTOMINE(MAXDIM)
           RETURN

d181 1
d242 2
d245 1
a245 1
     &                     .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
a1279 94
C       ----------------------- DOCTOMINE ----------------------------

	SUBROUTINE DOCTOMINE(MAXDIM)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        CHARACTER (LEN=12)                :: CDATT
        CHARACTER (LEN=8)                 :: CTIMT
	CHARACTER(LEN=MAXNAM)             :: DOCNAM,FILNAM,FILNAMS
        INTEGER,INTENT(IN)                :: MAXDIM
	CHARACTER(LEN=1)                  :: TAB,QUO
        REAL, ALLOCATABLE, DIMENSION(:,:) :: DBUF

        COMMON   DLIST(1)

	DATA NDOCINT,NDOCOUT/70,72/

        TAB = CHAR(9)
        QUO = CHAR(34)

C       OPEN INPUT DOC. FILE
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOCINT,NDOCIN,.TRUE.,
     &           'INPUT DOCUMENT',.TRUE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       GET ARRAY SIZE
        CALL LUNDOCINFO(NDOCIN,MAXY,MAXX,NUSED,.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       LOAD DATA
        ALLOCATE(DBUF(MAXX,MAXY),STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
            CALL ERRT(46,'DBUF',MAXX*MAXY)
            RETURN   
        ENDIF
        CALL LUNDOCREDALL(NDOCIN,DBUF,MAXX,MAXY,.TRUE.,MAXYGOT,IRTFLG)
        IF (IRTFLG.NE.0) GOTO 9999 

C       CREATE MINESET DATA OUTPUT FILE 
        CALL OPAUXFILE(.TRUE.,FILNAM,'data',NDOCOUT,0,
     &                 'N','MINESET OUTPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        DO IKEY = 1,MAXY
           ICOUNT = DBUF(1,IKEY)
           IF (ICOUNT .GT. 0) THEN
C             GOT VALID DOC FILE DATA LINE
              WRITE(NDOCOUT,90) IKEY,(TAB,DBUF(I,J),J=2,MAXX)
90            FORMAT(I7,50(A,F12.6))
              ICOUNTLAS = ICOUNT
           ENDIF
        ENDDO
        CLOSE(NDOCOUT)

C       CREATE MINESET SCHEME OUTPUT FILE
        NLETI = INDEX(FILNAM,'.',.TRUE.) 
        FILNAMS = FILNAM(1:NLETI-1)
        CALL OPAUXFILE(.FALSE.,FILNAMS,'schema',NDOCOUT,0,
     &                 'N',' ',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        NLETS = lnblnkn(FILNAMS)

C       WRITE HEADER INTO FILE
        CALL DATE_2K(CDATT)
        CALL MYTIME(CTIMT)
        WRITE(NDOCOUT,91) FILNAMS(1:NLETS),CDATT(1:11),CTIMT
91      FORMAT('# Mineset Scheme File: ',A,'  Created ',A,' AT ',A)
 
        WRITE(NDOCOUT,92)DOCNAM(:NLET),DATEXC(1:3)
92      FORMAT('# From SPIDER Doc File: ',A,'.',A)
        WRITE(NDOCOUT,*) 'input {'
        NLET  = lnblnkn(FILNAM)
        WRITE(NDOCOUT,*) '   file ',QUO,FILNAM(1:NLET),QUO,';'
        WRITE(NDOCOUT,*) '     int image;'

        DO I = 1,ICOUNTLAS
           IF (I .le. 9) THEN
              WRITE(NDOCOUT,97)I
97            FORMAT('      float f',I1,';')
           ELSE
              WRITE(NDOCOUT,98)I
98            FORMAT('      float f',I2,';')
           ENDIF
        ENDDO
        WRITE(NDOCOUT,*) '      }'
      
9999    CLOSE(NDOCIN)
        CLOSE(NDOCOUT)
        IF (ALLOCATED(DBUF)) DEALLOCATE(DBUF)

 
        RETURN
        END
d1585 1
@


1.65
log
@GPL_2010
@
text
@d4 21
a24 20
C DOCS1 NEW                         JUNE 99   ARDEAN LEITH
C       ADDED 'DOC RAN'             AUG 99    ARDEAN LEITH
C       USED LUNDOCWRTDAT           AUG 99    ARDEAN LEITH                                                                 *
C       ADDED 'DOC AND'             SEPT 99   ARDEAN LEITH
C       ADDED 'DOC SPLIT'           OCT 99    ARDEAN LEITH
C       OPENDOC PARAMETERS          DEC 2000  ARDEAN LEITH
C       ADDED 'DOC TOMINESET'       JUNE 2001 ARDEAN LEITH
C       CLOSED NDOCOUT IN ROUTINES  JULY 2001 ARDEAN LEITH
C       ADDED 'DOC COM'             DEC  2001 ARDEAN LEITH
C       'DOC COM' BUG               MAY  2002 ARDEAN LEITH
C       'DOC COM' FILE NAME BUG     SEP  2002 ARDEAN LEITH
C       'DOC COM' MAXY BUF          JUN  2003 ARDEAN LEITH
C       INCORE OPENDOC              JUL  2003 ARDEAN LEITH
C       MPI                         OCT  2003 CHAO YANG
C       'DOC RAN' BUG               JAN  2004 ARDEAN LEITH
C       ADDED 'DOC OLD'             FEB  2004 ARDEAN LEITH
C       'DOC AND' BUG               FEB  2004 ARDEAN LEITH
C       'DOC MIR' KEYCOL BUG        OCT  2004 ARDEAN LEITH
C       'DOC KEY' ADDED             JUL  2005 ARDEAN LEITH
C       'DOC BOOT ' ADDED           JAN  2006 ARDEAN LEITH
d60 1
a60 1
        INTEGER,INTENT(IN)                :: MAXDIM
d63 1
a63 1
        REAL, ALLOCATABLE, DIMENSION(:)   :: DLIST
d66 1
a66 1
        REAL, DIMENSION(:,:), POINTER     :: DOCBUF
d68 1
a68 1
	DATA NDOCIN/70/
d70 1
a70 9
#ifdef USE_MPI
        INCLUDE 'mpif.h'
        INTEGER COMM, MYPID, MPIERR
        COMM = MPI_COMM_WORLD
        MPIERR = 0
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
#else
        MYPID = -1
#endif
d119 1
a119 1
           CALL ERRT(101,'UNABLE TO ALLOCATE DLIST IN DOCS1',ND)
d169 8
a176 7
	CHARACTER(LEN=MAXNAM)             :: DOCNAM2,DOCNAM3
	CHARACTER(LEN=1)                  :: NULL,ANSW
        LOGICAL                           :: NEWFILE,ERRI2,RENUMBER

        REAL, DIMENSION(MAXX*MAXY)        :: DOCBUF
        REAL,    ALLOCATABLE, DIMENSION(:):: SORTED,SORTED2,DLIST
        INTEGER, ALLOCATABLE, DIMENSION(:):: KEYLIST
d179 5
a183 4
        REAL, DIMENSION(:,:), POINTER     :: DOCBUF2
	CHARACTER(LEN=80)                 :: PROMPT
        LOGICAL                           :: SENDIT,REP_KEY,UNIQUE
        INTEGER                           :: NEEDINC
d190 3
a192 2
           PROMPT   = 'COLUMN TO BE SORTED BY (0 IS KEY)' 
           NLETP    = 33
d259 5
d267 1
a267 1
               IF (ERRI2(KEYCOL,IDUM,1,0,MAXX-1,0,0)) GOTO 11
d291 1
a291 1
        IF (FCHAR(4:5) .EQ. 'SO' .AND. KEYCOL .EQ. 0)THEN
d380 1
a380 1
              CALL ERRT(101,'UNABLE TO ALLOCATE SORTED IN DOCS1',ND)
d394 1
a394 1
                 CALL ERRT(101,'UNABLE TO ALLOCATE SORTED IN DOCS1',ND)
d409 1
a409 1
                 CALL ERRT(101,'UNABLE TO ALLOCATE SORTED IN DOCS1',ND)
d428 1
a428 1
           CALL ERRT(101,'UNABLE TO ALLOCATE DLIST IN DOCS1',ND)
d435 1
a435 1
C          SORT THE INPUT DOC FILE--------------------------- 'AT IT   '
d438 11
a448 1
           DO IROW = 1,IKEYS
d1018 1
a1019 1
        INTEGER,INTENT(IN)               :: MAXDIM
d1022 1
a1022 1
        REAL,ALLOCATABLE,DIMENSION(:)    :: DLIST
d1029 1
a1029 8
#ifdef USE_MPI
        include 'mpif.h'
        INTEGER MYPID, COMM, IERR
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
#else
        MYPID = -1
#endif
d1055 1
a1055 1
           CALL ERRT(101,'UNABLE TO ALLOCATE NLIST IN DOCCREATE',ND)
d1105 3
a1107 3
        REAL, DIMENSION(MAXX*MAXY)        :: DOCBUF
        REAL, DIMENSION(MAXX)             :: DLIST
        INTEGER, ALLOCATABLE, DIMENSION(:):: KEYLIST
d1128 1
a1128 1
           CALL ERRT(101,'UNABLE TO ALLOCATE KEYLIST IN DOCS1',ND)
d1194 1
a1194 1
C       RENUMBER THE INPUT DOC FILE--------------------- 'DOC RENUMBER'
d1198 1
a1198 2
C         write(6,*) 'maxx,maxy:',maxx,maxy

d1222 1
a1222 1
C       RE KEY THE INPUT DOC FILE --------------------------- 'DOC KEY'
d1240 1
a1240 1
C       RE-KEY THE INPUT DOC FILE--------------------- 'DOC KEY'
d1313 1
a1313 1
            CALL ERRT(46,'DBUF',IER)
d1621 1
a1621 1
           CALL ERRT(101,'UNABLE TO ALLOCATE KEYLISTs IN DOCS1',ND)
@


1.64
log
@removed iwant from doc boot
@
text
@a25 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d27 5
a31 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d33 1
a33 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d38 1
a38 1
C=* This program is distributed in the hope that it will be useful,    *
d40 1
a40 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a41 1
C=*                                                                    *
d43 1
a43 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.63
log
@added DOC BOOT
@
text
@d1615 4
a1618 3
        CALL RDPRI1S(IWANT,NOT_USED,
     &               'NUMBER OF SELECTIONS WANTED',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
d1620 1
a1620 1
        ALLOCATE(KEYLIST(MAXY),KEYLISTOUT(IWANT),STAT=IRTFLG)
d1636 1
@


1.62
log
@doc and key wrong
@
text
@d23 1
d137 4
d1585 93
@


1.61
log
@GPL License fixed
@
text
@d904 1
@


1.60
log
@HRI GPL License used
@
text
@a24 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d28 1
a28 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a47 6

C * COPYRIGHT (C)1985, 2005. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.59
log
@added DOC KEY operation
@
text
@d26 24
@


1.58
log
@Need to put MPI back in to synch doc file
@
text
@d22 1
d26 1
a26 1
C * COPYRIGHT (C)1985, 2004. HEALTH RESEARCH INCORPORATED (HRI),       *
d51 1
a51 1
        REAL, DIMENSION(:,:), POINTER       :: DOCBUF
d79 1
d85 1
d91 1
d102 1
a102 1
C       DOC RENUMBER NEEDS SEQUENTIL READ OF LINES NOT BY KEY
d123 4
d1165 1
a1165 1
        LOGICAL                                   :: NEWFILE
d1184 1
a1191 1
            NLIST = MAXX
d1200 58
@


1.57
log
@removed MPI stuff
@
text
@d54 10
d991 9
d1050 9
a1058 1
        CLOSE(NDOCOUT)
@


1.56
log
@Removed MPI I/O sync because it is now taken care of in lower level I/O routines
@
text
@a53 10
#ifdef USE_MPI
        INCLUDE 'mpif.h'
        INTEGER COMM, MYPID, MPIERR
        COMM = MPI_COMM_WORLD
        MPIERR = 0
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
#else
        MYPID = -1
#endif

a980 9
#ifdef USE_MPI
        include 'mpif.h'
        INTEGER MYPID, COMM, IERR
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID, IERR)
#else
        MYPID = -1
#endif

d1031 1
a1031 9
#ifdef USE_MPI
        IF (mypid .eq. 0) THEN
           CALL FLUSHFILE(NICDOCOUT)
           CLOSE(NICDOCOUT)
        ENDIF
        CALL MPI_BARRIER(comm,ierr)
#else
        IF (MYPID .LE. 0) CLOSE(NDOCOUT)
#endif
@


1.55
log
@'DOC MIR' KEYCOL BUG
@
text
@a116 6
#ifdef USE_MPI
           IF (MYPID .EQ. 0) THEN 
              CALL DOCRENUMBER(MAXX, MAXY, DOCBUF(1,1), DLIST)
           ENDIF
           CALL MPI_BCAST(IBCNT, 1, MPI_INTEGER, 0, COMM, IERR)
#else
a117 1
#endif
@


1.54
log
@mpi
@
text
@d18 1
a18 1
C       DOC RAN BUG                 JAN  2004 ARDEAN LEITH
d20 2
a21 1
C       DOC AND BUG                 FEB  2004 ARDEAN LEITH
d25 1
a25 1
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
d472 15
a494 1
           IF (KEYCOL .EQ. 0) DLIST(2) = 1.0
a511 1

@


1.53
log
@undefined icount fixed
@
text
@d55 1
a55 2
        INTEGER COMM

d57 1
d59 2
d1050 1
a1050 1
        CLOSE(NDOCOUT)
@


1.52
log
@Variable I is used before its value defined (only for mineset)
@
text
@d1228 2
a1229 1
           IF (DBUF(1,IKEY) .GT. 0) THEN
@


1.51
log
@efc compiler complains on ,,
@
text
@d1228 1
a1228 1
           IF (DBUF(1,I) .EQ. IKEY) THEN
@


1.50
log
@doc and bug 1 not same as 2
@
text
@d1475 1
a1475 1
96              FORMAT(I6,,I1,9G12.3)
@


1.49
log
@docdown
@
text
@d20 1
d849 2
a850 2
                             SENDIT = .FALSE.
                          ELSEIF (VAL1 .LT. SORTED2(IGO2T)) THEN
@


1.48
log
@mpi
@
text
@d19 1
d67 1
a67 1
C          SHUFFLE OLD DOC FILE -------------------------DOC SHUFFLE'
d72 5
d78 1
a78 1
C          CREATE MINESET INPUT FILE ---------------------DOC MINE'
d83 1
a83 1
C          COMBINE A SERIES OF INPUT DOC. FILES -----------DOC COMBINE'
d1355 130
@


1.47
log
@doc ran count bug
@
text
@d51 8
@


1.46
log
@mpi
@
text
@d18 1
d1081 1
a1081 1
            IF (DOCBUF(ILOC) .EQ. IKEY) THEN
@


1.45
log
@bad 'doc merge' with keycol -1
@
text
@d17 1
d98 6
d105 1
d968 5
a972 3
        integer mypid, comm, ierr
        comm = MPI_COMM_WORLD 
        call MPI_COMM_RANK(comm, mypid,  IERR)
d1026 5
a1030 3
        if (mypid .eq. 0) then
           CLOSE(NDOCOUT)
        endif
@


1.44
log
@doc ren bug
@
text
@d265 52
d482 1
a482 44
           IF (KEYCOL .LT. 0) THEN
C             MERGING ALL KEYS
              KEYNEW = 0

C             MAKE SURE ALL REGISTERS ARE ZEROED IN OUTPUT
              NVAL = MAX(MAXX,MAXX2) - 1
              DO IREG = 1,NVAL
                 DLIST(IREG) = 0.0
              ENDDO

C             COPY VALUES FROM FIRST FILE
              DO IKEYT = 1,MAXY
                 ICOUNT   = DOCBUF((IT - 1) * MAXX + 1)
                 IF (ICOUNT .GT. 0 )THEN
C                   KEY EXISTS PUSH DLIST FROM FILE 1 INTO OUTPUT FILE
                    DO IREG = 1,MAXX
                       DLIST(IREG) = DOCBUF((IKEYT - 1) * MAXX + IREG)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    KEYNEW = KEYNEW + 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DLIST(2),
     &                                NVAL,IRTFLG)
                 ENDIF
              ENDDO

C             COPY VALUES FROM SECOND FILE
              DO IKEYT = 1,MAXY2
                 ICOUNT  = DOCBUF2(1,IT)
                 IF (ICOUNT .GT. 0 )THEN
C                   KEY EXISTS, PUSH DLIST FROM FILE 2 INTO OUTPUT FILE
                    DO IREG = 1,MAXX2
                       DLIST(IREG) = DOCBUF2(IREG,IKEYT)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    KEYNEW = KEYNEW + 1
                    CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DLIST(2),
     &                                NVAL,IRTFLG)
                 ENDIF
              ENDDO


           ELSEIF (KEYCOL .EQ. 0) THEN
@


1.43
log
@mpi
@
text
@d948 1
@


1.42
log
@debug output removed
@
text
@d948 6
d1004 6
d1011 1
@


1.41
log
@sort bug
@
text
@d1107 1
a1107 1
         write(6,*) 'maxx,maxy:',maxx,maxy
@


1.40
log
@doc ren bug
@
text
@d227 1
d244 20
a263 1

d265 4
a268 4
        IF (FCHAR(4:5) .EQ. 'SO' .OR. FCHAR(4:5) .EQ. 'MI' .OR.
     &      FCHAR(4:5) .EQ. 'ME' .OR. FCHAR(4:5) .EQ. 'SU' .OR.
     &      FCHAR(4:5) .EQ. 'IT' .OR. 
     &      FCHAR(4:5) .EQ. 'AN' .AND. KEYCOL .GT. 0) THEN
d848 2
a849 2
	CLOSE(NDOCOUT)
	CLOSE(NDOCOUT2)
@


1.39
log
@doc combine buggy (icount)
@
text
@d1077 1
a1077 1
        LOGICAL                           :: NEWFILE
d1087 2
@


1.38
log
@dlist(1) (icount) bug in 'AND' & 'SUB' fixed?
@
text
@d1261 2
a1262 2
              IKEYGOT = DOCBUF(1,IKEY)
              IF (IKEYGOT .GT. 0) THEN
d1265 1
a1265 1
                 CALL LUNDOCWRTDAT(NICDOCOUT,IKEYNOW,DOCBUF(2,IKEYGOT),
@


1.37
log
@icount changed
@
text
@d324 1
a324 1
                  DLIST(1) = NEWKEY
d327 1
a327 1
                  DLIST(1) = IKEY 
a334 1
               IKEYT = DLIST(1)
a391 1
                    DLIST(1)        = NEWKEY
d396 1
a396 1
                    IKEYT = DLIST(1)
d715 4
a718 4
C                      PUSH DLIST INTO DOC. FILE
                       NVAL  = MAXX - 1
                       IKEYT = DLIST(1)
                       CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
d743 1
a743 1
                       CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
d759 1
d808 1
a808 1
C                   VALUE FROM KEYCOL NOT IN 2'ND DOC. FILE
d815 3
a817 3
                    NVAL  = MAXX - 1
                    IKEYT = DLIST(1)
                    CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
@


1.36
log
@icount not ikey in docbuf(1 for sortit
@
text
@d423 3
a425 3
              DO IT = 1,MAXY
                 IKEYT   = DOCBUF((IT - 1) * MAXX + 1)
                 IF (IKEYT .NE. 0 )THEN
d428 1
a428 1
                       DLIST(IREG) = DOCBUF((IT - 1) * MAXX + IREG)
d439 4
a442 4
              DO IT = 1,MAXY2
                 IKEYT  = DOCBUF2(1,IT)
                 IF (IKEYT .NE. 0 )THEN
C                   KEY EXISTS PUSH DLIST FROM FILE 2 INTO OUTPUT FILE
d458 13
a470 11
              DO IT = 1,MAXYT
                 KEY1 = 0
                 IF (IT .LE. MAXY) 
     &              KEY1 = DOCBUF((IT - 1) * MAXX + KEYCOL + 1)
                 KEY2 = 0
                 IF (IT .LE. MAXY2) 
     &               KEY2 = DOCBUF2( KEYCOL + 1,IT)

                 IF (IT .LE. MAXY .AND. KEY1 .NE. 0 .AND. 
     &              KEY2 .LE. 0)THEN
C                   KEY1 EXISTS AND KEY 2 DOES NOT EXIST, PUSH DLIST 
d473 1
a473 1
                       DLIST(IREG) = DOCBUF((IT - 1) * MAXX + IREG)
d478 1
a478 2
                    IKEYT = DLIST(1)
                    CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
d481 1
a481 1
                 ELSEIF (IT .LE. MAXY2 .AND. KEY2 .NE. 0) THEN
d484 1
a484 1
                       DLIST(IREG) = DOCBUF2(IREG,IT)
d489 1
a489 2
                    IKEYT = DLIST(1)
                    CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
d512 1
a512 1
              DO WHILE( IGO1 .LE. IKEYS .OR. IGO2 .LE. IKEYS2)
d627 3
a629 3
              DO IT = 1,MAXY
                 KEY1 = DOCBUF((IT - 1) * MAXX + KEYCOL + 1)
                 IF (KEY1 .NE. 0 .AND. KEY1 .LE. MAXY2) THEN
d632 2
a633 2
                    KEY2 = DOCBUF2( KEYCOL + 1,IT)
                    IF (KEY2 .EQ. 0) THEN
d636 1
a636 1
                          DLIST(IREG) = DOCBUF((IT - 1) * MAXX + IREG)
a640 1
                       IKEYT = DLIST(1)
a642 1

d645 1
a645 1
                 ELSEIF (KEY1 .NE. 0) THEN
d649 1
a649 1
                       DLIST(IREG) = DOCBUF((IT - 1) * MAXX + IREG)
d652 3
a654 4
C                      PUSH DLIST INTO DOC. FILE
                       NVAL  = MAXX - 1
                       IKEYT = DLIST(1)
                       CALL LUNDOCWRTDAT(NICDOCOUT,IKEYT,DLIST(2),
d731 3
a733 3
              DO IT = 1,MAXY
                 KEY1 = DOCBUF((IT - 1) * MAXX + KEYCOL + 1)
                 IF (KEY1 .NE. 0 .AND. KEY1 .LE. MAXY2) THEN
d736 2
a737 2
                    KEY2 = DOCBUF2(KEYCOL + 1,IT)
                    IF (KEY2 .NE. 0) THEN
d740 1
a740 1
                          DLIST(IREG) = DOCBUF((IT - 1) * MAXX + IREG)
a744 1
                       IKEYT = DLIST(1)
d768 1
@


1.35
log
@*** empty log message ***
@
text
@d870 1
a870 1
           IF (DOCBUF(1,IROW) .EQ. IROW) THEN
@


1.34
log
@lundocrednxt replaced
@
text
@d572 2
a573 2
                       CALL LUNDOCWRTDAT(NICDOCOUT,KEYNEW,DOCBUF2(2,KEY2),
     &                                NVAL,IRTFLG)
d1136 2
a1137 2
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOCINT,NDOCIN..TRUE.,
     &               'INPUT DOCUMENT',.TRUE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
d1161 1
a1161 1
              WRITE(NDOCOUT,90) IKEY,(TAB,DBUF(J),J=2,MAXX)
@


1.33
log
@incore opendoc now
@
text
@d1121 6
a1126 5
        CHARACTER (LEN=12)  ::     CDATT
        CHARACTER (LEN=8)  ::      CTIMT
	CHARACTER(LEN=MAXNAM)   :: DOCNAM,FILNAM,FILNAMS
        INTEGER,INTENT(IN)      :: MAXDIM
	CHARACTER(LEN=1)        :: TAB,QUO
d1130 1
a1130 1
	DATA NDOCIN,NDOCOUT/70,72/
d1136 1
a1136 1
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOCIN,NICDOCIN..TRUE.,
d1140 13
d1158 8
a1165 10
10      CALL LUNDOCREDNXT(NICDOCIN,IKEY,DLIST,MAXDIM,ICOUNT,IRTFLG)
        IF (IRTFLG .EQ. 1) GOTO 9999

        IF (IRTFLG .NE. 2) THEN
C          GOT VALID DOC FILE DATA LINE
           WRITE(NDOCOUT,90) IKEY,(TAB,DLIST(j),j=1,ICOUNT)
90         FORMAT(I7,50(A,F12.6))
           ICOUNTLAS = ICOUNT
           GOTO 10
        ENDIF
d1202 1
d1204 1
@


1.32
log
@maxy bug in 'doc com'
@
text
@d16 1
d47 1
a47 1
	DATA NDOCIN,NDOCIN2,NDOCOUT,NDOCOUT2/70,71,72,73/
a92 1

a96 1

a111 2
        CLOSE(NDOCOUT)

d144 1
a144 1
	DATA NDOCIN,NDOCIN2,NDOCOUT,NDOCOUT2/70,71,72,73/
d202 1
a202 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,' ',
d238 2
a239 2
           CALL OPENDOC(DOCNAM2,.TRUE.,NLET,NDOCOUT2,.FALSE.,' ',
     &                     .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
d241 1
a241 1
       ENDIF
d336 1
a336 1
               CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),NVAL,IRTFLG)
d354 1
a354 1
                  CALL LUNDOCWRTDAT(NDOCOUT,NEWKEY1,DLIST(2),
d366 1
a366 1
                     CALL LUNDOCWRTDAT(NDOCOUT2,NEWKEY2,DLIST(2),
d399 1
a399 1
                    CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d433 1
a433 1
                    CALL LUNDOCWRTDAT(NDOCOUT,KEYNEW,DLIST(2),
d449 1
a449 1
                    CALL LUNDOCWRTDAT(NDOCOUT,KEYNEW,DLIST(2),
d477 1
a477 1
                    CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d489 1
a489 1
                    CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d523 1
a523 1
                    CALL LUNDOCWRTDAT(NDOCOUT,KEYNEW,DOCBUF2(2,KEY2),
d539 1
a539 1
                    CALL LUNDOCWRTDAT(NDOCOUT,KEYNEW,DLIST(2),
d557 1
a557 1
                       CALL LUNDOCWRTDAT(NDOCOUT,KEYNEW,DLIST(2),
d572 1
a572 1
                       CALL LUNDOCWRTDAT(NDOCOUT,KEYNEW,DOCBUF2(2,KEY2),
d601 1
a601 1
                             CALL LUNDOCWRTDAT(NDOCOUT,KEYNEW,
d642 1
a642 1
                       CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d657 1
a657 1
                       CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d723 1
a723 1
                       CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d749 1
a749 1
                       CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d821 1
a821 1
                    CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d839 2
a840 1
 
d931 1
a931 1
	DATA NDOCIN,NDOCIN2,NDOCOUT/70,71,72/
d940 1
a940 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,' ',
d978 1
a978 1
           CALL LUNDOCWRTDAT(NDOCOUT,IKEY,DLIST,NLIST,IRTFLG)
d1003 1
a1003 1
	DATA NDOCIN,NDOCIN2,NDOCOUT/70,71,72/
d1012 1
a1012 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,' ',
d1054 1
a1054 1
          CALL LUNDOCWRTDAT(NDOCOUT,IKEY,DLIST,NLIST,IRTFLG)
d1083 1
a1083 1
	DATA NDOCIN,NDOCIN2,NDOCOUT/70,71,72/
d1092 1
a1092 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,' ',
d1106 1
a1106 1
            CALL LUNDOCWRTDAT(NDOCOUT,IKEY,DLIST,NLIST,IRTFLG)
d1129 1
a1129 1
	DATA NDOCIN,NDOCIN2,NDOCOUT/70,71,72/
d1135 2
a1136 2
        CALL OPENDOC(DOCNAM,.TRUE.,NLET,NDOCIN,.TRUE.,'INPUT DOCUMENT',
     &                     .TRUE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
d1144 1
a1144 1
10      CALL LUNDOCREDNXT(NDOCIN,IKEY,DLIST,MAXDIM,ICOUNT,IRTFLG)
a1148 1

a1153 1

d1194 1
d1227 1
a1227 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.TRUE.,
d1255 1
a1255 1
                 CALL LUNDOCWRTDAT(NDOCOUT,IKEYNOW,DOCBUF(2,IKEYGOT),
a1258 1

@


1.31
log
@NLETP bug in 'DOC COMB'
@
text
@d15 1
d1245 2
@


1.30
log
@doc com bug
@
text
@d14 1
d1217 1
a1217 1
        CALL FILELIST(.TRUE.,NDOCIN2,FILPAT,NLET,INUMBR,NILMAX,NFILE,
d1239 1
a1239 1
           CALL FILGET(FILPAT,DOCNAM1,NLET,INUMBR(IFILE),IRTFLG)
@


1.29
log
@nloop,iloop_removed
@
text
@d13 1
d17 1
a17 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
a1206 2
        INTEGER, ALLOCATABLE, DIMENSION(:) :: ILIST
        REAL, ALLOCATABLE, DIMENSION(:)    :: DLIST
d1212 1
a1212 1
C       ALLOCATE SPACE FOR DOC FILE LIST
a1213 5
        ALLOCATE(ILIST(NILMAX),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'DOC COM, NILMAX',IER)
           RETURN
        ENDIF
d1216 1
a1216 1
        CALL FILELIST(.TRUE.,NDOCIN2,FILPAT,NLET,ILIST,NILMAX,NFILE,
d1218 1
a1218 1
        IF (IRTFLG .NE. 0) GOTO 9999
d1238 1
a1238 1
           CALL FILGET(FILPAT,DOCNAM1,NLET,ILIST(IFILE),IRTFLG)
d1247 1
a1247 6
           NLIST = MAXX
           ALLOCATE(DLIST(NLIST),STAT=IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(101,'UNABLE TO ALLOCATE DLIST IN DOCCOMBINE',ND)
              GOTO 9999
           ENDIF
d1252 1
a1252 6
C                KEY EXISTS
                 DO ICOL = 2,MAXX
                    DLIST(ICOL - 1) = DOCBUF(ICOL,IKEY)
                 ENDDO

C                PUSH DLIST INTO DOC. FILE
d1254 1
a1254 1
                 CALL LUNDOCWRTDAT(NDOCOUT,IKEYNOW,DOCBUF(2,IKEY),
a1259 1
           IF (ALLOCATED(DLIST)) DEALLOCATE(DLIST)
d1266 1
a1269 4

C       DEALLOCATE ILIST & DLIST MEMORY
        IF (ALLOCATED(ILIST)) DEALLOCATE(ILIST)
        IF (ALLOCATED(DLIST)) DEALLOCATE(DLIST)
@


1.28
log
@doc combine
@
text
@d215 1
a215 1
11         CALL RDPRI1S(KEYCOL,NLOOP,ILOOP,PROMPT(1:NLETP),IRTFLG)
d943 1
a943 1
10      CALL RDPRI1S(KEYCOL,NLOOP,ILOOP,
d1015 1
a1015 1
        CALL RDPRM1S(PERCENT,NLOOP,ILOOP,'PERCENT WANTED',IRTFLG)
@


1.27
log
@closed ndocout in some routines
@
text
@d12 1
d33 1
d36 1
a36 1
 	CHARACTER(LEN=80)                 :: DOCNAM
d61 5
d128 1
d130 1
a130 1
	CHARACTER(LEN=80)                 :: DOCNAM2,DOCNAM3
d919 1
d921 1
a921 1
	CHARACTER(LEN=80)                :: DOCNAM3
d992 1
d994 1
a994 1
	CHARACTER(LEN=80)                 :: DOCNAM3
d1073 1
d1078 1
a1078 1
	CHARACTER(LEN=80)                 :: DOCNAM3
d1194 99
@


1.26
log
@fixed schema name
@
text
@d3 10
a12 9
C                                                                      *
C DOCS1 NEW                JUNE 99  ARDEAN LEITH
C       ADDED 'DOC RAN'    AUG 99   ARDEAN LEITH
C       USED LUNDOCWRTDAT  AUG 99   ARDEAN LEITH                                                                 *
C       ADDED 'DOC AND'    SEPT 99  ARDEAN LEITH
C       ADDED 'DOC SPLIT'  OCT 99   ARDEAN LEITH
C       OPENDOC PARAMETERS DEC 2000 ARDEAN LEITH
C       ADDED 'DOC TOMINESET' JUNE 2001 ARDEAN LEITH
C                                                                      *
d972 1
d1053 2
d1096 2
@


1.25
log
@fixed mineset file names
@
text
@d1143 1
a1143 1
        CALL OPAUXFILE(.FALSE.,FILNAMS,'scheme',NDOCOUT,0,
@


1.24
log
@added 'DOC MINE'
@
text
@d1123 1
a1123 1
     &                 'N','MINESET OUTPUT FILE',.TRUE.,IRTFLG)
a1125 1
 
d1140 3
a1142 2
C       CREATE MINESET SCHEME OUTPUT FILE 
        FILNAMS = FILNAM(1:NLET)
@


1.23
log
@opendoc parameters changed.
@
text
@d10 1
d14 1
a14 1
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
d43 1
a43 1
C          CREATE NEW DOC FILE --------------------------- 'DOC CREATE'
d53 5
d1096 81
@


1.22
log
@changed order of questions in doc ran
@
text
@d4 6
a9 5
C DOCS1 NEW JUNE 99 ARDEAN LEITH
C       ADDED 'DOC RAN'   AUG 99  ARDEAN LEITH
C       USED LUNDOCWRTDAT AUG 99  ARDEAN LEITH                                                                 *
C       ADDED 'DOC AND'   SEPT 99 ARDEAN LEITH
C       ADDED 'DOC SPLIT' OCT 99  ARDEAN LEITH
d187 1
a187 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,
d223 1
a223 1
           CALL OPENDOC(DOCNAM2,.TRUE.,NLET,NDOCOUT2,.FALSE.,
d923 1
a923 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,
d993 1
a993 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,
d1070 1
a1070 1
        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,
@


1.21
log
@ndocout2 not defined
@
text
@a988 3
        CALL RDPRM1S(PERCENT,NLOOP,ILOOP,'PERCENT WANTED',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

d994 3
@


1.20
log
@bug at end of doc merge allowed 2x line listing
@
text
@d128 1
a128 1
	DATA NDOCIN,NDOCIN2,NDOCOUT/70,71,72/
@


1.19
log
@added link to sd shuffle
@
text
@d546 1
a546 1
                       IF (IGO1 .LT. IKEYS) THEN
d561 1
a561 1
                       IF (IGO1 .LT. IKEYS) THEN
@


1.18
log
@removed unused subroutine
@
text
@d45 6
@


1.17
log
@fiexed merge
@
text
@a1082 13
C       --------------------- PUSHIT ------------------------------

        SUBROUTINE PUSHIT(NDOCOUT,DLIST,MAXX,KEYNEW,
     &                    NVAL,IRTFLG)

        REAL, DIMENSION(MAXX)     :: DLIST

C       PUSH DLIST INTO DOC. FILE
        KEYNEW = KEYNEW + 1
        CALL LUNDOCWRTDAT(NDOCOUT,KEYNEW,DLIST,NVAL,IRTFLG)

        RETURN
        END
@


1.16
log
@added merge with renumber
@
text
@d120 1
d395 1
a395 1
              NVAL = MAX(MAXX,MAXX2)
d418 1
a418 1
                 IKEYT  = DOCBUF((IT - 1) * MAXX2 + 1)
d422 1
a422 1
                       DLIST(IREG) = DOCBUF((IT - 1) * MAXX2 + IREG)
d461 1
a461 1
                       DLIST(IREG) = DOCBUF2( IREG,IT)
d475 2
d490 2
a491 1
              DO IK = 1,MAXKEYS
d499 3
a501 8
                    DO IREG = 1,MAXX
                       DLIST(IREG) = DOCBUF2( IREG, KEY2)
                    ENDDO

C                   PUSH DLIST INTO DOC. FILE
                    NVAL  = MAXX2 - 1
                    IKEYT = DLIST(1)
                    CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d516 2
a517 2
                    IKEYT = DLIST(1)
                    CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d526 1
a526 1
                    IF (VALNEXT1.LT.VALNEXT2)THEN
d533 3
a535 3
                       NVAL  = MAXX - 1
                       IKEYT = DLIST(1)
                       CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
a546 3
                       DO IREG = 1,MAXX2
                          DLIST(IREG) = DOCBUF2(IREG, KEY2)
                       ENDDO
d548 3
a550 4
C                      PUSH DLIST INTO DOC. FILE
                       NVAL  = MAXX2 - 1
                       IKEYT = DLIST(1)
                       CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
d569 1
d577 4
a580 11
                             DO IREG = 1,MAXX2
                                 DLIST(IREG) = DOCBUF2(IREG,KEY1)
                             ENDDO

C                            PUSH DLIST INTO DOC. FILE
                             NVAL  = MAXX - 1
                             IKEYT = DLIST(1)
                             CALL LUNDOCWRTDAT(NDOCOUT,IKEYT,DLIST(2),
     &                                         NVAL,IRTFLG)
                             IF (VALNEXT1 .EQ. VALNEXT2) EXIT

d583 1
d589 1
a589 1
                       IGO2     = IGO2T + 1
d1083 6
d1090 6
@


1.15
log
@getdoc changed
@
text
@d194 5
a198 1
           IF (ERRI2(KEYCOL,IDUM,1,0,MAXX-1,0,0)) GOTO 11
d389 44
a432 1
           IF (KEYCOL .EQ. 0) THEN
@


1.14
log
@getdocdat changed
@
text
@d117 1
a117 1
        REAL, DIMENSION(:), POINTER       :: DOCBUF2
d255 1
a255 1
              CALL SORTIT(DOCBUF2(1),MAXX2,MAXY2,KEYCOL,SORTED2,
d270 1
a270 1
              CALL SORTIT(DOCBUF2(1),MAXX2,MAXY2,KEYCOL,SORTED2,
d394 1
a394 1
     &               KEY2 = DOCBUF2((IT - 1) * MAXX2 + KEYCOL + 1)
d413 1
a413 1
                       DLIST(IREG) = DOCBUF2((IT - 1) * MAXX2 + IREG)
d435 1
a435 1
              VALNEXT2 = DOCBUF2((KEY2 - 1) * MAXX2 + KEYCOL + 1)
d449 1
a449 1
                       DLIST(IREG) = DOCBUF2((KEY2 - 1) * MAXX2 + IREG)
d502 1
a502 1
                          DLIST(IREG) = DOCBUF2((KEY2 - 1) * MAXX2+IREG)
d521 1
a521 2
                          VALNEXT2 = DOCBUF2((KEY2 - 1) * MAXX2 + 
     &                               KEYCOL + 1)
d529 1
a529 1
                          VALNEXT2 = DOCBUF2((KEY2 - 1)*MAXX2+KEYCOL +1)
d535 1
a535 2
                                 DLIST(IREG) = 
     &                             DOCBUF2((KEY1 - 1) * MAXX2 + IREG)
d555 1
a555 1
                          VALNEXT2 = DOCBUF2((KEY2 - 1)*MAXX2+KEYCOL +1)
d573 1
a573 1
                    KEY2 = DOCBUF2((IT - 1) * MAXX2 + KEYCOL + 1)
d680 1
a680 1
                    KEY2 = DOCBUF2((IT - 1) * MAXX2 + KEYCOL + 1)
d785 1
a785 1
           CALL DEALLOCMEM_R(DOCBUF2,IRTFLG)
@


1.13
log
@doc split renumbers keys now
@
text
@d36 1
a36 1
        REAL, DIMENSION(:), POINTER       :: DOCBUF
d69 1
a69 1
           CALL DOCRAN(MAXX, MAXY, DOCBUF(1), DLIST)
d74 1
a74 1
           CALL DOCRENUMBER(MAXX, MAXY, DOCBUF(1), DLIST)
d79 1
a79 1
           CALL DOCSDO(MAXX, MAXY, DOCBUF(1))
d84 1
a84 1
9995    CALL DEALLOCMEM_R(DOCBUF,IRTFLG)
@


1.12
log
@*** empty log message ***
@
text
@a93 33
C       ----------------------- DOCRENUMBER --------------------------

	SUBROUTINE DOCRENUMBER(MAXX, MAXY, DOCBUF, DLIST)

        INCLUDE 'CMBLOCK.INC'

        INTEGER, INTENT(IN)               :: MAXX,MAXY
        REAL, DIMENSION(MAXX*MAXY)        :: DOCBUF
        REAL, DIMENSION(MAXX)             :: DLIST
	CHARACTER(LEN=80)                 :: DOCNAM3
	CHARACTER(LEN=1)                  :: NULL
        LOGICAL                           :: NEWFILE

	DATA NDOCIN,NDOCIN2,NDOCOUT/70,71,72/

	NULL = CHAR(0)

C       RENUMBER THE INPUT DOC FILE--------------------- 'DOC RENUMBER'

        CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

        CALL OPENDOC(DOCNAM3,.TRUE.,NLET,NDOCOUT,.FALSE.,
     &                     .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       DOC REN OPERATION USES NON-STANDARD DOCBUF (WITHOUT KEYS)
C       HAVING LISTING OF ALL LINES IN THE DOC FILE IN ORDER

        DO IKEY = 1,MAXY
            DO ICOL = 1,MAXX
               DLIST(ICOL) = DOCBUF((IKEY - 1) * MAXX + ICOL)
            ENDDO
a94 9
C           PUSH DLIST INTO DOC. FILE
            NLIST = MAXX
            CALL LUNDOCWRTDAT(NDOCOUT,IKEY,DLIST,NLIST,IRTFLG)
        ENDDO

        RETURN
	END


d315 5
a319 3
           NVAL  = MAXX - 1
           DO IX = 1,MAXY,2
               KEY1 = DOCBUF((IX) * MAXX + 1)
d323 1
a323 1
                     DLIST(ICOL) = DOCBUF((IX - 1) * MAXX + ICOL)
d325 1
a325 1

d327 2
a328 1
                  CALL LUNDOCWRTDAT(NDOCOUT,KEY1,DLIST(2),NVAL,IRTFLG)
d331 1
a331 1
               IF (IX .LT. MAXY) THEN
d333 1
a333 1
                  KEY2 = DOCBUF((IX+1) * MAXX + 1)
d336 1
a336 1
                        DLIST(ICOL) = DOCBUF((IX) * MAXX + ICOL)
d338 2
a339 2

                     CALL LUNDOCWRTDAT(NDOCOUT2,KEY2,DLIST(2),
d1003 42
@


1.11
log
@added doc split
@
text
@d21 1
a21 3
C  PURPOSE: 'AT IT" USING CATEGORIZE INPUT DOCUMENT FILE, PUTS ALL 
C           THE IMAGE NUMBERS IN AN ASCENDING ORDER, WITH A 
C           SEQUENTIAL KEY NUMBER AND REMOVES DUPLICATED ENTRIES.
d428 6
a433 2
                 KEY1 = DOCBUF((IT - 1) * MAXX + KEYCOL + 1)
                 KEY2 = DOCBUF2((IT - 1) * MAXX2 + KEYCOL + 1)
d436 3
a438 2
     &               KEY2 .LE. 0) THEN
C                   KEY1 EXISTS, PUSH DLIST FROM FILE 1 INTO OUTPUT FILE
d813 1
a813 1
C       CLOSE THE OUTPUT DOC. FILE
@


1.10
log
@added "DOC AND"
@
text
@d8 1
d40 1
a40 1
	DATA NDOCIN,NDOCIN2,NDOCOUT/70,71,72/
d250 9
a258 1
        ENDIF
d268 1
d357 29
d812 1
d1041 1
@


1.9
log
@used lundoc, added doc ran
@
text
@d5 3
a7 2
C       ADDED 'DOC RAN'   AUG 99 ARDEAN LEITH
C       USED LUNDOCWRTDAT AUG 99 ARDEAN LEITH                                                                 *
a26 11
#ifndef SP_F90

	SUBROUTINE DOCS1(MAXDIM)
        INCLUDE 'CMBLOCK.INC'

        CALL ERRT(101,'OPERATION NOT COMPILED UNDER F77',IDUM)
        RETURN
        END

#else

d145 1
d203 13
d227 2
a228 1
     &      FCHAR(4:5) .EQ. 'ME' .OR. FCHAR(4:5) .EQ. 'SU' ) THEN
d233 1
d255 2
a256 1
     &      FCHAR(4:5) .EQ. 'IT' ) THEN
d264 1
d292 15
d668 101
d780 2
a781 1
9997    IF (FCHAR(4:5) .EQ. 'ME' .OR. FCHAR(4:5) .EQ. 'SU' ) THEN
a1001 2

#endif
@


1.8
log
@irtflg set in sortit
@
text
@d4 3
a6 1
C DOCS1                                                                *
d36 1
d41 4
a44 7
        INTEGER,INTENT(IN)               :: MAXDIM
	CHARACTER(LEN=80)                :: DOCNAM,DOCNAM2,DOCNAM3
	CHARACTER(LEN=1)                 :: NULL,ANSW
        LOGICAL                          :: NEWFILE,ERRI2,RENUMBER

        REAL, DIMENSION(:), POINTER      :: SORTED,SORTED2,DLIST 
        REAL, ALLOCATABLE, DIMENSION(:,:):: DOCBUF3
d47 1
a47 3
        REAL, DIMENSION(:), POINTER      :: DOCBUF,DOCBUF2
	CHARACTER(LEN=80)                :: PROMPT
        LOGICAL                          :: SENDIT,REP_KEY,UNIQUE
a48 3
        INTEGER, DIMENSION(1)            :: ILIST
        COMMON ILIST

a50 2
	NULL = CHAR(0)

d52 1
a52 1
C          CREATE NEW DOC FILE ---------------------------- 'DOC CREATE'
d54 1
a54 1
           CALL DOCCREATE(DOCNAM3,MAXDIM)
d58 1
a58 1

d63 2
d71 21
a91 8
        IF (FCHAR(4:5) .EQ. 'ME' .OR. FCHAR(4:5) .EQ. 'SU' ) THEN
C          MERGE & SUBTRACT USE 2 INPUT DOC. FILES
C          MAXX2 IS 1 + NUM OF REGISTERS SINCE DOCBUF CONTAINS KEY ALSO
           MAXX2  = 0
           MAXY2  = 0
           CALL GETDOCDAT('SECOND INPUT DOCUMENT',.TRUE.,DOCNAM2,
     &                  NDOCIN2,.TRUE.,MAXX2, MAXY2,DOCBUF2,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9998
d94 83
d192 8
d204 8
d214 1
a220 2
        NRUN = 1
        IAP  = 1
d239 1
d245 2
d250 2
d258 5
a262 2
           CALL ALLOCMEM(MAXY,SORTED,.TRUE.,'DOCS1',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9997
d266 1
a266 1
           CALL SORTIT(DOCBUF(1),MAXX,MAXY,KEYCOL,SORTED,
d268 1
a268 1
           IF (IRTFLG .NE. 0) GOTO 9996
d272 5
a276 2
              CALL ALLOCMEM(MAXY2,SORTED2,.TRUE.,'DOCS1',IRTFLG)
              IF (IRTFLG .NE. 0)GOTO 9996
d287 9
a295 8
        IF (FCHAR(4:5) .EQ. 'RE') THEN
C          RENUMBER THE INPUT DOC FILE------------------ 'DOC RENUMBER'

           CALL ALLOCMEM(MAXX,DLIST,.TRUE.,'DOCS1',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9995

           DO IKEY = 1,MAXY
               DLIST(1) = IKEY 
a296 6
               DO ICOL = 1,MAXX
                  DLIST(ICOL+1) = DOCBUF((IKEY - 1) * MAXX + ICOL)
               ENDDO
C              PUSH DLIST INTO DOC. FILE
               CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX+1,NRUN,IAP)
           ENDDO
d298 1
a298 1
        ELSEIF (FCHAR(4:5) .EQ. 'SO' .OR. FCHAR(4:5) .EQ. 'IT') THEN
a302 3
           CALL ALLOCMEM(MAXX,DLIST,.TRUE.,'DOCS1',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9995

d307 1
a307 1
                  NEWKEY = NEWKEY + 1
d316 1
d318 4
a321 1
               CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
a329 4
           NLIST = MAX(2,KEYCOL+1)
           CALL ALLOCMEM(NLIST,DLIST,.TRUE.,'DOCS1',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9995

d345 1
a345 1
                    DLIST(1)      = NEWKEY
d349 5
a353 1
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,NLIST,NRUN,IAP)
a362 2
           CALL ALLOCMEM(MAXXT,DLIST,.TRUE.,'DOCS1',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9995
d377 7
a383 1
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
d389 7
a395 1
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX2,NRUN,IAP)
d425 7
a431 1
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX2,NRUN,IAP)
d441 7
a447 1
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
d459 7
a465 1
                       CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
d478 7
a484 1
                       CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX2,NRUN,IAP)
d513 6
a518 2
                             CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,
     &                                  NRUN,IAP)
a541 3
           CALL ALLOCMEM(MAXX,DLIST,.TRUE.,'DOCS1',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9995

d555 7
a561 1
                       CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
d570 6
a575 1
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
d636 6
a641 1
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
a647 1
	CALL SAVDC
d651 3
a653 6
9994    CALL DEALLOCMEM_R(DLIST,IRTFLG)

9995    IF (FCHAR(4:5) .EQ. 'SU') THEN
           CALL DEALLOCMEM_R(SORTED2,IRTFLG)
        ENDIF
9996    IF (FCHAR(4:5) .NE. 'RE') CALL DEALLOCMEM_R(SORTED,IRTFLG)
a659 1
9998    CALL DEALLOCMEM_R(DOCBUF,IRTFLG)
d730 1
a730 1
	SUBROUTINE DOCCREATE(DOCNAM3,MAXDIM)
d734 1
a735 1
	CHARACTER(LEN=80),INTENT(INOUT)  :: DOCNAM3
d738 1
a738 5

        REAL, DIMENSION(:), POINTER      :: DLIST 
        REAL, ALLOCATABLE, DIMENSION(:,:):: DOCBUF3

        INCLUDE 'F90ALLOC.INC'
d741 1
a741 1
        COMMON ILIST
d743 1
a743 1
	DATA NDOCOUT/72/
d746 2
a747 2
        NRUN = 0
        IAP  = 1
d749 2
a750 1
C          CREATE OUTPUT DOC FILE ------------------------- 'DOC CREATE'
d752 3
a754 2
           CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d756 4
a759 4
10         CALL RDPRI1S(KEYCOL,NLOOP,ILOOP,
     &          'COLUMN TO BE FILLED (0 IS KEY)',IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
           IF (ERRI2(KEYCOL,IDUM,1,0,6,0,0)) GOTO 10
d761 2
a762 2
           NUMB = MAXDIM
           CALL RDPRAI(ILIST,MAXDIM,NUMB,1,MAXDIM,'ENTER NUMBERS',
d764 54
a817 1
           IF (IRTFLG .NE. 0) RETURN
d819 2
a820 3
           MAXX = MAX(2,KEYCOL+1)
           CALL ALLOCMEM(MAXX,DLIST,.TRUE.,'DOCS1',IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d822 2
a823 4
C          FILL UNUSED COLUMNS WITH ZERO'S
           DO I = 1, MAXX
              DLIST(I) = 0.0
           ENDDO
d825 3
a827 2
C          IF FILLING KEYS PUT A 1.0 IN FIRST REGISTER COL.
           IF (KEYCOL .EQ. 0) DLIST(2) = 1.0
d829 3
a831 12
           DO I=1,NUMB
              DLIST(1)        = I
C             IF FILLING KEYS THIS WILL OVERWRITE COLUMN ONE AS WANTED
              DLIST(KEYCOL+1) = ILIST(I)

C             PUSH DLIST INTO DOCNAM3 DOC. FILE
              CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
              NRUN = 1
           ENDDO
           CLOSE(NDOCOUT)
           CALL SAVDC()
           CALL DEALLOCMEM_R(DLIST,IRTFLG)
d833 11
d845 29
d875 3
a877 1
        END
@


1.7
log
@added renumber op
@
text
@d564 1
@


1.6
log
@used lundoc
@
text
@d67 5
a71 2
        MAXX   = 0
        MAXY   = 0
d73 1
a73 1
     &                 NDOCIN,.TRUE.,MAXX, MAXY,DOCBUF,IRTFLG)
d170 17
a186 1
        IF (FCHAR(4:5) .EQ. 'SO' .OR. FCHAR(4:5) .EQ. 'IT') THEN
d493 1
a493 1
9996    CALL DEALLOCMEM_R(SORTED,IRTFLG)
@


1.5
log
@bad speellin of ikey2
@
text
@d49 1
a49 1
        LOGICAL                          :: SENDIT,REP_KEY
d122 1
a122 1
           IF (ERRI2(KEYCOL,IDUM,2,0,MAXX-1,0,0)) GOTO 11
d147 1
d150 1
a150 1
     &                 IKEYS,.TRUE.,IRTFLG)
d159 2
a160 1
              REP_KEY = (FCHAR(4:5) .EQ. 'ME') 
d162 1
a162 1
     &                    IKEYS2,REP_KEY,IRTFLG)
d428 2
a429 2
     &                      IGO2 .LT. IKEYS2) THEN
C                      VALUE 1 = NEXT VALUE 2, MUST INCREASE VALNEXT2
d432 1
a432 1
                       VALNEXT2 = SORTED2(IGO2)
d490 1
a490 1
     &                    IKEYS,RET_KEY,IRTFLG)
d495 1
a495 1
        LOGICAL,INTENT(IN)                      :: RET_KEY
d501 3
a503 1
        IKEYS = 0
d514 1
a514 1
                 SORTED(IKEYS) = DOCBUF(KEYCOL+1,IROW)
d518 1
a518 1
              RKEYARAY(IKEYS)  = DOCBUF(KEYCOL+1,IROW)
d525 20
@


1.4
log
@needed f77 ifdef
@
text
@d334 1
a334 1
                       DO IGO2T = IGO2,IKEY2
d353 1
a353 1
                       ENDDO   !DO IGO2T = IGO2,IKEY2
@


1.3
log
@added "at it' operation
@
text
@d24 10
d593 1
@


1.2
log
@bugs fixed
@
text
@d17 3
a19 3
C  PURPOSE: USING CATEGORIZE INPUT DOCUMENT FILE, PUTS ALL THE IMAGE  
C           NUMBERS IN AN ASCENDING ORDER, WITH A SEQUENTIAL KEY 
C           NUMBER AND REMOVES DUPLICATED ENTRIES.
d49 1
a49 1
C          CREATE OUTPUT DOC FILE ------------------------- 'DOC CREATE'
d64 1
d120 13
d155 1
a155 1
        IF (FCHAR(4:5) .EQ. 'SO') THEN
d157 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
C DOCS1                                                                 *
d33 1
a33 1
        REAL, DIMENSION(:), POINTER      :: SORTED,SORTED2,SORTED3,DLIST 
d39 1
a46 2
        NRUN = 0
        IAP  = 1
d51 1
a51 37
           CALL FILERD(DOCNAM3,NLET,NULL,'OUTPUT DOCUMENT',IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

10         CALL RDPRI1S(KEYCOL,NLOOP,ILOOP,
     &          'COLUMN TO BE FILLED (0 IS KEY)',IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
           IF (ERRI2(KEYCOL,IDUM,1,0,6,0,0)) GOTO 10

           NUMB = MAXDIM
           CALL RDPRAI(ILIST,MAXDIM,NUMB,1,MAXDIM,'ENTER NUMBERS',
     &                 NULL,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           MAXX = MIN(2,KEYCOL+1)
           CALL ALLOCMEM(MAXX,DLIST,.TRUE.,'DOCS1',IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9997

C          FILL UNUSED COLUMNS WITH ZERO'S
           DO I = 1, MAXX
              DLIST(I) = 0.0
           ENDDO

C          IF FILLING KEYS PUT A 1.0 IN FIRST REGISTER COL.
           IF (KEYCOL .EQ. 0) DLIST(2) = 1.0

           DO I=1,NUMB
              DLIST(1)        = I
C             IF FILLING KEYS THIS WILL OVERWRITE COLUMN ONE AS WANTED
              DLIST(KEYCOL+1) = ILIST(I)

C             PUSH DLIST INTO DOCNAM3 DOC. FILE
              CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
              NRUN = 1
           ENDDO
           CLOSE(NDOCOUT)
           CALL SAVDC()
           CALL DEALLOCMEM_R(DLIST,IRTFLG)
a71 3
        CALL FILERD(DOCNAM3,NLET,CHAR(0),'OUTPUT DOCUMENT',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9997

d93 2
d96 5
d123 3
a125 2
C          RETURN LIST OF KEYS SORTED USING VALUE IN KEYCOL
           CALL SORTIT(DOCBUF(1),MAXX,MAXY,KEYCOL,SORTED,IKEYS,IRTFLG)
d128 2
a129 2
           IF (FCHAR(4:5) .EQ. 'SU' ) THEN
C             SORT THE SECOND LIST OF KEYS ALSO
d133 2
a134 1
C             RETURN LIST OF KEYS SORTED USING VALUE IN KEYCOL
d136 1
a136 1
     &                    IKEYS2,IRTFLG)
a162 1
               NRUN = 1
a166 1
           NEWVAL  = 0
d168 2
a169 1
           LASTVAL = 1
d171 2
a172 2
           MAXX = MIN(2,KEYCOL+1)
           CALL ALLOCMEM(MAXX,DLIST,.TRUE.,'DOCS1',IRTFLG)
d176 1
a176 1
           DO I = 1,KEYCOL+1
d184 1
a184 1
              IF (IVAL .GT. LASTVAL) THEN
d191 1
a191 1
                    DLIST(KEYCOL) = IT
d194 1
a194 2
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,2,NRUN,IAP)
                    NRUN = 1
d212 5
a216 2
                 IF (IT .LE. MAXY .AND. KEY1 .NE. 0) THEN
C                   KEY EXISTS, PUSH DLIST INTO OUTPUT FILE
d221 2
a222 6
                    NRUN = 1
                 ENDIF

                 KEY2 = DOCBUF2((IT - 1) * MAXX2 + KEYCOL + 1)
                 IF (IT .LE. MAXY2 .AND. KEY2 .NE. 0) THEN
C                   KEY EXISTS, PUSH DLIST INTO OUTPUT FILE
d224 1
a224 1
                       DLIST(IREG) = DOCBUF((IT - 1) * MAXX2 + IREG)
a226 1
                    NRUN = 1
d232 19
d252 7
a258 8
C             MAXYT CAN NOT BE MORE THAN SUM OF INPUTS
              MAXYT = MAXX + MAXY
              ALLOCATE(DOCBUF3(MAXYT,MAXXT))
              IF (IRTFLG .NE. 0) THEN
                 CALL ERRT(101,'CAN NOT ALLOCATE MEMORY IN DOCS1',IDUM)
                 GOTO 9995
              ENDIF
              CALL CHKALLOC(1,MAXYT*MAXXT,IRTFLG)
d260 9
a268 4
C             CLEAR OUTPUT BUFFER
              DO IK = 1,MAXXT
                 DOCBUF3(1,IK) = 0
              ENDDO
d270 2
a271 2
C             INITIALIZE NEXT KEY NUMBER
              KEYGOT = 0
d273 4
a276 13
C             FILL OUTPUT BUFFER WITH MERGED KEYCOL COLUMN
              DO IK = 1,MAXX
                 KEY1 = DOCBUF((IT - 1) * MAXX + 0 + 1)
                 IF (KEY1 .GT. 0) THEN
C                   THIS KEY EXISTS
                    LOC1 = DOCBUF((IT - 1) * MAXX + KEYCOL + 1)
                    IF (LOC1 .GT. 0) THEN
C                      PUT THIS LINE IN OUTPUT BUFFER
                       KEYGOT   = KEYGOT + 1
                       DOCBUF3(1,KEYGOT) = KEYGOT
                       DO IREG = 2,MAXX
                          DOCBUF3(IREG,KEYGOT) = 
     &                          DOCBUF((IT - 1) * MAXX + IREG)
d278 12
a289 16
                    ENDIF
                 ENDIF
              ENDDO

              DO IK = 1,MAXX2
                 KEY2 = DOCBUF2((IT - 1) * MAXX2 + 0 + 1)
                 IF (KEY2 .GT. 0) THEN
C                   THIS KEY EXISTS
                    LOC2 = DOCBUF2((IT - 1) * MAXX2 + KEYCOL + 1)
                    IF (LOC2 .GT. 0) THEN
C                      PUT THIS LINE IN OUTPUT BUFFER
                       KEYGOT   = KEYGOT + 1
                       DOCBUF3(1,KEYGOT) = KEYGOT
                       DO IREG = 2,MAXX
                          DOCBUF3(IREG,KEYGOT) = 
     &                          DOCBUF((IT - 1) * MAXX + IREG)
d291 45
a335 3
                    ENDIF
                 ENDIF
              ENDDO
d337 2
a338 9
              DO KEY = 1,KEYGOT
                 IF (DOCBUF3(1,KEY) .GT. 0) THEN
C                   KEY EXISTS IN MERGED DOC FILE, PUSH DLIST INTO OUTPUT 
                    DO IREG = 1,MAXXT
                       DLIST(IREG) = DOCBUF3(IREG,KEY)
                    ENDDO
                    CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
                    NRUN = 1
                 ENDIF
a339 4

C             DEALLOCATE ALLOCATABLE ARRAYS
              DEALLOCATE(DOCBUF3)
              CALL CHKALLOC(2,MAXYT*MAXXT,IRTFLG)
a341 2


d349 1
a349 1
C             EXCLUSIVE MERGING BY KEY
d353 1
a353 1
C                   KEY EXISTS IF FIRST FILE, CHECK EXISTANCE IN 2ND
d356 1
a356 1
                    IF (KEY1 .EQ. 0) THEN
a361 1
                       NRUN = 1
d363 8
d375 5
a379 16
C             MERGING BY COLUMN OTHER THAN KEY

              CALL ALLOCMEM(MAXY2,SORTED3,.TRUE.,'DOCS1',IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9995

C             CLEAR SORTED3 BUFFER
              DO IT = 1,MAXY2
                 SORTED3(IT) = 0
              ENDDO
C             SORTED3 LISTS VALUES FOUND IN KEYCOL OF 2'ND DOC FILE
              DO IT = 1,MAXY2
                 KEY           = SORTED2(IT)
                 IVAL          = DOCBUF2((KEY - 1) * MAXX + KEYCOL + 1)
                 SORTED3(IVAL) = 1.0
              ENDDO

d381 1
a381 1
              DO IK = 1,MAXX
a382 1
                 IVAL1 = DOCBUF((IT - 1) * MAXX + KEYCOL + 1)
d384 37
a420 11
                 IF (IVAL1 .GT. 0) THEN
C                   THIS VALUE IS MORE THAN ZERO IN FIRST FILE
                    LOC1 = DOCBUF((IT - 1) * MAXX + KEYCOL + 1)

                    IF (IVAL1 .LE. MAXY2 .AND. 
     &                  SORTED3(IVAL1) .EQ. 0) THEN
C                      VALUE FROM KEYCOL NOT IN 2'ND DOC. FILE
C                      PUT LINE FROM FIRST DOC. FILE INTO OUTPUT FILE
                       DO IREG = 1,MAXXT
                          DLIST(IREG) = 
     &                       DOCBUF((IT - 1) * MAXX + IREG)
d422 10
a431 3
                       CALL SAVDN1(NDOCOUT,DOCNAM3,DLIST,MAXX,NRUN,IAP)
                       NRUN = 1
                    ENDIF
a433 1
              CALL DEALLOCMEM_R(SORTED3,IRTFLG)
d463 1
a463 1
     &                    IKEYS,IRTFLG)
d468 1
d480 7
a486 2
C             RETURN THE KEY NUMBER IN SORTED
              SORTED(IKEYS) = IROW
d500 1
a500 3
#ifdef NEVER
C       ------------------------- PUTDOC ------------------------------
	SUBROUTINE PUTDOC(DOCBUF,MAXX,MAXY,NLIST,COMPRESS,IRTFLG)
d502 2
d506 37
a542 4
	DIMENSION     DOCBUF(MAXX,MAXY)
        DIMENSION     DLIST(29)
        LOGICAL       COMPRESS
        CHARACTER *81 DOCNAM
d544 4
a547 1
        DATA NDOCOUT/70/
d549 2
a550 2
        CALL FILERD(DOCNAM,NLET,CHAR(0),'OUTPUT DOCUMENT',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
d552 4
d557 2
a558 16
        NLIST  = MAXX
        NRUN    = 0
        IAP     = 0
        NEXTNUM = 1
        DO IROW = 1,MAXY
           IF (DOCBUF(1,IROW) .EQ. IROW) THEN
              IF (COMPRESS) THEN
                 DLIST(1) = NEXTNUM
                 NEXTNUM  = NEXTNUM + 1
              ELSE
	         DLIST(1) = IROW
              ENDIF
              DO ICOL =2,NLIST
	         DLIST(ICOL) = DOCBUF(ICOL,IROW)
              ENDDO
	      CALL SAVD(NDOCOUT,DOCNAM,DLIST,NLIST,NRUN,IAP)
d560 5
a564 2
           ENDIF
	END DO
a565 4
	CALL SAVDC
	CLOSE(NDOCOUT)
        IRTFLG = 0

d567 1
a567 2
	END	
#endif
@
