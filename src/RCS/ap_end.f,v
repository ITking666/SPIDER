head	1.45;
access;
symbols
	pre_getangas:1.34
	GPL2010:1.33
	pre_GPL2010:1.32
	pre_var_equation:1.30
	pre_fftwrings:1.28
	pre_opfiles:1.28
	src:1.28
	best-code:1.28
	x-named-regs:1.28
	x:1.28
	v13-00:1.28
	pre_GPL:1.26;
locks; strict;
comment	@c @;


1.45
date	2012.10.01.13.47.31;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2012.06.11.16.49.10;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2012.06.11.12.39.00;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2012.05.14.13.57.52;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2012.05.14.13.56.21;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2012.04.03.18.58.36;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2012.04.02.16.21.53;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2012.04.02.16.09.15;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2012.03.07.16.35.43;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2011.12.13.15.46.25;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2011.02.16.18.54.47;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2010.10.12.18.37.56;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.24.13.25.03;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2009.08.26.13.49.36;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.21.14.01.33;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.25.15.47.39;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2008.10.31.15.19.49;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.17.20.34.42;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.17.18.25.17;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.09.16.54.36;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.30.20.09.29;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.19.15.13.07;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.03.16.29.02;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.02.15.26.00;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2004.10.26.15.06.32;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2004.10.12.19.25.30;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2004.10.07.14.41.18;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.07.14.38.24;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.05.19.35.40;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.05.16.35.44;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2004.09.30.16.53.25;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2004.09.20.12.39.39;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.20.20.17.39;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.20.19.29.45;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.03.15.11.54;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.03.12.58.30;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.18.14.36.05;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.23.17.48.31;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.20.15.35.24;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2004.03.29.20.37.09;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2004.03.22.21.29.52;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.22.21.26.06;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2004.03.22.16.31.49;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2004.03.16.14.33.56;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2004.03.11.14.57.15;	author leith;	state Exp;
branches;
next	;


desc
@@


1.45
log
@added 2 more digits to ccrot output format
@
text
@
C++*********************************************************************
C
C    AP_END
C           PEAKV REMOVED                           MAR 04 ArDean Leith
C           IKEY                                    MAR 04 ArDean Leith
C           ANGDIF IF CHANGE IN MIRROR              AUG 04 ArDean Leith
C           ANGLES IN REG OUTPUT WRONG              AUG 04 ArDean Leith
C           APEND2                                  SEP 04 Chao Yang
C           REWRITE FOR END OF 'AP MD'..            SEP 04 ArDean Leith
C           REWRITE FOR UN-MIRROR                   OCT 04 ArDean Leith
C           RANGOUT <= 360                          DEC 04 ArDean Leith
C           MPI WRITES TO REGISTERS NOW             OCT 08 ArDean Leith
C           REMOVED APSHIFT CALL                    NOV 08 ArDean Leith
c           IF (NPROJ.EQ.0)NPROJ=1                  AUG 09 ArDean Leith
C           IF(ABS(ANGDIF).LT.ALMOSTZERO)           AUG 09 ArDean Leith
C           REMOVED OBSLT                           OCT 10 ArDean Leith
C           AP_ENDS FOR REPORTING RAW SHIFTS        MAR 12 ArDean Leith
C           ABS(PEAKV)                              MAY 12 ArDean Leith
C           KEEP OLD PARAM ALWAYS                   JUN 12 ArDean Leith
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C   AP_END(IMGEXP,IMGREF, 
C          ANGREF,REFDIR, ANGEXP,EXPDIR,ISHRANGE,
C          GOTREFANG, NGOTPAR,CCROTT,PEAKVT,
C          RANGNEW,MIRRORNEW,REFPAT,
C          NPROJT,LUNDOC,DLIST)
C   
C PURPOSE : WRITE ALIGNMENT PARAMETERS TO OUTPUT FILE
C
C PARAMETERS:
C       KEY               IMAGE KEY NUMBER                 (INPUT)
C       IMGEXP            EXP IMAGE NUMBER                 (INPUT)
C       IMGREF            REF IMAGE NUMBER                 (INPUT)
C       ANGREF            REF IMAGE DIRECTION              (INPUT)
C       REFDIR            REF IMAGE DIRECTION              (INPUT)
C       ANGEXP            EXP IMAGE DIRECTION              (INPUT)
C       EXPDIR            EXP IMAGE DIRECTION              (INPUT)
C       ISHRANGE          SHIFT RANGE                      (INPUT)
C       GOTREFANG         FLAG FOR REF. ANGLES AVAIL.      (INPUT)
C       NGOTPAR           NUMBER OF PARAMETERS IN DOC      (INPUT)
C       CCROTT            ROTATIONAL CC VALUE              (INPUT)
C       PEAKVT            FINAL CC VALUE                   (INPUT)            
C       RANGNEW           ROTATION                         (INPUT)
C       XSHNEW,YSHNEW     SHIFT VALUES                     (INPUT)
C       MIRRORNEW         MIRRORED FLAG                    (INPUT)
C       REFPAT            REF. IMAGE SERIES FILE TEMPLATE  (INPUT)
C       NPROJT            # OF PROJECTIONS                 (INPUT)
C       CTYPE             'SH', 'FOU', or 'REF' FLAG       (INPUT)
C       LUNDOC            DOC. FILE OUTPUT UNIT            (INPUT)  
C       CHNG_ORDER        CHANGE ORDER OF SHIFT/ROTATE     (INPUT)
C       SAY_RAW           SAY RAW SHIFTS                   (INPUT)
C       DLIST             PARAMETERS                       (OUTPUT)
C
C  OPERATIONS:  'AP REF', 'AP SH'
C
C--*********************************************************************

         SUBROUTINE AP_ENDS(KEY,IMGEXP,IMGREF, 
     &                  ANGREF,REFDIR, 
     &                  ANGEXP,EXPDIR,ISHRANGE,
     &                  GOTREFANG, NGOTPAR, CCROTT,PEAKVT,
     &                  RANGNEW,XSHRAW,YSHRAW, MIRRORNEW,REFPAT,
     &                  NPROJT, CTYPE, LUNDOC,
     &                  CHNG_ORDER,SAY_RAW,DLIST)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER             :: KEY,IMGEXP,IMGREF
	REAL                :: ANGREF(3),REFDIR(3)
	REAL                :: ANGEXP(7),EXPDIR(3)
        INTEGER             :: ISHRANGE
	LOGICAL             :: GOTREFANG
        INTEGER             :: NGOTPAR
	REAL                :: CCROTT,PEAKVT,RANGNEW,XSHRAW,YSHRAW
        LOGICAL             :: MIRRORNEW
        CHARACTER (LEN=*)   :: REFPAT 
        INTEGER             :: NPROJT
        CHARACTER (LEN=*)   :: CTYPE 
        INTEGER             :: LUNDOC
        REAL                :: DLIST(*)
        LOGICAL             :: CHNG_ORDER,SAY_RAW

        LOGICAL             :: MIRROROLD
	REAL                :: ANGOUT(3)

        REAL, PARAMETER     :: QUADPI = 3.14159265358979323846
        REAL, PARAMETER     :: DGR_TO_RAD = (QUADPI/180)
        REAL, PARAMETER     :: ALMOST_ZERO = 0.05

         NPROJ   = NPROJT
c         IF (NPROJ .EQ. 0) NPROJ = 1 removed aug 09 al

         PEAKV = PEAKVT

         IF (IMGREF > 0) THEN
C           IMGREF IS NUMBER OF MOST SIMILAR REF. IMAGE 
            CCROT   = CCROTT
         ELSE
C           NO REFERENCE IMAGE SELECTED
            CCROT = -1.0
            PEAKV = 0.0
         ENDIF

C        SET NEW PROJECTION ANGLES
         ANGOUT = 0.0            ! DEFAULT VALUE
         IF (IMGREF > 0 .AND. GOTREFANG) THEN
C           USE REF. ANGLES AS NEW PROJECTION ANGLES
            ANGOUT = ANGREF(1:3)

            IF (MIRRORNEW) THEN
C              REF. PROJECTION MUST BE MIRRORED
               ANGOUT(1) = -ANGOUT(1)
               ANGOUT(2) = 180+ANGOUT(2)
            ENDIF
         ELSEIF (NGOTPAR >= 3) THEN
C           KEEP OLD EXP. PROJ. ANGLES 
            ANGOUT = ANGEXP(1:3)
         ENDIF

         RANGOLD   = 0.0
         XSHOLD    = 0.0
         YSHOLD    = 0.0

         IF (NGOTPAR >= 7 ) THEN
C           USE OLD INPLANE ROT. & SHIFT  
            RANGOLD   = ANGEXP(4)
            XSHOLD    = ANGEXP(5)
            YSHOLD    = ANGEXP(6)

            MIRROROLD = (ANGEXP(7) > 0)
            IF (MIRROROLD) THEN
               WRITE(NOUT,90)
90             FORMAT(
     &           ' *** MIRRORED PROJECTION INPUT NO LONGER ALLOWED.',/,
     &           ' *** CONVERT YOUR ALIGNMENT PARAMETER FILES TO ',
     &           ' NON-MIRRORED FORM OR USE OLDER SPIDER RELEASE.')
               CALL ERRT(101,
     &          'MIRRORED PROJECTION INPUT NO LONGER ALLOWED',NE)
            ENDIF

         ENDIF

         IF (CHNG_ORDER) THEN
C           HAVE TO CHANGE ORDER OF SHIFT & ROTATION.
C           IN 'AP **' IMAGE IS SHIFTED FIRST, ROTATED SECOND.
C           IN 'RT SQ' IT IS ROTATED FIRST, SHIFTED SECOND.
C           THIS CODE CORRESPONDS TO OLD OPERATION: 'SA P'.
            SX     = -XSHRAW              ! BEST X SHIFT
            SY     = -YSHRAW              ! BEST Y SHIFT
	    CO     =  COS(RANGNEW * DGR_TO_RAD)
	    SO     = -SIN(RANGNEW * DGR_TO_RAD)

	    XSHNEW = SX*CO - SY*SO
	    YSHNEW = SX*SO + SY*CO
         ELSE
	    XSHNEW = XSHRAW
	    YSHNEW = YSHRAW
         ENDIF
   
C        COMBINE ROT. & SHIFT WITH PREVIOUS TRANSFORMATIONS
         C       =  COS(RANGNEW * DGR_TO_RAD)
         S       = -SIN(RANGNEW * DGR_TO_RAD)

         XSHOUT  = XSHNEW  + XSHOLD*C - YSHOLD*S
         YSHOUT  = YSHNEW  + XSHOLD*S + YSHOLD*C
         RANGOUT = RANGOLD + RANGNEW

C        LIST ANGLES IN RANGE 0...360
         DO WHILE(RANGOUT < 0.0)
            RANGOUT = RANGOUT + 360.0
         ENDDO
         DO WHILE(RANGOUT >= 360.0)
            RANGOUT = RANGOUT - 360.0
         ENDDO

C        CONVERT ~360 TO: 0
         IF ( ABS(RANGOUT - 360.0) <= ALMOST_ZERO) RANGOUT = 0.0


C        SET FLAG FOR NO ANGDIF DETERMINED
         ANGDIF = -1.0 

         IF (IMGREF <= 0)  THEN
C            NO RELEVANT REF. IMAGE FOUND
             ANGDIF = 0.0

         ELSEIF (GOTREFANG .AND. NGOTPAR >= 3) THEN
C            CAN FIND ANGDIF
             ANGDIF = ABS(EXPDIR(1) * REFDIR(1) + 
     &                    EXPDIR(2) * REFDIR(2) + 
     &                    EXPDIR(3) * REFDIR(3))
             ANGDIF = MIN(1.0,ANGDIF)
             ANGDIF = ACOS(ANGDIF) / DGR_TO_RAD
         ENDIF

         IKEY     = KEY
         IF (CTYPE(1:2) == 'SH'  .OR. 
     &       CTYPE(1:3) == 'FOU' .OR.
     &       CTYPE(1:3) == 'REF') THEN
             IKEY     = IMGEXP
         ENDIF

         IF (SAY_RAW) THEN
C           WANT TO REPORT SHIFT BEFORE ROTATE
            XSHT = XSHRAW
            YSHT = YSHRAW
         ELSE
            XSHT = XSHNEW
            YSHT = YSHNEW
         ENDIF


C        SAVE 15 ALIGNMENT PARAMETERS
         CALL AP_OUT(IKEY,IMGEXP,
     &               ANGOUT, IMGREF,CCROT,
     &               RANGNEW,XSHT,YSHT,MIRRORNEW,
     &               RANGOUT,XSHOUT,YSHOUT,
     &               NPROJ,ANGDIF,PEAKV,
     &               LUNDOC,DLIST,15,IRTFLG)

          END




C++******************************  AP_END *****************************



        SUBROUTINE AP_END(KEY,IMGEXP,IMGREF, 
     &                  ANGREF,REFDIR, 
     &                  ANGEXP,EXPDIR,ISHRANGE,
     &                  GOTREFANG, NGOTPAR, CCROTT,PEAKVT,
     &                  RANGNEW,XSHNEW,YSHNEW, MIRRORNEW,REFPAT,
     &                  NPROJT, CTYPE, LUNDOC,DLIST)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        CHARACTER (LEN=*)                           :: REFPAT 

        LOGICAL                                     :: MIRROROLD
        LOGICAL                                     :: MIRRORNEW
	LOGICAL                                     :: GOTREFANG

	REAL, DIMENSION(7)                          :: ANGEXP
	REAL, DIMENSION(3)                          :: ANGREF
	REAL, DIMENSION(3)                          :: ANGOUT
	REAL, DIMENSION(3)                          :: EXPDIR,REFDIR
        CHARACTER (LEN=*)                           :: CTYPE 

        REAL, DIMENSION(*)                          :: DLIST

        PARAMETER (QUADPI = 3.14159265358979323846)
        PARAMETER (DGR_TO_RAD = (QUADPI/180))

         NPROJ   = NPROJT
c         IF (NPROJ .EQ. 0) NPROJ = 1 removed aug 09 al

         PEAKV = PEAKVT  

         IF (IMGREF > 0) THEN
C           IMGREF IS NUMBER OF MOST SIMILAR REF. IMAGE 
            CCROT   = CCROTT
         ELSE
C           NO REFERENCE IMAGE SELECTED
            CCROT = -1.0
            PEAKV = 0.0
         ENDIF

C        SET NEW PROJECTION ANGLES
         ANGOUT = 0.0            ! DEFAULT VALUE
         IF (IMGREF > 0 .AND. GOTREFANG) THEN
C           USE REF. ANGLES AS NEW PROJECTION ANGLES
            ANGOUT = ANGREF(1:3)

            IF (MIRRORNEW) THEN
C              REF. PROJECTION MUST BE MIRRORED
               ANGOUT(1) = -ANGOUT(1)
               ANGOUT(2) = 180+ANGOUT(2)
            ENDIF
         ELSEIF (NGOTPAR >= 3) THEN
C           KEEP OLD EXP. PROJ. ANGLES 
            ANGOUT = ANGEXP(1:3)
         ENDIF

         RANGOLD   = 0.0
         XSHOLD    = 0.0
         YSHOLD    = 0.0

         IF (NGOTPAR >= 7 .AND. ISHRANGE > 0) THEN
C           USE OLD INPLANE ROT. & SHIFT  
            RANGOLD   = ANGEXP(4)
            XSHOLD    = ANGEXP(5)
            YSHOLD    = ANGEXP(6)

            MIRROROLD = (ANGEXP(7) > 0)
            IF (MIRROROLD) THEN
               WRITE(NOUT,90)
90             FORMAT(
     &           ' *** MIRRORED PROJECTION INPUT NO LONGER ALLOWED.',/,
     &           ' *** CONVERT YOUR ALIGNMENT PARAMETER FILES TO ',
     &           ' NON-MIRRORED FORM OR USE OLDER SPIDER RELEASE.')
               CALL ERRT(101,
     &          'MIRRORED PROJECTION INPUT NO LONGER ALLOWED',NE)
            ENDIF

         ENDIF
    
C        COMBINE ROT. & SHIFT WITH PREVIOUS TRANSFORMATION
         C       =  COS(RANGNEW * DGR_TO_RAD)
         S       = -SIN(RANGNEW * DGR_TO_RAD)

         XSHOUT  = XSHNEW  + XSHOLD*C - YSHOLD*S
         YSHOUT  = YSHNEW  + XSHOLD*S + YSHOLD*C
         RANGOUT = RANGOLD + RANGNEW

C        LIST ANGLES IN RANGE 0...360
         DO WHILE(RANGOUT .LT. 0.0)
            RANGOUT = RANGOUT + 360.0
         ENDDO
         DO WHILE(RANGOUT .GE. 360.0)
            RANGOUT = RANGOUT - 360.0
         ENDDO

C        CONVERT ~360 TO: 0
         IF ( ABS(RANGOUT - 360.0) <= 0.05) RANGOUT = 0.0


C        SET FLAG FOR NO ANGDIF DETERMINED
         ANGDIF = -1.0 

         IF (IMGREF <= 0)  THEN
C            NO RELEVANT REF. IMAGE FOUND
             ANGDIF = 0.0

         ELSEIF (GOTREFANG .AND. NGOTPAR >= 3) THEN
C            CAN FIND ANGDIF
             ANGDIF = ABS(EXPDIR(1) * REFDIR(1) + 
     &                    EXPDIR(2) * REFDIR(2) + 
     &                    EXPDIR(3) * REFDIR(3))
             ANGDIF = MIN(1.0,ANGDIF)
             ANGDIF = ACOS(ANGDIF) / DGR_TO_RAD
         ENDIF

         IKEY     = KEY
         IF (CTYPE(1:2) == 'SH'  .OR. 
     &       CTYPE(1:3) == 'FOU' .OR.
     &       CTYPE(1:3) == 'REF') THEN
             IKEY     = IMGEXP
         ENDIF

C        SAVE 15 ALIGNMENT PARAMETERS
         CALL AP_OUT(IKEY,IMGEXP,
     &               ANGOUT, IMGREF,CCROT,
     &               RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &               RANGOUT,XSHOUT,YSHOUT,
     &               NPROJ,ANGDIF,PEAKV,
     &               LUNDOC,DLIST,15,IRTFLG)

          END


C++****************************** AP_OUT *****************************

        SUBROUTINE AP_OUT(KEY,IMGEXP,
     &                    ANGOUT, IMGREF,CCROT,
     &                    RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &                    RANGOUT,XSHOUT,YSHOUT,
     &                    NPROJ,ANGDIF,PEAKV,
     &                    LUNDOC,DLIST,NLIST,IRTFLG)

        IMPLICIT NONE
        INCLUDE 'CMBLOCK.INC'

        INTEGER           :: KEY,IMGEXP
        REAL              :: ANGOUT(3)
        INTEGER           :: IMGREF
        REAL              :: CCROT,RANGNEW,XSHNEW,YSHNEW
        LOGICAL           :: MIRRORNEW
        REAL              :: RANGOUT,XSHOUT,YSHOUT 
        INTEGER           :: NPROJ
        REAL              :: ANGDIF,PEAKV
        INTEGER           :: LUNDOC
        REAL              :: DLIST(NLIST)
        INTEGER           :: NLIST,IRTFLG

        REAL, PARAMETER   :: ALMOSTZERO = 0.05
        INTEGER           :: NSEL_USED

        CHARACTER(LEN=150) :: FORMOUT

        !FORMOUT  = '(I10,1X,I4,10000(1X,1PG13.6))'  old format 3/30/12

C       <,<,<, REF#,IMG#,
C       ROT<, SX,SY,NPROJ, <DIF,CCROT,
C       ROT<,SX,SY,PEAK
        FORMOUT  = 
     &      '(I7,1X,I2,1X,F7.2,1X,F7.2,1X,F7.2,2X,F6.0,2X,F7.0,2X,'// 
     &      'F7.2,1X,F7.2,1X,F7.2,2X,F6.0,1X, F7.2,1X, F11.2,1X,'  //
     &      'F7.2,1X,F7.2,1X,F7.2,2X,F7.4)'              
C            123456789 123456789 123456789 123456789 123456789 1234567890123456789012

C       ZERO DLIST ARRAY
        DLIST     = 0.0

        DLIST(1)  = ANGOUT(1)
        DLIST(2)  = ANGOUT(2)
        DLIST(3)  = ANGOUT(3)
        DLIST(4)  = IMGREF
        DLIST(5)  = IMGEXP

        DLIST(6)  = RANGOUT
        IF (ABS(RANGOUT) < ALMOSTZERO) DLIST(6) = 0.0
        DLIST(7)  = XSHOUT
        IF (ABS(XSHOUT)  < ALMOSTZERO) DLIST(7) = 0.0
        DLIST(8)  = YSHOUT
        IF (ABS(YSHOUT)  < ALMOSTZERO) DLIST(8) = 0.0

        DLIST(9)  = NPROJ

        DLIST(10) = ANGDIF
        IF (ABS(ANGDIF) < ALMOSTZERO) DLIST(10) = 0.0

        DLIST(11) = CCROT

        DLIST(12) = RANGNEW
        IF (ABS(RANGNEW) < ALMOSTZERO) DLIST(12) = 0.0
        DLIST(13) = XSHNEW
        IF (ABS(XSHNEW)  < ALMOSTZERO) DLIST(13) = 0.0
        DLIST(14) = YSHNEW
        IF (ABS(YSHNEW)  < ALMOSTZERO) DLIST(14) = 0.0

        DLIST(15) = ABS(PEAKV)   ! IN CASE OF NEGATIVE
        IF (MIRRORNEW) DLIST(15) = -(ABS(PEAKV)) 

#ifndef USE_MPI
         IF (LUNDOC .GT. 0) THEN
C           SAVE IN ALIGNMENT DOC FILE IF NOT USING MPI
C       <,<,<, REF#,IMG#,ROT<, SX,SY,NPROJ, <DIF,CCROT,ROT<,SX,SY,PEAK

            IF (USE_LONGCOL) THEN
              CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,NLIST,IRTFLG)

            ELSE
              CALL LUNDOCWRTDATF(LUNDOC,KEY,DLIST,NLIST,FORMOUT,IRTFLG)
            ENDIF
         ENDIF
#endif
 
         CALL REG_GET_USED(NSEL_USED)

         IF (NSEL_USED .GT. 0) THEN
C            OUTPUT TO SPIDER'S REGISTERS
             CALL REG_SET_NSEL(1,5, DLIST(1),DLIST(2),DLIST(3),
     &                              DLIST(4),DLIST(5),IRTFLG)
             CALL REG_SET_NSEL(6,5, DLIST(6),DLIST(7),DLIST(8),
     &                              DLIST(9),DLIST(10),IRTFLG)
             CALL REG_SET_NSEL(11,5,DLIST(11),DLIST(12),DLIST(13),
     &                              DLIST(14),DLIST(15),IRTFLG)
          ENDIF

          END

C+**********************************************************************

       SUBROUTINE AP_END_HEAD(IMNUM,FILPAT,LUNIN,PARLIST,NVALS,IRTFLG)

C      PURPOSE: PUT ANGLES, ETC AS HEADER VALUES IN IMAGE

       IMPLICIT NONE
       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       INTEGER               :: IMNUM
       CHARACTER(LEN=*)      :: FILPAT
       INTEGER               :: LUNIN
       REAL                  :: PARLIST(NVALS)
       INTEGER               :: NVALS
       INTEGER               :: IRTFLG

       CHARACTER(LEN=MAXNAM) :: FILNAM
       INTEGER               :: MAXIM,ITYPE,LSAM,LROW,LSLICE,NLET
       LOGICAL               :: FOUROK = .FALSE.

C      OPEN EXISTING IMAGE FILE FOR OUTPUT
       IF (IMNUM >= 0) THEN
C         CREATE IMAGE FILE NAME FIRST
          NLET = 0
          CALL FILGET(FILPAT,FILNAM,NLET,IMNUM,IRTFLG)
          IF (IRTFLG .NE. 0)  RETURN
       ELSE
          FILNAM = FILPAT
       ENDIF
 
       MAXIM = 0
       CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',ITYPE,
     &              LSAM,LROW,LSLICE,MAXIM,' ',FOUROK,IRTFLG)
       IF (IRTFLG .NE. 0)  RETURN

C      PUT ANGLES, ETC IN HEADER
       CALL LUNSETVALS(LUNIN,IAPLOC+1,NVALS,PARLIST,IRTFLG)

       CLOSE(LUNIN)

       END
@


1.44
log
@F7.2,1X,F7.2,1X,F7.2,2X,F7.4
@
text
@d418 3
a420 1
C       <,<,<, REF#,IMG#,ROT<, SX,SY,NPROJ, <DIF,CCROT,ROT<,SX,SY,PEAK
d423 1
a423 1
     &      'F7.2,1X,F7.2,1X,F7.2,2X,F6.0,1X, F7.2,1X, F9.2,1X,'    //
@


1.43
log
@keep old rot & shift always if available
@
text
@d422 1
a422 1
     &      'F7.2,1X,F7.2,1X,F7.2,1X,F7.2,1X, 1PG12.5)'              
@


1.42
log
@typo
@
text
@d20 1
d118 1
a118 1
         IF (IMGREF .GT. 0) THEN
d129 1
a129 1
         IF (IMGREF .GT. 0 .AND. GOTREFANG) THEN
d138 1
a138 1
         ELSEIF (NGOTPAR .GE. 3) THEN
d147 1
a147 1
         IF (NGOTPAR .GE. 7 .AND. ISHRANGE .GT. 0) THEN
d153 1
a153 1
            MIRROROLD = (ANGEXP(7) .GT. 0)
d220 3
a222 3
         IF (CTYPE(1:2) .EQ. 'SH'  .OR. 
     &       CTYPE(1:3) .EQ. 'FOU' .OR.
     &       CTYPE(1:3) .EQ. 'REF') THEN
d285 1
a285 1
         IF (IMGREF .GT. 0) THEN
d296 1
a296 1
         IF (IMGREF .GT. 0 .AND. GOTREFANG) THEN
d305 1
a305 1
         ELSEIF (NGOTPAR .GE. 3) THEN
d314 1
a314 1
         IF (NGOTPAR .GE. 7 .AND. ISHRANGE .GT. 0) THEN
d320 1
a320 1
            MIRROROLD = (ANGEXP(7) .GT. 0)
d350 1
a350 1
         IF ( ABS(RANGOUT - 360.0) .LE. 0.05) RANGOUT = 0.0
d356 1
a356 1
         IF (IMGREF .LE. 0)  THEN
d360 1
a360 1
         ELSEIF (GOTREFANG .AND. NGOTPAR .GE. 3) THEN
d370 3
a372 3
         IF (CTYPE(1:2) .EQ. 'SH'  .OR. 
     &       CTYPE(1:3) .EQ. 'FOU' .OR.
     &       CTYPE(1:3) .EQ. 'REF') THEN
@


1.41
log
@DLIST(15) = ABS(PEAKV) in case of negative cc
@
text
@d455 1
a455 1
        IF (MIRRORNEW) DLIST(15) = -(ABS(PEAKV) 
@


1.40
log
@USE_LONGCOL .
@
text
@d19 1
d282 1
a282 1
         PEAKV = PEAKVT
d453 3
a455 2
        DLIST(15) = PEAKV 
        IF (MIRRORNEW) DLIST(15) = -PEAKV 
@


1.39
log
@IF (USE_LONGCOL) option\
@
text
@d395 1
d460 1
a460 1
            IF (USE_LONGCOL)
@


1.38
log
@LONGCOL OFF
@
text
@d459 6
a464 1
            CALL LUNDOCWRTDATF(LUNDOC,KEY,DLIST,NLIST,FORMOUT,IRTFLG)
@


1.37
log
@say shifts before rotation capability.
added shift rot in here
@
text
@d394 27
a420 4
        REAL, DIMENSION(3)             :: ANGOUT
        LOGICAL                        :: MIRRORNEW
        REAL, DIMENSION(NLIST)         :: DLIST
        REAL, PARAMETER                :: ALMOSTZERO=0.05
a424 1

d432 1
a432 1
        IF (ABS(RANGOUT) .LT. ALMOSTZERO) DLIST(6) = 0.0
d434 1
a434 1
        IF (ABS(XSHOUT)  .LT. ALMOSTZERO) DLIST(7) = 0.0
d436 1
a436 1
        IF (ABS(YSHOUT)  .LT. ALMOSTZERO) DLIST(8) = 0.0
d441 1
a441 1
        IF (ABS(ANGDIF) .LT. ALMOSTZERO) DLIST(10) = 0.0
d446 1
a446 1
        IF (ABS(RANGNEW) .LT. ALMOSTZERO) DLIST(12) = 0.0
d448 1
a448 1
        IF (ABS(XSHNEW)  .LT. ALMOSTZERO) DLIST(13) = 0.0
d450 1
a450 1
        IF (ABS(YSHNEW)  .LT. ALMOSTZERO) DLIST(14) = 0.0
d457 3
a459 2
C           <,<,<, REF#,IMG#,INPLANE<, SX,SY,NPROJ, <DIF,CCROT,INPLANE<,SX,SY,PEAK
            CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,NLIST,IRTFLG)
d481 1
a481 1
C      PURPOSE:  PUT ANGLES, ETC AS HEADER VALUES IN IMAGE
@


1.36
log
@CTYPE(1:3) .EQ. 'FOU.
@
text
@d18 1
d24 1
a24 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d51 22
a72 2
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       DLIST               PARAMETERS                       (OUTPUT)
d78 174
a251 1
         SUBROUTINE AP_END(KEY,IMGEXP,IMGREF, 
a382 1

@


1.35
log
@AP_END_HEAD added
@
text
@d174 2
a175 1
         IF (CTYPE(1:2) .EQ. 'SH' .OR. 
@


1.34
log
@REMOVED OBSLT
@
text
@d260 42
@


1.33
log
@GPL_2010
@
text
@d17 1
d53 1
a53 1
C  OPERATIONS:  'AP REF', 'AP RD', 'AP RN', 'AP MQ', 'AP NQ', 'AP SH'
a82 31
        IF (CTYPE(1:1) .EQ. 'M'  .OR. 
     &      CTYPE(1:1) .EQ. 'N'  .OR.
     &      CTYPE(1:2) .EQ. 'RQ' .OR.
     &      CTYPE(1:2) .EQ. 'RD' .OR.
     &      CTYPE(1:2) .EQ. 'RN') THEN
C           FOR OBSOLETE: 'AP MQ', 'AP MD'....
            CALL AP_END_OBSLT(IMGEXP,IMGREF, 
     &                  CCROTT,RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &                  DLIST)

            IF (LUNDOC .GT. 0) THEN
C              SAVE IN ALIGNMENT DOC FILE
C              REF#,CCROT,PSI,SX,SY,IMG#,-1
               CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,7,IRTFLG)
            ENDIF
 
            CALL REG_GET_USED(NSEL_USED)

            IF (NSEL_USED .GT. 0) THEN
C               OUTPUT TO SPIDER'S REGISTERS
                CALL REG_SET_NSEL(1,5, DLIST(1),DLIST(2),DLIST(3),
     &                                 DLIST(4),DLIST(5),IRTFLG)
                CALL REG_SET_NSEL(6,5, DLIST(6),DLIST(7),DLIST(8),
     &                                 DLIST(9),DLIST(10),IRTFLG)
                CALL REG_SET_NSEL(11,5,DLIST(11),DLIST(12),DLIST(13),
     &                                 DLIST(14),DLIST(15),IRTFLG)
            ENDIF
            RETURN     ! ------------------------------------
         ENDIF


a259 42
C++**************************** AP_END_OBSLT **************************

         SUBROUTINE AP_END_OBSLT(IMGEXP,IMGREF, 
     &                  CCROTT,RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &                  DLIST)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        LOGICAL                                     :: MIRRORNEW
        REAL, DIMENSION(*)                          :: DLIST

	PARAMETER (QUADPI = 3.14159265358979323846)
	PARAMETER (DGR_TO_RAD =   (QUADPI/180))

         IF (IMGREF .GT. 0) THEN
C           IMGREF IS NUMBER OF MOST SIMILAR REF. IMAGE 
            CCROT   = CCROTT
         ELSE
            CCROT   = -1.0
         ENDIF

C        OUTPUT .
C        1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C        2 - NOT-NORMALIZED CORRELATION COEFFICIENT (ROTATION).
C        3 - PSI ANGLE. (IN=PLANE ROTATION)
C        4 - SX SHIFT (SET TO ZERO IF NOT 'AP MQ,..')  
C        5 - SY SHIFT (SET TO ZERO IF NOT 'AP MQ,..')  
C        6 - INPUT IMAGE NUMBER.
C        7 - ANGULAR DIFFERENCE. (-1.0 IF NOT DETERMINED)

         DLIST(1) = IMGREF        ! NUMBER OF MOST SIMILAR REF. IMAGE 
         IF (MIRRORNEW) DLIST(1) = -IMGREF  ! REF. IMAGE NUMBER <0 
                
         DLIST(2)  = CCROT        ! NOT-NORMALIZED CC  (ROTATION)
         DLIST(3)  = RANGNEW      ! IN=PLANE ROTATION
	 DLIST(4)  = XSHNEW       ! X SHIFT
	 DLIST(5)  = YSHNEW       ! Y SHIFT
         DLIST(6)  = IMGEXP       ! INPUT IMAGE NUMBER
         DLIST(7)  = -1.0         ! ANGDIF IS NOT AVAILABLE
 
         END
@


1.32
log
@IF(ABS(ANGDIF)..
@
text
@d19 4
a22 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.                          *
d33 1
a33 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a34 1
C=*                                                                    *
d36 1
a36 1
C=* along with this program. If not, see <http://www.gnu.org/licenses> *       
@


1.31
log
@IF (NPROJ .EQ. 0) NPROJ = 1 removed
@
text
@d5 13
a17 11
C                     PEAKV REMOVED                MAR 04 ArDean Leith
C                     IKEY                         MAR 04 ArDean Leith
C                     ANGDIF IF CHANGE IN MIRROR   AUG 04 ArDean Leith
C                     ANGLES IN REG OUTPUT WRONG   AUG 04 ArDean Leith
C                     APEND2                       SEP 04 Chao Yang
C                     REWRITE FOR END OF 'AP MD'.. SEP 04 ArDean Leith
C                     REWRITE FOR UN-MIRROR        OCT 04 ArDean Leith
C                     RANGOUT <= 360               DEC 04 ArDean Leith
C                     MPI WRITES TO REGISTERS NOW  OCT 08 ArDean Leith
C                     REMOVED APSHIFT CALL         NOV 08 ArDean Leith
c                     IF (NPROJ.EQ.0)NPROJ=1       AUG 09 ArDean Leith
d251 1
d255 2
@


1.30
log
@ removed apshift call
@
text
@d15 1
d17 5
a21 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d23 1
a23 6
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d28 1
a28 1
C=* This program is distributed in the hope that it will be useful,    *
d34 1
a34 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d113 1
a113 1
         IF (NPROJ .EQ. 0) NPROJ = 1
@


1.29
log
@usebcast mpi changes
@
text
@d14 1
d41 5
a45 5
C   AP_END(KEY,IMGEXP,IMGREF, 
C          ANGREF,REFDIR,ANGEXP,EXPDIR,ISHRANGE,
C          GOTREFANG, NGOTPAR,LSAM,LROW,CCROTT,PEAKVT,
C          RANGNEW,MIRRORNEW,EXPPAT,REFPAT,
C          NPROJT, CTYPE, XBUF,LUNDOC)
a49 1
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
a50 1
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
d58 5
a62 4
     &                  ANGREF,REFDIR,ANGEXP,EXPDIR,ISHRANGE,
     &                  GOTREFANG, NGOTPAR,LSAM,LROW,CCROTT,PEAKVT,
     &                  RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &                  NPROJT, CTYPE, XBUF, LUNDOC,DLIST)
d67 1
a67 2
        CHARACTER (LEN=*)                           :: CTYPE 
        CHARACTER (LEN=*)                           :: EXPPAT,REFPAT 
d77 1
a77 1
	REAL, DIMENSION(*)                          :: XBUF
a82 3

	DATA  INPIC/77/

d114 1
d167 1
a167 12

         IF (CTYPE(1:3) .EQ. 'REF' .AND.
     &       IMGREF .GT. 0 .AND. ISHRANGE .GT. 0) THEN
C           FIND SHIFT PARAMETERS FOR 'AP REF' ALIGNMENT 

            NSAMP = 2*LSAM+2
            NROWP = 2*LROW
            CALL APSHIFT(INPIC,EXPPAT,LSAM,LROW,IMGEXP,IMGREF,
     &                 REFPAT, XBUF,ISHRANGE,NSAMP,NROWP,
     &                 RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,PEAKV,IRTFLG)
         ENDIF
      
d184 4
a221 2


d234 1
d239 1
d247 1
d249 1
d251 1
d258 1
d260 1
d262 1
@


1.28
log
@GPL License fixed
@
text
@d13 1
d16 1
a16 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a96 1
#ifndef USE_MPI
d114 1
a114 2
#endif
            RETURN
d117 1
a270 1

d272 1
a272 1
C           SAVE IN ALIGNMENT DOC FILE
d276 1
a288 1
#endif
@


1.27
log
@HRI GPL License used
@
text
@a2 1
C++************************************************************************
a13 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d17 1
a17 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a36 6

C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.26
log
@dlist returned
@
text
@d2 1
d16 24
@


1.25
log
@*** empty log message ***
@
text
@d34 1
d62 1
a62 2
        INTEGER, PARAMETER                          :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)                   :: DLIST
d209 1
a209 1
     &               LUNDOC,15,IRTFLG)
d224 1
a224 1
     &                    LUNDOC,NLIST,IRTFLG)
d228 1
a228 4

C       AUTOMATIC ARRAY
        INTEGER, PARAMETER             :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)      :: DLIST
d231 1
a231 3
        DLIST = 0.0

        NLISTT    = MIN(NLIST,NLISTMAX)
d258 1
a258 1
            CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,NLISTT,IRTFLG)
d286 1
a286 2
        INTEGER, PARAMETER                          :: NLISTMAX = 15
        REAL, DIMENSION(NLISTMAX)                   :: DLIST
@


1.24
log
@MIRRORED PROJECTION INPUT NO LONGER ALLOWED
@
text
@d12 1
d177 3
@


1.23
log
@apmq_no_output_bug
@
text
@d50 1
d70 3
a72 1
     &      CTYPE(1:1) .EQ. 'R') THEN
d121 1
a121 1
C              REF. PROJECDTION MUST BE MIRRORED
d139 12
@


1.22
log
@no mirror output now
@
text
@d67 3
a69 3
        IF (CTYPE(1:4) .EQ. 'AP M'  .OR. 
     &      CTYPE(1:4) .EQ. 'AP N'  .OR.
     &      CTYPE(1:4) .EQ. 'AP R') THEN
d74 20
@


1.21
log
@NLISTT = 7
@
text
@d5 7
a11 5
C                      PEAKV REMOVED               MAR 04 ArDean Leith
C                      IKEY                        MAR 04 ArDean Leith
C                      ANGDIF IF CHANGE IN MIRROR  AUG 04 ArDean Leith
C                      ANGLES IN REG OUTPUT WRONG  AUG 04 ArDean Leith
C                      APEND2                      SEP 04 Chao Yang
a49 2
	CHARACTER(LEN=1)                            :: NULL
	LOGICAL                                     :: MIRROROLD
a50 1
	LOGICAL                                     :: MIRROROUT
a61 5
#ifdef USE_MPI
        integer                                     :: comm
        include 'mpif.h'
#endif

d67 12
a78 5
#ifdef USE_MPI
        comm = mpi_comm_world
        call mpi_comm_rank(comm,mypid,ierr)
#endif
        NULL = CHAR(0)
d80 1
a80 1
            peakv   = peakvt
a84 3
            PEAKV   = PEAKVT
            NPROJ   = NPROJT
            IF (NPROJ .EQ. 0) NPROJ = 1
d86 3
a88 2
            CCROT   = -1.0
            NPROJ = 1
d91 2
a92 2
C        NEW PROJECTION ANGLES
         ANGOUT = 0.0
d97 5
d103 1
a103 1
C           KEEP OLD EXP. PROJ. ANGLES
a109 1
         MIRROROLD = .FALSE.
d112 1
a112 2

C           USE OLD ROT., MIR., & SHIFT  
a115 1
            MIRROROLD = (ANGEXP(7) .GT. 0)
d120 1
a120 1
C            FIND SHIFT PARAMETERS FOR 'AP REF' ALIGNMENT 
d128 13
a140 6

C         COMBINE ROT., MIR., & SHIFT WITH PREVIOUS TRANSFORMATION
          CALL APCOMROT(RANGOLD,XSHOLD,YSHOLD,MIRROROLD,
     &                  RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &                  RANGOUT,XSHOUT,YSHOUT,MIRROROUT,
     &                  IRTFLG)
d151 2
a152 18
C            ANGDIF = ABS(EXPDIR(1) * REFDIR(1) +
C            CAN FIND ANGDIF
             E1 = EXPDIR(1)
             E2 = EXPDIR(2)
             IF (MIRROROLD) THEN
                E1 = -E1
                E2 = 180 + E2
             ENDIF

             R1 = REFDIR(1)
             R2 = REFDIR(2)
             IF (MIRRORNEW) THEN
                R1 = -R1
                R2 = 180 + R2
             ENDIF

             ANGDIF = ABS(E1 * R1 + 
     &                    E2 * R2 + 
d156 1
a156 1
          ENDIF
d158 5
a162 8
          IF (CTYPE(1:2) .EQ. 'SH' .OR. 
     &        CTYPE(1:3) .EQ. 'REF') THEN
              NWANTOUT = 15
              IKEY     = IMGEXP
          ELSE
              NWANTOUT = 7
              IKEY     = KEY
          ENDIF
d164 7
a170 8
C         SAVE NWANTOUT ALIGNMENT PARAMETERS
            
          CALL AP_OUT(IKEY,IMGEXP,
     &                ANGOUT, IMGREF,CCROT,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &                RANGOUT,XSHOUT,YSHOUT,MIRROROUT,
     &                NPROJ,ANGDIF,PEAKV,
     &                LUNDOC,NWANTOUT,IRTFLG)
d174 4
d183 1
a183 1
     &                    RANGOUT,XSHOUT,YSHOUT,MIRROROUT,
d188 1
a188 1
        LOGICAL                        :: MIRRORNEW,MIRROROUT
d197 1
a197 34
        IF (NLIST .GT. 7) THEN

           NLISTT    = MIN(NLIST,NLISTMAX)

           DLIST(1)  = ANGOUT(1)
           DLIST(2)  = ANGOUT(2)
           DLIST(3)  = ANGOUT(3)
           DLIST(4)  = IMGREF
           IF (MIRROROUT) DLIST(4) = -IMGREF 
           DLIST(5)  = IMGEXP

           DLIST(6)  = RANGOUT
           DLIST(7)  = XSHOUT
           DLIST(8)  = YSHOUT
           DLIST(9)  = NPROJ

           DLIST(10) = ANGDIF
           DLIST(11) = CCROT

           DLIST(12) = RANGNEW
           DLIST(13) = XSHNEW
           DLIST(14) = YSHNEW
           DLIST(15) = PEAKV 
           IF (MIRRORNEW) DLIST(15) = -PEAKV 

       ELSE
C          OUTPUT .
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT (ROTATION).
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX SHIFT PERMANENTLY SET TO ZERO IF NOT 'AP MQ,..'  
C          5 - SY SHIFT PERMANENTLY SET TO ZERO IF NOT 'AP MQ,..'  
C          6 - INPUT IMAGE NUMBER.
C          7 - ANGULAR DIFFERENCE. (-1.0 IF NOT DETERMINED)
d199 19
a217 15
           NLISTT = 7

C          SAVE NUMBER OF MOST SIMILAR REF. IMAGE 
           DLIST(1) = IMGREF

C          SET MOST SIMILAR REF. IMAGE NUMBER <0 IF MIRRORED
           IF (MIRRORNEW)  DLIST(1) = -IMGREF 
                
           DLIST(2)  = CCROT
           DLIST(3)  = RANGNEW
	   DLIST(4)  = XSHNEW
	   DLIST(5)  = YSHNEW
           DLIST(6)  = IMGEXP
           DLIST(7)  = ANGDIF
         ENDIF
d223 1
a223 3
C           <,<,<, MIR-REF#,IMG#,INPLANE<, SX,SY,NPROJ, <DIF,CCROT,INPLANE<,SX,SY
C               OR
C           MIR-REF#, CCROT, INPLANE<, SX,SY, IMG#, < DIFF
d230 1
a230 1
C            OUTPUT TO REGISTERS
d242 1
d244 3
a246 25
C++************************************************************************
C
C APCOMROT.F         NEW                           NOV 03 ARDEAN LEITH
C                    FT BAD LOGIC                  JUN 04 ARDEAN LEITH
C                    SHIFT BAD LOGIC               JUN 04 ARDEAN LEITH
C                    MIRROR&RANG MISSING           SEP 04 ARDEAN LEITH
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C **********************************************************************
C
C  APCOMROT()                                  
C
C  PURPOSE:  COMBINE ROT., MIR., & SHIFT WITH PREVIOUS TRANSFORMATION
C
C  PARAMETERS: RANGNEW    INPLANE ROTATION ANGLE                 SENT
C              MIRRORNEW  LOGICAL FLAG THAT REF. NEEDS MIRROR    SENT
C              IMGREF     REF. IMAGE NUMBER                      SENT
C              IRTFLG     ERROR FLAG                             RET.  
C
C--************************************************************************
d248 2
a249 4
        SUBROUTINE APCOMROT(RANGOLD,XSHOLD,YSHOLD,MIRROROLD,
     &                      RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &                      RANGOUT,XSHOUT,YSHOUT,MIRROROUT,
     &                      IRTFLG)
d251 3
a253 1
        LOGICAL    :: MIRRORNEW,MIRROROUT,MIRROROLD
d258 6
a263 40
C       COMBINE ROT., MIR., & SHIFT WITH PREVIOUS TRANSFORMATION

C       write(6,*) rangold,xshold,yshold,mirrorold
C       write(6,*) rangnew,xshnew,yshnew,mirrornew
        
        RANGNEWT = RANGNEW
        IF (MIRROROLD) RANGNEWT = - RANGNEWT

        C =  COS(RANGNEWT * DGR_TO_RAD)
        S = -SIN(RANGNEWT * DGR_TO_RAD)

        IF (.NOT. MIRROROLD  .AND. .NOT. MIRRORNEW) THEN
           XSHOUT =    XSHNEW + XSHOLD*C - YSHOLD*S
        ELSEIF (.NOT. MIRROROLD  .AND.  MIRRORNEW) THEN
           XSHOUT =    XSHNEW + XSHOLD*C - YSHOLD*S
        ELSEIF (MIRROROLD  .AND.  .NOT. MIRRORNEW) THEN
           XSHOUT =  - XSHNEW + XSHOLD*C - YSHOLD*S
        ELSE
           XSHOUT =  - XSHNEW + XSHOLD*C - YSHOLD*S
        ENDIF

        RANGOUT = RANGOLD + RANGNEW
        IF (MIRROROLD) RANGOUT = RANGOLD - RANGNEW

        MIRROROUT = .TRUE.
        IF (MIRROROLD .AND.  MIRRORNEW)            MIRROROUT = .FALSE.
        IF (.NOT. MIRROROLD .AND. .NOT. MIRRORNEW) MIRROROUT = .FALSE.

        YSHOUT  = YSHNEW  + XSHOLD*S + YSHOLD*C

        DO WHILE(RANGOUT .LT. 0.0)
           RANGOUT = RANGOUT + 360.0
        ENDDO
        RANGOUT =  MOD(RANGOUT,360.0)

C       write(6,*) rangout,xshout,yshout,mirrorout
C       write(6,*) '----'

        IRTFLG = 0
        END
d265 8
d274 11
@


1.20
log
@expdirt bug
@
text
@d240 1
a240 1
           NLIST = 7
@


1.19
log
@missing endif
@
text
@d37 1
a37 1
     &                  ANGREF,REFDIRT,ANGEXP,EXPDIRT,ISHRANGE,
d79 2
d227 2
a228 2
           DLIST(15) = 0 
           IF (MIRRORNEW) DLIST(15) = -1.0 
@


1.18
log
@dlist in parameters (for mpi consistency)
@
text
@d252 1
@


1.17
log
@mpi lowercased
@
text
@d37 1
a37 1
     &                  ANGREF,REFDIR,ANGEXP,EXPDIR,ISHRANGE,
d40 1
a40 1
     &                  NPROJT, CTYPE, XBUF,LUNDOC)
d60 8
d73 4
d228 1
a228 6
           IF (LUNDOC .GT. 0) THEN
C             SAVE IN ALIGNMENT DOC FILE
C             <,<,<, MIR-REF#,IMG#,INPLANE<, SX,SY,NPROJ, <DIF,CCROT,INPLANE<,SX,SY
              CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,NLISTT,IRTFLG)
           ENDIF
        ELSE
d253 1
a253 5
           IF (LUNDOC .GT. 0) THEN
C              SAVE IN ALIGNMENT DOC FILE

C              MIR-REF#, CCROT, INPLANE<, SX,SY, IMG#, < DIFF
               CALL LUNDOCWRTDAT(LUNDOC,KEY,DLIST,NLIST,IRTFLG)
d255 6
a260 1
            ENDIF
d262 1
a262 1

d274 1
a355 220
C----------------------MPI PARALLEL ONLY----------------------------------
#ifdef USE_MPI
         subroutine ap_end2(key,imgexp,imgref, 
     &                  angref,refdir,angexp,expdir,ishrange,
     &                  gotrefang, ngotpar,lsam,lrow,ccrott,peakvt,
     &                  rangnew,xshnew,yshnew,mirrornew,exppat,refpat,
     &                  nprojt, ctype, xbuf, dlist)

        include 'cmlimit.inc'
        include 'cmblock.inc'

        character (len=*)                           :: ctype 
        character (len=*)                           :: exppat,refpat 

	character(len=1)                            :: null
	logical                                     :: mirrorold
        logical                                     :: mirrornew
	logical                                     :: mirrorout
	logical                                     :: gotrefang

	real, dimension(7)                          :: angexp
	real, dimension(3)                          :: angref
	real, dimension(3)                          :: angout
	real, dimension(3)                          :: expdir,refdir
	real, dimension(*)                          :: xbuf
c
        real  dlist(15)

        parameter (quadpi = 3.14159265358979323846)
        parameter (dgr_to_rad = (quadpi/180))

	data  inpic/77/

        include 'mpif.h'
        integer  mypid, comm, ierr
c
        comm = mpi_comm_world
        call mpi_comm_rank(comm, mypid , ierr)

        null = char(0)

        if (imgref .gt. 0) then
c           imgref is number of most similar ref. image 
            ccrot   = ccrott
            peakv   = peakvt
            nproj   = nprojt
            if (nproj .eq. 0) nproj = 1
        else
            ccrot   = -1.0
            nproj = 1
        endif

c       new projection angles
        angout = 0.0
        if (imgref .gt. 0 .and. gotrefang) then
c           use ref. angles as new projection angles
            angout = angref(1:3)

        elseif (ngotpar .ge. 3) then
c           keep old exp. proj. angles
            angout = angexp(1:3)
        endif

        rangold   = 0.0
        xshold    = 0.0
        yshold    = 0.0
        mirrorold = .false.

        if (ngotpar .ge. 7 .and. ishrange .gt. 0) then

c           use old rot., mir., & shift  
            rangold   = angexp(4)
            xshold    = angexp(5)
            yshold    = angexp(6)
            mirrorold = (angexp(7) .gt. 0)
        endif

        if (ctype(1:3) .eq. 'ref' .and.
     &      imgref .gt. 0 .and. ishrange .gt. 0) then
c           find shift parameters for 'ap ref' alignment 

            nsamp = 2*lsam+2
            nrowp = 2*lrow
            call apshift(inpic,exppat,lsam,lrow,imgexp,imgref,
     &                 refpat, xbuf,ishrange,nsamp,nrowp,
     &                 rangnew,xshnew,yshnew,mirrornew,peakv,irtflg)
        endif

c       combine rot., mir., & shift with previous transformation
        call apcomrot(rangold,xshold,yshold,mirrorold,
     &                rangnew,xshnew,yshnew,mirrornew,
     &                rangout,xshout,yshout,mirrorout,
     &                irtflg)

c       set flag for no angdif determined
        angdif = -1.0 

        if (imgref .le. 0)  then
c            no relevant ref. image found
             angdif = 0.0

        elseif (gotrefang .and. ngotpar .ge. 3) then
c            can find angdif
             e1 = expdir(1)
             e2 = expdir(2)
             if (mirrorold) then
                e1 = -e1
                e2 = 180 + e2
             endif

             r1 = refdir(1)
             r2 = refdir(2)
             if (mirrornew) then
                r1 = -r1
                r2 = 180 + r2
             endif

             angdif = abs(e1 * r1 + 
     &                    e2 * r2 + 
     &                    expdir(3) * refdir(3))
             angdif = min(1.0,angdif)
             angdif = acos(angdif) / dgr_to_rad
       endif

        if (ctype(1:2) .eq. 'sh' .or. 
     &      ctype(1:3) .eq. 'ref') then
            nwantout = 15
            ikey     = imgexp
        else
            nwantout = 7
            ikey     = key
        endif

c       save nwantout alignment parameters
        call ap_save(ikey,imgexp,
     &               angout, imgref,ccrot,
     &               rangnew,xshnew,yshnew,mirrornew,
     &               rangout,xshout,yshout,mirrorout,
     &               nproj,angdif,peakv,
     &               dlist,nwantout,irtflg)
        end
c
        subroutine ap_save(key,imgexp,
     &                    angout, imgref,ccrot,
     &                    rangnew,xshnew,yshnew,mirrornew,
     &                    rangout,xshout,yshout,mirrorout,
     &                    nproj,angdif,peakv,
     &                    dlist,nlist,irtflg)

        real, dimension(3)             :: angout
        logical                        :: mirrornew,mirrorout

c       automatic array
        integer, parameter             :: nlistmax = 15
        real                              dlist(15)

        if (nlist .gt. 7) then

           nlistt    = min(nlist,nlistmax)

           dlist(1)  = angout(1)
           dlist(2)  = angout(2)
           dlist(3)  = angout(3)
           dlist(4)  = imgref
           if (mirrorout) dlist(4) = -imgref 
           dlist(5)  = imgexp

           dlist(6)  = rangout
           dlist(7)  = xshout
           dlist(8)  = yshout
           dlist(9)  = nproj

           dlist(10) = angdif
           dlist(11) = ccrot

           dlist(12) = rangnew
           dlist(13) = xshnew
           dlist(14) = yshnew
           dlist(15) = 0 
           if (mirrornew) dlist(15) = -1.0 
        else
c          output .
c          1 - number of the most similar reference projection.
c          2 - not-normalized correlation coefficient (rotation).
c          3 - psi angle. (in=plane rotation)
c          4 - sx shift permanently set to zero if not 'ap mq,..'  
c          5 - sy shift permanently set to zero if not 'ap mq,..'  
c          6 - input image number.
c          7 - angular difference. (-1.0 if not determined)

           nlist = 7

c          save number of most similar ref. image 
           dlist(1) = imgref

c          set most similar ref. image number <0 if mirrored
           if (mirrornew)  dlist(1) = -imgref 
                
           dlist(2)  = ccrot
           dlist(3)  = rangnew
	   dlist(4)  = xshnew
	   dlist(5)  = yshnew
           dlist(6)  = imgexp
           dlist(7)  = angdif
         endif

c         call reg_get_used(nsel_used)
c
c         if (nsel_used .gt. 0) then
cc            output to registers
c             call reg_set_nsel(1,5, dlist(2),dlist(2),dlist(3),
c     &                              dlist(4),dlist(5),irtflg)
c             call reg_set_nsel(6,5, dlist(6),dlist(7),dlist(8),
c     &                              dlist(9),dlist(10),irtflg)
c             call reg_set_nsel(12,1,dlist(11),dlist(12),dlist(13),
c     &                              dlist(14),dlist(15),irtflg)
c          endif
c
          end
#endif
@


1.16
log
@angdif
@
text
@d349 25
a373 25
         SUBROUTINE AP_END2(KEY,IMGEXP,IMGREF, 
     &                  ANGREF,REFDIR,ANGEXP,EXPDIR,ISHRANGE,
     &                  GOTREFANG, NGOTPAR,LSAM,LROW,CCROTT,PEAKVT,
     &                  RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,EXPPAT,REFPAT,
     &                  NPROJT, CTYPE, XBUF, DLIST)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        CHARACTER (LEN=*)                           :: CTYPE 
        CHARACTER (LEN=*)                           :: EXPPAT,REFPAT 

	CHARACTER(LEN=1)                            :: NULL
	LOGICAL                                     :: MIRROROLD
        LOGICAL                                     :: MIRRORNEW
	LOGICAL                                     :: MIRROROUT
	LOGICAL                                     :: GOTREFANG

	REAL, DIMENSION(7)                          :: ANGEXP
	REAL, DIMENSION(3)                          :: ANGREF
	REAL, DIMENSION(3)                          :: ANGOUT
	REAL, DIMENSION(3)                          :: EXPDIR,REFDIR
	REAL, DIMENSION(*)                          :: XBUF
C
        REAL  DLIST(15)
d375 2
a376 2
        PARAMETER (QUADPI = 3.14159265358979323846)
        PARAMETER (DGR_TO_RAD = (QUADPI/180))
d378 1
a378 1
	DATA  INPIC/77/
d381 155
a535 155
        INTEGER  MYPID, COMM, IERR
C
        COMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(COMM, MYPID , IERR)

        NULL = CHAR(0)

        IF (IMGREF .GT. 0) THEN
C           IMGREF IS NUMBER OF MOST SIMILAR REF. IMAGE 
            CCROT   = CCROTT
            PEAKV   = PEAKVT
            NPROJ   = NPROJT
            IF (NPROJ .EQ. 0) NPROJ = 1
        ELSE
            CCROT   = -1.0
            NPROJ = 1
        ENDIF

C       NEW PROJECTION ANGLES
        ANGOUT = 0.0
        IF (IMGREF .GT. 0 .AND. GOTREFANG) THEN
C           USE REF. ANGLES AS NEW PROJECTION ANGLES
            ANGOUT = ANGREF(1:3)

        ELSEIF (NGOTPAR .GE. 3) THEN
C           KEEP OLD EXP. PROJ. ANGLES
            ANGOUT = ANGEXP(1:3)
        ENDIF

        RANGOLD   = 0.0
        XSHOLD    = 0.0
        YSHOLD    = 0.0
        MIRROROLD = .FALSE.

        IF (NGOTPAR .GE. 7 .AND. ISHRANGE .GT. 0) THEN

C           USE OLD ROT., MIR., & SHIFT  
            RANGOLD   = ANGEXP(4)
            XSHOLD    = ANGEXP(5)
            YSHOLD    = ANGEXP(6)
            MIRROROLD = (ANGEXP(7) .GT. 0)
        ENDIF

        IF (CTYPE(1:3) .EQ. 'REF' .AND.
     &      IMGREF .GT. 0 .AND. ISHRANGE .GT. 0) THEN
C           FIND SHIFT PARAMETERS FOR 'AP REF' ALIGNMENT 

            NSAMP = 2*LSAM+2
            NROWP = 2*LROW
            CALL APSHIFT(INPIC,EXPPAT,LSAM,LROW,IMGEXP,IMGREF,
     &                 REFPAT, XBUF,ISHRANGE,NSAMP,NROWP,
     &                 RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,PEAKV,IRTFLG)
        ENDIF

C       COMBINE ROT., MIR., & SHIFT WITH PREVIOUS TRANSFORMATION
        CALL APCOMROT(RANGOLD,XSHOLD,YSHOLD,MIRROROLD,
     &                RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &                RANGOUT,XSHOUT,YSHOUT,MIRROROUT,
     &                IRTFLG)

C       SET FLAG FOR NO ANGDIF DETERMINED
        ANGDIF = -1.0 

        IF (IMGREF .LE. 0)  THEN
C            NO RELEVANT REF. IMAGE FOUND
             ANGDIF = 0.0

        ELSEIF (GOTREFANG .AND. NGOTPAR .GE. 3) THEN
C            CAN FIND ANGDIF
             E1 = EXPDIR(1)
             E2 = EXPDIR(2)
             IF (MIRROROLD) THEN
                E1 = -E1
                E2 = 180 + E2
             ENDIF

             R1 = REFDIR(1)
             R2 = REFDIR(2)
             IF (MIRRORNEW) THEN
                R1 = -R1
                R2 = 180 + R2
             ENDIF

             ANGDIF = ABS(E1 * R1 + 
     &                    E2 * R2 + 
     &                    EXPDIR(3) * REFDIR(3))
             ANGDIF = MIN(1.0,ANGDIF)
             ANGDIF = ACOS(ANGDIF) / DGR_TO_RAD
       ENDIF

        IF (CTYPE(1:2) .EQ. 'SH' .OR. 
     &      CTYPE(1:3) .EQ. 'REF') THEN
            NWANTOUT = 15
            IKEY     = IMGEXP
        ELSE
            NWANTOUT = 7
            IKEY     = KEY
        ENDIF

C       SAVE NWANTOUT ALIGNMENT PARAMETERS
        CALL AP_SAVE(IKEY,IMGEXP,
     &               ANGOUT, IMGREF,CCROT,
     &               RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &               RANGOUT,XSHOUT,YSHOUT,MIRROROUT,
     &               NPROJ,ANGDIF,PEAKV,
     &               DLIST,NWANTOUT,IRTFLG)
        END
C
        SUBROUTINE AP_SAVE(KEY,IMGEXP,
     &                    ANGOUT, IMGREF,CCROT,
     &                    RANGNEW,XSHNEW,YSHNEW,MIRRORNEW,
     &                    RANGOUT,XSHOUT,YSHOUT,MIRROROUT,
     &                    NPROJ,ANGDIF,PEAKV,
     &                    DLIST,NLIST,IRTFLG)

        REAL, DIMENSION(3)             :: ANGOUT
        LOGICAL                        :: MIRRORNEW,MIRROROUT

C       AUTOMATIC ARRAY
        INTEGER, PARAMETER             :: NLISTMAX = 15
        REAL                              DLIST(15)

        IF (NLIST .GT. 7) THEN

           NLISTT    = MIN(NLIST,NLISTMAX)

           DLIST(1)  = ANGOUT(1)
           DLIST(2)  = ANGOUT(2)
           DLIST(3)  = ANGOUT(3)
           DLIST(4)  = IMGREF
           IF (MIRROROUT) DLIST(4) = -IMGREF 
           DLIST(5)  = IMGEXP

           DLIST(6)  = RANGOUT
           DLIST(7)  = XSHOUT
           DLIST(8)  = YSHOUT
           DLIST(9)  = NPROJ

           DLIST(10) = ANGDIF
           DLIST(11) = CCROT

           DLIST(12) = RANGNEW
           DLIST(13) = XSHNEW
           DLIST(14) = YSHNEW
           DLIST(15) = 0 
           IF (MIRRORNEW) DLIST(15) = -1.0 
        ELSE
C          OUTPUT .
C          1 - NUMBER OF THE MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT (ROTATION).
C          3 - PSI ANGLE. (IN=PLANE ROTATION)
C          4 - SX SHIFT PERMANENTLY SET TO ZERO IF NOT 'AP MQ,..'  
C          5 - SY SHIFT PERMANENTLY SET TO ZERO IF NOT 'AP MQ,..'  
C          6 - INPUT IMAGE NUMBER.
C          7 - ANGULAR DIFFERENCE. (-1.0 IF NOT DETERMINED)
d537 1
a537 1
           NLIST = 7
d539 2
a540 2
C          SAVE NUMBER OF MOST SIMILAR REF. IMAGE 
           DLIST(1) = IMGREF
d542 2
a543 2
C          SET MOST SIMILAR REF. IMAGE NUMBER <0 IF MIRRORED
           IF (MIRRORNEW)  DLIST(1) = -IMGREF 
d545 21
a565 21
           DLIST(2)  = CCROT
           DLIST(3)  = RANGNEW
	   DLIST(4)  = XSHNEW
	   DLIST(5)  = YSHNEW
           DLIST(6)  = IMGEXP
           DLIST(7)  = ANGDIF
         ENDIF

C         CALL REG_GET_USED(NSEL_USED)
C
C         IF (NSEL_USED .GT. 0) THEN
CC            OUTPUT TO REGISTERS
C             CALL REG_SET_NSEL(1,5, DLIST(2),DLIST(2),DLIST(3),
C     &                              DLIST(4),DLIST(5),IRTFLG)
C             CALL REG_SET_NSEL(6,5, DLIST(6),DLIST(7),DLIST(8),
C     &                              DLIST(9),DLIST(10),IRTFLG)
C             CALL REG_SET_NSEL(12,1,DLIST(11),DLIST(12),DLIST(13),
C     &                              DLIST(14),DLIST(15),IRTFLG)
C          ENDIF
C
          END
@


1.15
log
@mpi from chao yang
@
text
@d129 18
a146 3
C            ANGDIF = ABS(EXPDIR(1) * REFDIR(1) + 
             ANGDIF =    (EXPDIR(1) * REFDIR(1) + 
     &                    EXPDIR(2) * REFDIR(2) + 
a148 5
             ANGDIF = MAX(-1.0,ANGDIF)
C            ADJUST ANGDIF FOR MIRROR CHANGE
             IF ((      MIRROROLD .AND. .NOT. MIRRORNEW) .OR.
     &           (.NOT. MIRROROLD .AND.       MIRRORNEW ))
     &           ANGDIF = -ANGDIF
d450 16
a465 2
             ANGDIF = ABS(EXPDIR(1) * REFDIR(1) + 
     &                    EXPDIR(2) * REFDIR(2) + 
d469 1
a469 1
        ENDIF
@


1.14
log
@MIRROR&RANG MISSING LINE (BUGGY)
@
text
@d9 1
d336 208
@


1.13
log
@reg_set_nsel(11 wrong
@
text
@d33 1
a33 1
C--************************************************************************
d264 1
a264 1
C
d307 1
a307 2
           XSHOUT    =     XSHNEW + XSHOLD*C - YSHOLD*S

d309 1
a309 2
           XSHOUT    =     XSHNEW + XSHOLD*C - YSHOLD*S

d311 4
a314 4
           XSHOUT    =   - XSHNEW + XSHOLD*C - YSHOLD*S

       ELSE
           XSHOUT    =   - XSHNEW + XSHOLD*C - YSHOLD*S
d316 2
a317 1
        ENDIF
d319 3
a321 7
        IF (MIRROROLD .AND.  MIRRORNEW) THEN
           RANGOUT   = RANGOLD - RANGNEW
           MIRROROUT = (.NOT. MIRRORNEW) 
        ELSE
           RANGOUT   = RANGOLD + RANGNEW
           MIRROROUT = MIRRORNEW
        ENDIF
@


1.12
log
@angle for first reg wrong if reg. output used
@
text
@d252 1
a252 1
             CALL REG_SET_NSEL(12,1,DLIST(11),DLIST(12),DLIST(13),
@


1.11
log
@logic of mirror bug
@
text
@d8 1
d248 1
a248 1
             CALL REG_SET_NSEL(1,5, DLIST(2),DLIST(2),DLIST(3),
@


1.10
log
@ANGDIF IF CHANGE IN MIRROR
@
text
@d134 3
a136 4
             IF ((MIRROROLD .EQ. .TRUE. .AND.
     &            MIRRORNEW .EQ. .FALSE. .OR.
     &           (MIRROROLD .EQ. .FALSE. .AND.
     &            MIRRORNEW .EQ. .TRUE.)) ANGDIF = -ANGDIF
@


1.9
log
@logic for MIRROROLD  .AND.  .NOT. MIRRORNEW etc
@
text
@d5 3
a7 3
C                            PEAKV REMOVED         MAR 04 ArDean Leith
C                            IKEY                  MAR 04 ArDean Leith
C
d127 2
a128 1
             ANGDIF = ABS(EXPDIR(1) * REFDIR(1) + 
d132 6
@


1.8
log
@trap for no fref angles > angout
@
text
@d255 3
d290 3
d294 1
a294 1
        IF (MIRROROLD) RANGNEWT = -RANGNEWT
d299 15
a313 1
        IF (MIRROROLD) THEN
a314 1
           XSHOUT    = -XSHNEW + XSHOLD*C - YSHOLD*S
a317 1
           XSHOUT    = XSHNEW  +  XSHOLD*C - YSHOLD*S
d327 3
@


1.7
log
@labels only cosmetic
@
text
@d78 1
a78 1
         IF (IMGREF .GT. 0) THEN
@


1.6
log
@ikey used for ap mq
@
text
@d200 1
a200 1
C             <,<,<, REF#,IMG#,INPLANE<, SX,SY,NPROJ, <DIF,CCROT,INPLANE<,SX,SY
a233 3
C              write(6,*)' REF#, CCROT, INPLANE<, SX,SY, IMG#, < DIFF'
C              write(6,*)(dlist(it),it=1,NLIST)
C               write(6,*) '--------------'
@


1.5
log
@debug output removed
@
text
@d6 1
a133 1
          NWANTOUT = 7
d135 7
a141 1
     &        CTYPE(1:3) .EQ. 'REF') NWANTOUT = 15
d143 3
a145 2
C         SAVE NWANTOUT ALIGNMENT PARAMETERS 
          CALL AP_OUT(IMGEXP,IMGEXP,
@


1.4
log
@doc file cols. changed
@
text
@a193 1
          write(6,*) (dlist(ij),ij=1,11)
@


1.3
log
@-iref
@
text
@d194 1
@


1.2
log
@PEAKV REMOVED
@
text
@d20 1
a20 1
C          NIMALCGT, CTYPE, XBUF,LUNDOC)
d37 1
a37 1
     &                  NIMALCGT, CTYPE, XBUF,LUNDOC)
d68 2
a69 2
            NIMALCG = NIMALCGT
            IF (NIMALCG .EQ. 0) NIMALCG = 1
d72 1
a72 1
            NIMALCG = 1
d142 1
a142 1
     &                NIMALCG,ANGDIF,PEAKV,
d153 1
a153 1
     &                    NIMALCG,ANGDIF,PEAKV,
d174 2
a175 1
           DLIST(5)  = CCROT
d180 1
a180 2
           DLIST(9)  = 0.0
           IF (MIRROROUT) DLIST(9) = 1.0 
d182 2
a183 2
           DLIST(10)  = ANGDIF
C          DLIST(11)  = PEAKV
d185 5
a189 5
           DLIST(11)  = RANGNEW
           DLIST(12)  = XSHNEW
           DLIST(13)  = YSHNEW
           DLIST(14)  = -NIMALCG 
           IF (MIRRORNEW) DLIST(14)  = NIMALCG
d193 1
a193 1
C             <,<,<, REF#,CCROT,INPLANE <, SX,SY,MIR,INPLANE <, SX,SY,MIR,< DIFF,PEAKV
a194 5

C             write(6,*)
C     &       '<,<,<, REF#,CCROT,INPLANE <, SX,SY, MIR,IMG#, < DIFF,PEAKV'
C             write(6,*)(dlist(it),it=1,NLIST)
C             write(6,*)' '
@


1.1
log
@Initial revision
@
text
@d5 1
d147 1
d160 1
a160 1
        INTEGER, PARAMETER             :: NLISTMAX = 16
d183 1
a183 1
           DLIST(11)  = PEAKV
d185 5
a189 5
           DLIST(12)  = RANGNEW
           DLIST(13)  = XSHNEW
           DLIST(14)  = YSHNEW
           DLIST(15)  = -NIMALCG 
           IF (MIRRORNEW) DLIST(15)  = NIMALCG
@
