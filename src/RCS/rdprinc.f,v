head	1.32;
access;
symbols
	healthdept_2018:1.32
	pre_getangas:1.30
	GPL2010:1.30
	pre_GPL2010:1.29
	pre_var_equation:1.29
	pre_fftwrings:1.29
	pre_opfiles:1.29
	src:1.29
	best-code:1.29
	named-reg:1.28
	x-named-regs:1.27
	x:1.27
	v13-00:1.26
	pre_GPL:1.25
	prec_CA:1.23
	noindx:1.21
	Bproc:1.11
	oct21:1.7
	last77:1.4;
locks; strict;
comment	@c @;


1.32
date	2018.10.03.14.34.14;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2012.03.29.14.15.01;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.24.13.26.40;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.14.16.47.39;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.12.15.29.33;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.15.21.51.15;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.17.21.05.34;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.13.16.22.24;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.24.17.25.09;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.04.13.23.58;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.28.20.42.12;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.11.14.26.15;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.15.17.51.19;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.14.21.01.55;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.06.13.11.53;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2001.08.06.13.09.27;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.23.20.08.22;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.09.14.24.14;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.02.20.23.25;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.01.19.56.45;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.17.14.11.52;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	99.12.28.17.29.17;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	99.11.04.14.02.39;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	99.11.02.17.47.56;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	99.11.02.17.47.03;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	99.10.21.15.24.41;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	99.08.27.16.59.33;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	99.05.25.19.54.27;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	99.03.26.16.49.44;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	99.03.26.15.16.38;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	99.03.03.16.04.40;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	99.02.23.19.31.31;	author leith;	state Exp;
branches;
next	;


desc
@@


1.32
log
@email_health_dept
@
text
@
C++************************************************************************ 
C
C   RDPRINC.F             REMOVED FROM RDPRI       FEB 99  ArDean Leith
C                         LENGTHENED ANSW        11/17/00  ArDean Leith
C                         EXPRESSQ SHOULD BE SUB.  MAY 01  ArDean Leith
C                         DID NOT PRINT IF X       JAN 02  ArDean Leith
C                         ~PROMPT                  FEB 03  ArDean Leith
C                         NLOG                   11/26/03  ArDean Leith
C                         RDPR PARAMETERS        04/14/05  ArDean Leith
C                         ?..? LEVELS            11/28/05  ArDean Leith
C                        [] REWRITE              12/02/05  ArDean Leith
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C   RDPRINC(PROMPT,NVAL,INTS,NOT_USED,VAL1,VAL2,VAL3,IRTFLG)
C
C   PURPOSE:    EVALUATE INPUT FOR RDPR** SUBROUTINES
C
C   PARAMETERS:
C        PROMPT      PROMPT                                       (SENT)
C        NVAL        NUMBER OF VALUES TO RETURN                   (SENT)
C        INTS        LOGICAL FLAG FOR INTEGER RETURN              (SENT)
C        NOT_USED                                                 (SENT)
C        VAL1..      VALUES (ALWAYS AS FLOATS!)               (RETURNED)
C        IRTFLG      RETURN FLAG (0 IS NORMAL,1 IS ERROR      (RETURNED)
C                             -1 IS GOTO PREVIOUS QUESTION
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

      SUBROUTINE RDPRINC(PROMPT,NVAL,INTS,NOT_USED,
     &                   VAL1,VAL2,VAL3,IRTFLG)

      CHARACTER(LEN=*)  :: PROMPT
      LOGICAL           :: INTS
      REAL              :: VALUES(3)

      VALUES(1) = VAL1
      VALUES(2) = VAL2
      VALUES(3) = VAL3

      IRTFLG = 654321            ! FLAG TO ACCEPT <CR> or *

      CALL RDPRA(PROMPT,NVAL,0,INTS,VALUES,NGOT,IRTFLG)
      IF (IRTFLG .NE. 0) RETURN

      IF (NGOT > 0) THEN
C        COPY THE RETURNED VALUES 
         IF (NGOT .GE. 1) VAL1 = VALUES(1)
         IF (NGOT .GE. 2) VAL2 = VALUES(2)
         IF (NGOT .GE. 3) VAL3 = VALUES(3)
      ENDIF
      END

@


1.31
log
@IRTFLG = 654321  FLAG TO ACCEPT <CR> or *
@
text
@d19 1
a19 1
C=* Email: spider@@wadsworth.org                                        *
@


1.30
log
@GPL_2010
@
text
@d17 1
a17 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d44 1
a44 1
C        VAL1..      VALUES (ALWAYS AS FLOATS)                (RETURNED)
d54 3
a56 3
      CHARACTER(LEN=*)         :: PROMPT
      LOGICAL                  :: INTS
      REAL, DIMENSION(3)       :: VALUES
d62 2
d67 1
a67 1
      IF (NGOT .GT. 0) THEN
@


1.29
log
@split out rdpra.f
@
text
@a13 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d15 5
a19 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d21 1
a21 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d26 1
a26 1
C=* This program is distributed in the hope that it will be useful,    *
d28 1
a28 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a29 1
C=*                                                                    *
d31 1
a31 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.28
log
@native named registers
@
text
@d66 1
a66 1
      CALL RDPRA(PROMPT,NVAL,INTS,VALUES,NGOT,IRTFLG)
a76 231
C******************************* RDPRA ******************************


      SUBROUTINE RDPRA(PROMPT,NVAL,INTS,VALUES,NGOT,IRTFLG)

      INCLUDE 'CMBLOCK.INC' 

      CHARACTER(LEN=*)         :: PROMPT
      REAL, DIMENSION(NVAL)    :: VALUES
      LOGICAL                  :: INTS

C     MAXANS IS LENGTH OF ANSW,RESPONSE
      INTEGER, PARAMETER       :: MAXANS = 600
      CHARACTER(LEN=MAXANS)    :: ANSW,RESPONSE

      LOGICAL                  :: GETANS,UPPER,WANTSUB
      LOGICAL                  :: SAYPRMT,SAYANS,ENDATSEMI,STRIP
      LOGICAL                  :: INPARLOOP

      INTEGER, PARAMETER       :: MAXB = 200
      REAL, DIMENSION(MAXB)    :: FBUF

      SAVE            FBUF

#ifdef USE_MPI
      include 'mpif.h'
      integer mypid, comm, ierr
      comm = MPI_COMM_WORLD
      call MPI_COMM_RANK(comm, mypid,  IERR)
#else
      mypid = -1
#endif

C     NOFF IS OFFSET FOR NUMBER OF INPUTTED MULTILINE INPUT VALUE
      NOFF = 1

      GETANS    = .TRUE.
      UPPER     = .FALSE.
      WANTSUB   = .TRUE.
      SAYPRMT   = .TRUE.
      SAYANS    = .FALSE.
      ENDATSEMI = .TRUE.
      STRIP     = .TRUE.

10    IF (PROMPT(:1) .EQ. '~') THEN
C         USE PROMPT FOR INPUT LINE
          ANSW    = PROMPT(2:)
          NCHAR   = lnblnkn(ANSW)
      ELSE
          CALL RDPR(PROMPT,NCHAR,ANSW,GETANS,
     &             UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI,STRIP,IRTFLG)
         IF (IRTFLG .EQ. -1) RETURN
      ENDIF

      IF (NCHAR .LE. 0) THEN
         IRTFLG = 0
         RETURN
      ENDIF

      DO WHILE (ANSW(NCHAR:NCHAR) .EQ. ',') 
C        INPUT CONTINUATION LINE 
         CALL RDPR('ENTER NEXT LINE OF INPUT',NCHAR2,RESPONSE,GETANS,
     &             UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI,STRIP,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN

         IF ((NCHAR + NCHAR2) .GT. MAXANS) THEN
            CALL ERRT(101,'ANSWER TOO LONG',NE)
            RETURN
         ENDIF
         ANSW(NCHAR+1:) = RESPONSE(1:NCHAR2)
         NCHAR = NCHAR + NCHAR2
      ENDDO

      IF (ANSW(:1) .EQ. '?') THEN
C         ?PROMPT? [var] LINE RETURNED, FIND NEXT RESPONSE
          CALL STACK_RESPONSE(ANSW(1:NCHAR),RESPONSE,IRTFLG)

C         STRIP SEMICOLON DENOTED COMMENT & TRAILING BLANKS
          CALL DECOMMENT(RESPONSE,NCHAR,LOCSEMI)

C         SEE IF NEED TO CONVERT OLD x11 REGISTER FORMAT 
          IX = SCAN(RESPONSE(1:NCHAR),'xX')
          IF (IX .GT. 0) THEN
C            CONVERT OLD x11 REGISTER FORMAT TO TO NEW: [name] FORMAT
             CALL DEXREG(RESPONSE,NCHAR)
          ENDIF
          ANSW   = RESPONSE(1:NCHAR)
          ISTACK = -1
      ELSE
          ISTACK = 0
      ENDIF

C     EVALUATE EXPRESSION(S) OR LIST OF VALUES FROM ANSW
      CALL EXPRESS3Q(ANSW(1:NCHAR),ISTACK,MAXB,
     &                  FBUF,INUM,INPARLOOP,IRTFLG)

      IF (IRTFLG .NE. 0) THEN
C        GOT BAD INPUT PARAMETERS, RE-ENTER
         CALL ERRT(16,'CAN NOT INTERPRET INPUT',NE)
         GOTO 10
      ENDIF

C     PREVIOUSLY ANY  EXPRESSION WITH REGISTERS DID NOT NEED ()
      IBRAK = SCAN(ANSW(1:NCHAR),'[')
      IF (IBRAK .GT. 0) INPARLOOP = .TRUE.

      IF (INPARLOOP .OR. NLOOP .LE. 1) THEN
C        INPUT HAS () AROUND IT OR IS NOT IN A MULTIPLE VALUE LOOP.
C        IF IN A LOOP, USES SAME INPUT FOR ALL LOOP INDICES
         ILOC = 1
C        NGOT IS NUMBER OF VALUES LEFT IN FBUF
         NGOT = INUM
      ELSE
C        INPUT HAS NO () AROUND IT, USES DIFFERENT SET OF INPUTS
C        FOR EACH INDEX OF THE CURRENT LOOP
 
         NTOT   = NOFF + INUM - 1 
         NEEDED = NVAL * NLOOP 
         IF (NTOT .LT. NEEDED)  THEN
C           NEEDS MORE INPUT TO GET "NVAL" INPUTS, READ ANOTHER LINE.
C           INCREMENT CURRENT INPUT VALUE INDEX FIRST
            NOFF = NOFF + INUM
            GOTO 10
         ENDIF

C        ILOC IS POINTER TO CURRENT LOCATION IN FBUF
         ILOC = (ILOOP - 1) * NVAL + 1
C        NGOT IS NUMBER OF VALUES LEFT IN FBUF
         NGOT = NTOT - ILOC + 1
      ENDIF
 
      NGOT = MIN(NGOT,NVAL)
      IF (INTS) THEN
C        CONVERT VALUES TO INTEGERS
         DO I = 1,NGOT
            VALUES(I) = INT(FBUF(ILOC + I -1))
         ENDDO
      ELSE
C        FLOATING POINT VALUES WANTED
         DO I = 1,NGOT
            VALUES(I) = FBUF(ILOC + I -1)
         ENDDO
      ENDIF
  
      IF (INTS .AND. MYPID .LE. 0) THEN
C        INTEGER VALUES WANTED
         IF (NOUT .NE .0) WRITE(NOUT,90) (INT(VALUES(I)),I=1,NGOT)
         IF (NLOG .NE .0) WRITE(NLOG,90) (INT(VALUES(I)),I=1,NGOT)
 90      FORMAT(2X,10(1X,I7))
      ELSEIF (MYPID .LE. 0) THEN
C        FLOATING POINT VALUES WANTED
         IF (NOUT .NE .0) WRITE(NOUT,91) (VALUES(I),I=1,NGOT)
         IF (NLOG .NE .0) WRITE(NLOG,91) (VALUES(I),I=1,NGOT)
  91     FORMAT(2X,10(G12.3,1X))
      ENDIF
 
      IRTFLG = 0

      RETURN
      END


C      *********************** STACK_RESPONSE *************************

      SUBROUTINE STACK_RESPONSE(PROMPTNID,RESPONSE,IRTFLG)

      INCLUDE 'CMBLOCK.INC' 
      INCLUDE 'CMLIMIT.INC' 
 
      CHARACTER (LEN=*)        :: PROMPTNID,RESPONSE

      CHARACTER (LEN=2*MAXNAM) :: PROMPT,SYMPARID
      CHARACTER (LEN=1)        :: NULL,CDUM

C     FOR LOCAL VARIABLE HANDLING 
      INTEGER, DIMENSION(MAXPRC) :: IPSTACK,IPNUMSTACK,IPARNUM
      COMMON /QSTR_STUFF1/ ISTOP,ITI,ITIN,IWHERE,IPSTACK,
     &                     IPNUMSTACK,IPARNUM

#ifdef USE_MPI
      include 'mpif.h'
      icomm = MPI_COMM_WORLD
      call MPI_COMM_RANK(icomm, mypid, ierr)
#else
      MYPID = -1
#endif

      NULL = CHAR(0)

C     EXTRACT PROMPT FROM PROMPTNID INPUT STRING
      CALL PARSESYMPAR(PROMPTNID,NULL,PROMPT,NCHARP,
     &                 SYMPARID,NCHARI,CDUM,NDUM,CALLERRT,IRTFLG)
      IF (PROMPT .EQ. NULL) RETURN

C     WRITE PROMPT TO  RESULTS FILE
      IF (MYPID .LE. 0) THEN
         WRITE(NOUT,*) ' ',PROMPT(1:NCHARP)
      ENDIF 

      IF (FROMBATCH) THEN
C        FROM BATCH MODE, NOT FROM INTERACTIVE MODE
C        SO GET RESPONSE FROM CALLING PROCEDURE FILE

C        INCREMENT BATCH LINE POINTER FOR FURTHER READS
         IPSTACK(ISTOP) = IPSTACK(ISTOP) + 1
         CALL PROC_GETPLINE(IPSTACK(ISTOP),IPNUMSTACK(ISTOP-1),
     &                      RESPONSE, NCHAR,IRTFLG)

      ELSE
C        '?...?' FROM BATCH TO INTERACTIVE MODE

C        WRITE  ?---? PROMPT TO TERMINAL 
         IF (MYPID .LE. 0) THEN
            WRITE(ITI,991,ADVANCE='NO') PROMPT(1:NCHARP)
         ENDIF
991      FORMAT( ' .',A,': ')

C        GET RESPONSE FROM CALLING TERMINAL
         READ(ITIN,80) RESPONSE
80       FORMAT(A)
      ENDIF

C     STRIP SEMICOLON DENOTED COMMENT & TRAILING BLANKS
      CALL DECOMMENT(RESPONSE,NCHAR,LOCSEMI)

#ifdef USE_MPI
      call MPI_BARRIER(icomm,ierr)
#endif
      RETURN
      END

@


1.27
log
@named register support
@
text
@a4 1
C                         ADDED FILNAMSUB CALL     DEC 99  ArDean Leith
a5 1
C                         REMOVED FILNAMSUB        APR 01  ArDean Leith
d11 2
d58 24
d85 1
a85 1
      CHARACTER(LEN=161)       :: ANSW
d88 8
a95 2
      LOGICAL                  :: GETANS
      LOGICAL                  :: UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI
a97 2
      INTEGER, DIMENSION(MAXB) :: IBUF(MAXB)
      EQUIVALENCE     (FBUF,IBUF)
d99 1
a99 1
      SAVE            IBUF,FBUF
d113 2
a114 1
      UPPER     = .TRUE.
d119 1
a119 1
      GETANS    = .TRUE.
d124 1
a124 1
          NCHAR   = LEN(ANSW)
a125 1
COLD      CALL RDPR(PROMPT,NCHAR,ANSW,.TRUE.,.TRUE.,IRTFLG)
d127 1
a127 1
     &             UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI,IRTFLG)
d136 5
a140 2
C     IGNORE SEMICOLON DENOTED COMMENT AT END OF ANSW STRING
      LOCSEMI = INDEX(ANSW(1:NCHAR),';')
d142 25
a166 4
      IF (LOCSEMI .GT. 1) THEN
C         STRIP COMMENT & TRAILING BLANKS
          NCHAR = LNBLNKN(ANSW(1:LOCSEMI-1))
          ANSW(LOCSEMI:) = ' '
d169 9
a177 1
      CALL EXPRESS3Q(ANSW(1:NCHAR),NCHAR,VAL1,VAL2,VAL3,NGOT) 
d179 21
a199 7
      IF (NGOT .GT. 0) THEN
C        INPUT CONTAINS A REGISTER EXPRESSION RETURNED IN VAL1....
         IF (INTS) THEN
C           CONVERT VAL1... TO INTEGERS
            VAL1 = INT(VAL1)
            IF (NVAL .GE. 2) VAL2 = INT(VAL2)
            IF (NVAL .GE. 3) VAL3 = INT(VAL3)
d201 13
d215 17
a231 1
C        NO REGISTERS IN INPUT, EXTRACT THE NUMBER(S)
d233 4
a236 9
C        ERROR OUTPUT ADDED 11/30/94 al
         IF (NOFF + NVAL .GT. MAXB) THEN
C           POTENTIAL OVERFLOW OF IBUF OR FBUF
            CALL ERRT(101,'INPUT BUFFER OVERFLOW IN RDPRINC',NE)
            IRTFLG = 1
            RETURN
         ENDIF
C        REMOVE ANY LEADING BLANKS
         IF (ANSW(1:1) .EQ. ' ') ANSW = ADJUSTL(ANSW)
a237 11
         IF (ANSW(1:1) .NE. '(' .AND. NLOOP .GT. 1) THEN
C           INSIDE A LOOP AND INPUT HAS NO () AROUND IT.
C           CHECK FOR INVALID CHAR. THAT MAY INDICATE MISSING ()S
            INOT = VERIFY(ANSW,' -+.Ee0123456789,')
            IF (INOT .GT. 0) THEN
C              INVALID CHAR. IN INPUT
               WRITE(NOUT,*)
     &           '*** INSIDE DO-LOOP; YOU MAY HAVE FORGOTTEN ()s' 
CCC                WRITE(NOUT,*)NLOOP,INOT 
            ENDIF
         ENDIF
d239 1
a239 9
         IF (INTS) THEN
C           WANT INTEGERS
            CALL CHKSTR(ANSW(1:NCHAR),NCHAR,'I',IBUF(NOFF),DUM,
     &                  MAXB,INUM,IER)
         ELSE
C           WANT FLOATING POINT VALUES
            CALL CHKSTR(ANSW(1:NCHAR),NCHAR,'R',NDUM,FBUF(NOFF),
     &                 MAXB,INUM,IER)
         ENDIF
d241 1
a241 6
         IF (IER .NE. 0) THEN
C           CHKSTRQ GOT BAD INPUT PARAMETERS, RE-ENTER
c            WRITE(NOUT,*) 'NCHAR: ',NCHAR,'  BAD INPUT STRING: ',ANSW
            CALL ERRT(16,'RDPRINC',NE)
            GOTO 10
         ENDIF
d243 2
a244 6
         IF (ANSW(1:1) .EQ. '(' .OR. NLOOP .LE. 1) THEN
C           INPUT HAS () AROUND IT OR IS NOT IN A MULTIPLE VALUE LOOP.
C           IF IN A LOOP, USES SAME INPUT FOR ALL LOOP INDICES
            ILOC = 1
C           NGOT IS NUMBER OF VALUES LEFT IN IBUF/FBUF
            NGOT = INUM
d246 4
a249 17
         ELSE
C           INPUT HAS NO () AROUND IT, USES DIFFERENT SET OF INPUTS
C           FOR EACH INDEX OF THE CURRENT LOOP
 
            NTOT   = NOFF + INUM - 1 
            NEEDED = NVAL * NLOOP 
            IF (NTOT .LT. NEEDED)  THEN
C              NEEDS MORE INPUT TO GET "NVAL" INPUTS, READ ANOTHER LINE.
C              INCREMENT CURRENT INPUT VALUE INDEX FIRST
               NOFF = NOFF + INUM
               GOTO 10
            ENDIF
C           ILOC IS POINTER TO CURRENT LOCATION IN IBUF/FBUF
            ILOC = (ILOOP - 1) * NVAL + 1
C           NGOT IS NUMBER OF VALUES LEFT IN IBUF/FBUF
            NGOT = NTOT - ILOC + 1
         ENDIF
d251 4
a254 10
         IF (INTS) THEN
C           INTEGER VALUES WANTED
            VAL1 = IBUF(ILOC)
            IF (NGOT .GE. 2 .AND. NVAL .GE. 2) VAL2 = IBUF(ILOC + 1)
            IF (NGOT .GE. 3 .AND. NVAL .GE. 3) VAL3 = IBUF(ILOC + 2)
        ELSE
C           FLOATING POINT VALUES WANTED
            VAL1 = FBUF(ILOC)
            IF (NGOT .GE. 2 .AND. NVAL .GE. 2) VAL2 = FBUF(ILOC + 1)
            IF (NGOT .GE. 3 .AND. NVAL .GE. 3) VAL3 = FBUF(ILOC + 2)
d256 7
a262 2
        ENDIF
      ENDIF
d264 1
a264 2
      IF (INTS) THEN
C        INTEGER VALUES WANTED
d266 18
a283 16
         IF (MYPID .LE. 0) THEN
            IF (NVAL .EQ. 1) THEN
               IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1)
               IF (NLOG .NE. 0)  WRITE(NLOG,90)  INT(VAL1)
 90            FORMAT(5X,3(1X,I7))

            ELSEIF(NVAL .EQ. 2) THEN
               IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1),INT(VAL2)
               IF (NLOG .NE. 0) WRITE(NLOG,90)   INT(VAL1),INT(VAL2)
            ELSE
               IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1),INT(VAL2),
     &                                           INT(VAL3)
               IF (NLOG .NE. 0) WRITE(NLOG,90)   INT(VAL1),INT(VAL2),
     &                                           INT(VAL3)
            ENDIF
         ENDIF
d286 3
a288 1
C        FLOATING POINT VALUES WANTED
d290 1
a290 11
            IF (NVAL .EQ. 1) THEN
               IF (NOUT .NE. 0) WRITE(NOUT,91)   VAL1
               IF (NLOG .NE. 0) WRITE(NLOG,91)   VAL1
 91            FORMAT(5X,3(G14.3,1X))
            ELSEIF(NVAL .EQ. 2) THEN
               IF (NOUT .NE. 0) WRITE(NOUT,91)   VAL1,VAL2
               IF (NLOG .NE. 0) WRITE(NLOG,91)   VAL1,VAL2
            ELSE
               IF (NOUT .NE. 0) WRITE(NOUT,91)   VAL1,VAL2,VAL3
               IF (NLOG .NE. 0) WRITE(NLOG,91)   VAL1,VAL2,VAL3
            ENDIF
d292 5
a297 2
 
      IRTFLG = 0
d299 6
d307 1
@


1.26
log
@GPL License fixed
@
text
@d2 1
a2 1
C++*********************************************************************
d12 1
a12 1
C
d58 1
a58 1
      INCLUDE        'CMBLOCK.INC' 
d60 9
a68 7
      CHARACTER *(*)  PROMPT
      CHARACTER *161  ANSW
      LOGICAL         INTS

      PARAMETER       (MAXB = 200)
      DIMENSION       FBUF(MAXB)
      DIMENSION       IBUF(MAXB)
d85 7
d97 3
a99 1
          CALL RDPR(PROMPT,NCHAR,ANSW,.TRUE.,.TRUE.,IRTFLG)
@


1.25
log
@cosmetic
@
text
@d2 1
a2 1
C++************************************************************************ 
d14 23
a36 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.24
log
@NLOG
@
text
@d204 2
a205 2
               IF (NOUT .NE. 0) WRITE(NOUT,91)  VAL1
               IF (NLOG .NE. 0) WRITE(NLOG,91) VAL1
a206 1

d208 1
a208 1
               IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1,VAL2
@


1.23
log
@mpi
@
text
@d6 2
a7 2
C                         LENGTHENED ANSW        11/17/00  ARDEAN LEITH
C                         REMOVED FILNAMSUB        APR 01  ARDEAN LEITH
d11 1
d53 1
d59 2
d62 1
d182 16
a197 15
#ifdef USE_MPI
         if (mypid .eq. 0) then
         IF (NVAL .EQ. 1) THEN
            IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1)
            IF (NPROC .NE. 0) WRITE(NPROC,90) INT(VAL1)
 90         FORMAT(5X,3(1X,I7))

         ELSEIF(NVAL .EQ. 2) THEN
            IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1),INT(VAL2)
            IF (NPROC .NE. 0) WRITE(NPROC,90) INT(VAL1),INT(VAL2)
         ELSE
            IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1),INT(VAL2),
     &                                        INT(VAL3)
            IF (NPROC .NE. 0) WRITE(NPROC,90) INT(VAL1),INT(VAL2),
     &                                        INT(VAL3)
d199 1
a199 17
         endif
#else
         IF (NVAL .EQ. 1) THEN
            IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1)
            IF (NPROC .NE. 0) WRITE(NPROC,90) INT(VAL1)
 90         FORMAT(5X,3(1X,I7))

         ELSEIF(NVAL .EQ. 2) THEN
            IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1),INT(VAL2)
            IF (NPROC .NE. 0) WRITE(NPROC,90) INT(VAL1),INT(VAL2)
         ELSE
            IF (NOUT .NE .0)  WRITE(NOUT,90)  INT(VAL1),INT(VAL2),
     &                                        INT(VAL3)
            IF (NPROC .NE. 0) WRITE(NPROC,90) INT(VAL1),INT(VAL2),
     &                                        INT(VAL3)
         ENDIF
#endif
d202 13
a214 13
#ifdef USE_MPI
         if (mypid .eq. 0) then
         IF (NVAL .EQ. 1) THEN
            IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1
            IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1
 91         FORMAT(5X,3(G14.3,1X))

         ELSEIF(NVAL .EQ. 2) THEN
            IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1,VAL2
            IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1,VAL2
         ELSE
            IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1,VAL2,VAL3
            IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1,VAL2,VAL3
a215 15
         endif
#else
         IF (NVAL .EQ. 1) THEN
            IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1
            IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1
 91         FORMAT(5X,3(G14.3,1X))

         ELSEIF(NVAL .EQ. 2) THEN
            IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1,VAL2
            IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1,VAL2
         ELSE
            IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1,VAL2,VAL3
            IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1,VAL2,VAL3
         ENDIF
#endif
@


1.22
log
@~prompt
@
text
@d52 6
a57 1

d177 2
d193 6
d200 10
d212 16
d240 1
@


1.21
log
@nloop removed
@
text
@d10 1
d56 8
a63 2
   10 CALL RDPR(PROMPT,NCHAR,ANSW,.TRUE.,.TRUE.,IRTFLG)
      IF (IRTFLG .EQ. -1) RETURN
@


1.20
log
@bug in print for x??
@
text
@d20 1
a20 1
C   RDPRINC(PROMPT,NVAL,INTS,NLOOPD,ILOOPD,VAL1,VAL2,VAL3,IRTFLG)
d28 1
a28 1
C        NLOOP,ILOOP LOOP COUNTERS                                (SENT)
d36 1
a36 1
      SUBROUTINE RDPRINC(PROMPT,NVAL,INTS,NLOOPD,ILOOPD,
d95 1
a95 1
         IF (ANSW(1:1) .NE. '(' .AND. NLOOPD .GT. 1) THEN
d103 1
a103 1
CCC                WRITE(NOUT,*)NLOOPD,INOT 
d124 1
a124 1
         IF (ANSW(1:1) .EQ. '(' .OR. NLOOPD .LE. 1) THEN
d136 1
a136 1
            NEEDED = NVAL * NLOOPD 
d144 1
a144 1
            ILOC = (ILOOPD - 1) * NVAL + 1
@


1.19
log
@did not print registers when input
@
text
@d166 2
a167 2
            IF (NOUT .NE .0)  WRITE(NOUT,90)  IBUF(ILOC)
            IF (NPROC .NE. 0) WRITE(NPROC,90) IBUF(ILOC)
d171 2
a172 4
            IF (NOUT .NE .0)  WRITE(NOUT,90)  IBUF(ILOC),
     &                                        IBUF(ILOC + 1)
            IF (NPROC .NE. 0) WRITE(NPROC,90) IBUF(ILOC),
     &                                           IBUF(ILOC + 1)
d174 4
a177 6
            IF (NOUT .NE .0)  WRITE(NOUT,90)  IBUF(ILOC),
     &                                        IBUF(ILOC + 1),
     &                                        IBUF(ILOC + 2)
            IF (NPROC .NE. 0) WRITE(NPROC,90) IBUF(ILOC),
     &                                        IBUF(ILOC + 1),
     &                                        IBUF(ILOC + 2)
d179 1
@


1.18
log
@format 91
@
text
@d9 1
d154 1
a154 20

            IF (NVAL .EQ. 1) THEN
               IF (NOUT .NE .0)  WRITE(NOUT,90)  IBUF(ILOC)
               IF (NPROC .NE. 0) WRITE(NPROC,90) IBUF(ILOC)
 90            FORMAT(5X,3(1X,I7))

            ELSEIF(NVAL .EQ. 2) THEN
               IF (NOUT .NE .0)  WRITE(NOUT,90)  IBUF(ILOC),
     &                                           IBUF(ILOC + 1)
               IF (NPROC .NE. 0) WRITE(NPROC,90) IBUF(ILOC),
     &                                           IBUF(ILOC + 1)
            ELSE
               IF (NOUT .NE .0)  WRITE(NOUT,90)  IBUF(ILOC),
     &                                           IBUF(ILOC + 1),
     &                                           IBUF(ILOC + 2)
               IF (NPROC .NE. 0) WRITE(NPROC,90) IBUF(ILOC),
     &                                           IBUF(ILOC + 1),
     &                                           IBUF(ILOC + 2)
            ENDIF
         ELSE
d160 36
a195 12
            IF (NVAL .EQ. 1) THEN
               IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1
               IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1
 91            FORMAT(5X,3(G14.3,1X))

            ELSEIF(NVAL .EQ. 2) THEN
               IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1,VAL2
               IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1,VAL2
            ELSE
               IF (NOUT  .NE. 0) WRITE(NOUT,91)  VAL1,VAL2,VAL3
               IF (NPROC .NE. 0) WRITE(NPROC,91) VAL1,VAL2,VAL3
            ENDIF
d198 1
a198 1

@


1.17
log
@outputs value of parameters now (now in rdpris....)
@
text
@d179 3
a181 3
               IF (NOUT  .NE. 0) WRITE(NOUT,90)  VAL1
               IF (NPROC .NE. 0) WRITE(NPROC,90) VAL1
 90            FORMAT(5X,3(G14.3,1X))
d184 2
a185 2
               IF (NOUT  .NE. 0) WRITE(NOUT,90)  VAL1,VAL2
               IF (NPROC .NE. 0) WRITE(NPROC,90) VAL1,VAL2
d187 2
a188 2
               IF (NOUT  .NE. 0) WRITE(NOUT,90)  VAL1,VAL2,VAL3
               IF (NPROC .NE. 0) WRITE(NPROC,90) VAL1,VAL2,VAL3
@


1.16
log
@express3q should be subroutine & had register 2 & 3 set to zero alwasys
@
text
@d153 19
d177 13
@


1.15
log
@rdpr simplification for symbolic parameters & variable subs.
@
text
@d8 1
d10 8
a17 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d42 1
a42 1
      LOGICAL         EXPRESS3Q,INTS
d71 3
a73 1
      IF (EXPRESS3Q(ANSW,NCHAR,VAL1,VAL2,VAL3)) THEN
d77 1
a77 1
            VAL1                  = INT(VAL1)
@


1.14
log
@ANSW(1:NCHAR)
@
text
@d7 1
a68 7
      ENDIF

      ILEFBRAK = INDEX(ANSW(:NCHAR),'{')
      IF (ILEFBRAK .GT. 0) THEN
C        SUBSTITUTE FOR {***X??) OR {---X??} IN NEWSTR
         CALL FILNAMSUB(ANSW,NCHAR,.FALSE.,FDUM,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
@


1.13
log
@(:NCHAR) on chkstrq call
@
text
@d62 1
a62 1
      LOCSEMI = INDEX(ANSW,';')
d122 1
a122 1
            WRITE(NOUT,*) 'BAD INPUT STRING: ',ANSW
@


1.12
log
@lengthened answ, handles comments now
@
text
@d112 2
a113 1
            CALL CHKSTR(ANSW,NCHAR,'I',IBUF(NOFF),DUM,MAXB,INUM,IER)
d116 2
a117 1
            CALL CHKSTR(ANSW,NCHAR,'R',NDUM,FBUF(NOFF),MAXB,INUM,IER)
d122 1
@


1.11
log
@used filnamsub
@
text
@d6 1
d40 1
a40 1
      CHARACTER *80   ANSW
d59 9
@


1.10
log
@used chkstr not chkstrq
@
text
@d4 3
a6 2
C   RDPRINC.F             REVOVED FROM RDPRI       FEB 99  Ardean Leith
C     
d58 7
@


1.9
log
@removed debug output
@
text
@d94 1
a94 1
            CALL CHKSTRQ(ANSW,NCHAR,'I',IBUF(NOFF),DUM,INUM,IER)
d97 1
a97 1
            CALL CHKSTRQ(ANSW,NCHAR,'R',NDUM,FBUF(NOFF),INUM,IER)
@


1.8
log
@nloop now is 0 if not in a loop & error msg warning added
@
text
@d88 1
a88 1
                WRITE(NOUT,*)NLOOPD,INOT 
@


1.7
log
@(1...  precedded by balnk bug fixed
@
text
@d77 14
d106 2
a107 3
         IF (ANSW(1:1) .EQ. ' ') ANSW = ADJUSTL(ANSW)
         IF (ANSW(1:1) .EQ. '(' .OR. NLOOPD .EQ. 1) THEN
C           INPUT HAS () AROUND IT OR IS NOT IN A LOOP.
@


1.6
log
@bad NCUR --> NGOT
@
text
@d92 1
@


1.5
log
@fixed  multiple oine loop input
@
text
@d121 1
a121 1
            IF (NCUR .GE. 3 .AND. NVAL .GE. 3) VAL3 = IBUF(ILOC + 2)
@


1.4
log
@first input for i3 asked more questions instead of accepted null
@
text
@d70 7
a76 7
C           ERROR OUTPUT ADDED 11/30/94 al
            IF (NOFF + NVAL .GT. MAXB) THEN
C              POTENTIAL OVERFLOW OF IBUF OR FBUF
               CALL ERRT(101,'INPUT BUFFER OVERFLOW IN RDPRINC',NE)
               IRTFLG = 1
               RETURN
            ENDIF
d92 7
a98 16
         IF (ANSW(1:1) .EQ. '(' .OR.
     &      (INUM .EQ. 1 .AND. NOFF .EQ. 1) .OR.
     &      (INUM .EQ. 2 .AND. NOFF .EQ. 1 .AND. NVAL .EQ. 3)) THEN
C           INPUT HAS () AROUND IT, OR ONLY 1 INPUT AND THIS IS THE
C           FIRST INPUTED LINE IN THIS ROUTINE
            IF (INTS) THEN
C              INTEGER VALUES WANTED
               VAL1                                    = IBUF(1)
               IF (NVAL .GE. 2 .AND. INUM .NE. 1) VAL2 = IBUF(2)
               IF (NVAL .GE. 3 .AND. INUM .NE. 2) VAL3 = IBUF(3)
            ELSE
C              FLOATING POINT VALUES WANTED
               VAL1                                    = FBUF(1)
               IF (NVAL .GE. 2 .AND. INUM .NE. 1) VAL2 = FBUF(2)
               IF (NVAL .GE. 3 .AND. INUM .NE. 2) VAL3 = FBUF(3)
            ENDIF
d100 9
a108 6
C           INCREMENT NOFF IN CASE MORE INPUT IS NEEDED
            NOFF   = NOFF + INUM
            NEEDED = NVAL * NLOOPD  
            IF (NOFF-1 .LT. NEEDED)  THEN
C              NON () INPUT NEEDS MORE VALUES TO GET NVAL  INPUTS
C              GO BACK AND READ ANOTHER INPUT LINE
a110 1

d113 14
a126 11
            IF (INTS) THEN
C              INTEGER VALUES WANTED
               VAL1                  = IBUF(ILOC)
               IF (NVAL .GE. 2) VAL2 = IBUF(ILOC + 1)
               IF (NVAL .GE. 3) VAL3 = IBUF(ILOC + 2)
            ELSE
C              FLOATING POINT VALUES WANTED
               VAL1                  = FBUF(ILOC)
               IF (NVAL .GE. 2) VAL2 = FBUF(ILOC + 1)
               IF (NVAL .GE. 3) VAL3 = FBUF(ILOC + 2)
            ENDIF
@


1.3
log
@returns irtflg=0 if null response now
@
text
@d92 3
a94 1
         IF ((INUM .EQ. 1 .AND. NOFF .EQ. 1).OR.ANSW(1:1) .EQ. '(')THEN
@


1.2
log
@used rdprinc
@
text
@d26 1
a26 1
C        IRTFLG      RETURN FLAG (0 IS NORMAL,                (RETURNED)
a27 1
C                             -3 IS ACCEPTED NULL RETURN
d55 1
a55 1
         IRTFLG = - 3
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
C   RDPRI1S.F             REVOVED FROM RDPRI       FEB 99  Ardean Leith
d16 1
a16 1
C   RDPRINC(ANSW,NCHAR,NVAL,INTS,VAL1,VAL2,VAL3,IRTFLG)
d21 8
a28 6
C        ANSW     INPUT STRING                               (SENT)
C        NCHAR    NUMBER OF CHAR. IN INPUT STRING            (SENT)
C        NVAL     NUMBER OF VALUES TO RETURN                 (SENT)
C        INTS     LOGICAL FLAG FOR INTEGER RETURN            (SENT)
C        VAL1..   VALUES                                     (RETURNED)
C        IRTFLG   RETURN FLAG (0 IS NORMAL,  -1 IS REPEAT PREVIOUS QUESTION)
a29 1
C        0         2         3         4         5         6         7
d33 2
a34 1
      SUBROUTINE RDPRINC(ANSW,NCHAR,NVAL,INTS,VAL1,VAL2,VAL3,IRTFLG)
d38 2
a39 1
      CHARACTER *(*)  ANSW
d41 2
a42 1
      PARAMETER       (MAXB = 300)
d45 1
d47 1
a47 1
      SAVE            IBUF
d49 1
d52 8
d63 2
a64 1
            VAL1 = INT(VAL1)
d69 10
a78 1
C        NO REGISTERS IN INPUT, EXTRACT THE NUMBER(S) 
d80 1
d83 1
d88 1
a88 1
C           BAD INPUT PARAMETERS, RE-ENTER
d90 1
a90 2
            IRTFLG = -1
            RETURN
d94 2
d97 2
a98 1
               VAL1 = IBUF(1)
d102 2
a103 1
               VAL1 = FBUF(1)
d108 7
a114 5
            NOFF        = NOFF + INUM
            NVALTNLOOPD = NVAL * NLOOPD  
            IF (NOFF-1 .LT. NVALTNLOOPD)  THEN
               IRTFLG = -1
               RETURN
d117 2
a118 5
C           ERROR OUTPUT ADDED 11/30/94 al
            NVALTILOOPD = NVAL * ILOOPD
            IF (NVALTILOOPD .GT. MAXB) THEN
               CALL ERRT(101,' ILOOPD > MAXB IN RDPRINC',NE)
            ENDIF
d120 4
a123 3
               VAL1    = IBUF(2*ILOOPD - 1)
               IF (NVAL .GE. 2) VAL2 = IBUF(2*ILOOPD)
               IF (NVAL .GE. 2) VAL3 = IBUF(2*ILOOPD + 1)
d125 4
a128 3
               I1    = FBUF(2*ILOOPD - 1)
               IF (NVAL .GE. 2) VAL2 = FBUF(2*ILOOPD)
               IF (NVAL .GE. 2) VAL3 = FBUF(2*ILOOPD + 1)
@
