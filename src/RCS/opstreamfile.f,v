head	1.31;
access;
symbols
	pre_getangas:1.20
	GPL2010:1.20
	pre_GPL2010:1.19
	pre_var_equation:1.19
	pre_fftwrings:1.14
	pre_opfiles:1.14
	src:1.14
	best-code:1.14
	x-named-regs:1.13
	x:1.13
	v13-00:1.13
	pre_GPL:1.12
	prec_CA:1.12
	noindx:1.6;
locks; strict;
comment	@c @;


1.31
date	2015.07.15.14.16.19;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2015.01.21.16.38.32;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2014.09.15.15.37.33;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.01.12.33.42;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2013.08.01.12.30.25;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2013.07.31.18.07.54;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.21.17.44.03;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.12.12.49.53;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.05.18.46.23;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.21.16.38.59;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2012.05.17.14.48.30;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.24.13.25.18;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.22.13.29.07;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.05.16.28.04;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.19.15.19.39;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2008.09.26.12.33.05;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2008.09.26.12.29.08;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.09.16.14.10;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.17.20.59.58;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.22.18.38.02;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.11.16.15.14;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.04.16.05.07;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.04.15.47.53;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.03.16.57.36;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.20.21.41.09;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.18.13.49.18;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.15.20.32.51;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.29.19.53.13;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.11.14.08.56;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.04.19.01.45;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.22.18.06.32;	author leith;	state Exp;
branches;
next	;


desc
@@


1.31
log
@*** empty log message ***
@
text
@
C ++********************************************************************
C
C OPSTREAMFILE             STREAM IO               FEB 13 ArDean Leith
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C 
C OPSTREAMFILE(ASKNAME,FILNAM,EXTENT,LUNT, FORMVAR, DISP, 
C              PROMPTT,CALLERRT,IRTFLG)
C                                                                      
C PURPOSE: 
C
C NOTES: 
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

         SUBROUTINE OPSTREAMFILE(ASKNAME,FILNAM,EXTENT,LUNT,
     &                           FORMVAR, DISP, 
     &                           PROMPTT,CALLERRT,IRTFLG)

        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC'
       
        LOGICAL           :: ASKNAME
        CHARACTER(LEN=*)  :: FILNAM,EXTENT
        INTEGER           :: LUNT
        CHARACTER(LEN=11) :: FORMVAR
        CHARACTER(LEN=*)  :: DISP,PROMPTT
        LOGICAL           :: CALLERRT
        INTEGER           :: IRTFLG

        LOGICAL           :: EX
        CHARACTER(LEN=96) :: PROMPT
        CHARACTER(LEN=80) :: EXTEN
        CHARACTER(LEN=7)  :: STATVAR

        INTEGER           :: ICOMM,MYPID,MPIERR,LENP,NCHAR
        INTEGER           :: LNBLNKN
        INTEGER           :: LENE,IRTFLGT,LUN,IDUM,LENOPEN,LENOPENFILE
        INTEGER           :: LENOPN,LENREC

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID  #ifdef USE_MPI

C       SET DEFAULT ERROR RETURN
        IRTFLG = 1

C       DO NOT WANT TO RETURN EXTEN
        EXTEN = EXTENT

C       INPUT FILE NAME (IF EXTEN EXISTS IT IS ADDED)

        IF (ASKNAME) THEN
C          SET PROMPT TO ALLOW FILE EXTENSION ON INPUT
           LENP   = LEN(PROMPTT)
           LENP   = MIN(LENP,93)
           PROMPT = PROMPTT(1:LENP) // '~9' 

           CALL FILERD(FILNAM,NCHAR,EXTEN,PROMPT(1:LENP+2),IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ELSE
C          MAY WANT TO ADD EXTENT TO FILNAM
           NCHAR = LNBLNKN(FILNAM)
           LENE  = LNBLNKN(EXTENT)
           IF (LENE > 0) THEN
C             ADD THE EXTENSION THAT IS SENT TO FILNAM
              CALL FILNAMANDEXT(FILNAM,EXTEN,FILNAM,NCHAR,
     &                          .TRUE.,IRTFLGT)
           ENDIF
        ENDIF

        LUN = ABS(LUNT)
        IF ((LUN <= 0 .OR. LUN > 100) .AND.
     &     (LUN .NE. 103)) THEN
C          LUN=103 USED IN  SYMPARTEXT 
           CALL ERRT(102,'IN SOURCE CODE, LUN MUST BE 1...100',LUN)
           RETURN
        ENDIF

        IF (LUN > 0 .AND. LUN <= 100) THEN
C          ZERO THE FLAGS USED IN REDLIN/WRTLIN
           CALL LUNSETLUNS(LUN,0,0,LUN,0,IRTFLGT)
 
C          MAKE SURE THIS IS NOT TREATED AS INLINE FILE
           CALL CLOSEINLN(LUN,IRTFLGT)
        ENDIF

C       SET STATUS FOR OPEN
        STATVAR = 'NEW'

        IF (DISP(1:1) == 'N' .OR. DISP(1:1) == 'U') 
     &     STATVAR = 'REPLACE'

        IF (DISP(1:1) == 'S') STATVAR = 'SCRATCH'

        IF (DISP(1:1) == 'O') THEN
C          CHECK FOR FILE EXISTENCE 
           IF (MYPID <= 0) THEN
              INQUIRE (FILE=FILNAM(1:NCHAR),EXIST=EX,IOSTAT=IRTFLGT) 
           ENDIF

#ifdef USE_MPI
           CALL BCAST_MPI('OPSTREAMFILE','EX',           EX,1,'L',ICOMM)
           CALL BCAST_MPI('OPSTREAMFILE','IRTFLGT', IRTFLGT,1,'I',ICOMM)
#endif

           IF (IRTFLGT .NE. 0) THEN
              WRITE(NOUT,*) '*** INQUIRY ERROR'
              IF (CALLERRT)  CALL ERRT(4,'OPSTREAMFILE',IDUM)
              RETURN
        
           ELSEIF (.NOT. EX) THEN
              WRITE(NOUT,*) '*** FILE DOES NOT EXIST: ',FILNAM(1:NCHAR)
              IF (CALLERRT)  CALL ERRT(100,'OPSTREAMFILE',IDUM)
              RETURN

           ENDIF
           STATVAR = 'OLD'
        ENDIF

C       OPEN FILE FOR STREAM ACCESS

C       COMPUTE RECL UNITS (DIFFERS WITH OS &A COMPILER FLAGS)
        LENOPN = LENOPENFILE(LENREC)

        IF (MYPID <= 0) THEN
           IF (STATVAR == 'SCRATCH') THEN
	      OPEN(UNIT=LUN,STATUS=STATVAR,
     &             FORM=FORMVAR, ACCESS='STREAM',
     &             IOSTAT=IRTFLGT)
           ELSE
	      OPEN(UNIT=LUN,FILE=FILNAM(1:NCHAR),STATUS=STATVAR,
     &             FORM=FORMVAR, ACCESS='STREAM', 
     &             IOSTAT=IRTFLGT)
           ENDIF
        ENDIF

#ifdef USE_MPI
        CALL BCAST_MPI('OPSTREAMFILE','IRTFLGT', IRTFLGT,1, 'I',ICOMM)
#endif


        IF (IRTFLGT .NE. 0) THEN
           WRITE(NOUT,90) FORMVAR(1:1), FILNAM(:NCHAR)
 90        FORMAT(' ERROR OPENING (',A1,'): ',A)
           IF (CALLERRT) CALL ERRT(102,'OPSTREAMFILE',IRTFLGT)
           RETURN
        ENDIF

        IF (VERBOSE .AND. MYPID <= 0) THEN
           WRITE(NOUT,91) FORMVAR(1:1), FILNAM(:NCHAR)
 91        FORMAT('  OPENED (',A1,'): ',A)
        ENDIF

        IRTFLG = 0

        END


@


1.30
log
@IPOSMRC  to INTEGER * 8
@
text
@d4 1
a4 13
C COPYCCP4                 MODIFIED FROM COPYMRC   FEB 02 ArDean Leith         
C                          ISSWAB ADDED            JUL 02 ArDean Leith
C                          FLIP QUESTION           MAR 03 ArDean Leith
C                          BAD IRECMRC4 & FLIP     SEP 03 ArDean Leith
C                          SCALING                 JAN 05 ArDean Leith
C                          I*8                     SEP 08 ArDean Leith
C                          NPIX8                   DEC 08 ArDean Leith
C                          BOTLEFT OPTION          MAY 12 ArDean Leith
C                          STREAM IO               FEB 13 ArDean Leith
C                          VOL BUG                 JUN 13 ArDean Leith
C                          VOL BUG FIXED           JUL 13 ArDean Leith
C                          MODE 6 STACK SUPPORT    SEP 14 ArDean Leith
C                          IPOSMRC INTEGER *8      JAN 15 ArDean Leith
d27 2
a28 1
C COPYCCP4(LUNSPI,LUNMRC,NX,NY,NZ)
d30 1
a30 2
C PURPOSE: CONVERTS SPIDER IMAGES TO OR FROM CCP4 FORMAT
C          CRUDELY WRITTEN!!!
d32 1
a32 6
C NOTES: DATA IN MRC FILE
C	 MODE   TYPES OF PIXEL IN IMAGE
C               0 : INTEGER*1 (UNSIGNED BYTES) 
C               1 : INTEGER*2 (SIGNED) 
C               2 : REALS
C               6 : INTEGER*2 (UNSIGNED)
a36 603
        SUBROUTINE COPYCCP4(LUNSPI,LUNMRC,NX,NY,NZ)

        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
 
        COMMON /IOERR/  IERR       ! LEGACY REDLIN ERROR FLAG

        REAL                    :: BUFIN
        COMMON /IOBUF/  BUFIN(NBUFSIZ)

        INTEGER                 :: LUNSPI,LUNMRC, NX,NY,NZ

        REAL,       ALLOCATABLE :: STREAMBUF(:)
        INTEGER *1, ALLOCATABLE :: I1STREAMBUF(:)
        INTEGER *2, ALLOCATABLE :: I2STREAMBUF(:)
        INTEGER,    ALLOCATABLE :: ILIST(:)
        REAL                    :: BUF(NBUFSIZ),FIXLENBUF(256)
        INTEGER *1              :: I1BUF(1024)
        COMMON                     BUF,FIXLENBUF,I1BUF

        CHARACTER(LEN=MAXNAM)   :: MRCFILE,FILPAT,FILOUT
	CHARACTER(LEN=8)        :: ANS
	CHARACTER(LEN=80)       :: PROMPT
        LOGICAL                 :: FLIP,ISSWABT,ISSWAB,BOTLEFT
        INTEGER                 :: IVAL
        INTEGER *1              :: I1VAL
        INTEGER *2              :: I2VAL

        INTEGER *2              :: I2V
        INTEGER *1              :: I1V(2),I1TMP
        EQUIVALENCE                (I2V,I1V)

        REAL    *4              :: R4VALIN,R4VALOUT
        INTEGER *1              :: I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE                (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)

	CHARACTER(LEN=1)        :: NULL = CHAR(0)
        INTEGER                 :: IERR,LENOPENB,LENOPENF,IRTFLG,MODE
        INTEGER                 :: NSYMBT,MACHST,NE,MAXIM,IOFFSET 
        INTEGER                 :: LENOPEN,NCHAR,IRECMRC,IRECSPI
        INTEGER                 :: IBOTLEF,NOT_USED,IRECINC,ILOCOUT
        INTEGER                 :: IRECIN,ILOCIN,IRECINT
        REAL                    :: RMS,FMINT,FMAXT,FAVT,FSIGT,FN,FNCON
        REAL                    :: UNUSED,SCALE
        INTEGER                 :: IX,IY,IZ,NLET,LOCAT,LOCAST
        INTEGER                 :: I,NSTACKT,ITYPE,NUNUSED,NSTACKOUT
        INTEGER                 :: IMGNUMOUT,NSTACK,IGO,ISTACK,IRECSTK

        INTEGER *8              :: IPOSMRC

        LOGICAL                 :: ASKNAM,FOUROK,WANTSTACK,FOLD
        INTEGER, PARAMETER      :: LUNDOCSEL = 0
        INTEGER, PARAMETER      :: LUNXM     = 0

        integer   :: imax   = -1000000, iymax  = 0, imax2  = 0
        integer   :: ixmax2 = 0, iymax2 = 0
        integer   :: imin   = 100000000, ixmin = 0,iymin = 0, imin2 = 0
        integer   :: ixmin2 = 0, iymin2 = 0

        IERR = 0

C       FIND IF CURRENTLY SWAPPING BYTES
        ISSWABT = ISSWAB(99)

        IF (FCHAR(4:5)  == 'TO')      GOTO 1000


C       COPY FROM MRC TO SPIDER FILE FORMAT --------------- FROM MRC

C       OPEN MRC FILE AS DIRECT ACCESS, UNFORMATTED, RECL=1024 BYTES
        LENOPENB = 1024
        LENOPENF = 1024 / 4
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'O',
     &                       'MRC (CCP4) INPUT',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       READ MRC HEADER 
        CALL REDLIN(LUNMRC,FIXLENBUF,LENOPENF,1)
 
C	PARSE MRC HEADER	
	CALL GETHEDCCP4(FIXLENBUF,NX,NY,NZ,MODE,FMIN,FMAX,
     &                   AV,RMS,NSYMBT,ISSWABT,FLIP,MACHST,IRTFLG)
        IF (IRTFLG == 2) THEN
            CALL ERRT(101,'NOT CURRENT MRC FORMAT, MAY BE PRE 1999 MRC',
     &                NE)
           GOTO 9999
        ENDIF
C       CLOSE MRC FILE
        CLOSE(LUNMRC)

        WANTSTACK = .FALSE. 
        NSTACK    = 0

        IF (NZ > 1) THEN
C          MRC FILE MAY BE VOLUME OR STACK (STUPID FILE FORMAT FOR STACK)
           PROMPT = 
     &      'OUTPUT VOLUME OR TEMPLATE FOR IMAGE STACK (E.G. STK@@*)~'

           CALL FILERD(FILPAT,NLET,NULL,PROMPT,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           LOCAT     = INDEX(FILPAT(1:NLET),'@@')   
           LOCAST    = INDEX(FILPAT(1:NLET),'*')
           WANTSTACK = (LOCAST > LOCAT ) 
           ASKNAM    = .FALSE.    ! ALREADY ASKED OUTPUT FILENAME

           IF (WANTSTACK) THEN
C             OPEN FIRST SPIDER OUTPUT FILE	

              IGO = 1
              CALL RDPRI1S(IGO,NOT_USED,
     &                    'FIRST IMAGE NUMBER IN STACK',IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999

              NSTACK = NZ
              ALLOCATE(ILIST(NSTACK),STAT=IRTFLG)
              IF (IRTFLG > 0) THEN
                 CALL ERRT(46,'COPYCCP4; ILIST',NSTACK)
                 GOTO 9999
              ENDIF

C             MAKE LIST OF STACKED FILE NUMBERS
              DO I = IGO,NSTACK
                 ILIST(I) = I
              ENDDO

              NSTACKT = -NSTACK    ! USE ILIST FOR STACKED IMG NUMBERS
              FOUROK  = .FALSE.    ! NOT FOURIER
              NZ      = 1          ! NOT A VOLUME
              ITYPE   = 1

C             OPEN SPIDER STACK OUTPUT FILE	
              CALL OPFILES(0,LUNSPI,LUNDOCSEL,LUNXM,
     &            ASKNAM,FILOUT,NLET, 'U',
     &            ITYPE,NX,NY,NZ,MAXIM,
     &            FILPAT,
     &            FOUROK, ILIST,NSTACKT, 
     &            NUNUSED,NSTACKOUT, IMGNUMOUT, IRTFLG)
              !write(6,*) 'nstackout, imgnumout:', nstackout, imgnumout 

           ELSE
C             OPEN SPIDER VOLUME OUTPUT FILE	
              ITYPE  = 3
              MAXIM  = 0
              CALL OPFILEC(0,ASKNAM,FILPAT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                 MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0) GOTO 9999
           ENDIF
        ELSE
C          OPEN SPIDER IMAGE OUTPUT FILE	
           ITYPE  = 1
           MAXIM  = 0
           CALL OPFILEC(0,.TRUE.,FILPAT,LUNSPI,'U',ITYPE,NX,NY,NZ,
     &                 MAXIM,'SPIDER IMAGE OUTPUT',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
        ENDIF


C       EXTRACT DATA FROM MRC FILE AFTER HEADER & PUT IN SPIDER FILE
        IOFFSET = 1024 + NSYMBT

        IF (MODE == 0) THEN
           ALLOCATE(I1STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)

        ELSEIF (MODE == 1 .OR. MODE == 6)  THEN
           ALLOCATE(I2STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)

        ELSEIF (MODE == 2 )  THEN
           ALLOCATE(STREAMBUF(NX),STAT=IRTFLG)

        ELSE 
           CALL ERRT(102,'UNSUPPORTED MRC MODE',MODE)
        ENDIF 

        IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'COPYCCP4; **STREAMBUF',NX)
           GOTO 9999
        ENDIF

C       OPEN MRC FILE FOR STREAM ACCESS
        CALL OPSTREAMFILE(.FALSE.,MRCFILE,NULL,LUNMRC,
     &                    'UNFORMATTED','O',' ',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        CALL RDPRMC(ANS,NCHAR,.TRUE.,
     &           'FLIP BYTE ORDERING? (Y/N), INVERT TOP/BOTTOM? (Y/N)',
     &            NULL,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (ANS(1:1) == 'Y') FLIP = .NOT. FLIP

        ! BOTLEFT IS USUAL MRC BOTTOM IN CURRENT FORMAT !!
        BOTLEFT = (NCHAR > 2 .AND. (INDEX(ANS(3:NCHAR),'Y')) > 0) 

        ISTACK  = 1

        DO  ! POSSIBLE LOOP OVER MRC STACK -------------------------
         IRECSPI = 0
         IRECINC = 1
         IRECSTK = (ISTACK-1) * NY

         IF (BOTLEFT) THEN
C           INVERT TOP & BOT OF EACH IMAGE OR EACH IMAGE WITHIN VOLUME
            IRECSPI = NY*NZ + 1    ! NZ HAS BEEN SET = 1 IF STACK
            IRECINC = -1
         ENDIF

         IF (MODE == 0) THEN
C          SIGNED 8 BIT INTEGER CCP4 (MRC) INPUT FILE

           DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY

C               IPOSMRC = IOFFSET + (IREC-1) * NX + 1

                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) I1STREAMBUF

                DO IX = 1,NX
                   IVAL = I1STREAMBUF(IX)
                   IF (IVAL < 0) IVAL = 256 + IVAL
                   STREAMBUF(IX) = IVAL
                ENDDO
  
                !if (irec == 1) then
                !   write(6,*)' ',iposmrc,i1streambuf(1),streambuf(1)
                !endif

                IRECSPI = IRECSPI + IRECINC
                !write(6,*) ' irecspi:',irecspi
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

              ENDDO ! END OF: IY = 1,NY
           ENDDO    ! END OF: IZ = 1,NZ

        ELSEIF (MODE == 1 .OR. MODE == 6) THEN
C         16 BIT INTEGER CCP4 (MRC) INPUT FILE

          FOLD = (MODE == 1)
          !write(6,*) 'Flip & fold:',flip,fold

          DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY

c               IPOSMRC = IOFFSET + (IREC-1) * NX * 2 + 1

                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IPOSMRC * 2
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) I2STREAMBUF

                IF (FLIP .AND. FOLD) THEN
C                  INVERT BYTE ORDER & CONVERT SIGNED INTEGER TO UNSIGNED
                   DO IX = 1,NX
                      I2V           = I2STREAMBUF(IX)
                      I1TMP         = I1V(1)
                      I1V(1)        = I1V(2)
                      I1V(2)        = I1TMP

C                     FOLD CONVERTS SIGNED INTEGER TO UNSIGNED
                      IF (I2V < 0) I2V = 65536 + I2V

                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSEIF (FOLD) THEN
C                  CONVERT SIGNED INTEGER TO UNSIGNED
                   DO IX = 1,NX
                      I2V = I2STREAMBUF(IX)
                      IF (I2V < 0) I2V = 65536 + I2V
                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSEIF (FLIP) THEN
C                  INVERT BYTE ORDER
                   DO IX = 1,NX
                      I2V           = I2STREAMBUF(IX)
                      I1TMP         = I1V(1)
                      I1V(1)        = I1V(2)
                      I1V(2)        = I1TMP
                      STREAMBUF(IX) = I2V
                   ENDDO

                ELSE
C                  NO CONVERSION
                   STREAMBUF = I2STREAMBUF
                ENDIF

#ifdef NEVER
                do ix = 1,nx
                   if (streambuf(ix) < imin) then
                      imin2  = imin
                      ixmin2 = ixmin
                      iymin2 = iymin
                      imin   = streambuf(ix)
                      ixmin  = ix
                      iymin  = iy
                   endif
                   if (streambuf(ix) > imax) then
                      imax2  = imax
                      ixmax2 = ixmax
                      iymax2 = iymax
                      imax   = streambuf(ix)
                      ixmax  = ix
                      iymax  = iy
                   endif
                enddo
#endif

C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

              ENDDO
           ENDDO

#ifdef NEVER
           write(6,*) 'maxs: ',ixmax,iymax,imax
           write(6,*) 'maxs2:',ixmax2,iymax2,imax2
           write(6,*) 'mins: ',ixmin,iymin,imin
           write(6,*) 'mins2:',ixmin2,iymin2,imin2
#endif

        ELSEIF (MODE == 2) THEN
C          32 BIT FOATING POINT CCP4 MRC INPUT FILE

           DO IZ = 1,NZ
             DO IY = 1,NY
                IREC    = IRECSTK + (IZ  -1) * NY + IY
c               IPOSMRC = IOFFSET + (IREC-1) * NX * 4 + 1
                      
                IPOSMRC = (IREC-1)    ! KLUDGE FOR INTEGER *8 PRESERVE
                IPOSMRC = IPOSMRC * NX
                IPOSMRC = IPOSMRC * 4
                IPOSMRC = IOFFSET + IPOSMRC + 1

                READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) STREAMBUF
                !if (irec ==1) write(6,*) ' Val:',iposmrc, streambuf(1)
                !write(6,*) ' irec,iposmrc:',irec,iposmrc

                IF (FLIP) THEN
C                  INVERT BYTE ORDER
                   DO IX = 1,NX
                      R4VALIN       = STREAMBUF(IX)
                      I1VALOUT(1)   = I1VALIN(4)
                      I1VALOUT(2)   = I1VALIN(3)
                      I1VALOUT(3)   = I1VALIN(2)
                      I1VALOUT(4)   = I1VALIN(1)
                      STREAMBUF(IX) = R4VALOUT
                   ENDDO
                ENDIF

C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

              ENDDO
           ENDDO

        ELSE
           CALL ERRT(102,'CAN NOT COPY MRC MODE',MODE)
        ENDIF

        IF (.NOT. WANTSTACK) EXIT    ! FINISHED IF NOT A MRC STACK

C       OPEN NEXT STACKED OUTPUT FILE 
        CALL NEXTFILE(ISTACK, ILIST, 
     &                FOUROK,LUNXM,
     &                NSTACK,MAXIM,   
     &                LUNSPI,0,
     &                FILPAT,'N',
     &                IMGNUMOUT, IRTFLG) 

        IF (ISTACK > NSTACK) EXIT    ! FINISHED 
        IF (IRTFLG == -99) THEN
           CALL ERRT(102,'INSUFFICIENT OUTPUT FILE NAMES',NSTACK)
           EXIT         
        ELSEIF (IRTFLG .NE. 0) THEN
           EXIT                      ! ERROR
        ENDIF

       ENDDO   ! END OF STACK LOOP --------------------------

       GOTO 9999

	



C      COPY FROM SPIDER TO MRC FILE FORMAT ----------------- TO MRC

1000   CONTINUE

C	OPEN NEW MRC FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
        LENOPENB = 1024
        LENOPENF = LENOPENB / 4
        CALL OPAUXFILE(.TRUE.,MRCFILE,DATEXC,LUNMRC,LENOPENB,'U',
     &                 'MRC OUTPUT',.TRUE.,IRTFLG)

        IVAL    = 8
        IBOTLEF = 0
        CALL RDPRI2S(IVAL,IBOTLEF,NOT_USED,
     &       'MRC DATA LENGTH (8/32 BITS), FLIP TOP/BOTTOM =1 (0/1)',
     &        IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        MODE = 2
        IF (IVAL == 8) MODE = 0
        BOTLEFT = (IBOTLEF > 0)   ! USUAL MRC BOTTOM!!

C	CREATE A NEW HEADER FOR THE CCP4 FILE
        FMINT = FMIN
        FMAXT = FMAX
        FAVT  = AV
        FSIGT = SIG

        IF (MODE == 0) THEN
           FN    = (255.0 - 0.0) / (FMAXT - FMINT)
           FNCON = 0.0 - FN * FMINT

           FMINT = 0.0
           FMAXT = 255.0
           I2VAL = FMINT * FN + FNCON
           FAVT  = I2VAL
C          FSIGT IS NOT RIGHT!!!!
           FSIGT = -1.0
        ENDIF

C       TRY TO GET SCALE VALUE (MAY NOT BE USED)
        CALL GETLAB(LUNSPI,NX,UNUSED,21,1,SCALE,IRTFLG)

C	CREATE HEADER. (NOTE: FMIN, FMAX, AV ARE SAME AS SPIDER IMAGE)
        CALL SETHEDCCP4(FIXLENBUF, NX, NY, NZ,
     &            FMINT,FMAXT,FAVT,FSIGT,SCALE,MODE,ISSWABT,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

C	WRITE HEADER OF 1024 BYTES (256 FLOATS) TO MRC FILE
        CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,1) 

C       SET STARTING RECORD FOR MRC DATA
        IRECMRC = 1   !SKIPS ONE HEADER RECORD
        ILOCOUT = 0

        IF (MODE == 2) THEN
C          FLOATING POINT OUTPUT

           DO  IRECIN = 1,NY * NZ

C             READ EACH ROW OF SPIDER INPUT FILE 
              IF (BOTLEFT) THEN
                 IRECINT = (NY * NZ) - IRECIN + 1  
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECINT)
              ELSE
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
              ENDIF

C             PUT ROW OUT TO MRC FILE
              DO ILOCIN=1,NX
                ILOCOUT            = ILOCOUT + 1
                FIXLENBUF(ILOCOUT) = BUFIN(ILOCIN)

                IF (ILOCOUT >= LENOPENF) THEN
C                  PUT OUT COMPLETED RECORD

                   IRECMRC = IRECMRC + 1

                   CALL WRTLIN(LUNMRC,FIXLENBUF,LENOPENF,IRECMRC)
                   ILOCOUT = 0
                ENDIF
              ENDDO
           ENDDO

           IF (ILOCOUT > 0) THEN
C             PUT OUT REMAINING RECORD
              IRECMRC = IRECMRC + 1
              CALL WRTLIN(LUNMRC,FIXLENBUF,ILOCOUT,IRECMRC)
           ENDIF
 	
        ELSEIF (MODE == 0) THEN
C          COPY FROM SPIDER TO MRC 8 BIT FILE FORMAT 

           DO IRECIN = 1,NY * NZ
C             READ EACH ROW OF SPIDER INPUT FILE 
              IF (BOTLEFT) THEN
                 IRECINT = (NY * NZ) - IRECIN + 1  
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECINT)
              ELSE
                 CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
              ENDIF

C             PUT ROW OUT TO CCP4 FILE
              DO ILOCIN=1,NX
                ILOCOUT        = ILOCOUT + 1
                I2VAL          = BUFIN(ILOCIN) * FN + FNCON
                I1BUF(ILOCOUT) = I2VAL

                IF (ILOCOUT >= LENOPENB) THEN
C                  PUT OUT COMPLETED RECORD
                   IRECMRC = IRECMRC + 1

                   CALL WRTLIN8(LUNMRC,I1BUF,LENOPENB,IRECMRC)
                   IF (IERR .NE. 0) THEN
                      CALL ERRT(102,'WRITING RECORD',IRECMRC)
                      GOTO 9999
                   ENDIF
                   ILOCOUT = 0
                ENDIF
              ENDDO
           ENDDO

           IF (ILOCOUT > 0) THEN
C             PUT OUT REMAINING RECORD
              IRECMRC = IRECMRC + 1
              CALL WRTLIN8(LUNMRC,I1BUF,ILOCOUT,IRECMRC)
          ENDIF

        ELSE
           CALL ERRT(102,'CAN NOT CREATE MRC MODE',MODE)
           GOTO 9999
        ENDIF

        IF (IERR .NE. 0) THEN
           CALL ERRT(102,'WRITING RECORD',IRECIN)
           GOTO 9999
        ENDIF

	
9999    CLOSE(LUNSPI)
        CLOSE(LUNMRC)
        IF(ALLOCATED(STREAMBUF)) DEALLOCATE(STREAMBUF)

        END


C       -------------- ISSWAB ----------------------------------------

        LOGICAL FUNCTION ISSWAB(LUN)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
 
        INTEGER,DIMENSION(3) ::  IVAL
        CHARACTER(LEN=12) ::     CVAL,CVALIN
        EQUIVALENCE(IVAL,CVAL)

        CHARACTER(LEN=MAXNAM) :: FILNAM
        LOGICAL ::               VERBOSE_SAVE

        CHARACTER(LEN=1) ::      NULL = CHAR(0)

C       DO NOT ECHO FILE OPENING
        VERBOSE_SAVE = VERBOSE
        VERBOSE      = .FALSE.

        FILNAM = 'TMP_JNK_SCRATCH'
        CALL OPAUXFILE(.FALSE.,FILNAM,NULL,LUN,12,'U',' ',.TRUE.,IRTFLG)

        CVAL(1:1)   = CHAR(0)
        CVAL(2:2)   = CHAR(0)
        CVAL(3:3)   = CHAR(0)
        CVAL(4:4)   = CHAR(4)
        CVAL(5:5)   = CHAR(48)
        CVAL(6:6)   = CHAR(48)
        CVAL(7:7)   = CHAR(49)
        CVAL(8:8)   = CHAR(50)
        CVAL(9:9)   = CHAR(0)
        CVAL(10:10) = CHAR(0)
        CVAL(11:11) = CHAR(0)
        CVAL(12:12) = CHAR(4)

        CALL WRTLIN(LUN,IVAL,3,1)
        CLOSE(LUN)

        CALL OPAUXFILE(.FALSE.,FILNAM,NULL,LUN,0,'O',' ',.TRUE.,IRTFLG)

        READ(LUN,*) CVALIN

        CLOSE(LUN,STATUS='DELETE')

c       WRITE(NOUT,*) 'CVALIN: ',CVALIN,' == ',CVAL
 
        ISSWAB   = (CVALIN(8:8) .NE. CVAL(8:8))

c        IF (ISSWAB) THEN
c           WRITE(NOUT,*) 'NON-NATIVE BYTE ORDER '
c        ELSE
c           WRITE(NOUT,*) 'NATIVE BYTE ORDER'
c        ENDIF

        VERBOSE = VERBOSE_SAVE

        END

C       --------------  OPSTREAMFILE ------------------------------

a40 1

d44 1
a44 2

        
@


1.29
log
@==,  stack support, speed bug fixed, ..
@
text
@d16 1
d21 1
a21 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d100 1
a100 1
        INTEGER                 :: IPOSMRC,IX,IY,IZ,NLET,LOCAT,LOCAST
d104 2
d269 6
a274 1
                IPOSMRC = IOFFSET + (IREC-1) * NX + 1
d304 7
a310 1
                IPOSMRC = IOFFSET + (IREC-1) * NX * 2 + 1
d392 6
a397 1
                IPOSMRC = IOFFSET + (IREC-1) * NX * 4 + 1
@


1.28
log
@*** empty log message ***
@
text
@d4 12
a15 11
C COPYCCP4                 MODIFIED FROM COPYMRC FEB 02 ArDean Leith         
C                          ISSWAB ADDED          JUL 02 ArDean Leith
C                          FLIP QUESTION         MAR 03 ArDean Leith
C                          BAD IRECMRC4 & FLIP   SEP 03 ArDean Leith
C                          SCALING               JAN 05 ArDean Leith
C                          I*8                   SEP 08 ArDean Leith
C                          NPIX8                 DEC 08 ArDean Leith
C                          BOTLEFT OPTION        MAY 12 ArDean Leith
C                          STREAM IO             FEB 13 ArDean Leith
C                          VOL BUG               JUN 13 ArDean Leith
C                          VOL BUG FIXED         JUL 13 ArDean Leith
d20 1
a20 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d43 6
a48 4
C NOTES: DATA IN MRC FILE:
C	 MODE   0 : IMAGE STORED AS INTEGER*1  
C               1 : IMAGE STORED AS INTEGER*2
C               2 : IMAGE STORED AS REALS
d60 1
a60 1
        COMMON /IOERR/  IERR
d65 1
a65 1
        INTEGER                 :: LUNSPI,LUNMRC,NX,NY,NZ
d67 1
a67 1
        REAL, ALLOCATABLE       :: STREAMBUF(:)
d70 1
d75 3
a77 4
        INTEGER *8              :: NPIX8,NEED8,IGOT8,NT8

        CHARACTER(LEN=MAXNAM)   :: FILNAM,MRCFILE
	CHARACTER(LEN=80)       :: ANS
d87 1
a87 1
        REAL *4                 :: R4VALIN,R4VALOUT
d93 1
a93 1
        INTEGER                 :: NSYMBT,MACHST,NE,MAXIM,IOFFSET,MODEA 
d95 1
a95 2
        INTEGER                 :: ILOCCCCP,NVAL,IBOTLEF,NOT_USED 
        INTEGER                 :: ILOCSPI,ILOCMRC,IRECINC,ILOCOUT
d99 13
a111 2
        INTEGER                 :: IPOSMRC,IX,IY,IZ
    
d143 67
a209 7
C       OPEN SPIDER OUTPUT FILE	
        IFORM  = 1
        IF (NZ > 1) IFORM = 3
        MAXIM  = 0
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNSPI,'U',IFORM,NX,NY,NZ,
     &             MAXIM,'SPIDER OUTPUT',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
d214 2
a215 3
C       NPIX8 = TOTAL NUMBER OF PIXELS IN MRC FILE
        NPIX8 = NX * NY     ! DO NOT SIMPLIFY, COMPILER WRONG
        NPIX8 = NPIX8 * NZ
d217 2
a218 2
C       CHANGE MODE: 0,1,2 TO MODEA: 8,16,32
        MODEA = (2**(MODE + 1)) * 4
d220 1
a220 5
        IF (MODEA == 8) THEN
           ALLOCATE(I1STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)
        ELSEIF (MODEA == 16) THEN
           ALLOCATE(I2STREAMBUF(NX), STREAMBUF(NX),STAT=IRTFLG)
        ELSE
d222 3
d226 1
d234 1
a234 2
     &                    'UNFORMATTED','O', ' ',.TRUE.,IRTFLG)

d238 1
a238 1
     &           'FLIP BYTE ORDERING? (Y/N), INVERT TOP/BOTTEM? (Y/N)',
d244 1
a244 1
        ! USUAL MRC BOTTEM!!
d247 1
a247 2
c        write(6,*)' modea,lenop,NPIX8:',
c     &              modea,lenopen,NPIX8,NX,NY,NZ
d249 1
d252 1
d256 1
a256 1
            IRECSPI = NY*NZ + 1
d260 2
a261 2
        IF (MODEA == 8) THEN
C          8 BIT INTEGER CCP4 (MRC) INPUT FILE
d265 1
a265 1
                IREC    = (IZ -1) * NY + IY
d273 1
a273 1
                   STREAMBUF = IVAL
d284 5
a288 2
              ENDDO
           ENDDO
d290 2
a291 2
        ELSEIF (MODEA == 16) THEN
C          16 BIT INTEGER CCP4 (MRC) INPUT FILE
d295 1
a295 1
                IREC    = (IZ -1) * NY + IY
a298 2
                !if (irec ==1) write(6,*)' Val:',iposmrc,i2streambuf(1)
                !write(6,*) ' irec,iposmrc:',irec,iposmrc
d300 23
a322 1
                IF (FLIP) THEN
d330 5
a334 1
                    ENDDO
d337 20
a356 5
                DO IX = 1,NX
                   IVAL = I2STREAMBUF(IX)
                   IF (IVAL < 0) IVAL = 256 + IVAL
                   STREAMBUF = IVAL
                ENDDO
d365 8
a372 1
        ELSEIF (MODEA == 32) THEN
d375 1
a375 1
          DO IZ = 1,NZ
d377 1
a377 1
                IREC    = (IZ -1) * NY + IY
d407 21
a427 1
        GOTO 9999
d433 1
a433 1
C       COPY FROM SPIDER TO MRC FILE FORMAT ----------------- TO MRC
d435 1
a435 1
1000    CONTINUE
d446 1
a446 1
     &       'MRC DATA LENGTH (8/32 BITS), FLIP TOP/BOTTEM =1 (0/1)',
d451 1
a451 1
        BOTLEFT = (IBOTLEF > 0)   ! USUAL MRC BOTTEM!!
a665 4
#ifdef USE_MPI
        INCLUDE 'mpif.h'
#endif

d726 2
a727 10
           CALL MPI_BCAST(EX, 1, MPI_LOGICAL, 0, ICOMM, MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST EX'
              STOP
           ENDIF 
           CALL MPI_BCAST(IRTFLGT, 1, MPI_INTEGER, 0, ICOMM, MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST IRTFLGT'
              STOP
           ENDIF 
d762 1
a762 5
        CALL MPI_BCAST(IRTFLGT, 1, MPI_INTEGER, 0, ICOMM, MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) 'OPSTREAMFILE: FAILED TO BCAST IRTFLGT'
           STOP
        ENDIF 
d764 1
@


1.27
log
@*** empty log message ***
@
text
@d167 2
a168 2
     &             'FLIP BYTE ORDERING? (Y/N), FLIP TOP/BOTTEM? (Y/N)',
     &              NULL,IRTFLG)
@


1.26
log
@invert bug fixed for all known cases
@
text
@d167 1
a167 1
     &             'FLIP BYTE ORDERING? (Y/N), FLIP TOP/BOTTEM (Y/N)',
@


1.25
log
@IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 1
@
text
@d13 2
d40 1
d42 1
a42 1
C NOTES: DATA IN CCP4 FILE:
d59 1
a59 1
        REAL                  :: BUFIN
d62 1
a62 1
        INTEGER               :: LUNSPI,LUNMRC,NX,NY,NZ
d64 34
a97 26
        REAL, ALLOCATABLE     :: STREAMBUF(:)
        REAL                  :: BUF(NBUFSIZ),FIXLENBUF(256)
        INTEGER * 1           :: I1BUF(1024)
        COMMON                   BUF,FIXLENBUF,I1BUF

        INTEGER * 8           :: NPIX8,NEED8,IGOT8,NT8

        CHARACTER(LEN=MAXNAM) :: FILNAM,MRCFILE
	CHARACTER(LEN=80)     :: ANS
        LOGICAL               :: FLIP,ISSWABT,ISSWAB,BOTLEFT
        INTEGER * 2           :: I2VAL

        REAL *4               :: R4VALIN,R4VALOUT
        INTEGER *1            :: I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE              (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
 
	CHARACTER(LEN=1)      :: NULL = CHAR(0)
        INTEGER               :: IERR,LENOPENB,LENOPENF,IRTFLG,MODE
        INTEGER               :: NSYMBT,MACHST,NE,MAXIM,IOFFSET,MODEA 
        INTEGER               :: LENOPEN,NCHAR,IRECMRC,IRECSPI
        INTEGER               :: ILOCCCCP,NVAL,IVAL,IBOTLEF,NOT_USED 
        INTEGER               :: ILOCSPI,ILOCMRC,IRECINC,ILOCOUT
        INTEGER               :: IRECIN,ILOCIN,IRECINT
        REAL                  :: RMS,FMINT,FMAXT,FAVT,FSIGT,FN,FNCON
        REAL                  :: UNUSED,SCALE
        INTEGER               :: IPOSMRC,IX
d107 1
a107 1
C       COPY FROM MRC TO SPIDER FILE FORMAT --------------- FROM CCP4
d127 2
d148 4
a151 8
C       CLOSE MRC FILE
        CLOSE(LUNMRC)

        IF (MODEA == 8 .OR. MODEA == 16) THEN
C          REOPEN MRC FILE AS NX*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NX * (MODEA / 8)
           CALL OPAUXFILE(.FALSE.,MRCFILE,NULL,LUNMRC,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
d154 5
a158 4
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'COPYCCP4; STREAMBUF',NX)
              GOTO 9999
           ENDIF
d160 3
a162 4
C          OPEN FOR STREAM ACCESS
           CALL OPSTREAMFILE(.FALSE.,MRCFILE,NULL,LUNMRC,
     &                       'UNFORMATTED','O', ' ',.TRUE.,IRTFLG)
        ENDIF
d166 1
a166 1
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,
d179 9
d189 1
a189 3
C          8 BIT INTEGER CCP4 INPUT FILE
           CALL RAW8TOSPI(LUNMRC,LUNSPI,NX,NPIX8,IOFFSET,.TRUE.,
     &                   LENOPEN,BUF,IRTFLG)
d191 4
a194 2
        ELSEIF (MODEA == 16) THEN
C          16 BIT INTEGER MRC FILE (HEADER LENGTH DIVISABLE BY TWO)
d196 1
a196 4
           IF (IRTFLG .NE. 0) GOTO 9999
           FLIP = .NOT. FLIP
           CALL RAW16TOSPI(LUNMRC,LUNSPI,NX,NPIX8,IOFFSET,FLIP,
     &                   .FALSE.,LENOPEN,BUF,IRTFLG)
d198 13
a210 2
        ELSEIF (MODEA == 32) THEN
C          32 BIT FOATING POINT MRC INPUT FILE
d212 2
a213 6
          IRECSPI = 0
          IRECINC = 1
          IF (BOTLEFT) THEN
             IRECSPI = NY + 1
             IRECINC = -1
          ENDIF
d215 2
a216 2
          DO IREC = 1,NY*NZ
             IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 1
d218 19
a236 1
            !write(6,*) ' irec,iposmrc:',irec,iposmrc
a237 5
             READ(LUNMRC, POS=IPOSMRC,IOSTAT=IERR) STREAMBUF
             !if (irec ==1) write(6,*) ' Val:',iposmrc, streambuf(1)

             IF (FLIP) THEN
C               INVERT BYTE ORDER
d239 3
a241 6
                   R4VALIN       = STREAMBUF(IX)
                   I1VALOUT(1)   = I1VALIN(4)
                   I1VALOUT(2)   = I1VALIN(3)
                   I1VALOUT(3)   = I1VALIN(2)
                   I1VALOUT(4)   = I1VALIN(1)
                   STREAMBUF(IX) = R4VALOUT
a242 1
             ENDIF
d244 3
a246 7
C            PUT OUT COMPLETED RECORD
             IRECSPI = IRECSPI + IRECINC
             CALL WRTLIN(LUNSPI,STREAMBUF,NX,IRECSPI)

c            itmp = mod(irecspi,NY)
c            if (itmp == 0) write(6,999) irecspi,buf(NX)
999          format(i10,' ; ',1pg13.7)
d248 33
a280 2
          ENDDO
          !write(6,*) ' irec,iposmrc:',irec,iposmrc
d381 1
a381 1
C          COPY FROM SPIDER TO MRC  8 BIT FILE FORMAT 
d383 1
a383 1
           DO  IRECIN = 1,NY * NZ
d653 1
a653 1
        RETURN
a654 1

@


1.24
log
@mpi header needed
@
text
@d194 1
a194 1
             IPOSMRC = IOFFSET + (IREC-1)*NX*4 + 0
@


1.23
log
@OPSTREAMFILE used for 32 bit mrc --> spider conversion
@
text
@d467 4
@


1.22
log
@bot left option added
@
text
@d12 1
d17 1
a17 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d61 1
d86 1
a86 1

d93 1
a93 1
        IF (FCHAR(4:5)  .EQ. 'TO')      GOTO 1000
d138 17
a154 4
C       REOPEN MRC FILE AS NX*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
        LENOPEN = NX * (MODEA / 8)
        CALL OPAUXFILE(.FALSE.,MRCFILE,NULL,LUNMRC,LENOPEN,'O',
     &                ' ',.TRUE.,IRTFLG)
a185 6
          IOFFSET = IOFFSET / 4
          IRECMRC = 0
          ILOCSPI = 0
          ILOCMRC = NX + 1
          IGOT8   = 0

a191 6
    
C         NEED8 IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
          NEED8 = NPIX8 + IOFFSET

          DO WHILE (IGOT8 < NEED8)
             ILOCMRC = ILOCMRC + 1
d193 2
a194 7
             IF (ILOCMRC > NX) THEN
C               NEED TO READ NEW RECORD FROM INPUT
                NVAL = NX
                NT8  = NEED8 - IGOT8
                IF (NT8 .LT. NX) NVAL = NT8
                IRECMRC = IRECMRC + 1
                CALL REDLIN(LUNMRC,FIXLENBUF,NVAL,IRECMRC)
d196 1
a196 2
c               if(IRECMRC .le. 10)write(6,998)IRECMRC,nval,FIXLENBUF(nval)
998             format(' irec,nval,: ',2i10,' ; ',1pg13.7)
d198 2
a199 5
                ILOCMRC = 1
             ENDIF

C            IGOT8 POINTS TO CURRENT WORD IN INPUT FILE
             IGOT8 = IGOT8 + 1
d201 10
a210 15
             IF (IGOT8 > IOFFSET) THEN
C               WANT THIS VALUE FOR AN OUTPUT PIXEL
                ILOCSPI = ILOCSPI + 1
                IF (FLIP) THEN
C                  INVERT BYTE ORDER
                   R4VALIN      = FIXLENBUF(ILOCMRC)
                   I1VALOUT(1)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(2)
                   I1VALOUT(4)  = I1VALIN(1)
                   BUF(ILOCSPI) = R4VALOUT
                ELSE
C                  NO FLIP
                   BUF(ILOCSPI) = FIXLENBUF(ILOCMRC)
                ENDIF
d213 7
a219 9
             IF (ILOCSPI >= NX) THEN
C               PUT OUT COMPLETED RECORD
                IRECSPI = IRECSPI + IRECINC
                CALL WRTLIN(LUNSPI,BUF,NX,IRECSPI)
                ILOCSPI = 0

c          itmp = mod(irecspi,NY)
c          if (itmp .eq. 0) write(6,999) irecspi,buf(NX)
999       format(i10,' ; ',1pg13.7)
a220 1
             ENDIF
d222 1
d373 1
d437 66
d504 3
d508 86
@


1.21
log
@nx, mrc not ccp4 labels,  prompts updated
@
text
@d7 1
a7 1
C                          BAD IRECCCP4 & FLIP   SEP 03 ArDean Leith
d11 1
d16 1
a16 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d34 1
a34 1
C COPYCCP4(LUNSPI,LUNCCP4,NX,NY,NZ)
d46 3
a48 1
        SUBROUTINE COPYCCP4(LUNSPI,LUNCCP4,NX,NY,NZ)
d54 2
d58 6
a64 2
        INTEGER * 1           :: I1BUF
        COMMON                BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d66 3
a68 3
        CHARACTER(LEN=MAXNAM) :: FILNAM,CCP4FILE
	CHARACTER(LEN=1)      :: NULL,ANS
        LOGICAL               :: FLIP,ISSWABT,ISSWAB
d75 11
a85 1
        NULL = CHAR(0)
d94 1
a94 1
C       COPY FROM CCP4 TO SPIDER FILE FORMAT --------------- FROM CCP4
d96 1
a96 1
C       OPEN CCP4 FILE AS DIRECT ACCESS, UNFORMATTED, RECL=1024 BYTES
d99 1
a99 1
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENOPENB,'O',
d104 1
a104 1
        CALL REDLIN(LUNCCP4,FIXLENBUF,LENOPENF,1)
d110 1
a110 2
C           NOT CURRENT CCP4 FORMAT
            CALL ERRT(101,'NOT CURRENT MRC FORMAT, TRY OLD MRC FORMAT',
d117 1
a117 1
        IF (NZ .GT. 1) IFORM = 3
d134 1
a134 1
        CLOSE(LUNCCP4)
d138 1
a138 1
        CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
d142 9
a150 3
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,'FLIP BYTE ORDERING? (Y/N)',
     &               NULL,IRT)
        IF (ANS .EQ. 'Y') FLIP = .NOT. FLIP
d157 1
a157 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NX,NPIX8,IOFFSET,.TRUE.,
d161 1
a161 1
C          16 BIT INTEGER CCP4 FILE (HEADER LENGTH DIVISABLE BY TWO)
d165 1
a165 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NX,NPIX8,IOFFSET,FLIP,
d169 1
a169 1
C          32 BIT FOATING POINT CCP4 INPUT FILE
d172 5
a176 1
          IRECCCP = 0
d178 6
a183 4
          ILOCSPI = 0
          ILOCCCP = NX + 1
          IGOT8    = 0
          
d188 3
a190 2
             ILOCCCP = ILOCCCP + 1
             IF (ILOCCCP .GT. NX) THEN
d195 2
a196 2
                IRECCCP = IRECCCP + 1
                CALL REDLIN(LUNCCP4,FIXLENBUF,NVAL,IRECCCP)
d198 1
a198 1
c            if(IRECCCP .le. 10)write(6,998)IRECCCP,nval,FIXLENBUF(nval)
d201 1
a201 1
                ILOCCCP = 1
d207 1
a207 1
             IF (IGOT8 .GT. IOFFSET) THEN
d212 1
a212 1
                   R4VALIN      = FIXLENBUF(ILOCCCP)
d220 1
a220 1
                   BUF(ILOCSPI) = FIXLENBUF(ILOCCCP)
d224 1
a224 1
             IF (ILOCSPI .GE. NX) THEN
d226 1
a226 1
                IRECSPI = IRECSPI + 1
d238 1
a238 1
           CALL ERRT(102,'CAN NOT COPY CCP4 MODE',MODE)
d245 2
d254 1
a254 1
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENOPENB,'U',
d257 5
a261 3
        IVAL = 8
        CALL RDPRI1S(IVAL,NOT_USED,
     &       'ENTER DATA LENGTH FOR MRC FILE (8 OR 32 BITS)',IRTFLG)
d264 2
a265 1
        IF (IVAL .EQ. 8) MODE = 0
d273 1
a273 1
        IF (MODE .EQ. 0) THEN
d293 2
a294 2
C	WRITE HEADER OF 1024 BYTES (256 FLOATS) TO CCP4 FILE
        CALL WRTLIN(LUNCCP4,FIXLENBUF,LENOPENF,1) 
d297 5
a301 2
        IRECOUT         = 1
        ILOCOUT         = 0
a302 1
        IF (MODE .EQ. 2) THEN
a303 2
C             READ EACH ROW OF SPIDER INPUT FILE   
              CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
d305 9
a313 1
C             PUT ROW OUT TO CCP4 FILE
d318 1
a318 1
                IF (ILOCOUT .GE. LENOPENF) THEN
d320 4
a323 2
                   IRECOUT = IRECOUT + 1
                   CALL WRTLIN(LUNCCP4,FIXLENBUF,LENOPENF,IRECOUT)
d329 1
a329 1
           IF (ILOCOUT .GT. 0) THEN
d331 2
a332 2
              IRECOUT = IRECOUT + 1
              CALL WRTLIN(LUNCCP4,FIXLENBUF,ILOCOUT,IRECOUT)
d335 2
a336 2
        ELSEIF (MODE .EQ. 0) THEN
C          COPY FROM SPIDER TO CCP4  8 BIT FILE FORMAT 
d339 7
a345 2
C             READ EACH ROW OF SPIDER INPUT FILE   
              CALL REDLIN(LUNSPI,BUFIN,NX,IRECIN)
d353 1
a353 1
                IF (ILOCOUT .GE. LENOPENB) THEN
d355 3
a357 2
                   IRECOUT = IRECOUT + 1
                   CALL WRTLIN8(LUNCCP4,I1BUF,LENOPENB,IRECOUT)
d359 1
a359 1
                      CALL ERRT(102,'WRITING RECORD',IRECIN)
d367 1
a367 1
           IF (ILOCOUT .GT. 0) THEN
d369 2
a370 2
              IRECOUT = IRECOUT + 1
              CALL WRTLIN8(LUNCCP4,I1BUF,ILOCOUT,IRECOUT)
d374 1
a374 1
           CALL ERRT(102,'CAN NOT CREATE CCP4 MODE',MODE)
d382 1
a382 1
 
d385 1
a385 1
        CLOSE(LUNCCP4)
a386 1
        RETURN
a400 1
        CHARACTER(LEN=1) ::      NULL
d404 1
a404 1
        NULL = CHAR(0)
d408 1
a408 1
        VERBOSE = .FALSE.
@


1.20
log
@GPL_2010
@
text
@d33 1
a33 1
C COPYCCP4(LUNSPI,LUNCCP4,NSAM,NROW,NSLICE)
d45 1
a45 1
        SUBROUTINE COPYCCP4(LUNSPI,LUNCCP4,NSAM,NROW,NSLICE)
d81 1
a81 1
     &                       'CCP4 INPUT',.TRUE.,IRTFLG)
d84 1
a84 1
C       READ CCP4 HEADER 
d87 2
a88 2
C	PARSE CCP4 HEADER	
	CALL GETHEDCCP4(FIXLENBUF,NSAM,NROW,NSLICE,MODE,FMIN,FMAX,
d90 1
a90 1
        IF (IRTFLG .EQ. 2) THEN
d92 2
a93 1
            CALL ERRT(101,'NOT CCP4 FORMAT, TRY OLD MRC FORMAT',NE)
d99 1
a99 1
        IF (NSLICE .GT. 1) IFORM = 3
d101 1
a101 1
        CALL OPFILEC(0,.TRUE.,FILNAM,LUNSPI,'U',IFORM,NSAM,NROW,NSLICE,
d105 1
a105 1
C       EXTRACT DATA FROM CCP4 FILE AFTER HEADER & PUT IN SPIDER FILE
d108 3
a110 3
C       NPIX8 = TOTAL NUMBER OF PIXELS IN CCP4 FILE
        NPIX8 = NSAM * NROW     ! DO NOT SIMPLIFY, COMPILER WRONG
        NPIX8 = NPIX8 * NSLICE
d115 1
a115 1
C       CLOSE CCP4 FILE
d118 2
a119 2
C       REOPEN CCP4 FILE AS NSAM*MODEA/8 BYTE, DIRECT ACCESS, UNFORMATTED
        LENOPEN = NSAM * (MODEA / 8)
d129 1
a129 1
c     &              modea,lenopen,NPIX8,nsam,nrow,nslice
d131 1
a131 1
        IF (MODEA .EQ. 8) THEN
d133 1
a133 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX8,IOFFSET,.TRUE.,
d136 1
a136 1
        ELSEIF (MODEA .EQ. 16) THEN
d141 1
a141 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX8,IOFFSET,FLIP,
d144 1
a144 1
        ELSEIF (MODEA .EQ. 32) THEN
d151 1
a151 1
          ILOCCCP = NSAM + 1
d157 1
a157 1
          DO WHILE (IGOT8 .LT. NEED8)
d159 1
a159 1
             IF (ILOCCCP .GT. NSAM) THEN
d161 1
a161 1
                NVAL = NSAM
d163 1
a163 1
                IF (NT8 .LT. NSAM) NVAL = NT8
d193 1
a193 1
             IF (ILOCSPI .GE. NSAM) THEN
d196 1
a196 1
                CALL WRTLIN(LUNSPI,BUF,NSAM,IRECSPI)
d199 2
a200 2
c          itmp = mod(irecspi,nrow)
c          if (itmp .eq. 0) write(6,999) irecspi,buf(nsam)
d214 1
a214 1
C       COPY FROM SPIDER TO CCP4 FILE FORMAT ----------------- TO CCP4
d218 1
a218 1
C	OPEN NEW CCP4 FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
d222 1
a222 1
     &                 'CCP4 OUTPUT',.TRUE.,IRTFLG)
d226 1
a226 1
     &       'ENTER DATA LENGTH FOR CCP4 FILE (8 OR 32 BITS)',IRTFLG)
d250 1
a250 1
        CALL GETLAB(LUNSPI,NSAM,UNUSED,21,1,SCALE,IRTFLG)
d253 1
a253 1
        CALL SETHEDCCP4(FIXLENBUF, NSAM, NROW, NSLICE,
d260 1
a260 1
C       SET STARTING RECORD FOR CCP4 DATA
d265 1
a265 1
           DO  IRECIN = 1,NROW * NSLICE
d267 1
a267 1
              CALL REDLIN(LUNSPI,BUFIN,NSAM,IRECIN)
d270 1
a270 1
              DO ILOCIN=1,NSAM
d292 1
a292 1
           DO  IRECIN = 1,NROW * NSLICE
d294 1
a294 1
              CALL REDLIN(LUNSPI,BUFIN,NSAM,IRECIN)
d297 1
a297 1
              DO ILOCIN=1,NSAM
@


1.19
log
@integer 8
@
text
@a11 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                       *
d13 5
a17 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d19 1
a19 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d24 1
a24 1
C=* This program is distributed in the hope that it will be useful,    *
d26 1
a26 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a27 1
C=*                                                                    *
d29 1
a29 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.18
log
@ngot8 in 32 bit bug
@
text
@d57 1
a57 1
        INTEGER * 8           :: NPIX8,NEED8,IGOT8
d131 2
a132 1
c       write(6,*)' modea,lenopen,NPIX8,nsam:',modea,lenopen,NPIX8,nsam,nrow,nslice
d163 4
a166 2
C               NEED8 TO READ NEW RECORD FROM INPUT
                NVAL    = MIN(NSAM,NEED8-IGOT8)
d169 4
d201 5
@


1.17
log
@npix8 on calls
@
text
@d157 1
a157 3
C         NPIX8 = TOTAL NUMBER OF PIXELS IN CCP4 FILE
          NPIX8 = NSAM * NROW * NSLICE
          NEED8 = NPIX + IOFFSET
@


1.16
log
@npix8 & need8
@
text
@d10 1
a10 1
C
d13 1
a13 1
C=* Copyright (C) 1985-208  Health Research Inc.                       *
d57 1
a57 1
        INTEGER * 8           :: NPIX8,NEED8
d111 3
a113 2
C       NPIX = TOTAL NUMBER OF PIXELS IN CCP4 FILE
        NPIX = NSAM * NROW * NSLICE
d131 2
d135 1
a135 1
           CALL RAW8TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,.TRUE.,
d143 1
a143 1
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,FLIP,
d154 1
a154 1
          IGOT    = 0
d161 1
a161 1
          DO WHILE (IGOT .LT. NEED8)
d165 1
a165 1
                NVAL    = MIN(NSAM,NEED8-IGOT)
d171 2
a172 2
C            IGOT POINTS TO CURRENT WORD IN INPUT FILE
             IGOT = IGOT + 1
d174 1
a174 1
             IF (IGOT .GT. IOFFSET) THEN
a395 2


@


1.15
log
@npix8 & need8
@
text
@d57 3
a59 3
        INTEGER * 8     :: NPIX8,NEED8
        INTEGER * 1     :: I1BUF
        COMMON          :: BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d68 1
a68 1
        EQUIVALENCE           :: (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
@


1.14
log
@scale
@
text
@d9 1
d13 1
a13 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d57 3
a59 2
        INTEGER * 1     I1BUF
        COMMON          BUF(NBUFSIZ),FIXLENBUF(256),I1BUF(1024)
d62 7
a68 7
	CHARACTER(LEN=1) ::      NULL,ANS
        LOGICAL  ::              FLIP,ISSWABT,ISSWAB
        INTEGER * 2              I2VAL

        REAL *4                  R4VALIN,R4VALOUT
        INTEGER *1               I1VALIN(4),I1VALOUT(4)
        EQUIVALENCE              (R4VALIN,I1VALIN),(R4VALOUT,I1VALOUT)
d81 1
a81 1
C       OPEN CCP4 FILE AS DIRECT ACCESS, UNFORMATTED, RECL= 1024 BYTES
d153 4
a156 2
C         NEED IS TOTAL NUMBER OF BYTES TO BE READ INCLUDING HEADER
          NEED = NPIX + IOFFSET
d158 1
a158 1
          DO WHILE (IGOT .LT. NEED)
d161 2
a162 2
C               NEED TO READ NEW RECORD FROM INPUT
                NVAL    = MIN(NSAM,NEED-IGOT)
d329 1
@


1.13
log
@GPL License fixed
@
text
@d8 1
d235 3
d240 1
a240 1
     &            FMINT,FMAXT,FAVT,FSIGT,MODE,ISSWABT,IRTFLG)
@


1.12
log
@flip & offset bugs
@
text
@d10 23
a32 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.11
log
@fixed flip
@
text
@d7 1
d126 2
a127 1
          IRECCCP = 1
d132 1
a132 1

d157 1
a157 1
                   I1VALOUT(3)  = I1VALIN(1)
@


1.10
log
@flip question
@
text
@d153 4
a156 4
                   I1VALOUT(4)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(1)
                   I1VALOUT(1)  = I1VALIN(2)
@


1.9
log
@lunsetluns in opauxfile now
@
text
@a78 4
        CALL  RDPRMC(ANS,NCHAR,.TRUE.,'FLIP BYTE ORDERING? (Y/N)',
     &               NULL,IRT)
        IF (ANS .EQ. 'Y') FLIP = .NOT. FLIP

d104 4
@


1.8
log
@flip on 16
@
text
@d6 2
a7 1
C             
a33 1
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)
a54 2
        LUNARB(LUNCCP4) = LUNCCP4
        LUNSTK(LUNCCP4) = 0
d57 1
d79 4
a307 2
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

a323 1
        LUNARB(LUN) = LUN
@


1.7
log
@opfilec
@
text
@d115 1
@


1.6
log
@*** empty log message ***
@
text
@d84 1
a84 1
        CALL OPFILE(.TRUE.,FILNAM,LUNSPI,'U',IFORM,NSAM,NROW,NSLICE,
@


1.5
log
@*** empty log message ***
@
text
@d42 1
a42 1
        LOGICAL  ::              FLIP,ISSWABT,ISSWAB,REVERSE
d55 2
a58 1

d62 3
a64 2
        LENREC = 1024
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,LENREC,'O',
a66 2
 
        READ(LUNCCP4,REC=1,IOSTAT=IERR) FIXLENBUF
d68 2
a69 5
        IF (IERR .NE. 0) THEN
           WRITE(NOUT,*) '*** ERROR: (',IERR,') READING CCP4 HEADER'
           CALL ERRT(100,'COPYCCP4',NE)
           GOTO 9999
        ENDIF
d71 1
a71 1
C	PARSE THE CCP4 HEADER	
d94 3
a99 3
C       CHANGE MODE: 0,1,2 TO MODEA: 8,16,32
        MODEA = (2**(MODE + 1)) * 4

d113 2
d119 40
a158 5
C          32 BIT FOATING POINT IMAGE
           NFLIP = 0
           IF (FLIP) NFLIP = 2
           CALL RAW32TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,
     &                     IOFFSET,NFLIP,LENOPEN,BUF,IRTFLG)
d160 8
d180 4
a183 3
C	OPEN A NEW FILE FOR THE CCP4 FORMAT USING DIRECT ACCESS
C       RECORD LENGTH IS 4 BYTES  
        CALL OPAUXFILE(.TRUE.,CCP4FILE,DATEXC,LUNCCP4,4,'N',
d185 1
a185 1
	
d211 2
a212 2
C	WRITE HEADER. (NOTE: FMIN, FMAX, AV ARE SAME AS SPIDER IMAGE)
        CALL SETHEDCCP4(BUF, NSAM, NROW, NSLICE,
d216 2
a217 21
        IF (ISSWABT) THEN
           WRITE(NOUT,*)'      Flipping file data byte order'
        ENDIF


C	WRITE HEADER OF 1024 BYTES (256 FLOATS) FLOAT BY FLOAT
	DO IRECT=1, 256
	   WRITE(LUNCCP4,REC=IRECT,IOSTAT=IERR) BUF(IRECT)
           IF (IERR .NE. 0) THEN
              CALL ERRT(102,'WRITING CCCP HEADER POSITION',IRECT)
              GOTO 9999
           ENDIF
 	ENDDO

C	REOPEN CCP4 FILE FOR DIRECT ACCESS, RECORD LENGTH 1024 BYTES
        CLOSE(LUNCCP4)  
        LENREC = 1024
        CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENREC,'O',
     &                 ' ',.TRUE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

d220 2
a221 3
        IRECOUT        = 1
        ILOCOUT        = 0
        LUNARB(LUNCCP4) = LUNCCP4
d230 2
a231 13
                ILOCOUT = ILOCOUT + 1

                IF (ISSWABT) THEN
C                  FLIP BYTE ORDER
                   R4VALIN      = BUFIN(ILOCIN)
                   I1VALOUT(4)  = I1VALIN(3)
                   I1VALOUT(3)  = I1VALIN(4)
                   I1VALOUT(2)  = I1VALIN(1)
                   I1VALOUT(1)  = I1VALIN(2)
                   BUF(ILOCOUT) = R4VALOUT
                ELSE
                   BUF(ILOCOUT) = BUFIN(ILOCIN)
                ENDIF
d233 1
a233 1
                IF (ILOCOUT .GE. 256) THEN
d236 1
a236 5
                   CALL WRTLIN(LUNCCP4,BUF,256,IRECOUT)
                   IF (IERR .NE. 0) THEN
                      CALL ERRT(102,'WRITING RECORD',IRECIN)
                      GOTO 9999
                   ENDIF
d245 1
a245 1
              CALL WRTLIN(LUNCCP4,BUF,ILOCOUT,IRECOUT)
d261 1
a261 1
                IF (ILOCOUT .GE. LENREC) THEN
d264 1
a264 1
                   CALL WRTLIN8(LUNCCP4,I1BUF,LENREC,IRECOUT)
@


1.4
log
@*** empty log message ***
@
text
@d5 2
a6 1
C                                         
d9 1
a9 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d16 1
a16 1
C COPYCCP4(LUNSPI,LUNNEW)
d41 2
a42 2
	CHARACTER(LEN=1) ::      NULL
        LOGICAL  ::              FLIP
d45 4
d52 3
d76 1
a76 1
     &                   AV,RMS,NSYMBT,FLIP,MACHST,IRTFLG)
d170 1
a170 1
     &                FMINT,FMAXT,FAVT,FSIGT,MODE,IRTFLG)
d173 5
d208 12
a219 1
                BUF(ILOCOUT) = BUFIN(ILOCIN)
d288 66
@


1.3
log
@nloop,iloop_removed
@
text
@d71 1
a71 1
            CALL ERRT(101,'NOT CCP4 FORMAT, TRY MRC FORMAT?',NE)
d108 1
a108 4

           MSB = 1
           IF (FLIP) MSB = 2
           CALL RAW16TOSPI(LUNCCP4,LUNSPI,NSAM,NPIX,IOFFSET,MSB,
@


1.2
log
@*** empty log message ***
@
text
@d139 1
a139 1
        CALL RDPRI1S(IVAL,NLOOP,ILOOP,
@


1.1
log
@Initial revision
@
text
@d40 2
a41 2
	CHARACTER * 1            NULL
        LOGICAL                  FLIP
d92 2
a93 3
        IF (MODE .EQ. 0) THEN
C          8 BIT INTEGER CCP4 INPUT FILE
           INMODE  = 8
d95 5
a99 5
C          REOPEN CCP4 FILE WITH LENREC = 1 BYTE, DIRECT, FORMATTED
           LENOPEN = NSAM
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
d101 2
d106 1
a106 1
        ELSEIF (MODE .EQ. 1) THEN
a108 6
C          REOPEN CCP4 FILE AS NSAM*2 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NSAM * 2
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                   ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

d114 1
a114 1
        ELSEIF (MODE .EQ. 2) THEN
d116 2
a117 9

C          REOPEN CCP4 FILE AS NSAM*4 BYTE, DIRECT ACCESS, UNFORMATTED
           LENOPEN = NSAM * 4
           CALL OPAUXFILE(.FALSE.,CCP4FILE,NULL,LUNCCP4,LENOPEN,'O',
     &                    ' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

           IMODE = 32
           IF (FLIP) IMODE = -33
d119 1
a119 1
     &                     IOFFSET,IMODE,LENOPEN,BUF,IRTFLG)
d122 1
a122 3
 	   WRITE(NOUT,*)'CCP4 MODE: ',MODE,
     &                  '  CAN NOT BE COPIED TO SPIDER' 
           CALL ERRT(100,'COPYCCP4',NE)
@
