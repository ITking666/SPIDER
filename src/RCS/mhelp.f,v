head	1.29;
access;
symbols
	pre_var_equation:1.28
	pre_fftwrings:1.28
	pre_opfiles:1.27
	src:1.27
	best-code:1.27
	x-named-regs:1.27
	x:1.27
	v13-00:1.27
	pre_GPL:1.25
	prec_CA:1.25
	noindx:1.24
	Bproc:1.23
	oct21:1.21
	last77:1.18;
locks; strict;
comment	@c @;


1.29
date	2009.08.18.14.59.31;	author leith;	state dead;
branches;
next	1.28;

1.28
date	2007.04.06.13.54.08;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.17.20.35.16;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.17.18.25.48;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2003.01.28.21.10.33;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.06.18.26.43;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.18.20.21.07;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.06.21.02.51;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	99.10.19.19.50.49;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	99.09.17.12.45.58;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	99.06.03.14.35.15;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	99.02.05.16.32.12;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	99.02.04.16.50.39;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	98.03.31.20.53.02;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	98.01.28.19.31.36;	author pawel;	state Exp;
branches;
next	1.14;

1.14
date	98.01.27.19.25.52;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	98.01.27.16.59.21;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	96.09.30.16.31.09;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	96.09.30.15.43.15;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	95.10.05.20.02.18;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	95.10.03.19.41.11;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	95.06.27.20.05.32;	author mladjadj;	state Exp;
branches;
next	1.7;

1.7
date	95.03.24.15.24.54;	author mladjadj;	state Exp;
branches;
next	1.6;

1.6
date	95.03.21.20.57.03;	author mladjadj;	state Exp;
branches;
next	1.5;

1.5
date	94.11.09.20.06.43;	author mladjadj;	state Exp;
branches;
next	1.4;

1.4
date	94.07.19.17.43.22;	author mladjadj;	state Exp;
branches;
next	1.3;

1.3
date	94.05.17.12.59.19;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.07.06;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.50.05;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.29
log
@obsolete
@
text
@#if defined(__APPLE__)
C   THIS ROUTINE  UNAVAILABLE ON APPLE MAC

       SUBROUTINE mhelp(PROMPT,IANS,USER_STR,NCHAR,IS_HELP)

       LOGICAL        IS_HELP
       CHARACTER *(*) PROMPT, USER_STR

       COMMON /UNITS/LUNC,NIN,NOUT

       WRITE(NOUT,*) ' HELP OPERATION NOT AVAILABLE ON MAC'
       RETURN
       END

#else
#if defined(SP_NT) || defined(SP_IBMSP3) || defined(__linux__)
 
C   THIS ROUTINE SPECIFIC TO UNIX SPIDER AND IS NOT 
C       USED AT  NT SITES
 
       SUBROUTINE mhelp(PROMPT,IANS,USER_STR,NCHAR,IS_HELP)

       LOGICAL        IS_HELP
       CHARACTER *(*) PROMPT, USER_STR
 
       COMMON /UNITS/LUNC,NIN,NOUT
 
       WRITE(NOUT,*) ' sHELP OPERATION NOT AVAILABLE ON THIS OSs'
       RETURN
       END

 
#else

C++*********************************************************************
C
C  MHELP.FOR -- CREATED 3/29/93 ML
C
C **********************************************************************
C *  AUTHOR: MAHIEDDINE LADJADJ                                            *
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C **********************************************************************
C
C    MHELP(PROMPT,IANS,USER_STR)
C
C    PURPOSE:       DISPLAY HELP FILES
C
C    PARAMETERS:    PROMPT     SPIDER PROMPT
C                   IANS       POSITION OF '?' IN USER_STR STRING
C                   USER_STR   USER RESPONSE
C                   NCHAR      NUMBER OF CHARS IN USER_STR STRING
C                   IS_HELP   .TRUE. IF "HELP" WAS TYPED IN IANS STRING.
C
C                   LUNDOC    UNIT TO READ FILE (SET TO 98)
C
C    CALLED BY:     READCH.F
C    
C    CALLS:         MHELP_SUB 
C
C        1         2         3         4         5         6         7       
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE MHELP(PROMPT,IANS,USER_STR,NCHAR,LDUM)

        INCLUDE 'CMBLOCK.INC'

        CHARACTER *(*) PROMPT, USER_STR
        INTEGER        HELP_FILEON
        LOGICAL        EX, IS_HELP
        CHARACTER * 80 ANSWER, S_PROMPT, DIR_NAME, NEWFILE
        CHARACTER * 1  NULL
        CHARACTER * 81 FILNAM, PROMPT00
        CHARACTER * 4  EXT
        CHARACTER * 9  FIND_DIR
	CHARACTER *80  LOWCAS
        CHARACTER * 16 FMT2

        DATA DIR_NAME /' '/
        DATA FILNAM/' '/
	DATA EXT/'.man'/
	DATA FIND_DIR/'SPMAN_DIR'/
        DATA FMT2 /'($,'' .'',A  '': '')'/
        DATA LOWCAS/' '/

        NULL = CHAR(0)

C	PROCESS PROMPT TO CREATE THE FORMAT
        NA = INDEX(PROMPT,'$') - 1
        IF (NA .LE. 0) NA = LEN(PROMPT)
        WRITE(FMT2(10:11),8001) NA
8001    FORMAT(I2)

        LUNDOC           = 99
        LENA             = LEN(PROMPT)
        S_PROMPT(1:LENA) = PROMPT(1:LENA)

C       READ IN THE ENVIRONMENT VARIABLE 'SPMAN_DIR'.
        CALL MYGETENV(FIND_DIR,DIR_NAME,NLEN,
     &               'DIR_CONTAINING_SPIDER_MANUALS',IRTFLG)

C	ONLY SEARCHES FOR FILES WITH EXTENSIONS .MAN
C       MA1 REMOVED OCT 99 AL

C       FIRST,  ROUTINE CHECKS IF FILE NAME EXISTS IN USER_STR STRING.
C       SECOND, ROUTINE CHECKS IF FILE NAME EXISTS IN FCHAR STRING.
C       THIRD,  ROUTINE CHECKS IF FILE NAME EXISTS IN PROMPT STRING.

        JKOOP   = 0
        ANSWER  = USER_STR(1:NCHAR)


C       --------------------------------------------------------------

200     CONTINUE

C	STRIP LEADING AND TRAILING BLANKS, NULLS FROM ANSWER
        ANSWER = ADJUSTL(ANSWER)
        NA     = LNBLNKN(ANSWER)
C	STRIP COMMENT FROM ANSWER
        ISEMI = INDEX(ANSWER(1:NA),';')  
        IF (ISEMI .GT. 1) NA = LNBLNKN(ANSWER(1:ISEMI-1))

C       COPY  THE FUNC STRING SO IT IS CONVERTED TO LOWER CASE
C       DON'T WANT TO CHANGE THE ORIGINAL AND CONFUSE CALLER.
        LOWCAS = ANSWER(1:NA)
        CALL SSLOWCAS(LOWCAS)

        IANS  = INDEX(LOWCAS,'?')
        IHELP = INDEX(LOWCAS,'help')

        IF (NA .EQ. 1 .AND. IANS .EQ. 1 .OR.
     &      NA .EQ. 4 .AND. IHELP .GT. 0) THEN
C          ANSWER IS JUST: '?' OR JUST "HELP', USE PROMPT AND FCHAR 
C          STRINGS TO FIND RELEVANT PORTION OF HELPFILE.

           IF (INDEX(S_PROMPT,'OPERATION') .GT. 0) THEN
C             PROMPT = 'OPERATION', DISPLAY DEFAULT MENU.
              WRITE(NOUT,*) 
     &        ' USE YOUR WWW BROWSER TO VIEW: ..spider/docs/master.html'
              RETURN                                        
           ENDIF

C          TRY NEXT POSSIBLE LOCATION
           JKOOP = JKOOP + 1
           IF (JKOOP .EQ. 1) THEN
C             GET FILENAME FROM FCHAR
              NCHAR   = LEN(FCHAR)
              ANSWER  = FCHAR(1:NCHAR)
              GOTO 200

           ELSEIF (JKOOP .EQ. 2) THEN
C             GET FILENAME FROM PROMPT
              NCHAR   = LEN(PROMPT)
              ANSWER  = PROMPT(1:NCHAR)
              GOTO 200
           ENDIF
           WRITE(NOUT,*) '*** COULD NOT FIND ANY HELP FILE'
	   RETURN

        ELSEIF (JKOOP .EQ. 0 .AND. IANS .GT. 1 .AND. IANS .LT. NA) THEN
C	   CHECK THAT "?" IS EITHER AT THE END OR AT THE BEGINNING
           WRITE(NOUT,*) '     '
           WRITE(NOUT,*) ' *** CALL FOR HELP HAS TO BE :         '
           WRITE(NOUT,*) '      [command] [subcommand]  ?   or   '
           WRITE(NOUT,*) '   ?  [command] [subcommand]           '
           WRITE(NOUT,*) '     '
           WRITE(NOUT,*) '  with [subcommand] being optional     '
           WRITE(NOUT,*) '     '
           WRITE(NOUT,FMT2) PROMPT
           RETURN
        ENDIF

C       HELP FILENAME MAY HAVE BEEN PROVIDED BY THE USER IN THE FORMAT: 
C       "FILENAME ?" OR "? FILENAME" "HELP FILENAME"

        IF (IANS .EQ. 1) THEN
C          STRIP LEADING ? FROM LOWCASE
           LOWCAS = ANSWER(2:)
           NA = NA - 1
        ELSEIF (IANS .EQ. NA) THEN
C          STRIP TRAILING ? FROM LOCASE
           NA = NA - 1
        ELSEIF (IHELP .EQ. 1) THEN
C          STRIP LEADING 'HELP' FROM LOWCASE
           LOWCAS = ANSWER(5:)
           NA = NA - 4
        ENDIF

C	THE USER HAS ASKED FOR SPECIFIC HELP. FIND IT AND DISPLAY IT.
C	THE ROUTINE WILL CONSTRUCT THE LONGEST POSSIBLE FILENAME AND
C	CALL THAT FILE FOR DISPLAY.
        IP    = 0
        IMOOP = NA
        J     = 1
        DO WHILE (IMOOP .GT. 0)
          IF (LOWCAS(J:J) .EQ. ' ' .OR. LOWCAS(J:J) .EQ. NULL) THEN
C           DELETE BLANKS AND NULLS FROM THE FILE NAME
            DO  I = J, J + IMOOP - 1
               LOWCAS(I:I) = LOWCAS(I+1:I+1)
            ENDDO
            GOTO 2010
          ENDIF

C	  SEARCH FOR THE FILE IN THE CURRENT DIRECTORY
          FILNAM = DIR_NAME(1:NLEN) // LOWCAS(1:J) // EXT // NULL

          INQUIRE(FILE=FILNAM,EXIST=EX,ERR=999)
          IF (EX) IP = J
          J     = J + 1
 2010     IMOOP = IMOOP - 1 
        END DO


        IF (IP .GT. 0) THEN
C          HELP FILE EXISTS, READ AND DISPLAY IT.
           FILNAM = DIR_NAME(1:NLEN) // LOWCAS(1:IP) // EXT // NULL

           CALL MHELP_SUB(FILNAM,LUNDOC,S_PROMPT)
           RETURN
        ELSE
C          NO SUCH HELP FILE 
#ifndef __osf__
#ifndef SP_SUN4
C           SEARCH THE DIRECTORY FOR XX*.MA* FILES.
            IRTFLG = HELP_FILEON(DIR_NAME(1:NLEN), NLEN,LOWCAS(1:2), 2,
     &           LUNDOC,S_PROMPT)
            IF (IRTFLG .EQ. -1) GOTO 999
#endif
#endif
            GOTO 998
	ENDIF

999     WRITE(NOUT,*) '     '	
        WRITE(NOUT,*) 'UNABLE TO FIND HELP FILE: ',FILNAM
        WRITE(NOUT,*) '     '
998     WRITE(NOUT,FMT2) PROMPT
        RETURN
        END


 
#ifndef __osf__
#ifndef SP_SUN4
 
C   THIS ROUTINE SPECIFIC TO UNIX SPIDER AND IS NOT 
C       USED AT VAX SITES
C **********************************************************************
C
C       WRITTEN BY MAHIEDDINE LADJADJ         5/19/93
C
C       INTEGER FUNCTION HELP_FILEON()
C
C  This function is called with two arguments. the first arg. is the
C  name of a file (input) and the second arg. is the name of a file
C  that is the longest with the same starting two char.
C      infile : INPUT name of the file given by the calling program.
C      newfile: OUTPUT name of the file  returned.
C      int    : the function returns iflag to indicate the success or
C               failure of the call.
C               iflag  =  -1   no such file
C                          1  file exists
C
C       OPEN : OPENS THE "DIRECTORY FILE".
C              DIR_PTR: FILE DESCRIPTOR.
C              DIR_PATH: PATH TO THE DIRECTORY
C       GETDENTS: READ DIRECTORY ENTRIES AND PUT THEM IN A FILE SYSTEM
C       INDEPENDENT FORMAT.
C       INTEGER*4 FUNCTION GETENDS
C       THE INDEPENDENT FORMAT STORES THE DIRECTORY ENTRIES IN STRUCTURES
C       (man dirent) THAT NEEDS (LONG, LONG, SHORT, CHAR. ENTRY NAME).
C       NOTE : THE ENTRY NAME ALWAYS STARTS ON A LONG BOUNDARY. 
C
C **********************************************************************
C *  AUTHOR: MAHIEDDINE LADJADJ                                            *
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
C **********************************************************************
C
C	DIR_PATH, DIR_LEN	: DIRECTORY NAME AND ITS LENGTH
C	INFILE, INFILE_LEN	: INPUT FILE NAME AND ITS LENGTH
C	LUNDOC			: UNIT NUMBER FOR READ
C	S_PROMPT		: USER PROMPT
C

        INTEGER FUNCTION HELP_FILEON(DIR_PATH, DIR_LEN,
     &			INFILE, INFILE_LEN, LUNDOC, S_PROMT)

C       NUMBER OF BYTES IN A LONG AND A SHORT WORD ON THE MACHINE.
        INTEGER N_LONG, N_SHORT
        PARAMETER ( N_LONG = 4, N_SHORT = 2)
C       NBYTES NEEDED FOR GETDENTS FUNCTION.
C       BEST IF NBYTES IS DIVISIBLE BY N_LONG.
        INTEGER*4 NBYTES, O_RDONLY, MODE, O_WRONLY
        PARAMETER ( NBYTES = 100)
C       EXECUTE BY OWNER (SEE CHMOD & UMASK SYSTEM CALLS)
        PARAMETER (MODE = 100, O_RDONLY = 0, O_WRONLY = 1)

        CHARACTER * 512 BUF
        CHARACTER * 81  FILNAM, ENTRY_NAME, NEWFILE
        CHARACTER *(*)  INFILE, DIR_PATH
        CHARACTER       NULL
        INTEGER*4       DIR_PTR, NXT_TRY
        INTEGER*4       OPEN, GETDENTS, CLOSE
        INTEGER         DIR_LEN, P_DOT, INFILE_LEN, NEWFILE_LEN
        CHARACTER *80   STR_ERR, S_PROMPT
        CHARACTER *14   IS_DIR

        DATA IS_DIR/'Is a directory'/

        NULL = CHAR(0)
        NEWFILE_LEN = 0
 	IF (DIR_LEN .EQ. 0) THEN
	  DIR_PATH(1:1) = '.'
          DIR_PATH(2:2) = NULL
          DIR_LEN = 1
	ELSE
C         OPEN THE DIRECTORY FILE DIR_PATH
          DIR_PTR = 0
          DIR_PTR = OPEN(DIR_PATH(1:DIR_LEN), O_RDONLY, MODE)
          IF(DIR_PTR .LE. 0) THEN
            CALL GERROR(STR_ERR)
            IF (STR_ERR(1:14) .EQ. IS_DIR(1:14)) THEN
              WRITE(NOUT,*)'  DIRECTORY EXISTS:  ',DIR_PATH(1:DIR_LEN)
              WRITE(NOUT,*)'  BUT COULD NOT OPEN IT. RETURN WITH ERROR'
            ELSE
              WRITE(NOUT,*)' NO DIRECTORY EXISTS ',DIR_PATH(1:DIR_LEN)
              WRITE(NOUT,*)' HELP_FILEON.F  1'
            END IF 
            HELP_FILEON = -1
            RETURN
          END IF
	END IF
	IF (INFILE_LEN .EQ. 0) THEN
            HELP_FILEON = -1
            WRITE(NOUT,*)' FILENAME FOR SEARCH DOES NOT EXIST'
            WRITE(NOUT,*)' LENGTH OF FILENAME IS ZERO.'
            WRITE(NOUT,*)' HELP_FILEON.F  2'
            RETURN
	END IF

C       NXT_TRY:  NUMBER OF BYTES ACTUALLY READ
        NXT_TRY = GETDENTS(DIR_PTR, BUF, NBYTES)
        IF (NXT_TRY .EQ. 0) THEN

C         END OF DIRECTORY::
          IF (NEWFILE_LEN .EQ. 0) THEN
            HELP_FILEON =  -1
            WRITE(NOUT,*)' END OF DIRECTORY : NO HELP FILES'
            WRITE(NOUT,*)' DIRECTORY IS ::',  DIR_PATH(1:DIR_LEN)
            WRITE(NOUT,*)' HELP_FILEON.F  4'
          END IF
	  GOTO 9999
        ELSE
          IF (NXT_TRY .LT. 0) THEN
            WRITE(NOUT,*)' ERROR:: COULD NOT READ DIRECTORY FILES'
            WRITE(NOUT,*)' DIRECTORY IS ::',  DIR_PATH(1:DIR_LEN)
	    HELP_FILEON = -1
            WRITE(NOUT,*)' HELP_FILEON.F  5'
	    GOTO 9999
          END IF
        END IF

C       NULL TERMINATE BUF ARRAY JUST IN CASE TO HELP IN DO WHILE LOOP
        BUF(NXT_TRY + 1:NXT_TRY + 1) = NULL

C       FIND THE NUMBER OF BYTES FOR A LONG AND A SHORT ON THIS MACHINE
        OFF_ENTRY = N_LONG + N_LONG + N_SHORT
        DO WHILE (NXT_TRY .GT. 0)

C         FIRST ENTRY NAME POSITION
          I = 1
          I = I + OFF_ENTRY
          DO WHILE (I .LT. NXT_TRY)

C           PARSE BUF ARRAY TO FIND THE ENTRY NAMES.
            L1 = I
            DO WHILE (BUF(I:I) .NE. NULL)
              I = I + 1
            END DO
            IF (I .GT. NXT_TRY) GOTO 5000

C           DIRECTORY ENTRY FOUND : ENTRY_NAME.
            LEN_ENTRY = I - L1
            ENTRY_NAME(1:LEN_ENTRY) = BUF(L1:I - 1)
	    CALL SSUPCAS(ENTRY_NAME(1:LEN_ENTRY))

C	    CHECK THAT THE BEGINNING OF FILENAME IS THE SAME,
C	    THEN THAT .MAN OR .MA1 IS THE EXTENSION.
	    IF (INFILE(1:2) .EQ. ENTRY_NAME(1:2)) THEN
              IF (ENTRY_NAME(LEN_ENTRY - 3:LEN_ENTRY) .EQ. '.MAN'
     &          .OR. ENTRY_NAME(LEN_ENTRY - 3:LEN_ENTRY) .EQ.'.MA1')
     &        THEN
	        IF (NEWFILE_LEN. LT. LEN_ENTRY) THEN

C                 CHOOSING THE LONGEST NAME AVAILABLE
                  NEWFILE(1:LEN_ENTRY) = ENTRY_NAME(1:LEN_ENTRY)
                  NEWFILE_LEN = LEN_ENTRY
                END IF
	      END IF
	    END IF

C           ALIGN THE BEGINNING OF THE STRUCTURE ON A LONG BOUNDARY
 4000       K = MOD(I, N_LONG)
            IF (K .GT. 0) I = I + (N_LONG - K)
            I = I + OFF_ENTRY + 1
          END DO
C         END DO OF  DO WHILE (I .LT. NXT_TRY)

C         NULL TERMINATE BUF ARRAY JUST IN CASE TO HELP IN DO WHILE LOOP
 5000     NXT_TRY = GETDENTS(DIR_PTR, BUF, NBYTES)
          BUF(NXT_TRY + 1:NXT_TRY + 1) = NULL

        END DO

 9999   IRTFLG = CLOSE(DIR_PTR)
        IF (NEWFILE_LEN .GT. 0) THEN
	  FILNAM = DIR_PATH(1:DIR_LEN) // NEWFILE(1:NEWFILE_LEN)
     &             //NULL

          HELP_FILEON = 1
          CALL MHELP_SUB(FILNAM,LUNDOC,S_PROMPT)
        ELSE
          HELP_FILEON = -1
        END IF
        RETURN
        END
#endif
#endif
#endif
#endif

@


1.28
log
@*** empty log message ***
@
text
@@


1.27
log
@GPL License fixed
@
text
@d1 15
d28 1
a28 1
       WRITE(NOUT,*) 'DUMMY CALL: mhelp'
d474 1
a474 1

@


1.26
log
@HRI GPL License used
@
text
@a20 1
C++*************************************************************************
a24 1
C **************************************************************************
a25 2
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
d29 1
a29 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a48 7

C *  COPYRIGHT (C)1990, WADSWORTH CENTER FOR LABORATORIES AND              *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
a49 1
C **************************************************************************
a255 1
C*************************************************************************
a281 1
C **************************************************************************
a282 2
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
d286 1
a286 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a305 7

C *  COPYRIGHT (C)1990, WADSWORTH CENTER FOR LABORATORIES AND              *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH                            *
a306 1
C **************************************************************************
@


1.25
log
@SP_LINUX --> __linux__
@
text
@d20 1
d25 1
d28 1
d30 24
d60 1
d267 1
d294 1
d297 1
d299 24
d329 1
@


1.24
log
@removed from LINUX
@
text
@d1 1
a1 1
#if defined(SP_NT) || defined(SP_IBMSP3) || defined(SP_LINUX)
@


1.23
log
@removed SP_UNIX web browser help
@
text
@d1 1
a1 1
#if defined(SP_NT) || defined(SP_IBMSP3)
@


1.22
log
@for ibm
@
text
@a78 20
#ifdef SP_UNIX
	IF (N_MOSAIC .EQ. 1) THEN
C	   WANT TO USE WEB BROWSER FOR HELP.
 
           NLEN = lnblnk(FCHAR)
	   IF (NLEN .NE. 0) THEN
              ANSWER(1:NLEN) = FCHAR(1:NLEN)
              NCHAR          = NLEN
           ELSE
              ANSWER(1:NCHAR) = USER_STR(1:NCHAR)
           END IF
           PROMPT00 = "$SPIDER_LOC/../docs/utils/htbrowse help "
     &               // ANSWER(1:NCHAR)  // NULL

           CALL CSVMS(PROMPT00, IERR)
	   RETURN

	ENDIF
#endif

@


1.21
log
@updated and simplified
@
text
@d1 1
a1 2

#ifdef SP_NT
@


1.20
log
@removed check-this_out
@
text
@d7 1
a7 1
       SUBROUTINE mhelp(IPROMPT,IANS,USER_STR,NCHAR,IS_HELP)
d10 1
a10 1
       CHARACTER *(*) IPROMPT, USER_STR
d36 1
a36 1
C    MHELP(IPROMPT,IANS,USER_STR)
d40 2
a41 1
C    PARAMETERS:    IPROMPT   SPIDER PROMPT
d43 1
a43 2
C                   NCHAR     NUMBER OF CHARACTER IN USER_STR STRING
C                   IANS      POSITION OF '?' IN USER_STR STRING
d56 1
a56 1
        SUBROUTINE MHELP(IPROMPT,IANS,USER_STR,NCHAR,IS_HELP)
d60 2
a61 2
        CHARACTER *(*) IPROMPT, USER_STR
        INTEGER        EXT_DONE,HELP_FILEON
d66 1
a66 1
        CHARACTER * 4  EXT, EXT0, EXT1
d68 1
a68 1
	CHARACTER *80  UPFUNC
d73 1
a73 2
	DATA EXT0/'.man'/
	DATA EXT1/'.ma1'/
d76 1
a76 1
        DATA UPFUNC/' '/
d82 1
a83 2
C	   WE HAVE INSTALLED WWW HELP.
 
d97 1
a97 1
	END IF
d101 2
a102 2
        NA = INDEX(IPROMPT,'$') - 1
        IF (NA .LE. 0) NA = LEN(IPROMPT)
d106 3
a108 3
        LUNDOC           = 98
        LENA             = LEN(IPROMPT)
        S_PROMPT(1:LENA) = IPROMPT(1:LENA)
d114 9
a122 1
        IF (.NOT. IS_HELP ) GOTO 12
a123 20
C       THE USER HAS TYPED "HELP". HOWEVER WE WILL
C       DISPLAY THE WWW REFERENCE ONLY IF THIS WAS DONE AT THE 
C       'OPERATION' PROMPT.
 10     J_HELP = INDEX(S_PROMPT,'OPERATION')

        IF (J_HELP .LE. 0) THEN

C          "HELP" WAS ENTERED BUT NOT AT THE .OPERATION PROMPT, 
C          SO ANS() DOES NOT HAVE THE NAME OF THE
C	   HELP FILE. BUT FCHAR() SHOULD STILL HAVE IT.
           JKOOP    = 2
           EXT_DONE = 0
           EXT(1:4) = EXT0(1:4)
	   GOTO 180
        ELSE
C          'HELP' WAS ENTERED AT OPERATION PROMPT
           WRITE(NOUT,*) 
     &        ' USE YOUR WWW BROWSER TO VIEW ...spider/docs/master.html'
           RETURN                                        
        END IF
d127 1
a127 25
C	THE ROUTINE SEARCHS FOR FILES WITH EXTENSIONS .MAN
C       (EXT_DONE=0) THEN FILES WITH EXTENSIONS .MA1 (EXT_DONE=1)
C	BEFORE EXITING FROM THE HELP PROGRAM
  12    CONTINUE
        EXT_DONE = 0
        EXT(1:4) = EXT0(1:4)

C       FIRST, THE ROUTINE CHECKS IF A FILE NAME EXISTS IN USER_STR STRING.
C       SECOND, THE ROUTINE CHECKS IF A FILE NAME EXISTS IN FCHAR STRING.
C       THIRD, THE ROUTINE CHECKS IF A FILE NAME EXISTS IN IPROMPT STRING.

C       FIRST OPTION
1200    CONTINUE
        JKOOP           = 1
        ANSWER(1:NCHAR) = USER_STR(1:NCHAR)
        GOTO 200

C       SECOND OPTION
180     NCHAR           = LEN(FCHAR)
        ANSWER(1:NCHAR) = FCHAR(1:NCHAR)
        GOTO 200

C       THIRD OPTION
190     NCHAR           = LEN(IPROMPT)
        ANSWER(1:NCHAR) = IPROMPT(1:NCHAR)
d129 43
a171 28
C	STRIP LEADING AND TRAILING BLANKS AND NULLS
200     CONTINUE
        DO  I = 1, NCHAR
          IF ( ANSWER(I:I) .NE. NULL .AND.
     &         ANSWER(I:I) .NE. ' '  .AND.
     &         ANSWER(I:I) .NE. '?'             ) THEN
            I1 = I
            I2 = I
            DO  J = NCHAR, I, -1
              IF ( ANSWER(J:J) .NE. NULL .AND.
     &             ANSWER(J:J) .NE. ' '  .AND.
     &             ANSWER(J:J) .NE. '?'         ) THEN
                I2 = J

C               THE ANSWER STRING IS NOT EMPTY.
                NA = I2 - I1 +1
                IF (NA .EQ. 0) STOP ' IMPOSSIBLE IN MHELP.FOR 1'

C               COPY  THE FUNC STRING SO IT IS CONVERTED TO UPCASE
C               DON'T WANT TO CHANGE THE ORIGINAL AND CONFUSE CALLER.
	        UPFUNC(1:NA) = ANSWER(I1:I2)
C	        CALL SSUPCAS(UPFUNC)
	        CALL SSLOWCAS(UPFUNC)
                GOTO (1000, 5000, 5000) JKOOP
              END IF
            END DO 
          END IF
        END DO
d173 11
a183 12
C       ANSWER IS OF THE FORMAT ANSWER()= '?'
C	THE USER HAS JUST ASKED FOR HELP.
C	USE IPROMPT AND FCHAR STRINGS TO FIND THE RELEVANT 
C	PORTIONS OF HELP NEEDED.
C       NOTE; IF IPROMPT = 'OPERATION' THEN FCHAR=0
C	      WE SHOULD DISPLAY THE DEFAULT MENU.

        J_HELP = INDEX(S_PROMPT,'OPERATION')
        IF (J_HELP .GT. 0) THEN
           WRITE(NOUT,*) 
     &        ' USE YOUR WWW BROWSER TO VIEW ...spider/docs/master.html'
           RETURN                                        
d186 15
a200 28
        JKOOP = JKOOP + 1
        IF (JKOOP .GT. 3) THEN
          WRITE(NOUT,*) 'NO INDICATION WHAT HELP IS WANTED '
          RETURN
        ELSE
          GOTO (180, 190) (JKOOP - 1)
        END IF
        WRITE(NOUT,*) 'COULD NOT FIND ANY HELP'
	RETURN

C       THE FILENAME HAS BEEN PROVIDED BY THE USER IN THE FORMAT 
C       ANSWER() = FILE ?
C       RESET THE POINTER NCHAR TO THE LAST NON-NULL CHAR. IN ANSWER() STRING
1000    CONTINUE
        NCHAR = I2

C	CHECK THAT "?" IS EITHER AT THE END OF ANSWER OR AT THE BEGINNING
        IF (IANS .GT. I1 .AND. IANS .LT. I2) THEN
          WRITE(NOUT,*) '     '
          WRITE(NOUT,*) ' THE CALL FOR HELP HAS TO BE :         '
          WRITE(NOUT,*) '      [command] [subcommand]  ?   or   '
          WRITE(NOUT,*) '   ?  [command] [subcommand]           '
          WRITE(NOUT,*) '     '
          WRITE(NOUT,*) '  with [subcommand] being optional     '
          WRITE(NOUT,*) '     '
          WRITE(NOUT,FMT2) IPROMPT
          RETURN
        END IF
a204 1
5000    CONTINUE
d208 3
a210 3
        DO WHILE (IMOOP .GT. 0)   
          IF (UPFUNC(J:J) .EQ. ' ' .OR. UPFUNC(J:J) .EQ. NULL) THEN  
C           DELETE BLANKS FROM THE FILE NAME
d212 2
a213 2
               UPFUNC(I:I) = UPFUNC(I+1:I+1)
            END DO
d215 1
a215 1
          END IF
d218 1
a218 1
          FILNAM = DIR_NAME(1:NLEN) // UPFUNC(1:J) // EXT // NULL
d222 1
a222 1
          J = J + 1
d228 2
a229 2
C         HELP FILE EXISTS, READ AND DISPLAY IT.
          FILNAM = DIR_NAME(1:NLEN) // UPFUNC(1:IP) // EXT // NULL
d231 2
a232 3
          CALL MHELP_SUB(FILNAM,LUNDOC,S_PROMPT)
          WRITE(NOUT,FMT2) IPROMPT
          RETURN
d234 1
a234 6
          IF (EXT_DONE .EQ. 0) THEN
             EXT_DONE=1
             EXT(1:4) = EXT1(1:4)
             GOTO 1200
          ELSE

d238 1
a238 1
            IRTFLG = HELP_FILEON(DIR_NAME(1:NLEN), NLEN, UPFUNC(1:2), 2,
d244 1
a244 2
          END IF
	END IF
d247 1
a247 1
        WRITE(NOUT,*) 'UNABLE TO FIND FILE: ',FILNAM
d249 1
a249 1
998     WRITE(NOUT,FMT2) IPROMPT
@


1.19
log
@lowercase
@
text
@d62 1
a62 1
        LOGICAL        EX, IS_HELP, J_HELP
d121 1
a121 2
 10     CALL CHECK_THIS_OUT(S_PROMPT,LENA,'OPERATION',9,J_HELP)
        IF (.NOT. (J_HELP)) THEN
d123 2
d203 2
a204 2
        CALL CHECK_THIS_OUT(S_PROMPT,LENA,'OPERATION',9,J_HELP)
        IF (J_HELP) THEN
d298 1
a298 43
C **************************************************************************
C
C $$ CHECK_THIS_OUT(USER_STR,NCHAR,STR2,I2,IS_HELP)
C
C    PURPOSE: CHECK IF STR2 IS IN USER_STR. IF SO, 
C             RETURN IS_HELP = .TRUE.
C
C    PARAMETERS:    USER_STR    USER RESPONSE
C                   NCHAR       NUMBER OF CHAR. IN USER_STR
C                   STR2, I2    A STRING AND ITS LENGTH.
C                   IS_HELP     LOGICAL VALUE
C
C    CALLED BY:     READCH.F, MHELP.F
C    
C        1         2         3         4         5         6         7       
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE CHECK_THIS_OUT(USER_STR,NCHAR,STR2,I2,IS_HELP)

        CHARACTER *(*)  USER_STR, STR2
        CHARACTER *80   STRING1
        LOGICAL         IS_HELP

C       CONVERT STRING TO ALL UPPER CASE.
        STRING1(1:NCHAR) = USER_STR(1:NCHAR)
        CALL SSUPCAS(STRING1(1:NCHAR))

        IS_HELP = .FALSE. 
        I       = 1
        DO WHILE (I .LT. NCHAR)
           IF ( STRING1(I:I) .NE. STR2(1:1) ) GOTO 1000
           DO J = 2, I2
              I = I + 1
              IF (STRING1(I:I) .NE. STR2(J:J)) GOTO 1000
           END DO
           IS_HELP = .TRUE.
           RETURN
1000       I = I + 1
        END DO
        RETURN
        END
 
@


1.18
log
@removed VMS specific code
@
text
@d38 1
a38 1
C    PURPOSE:        DISPLAY HELP FILES
d50 1
a50 1
C    CALLS:         MHELP_SUB   FILCAN
a58 1
CNO_SAVE 
a59 1

d61 2
a62 4
        INTEGER        IANS, NCHAR, LUNDOC, EXT_DONE
        INTEGER        I, I1, I2, J, IER, N, NA, LENA, IP,
     &                 IMOOP, JKOOP, NLEN, NEWFILE_LEN, IRTFLG 
        INTEGER        HELP_FILEON
a64 1
        LOGICAL        EX, IS_HELP, J_HELP
a65 1
        CHARACTER *4   MASTER
a67 1
        CHARACTER *2   MENU_LIST
a69 2
	CHARACTER *80  FLSPEC,RSLTSPEC
        REAL CTXT
a71 1
        DATA MASTER/'    '/
d73 2
a74 3
        DATA MENU_LIST/'ME'/
	DATA EXT0/'.MAN'/
	DATA EXT1/'.MA1'/
a77 2
        DATA FLSPEC/' '/
        DATA RSLTSPEC/' '/
d82 1
a82 1
	IF(N_MOSAIC.EQ.1) THEN
d84 1
a84 1
c	WE HAVE INSTALLED A HELP ON MOSAIC .
d87 3
a89 3
	   IF(NLEN.NE.0) THEN
             ANSWER(1:NLEN) = FCHAR(1:NLEN)
             NCHAR = NLEN
d91 1
a91 1
             ANSWER(1:NCHAR) = USER_STR(1:NCHAR)
d94 1
a94 1
     $               // ANSWER(1:nchar)  // NULL
d96 1
a96 1
           CALL CSVMS(prompt00, ierr)
d107 3
a109 2
        LUNDOC = 98
        LENA = LEN(IPROMPT)
d116 1
a116 1
        IF (.NOT.(IS_HELP)) GOTO 12
d118 2
a119 2
C       THE USER HAS ENTERED HIS CRY FOR HELP. HOWEVER WE WILL
C       DISPLAY THE MENU DEFAULT ONLY IF THIS WAS DONE AT THE 
d122 1
a122 1
        IF (.NOT.(J_HELP)) THEN
d124 12
a135 6
C         "HELP" WAS ENTERED, SO ANS() DOES NOT HAVE THE NAME OF THE
C	  HELP FILE. BUT FCHAR() SHOULD NOT BE EMPTY.
          JKOOP = 2
          EXT_DONE=0
          EXT(1:4) = EXT0(1:4)
	  GOTO 180
a136 6
 11     S_PROMPT(1:1)='*'
        DO I=2, LENA
          S_PROMPT(2:I)=' '
        END DO
        UPFUNC(1:2) = MENU_LIST(1:2)
        EXT(1:4) = EXT0(1:4)
d138 1
a138 4
C	SEARCH FOR THE FILE IN THE CURRENT DIRECTORY
        FILNAM = DIR_NAME(1:NLEN) // UPFUNC(1:2) // EXT // NULL
        INQUIRE(FILE=FILNAM,EXIST=EX,ERR=999)
        IF(EX) THEN
a139 8
C         HELP FILE EXISTS, READ AND DISPLAY IT.
          CALL MHELP_SUB(FILNAM,LUNDOC,S_PROMPT)
        ELSE
          WRITE(NOUT,*) 'NO MENU LISTING.'
        END IF
        WRITE(NOUT,FMT2) IPROMPT
        RETURN                                        

d144 1
a144 1
        EXT_DONE=0
d150 1
a150 1
C
d153 1
a153 1
        JKOOP = 1
d158 1
a158 1
180     NCHAR = LEN(FCHAR)
d163 1
a163 1
190     NCHAR = LEN(IPROMPT)
d187 2
a188 1
	        CALL SSUPCAS(UPFUNC)
d199 3
a201 2
C       NOTE; if iprompt = 'OPERATION' then fchar=0
C	      we should display the default menu.
d203 6
a208 1
        IF (J_HELP) GOTO 11
d226 1
a226 1
        IF(IANS .GT. I1 .AND. IANS .LT. I2) THEN
d242 1
a242 1
        IP = 0
d244 1
a244 1
        J = 1
a246 1

d249 1
a249 1
              UPFUNC(I:I) = UPFUNC(I+1:I+1)
d254 1
a254 1
C	SEARCH FOR THE FILE IN THE CURRENT DIRECTORY
d258 1
a258 3
          IF(EX) THEN
            IP = J
          END IF
d260 1
a260 1
 2010     IMOOP = IMOOP -1 
d262 2
d265 1
a265 2

C       HELP FILE EXISTS, READ AND DISPLAY IT.
d272 4
a275 4
          IF(EXT_DONE .EQ. 0) THEN
            EXT_DONE=1
            EXT(1:4) = EXT1(1:4)
            GOTO 1200
d280 1
a280 1
C  SEARCH THE DIRECTORY FOR XX*.MA* FILES.
d291 1
a291 1
        WRITE(NOUT,*) 'ERROR :: UNABLE TO FIND FILE',FILNAM
d309 1
a309 2
C
C    CALLED BY:     READCH.FOR, MHELP.FOR
d317 3
a319 4
        CHARACTER *(*) USER_STR, STR2
        CHARACTER *80 STRING1
        INTEGER NCHAR, I, I2
        LOGICAL IS_HELP
d324 1
d326 1
a326 1
        I = 1
d328 8
a335 8
          IF ( STRING1(I:I) .NE. STR2(1:1) ) GOTO 1000
          DO J = 2, I2
            I = I + 1
            IF( STRING1(I:I) .NE. STR2(J:J)) GOTO 1000
          END DO
          IS_HELP = .TRUE.
          RETURN
1000      I = I + 1
d390 1
a390 1
     $			INFILE, INFILE_LEN, LUNDOC, S_PROMT)
a407 1
        INTEGER         LEN, K, L1, L2, L3, IRTFLG, LUNDOC
d431 1
a431 1
              WRITE(NOUT,*)' HELP_FILEON.FOR  1'
d441 1
a441 1
            WRITE(NOUT,*)' HELP_FILEON.FOR  2'
d454 1
a454 1
            WRITE(NOUT,*)' HELP_FILEON.FOR  4'
d462 1
a462 1
            WRITE(NOUT,*)' HELP_FILEON.FOR  5'
@


1.17
log
@CNO_SAVE
@
text
@d1 1
a123 5
#ifdef SP_VMS
        NLEN = 10
        DIR_NAME(1:9) = FIND_DIR(1:9)
        DIR_NAME(10:10) = ':' 
#else
d127 1
a127 1
#endif
a151 3
#ifndef SP_VMS
        CALL SSLOWCAS(FILNAM)
#endif
d273 1
a273 3
#ifndef SP_VMS
          CALL SSLOWCAS(FILNAM)
#endif
d285 1
a285 3
#ifndef SP_VMS
          CALL SSLOWCAS(FILNAM)
#endif
a295 32
#ifdef SP_VMS
            UPFUNC(1:2) = USER_STR(1:2)
            UPFUNC(3:3) = '*'
            EXT(1:4) = '.MA*'
            FLSPEC= DIR_NAME(1:NLEN) // UPFUNC(1:3) // EXT // NULL

C           VMS LIBRARY CALLS TO FIND A FILE OF FORMAT 'XX*.MA*' WHERE
C           XX ARE THE TWO FIRST CHAR OF THE COMMAND NAME.
C           THE FIRST CALL IS TO FIND A FILE WITH A WILD CARD,
C           THE SECOND CALL IS TO FREE THE VIRTUAL MEMORY  ALLOCATED.
            CALL LIB$FIND_FILE(FLSPEC,RSLTSPEC,CTXT)
            CALL LIB$FIND_FILE_END(CTXT)
            FILNAM=RSLTSPEC
            INQUIRE(FILE=FILNAM,EXIST=EX,ERR=999)
            IF(EX) THEN

C       HELP FILE EXISTS, READ AND DISPLAY IT.
              CALL MHELP_SUB(FILNAM,LUNDOC,S_PROMPT)
              WRITE(NOUT,FMT2) IPROMPT
              RETURN
            ELSE
              WRITE(NOUT,*) ' '
              FILNAM = UPFUNC(1:3) // EXT // NULL
              WRITE(NOUT,990) FILNAM
 990          FORMAT(' NO HELP FILE FOUND. FILNENAME :',A30)
              WRITE(NOUT,*) ' '
              NA = INDEX(IPROMPT,'$') - 1
              IF (NA .LE. 0) NA = LEN(IPROMPT)
              WRITE(FMT2(10:11),8001) NA
            END IF

#else
a303 1
#endif
a359 1
#ifndef SP_VMS 
a550 1
#endif
@


1.16
log
@removed FILNAM initialization from data for f90 compiler
@
text
@d58 2
@


1.15
log
@*** empty log message ***
@
text
@d465 10
a474 10
        CHARACTER * 81 FILNAM, ENTRY_NAME, NEWFILE
        DATA (FILNAM(I:I), I=1,81)/81*' '/
        CHARACTER *(*) INFILE, DIR_PATH
        CHARACTER NULL
        INTEGER*4 DIR_PTR, NXT_TRY
        INTEGER*4 OPEN, GETDENTS, CLOSE
        INTEGER LEN, K, L1, L2, L3, IRTFLG, LUNDOC
        INTEGER DIR_LEN, P_DOT, INFILE_LEN, NEWFILE_LEN
        CHARACTER *80 STR_ERR, S_PROMPT
        CHARACTER *14 IS_DIR
d479 1
a479 1
 	IF(DIR_LEN .EQ. 0) THEN
@


1.14
log
@bad cpp command
@
text
@d13 1
a13 1
       WRITE(NOUT,*) 'DUMMY CALL: mhelp
@


1.13
log
@not used on nt
@
text
@d18 1
a18 1
 #else
@


1.12
log
@bug in if
@
text
@d1 18
d597 1
a597 1

@


1.11
log
@used mygetenv
@
text
@d59 1
a59 1
        DATA DIR_NAME /80*' '/
d61 1
a61 1
        DATA FILNAM/81*' '/
d67 3
a69 3
        DATA UPFUNC/80*' '/
        DATA FLSPEC/80*' '/
        DATA RSLTSPEC/80*' '/
@


1.10
log
@sun specific code added to not use getdents on sun
@
text
@d19 1
a19 1
C    PURPOSE: DISPLAY HELP FILES
d22 1
a22 1
C                   USER_STR    USER RESPONSE
d29 1
a29 1
C    CALLED BY:     READCH.FOR
d42 4
a45 4
        INTEGER IANS, NCHAR, LUNDOC, EXT_DONE
        INTEGER I, I1, I2, J, IER, N, NA, LENA, IP,
     &          IMOOP, JKOOP, NLEN, NEWFILE_LEN, IRTFLG 
        INTEGER HELP_FILEON
d50 2
a51 2
        CHARACTER *4 MASTER
        CHARACTER * 4   EXT, EXT0, EXT1
d53 1
a53 1
        CHARACTER *2  MENU_LIST
d56 1
a56 1
	CHARACTER *80 FLSPEC,RSLTSPEC
d59 1
a59 1
        DATA (DIR_NAME(I:I), I=1,80)/80*' '/
d61 1
a61 1
        DATA (FILNAM(I:I), I=1,81)/81*' '/
d67 3
a69 3
        DATA (UPFUNC(I:I), I=1,80)/80*' '/
        DATA (FLSPEC(I:I), I=1,80)/80*' '/
        DATA (RSLTSPEC(I:I), I=1,80)/80*' '/
a106 1
        IF (.NOT.(IS_HELP)) GOTO 12
d109 3
a111 16
        CALL GETENV(FIND_DIR,DIR_NAME)
        NLEN = 0
        I = 80
        DO WHILE (I .GT. 0 .AND. NLEN .EQ.0)
          IF (DIR_NAME(I:I) .NE. ' ') NLEN=I
          I = I - 1
        END DO
        IF (NLEN.EQ.0 .OR. NLEN .GT. 74) THEN
          WRITE(NOUT,*)' HELP DIRECTORY NOT FOUND. '
          WRITE(NOUT,*)' ADD TO YOUR .cshrc FILE THE FOLLOWING LINE:'
          WRITE(NOUT,*)' setenv SPMAN_DIR "/usr1/spider/man/"       '
          WRITE(NOUT,*)' WHERE "/usr1/spider/man/" IS THE DIR. PATH'
          WRITE(NOUT,*)' WHERE THE HELP FILES.MAN ARE STORED'
          WRITE(NOUT,*)' '
          WRITE(NOUT,*)' PLEASE NOTE THE LAST / IN THE PATH'
        END IF
a112 1
#endif
@


1.9
log
@removed TYPE statements (not f77)
@
text
@d335 1
d339 1
a339 3
            IF(IRTFLG .EQ. -1) GOTO 999
#else
            CONTINUE
d342 1
d401 1
d591 1
@


1.8
log
@clear hollorith continuation line prob
@
text
@a38 3
#ifdef SP_VMS
	INCLUDE 'COMMON1:CMBLOCK.INC'
#else
a39 1
#endif
d75 1
a75 1
c
d77 1
a77 1
c
d118 7
a124 7
          TYPE*,' HELP DIRECTORY NOT FOUND. '
          TYPE*,' ADD TO YOUR .cshrc FILE THE FOLLOWING LINE:'
          TYPE*,' setenv SPMAN_DIR "/usr1/spider/man/"       '
          TYPE*,' WHERE "/usr1/spider/man/" IS THE DIRECTORY PATH'
          TYPE*,' WHERE THE HELP FILES.MAN ARE STORED'
          TYPE*,' '
          TYPE*,' PLEASE NOTE THE LAST / IN THE PATH'
d486 2
a487 2
              TYPE*,'  DIRECTORY EXISTS:  ',DIR_PATH(1:DIR_LEN)
              TYPE*,'  BUT COULD NOT OPEN IT. RETURN WITH ERROR'
d489 2
a490 2
              TYPE*,' NO DIRECTORY EXISTS ',DIR_PATH(1:DIR_LEN)
              TYPE*,' HELP_FILEON.FOR  1'
d498 3
a500 3
            TYPE*,' FILENAME FOR SEARCH DOES NOT EXIST'
            TYPE*,' LENGTH OF FILENAME IS ZERO.'
            TYPE*,' HELP_FILEON.FOR  2'
d511 3
a513 3
            TYPE*,' END OF DIRECTORY : NO HELP FILES'
            TYPE*,' DIRECTORY IS ::',  DIR_PATH(1:DIR_LEN)
            TYPE*,' HELP_FILEON.FOR  4'
d518 2
a519 2
            TYPE*,' ERROR:: COULD NOT READ DIRECTORY FILES'
            TYPE*,' DIRECTORY IS ::',  DIR_PATH(1:DIR_LEN)
d521 1
a521 1
            TYPE*,' HELP_FILEON.FOR  5'
@


1.7
log
@cpp SP_UNIX added
@
text
@d250 3
a252 3
          WRITE(NOUT,*) ' THE CALL FOR HELP HAS TO BE : '
          WRITE(NOUT,*) '     [command] [subcommand] ?   or  
     $    ?  [command] [subcommand] '
d254 1
a254 1
          WRITE(NOUT,*) '  with [subcommand] being optional'
@


1.6
log
@ added mosaic help to it
@
text
@d77 1
d96 1
@


1.5
log
@add __osf__ cpp option to port spider to DEC/OSF1(unix) machine
@
text
@a50 1
        DATA (DIR_NAME(I:I), I=1,80)/80*' '/
d53 1
a53 1
        CHARACTER * 81 FILNAM
a54 2
        DATA MASTER/'    '/
        DATA (FILNAM(I:I), I=1,81)/81*' '/
a56 1
	DATA FIND_DIR/'SPMAN_DIR'/
d58 8
d69 2
a70 1
	CHARACTER *80  UPFUNC
a71 4
        CHARACTER * 16 FMT2
        DATA FMT2 /'($,'' .'',A  '': '')'/
	CHARACTER *80 FLSPEC,RSLTSPEC
        REAL CTXT
d75 21
a100 1
        NULL = CHAR(0)
@


1.4
log
@correct help on non-existing file for unix version irt=close(dir)
@
text
@d315 1
d320 2
d323 1
d381 1
d572 4
@


1.3
log
@fixed VMS
@
text
@a36 2
#ifdef SP_VMS

d39 1
d41 3
d48 3
a50 2
     &          IMOOP, JKOOP, NLEN
        CHARACTER * 80 ANST, ANSWER, S_PROMPT, DIR_NAME
d83 2
d89 20
d132 3
d141 1
a141 1
          WRITE(NOUT,*) 'NO MENU LISTING. please ask ArDean Leith'
d186 1
a186 1
C       THE ANSWER STRING IS NOT EMPTY.
d190 2
a191 2
C       MAKE A COPY TO THE FUNC STRING THAT CAN BE CONVERTED TO UPCASE
C       DON'T WANT TO CHANGE THE ORIGINAL AND CONFUSE CALLER.
d215 1
d256 3
d270 3
d282 2
a308 3
              WRITE(NOUT,*) '  Please report this fact to Mahieddine'
              WRITE(NOUT,*) '  e-mail:: mladjadj@@tethys.ph.albany.edu'
              WRITE(NOUT,*) ' '
a311 1
              GOTO 998
d313 8
d374 61
a434 7



#else
        SUBROUTINE MHELP(IPROMPT,IANS,USER_STR,NCHAR,IS_HELP)

        INCLUDE 'CMBLOCK.INC'
d436 2
a437 9
        CHARACTER *(*) IPROMPT, USER_STR
        INTEGER IANS, NCHAR, LUNDOC, EXT_DONE
        INTEGER I, I1, I2, J, IER, N, NA, LENA, IP,
     &          IMOOP, JKOOP, NLEN, NEWFILE_LEN
        CHARACTER * 80 ANST, ANSWER, S_PROMPT, DIR_NAME, NEWFILE
        DATA (DIR_NAME(I:I), I=1,80)/80*' '/
        CHARACTER * 1  NULL
        LOGICAL        EX, IS_HELP, J_HELP
        CHARACTER * 81 FILNAM
d439 9
a447 17
        CHARACTER *4 MASTER
        DATA MASTER/'    '/
        CHARACTER * 4   EXT, EXT0, EXT1
        CHARACTER * 9  FIND_DIR
        DATA FIND_DIR/'SPMAN_DIR'/
        CHARACTER *2  MENU_LIST
        DATA MENU_LIST/'ME'/
        DATA EXT0/'.MAN'/
        DATA EXT1/'.MA1'/
        CHARACTER *80  UPFUNC
        DATA (UPFUNC(I:I), I=1,80)/80*' '/
        CHARACTER * 16 FMT2
        DATA FMT2 /'($,'' .'',A  '': '')'/
        CHARACTER *80 FLSPEC,RSLTSPEC
        REAL CTXT
        DATA (FLSPEC(I:I), I=1,80)/80*' '/
        DATA (RSLTSPEC(I:I), I=1,80)/80*' '/
a448 5
C       PROCESS PROMPT TO CREATE THE FORMAT
        NA = INDEX(IPROMPT,'$') - 1
        IF (NA .LE. 0) NA = LEN(IPROMPT)
        WRITE(FMT2(10:11),8001) NA
 8001   FORMAT(I2)
d450 29
a478 3
        LUNDOC = 98
        LENA = LEN(IPROMPT)
        S_PROMPT(1:LENA) = IPROMPT(1:LENA)
d480 12
a491 47
C       READ IN THE ENVIRONMENT VARIABLE 'SPMAN_DIR'.
        CALL GETENV(FIND_DIR,DIR_NAME)
        NLEN = 0
        I = 80
        DO WHILE (I .GT. 0 .AND. NLEN .EQ.0)
          IF (DIR_NAME(I:I) .NE. ' ') NLEN=I
          I = I - 1
        END DO
        IF (NLEN.EQ.0 .OR. NLEN .GT. 74) THEN
          TYPE*,' HELP DIRECTORY NOT FOUND. '
          TYPE*,' ADD TO YOUR .cshrc FILE THE FOLLOWING LINE:'
          TYPE*,' setenv SPMAN_DIR "/usr1/spider/man/"       '
          TYPE*,' WHERE "/usr1/spider/man/" IS THE DIRECTORY PATH'
          TYPE*,' WHERE THE HELP FILES.MAN ARE STORED'
          TYPE*,' '
          TYPE*,' PLEASE NOTE THE LAST / IN THE PATH'
        END IF
        IF (.NOT.(IS_HELP)) GOTO 12

C       THE USER HAS ENTERED HIS CRY FOR HELP. HOWEVER WE WILL
C       DISPLAY THE MENU DEFAULT ONLY IF THIS WAS DONE AT THE
C       'OPERATION' PROMPT.
 10     CALL CHECK_THIS_OUT(S_PROMPT,LENA,'OPERATION',9,J_HELP)
        IF (.NOT.(J_HELP)) THEN

C       "HELP" WAS ENTERED, SO ANS() DOES NOT HAVE THE NAME OF THE
C       HELP FILE. BUT FCHAR() SHOULD NOT BE EMPTY.
          JKOOP = 2
          EXT_DONE=0
          EXT(1:4) = EXT0(1:4)
          GOTO 180
        END IF
 11     S_PROMPT(1:1)='*'
        DO I=2, LENA
          S_PROMPT(2:I)=' '
        END DO
        UPFUNC(1:2) = MENU_LIST(1:2)
        EXT(1:4) = EXT0(1:4)

C       SEARCH FOR THE FILE IN THE CURRENT DIRECTORY
        FILNAM = DIR_NAME(1:NLEN) // UPFUNC(1:2) // EXT // NULL
        CALL SSLOWCAS(FILNAM)
        INQUIRE(FILE=FILNAM,EXIST=EX,ERR=999)
        IF(EX) THEN

C       HELP FILE EXISTS, READ AND DISPLAY IT.
          CALL MHELP_SUB(FILNAM,LUNDOC,S_PROMPT)
d493 7
a499 1
          WRITE(NOUT,*) 'NO MENU LISTING. please ask ArDean Leith'
a500 2
        WRITE(NOUT,FMT2) IPROMPT
        RETURN
d502 2
a503 6
C       THE ROUTINE SEARCHS FOR FILES WITH EXTENSIONS .MAN
C       (EXT_DONE=0) THEN FILES WITH EXTENSIONS .MA1 (EXT_DONE=1)
C       BEFORE EXITING FROM THE HELP PROGRAM
 12     CONTINUE
        EXT_DONE=0
        EXT(1:4) = EXT0(1:4)
d505 15
a519 36
C   FIRST, THE ROUTINE CHECKS IF A FILE NAME EXISTS IN USER_STR STRING.
C   SECOND, THE ROUTINE CHECKS IF A FILE NAME EXISTS IN FCHAR STRING.
C   THIRD, THE ROUTINE CHECKS IF A FILE NAME EXISTS IN IPROMPT STRING.
C
C   FIRST OPTION
1200   CONTINUE
        JKOOP = 1
        ANSWER(1:NCHAR) = USER_STR(1:NCHAR)
        GOTO 200

C       SECOND OPTION
 180    NCHAR = LEN(FCHAR)
        ANSWER(1:NCHAR) = FCHAR(1:NCHAR)
        GOTO 200

C      THIRD OPTION
 190    NCHAR = LEN(IPROMPT)
        ANSWER(1:NCHAR) = IPROMPT(1:NCHAR)
 200    CONTINUE

C       STRIP LEADING AND TRAILING BLANKS AND NULLS
        DO I = 1, NCHAR
          IF ( ANSWER(I:I) .NE. NULL .AND.
     &         ANSWER(I:I) .NE. ' '  .AND.
     &         ANSWER(I:I) .NE. '?'             ) THEN
            I1 = I
            I2 = I
            DO  J = NCHAR, I, -1
              IF ( ANSWER(J:J) .NE. NULL .AND.
     &             ANSWER(J:J) .NE. ' '  .AND.
     &             ANSWER(J:J) .NE. '?'         ) THEN
                I2 = J

C              THE ANSWER STRING IS NOT EMPTY.
                NA = I2 - I1 +1
                IF (NA .EQ. 0) STOP ' IMPOSSIBLE IN MHELP.FOR 1'
d521 24
a544 8
C       MAKE A COPY TO THE FUNC STRING THAT CAN BE CONVERTED TO UPCASE
C       DON'T WANT TO CHANGE THE ORIGINAL AND CONFUSE CALLER.
                UPFUNC(1:NA) = ANSWER(I1:I2)
                CALL SSUPCAS(UPFUNC)
                GOTO (1000, 5000, 5000) JKOOP
              END IF
            END DO
            END IF
d546 1
a546 20

C       ANSWER IS OF THE FORMAT ANSWER()= '?'
C
C       THE USER HAS JUST ASKED FOR HELP.
C       USE IPROMPT AND FCHAR STRINGS TO FIND THE RELEVANT
C       PORTIONS OF HELP NEEDED.
C
C       NOTE; if iprompt = 'OPERATION' then fchar=0
C             we should display the default menu.
        CALL CHECK_THIS_OUT(S_PROMPT,LENA,'OPERATION',9,J_HELP)
        IF (J_HELP) GOTO 11
        JKOOP = JKOOP + 1
        IF (JKOOP .GT. 3) THEN
          WRITE(NOUT,*) 'NO INDICATION WHAT HELP IS WANTED '
          RETURN
        ELSE
          GOTO (180, 190) (JKOOP - 1)
        END IF
        WRITE(NOUT,*) 'COULD NOT FIND ANY HELP'
 1000   CONTINUE
d548 3
a550 4
C       THE FILENAME HAS BEEN PROVIDED BY THE USER IN THE FORMAT
C       ANSWER() = FILE ?
C       RESET THE POINTER NCHAR TO THE LAST NON-NULL CHAR. IN ANSWER() STRING
        NCHAR = I2
d552 1
a552 29
C       CHECK THAT "?" IS EITHER AT THE END OF ANSWER OR AT THE BEGINNING
        IF(IANS .GT. I1 .AND. IANS .LT. I2) THEN
          WRITE(NOUT,*) '     '
          WRITE(NOUT,*) ' THE CALL FOR HELP HAS TO BE : '
          WRITE(NOUT,*) '     [command] [subcommand] ?   or
     $    ?  [command] [subcommand] '
          WRITE(NOUT,*) '     '
          WRITE(NOUT,*) '  with [subcommand] being optional'
          WRITE(NOUT,*) '     '
          WRITE(NOUT,FMT2) IPROMPT
          RETURN
        END IF

C       THE USER HAS ASKED FOR SPECIFIC HELP. FIND IT AND DISPLAY IT.
C       THE ROUTINE WILL CONSTRUCT THE LONGEST POSSIBLE FILENAME AND
C       CALL THAT FILE FOR DISPLAY.
 5000   CONTINUE
        IP = 0
        IMOOP = NA
        J = 1
        DO WHILE (IMOOP .GT. 0)
          IF (UPFUNC(J:J) .EQ. ' ' .OR. UPFUNC(J:J) .EQ. NULL) THEN

C           DELETE BLANKS FROM THE FILE NAME
            DO I = J, J + IMOOP - 1
              UPFUNC(I:I) = UPFUNC(I+1:I+1)
            END DO
            GOTO 2010
          END IF
d554 4
a557 11
C         SEARCH FOR THE FILE IN THE CURRENT 
          FILNAM = DIR_NAME(1:NLEN) // UPFUNC(1:J) // EXT // NULL
          CALL SSLOWCAS(FILNAM)
          INQUIRE(FILE=FILNAM,EXIST=EX,ERR=999)
          IF(EX) THEN
            IP = J
          END IF
          J = J + 1
 2010     IMOOP = IMOOP -1
        END DO
        IF (IP .GT. 0) THEN
d559 1
a559 3
C       HELP FILE EXISTS, READ AND DISPLAY IT.
          FILNAM = DIR_NAME(1:NLEN) // UPFUNC(1:IP) // EXT // NULL
          CALL SSLOWCAS(FILNAM)
a560 2
          WRITE(NOUT,FMT2) IPROMPT
          RETURN
d562 1
a562 11
          IF(EXT_DONE .EQ. 0) THEN
            EXT_DONE=1
            EXT(1:4) = EXT1(1:4)
            GOTO 1200
          ELSE

C  SEARCH THE DIRECTORY FOR XX*.MA* FILES.
            CALL HELP_FILEON(DIR_NAME(1:NLEN), NLEN, UPFUNC(1:2), 2,
     &           LUNDOC,S_PROMPT)
            GOTO 998
          END IF
a563 49
 999    WRITE(NOUT,*) '     '
        WRITE(NOUT,*) 'ERROR :: UNABLE TO FIND FILE',FILNAM
        WRITE(NOUT,*) '     '
 998    WRITE(NOUT,FMT2) IPROMPT
        RETURN
        END

C **************************************************************************
C
C    CHECK_THIS_OUT(USER_STR,NCHAR,STR2,I2,IS_HELP)
C
C    PURPOSE: CHECK IF THE ANSWER IS "HELP" OR "help". IF SO,
C             RETURN IS_HELP = .TRUE.
C
C    PARAMETERS:    USER_STR    USER RESPONSE
C                   NCHAR       NUMBER OF CHAR. IN USER_STR
C                   STR2, I2    STRING AND ITS LENGTH
C                   IS_HELP     LOGICAL VALUE
C
C
C    CALLED BY:     READCH.FOR, MHELP.FOR
C
C        1         2         3         4         5         6         7
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE CHECK_THIS_OUT(USER_STR,NCHAR,STR2,I2,IS_HELP)

        CHARACTER *(*) USER_STR, STR2
        INTEGER NCHAR, I, I2
        LOGICAL IS_HELP
        CHARACTER *80  STRING1

C       CONVERT STRING TO ALL UPPER CASE.
        STRING1(1:NCHAR) = USER_STR(1:NCHAR)
        CALL SSUPCAS(STRING1(1:NCHAR))

        IS_HELP = .FALSE.
        I = 1
        DO WHILE (I .LT. NCHAR)
          IF ( STRING1(I:I) .NE. STR2(1:1) ) GOTO 1000
          DO J = 2, I2
            I = I + 1
            IF( STRING1(I:I) .NE. STR2(J:J)) GOTO 1000
          END DO
          IS_HELP = .TRUE.
          RETURN
 1000     I = I + 1
        END DO
a565 1

@


1.2
log
@cpp_lines_added
@
text
@d1 1
a1 1
#ifdef VMS
d4 1
a4 1
C $$ MHELP.FOR -- CREATED 3/29/93 ML
d17 1
a17 1
C $$ MHELP(IPROMPT,IANS,USER_STR)
d37 2
a40 3
#ifdef SP_UNIX
	INCLUDE 'CMBLOCK.INC'
#else
d42 1
a42 1
#endif
a289 4
C++*************************************************************************
C
C $$ CHECK_THIS_OUT(USER_STR,NCHAR,STR2,I2,IS_HELP) -- CREATED 4/16/93 ML
C
a290 9
C *  AUTHOR: MAHIEDDINE LADJADJ                                            *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1990, WADSWORTH CENTER FOR LABORATORIES AND              *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d333 3
a338 1
#ifdef SP_UNIX
a339 3
#else
        INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
a578 4
C++*************************************************************************
C
C  CHECK_THIS_OUT(USER_STR,NCHAR,STR2,I2,IS_HELP) -- CREATED 4/16/93 ML
C
a579 9
C *  AUTHOR: MAHIEDDINE LADJADJ                                            *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1990, WADSWORTH CENTER FOR LABORATORIES AND              *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH                            *
C **************************************************************************
d608 1
d623 1
@


1.1
log
@Initial revision
@
text
@d1 1
d39 3
d43 1
d347 304
@
