head	1.52;
access;
symbols
	pre_getangas:1.50
	GPL2010:1.50
	pre_GPL2010:1.49
	pre_var_equation:1.49
	pre_fftwrings:1.49
	pre_opfiles:1.49
	src:1.49
	best-code:1.49
	x-named-regs:1.49
	x:1.49
	v13-00:1.49
	pre_GPL:1.47
	prec_CA:1.47
	noindx:1.46
	Bproc:1.39
	oct21:1.36
	last77:1.30;
locks; strict;
comment	@c @;


1.52
date	2014.07.29.14.46.56;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2012.03.15.19.15.34;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.24.13.25.48;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.17.20.02.05;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.17.17.57.42;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.20.19.40.13;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2002.03.11.14.07.50;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.05.19.43.20;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.09.18.54.44;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.08.16.00.31;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.02.20.33.46;	author pawel;	state Exp;
branches;
next	1.41;

1.41
date	2000.09.29.13.56.31;	author bimal;	state Exp;
branches;
next	1.40;

1.40
date	2000.09.28.20.13.13;	author bimal;	state Exp;
branches;
next	1.39;

1.39
date	2000.06.12.19.26.34;	author bimal;	state Exp;
branches;
next	1.38;

1.38
date	99.12.03.20.39.04;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	99.12.03.20.33.36;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	99.10.04.21.49.59;	author pawel;	state Exp;
branches;
next	1.35;

1.35
date	99.10.04.21.43.16;	author pawel;	state Exp;
branches;
next	1.34;

1.34
date	99.09.01.14.23.33;	author pawel;	state Exp;
branches;
next	1.33;

1.33
date	99.04.16.14.11.18;	author pawel;	state Exp;
branches;
next	1.32;

1.32
date	99.04.15.13.02.38;	author pawel;	state Exp;
branches;
next	1.31;

1.31
date	99.04.14.21.59.33;	author pawel;	state Exp;
branches;
next	1.30;

1.30
date	99.03.01.18.39.28;	author pawel;	state Exp;
branches;
next	1.29;

1.29
date	99.03.01.14.43.42;	author pawel;	state Exp;
branches;
next	1.28;

1.28
date	98.08.07.18.11.59;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	98.04.06.19.59.31;	author pawel;	state Exp;
branches;
next	1.26;

1.26
date	98.04.06.19.12.05;	author pawel;	state Exp;
branches;
next	1.25;

1.25
date	98.01.26.18.32.29;	author pawel;	state Exp;
branches;
next	1.24;

1.24
date	97.10.17.15.18.50;	author pawel;	state Exp;
branches;
next	1.23;

1.23
date	97.10.09.14.27.23;	author pawel;	state Exp;
branches;
next	1.22;

1.22
date	97.09.30.14.39.10;	author pawel;	state Exp;
branches;
next	1.21;

1.21
date	97.09.22.17.21.06;	author pawel;	state Exp;
branches;
next	1.20;

1.20
date	97.08.20.15.03.50;	author pawel;	state Exp;
branches;
next	1.19;

1.19
date	97.08.15.16.16.21;	author pawel;	state Exp;
branches;
next	1.18;

1.18
date	97.08.12.14.47.29;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	97.07.30.19.54.35;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	97.07.30.16.11.11;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	96.12.10.17.27.30;	author mladjadj;	state Exp;
branches;
next	1.14;

1.14
date	96.12.10.17.05.57;	author mladjadj;	state Exp;
branches;
next	1.13;

1.13
date	96.12.10.17.00.46;	author mladjadj;	state Exp;
branches;
next	1.12;

1.12
date	96.12.03.15.31.23;	author mladjadj;	state Exp;
branches;
next	1.11;

1.11
date	96.12.02.20.36.19;	author mladjadj;	state Exp;
branches;
next	1.10;

1.10
date	95.08.09.13.41.37;	author mladjadj;	state Exp;
branches;
next	1.9;

1.9
date	95.07.31.13.57.47;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	95.07.28.16.04.25;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	95.07.27.19.59.33;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	95.07.11.18.05.44;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	95.07.11.18.04.00;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	95.02.02.21.08.13;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	95.02.02.20.48.48;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.05.45;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.49.10;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.52
log
@LEN=MAXNAM
@
text
@C++*********************************************************************
C
C    GALI.F           DYNAMIC MEMORY ALLOCATION SEPT 2000 BIMAL RATH 
C                     REPLACED 'INCORE'         SEPT 2001 ARDEAN LEITH
C                     OPFILEC                   FEB  2003 ARDEAN LEITH
C                     GALI_P INSERTED           MAR  2012 ARDEAN LEITH
C                     BAD LUNIN                 DEC  2013 ARDEAN LEITH
C                     LEN=MAXNAM                JUL  2014 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2014, Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C   GALI
C
C   CALLS:  GALI_P 
C           ALROSI_Q 
C           ALROSF_Q 
C           RTQS_Q 
C           CROSRNG_Q
C           SHFI_Q 
C           BLOB_Q 
C           FINDMX_Q 
C           ALRQ_Q
C           ALPRBS_Q 
C           FOURING_Q 
C           RTQ_Q 
C           CENT_Q 
C           OUTIM_Q 
C           FMRS_1 
C           FMRS_1D 
C           QUADRI_Q
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE GALI

        INCLUDE 'CMBLOCK.INC' 
        INCLUDE 'CMLIMIT.INC'
 
        INTEGER, ALLOCATABLE   :: NUMR(:,:)
        REAL,    ALLOCATABLE   :: BLOB(:,:)

        CHARACTER(LEN=MAXNAM)  :: FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
        COMMON /FISPEC/
     &     FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC,NLET,NLETI,NLIMA,NLDOC

        COMMON /MXR/     MAXRIN
C       MXR in: ang.f, gali.f, hali_p.f

        LOGICAL                :: FOUROK = .FALSE.
        CHARACTER*1            :: MODE
        LOGICAL                :: USEBLOB

        CHARACTER(LEN=1)       :: NULL = CHAR(0)

        INTEGER,PARAMETER      :: INPIC  = 78
        INTEGER,PARAMETER      :: LUNDOC = 80   
        INTEGER,PARAMETER      :: LUNXM  = 0  ! SELFILE NOT ALLOWED

C       OPEN INPUT IMAGE(S)
        MAXIM = 0
        NILMAX = NIMAX
        CALL OPFILES(0,INPIC,LUNDOC,LUNXM, 
     &             .TRUE.,FINPAT,NLET, 'O',
     &             IFORM,NX,NY,NZ,MAXIM,
     &             'INPUT FILE TEMPLATE (E.G. PIC****)~',
     &             FOUROK,INUMBR,NILMAX, 
     &             NDUM,NIMA,IMGNUM, IRTFLG) 
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)


C       NIMA - TOTAL NUMBER OF IMAGES
        IF (NIMA > 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT('  Number of images: ',I5)
        ELSE
           CALL ERRT(101,'NO IMAGES',NDUM)
           GOTO 9999
        ENDIF

C       FOURIER SIZE
        LSD = NX + 2 - MOD(NX,2)

        CALL RDPRI1S(NSI,NOT_USED,'EXPECTED SIZE OF THE OBJECT',IRTFLG)
        IF (NSI >= NX)  THEN
           WRITE(NOUT,*)' OBJECT SIZE CANNOT BE LARGER THAN IMAGE SIZE'
           NSI = NX - 2
           WRITE(NOUT,*) ' OBJECT SIZE SET TO: ',NSI
        ENDIF
        NSI = MAX(1,(NX-NSI)/2)

        CALL RDPRMI(MR,NR,NOT_USED,'FIRST AND LAST RING RADIUS')

        IF (MR.LE.0 .OR. NR .GE. MIN((NX/2),(NY/2))) THEN
           CALL ERRT(31,'AP SR',NE)
           GOTO 9999
        ENDIF

        IF (NR .GT. NX/2-1)  THEN
           NR = NX/2-1
           WRITE(NOUT,*) ' LAST RING RADIUS LIMITED TO: ',NR
        ENDIF
        MR    = MAX(1,MIN(NR,MR))
        ISKIP = 1
        MODE  = 'F'

C       FIND TOTAL NUMBER OF RINGS
        NRING = 0
        DO I=MR,NR,ISKIP
           NRING = NRING + 1
        ENDDO

        ALLOCATE (NUMR(3,NRING), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'GALI; NUMR',3*NRING)
           GOTO 9999
        ENDIF

C       FILL RINGS POINTER
        NRING = 0
        DO I=MR,NR,ISKIP
           NRING         = NRING + 1
           NUMR(1,NRING) = I
        ENDDO

C       FILL NUMR
        CALL ALPRBS_Q(NUMR,NRING,LCIRC,MODE)

        MAXRIN = NUMR(3,NRING) - 2  ! WHY -2 ??

C       CHECK WHETHER USER HAS OWN REFERENCE FILE TO CENTER THE AVERAGE.
C       DISP = 'Z' WILL NOT CALL ERRT IN OPFIL IF NOT EXISTING
        MAXIM = 0
        CALL OPFILEC(0,.TRUE.,OUTIMA,INPIC,'Z',IFORM,NX,NY,NZ,
     &    MAXIM,'IMAGE TO BE USED TO CENTER THE AVERAGE',.FALSE.,IRTFLG)

        IF (IRTFLG .NE. 0)  THEN
           WRITE(NOUT,*) ' NO IMAGE GIVEN, DEFAULT PROCEDURE USED'
           USEBLOB = .TRUE.
        ELSE
           USEBLOB = .FALSE.
        ENDIF

C       TEMPLATES FOR OUTPUT FILES
        CALL  FILERD(OUTIMA,NLIMA,NULL,
     &        'TEMPLATE FOR AVERAGE FILES',IRTFLG)

        CALL  FILERD(OUTDOC,NLDOC,NULL,
     &        'TEMPLATE FOR ALIGNMENT DOC FILES',IRTFLG)
	
        JACUP = 0  ! UNKNOWN PURPOSE

        ALLOCATE(BLOB(LSD,NY),STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'AP SR; BLOB',LSD*NY)
           GOTO 9999
        ENDIF

        IF (.NOT.USEBLOB)  THEN 
           CALL READV(INPIC,BLOB,LSD,NY,NX,NY,NZ)
           CLOSE(INPIC)
        ENDIF

        CALL GALI_P(LSD,NX,NY,NSI,INUMBR,NIMA,MODE,JACUP,
     &           LCIRC,NUMR,NRING,MAXRIN,BLOB,USEBLOB,NR,NOUT,ITER)
 
        CALL REG_SET_NSEL(1,1,FLOAT(ITER),0.0,0.0,0.0,0.0,IRTFLG)

        !!WRITE (NOUT,2600)
2600    FORMAT (/'  ',12('-'),' END OF COMPUTATION ',12('-')/)

9999    IF (ALLOCATED(BLOB))  DEALLOCATE(BLOB)
        IF (ALLOCATED(NUMR))  DEALLOCATE(NUMR)
                
        END



C++*********************************************************************
C
C GALI_P.F            DYNAMIC MEMORY ALLOCATION SEP 2000 BIMAL RATH    
C                     REPLACED 'INCORE'         SEP 2001 ARDEAN LEITH
C                     ADDED ITER PARAM          MAR 2012 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C GALI_P
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE GALI_P(LSD,NX,NY,NSI,ILIST,NIMA,MODE,JACUP,
     &             LCIRC,NUMR,NRING,MAXRIN,BLOB,USEBLOB,NR,NOUT,NITER)

        REAL, ALLOCATABLE, DIMENSION(:,:) :: A, B, C, D, E
        REAL, ALLOCATABLE, DIMENSION(:,:) :: REFER, REFERN, REFERTMP
        REAL, ALLOCATABLE, DIMENSION(:,:) :: PARA
        REAL, ALLOCATABLE, DIMENSION(:)   :: A_CIRC, REFER_CIRC
        REAL, ALLOCATABLE, DIMENSION(:)   :: QIMAGES

        INTEGER    :: ILIST(NIMA)
        REAL       :: BLOB(LSD,NY)
        LOGICAL    :: CHANGE, NOCHANGE, USEBLOB, IMAGE(NIMA), INCORE
        INTEGER    :: NUMR(3,NRING)

C       TEMP IS AN AUTOMATIC ARRAY
        DOUBLE PRECISION  :: TEMP(MAXRIN+2,2),FNRM,DNRM

        CHARACTER*1       :: MODE

        DATA  ZERO/0.0/
        DATA  INPIC/77/

        NSNR = LSD * NY
        
        ALLOCATE(A(LSD,NY), B(LSD,NY),C(LSD,NY), D(LSD,NY),
     &           E(LSD,NY), REFER(LSD,NY), REFERN(LSD,NY),
     &           REFERTMP(LSD,NY), PARA(3,NIMA), A_CIRC(LCIRC),
     &           REFER_CIRC(LCIRC),    STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN
           MWANT = 8*LSD*NY + 3*NIMA + 2*LCIRC
           CALL  ERRT(46,'GALI_P; A,B,C,D,....',MWANT)
           GOTO 9999
        ENDIF

        INCORE = .FALSE.
        ISIZE  = NX * NY * NIMA
        ALLOCATE(QIMAGES(ISIZE), STAT=IRTFLG)
        IF (IRTFLG == 0) THEN
           WRITE(NOUT,*) ' -- IMAGES IN_CORE VERSION -- '
C          LOAD IMAGE DATA INTO QIMAGES TO SPEED THINGS UP
           DO IMI = 1,NIMA
              CALL GETIMA_Q(QIMAGES(NX*NY*(IMI-1)+1),NX,NX,NY,
     &                      IMI,ILIST,NIMA,QIMAGES,INPIC,INCORE)
           ENDDO
           INCORE = .TRUE.
        ELSE
           WRITE(NOUT,*) ' -- IMAGES FROM DISK VERSION -- '
        ENDIF

C       PREPARE 'BLOB'  TO CENTER INPUT IMAGES ....
        IF (USEBLOB) CALL BLOB_Q(BLOB,LSD,NX,NY,NR)
	
        INS = 1
        CALL FMRS_2(BLOB,NX,NY,INS)
        IF (INS == 0)  THEN
           CALL  ERRT(38,'AP SR',NE)
           GOTO 9999
        ENDIF

C       BUILD FIRST AVERAGE

C       IMAGE  IS USED HERE FOR THE RANDOM SELECTION OF IMAGES
C       INITIALIZE ALL IMAGE() TO .FALSE.

        IMAGE = .FALSE.
        CALL RANDOM_NUMBER(CIID)
        IMI         = MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))

        IMAGE(IMI)  = .TRUE.
        PARA(1,IMI) = 0.0
        PARA(2,IMI) = 0.0
        PARA(3,IMI) = 0.0

C       GET IMAGE DATA
        CALL GETIMA_Q(A,LSD,NX,NY,IMI,ILIST,NIMA,
     &                QIMAGES,INPIC,INCORE)

C       COPIES IMAGE DATA FROM A INTO B
        CALL COP(A,B,NSNR)

C       FT ON IMAGE DATA IN ARRAY B
        INS = 1
        CALL FMRS_2(B,NX,NY,INS)

C       BLOB - BLOB; B-CURRENT IMAGE; C-CCF.

        LSC = NX+2-MOD(NX,2)
        CALL CCRS_2(BLOB,B,C, LSC,NX,NY)

        CALL FINDMX_Q(C,LSD,NX,NY,NSI,CMX1,SX1,SY1)

        ISX1        = SX1
        ISY1        = SY1
        PARA(2,IMI) = ISX1
        PARA(3,IMI) = ISY1
        CALL SHFI_Q(A,REFERN,LSD,NX,NY,ISX1,ISY1)

C       PRINT  *,' FIRST IMAGE WITH BLOB',IMI,ISX1,ISY1
        CALL COP(REFERN,REFER,NSNR)
        CALL ALRQ_Q(REFER,LSD,NX,NY,NUMR,REFER_CIRC,LCIRC,
     &                NRING,MODE,IPIC)
        CALL FOURING_Q(REFER_CIRC,LCIRC,NUMR,NRING,TEMP,MODE)
        INS = 1
        CALL FMRS_2(REFER,NX,NY,INS)

C       GO THROUGH ALL THE REMAINING IMAGES.
        CHANGE = .FALSE.
        DO KTN = 2,NIMA
           DO
              CALL RANDOM_NUMBER(CIID)
              M   = MIN0(NIMA,MAX0(1,INT(CIID*(NIMA-KTN+1)+0.5)))
              IMI = 0
              DO  I=1,NIMA
                 IF (.NOT.IMAGE(I))  THEN
                    IMI = IMI + 1
                    IF (IMI .EQ. M)  THEN
                       IMI = I
                       GOTO  801
                    ENDIF
                 ENDIF
              ENDDO
           ENDDO

801        IMAGE(IMI) = .TRUE.
C          GET IMAGE DATA
           CALL GETIMA_Q(A,LSD,NX,NY,IMI,ILIST,NIMA,
     &                   QIMAGES,INPIC,INCORE)
C          COPY IMAGE DATA ARRAY A INTO ARRAY B
           CALL COP(A,B,NSNR)
           INS = 1

C          FT ON IMAGE DATA IN ARRAY B
           CALL FMRS_2(B,NX,NY,INS)

C          BLOB - BLOB; B-CURRENT IMAGE; C-CCF.

           LSC = NX+2-MOD(NX,2)
           CALL CCRS_2(BLOB,B,C, LSC,NX,NY)

           CALL FINDMX_Q(C,LSD,NX,NY,NSI,CMX1,SX1,SY1)

           ISX1        = SX1
           ISY1        = SY1
           PARA(1,IMI) = 0.0
           PARA(2,IMI) = ISX1
           PARA(3,IMI) = ISY1

           CALL SHFI_Q(A,B,LSD,NX,NY,ISX1,ISY1)

C          PRINT  *,' NEXT IMAGE WITH BLOB',IMI,ISX1,ISY1

C          RUN ROTATION-SHIFT ALIGNMENT
C          INPUT:  THREE REAL IMAGES, A, B AND REFERN
C          OUTPUT: B - REAL ALIGNED IMAGE, PARA - UDATED PARAMETERS
C          SCRATCH: D
C          NOCHANGE=.TRUE. - NO CHANGE IN THE POSITION OF THE IMAGE

           CALL ALROSI_Q(A,B,D,C,REFER,LSD,NX,NY,NSI,
     &          PARA(1,IMI),NOCHANGE,
     &          A_CIRC,REFER_CIRC,LCIRC,JACUP,NUMR,NRING,MAXRIN,
     &          TEMP,MODE,KTN)
           IF (.NOT. NOCHANGE)  CHANGE = .TRUE.

C          ADD IMAGE TO THE REFERENCE

C          CALL  UPDTF(REFERN,B,NSNR,KTN)
           CALL  UPDTF_R(REFERN,B,NX,NY,LSD,KTN)
        ENDDO
	
C       CORRECT CENTER

        IF (USEBLOB)  THEN
           CALL CENT_Q(REFERN,LSD,NX,NY,XS,YS)
           XS = -(XS-NX/2-1)
           YS = -(YS-NY/2-1)
        ELSE
C          BLOB - BLOB; REFERN-CURRENT AVERAGE; D-CCF.
           CALL COP(REFERN,REFER,NSNR)
           INS = +1
           CALL FMRS_2(REFER,NX,NY,INS)

           LSC = NX+2-MOD(NX,2)
           CALL CCRS_2(BLOB,REFER,D, LSC,NX,NY)

           CALL FINDMX_Q(D,LSD,NX,NY,NSI,CMX1,XS,YS)
        ENDIF

C        PRINT *, '  CENTER CORRECTION  ',XS,YS

        CALL RTQS_Q(REFERN,REFER,LSD,NX,NY,ZERO,XS,YS)
        DO IMI=1,NIMA
           PARA(2,IMI) = PARA(2,IMI)+XS
           PARA(3,IMI) = PARA(3,IMI)+YS
        ENDDO

        CALL OUTIM_Q(REFER,LSD,NX,NY,1)

        CALL OUTPR(PARA,NIMA,1)

        TEMP(1,1) = FNRM(REFER,NSNR)

        I = 1
        WRITE(NOUT,5091)  I,TEMP(1,1)
5091    FORMAT('  ITERATION:',I5,'   SUM OF SQUARES:',1PD12.5)

        NITER = I

C       IF NO CHANGES TERMINATE
        IF (.NOT. CHANGE) GOTO 9999

C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C       REFINE THE ALIGNMENT
C       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        ITER = 0
        DNRM = 0.0D0

C       ITERATE THE REFINEMENT
        DO
           CHANGE = .FALSE.
           ITER   = ITER + 1

c$omp      parallel do private(j,i)
           DO J=1,NY
              DO I=1,LSD
                 REFERN(I,J) = 0.0
              ENDDO
           ENDDO
c$omp      end parallel do
	   
c$omp      parallel do private(imi)
           DO IMI=1,NIMA
              IMAGE(IMI) = .FALSE.
           ENDDO
c$omp      end parallel do

           DO KTN=1,NIMA
              DO
                 CALL RANDOM_NUMBER(CIID) 
                 M   = MIN0(NIMA,MAX0(1,INT(CIID*(NIMA-KTN+1)+0.5)))
                 IMI = 0
                 DO I=1,NIMA
                    IF (.NOT. IMAGE(I))  THEN
                       IMI = IMI+1
                       IF (IMI.EQ.M)  THEN
                          IMI = I
                          GOTO  901
                       ENDIF
                    ENDIF
                 ENDDO
              ENDDO

901           IMAGE(IMI) = .TRUE.

C             PRINT *,' IMAGE  #  ',IMI
C             GET IMAGE DATA IN ARRAY A
              CALL GETIMA_Q(A,LSD,NX,NY,IMI,ILIST,NIMA,
     &                      QIMAGES,INPIC,INCORE)

              CALL RTQS_Q(A,C,LSD,NX,NY,PARA(1,IMI),
     &                    PARA(2,IMI),PARA(3,IMI))

C             SUBTRACT THE IMAGE FROM THE REFERENCE
              CALL SUBAF(REFER,C,REFERTMP,NSNR,NIMA)
              CALL COP(REFERTMP,E,NSNR)

C             RUN ROTATION-SHIFT ALIGNMENT
C             INPUT:  TWO REAL IMAGES, B AND REFER
C             OUTPUT: C - REAL ALIGNED IMAGE, PARA - UDATED PARAMETERS
C             NOCHANGE=.TRUE. - NO CHANGE IN THE POSITION OF THE IMAGE

              CALL  ALROSF_Q(A,C,D,B,REFERTMP,LSD,NX,NY,NSI,
     &                       PARA(1,IMI),NOCHANGE,
     &                       A_CIRC,REFER_CIRC,LCIRC,JACUP,
     &                       NUMR,NRING,MAXRIN,TEMP,MODE)

              IF (.NOT. NOCHANGE)  THEN
                 CHANGE = .TRUE.

C                ADD IMAGE TO THE REFERENCE
                 CALL UPDF(E,C,REFER,NSNR,NIMA)
              ENDIF
C              CALL UPDTF(REFERN,C,NSNR,KTN)
               CALL UPDTF_R(REFERN,C,NX,NY,LSD,KTN)
           ENDDO

C          CORRECT CENTER
           IF (USEBLOB)  THEN
              CALL CENT_Q(REFERN,LSD,NX,NY,XS,YS)
              XS = -(XS-NX/2-1)
              YS = -(YS-NY/2-1)
           ELSE

C             BLOB - BLOB; REFERN-CURRENT AVERAGE; D-CCF.
              CALL COP(REFERN,REFER,NSNR)
              INS = +1
              CALL FMRS_2(REFER,NX,NY,INS)

              LSC = NX+2-MOD(NX,2)
              CALL CCRS_2(BLOB,REFER,D, LSC,NX,NY)

              CALL FINDMX_Q(D,LSD,NX,NY,NSI,CMX1,XS,YS)
           ENDIF

           CALL RTQS_Q(REFERN,REFER,LSD,NX,NY,ZERO,XS,YS)
c$omp      parallel do private(imi)
           DO IMI=1,NIMA
              PARA(2,IMI) = PARA(2,IMI) + XS
              PARA(3,IMI) = PARA(3,IMI) + YS
           ENDDO
c$omp      end parallel do

           CALL OUTIM_Q(REFER,LSD,NX,NY,ITER+1)
           CALL OUTPR(PARA,NIMA,ITER+1)
           TEMP(1,1) = FNRM(REFER,NSNR)
           WRITE(NOUT,5091)  ITER+1,TEMP(1,1)
           NITER = ITER + 1

           IF (TEMP(1,1) .GE. DNRM)  THEN
              DNRM = TEMP(1,1)
              IF (.NOT.CHANGE)  GOTO 9999
           ELSE
              GOTO 9999
           ENDIF

C          END OF INFINITE ITERATIONS
        END DO

9999    IF (ALLOCATED(A))          DEALLOCATE(A)
        IF (ALLOCATED(B))          DEALLOCATE(B)
        IF (ALLOCATED(C))          DEALLOCATE(C)
        IF (ALLOCATED(D))          DEALLOCATE(D)
        IF (ALLOCATED(E))          DEALLOCATE(E)
        IF (ALLOCATED(REFER))      DEALLOCATE(REFER)
        IF (ALLOCATED(REFERN))     DEALLOCATE(REFERN)
        IF (ALLOCATED(REFERTMP))   DEALLOCATE(REFERTMP)
        IF (ALLOCATED(PARA))       DEALLOCATE(PARA)
        IF (ALLOCATED(A_CIRC))     DEALLOCATE(A_CIRC)
        IF (ALLOCATED(REFER_CIRC)) DEALLOCATE(REFER_CIRC)
        IF (ALLOCATED(QIMAGES))    DEALLOCATE(QIMAGES)

        END
@


1.51
log
@output formating, niter on op line
@
text
@d6 3
d14 1
a14 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
a32 17
C   CALLS:      GALI_P 
C               ALROSI_Q 
C               ALROSF_Q 
C               RTQS_Q 
C               CROSRNG_Q
C               SHFI_Q 
C               BLOB_Q 
C               FINDMX_Q 
C               ALRQ_Q
C               ALPRBS_Q 
C               FOURING_Q 
C               RTQ_Q 
C               CENT_Q 
C               OUTIM_Q 
C               FMRS_1 
C               FMRS_1D 
C               QUADRI_Q
d34 17
a50 1
C IMAGE_PROCESSING_ROUTINE
a52 1
C
d60 6
a65 9
        INTEGER, ALLOCATABLE     ::  ILIST(:)
        INTEGER, ALLOCATABLE     ::  NUMR(:,:)
        REAL, ALLOCATABLE        ::  BLOB(:,:)

        !CHARACTER(LEN=MAXNAM)   :: FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC

        CHARACTER*80    FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
        COMMON  /FISPEC/ FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC,
     &                   NLET,NLETI,NLIMA,NLDOC
d68 1
d70 3
a72 2
        CHARACTER*1      :: MODE
        LOGICAL          :: USEBLOB
d74 1
a74 1
        CHARACTER(LEN=1) :: NULL= CHAR(0)
d76 3
a78 1
        DATA  INPIC/78/
d80 2
d83 9
a91 5
        ALLOCATE(ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'AP SR; ILIST',NILMAX)
           RETURN
        ENDIF
d93 6
a98 7
C       ASK FOR DATA FILE LIST
        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NIMA,
     &    'ENTER TEMPLATE FOR 2-D IMAGE',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
	
        IF (NIMA .LE. 0)  THEN
           CALL ERRT(101,'NO IMAGES',IER)
a101 11
        WRITE(NOUT,2001) NIMA
2001    FORMAT('  NUMBER OF IMAGES: ',I6)

C       OPEN ONE FILE TO GET SIZE
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
        MAXIM  = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
        CLOSE(INPIC)

d103 1
a103 1
        LSD = NSAM + 2 - MOD(NSAM,2)
d105 4
a108 5
        CALL RDPRI1S(NSI,NOT_USED,'EXPECTED SIZE OF THE OBJECT',
     &                IRTFLG)
        IF (NSI .GE. NSAM)  THEN
           WRITE(NOUT,*)' OBJECT SIZE CANNOT BE LARGER THAN WINDOW SIZE'
           NSI = NSAM - 2
d111 1
a111 1
        NSI = MAX0(1,(NSAM-NSI)/2)
d115 1
a115 1
        IF (MR.LE.0 .OR. NR .GE. MIN0((NSAM/2),(NROW/2))) THEN
d120 2
a121 2
        IF (NR .GT. NSAM/2-1)  THEN
           NR = NSAM/2-1
d136 1
a136 1
           CALL ERRT(46,'AP SR; NUMR',3*NRING)
d140 1
d143 1
a143 1
           NRING = NRING + 1
d147 1
d149 2
a150 1
        MAXRIN = NUMR(3,NRING)-2
d155 1
a155 1
        CALL OPFILEC(0,.TRUE.,OUTIMA,INPIC,'Z',IFORM,NSAM,NROW,NSLICE,
d167 1
a167 1
     &        'ENTER TEMPLATE FOR AVERAGE FILES',IRTFLG)
d170 1
a170 1
     &        'ENTER TEMPLATE FOR ALIGNMENT DOC FILES',IRTFLG)
d172 1
a172 1
        JACUP = 0  ! UNKNOW PURPOSE
d174 1
a174 1
        ALLOCATE(BLOB(LSD,NROW),STAT=IRTFLG)
d176 1
a176 1
           CALL  ERRT(46,'AP SR; BLOB',LSD*NROW)
d181 1
a181 1
           CALL READV(INPIC,BLOB,LSD,NROW,NSAM,NROW,NSLICE)
d185 1
a185 1
        CALL GALI_P(LSD,NSAM,NROW,NSI,ILIST,NIMA,MODE,JACUP,
d190 1
a190 1
        WRITE (NOUT,2600)
a194 1
        IF (ALLOCATED(ILIST)) DEALLOCATE(ILIST)
d196 378
@


1.50
log
@GPL_2010
@
text
@d59 3
a61 3
        INTEGER, ALLOCATABLE,  DIMENSION(:)      ::  ILIST
        INTEGER, ALLOCATABLE, DIMENSION(:,:)     ::  NUMR
        REAL, ALLOCATABLE, DIMENSION(:,:)        ::  BLOB
d63 3
a65 1
        CHARACTER*80     FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
d71 4
a74 2
        CHARACTER*1      NULL,MODE
        LOGICAL          USEBLOB
a77 2
        NULL = CHAR(0)

d81 1
a81 1
           CALL ERRT(46,'AP SR, ILIST',IER)
d96 1
a96 1
2001    FORMAT(' NUMBER OF IMAGES: ',I6)
d120 1
a120 1
        IF (MR.LE.0 .OR. NR.GE.MIN0((NSAM/2),(NROW/2)))THEN
a124 3
C       CALL RDPRMI(ISKIP,NDUMP,NOT_USED,'SKIP')
C       ISKIP = MAX0(1,ISKIP)

d129 1
a129 1
        MR    = MAX0(1,MIN0(NR,MR))
d140 2
a141 2
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'AP SR, NUMR',IER)
d151 1
a151 1
        CALL  ALPRBS_Q(NUMR,NRING,LCIRC,MODE)
d169 2
a170 1
     &        'ENTER TEMPLATE FOR OUTPUT',IRTFLG)
d172 1
a172 5
     &        'ENTER TEMPLATE FOR OUTPUT DOC.',IRTFLG)

C        CALL  RDPRMI(JACUP,NDUMP,NOT_USED,
C     &    'PRECISION OF PEAK LOCATION (0..100)')
C        JACUP=MAX0(0,MIN0(100,JACUP))
d174 1
a174 1
        JACUP = 0
d178 1
a178 1
           CALL  ERRT(46,'AP SR, BLOB',IER)
d188 1
a188 1
     &           LCIRC,NUMR,NRING,MAXRIN,BLOB,USEBLOB,NR,NOUT)
d190 2
d193 1
a193 3
2600    FORMAT (/,' ',72('-'),//,
     &            ' ',' ALIGNMENT,   END OF COMPUTATION',//,
     &            ' ',72('-')/)
@


1.49
log
@GPL License fixed
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.48
log
@HRI GPL License used
@
text
@a7 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d11 1
a11 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a30 6

C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.47
log
@opfilec
@
text
@d9 24
@


1.46
log
@nloop,iloop_removed
@
text
@d4 2
a5 1
C                     REPLACED 'INCORE' SEPT 2001 ARDEAN LEITH
d81 1
a81 1
2001    FORMAT(' NUMBER OF IMAGES: ',i6)
d86 1
a86 1
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d145 1
a145 1
        CALL OPFIL(.TRUE.,OUTIMA,INPIC,'Z',NSAM,NROW,NSLICE,
@


1.45
log
@restored incore & cosmetic
@
text
@d93 1
a93 1
        CALL RDPRI1S(NSI,NLOOP,ILOOP,'EXPECTED SIZE OF THE OBJECT',
d102 1
a102 1
        CALL RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING RADIUS')
d109 1
a109 1
C       CALL RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
d160 1
a160 1
C        CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
@


1.44
log
@*** empty log message ***
@
text
@d1 1
a1 1
C++************************************************************************
d3 2
a4 1
C    GALI.F              DYNAMIC MEMORY ALLOCATION SEPT 2000 BIMAL RATH 
d6 27
a32 28
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C   SUBROUTINE  GALI
C   SUBROUTINE  GALI_P(LSD,NSAM,NROW,NSI,ILIST,NIMA,MODE,JACUP,
C   SUBROUTINE  ALROSI_Q(A,ATMP,B,C,REFER,LSD,NSAM,NROW,NSI,
C   SUBROUTINE  ALROSF_Q(A,ATMP,B,C,REFER,LSD,NSAM,NROW,NSI,
C   SUBROUTINE  RTQS_Q(X,OUT,LSD,NSAM,NROW,THETA,SHXI,SHYI)
C   SUBROUTINE  CROSRNG_Q
C   SUBROUTINE  SHFI_Q(X,OUT,LSD,NSAM,NROW,ISHX,ISHY)
C   SUBROUTINE  BLOB_Q(X,LSD,NSAM,NROW,NR)
C   SUBROUTINE  FINDMX_Q(D,LSD,NSAM,NROW,NSI,CMX,SX,SY)
C   SUBROUTINE  ALRQ_Q
C   SUBROUTINE  ALPRBS_Q(NUMR,NRING,LCIRC,MODE)
C   SUBROUTINE  FOURING_Q(CIRC,LCIRC,NUMR,NRING,EO,MODE)
C   SUBROUTINE  RTQ_Q(X,OUT,LSD,NSAM,NROW,THETA)
C   SUBROUTINE  CENT_Q(X,LSD,NSAM,NROW,SNS,SNR)
C   SUBROUTINE  OUTIM_Q(X,LSD,NSAM,NROW,IT)
C   SUBROUTINE  FMRS_1(X,N,INV)
C   SUBROUTINE  FMRS_1D(X,N,INV)
C   FUNCTION    QUADRI_Q(XX, YY, LSD, NXDATA, NYDATA, FDATA)
a35 1
C        1         2         3         4         5         6         7
d38 1
a38 1
C--************************************************************************
d49 3
a51 8
        COMMON  /FISPEC/
     &  FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC,NLET,NLETI,NLIMA,NLDOC
        COMMON /MXR/    MAXRIN
        INTEGER         MAXRIN

        CHARACTER*80    FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
        CHARACTER*1     NULL,MODE
        LOGICAL         USEBLOB
d53 5
a59 2
        NILMAX = NIMAX

d62 3
a64 2
        ALLOCATE (ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
d69 1
a69 2
C       ASK FOR DATA FILE

d72 1
a72 3
        IF (IRTFLG .NE. 0) THEN           
           RETURN
        ENDIF
d74 3
a76 6
        IF (NIMA .GT .0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT('  NUMBER OF IMAGES =',i5)
        ELSE
           WRITE(NOUT,*)  '  NO IMAGES !'
           RETURN
d78 5
a83 1

a84 2
        NSLICE = 1
        IFORM  = 1
d87 1
a87 4
        IF (IRTFLG .NE. 0) THEN
           DEALLOCATE (ILIST)
           RETURN
        ENDIF
d90 2
a91 1
        LSD = NSAM+2-MOD(NSAM,2)
d93 1
a93 1
        CALL  RDPRI1S(NSI,NLOOP,ILOOP,'EXPECTED SIZE OF THE OBJECT',
d97 1
a97 1
           NSI = NSAM-2
d102 1
a102 1
        CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING RADIUS')
d106 1
a106 2
           DEALLOCATE(ILIST)
           RETURN
d109 2
a110 2
C       CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
C       ISKIP=MAX0(1,ISKIP)
d114 1
a114 1
           WRITE(NOUT,*)  ' LAST RING RADIUS LIMITED TO: ',NR
d116 3
a118 3
        MR=MAX0(1,MIN0(NR,MR))
        ISKIP=1
        MODE='F'
d121 3
a123 3
        NRING=0
        DO    I=MR,NR,ISKIP
           NRING=NRING+1
d129 1
a129 2
           DEALLOCATE (ILIST)
           RETURN
d132 4
a135 4
        NRING=0
        DO    I=MR,NR,ISKIP
           NRING=NRING+1
           NUMR(1,NRING)=I
d139 1
a139 3
        MAXRIN=NUMR(3,NRING)-2

C   CHECK WHETHER THE USER HAS HIS OWN REFERENCE FILE TO CENTER THE AVERAGE.
d141 4
a144 2
        MAXIM=0
        CALL OPFIL(.TRUE.,OUTIMA,INPIC,'O',NSAM,NROW,NSLICE,
d147 2
a148 3
        IF (IRTFLG.NE.0)  THEN
           WRITE(NOUT,506)
506        FORMAT(' NO IMAGE GIVEN, DEFAULT PROCEDURE WILL BE USED')
d151 1
a151 1
           USEBLOB=.FALSE.
a154 1

d156 1
a156 1
     &      'ENTER TEMPLATE FOR OUTPUT',IRTFLG)
d158 1
a158 1
     &      'ENTER TEMPLATE FOR OUTPUT DOC',IRTFLG)
d167 1
a167 1
        IF (IRTFLG.NE.0) THEN
d169 1
a169 2
           DEALLOCATE (ILIST, NUMR)
           RETURN
d177 1
a177 1
        CALL  GALI_P(LSD,NSAM,NROW,NSI,ILIST,NIMA,MODE,JACUP,
d185 3
a187 1
        DEALLOCATE(BLOB, NUMR, ILIST)
@


1.43
log
@nsi redifined
@
text
@d101 2
a102 1
        CALL  RDPRI1S(NSI,NLOOP,ILOOP,'EXPECTED SIZE OF THE OBJECT')
@


1.42
log
@MR
@
text
@d3 1
a3 1
C    GALI.F                  DYNAMIC MEMORY ALLOCATION SEPT 2000 BIMAL RATH 
a45 1

a56 1
        
d58 1
a61 1
        NULL=CHAR(0)
d63 2
a70 1

d99 1
a99 1
        LSD=NSAM+2-MOD(NSAM,2)
d101 1
a101 1
        CALL  RDPRMI(NSI,NR,NLOOP,ILOOP,'EXPECTED SIZE OF THE OBJECT')
d104 1
a104 1
           NSI=NSAM-2
d107 1
a107 1
        NSI=MAX0(1,NSAM-NSI)
d111 1
a111 1
        IF(MR.LE.0.OR.NR.GE.MIN0((NSAM/2),(NROW/2)))THEN
a116 1

d119 3
a121 3
C
        IF(NR.GT.NSAM/2-1)  THEN
           NR=NSAM/2-1
d156 1
a156 1
        IF(IRTFLG.NE.0)  THEN
d159 1
a159 1
           USEBLOB=.TRUE.
d175 1
a175 1
        JACUP=0
d178 1
a178 1
        IF(IRTFLG.NE.0) THEN
d184 1
a184 1
        IF(.NOT.USEBLOB)  THEN 
d193 3
a195 2
2600    FORMAT (/' ',80('-')//' ',' ALIGNMENT,  ',
     &  'END OF COMPUTATION',//' ',80('-')/)
d197 2
a198 1
        DEALLOCATE(BLOB, NUMR, ILIST)        
@


1.41
log
@no argument for gali.f
@
text
@d126 1
a126 1
        MR=MAX0(2,MIN0(NR,MR))
@


1.40
log
@dynamic memory allocation
@
text
@d15 1
a15 1
C   SUBROUTINE  GALI(MAXMEM)
d41 1
a41 1
        SUBROUTINE GALI(MAXMEM)
@


1.39
log
@no message for small 1st ring
@
text
@d3 1
a3 1
C    GALI.F
d15 1
a15 1
C   SUBROUTINE GALI(MAXMEM)
a16 1
C   SUBROUTINE  GETIMA_Q(X,LSD,NSAM,NROW,IMI,Q)
d32 1
a32 1
C   FUNCTION  QUADRI_Q(XX, YY, LSD, NXDATA, NYDATA, FDATA)
d34 5
d41 1
a41 1
	SUBROUTINE GALI(MAXMEM)
d43 56
a98 61
	PARAMETER  (NILMAX=99998)
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
	INCLUDE 'CMBLOCK.INC'  
	COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),BAF(1)
	EQUIVALENCE  (BAF,NUMR) 

        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q

        LOGICAL         RUNTIME 
         REAL, ALLOCATABLE, DIMENSION(:,:) ::  BLOB
C be careful with the common, it has to agree with 64 bits...
C watch for NILMAX, it's in getima, outim and outpr.
         COMMON  /FISPEC/
     &   FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC,NLET,NLETI,NLIMA,NLDOC
         CHARACTER*80    FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
         COMMON /MXR/    MAXRIN
         INTEGER         MAXRIN
         CHARACTER*1     NULL,MODE
         COMMON  /CORE/  INCORE
         LOGICAL         INCORE,USEBLOB
         DATA  INPIC/78/
         NULL=CHAR(0)
C  ASK FOR DATA FILE
         CALL  FILERD(FINPAT,NLET,NULL,
     &      'ENTER TEMPLATE FOR 2-D IMAGE',IRTFLG)
         CALL FILERD(DOCFIL,NLETI,NULL,'SELECTION DOC',IRTFLG)
         K=0
         K2=1
         NIMA=0
778      LERR=-1
         IF (NIMA .EQ. NILMAX)  THEN
            WRITE(NOUT,*) '  TOO MANY IMAGES, LIST TRUNCATED'
            GOTO  779
         ENDIF
         KP1=K+1
         CALL  UNSAV(DOCFIL,K,INPIC,KP1,BUF,1,LERR,K2)
         IF (LERR .EQ. 0)  THEN
            NIMA        = NIMA+1
            ILIST(NIMA) = BUF(1)
            K           = K+1
            GOTO  778
         ENDIF

779      CLOSE(INPIC)
         IF (NIMA .GT .0)  THEN
            WRITE(NOUT,2001) NIMA
2001        FORMAT('  NUMBER OF IMAGES =',i5)
         ELSE
            WRITE(NOUT,*)  '  NO IMAGES !'
            RETURN
         ENDIF
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
         IF (NF.NE.2)  THEN
            CALL ERRT(4,'AP SR ',NE)
            RETURN
         ENDIF
         CLOSE(INPIC)
d100 1
a100 1
	 LSD=NSAM+2-MOD(NSAM,2)
d102 2
a103 2
         CALL  RDPRMI(NSI,NR,NLOOP,ILOOP,'EXPECTED SIZE OF THE OBJECT')
         IF (NSI .GE. NSAM)  THEN
d107 44
a150 9
         ENDIF
         NSI=MAX0(1,NSAM-NSI)
C
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
C
	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	CALL ERRT(31,'OR 2',NE)
	RETURN
	ENDIF
d152 1
d154 2
a155 21
C	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
C	ISKIP=MAX0(1,ISKIP)
C
         IF(NR.GT.NSAM/2-1)  THEN
            NR=NSAM/2-1
            WRITE(NOUT,*)  ' LAST RING LIMITED TO: ',NR
         ENDIF
         MR=MAX0(2,MIN0(NR,MR))
         ISKIP=1
         MODE='F'
         NRING=0
         DO    I=MR,NR,ISKIP
            NRING=NRING+1
            NUMR(1,NRING)=I
	 ENDDO
         CALL  ALPRBS_Q(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)-2
C
C  Check whether the user has his own reference file to center the average.
	MAXIM=0
	CALL OPFIL(.TRUE.,OUTIMA,INPIC,'O',NSAM,NROW,NSLICE,
d157 12
a168 9
	IF(IRTFLG.NE.0)  THEN
	  WRITE(NOUT,506)
506	  FORMAT(' No image given, default procedure will be used')
	  USEBLOB=.TRUE.
	ELSE
	  USEBLOB=.FALSE.
	ENDIF
C       templates for output files
         CALL  FILERD(OUTIMA,NLIMA,NULL,
d170 1
a170 1
         CALL  FILERD(OUTDOC,NLDOC,NULL,
d173 1
a173 1
C     CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
d175 3
a177 2
C     JACUP=MAX0(0,MIN0(100,JACUP))
         JACUP=0
a178 107
C   memory division    K
C       numr           1
C       image          2
C       para           3
C       WRK            4
C       A              5
C       B              6
C       C              7
C       D              8
C       refer          9
C       refern        10
C       refertmp      11
C       temp          12  !double precision
C       a_circ        13
C       refer_circ    14
C       E             15
C
C
C K1 not used
        K1=-1
        K2=1
        K3=IPALIGN64(K2+NIMA)
        K4=IPALIGN64(K3+3*NIMA)
        K5=IPALIGN64(K4+MAX0(NSAM,2*NROW))
        K6=IPALIGN64(K5+LSD*NROW)
        K7=IPALIGN64(K6+LSD*NROW)
        K8=IPALIGN64(K7+LSD*NROW)
        K9=IPALIGN64(K8+LSD*NROW)
        K10=IPALIGN64(K9+LSD*NROW)
        K11=IPALIGN64(K10+LSD*NROW)
        K12=IPALIGN64(K11+LSD*NROW)
        K13=IPALIGN64(K12+4*(MAXRIN+2))
        K14=IPALIGN64(K13+LCIRC)
        K15=IPALIGN64(K14+LCIRC)
        K16=IPALIGN64(K15+LSD*NROW)
        L_MAINBUF=K16
        INCORE=.FALSE.
        MEMTOT=L_MAINBUF+NSAM*NROW*NIMA
        CALL CHKMEM(MEMTOT, BAF, (MAXMEM-(NILMAX+1024+80)), 
     &              RUNTIME,IPQ,IRTFLG)
        IF(IRTFLG.EQ.0) THEN
           IF (.NOT. RUNTIME)  THEN
C             COULD NOT HAVE DYNAMIC MEMORY. TRY COMMON BLOCK.     
              K1=1
              K2=IPALIGN64(K1+3*NRING)
              K3=IPALIGN64(K2+NIMA)
              K4=IPALIGN64(K3+3*NIMA)
              K5=IPALIGN64(K4+MAX0(NSAM,2*NROW))
              K6=IPALIGN64(K5+LSD*NROW)
              K7=IPALIGN64(K6+LSD*NROW)
              K8=IPALIGN64(K7+LSD*NROW)
              K9=IPALIGN64(K8+LSD*NROW)
              K10=IPALIGN64(K9+LSD*NROW)
              K11=IPALIGN64(K10+LSD*NROW)
              K12=IPALIGN64(K11+LSD*NROW)
              K13=IPALIGN64(K12+4*(MAXRIN+2))
              K14=IPALIGN64(K13+LCIRC)
              K15=IPALIGN64(K14+LCIRC)
              K16=IPALIGN64(K15+LSD*NROW)
              L_MAINBUF=K16
              INCORE=.FALSE.
              MEMTOT=1200+L_MAINBUF+NSAM*NROW*NIMA
              
              CALL CHKMEM(MEMTOT, BAF, (MAXMEM-(NILMAX+1024+80)), 
     &              RUNTIME,IPQ,IRTFLG)
              IF (IRTFLG.EQ.0) THEN 

                  Q = >IPQ

C                ENOUGH MEMORY IN COMMON BLOCK.
                 WRITE (NOUT,2500)  MAXMEM , MEMTOT
                 WRITE(NOUT,*)  '   ***  IN-CORE VERSION  ***'
                 DO  IMI=1,NIMA     
                     CALL GETIMA_Q(Q(L_MAINBUF+NSAM*NROW*(IMI-1)),
     $                        NSAM,NSAM,NROW,IMI,Q(1))
                 ENDDO     
                 INCORE=.TRUE.
              END IF
           ELSE
C             RUNTIME IS TRUE. DYNAMIC MEM. ALLOCATION.
              Q = >IPQ
              WRITE (NOUT,2500)  MAXMEM , MEMTOT
              WRITE(NOUT,*)  '   ***  IN-CORE VERSION  ***'
              DO  IMI=1,NIMA     
                 CALL GETIMA_Q(Q(L_MAINBUF+NSAM*NROW*(IMI-1)),
     $                        NSAM,NSAM,NROW,IMI,Q(1))
              ENDDO        
              INCORE=.TRUE.
           END IF  
        END IF
        IF (.NOT.INCORE) THEN
C          REDUCE MEMORY. COULD NOT ALLOCATE DYN. MEM OR COMMON
C          BLOCK MEMORY

           MEMTOT=MEMTOT-NSAM*NROW*NIMA
           CALL CHKMEM(MEMTOT, BAF, (MAXMEM-(NILMAX+1024+80)), 
     &              RUNTIME,IPQ,IRTFLG)
           IF (IRTFLG.EQ.0) THEN
              Q = >IPQ

              WRITE (NOUT,2500)  MAXMEM , MEMTOT
           ELSE
              CALL ERRT(6,'AP SR ',NE)
              RETURN
           ENDIF 
        END IF
C
d180 20
a199 24
        IF(IRTFLG.NE.0) CALL  ERRT(46,'AP SR, BLOB',IER)
	IF(.NOT.USEBLOB)  THEN
         DO  J=1,NROW
	  CALL  REDLIN(INPIC,BLOB(1,J),NSAM,J)
	 ENDDO
	 CLOSE(INPIC)
	ENDIF
         CALL  GALI_P(LSD,NSAM,NROW,NSI,ILIST,NIMA,MODE,JACUP,
     &			Q(K4),Q(K5),Q(K6),Q(K7),Q(K8),Q(K15),Q(K9),
     &			Q(K10),Q(K11),Q(K2),Q(K3),
     &			Q(K13),Q(K14),LCIRC,
     &			NUMR,NRING,MAXRIN,Q(K12),Q(K16),
     &			BLOB,USEBLOB,NR,NOUT)
	 DEALLOCATE(BLOB)
         IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'GALI',IRTFLG)
      
         WRITE (NOUT,2600)
2600     FORMAT (/' ',80('-')//' ',' ALIGNMENT,  ',
     &   'END OF COMPUTATION',//' ',80('-')/)
         RETURN

2500     FORMAT (/,' MEMORY RESERVATION: YOU HAVE',
     &   ' RESERVED ',I8,',  YOU NEED  ',I8 / )
         END
@


1.38
log
@# continue char fails on NT f90
@
text
@d117 2
a118 5
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
@


1.37
log
@ # continue char fails on NT f90.
 # continue char fails on NT f90
@
text
@d45 1
a45 1
#ifdef SP_F90
d49 2
a50 5
#else
         DIMENSION Q(1)
         POINTER   (IPQ,Q) 
#endif
         LOGICAL         RUNTIME 
d151 1
a151 1
C templates for output files
d228 3
a230 3
#ifdef SP_F90
         Q = >IPQ
#endif
d242 1
a242 3
#ifdef SP_F90
         Q = >IPQ
#endif
d252 1
a252 1
        IF(.NOT.INCORE) THEN
d260 2
a261 3
#ifdef SP_F90
         Q = >IPQ
#endif
@


1.36
log
@*** empty log message ***
@
text
@d3 1
a3 1
C    GALI.FOR
a14 2
C   GALI.FOR
C
d38 1
d294 1
a294 1
     #   'END OF COMPUTATION',//' ',80('-')/)
d298 1
a298 1
     #   ' RESERVED ',I8,',  YOU NEED  ',I8 / )
@


1.35
log
@option to center images added
@
text
@d147 1
a147 1
     &    MAXIM,'IMAGE TO BE USED TO CENTER THE AVERGE',.FALSE.,IRTFLG)
@


1.34
log
@SKIP question removed
@
text
@d40 1
a40 1
	PARAMETER  (NILMAX=10000)
d55 1
a55 1
         
d65 2
a66 2
         LOGICAL         INCORE
         DATA  INPIC/77/
d143 12
a207 1
           
d275 9
a283 1
        
d289 2
a290 2
     &			NR,NOUT)

@


1.33
log
@*** empty log message ***
@
text
@d126 2
a127 2
	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
	ISKIP=MAX0(1,ISKIP)
@


1.32
log
@*** empty log message ***
@
text
@d116 13
d229 1
a229 1
     $                        NSAM,NSAM,NROW,IMI,Q)
d242 1
a242 1
     $                        NSAM,NSAM,NROW,IMI,Q)
@


1.31
log
@memory allocation fixede
@
text
@d39 2
a40 3
         SUBROUTINE GALI(MAXMEM)

         PARAMETER  (NILMAX=10000)
d43 3
a45 4
         INCLUDE 'CMBLOCK.INC'  
C        INCLUDE '/net/ithaca/usr1/spider/src/CMBLOCK.INC'
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),BAF(1)
         EQUIVALENCE  (BAF,NUMR) 
a127 1

a129 1

a130 1

a178 1
        
@


1.30
log
@*** empty log message ***
@
text
@d214 3
d228 3
d248 3
a257 3
#ifdef SP_F90
         Q = >IPQ
#endif
@


1.29
log
@ff
@
text
@d42 2
a43 1
         INTEGER  NUMR(3,480) 
d147 1
a147 1
C       numr           1  !int*2
@


1.28
log
@cosmetic
@
text
@d42 1
a42 1
         INTEGER*2  NUMR(3,480) 
d63 1
a63 1
         INTEGER*2       MAXRIN
a67 2
CNO_SAVE
 
a68 1
 
a69 1
 
a71 1
 
a80 1

d191 1
a191 1
              K2=IPALIGN64(K1+(3*NRING+3)/2)
a262 1

a266 2

     
@


1.27
log
@*** empty log message ***
@
text
@d17 19
a35 19
C         SUBROUTINE GALI(MAXMEM)
C         SUBROUTINE  GALI_P(LSD,NSAM,NROW,NSI,ILIST,NIMA,MODE,JACUP,
C         SUBROUTINE  GETIMA_Q(X,LSD,NSAM,NROW,IMI,Q)
C         SUBROUTINE  ALROSI_Q(A,ATMP,B,C,REFER,LSD,NSAM,NROW,NSI,
C         SUBROUTINE  ALROSF_Q(A,ATMP,B,C,REFER,LSD,NSAM,NROW,NSI,
C         SUBROUTINE  RTQS_Q(X,OUT,LSD,NSAM,NROW,THETA,SHXI,SHYI)
C         SUBROUTINE  CROSRNG_Q
C         SUBROUTINE  SHFI_Q(X,OUT,LSD,NSAM,NROW,ISHX,ISHY)
C         SUBROUTINE  BLOB_Q(X,LSD,NSAM,NROW,NR)
C         SUBROUTINE  FINDMX_Q(D,LSD,NSAM,NROW,NSI,CMX,SX,SY)
C        SUBROUTINE  ALRQ_Q
C        SUBROUTINE  ALPRBS_Q(NUMR,NRING,LCIRC,MODE)
C        SUBROUTINE  FOURING_Q(CIRC,LCIRC,NUMR,NRING,EO,MODE)
C         SUBROUTINE  RTQ_Q(X,OUT,LSD,NSAM,NROW,THETA)
C         SUBROUTINE  CENT_Q(X,LSD,NSAM,NROW,SNS,SNR)
C         SUBROUTINE  OUTIM_Q(X,LSD,NSAM,NROW,IT)
C         SUBROUTINE  FMRS_1(X,N,INV)
C        SUBROUTINE  FMRS_1D(X,N,INV)
C      FUNCTION  QUADRI_Q(XX, YY, LSD, NXDATA, NYDATA, FDATA)
d61 4
a64 4
         CHARACTER*80  FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
         COMMON /MXR/ MAXRIN
         INTEGER*2  MAXRIN
         CHARACTER*1  NULL,MODE
d66 1
a66 1
         LOGICAL  INCORE
d75 1
a75 1
     &   'Enter template for 2-D image name',IRTFLG)
d77 1
a77 1
         CALL  FILERD(DOCFIL,NLETI,NULL,'Selection doc',IRTFLG)
d82 3
a84 3
         IF(NIMA.EQ.NILMAX)  THEN
         WRITE(NOUT,*) '  Too many images, list truncated'
         GOTO  779
d86 1
d89 5
a93 5
         IF(LERR.EQ.0)  THEN
         NIMA=NIMA+1
         ILIST(NIMA)=BUF(1)
         K=K+1
         GOTO  778
d95 1
d97 3
a99 3
         IF(NIMA.GT.0)  THEN
         WRITE(NOUT,2001) NIMA
2001     FORMAT('  Number of images =',i5)
d101 2
a102 2
         WRITE(NOUT,*)  '  No images !'
         RETURN
d106 3
a108 3
         IF(NF.NE.2)  THEN
         CALL ERRT(4,'AP SR ',NE)
         RETURN
d111 3
a113 3
C
	LSD=NSAM+2-MOD(NSAM,2)
C
d115 4
a118 4
         IF(NSI.GE.NSAM)  THEN
         WRITE(NOUT,*) ' Object size cannot be larger than window size'
         NSI=NSAM-2
         WRITE(NOUT,*) ' Object size set to',NSI
d124 2
a125 2
         NR=NSAM/2-1
         WRITE(NOUT,*)  ' Last ring limited to ',NR
d132 2
a133 2
         NRING=NRING+1
         NUMR(1,NRING)=I
d135 1
a135 1
C
d138 1
a138 1
C
d140 1
a140 1
C
d142 1
a142 1
     &   'Enter template for output',IRTFLG)
d144 2
a145 2
     &   'Enter template for output doc',IRTFLG)
C
d147 1
a147 1
C     & 'Precision of peak location (0..100)$')
d150 1
a150 1
C
d218 1
a218 1
              IF(IRTFLG.EQ.0) THEN 
d221 1
a221 1
                 WRITE(NOUT,*)  '   ***  In-core version  ***'
d231 1
a231 1
              WRITE(NOUT,*)  '   ***  In-core version  ***'
d246 1
a246 1
           IF(IRTFLG.EQ.0) THEN
d267 3
d271 1
d274 1
a274 2
2600     FORMAT (/' ',80('-')//' ',' Alignment,  ',
     #   'end of computation',//' ',80('-')/)
@


1.26
log
@f90 alloc
@
text
@d45 2
a46 2
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),KAF(1)
         EQUIVALENCE  (KAF,NUMR) 
d188 1
a188 1
        CALL CHKMEM(MEMTOT, KAF, (MAXMEM-(NILMAX+1024+80)), 
d214 1
a214 1
              CALL CHKMEM(MEMTOT, KAF, (MAXMEM-(NILMAX+1024+80)), 
d242 1
a242 1
           CALL CHKMEM(MEMTOT, KAF, (MAXMEM-(NILMAX+1024+80)), 
@


1.25
log
@call to getima_q fixed
@
text
@d47 5
d54 1
d252 3
@


1.24
log
@R
@
text
@d216 1
a216 1
     $                        NSAM,NSAM,NROW,IMI)
d226 1
a226 1
     $                        NSAM,NSAM,NROW,IMI)
@


1.23
log
@*** empty log message ***
@
text
@d97 1
a97 1
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'R',NF,NSL)
@


1.22
log
@procedures removeed
@
text
@d123 1
a123 1
         DO  1  I=MR,NR,ISKIP
d125 2
a126 1
1        NUMR(1,NRING)=I
@


1.21
log
@VMS blocked
@
text
@a0 6
#ifdef SP_VMS
         SUBROUTINE GALI(MAXMEM)
         INCLUDE 'CMBLOCK.INC' 
	WRITE(NOUT,*)  '  Command not supported'
	END 
#else
d18 4
a21 5
C         SUBROUTINE  GALI_P(NSAM,NROW,ILIST,NIMA,MODE,JACUP,
C         SUBROUTINE  GETIMA_Q(X,LSD,NSAM,NROW,IMI)
C      SUBROUTINE  ALROSI_Q(A,ATMP,B,C,REFER,LSD,NSAM,NROW,WRK,PARA,NOCHANGE,
C      SUBROUTINE  ALROSF(A,ATMP,B,C,REFER,LSD,NSAM,NROW,WRK,PARA,NOCHANGE,
C         CALL  RTQ_Q(ATMP,B,LSD,NSAM,NROW,ROTMP)
d23 1
a24 1
C         SUBROUTINE SUMAP(
d26 6
a31 2
C         SUBROUTINE  FINDMX_Q(D,LSD,NSAM,NROW,CMX,SX,SY)
C         SUBROUTINE  CROSRNG_Q
d33 3
a35 8
C         SUBROUTINE OUTPR(PARA,NIMA,IT)
C         SUBROUTINE  UPDF(C,A,OUT,N,IMI)
C         DOUBLE PRECISION FUNCTION  FNRM(X,N)
C         SUBROUTINE  ALPRBS_Q(NUMR,NRING,LCIRC,MODE)
C         SUBROUTINE  ALRQ_Q
C     &   (REFER,LSD,NSAM,NROW,NUMR,REFER_CIRC,LCIRC,NRING,MODE,IPIC)
C	  SUBROUTINE FOURING_Q(CIRC,LCIRC,NUMR,NRING,EO,MODE)
C         SUBROUTINE  CENT_Q(X,LSD,NSAM,NROW,SNS,SNR)
a261 1365
C++************************************************************************
C
C $$ GALI_P.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ GALI_P.FOR
C
         SUBROUTINE  GALI_P(LSD,NSAM,NROW,NSI,ILIST,NIMA,MODE,JACUP,
     &		WRK,A,B,C,D,E,REFER,
     &		REFERN,REFERTMP,IMAGE,PARA,
     &		A_CIRC,REFER_CIRC,LCIRC,
     &		NUMR,NRING,MAXRIN,TEMP,QM,
     &		NR,NOUT)
         DIMENSION  ILIST(NIMA)
      DIMENSION  REFER(LSD,NROW),REFERN(LSD,NROW),REFERTMP(LSD,NROW)
         DIMENSION  WRK(*),E(LSD,NROW)
         DIMENSION  A(LSD,NROW),B(LSD,NROW),C(LSD,NROW),D(LSD,NROW)
         DIMENSION  PARA(3,NIMA),QM(1)
         LOGICAL  CHANGE,NOCHANGE
         LOGICAL  IMAGE(NIMA)
         INTEGER*2  NUMR(3,NRING),MAXRIN
         DOUBLE PRECISION  TEMP(MAXRIN+2,2),FNRM,DNRM
         DIMENSION  A_CIRC(LCIRC),REFER_CIRC(LCIRC)
         CHARACTER*8  ZEIT
         CHARACTER*1  MODE
C -------------------------
c	PARAMETER  (LBUF=2050)
c	COMMON  /I_LIBFFT/  INIT,COEFF(LBUF)
c	LOGICAL  INIT
C -------------------------
         DATA  ZERO/0.0/
CNO_SAVE
C
         NSNR=LSD*NROW
C
C  Prepare 'blob'  to center input images ....
C
         CALL  BLOB_Q(D,LSD,NSAM,NROW,NR)
c	INIT=.TRUE.
         INS=1
         CALL  FMRS_2(D,NSAM,NROW,INS)
c	INIT=.FALSE.
         IF(INS.EQ.0)  THEN
	CALL    ERRT(38,'AP SR',NE)
         RETURN
         ENDIF
C
C  Build first average
C
C
         CALL  TIME(ZEIT)
         ISEED=MOD(ICHAR(ZEIT(4:4))+100*ICHAR(ZEIT(5:5))
     &   +1000*ICHAR(ZEIT(7:7))+10000*ICHAR(ZEIT(8:8)),340189)
C
C  IMAGE  is used here for the random selection of images
C
         DO  803  IMI=1,NIMA
803      IMAGE(IMI)=.FALSE.
         IMI=MIN0(NIMA,MAX0(1,JNINT(RAND_P(ISEED)*NIMA+0.5)))
C
         IMAGE(IMI)=.TRUE.
         PARA(1,IMI)=0.0
         PARA(2,IMI)=0.0
         PARA(3,IMI)=0.0
         CALL GETIMA_Q(A,LSD,NSAM,NROW,IMI,QM)
         CALL COP(A,B,NSNR)
         INS=1
         CALL  FMRS_2(B,NSAM,NROW,INS)
C
C  d - blob; b-current image; c-ccf.
C
         CALL  CCRS_2R(D,B,C,LSD/2,NSAM,NROW)
         CALL  FINDMX_Q(C,LSD,NSAM,NROW,NSI,CMX1,SX1,SY1)
C
         ISX1=SX1
         ISY1=SY1
         PARA(2,IMI)=ISX1
         PARA(3,IMI)=ISY1
         CALL  SHFI_Q(A,REFERN,LSD,NSAM,NROW,ISX1,ISY1)
c	print  *,' First image with blob',imi,isx1,isy1
         CALL  COP(REFERN,REFER,NSNR)
         CALL  ALRQ_Q
     &   (REFER,LSD,NSAM,NROW,NUMR,REFER_CIRC,LCIRC,NRING,MODE,IPIC)
         CALL  FOURING_Q
     &   (REFER_CIRC,LCIRC,NUMR,NRING,TEMP,MODE)
         INS=1
         CALL  FMRS_2(REFER,NSAM,NROW,INS)

C
C  go through all the remaining images.
C
         CHANGE=.FALSE.
         DO  802  KTN=2,NIMA
C
804      M=MIN0(NIMA,MAX0(1,JNINT(RAND_P(ISEED)*(NIMA-KTN+1)+0.5)))
         IMI=0
         DO  809  I=1,NIMA
         IF(IMAGE(I))  GOTO  809
         IMI=IMI+1
         IF(IMI.EQ.M)  GOTO  810
809      CONTINUE
         GOTO  804
810      IMI=I
         IMAGE(IMI)=.TRUE.
C
         CALL  GETIMA_Q(A,LSD,NSAM,NROW,IMI,QM)
         CALL COP(A,B,NSNR)
         INS=1
         CALL  FMRS_2(B,NSAM,NROW,INS)
C
C  d - blob; b-current image; c-ccf.
C
         CALL  CCRS_2R(D,B,C,LSD/2,NSAM,NROW)
         CALL  FINDMX_Q(C,LSD,NSAM,NROW,NSI,CMX1,SX1,SY1)
C
         ISX1=SX1
         ISY1=SY1
         PARA(1,IMI)=0.0
         PARA(2,IMI)=ISX1
         PARA(3,IMI)=ISY1
         CALL  SHFI_Q(A,B,LSD,NSAM,NROW,ISX1,ISY1)
Cc     print  *,' Next image with blob',imi,isx1,isy1
C
C run rotation-shift alignment
C
C
C  input:  three real images, a, b and refern
C  output: b - real aligned image, para - udated parameters
C          nochange=.true. - no change in the position of the image
C
         CALL  ALROSI_Q(A,B,D,C,REFER,LSD,NSAM,NROW,NSI,
     &   WRK,PARA(1,IMI),NOCHANGE,
     &   A_CIRC,REFER_CIRC,LCIRC,JACUP,NUMR,NRING,MAXRIN,TEMP,MODE,KTN)
         IF(.NOT.NOCHANGE)  CHANGE=.TRUE.
C
C  add image to the reference
C
802      CALL  UPDTF(REFERN,B,NSNR,KTN)
C
C  correct center
C
         CALL  CENT_Q(REFERN,LSD,NSAM,NROW,XS,YS)
         XS=XS-NSAM/2-1
         YS=YS-NROW/2-1
Cc    print *, '  Center correction  ',xs,ys
         CALL  RTQS_Q(REFERN,REFER,LSD,NSAM,NROW,ZERO,-XS,-YS)
         DO  814  IMI=1,NIMA
         PARA(2,IMI)=PARA(2,IMI)-XS
814      PARA(3,IMI)=PARA(3,IMI)-YS
C
         CALL  OUTIM_Q(REFER,LSD,NSAM,NROW,1)
         CALL  OUTPR(PARA,NIMA,1)
         TEMP(1,1)=FNRM(REFER,NSNR)
         I=1
         WRITE(NOUT,5091)  I,TEMP(1,1)
5091     FORMAT('  Iteration #',i5,'     Sum of squares=',1pd12.5)
C
C  if no changes terminate
C
         IF(.NOT.CHANGE)  GOTO  9901
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C  refine the alignment
C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
C
         ITER=0
         DNRM=0.0D0
991      CHANGE=.FALSE.
         ITER=ITER+1
c$doacross local(j,i)
         DO  907  J=1,NROW
         DO  907  I=1,LSD
907      REFERN(I,J)=0.0
c$doacross local(imi)
         DO  903  IMI=1,NIMA
903      IMAGE(IMI)=.FALSE.
C
         DO  902  KTN=1,NIMA
C
904      M=MIN0(NIMA,MAX0(1,JNINT(RAND_P(ISEED)*(NIMA-KTN+1)+0.5)))
         IMI=0
         DO  909  I=1,NIMA
         IF(IMAGE(I))  GOTO  909
         IMI=IMI+1
         IF(IMI.EQ.M)  GOTO  910
909      CONTINUE
         GOTO  904
910      IMI=I
         IMAGE(IMI)=.TRUE.
C
Cc      print *,' Image  #  ',imi
         CALL  GETIMA_Q(A,LSD,NSAM,NROW,IMI,QM)
	CALL  RTQS_Q
     &	(A,C,LSD,NSAM,NROW,PARA(1,IMI),PARA(2,IMI),PARA(3,IMI))
C
C subtract the image from the reference
         CALL  SUBAF(REFER,C,REFERTMP,NSNR,NIMA)
         CALL  COP(REFERTMP,E,NSNR)
C
C run rotation-shift alignment
C
C  input:  two real images, b and refer
C  output: c - real aligned image, para - udated parameters
C          nochange=.true. - no change in the position of the image
C
         CALL  ALROSF_Q(A,C,D,B,REFERTMP,LSD,NSAM,NROW,NSI,
     &   WRK,PARA(1,IMI),NOCHANGE,
     &   A_CIRC,REFER_CIRC,LCIRC,JACUP,NUMR,NRING,MAXRIN,TEMP,MODE)
         IF(.NOT.NOCHANGE)  THEN
         CHANGE=.TRUE.
C
C  add image to the reference
C
         CALL  UPDF(E,C,REFER,NSNR,NIMA)
         ENDIF
         CALL  UPDTF(REFERN,C,NSNR,KTN)
902      CONTINUE
C
C  correct center
C
         CALL  CENT_Q(REFERN,LSD,NSAM,NROW,XS,YS)
         XS=XS-NSAM/2-1
         YS=YS-NROW/2-1
         CALL  RTQS_Q(REFERN,REFER,LSD,NSAM,NROW,ZERO,-XS,-YS)
c$doacross local(imi)
         DO  914  IMI=1,NIMA
         PARA(2,IMI)=PARA(2,IMI)-XS
914      PARA(3,IMI)=PARA(3,IMI)-YS
C
         CALL  OUTIM_Q(REFER,LSD,NSAM,NROW,ITER+1)
         CALL  OUTPR(PARA,NIMA,ITER+1)
         TEMP(1,1)=FNRM(REFER,NSNR)
         WRITE(NOUT,5091)  ITER+1,TEMP(1,1)
         IF(TEMP(1,1).GE.DNRM)  THEN
         DNRM=TEMP(1,1)
         IF(CHANGE)  GOTO  991
         ENDIF
C
9901     CONTINUE
         END
C++************************************************************************
C
C  GETIMA_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************

         SUBROUTINE  GETIMA_Q(X,LSD,NSAM,NROW,IMI,Q)
         INCLUDE 'CMBLOCK.INC'
C        INCLUDE '/net/ithaca/usr1/spider/src/CMBLOCK.INC'
         PARAMETER  (NILMAX=10000)
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX)
         COMMON  /FISPEC/
     &   FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC,NLET,NLETI,NLIMA,NLDOC
         CHARACTER*80  FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
         CHARACTER*1  NULL
         DIMENSION  X(LSD,NROW),Q(1)
         COMMON  /CORE/  INCORE
         LOGICAL  INCORE
         DATA  INPIC/77/
CNO_SAVE

         IF(INCORE)  THEN
         LBASE=NSAM*NROW*(IMI-1)
c$doacross local(i,j)
         DO  J=1,NROW
         DO  I=1,NSAM
         X(I,J)=Q(I+(J-1)*NSAM+LBASE)
         ENDDO
         ENDDO
         ELSE
         L=ILIST(IMI)
         NULL=CHAR(0)
         CALL  FILGET(FINPAT,FINPIC,NLET,L,INTFLAG)
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAMT,NROWT,'R',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*)  ' FILE NOT FOUND:',FINPIC
         RETURN
         ENDIF
         DO  611  J=1,NROW
611      CALL  REDLIN(INPIC,X(1,J),NSAM,J)
         CLOSE(INPIC)
         ENDIF
         END
C++************************************************************************
C
C $$ ALROSI_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ ALROSI_Q.FOR
C
         SUBROUTINE  ALROSI_Q(A,ATMP,B,C,REFER,LSD,NSAM,NROW,NSI,
     &   WRK,PARA,NOCHANGE,
     &   A_CIRC,REFER_CIRC,LCIRC,JACUP,NUMR,NRING,MAXRIN,TEMP,MODE,KTN)
         DIMENSION   A(LSD,NROW),B(LSD,NROW),C(LSD,NROW)
         DIMENSION   REFER(LSD,NROW),ATMP(LSD,NROW),PARA(3),WRK(*)
         INTEGER*2  NUMR(3,NRING),MAXRIN
         DOUBLE PRECISION  TEMP(MAXRIN+2,2),TOTMIN
         DIMENSION  A_CIRC(LCIRC),REFER_CIRC(LCIRC)
         LOGICAL  NOCHANGE
         CHARACTER*1 MODE
CNO_SAVE
C
         NSNR=LSD*NROW
C
C  atmp has to be updated before the call
C
         ITER=0
         NOCHANGE=.FALSE.
101      ITER=ITER+1
         CALL  ALRQ_Q
     &   (ATMP,LSD,NSAM,NROW,NUMR,A_CIRC,LCIRC,NRING,MODE,IPIC)
         CALL  FOURING_Q
     &   (A_CIRC,LCIRC,NUMR,NRING,TEMP,MODE)

         CALL  CROSRNG_Q
     &   (REFER_CIRC,A_CIRC,LCIRC,NRING,TEMP,TEMP(1,2),
     &   MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)
C
         ROTMP=ANG(TOT,MODE)
         CALL  RTQ_Q(ATMP,B,LSD,NSAM,NROW,ROTMP)
C
         INS=1
         CALL  FMRS_2(B,NSAM,NROW,INS)
         CALL  CCRS_2R(REFER,B,C,LSD/2,NSAM,NROW)
         CALL  FINDMX_Q(C,LSD,NSAM,NROW,NSI,CMX1,SX1,SY1)
C
         DD=((COSD(ROTMP)-1.0)*NUMR(1,NRING)+SX1)**2
     &   +(SIND(ROTMP)*NUMR(1,NRING)+SY1)**2
         IF(DD.LT.0.25 )  THEN
         IF(ITER.EQ.1)  NOCHANGE=.TRUE.
C
C next line would be used for non-zero tot only
C     call  updtc(refer_circ,a_circ,lcirc,nring,numr,tot,maxrin,ktn)
C
         CALL  UPDTF(REFER_CIRC,A_CIRC,LCIRC,KTN)
         CALL  UPDTF(REFER,B,NSNR,KTN)
         RETURN
         ENDIF
C
         CALL  SUMAP(PARA(1),PARA(2),PARA(3),ROTMP,SX1,SY1,P1,P2,P3)
         PARA(1)=P1
         PARA(2)=P2
         PARA(3)=P3
         CALL  RTQS_Q(A,ATMP,LSD,NSAM,NROW,PARA(1),PARA(2),PARA(3))
         IF(ITER.GT.25)  RETURN
         GOTO 101
         END
C++************************************************************************
C
C $$ ALROSF_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ ALROSF_Q.FOR
C
         SUBROUTINE  ALROSF_Q(A,ATMP,B,C,REFER,LSD,NSAM,NROW,NSI,
     &   WRK,PARA,NOCHANGE,
     &   A_CIRC,REFER_CIRC,LCIRC,JACUP,NUMR,NRING,MAXRIN,TEMP,MODE)
         DIMENSION   A(LSD,NROW),B(LSD,NROW),C(LSD,NROW)
         DIMENSION   REFER(LSD,NROW),ATMP(LSD,NROW),PARA(3),WRK(*)
         INTEGER*2  NUMR(3,NRING),MAXRIN
         DOUBLE PRECISION  TEMP(MAXRIN+2,2),TOTMIN
         DIMENSION  A_CIRC(LCIRC),REFER_CIRC(LCIRC)
         LOGICAL  NOCHANGE
         CHARACTER*1 MODE
CNO_SAVE
C
         NSNR=NSAM*NROW
C
         CALL  ALRQ_Q
     &   (REFER,LSD,NSAM,NROW,NUMR,REFER_CIRC,LCIRC,NRING,MODE,IPIC)
         CALL  FOURING_Q
     &   (REFER_CIRC,LCIRC,NUMR,NRING,TEMP,MODE)
         INS=1
         CALL  FMRS_2(REFER,NSAM,NROW,INS)
C
C  atmp has to be updated before the call
C     call  rtqs(a,atmp,nsam,nrow,para(1),para(2),para(3))
C
         ITER=0
         NOCHANGE=.FALSE.
101      ITER=ITER+1
         CALL  ALRQ_Q
     &   (ATMP,LSD,NSAM,NROW,NUMR,A_CIRC,LCIRC,NRING,MODE,IPIC)
         CALL  FOURING_Q
     &   (A_CIRC,LCIRC,NUMR,NRING,TEMP,MODE)

         CALL  CROSRNG_Q
     &   (REFER_CIRC,A_CIRC,LCIRC,NRING,TEMP,TEMP(1,2),
     &   MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)
C
         ROTMP=ANG(TOT,MODE)
         CALL  RTQ_Q(ATMP,B,LSD,NSAM,NROW,ROTMP)
C
         INS=1
         CALL  FMRS_2(B,NSAM,NROW,INS)
         CALL  CCRS_2R(REFER,B,C,LSD/2,NSAM,NROW)
         CALL  FINDMX_Q(C,LSD,NSAM,NROW,NSI,CMX1,SX1,SY1)
C
         DD=((COSD(ROTMP)-1.0)*NUMR(1,NRING)+SX1)**2
     &   +(SIND(ROTMP)*NUMR(1,NRING)+SY1)**2
         IF(DD.LT.0.25) THEN
         IF(ITER.EQ.1)  NOCHANGE=.TRUE.
         RETURN
         ENDIF
C
         CALL  SUMAP(PARA(1),PARA(2),PARA(3),ROTMP,SX1,SY1,P1,P2,P3)
         PARA(1)=P1
         PARA(2)=P2
         PARA(3)=P3
         CALL  RTQS_Q(A,ATMP,LSD,NSAM,NROW,PARA(1),PARA(2),PARA(3))
         IF(ITER.GT.25)  RETURN
         GOTO 101
         END
C++************************************************************************
C
C $$ RTQS_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ RTQS_Q.FOR
C
         SUBROUTINE  RTQS_Q(X,OUT,LSD,NSAM,NROW,THETA,SHXI,SHYI)
         DIMENSION  X(LSD,NROW),OUT(LSD,NROW)
CNO_SAVE
C
         SHX=AMOD(SHXI,FLOAT(NSAM))
         SHY=AMOD(SHYI,FLOAT(NROW))
         ICENT=NROW/2+1
         KCENT=NSAM/2+1
         RN2=-NROW/2
         SN2=-NSAM/2
         RW2=-RN2
         RS2=-SN2
         IF(MOD(NSAM,2).EQ.0)  RW2=RW2-1.0
         IF(MOD(NROW,2).EQ.0)  RS2=RS2-1.0
         COD=COSD(THETA)
         SID=SIND(THETA)
c$doacross local(i,k,yi,ycod,ysid,xi,xold,yold)
         DO  2  I=1,NROW
         YI=I-ICENT-SHY
         IF(YI.LT.RN2)  YI=AMIN1(RW2+YI-RN2+1.0,RW2)
         IF(YI.GT.RW2)  YI=AMAX1(RN2+YI-RW2-1.0,RN2)
         YCOD=YI*COD+ICENT
         YSID=-YI*SID+KCENT
         DO  3  K=1,NSAM
         XI=K-KCENT-SHX
         IF(XI.LT.SN2)  XI=AMIN1(RS2+XI-SN2+1.0,RS2)
         IF(XI.GT.RS2)  XI=AMAX1(SN2+XI-RS2-1.0,SN2)
         YOLD=XI*SID+YCOD
         XOLD=XI*COD+YSID
         OUT(K,I)=QUADRI_Q(XOLD, YOLD, LSD ,NSAM, NROW, X)
3        CONTINUE
2        CONTINUE
         END
C++************************************************************************
C
C $$ CROSRNG_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ CROSRNG_Q.FOR
C
         SUBROUTINE  CROSRNG_Q
     &   (CIRC1,CIRC2,LCIRC,NRING,T,Q,MAXRIN,JACUP,NUMR,QN,TOT,MODE)
C
C  INPUT - Fourier transforms of rings!!!
C
C  NUMR(3,I) - ACTUAL LENGTH +2 (to use new FFT)
C  CIRC - FT of rings stored as:
C  Re(0), 0, Re(1) Im(1), ..., Re((NUMR(3,I)-2)/2), 0.
         INTEGER*2  NUMR(3,NRING),NUMR2I,NUMR3I,MAXRIN
         DIMENSION  CIRC1(LCIRC),CIRC2(LCIRC)
         DOUBLE PRECISION  T(MAXRIN+2),Q(MAXRIN+2)
         DOUBLE PRECISION  QN,QT,PI,T7(-3:3)
         CHARACTER*1  MODE
CNO_SAVE
	PI=4.0*DATAN(1.0D0)
	IF(MODE.EQ.'F')  PI=2*PI
C
	DO  11  J=1,MAXRIN
11	Q(J)=0.0D0
C
	DO  1  I=1,NRING
	NUMR3I=NUMR(3,I)-2
	NUMR2I=NUMR(2,I)
	WR=FLOAT(NUMR(1,I))*PI/FLOAT(NUMR3I)*FLOAT(MAXRIN)/FLOAT(NUMR3I)
C
	DO  31  J=1,NUMR3I+2,2
	JC=J+NUMR2I-1
	T(J)=DBLE(CIRC1(JC))*CIRC2(JC)+DBLE(CIRC1(JC+1))*CIRC2(JC+1)
      T(J+1)=-DBLE(CIRC1(JC))*CIRC2(JC+1)+DBLE(CIRC1(JC+1))*CIRC2(JC)
31	CONTINUE
	IF(NUMR3I.LT.MAXRIN)  T(NUMR3I+1)=T(NUMR3I+1)/2.0
C###
	DO  44  J=1,NUMR3I+1
44	Q(J)=Q(J)+T(J)*WR
1	CONTINUE
C
	INV=-1
	IP=MAXRIN
	CALL  FMRS_1D(Q,IP,INV)
C
         QN=-1.0D20
         DO  20  J=1,MAXRIN
         IF(Q(J).GE.QN)  THEN
         QN=Q(J)
         JTOT=J
         ENDIF
20       CONTINUE
C
         DO  81  K=-3,3
         J=MOD(JTOT+K+MAXRIN-1,MAXRIN)+1
81       T7(K)=Q(J)
         CALL  PRB1D(T7,7,POS)
         TOT=FLOAT(JTOT)+POS
         END
C++************************************************************************
C
C $$ SHFI_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ SHFI_Q.FOR
C
         SUBROUTINE  SHFI_Q(X,OUT,LSD,NSAM,NROW,ISHX,ISHY)
         DIMENSION  X(LSD,NROW),OUT(LSD,NROW)
         INTEGER  RN2,SN2,RW2,RS2,XI,YI,SHX,SHY,YOLD,XOLD
CNO_SAVE
C
         SHX=MOD(ISHX,NSAM)
         SHY=MOD(ISHY,NROW)
         ICENT=NROW/2+1
         KCENT=NSAM/2+1
         RN2=-NROW/2
         SN2=-NSAM/2
         RW2=-RN2
         RS2=-SN2
         IF(MOD(NSAM,2).EQ.0)  RW2=RW2-1
         IF(MOD(NROW,2).EQ.0)  RS2=RS2-1
c$doacross local(i,k,yi,yold,xi,xold)
         DO  2  I=1,NROW
         YI=I-ICENT-SHY
         IF(YI.LT.RN2)  YI=MIN0(RW2+YI-RN2+1,RW2)
         IF(YI.GT.RW2)  YI=MAX0(RN2+YI-RW2-1,RN2)
         YOLD=YI+ICENT
         DO  3  K=1,NSAM
         XI=K-KCENT-SHX
         IF(XI.LT.SN2)  XI=MIN0(RS2+XI-SN2+1,RS2)
         IF(XI.GT.RS2)  XI=MAX0(SN2+XI-RS2-1,SN2)
         XOLD=XI+KCENT
         OUT(K,I)=X(XOLD, YOLD)
3        CONTINUE
2        CONTINUE
         END
C++************************************************************************
C
C $$ BLOB_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ BLOB_Q.FOR
C
         SUBROUTINE  BLOB_Q(X,LSD,NSAM,NROW,NR)
         DIMENSION   X(LSD,NROW)
CNO_SAVE
	PI=4.0*DATAN(1.0D0)
         RR=NR*NR
         NO=NROW/2+1
         NS=NSAM/2+1
c$doacross local(j,i,r,r2)
         DO J=1,NROW
         R=(J-NO)*(J-NO)
         DO I=1,LSD
         R2=R+(I-NS)*(I-NS)
         IF(R2.GT.RR)  THEN
         X(I,J)=0.0
         ELSE
         X(I,J)=(COS(SQRT(R2/RR)*PI)+1.0)*0.5
         ENDIF
         ENDDO
         ENDDO
         END
C++************************************************************************
C
C $$ FINDMX_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ FINDMX_Q.FOR
C
         SUBROUTINE  FINDMX_Q(D,LSD,NSAM,NROW,NSI,CMX,SX,SY)
         DIMENSION  D(LSD,NROW),Z(-1:1,-1:1)
         LOGICAL  FOUND
CNO_SAVE
         FOUND=.FALSE.
         JC=NROW/2+1
         IC=NSAM/2+1
         CMX=D(IC,JC)
         SX=0.0
         SY=0.0
         DO  1  JT=-NSI,NSI
         J=JT+JC
         DO  1  IT=-NSI,NSI
         I=IT+IC
         IF(CMX.LT.D(I,J))  THEN
         CMX=D(I,J)
         IX=I
         IY=J
         FOUND=.TRUE.
         ENDIF
1        CONTINUE
         IF(.NOT.FOUND)  RETURN
         SX=IX-IC
         SY=IY-JC
         IF(IY.LT.2.OR.IY.GT.NROW-1.OR.IX.LT.2.OR.IX.GT.NSAM-1) RETURN
         DO  81  J=-1,1
         DO  81  I=-1,1
81       Z(I,J)=D(IX+I,IY+J)
         CALL  PARABL(Z,XSH,YSH,CMX)
         SX=SX+XSH
         SY=SY+YSH
         END
C++************************************************************************
C
C $$ ALRQ_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ ALRQ_Q.FOR
C
        SUBROUTINE  ALRQ_Q
     &  (XIM,LSD,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,IPIC)
        DIMENSION  XIM(LSD,NROW),CIRC(LCIRC)
        INTEGER*2  NUMR(3,NRING)
        CHARACTER*1  MODE
        DOUBLE PRECISION  PI,DFI
CNO_SAVE
C
C  INTERPOLATION INTO POLAR COORDINATES
C
c$doacross local(i)
        DO  10  I=1,LCIRC
 10     CIRC(I)=0.0
C
        NS2=NSAM/2+1
        NR2=NROW/2+1
        PI=2*DATAN(1.0D0)
c$doacross local(i,j,inr,yq,l,lt,nsim,dfi,kcirc,xold,yold,fi,x,y)
        DO  20  I=1,NRING
C
C  RADIUS OF THE RING
        INR=NUMR(1,I)
        YQ=INR
C The actual, power-of-two length is NUMR(3,I)-2, additional
C two locations are only for the new FFT.
        L=NUMR(3,I)-2
        IF(MODE.EQ.'H')  THEN
        LT=L/2
        ENDIF
        IF(MODE.EQ.'F')  THEN
        LT=L/4
        ENDIF
        NSIM=LT-1
        DFI=PI/(NSIM+1)
        KCIRC=NUMR(2,I)
        XOLD=0.0
        YOLD=INR
        CIRC(KCIRC)=QUADRI_Q(XOLD+NS2,YOLD+NR2,LSD,NSAM,NROW,XIM)
        XOLD=INR
        YOLD=0.0
        CIRC(LT+KCIRC)=QUADRI_Q(XOLD+NS2,YOLD+NR2,LSD,NSAM,NROW,XIM)
        IF(MODE.EQ.'F')  THEN
        XOLD=0.0
        YOLD=-INR
        CIRC(LT+LT+KCIRC)=QUADRI_Q(XOLD+NS2,YOLD+NR2,LSD,NSAM,NROW,XIM)
        XOLD=-INR
        YOLD=0.0
        CIRC(LT+LT+LT+KCIRC)=
     &		QUADRI_Q(XOLD+NS2,YOLD+NR2,LSD,NSAM,NROW,XIM)
        ENDIF
        DO  20  J=1,NSIM
        FI=DFI*J
        X=SIN(FI)*YQ
        Y=COS(FI)*YQ
C
        XOLD=X
        YOLD=Y
        CIRC(J+KCIRC)=QUADRI_Q(XOLD+NS2,YOLD+NR2,LSD,NSAM,NROW,XIM)
        XOLD=Y
        YOLD=-X
        CIRC(J+LT+KCIRC)=QUADRI_Q(XOLD+NS2,YOLD+NR2,LSD,NSAM,NROW,XIM)
        IF(MODE.EQ.'F')  THEN
        XOLD=-X
        YOLD=-Y
        CIRC(J+LT+LT+KCIRC)=
     &		QUADRI_Q(XOLD+NS2,YOLD+NR2,LSD,NSAM,NROW,XIM)
        XOLD=-Y
        YOLD=X
        CIRC(J+LT+LT+LT+KCIRC)=
     &		QUADRI_Q(XOLD+NS2,YOLD+NR2,LSD,NSAM,NROW,XIM)
        ENDIF
 20     CONTINUE
C
        END
C++************************************************************************
C
C $$ ALPRBS_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ ALPRBS_Q.FOR
C
        SUBROUTINE  ALPRBS_Q(NUMR,NRING,LCIRC,MODE)
C
C  NUMR(1,I) - ring number
C  NUMR(2,I) - beginning in CIRC
C  NUMR(3,I) - length in CIRC +2
C  LCIRC - total length of CIRC
C
        INTEGER*2  NUMR(3,NRING)
        REAL*8  PI
        CHARACTER*1  MODE
CNO_SAVE
C
C  PREPARATION OF PARAMETERS
C
        PI=4.0*DATAN(1.0D0)
        IF(MODE.EQ.'F')  PI=2*PI
        LCIRC=0
        DO  1  I=1,NRING
        JP=PI*NUMR(1,I)
        IP=2**LOG2_P(JP)
        IF(I.LT.NRING.AND.JP.GT.IP+IP/2)  IP=MIN0(1024,2*IP)
C
C  Last ring should be oversampled to allow higher accuracy
C  of peak location (?).
C
        IF(I.EQ.NRING.AND.JP.GT.IP+IP/5)  IP=MIN0(1024,2*IP)
C  All the rings are power-of-two.  Increase by 2 to be able
C  to use new FFT.
        NUMR(3,I)=IP+2
        IF(I.EQ.1)  THEN
        NUMR(2,1)=1
        ELSE
        NUMR(2,I)=NUMR(2,I-1)+NUMR(3,I-1)
        ENDIF
        LCIRC=LCIRC+IP+2
 1      CONTINUE
        END
C++************************************************************************
C
C $$ FOURING_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ FOURING_Q.FOR
C
        SUBROUTINE  FOURING_Q(CIRC,LCIRC,NUMR,NRING,EO,MODE)
        INTEGER*2  NUMR(3,NRING)
        DIMENSION  CIRC(LCIRC)
        CHARACTER*1  MODE
        DOUBLE PRECISION  E,EO,QT,PI
CNO_SAVE
        PI=4.0*DATAN(1.0D0)
        IF(MODE.EQ.'F')  PI=2*PI
        E=0.0
c$doacross local(i,j,nsirt,qt,l),reduction(e)
        DO  201  I=1,NRING
        NSIRT=NUMR(3,I)-2
        QT=FLOAT(NUMR(1,I))*PI/FLOAT(NSIRT)
        DO  201  J=NUMR(2,I),NUMR(2,I)+NSIRT-1
201     E=E+QT*DBLE(CIRC(J))*CIRC(J)
        EO=E
c$doacross local(i,nsirt,inv)
        DO  202  I=1,NRING
	INV=+1
        NSIRT=NUMR(3,I)-2
        CALL  FMRS_1(CIRC(NUMR(2,I)),NSIRT,INV)
202     CONTINUE
        END
C++************************************************************************
C
C $$ RTQ_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C--************************************************************************
C
C $$ RTQ_Q.FOR
C
         SUBROUTINE  RTQ_Q(X,OUT,LSD,NSAM,NROW,THETA)
         DIMENSION  X(LSD,NROW),OUT(LSD,NROW)
CNO_SAVE
C
         IF(THETA.EQ.0.0)  THEN
         CALL  COP(X,OUT,LSD*NROW)
         RETURN
         ENDIF
         ICENT=NROW/2+1
         KCENT=NSAM/2+1
         RN2=-NROW/2
         SN2=-NSAM/2
         RW2=-RN2
         RS2=-SN2
         IF(MOD(NSAM,2).EQ.0)  RW2=RW2-1.0
         IF(MOD(NROW,2).EQ.0)  RS2=RS2-1.0
         COD=COSD(THETA)
         SID=SIND(THETA)
c$doacross local(i,k,yi,ycod,ysid,xi,xold,yold)
         DO  2  I=1,NROW
         YI=I-ICENT
         IF(YI.LT.RN2)  YI=AMIN1(RW2+YI-RN2+1.0,RW2)
         IF(YI.GT.RW2)  YI=AMAX1(RN2+YI-RW2-1.0,RN2)
         YCOD=YI*COD+ICENT
         YSID=-YI*SID+KCENT
         DO  3  K=1,NSAM
         XI=K-KCENT
         IF(XI.LT.SN2)  XI=AMIN1(RS2+XI-SN2+1.0,RS2)
         IF(XI.GT.RS2)  XI=AMAX1(SN2+XI-RS2-1.0,SN2)
         YOLD=XI*SID+YCOD
         XOLD=XI*COD+YSID
         OUT(K,I)=QUADRI_Q(XOLD, YOLD, LSD, NSAM, NROW, X)
3        CONTINUE
2        CONTINUE
         END
C++************************************************************************
C
C $$ CENT_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C
C
C--************************************************************************
C
C $$ CENT_Q.FOR
C
         SUBROUTINE  CENT_Q(X,LSD,NSAM,NROW,SNS,SNR)
         DIMENSION  X(LSD,NROW)
CNO_SAVE
C
         C=0.0
         S=0.0
         P=8*DATAN(1.0D0)/NSAM
c$doacross local(i,t,j),reduction(c,s)
         DO  1  I=1,NSAM
         T=0.0
         DO  11  J=1,NROW
11       T=T+X(I,J)
         C=C+COS(P*(I-1))*T
1        S=S+SIN(P*(I-1))*T
         FI=ATAN2(S,C)
         IF(FI.LT.0.0)  FI=FI+8*DATAN(1.0D0)
         SNS=FI/P+1.0
C
         C=0.0
         S=0.0
         P=8*DATAN(1.0D0)/NROW
c$doacross local(i,t,j),reduction(c,s)
         DO  2  J=1,NROW
         T=0.0
         DO  22  I=1,NSAM
22       T=T+X(I,J)
         C=C+COS(P*(J-1))*T
2        S=S+SIN(P*(J-1))*T
C
         FI=ATAN2(S,C)
         IF(FI.LT.0.0)  FI=FI+8*DATAN(1.0D0)
         SNR=FI/P+1.0
         END
C++************************************************************************
C
C    OUTIM_Q.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C
C  OUTIM_Q.FOR
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************

         SUBROUTINE  OUTIM_Q(X,LSD,NSAM,NROW,IT)

         INCLUDE 'CMBLOCK.INC'
C        INCLUDE '/net/ithaca/usr1/spider/src/CMBLOCK.INC'

         COMMON  DUMMY(80),BUF(1)
         COMMON  /FISPEC/
     &   FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC,NLET,NLETI,NLIMA,NLDOC

         CHARACTER*80  FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
         DIMENSION     X(LSD,NROW)
         DATA INPIC/69/
CNO_SAVE
 
         CALL  FILGET(OUTIMA,FINPIC,NLIMA,IT,INTFLAG)
         NSL   = 1
         IFORM = 1
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'UNKNOWN',NF,NSL)
         IF (NF.NE.2)  THEN
            CALL  ERRT(4,'OUTIM',NE)
            CLOSE(INPIC)
            RETURN
         ENDIF
         DO   J=1,NROW
             CALL  WRTLIN(INPIC,X(1,J),NSAM,J)
         ENDDO
         CLOSE(INPIC)
         END
C++************************************************************************
C
C $$ FMRS_1.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C  1D real mixed radix FFT.
C INPUT:  X(N) - real array
C OUTPUT: N even  X(N+2)
C   Order of elements:
C  R(0),0.0, R(1), I(1), R(2), I(2), ....., R(N/2-1), I(N/2-1), R(N/2),0.0
C
C         N odd  X(N+1)
C  R(0),0.0, R(1), I(1), R(2), I(2), ....., R(N/2-1), I(N/2-1), R(N/2),I(N/2-1)
C 
C INV: +1 forward FFT
C      -1 inverse FFT
C on output INV=0 indicates error
C
C--************************************************************************
C
C $$ FMRS_1.FOR
C
         SUBROUTINE  FMRS_1(X,N,INV)
         PARAMETER (LBUF=5000)
         DIMENSION  X(*),WORK(LBUF)
CNO_SAVE
#ifdef SP_LIBFFT
         IF(N+15.GT.LBUF)  THEN
         INV=0
C Insufficient buffer, increase LBUF and compile SPIDER
         CALL  ERRT(6,'FMRS_1',NE)
         RETURN
         ENDIF
	CALL  SCFFT1DUI(N,WORK)
	LDA=1
	IF(INV.GT.0)  THEN
	CALL  SCFFT1DU(INV,N,X,LDA,WORK)
	ELSE
	CALL  CSFFT1DU(INV,N,X,LDA,WORK)
	QT=1.0/FLOAT(N)
	CALL  SSCAL1D(N,QT,X,LDA)
	ENDIF
#else
         IF(N.GT.LBUF)  THEN
         INV=0
C Insufficient buffer, increase LBUF and compile SPIDER
         CALL  ERRT(6,'FMRS_1',NE)
         RETURN
         ENDIF
C inv can be +1 (forward FFT) or -1 (inverse FFT)
         IF(INV)  2,2,1
1        DO  11  I=1,N
11       WORK(I)=0.0
         CALL FFTMCF(X,WORK,N,N,N,INV)
         IF(MOD(N,2))  12,12,13
12       DO  14  I=N+1,3,-2
         X(I)=X((I+1)/2)
14       X(I+1)=WORK((I+1)/2)
         X(2)=0.0
         X(N+2)=0.0
         RETURN
13       DO  15  I=N,3,-2
         X(I)=X(I/2+1)
15       X(I+1)=WORK(I/2+1)
         X(2)=0.0
         RETURN
C
2        DO  27  I=2,N/2+1
         WORK(I)=X(2*I)/N
27       WORK(N-I+2)=-WORK(I)
         WORK(1)=0.0
C
         DO  28  I=1,N/2+1
28       X(I)=X(2*I-1)/N
         DO  29  I=N,N/2+2,-1
29       X(I)=X(N-I+2)
C
         CALL FFTMCF(X,WORK,N,N,N,INV)
#endif
         END
C++************************************************************************
C
C $$ FMRS_1D.FOR
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
C **************************************************************************
C  1D double precision mixed radix FFT.
C INPUT:  X(N) - real array
C OUTPUT: N even  X(N+2)
C   Order of elements:
C  R(0),0.0, R(1), I(1), R(2), I(2), ....., R(N/2-1), I(N/2-1), R(N/2),0.0
C
C         N odd  X(N+1)
C  R(0),0.0, R(1), I(1), R(2), I(2), ....., R(N/2-1), I(N/2-1), R(N/2),I(N/2-1)
C 
C INV: +1 forward FFT
C      -1 inverse FFT
C on output INV=0 indicates error
C
C--************************************************************************
C
C $$ FMRS_1D.FOR
C
	SUBROUTINE  FMRS_1D(X,N,INV)
	PARAMETER (LBUF=5000)
	DOUBLE PRECISION  X(*),WORK(LBUF),QT
CNO_SAVE
#ifdef SP_LIBFFT
	IF(N+15.GT.LBUF)  THEN
	INV=0
C Insufficient buffer, increase LBUF and compile SPIDER
	CALL  ERRT(6,'FMRS_1',NE)
	RETURN
	ENDIF
	CALL  DZFFT1DUI(N,WORK)
	LDA=1
	IF(INV.GT.0)  THEN
	CALL  DZFFT1DU(INV,N,X,LDA,WORK)
	ELSE
	CALL  ZDFFT1DU(INV,N,X,LDA,WORK)
	QT=1.0D0/FLOAT(N)
	CALL  DSCAL1D(N,QT,X,LDA)
	ENDIF
#else
	IF(INV.LT.0)  THEN
	IP=-LOG2_P(N)
C  Get old format
	X(2)=X(N+1)
	ELSE
	IP=LOG2_P(N)
	ENDIF
	CALL  FFTR_D(X,IP)
	IF(INV.GT.0)  THEN
	X(N+1)=X(2)
	X(2)=0.0
	X(N+2)=0.0
	ENDIF
#endif
	END
C
      FUNCTION  QUADRI_Q(XX, YY, LSD, NXDATA, NYDATA, FDATA)
C  Quadratic interpolation
C  XX,YY treated as circularly closed.
C  fdata - image 1..nxdata, 1..nydata
C
C
C                                  SPECIFICATIONS FOR ARGUMENTS
      DIMENSION  FDATA(LSD,NYDATA)
CNO_SAVE
C
C                    F3    FC       F0, F1, F2, F3 are the values
C                     +             at the grid points.  X is the
C                     + X           point at which the function
C              F2++++F0++++F1       is to be estimated. (It need
C                     +             not be in the First quadrant).
C                     +             FC - the outer corner point
C                    F4             nearest X.
C
C                                   F0 is the value of the FDATA at
C                                   FDATA(I,J), it is the interior mesh
C                                   point nearest  X.
C                                   The coordinates of F0 are (X0,Y0),
C                                   The coordinates of F1 are (XB,Y0),
C                                   The coordinates of F2 are (XA,Y0),
C                                   The coordinates of F3 are (X0,YB),
C                                   The coordinates of F4 are (X0,YA),
C                                   The coordinates of FC are (XC,YC),
C
	x=xx
	y=yy
	if(x.lt.1.0)  x=x+(1-ifix(x)/nxdata)*nxdata
	if(x.gt.float(nxdata)+0.5)  x=amod(x-1.0,float(nxdata))+1.0
	if(y.lt.1.0)  y=y+(1-ifix(y)/nydata)*nydata
	if(y.gt.float(nydata)+0.5)  y=amod(y-1.0,float(nydata))+1.0
	i=IFIX(x)
	j=IFIX(y)
C
      X0 = I
      Y0 = J
      XA = I-1
      XB = I+1
      YA = J-1
      YB = J+1
C
      DX0 = X - X0
      DY0 = Y - Y0
C
      DXB = X - XB
      DYB = Y - YB
C
	ip1=i+1
	im1=i-1
	jp1=j+1
	jm1=j-1
      F0 = FDATA(I,J)
	if(ip1.gt.nxdata) ip1=ip1-nxdata	
      F1 = FDATA(Ip1,J)
	if(im1.lt.1)  im1=im1+nxdata
      F2 = FDATA(Im1,J)
	if(jp1.gt.nydata) jp1=jp1-nydata	
      F3 = FDATA(I,Jp1)
	if(jm1.lt.1)  jm1=jm1+nydata
      F4 = FDATA(I,Jm1)
C
      IC = I + INT(SIGN(1.0,DX0))
      JC = J + INT(SIGN(1.0,DY0))
C
      XC = IC
      YC = JC
	if(ic.gt.nxdata) then
	ic=ic-nxdata	
	elseif(ic.lt.1)  then
	ic=ic+nxdata
	endif
	if(jc.gt.nydata)  then
	jc=jc-nydata
	elseif(jc.lt.1)  then
	jc=jc+nydata
	endif
      FC = FDATA(IC,JC)
C                       O               HXA, HXB are the mesh spacings
C                       +               in the X-direction to the left
C                      HYB              and right of the center point.
C                       +
C               O++HXA++O++HXB++O       HYB, HYA are the mesh spacings
C                       +               in the Y-direction.
C                      HYA
C                       +               HXC equals either  HXB  or  HXA
C                       O               depending on where the corner
C                                       point is located.
C
      HXA = X0 - XA
      HXB = XB - X0
      HYA = Y0 - YA
      HYB = YB - Y0
C
      HXC = XC - X0
      HYC = YC - Y0
C
      HXCB = XC - XB
      HYCB = YC - YB
C                                       Construct the interpolant
C                                       F = F0 + C1*(X-X0) +
C                                           C2*(X-X0)*(X-X1) +
C                                           C3*(Y-Y0) + C4*(Y-Y0)*(Y-Y1)
C                                           + C5*(X-X0)*(Y-Y0)
      C1 = (F1-F0)/HXB
      T1 = (F0-F2)/HXA
      C2 = (C1-T1)/(HXA+HXB)
      C3 = (F3-F0)/HYB
      T3 = (F0-F4)/HYA
      C4 = (C3-T3)/(HYA+HYB)
      C5 = (FC-F0-HXC*C1-HXC*HXCB*C2-HYC*C3-HYC*HYCB*C4)/(HXC*HYC)
C
      QUADRI_Q = F0 + DX0*(C1+DXB*C2+DY0*C5) + DY0*(C3+DYB*C4)
      END
#endif
@


1.20
log
@*** empty log message ***
@
text
@d1 6
d1634 1
@


1.19
log
@ipalign64
@
text
@d1125 1
a1125 1
C  NUMR(3,I) - length in CIRC
@


1.18
log
@FMRS_1D CORRECTED
@
text
@d43 2
a44 2
         PARAMETER  (NILMAX=9998)
         INTEGER*2  NUMR(3,1000) 
d165 14
a178 42
        K3=K2+NIMA
        K3=K3/2
        K3=K3*2+1
        K4=K3+3*NIMA
        K4=K4/2
        K4=K4*2+1
        K5=K4+MAX0(NSAM,2*NROW)
        K5=K5/2
        K5=K5*2+1
        K6=K5+LSD*NROW
        K6=K6/2
        K6=K6*2+1
        K7=K6+LSD*NROW
        K7=K7/2
        K7=K7*2+1
        K8=K7+LSD*NROW
        K8=K8/2
        K8=K8*2+1
        K9=K8+LSD*NROW
        K9=K9/2
        K9=K9*2+1
        K10=K9+LSD*NROW
        K10=K10/2
        K10=K10*2+1
        K11=K10+LSD*NROW
        K11=K11/2
        K11=K11*2+1
        K12=K11+LSD*NROW
        K12=K12/2
        K12=K12*2+1
        K13=K12+4*(MAXRIN+2)
        K13=K13/2
        K13=K13*2+1
        K14=K13+LCIRC
        K14=K14/2
        K14=K14*2+1
        K15=K14+LCIRC
        K15=K15/2
        K15=K15*2+1
        K16=K15+LSD*NROW
        K16=K16/2
        K16=K16*2+1
d190 15
a204 45
              K2=K1+(3*NRING+3)/2
              K2=K2/2
              K2=K2*2+1
              K3=K2+NIMA
              K3=K3/2
              K3=K3*2+1
              K4=K3+3*NIMA
              K4=K4/2
              K4=K4*2+1
              K5=K4+MAX0(NSAM,2*NROW)
              K5=K5/2
              K5=K5*2+1
              K6=K5+LSD*NROW
              K6=K6/2
              K6=K6*2+1
              K7=K6+LSD*NROW
              K7=K7/2
              K7=K7*2+1
              K8=K7+LSD*NROW
              K8=K8/2
              K8=K8*2+1
              K9=K8+LSD*NROW
              K9=K9/2
              K9=K9*2+1
              K10=K9+LSD*NROW
              K10=K10/2
              K10=K10*2+1
              K11=K10+LSD*NROW
              K11=K11/2
              K11=K11*2+1
              K12=K11+LSD*NROW
              K12=K12/2
              K12=K12*2+1
              K13=K12+4*(MAXRIN+2)
              K13=K13/2
              K13=K13*2+1
              K14=K13+LCIRC
              K14=K14/2
              K14=K14*2+1
              K15=K14+LCIRC
              K15=K15/2
              K15=K15*2+1
              K16=K15+LSD*NROW
              K16=K16/2
              K16=K16*2+1
d539 1
a539 1
         PARAMETER  (NILMAX=9998)
@


1.17
log
@corrected
@
text
@d1554 1
d1558 3
d1562 5
@


1.16
log
@new version, uses libfft, for the time being contains all the procedures
@
text
@d41 1
a41 1
	SUBROUTINE GALI(MAXMEM)
d43 4
a46 4
	PARAMETER  (NILMAX=9998)
	INTEGER*2  NUMR(3,1000) 
	INCLUDE 'CMBLOCK.INC'  
C         INCLUDE '/net/ithaca/usr1/spider/src/CMBLOCK.INC'
d275 1
a275 1
     $                        LSD,NSAM,NROW,IMI)
d362 3
a364 3
	PARAMETER  (LBUF=2050)
	COMMON  /I_LIBFFT/  INIT,COEFF(LBUF)
	LOGICAL  INIT
d374 1
a374 1
	INIT=.TRUE.
d377 1
a377 1
	INIT=.FALSE.
a511 1
C
d706 1
a706 4
         IF(ITER.GT.25)  then
	print  *,' alrosi =25'
	RETURN
	endif
d786 1
a786 4
         IF(ITER.GT.25)  then
	print  *,' alrosf =25'
	RETURN
	endif
a1054 1
	if(lsd.ne.0) return
@


1.15
log
@remove extra unreachable return statement.
@
text
@d12 1
a12 1
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
d19 6
a24 5
C         SUBROUTINE  GETIMA(X,NSAM,NROW,IMI)
C      SUBROUTINE  ALROSI(A,ATMP,B,C,REFER,NSAM,NROW,WRK,PARA,NOCHANGE,
C      SUBROUTINE  ALROSF(A,ATMP,B,C,REFER,NSAM,NROW,WRK,PARA,NOCHANGE,
C         SUBROUTINE  RTQS(X,OUT,NSAM,NROW,THETA,SHXI,SHYI)
C         SUBROUTINE  SHFI_2(X,OUT,NSAM,NROW,ISHX,ISHY)
d26 4
a29 4
C         SUBROUTINE  BLOB(X,NSAM,NROW,NR)
C         SUBROUTINE  FINDMX_F(D,NSAM,NROW,CMX,SX,SY,JACUP)
C         SUBROUTINE  CROSRNG_F
C         SUBROUTINE  OUTIM(X,NSAM,NROW,IT)
d33 5
d41 1
a41 1
         SUBROUTINE GALI(MAXMEM)
d43 4
a46 3
         PARAMETER  (NILMAX=9998)
         INTEGER*2  NUMR(3,1000) 
         INCLUDE 'CMBLOCK.INC'  
d52 1
a52 1
	 
d106 2
d116 1
a116 1
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING$')
d129 2
a130 2
         CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)
d166 1
a166 1
	K3=K3/2
d169 1
a169 1
	K4=K4/2
d172 1
a172 1
	K5=K5/2
d174 2
a175 2
        K6=K5+NSAM*NROW
	K6=K6/2
d177 2
a178 2
        K7=K6+NSAM*NROW
	K7=K7/2
d180 2
a181 2
        K8=K7+NSAM*NROW
	K8=K8/2
d183 2
a184 2
        K9=K8+NSAM*NROW
	K9=K9/2
d186 2
a187 2
        K10=K9+NSAM*NROW
	K10=K10/2
d189 2
a190 2
        K11=K10+NSAM*NROW
	K11=K11/2
d192 2
a193 2
        K12=K11+NSAM*NROW
	K12=K12/2
d195 2
a196 2
        K13=K12+4*MAXRIN
	K13=K13/2
d199 1
a199 1
	K14=K14/2
d202 1
a202 1
	K15=K15/2
d204 2
a205 2
        K16=K15+NSAM*NROW
	K16=K16/2
d209 2
a210 2
	MEMTOT=L_MAINBUF+NSAM*NROW*NIMA
	
d212 2
a213 2
     &	            RUNTIME,IPQ,IRTFLG)
	IF(IRTFLG.EQ.0) THEN
d215 2
a216 2
	   
C	      COULD NOT HAVE DYNAMIC MEMORY. TRY COMMON BLOCK. 	   
d219 1
a219 1
	      K2=K2/2
d222 1
a222 1
	      K3=K3/2
d225 1
a225 1
	      K4=K4/2
d228 1
a228 1
	      K5=K5/2
d230 2
a231 2
              K6=K5+NSAM*NROW
	      K6=K6/2
d233 2
a234 2
              K7=K6+NSAM*NROW
	      K7=K7/2
d236 2
a237 2
              K8=K7+NSAM*NROW
	      K8=K8/2
d239 2
a240 2
              K9=K8+NSAM*NROW
	      K9=K9/2
d242 2
a243 2
              K10=K9+NSAM*NROW
	      K10=K10/2
d245 2
a246 2
              K11=K10+NSAM*NROW
	      K11=K11/2
d248 2
a249 2
              K12=K11+NSAM*NROW
	      K12=K12/2
d251 2
a252 2
              K13=K12+4*MAXRIN
	      K13=K13/2
d255 1
a255 1
	      K14=K14/2
d258 1
a258 1
	      K15=K15/2
d260 2
a261 2
              K16=K15+NSAM*NROW
	      K16=K16/2
d265 2
a266 2
	      MEMTOT=1200+L_MAINBUF+NSAM*NROW*NIMA
	      
d268 1
a268 1
     &	            RUNTIME,IPQ,IRTFLG)
d274 3
a276 3
                     CALL GETIMA( Q(L_MAINBUF+NSAM*NROW*(IMI-1)),
     $                        NSAM,NROW,IMI)
                 ENDDO 	   
d278 3
a280 3
	      END IF
	   ELSE
C	      RUNTIME IS TRUE. DYNAMIC MEM. ALLOCATION.
d284 3
a286 3
                 CALL GETIMA( Q(L_MAINBUF+NSAM*NROW*(IMI-1)),
     $                        NSAM,NROW,IMI)
              ENDDO 	   
d288 2
a289 2
	   END IF  
	END IF
d292 1
a292 1
C	   BLOCK MEMORY
d296 1
a296 1
     &	            RUNTIME,IPQ,IRTFLG)
d299 1
a299 1
	   ELSE
d303 8
a310 7
	END IF
	
         CALL  GALI_P(NSAM,NROW,NSI,ILIST,NIMA,MODE,JACUP,
     &                Q(K4),Q(K5),Q(K6),Q(K7),Q(K8),Q(K15),Q(K9),
     &                Q(K10),Q(K11),Q(K2),Q(K3),Q(K13),Q(K14),LCIRC,
     &                NUMR,NRING,MAXRIN,Q(K12),Q(K16),
     &                NR,NOUT)
d322 1363
@


1.14
log
@put then with if statement
@
text
@a310 1
         RETURN
@


1.13
log
@correct some of the if then logic with memory usage.
@
text
@d281 1
a281 1
        IF(.NOT.INCORE)
@


1.12
log
@change NOT. into .NOT.
@
text
@d202 1
a202 1
        CALL CHKMEM(MEMTOT, KAF, MAXMEM-(NILMAX+1024+80), 
d258 1
a258 1
              CALL CHKMEM(MEMTOT, KAF, MAXMEM-(NILMAX+1024+80), 
d260 9
a268 2
              IF(IRTFLG.EQ.0) THEN
	         INCORE = .TRUE. 
d271 8
a278 2
C	     DYNAMIC MEM. ALLOCATION.	   
             INCORE=.TRUE.
d281 1
a281 7
        IF(INCORE) THEN
           WRITE (NOUT,2500)  MAXMEM , MEMTOT
           WRITE(NOUT,*)  '   ***  In-core version  ***'
           DO  IMI=1,NIMA
           CALL GETIMA(Q(L_MAINBUF+NSAM*NROW*(IMI-1)),NSAM,NROW,IMI)
           ENDDO 
	ELSE
d286 1
a286 1
           CALL CHKMEM(MEMTOT, KAF, MAXMEM-(NILMAX+1024+80), 
d289 1
a289 1
             WRITE (NOUT,2500)  MAXMEM , MEMTOT
d291 2
a292 2
             CALL ERRT(6,'AP SR ',NE)
             RETURN
d297 4
a300 4
     &   Q(K4),Q(K5),Q(K6),Q(K7),Q(K8),Q(K15),Q(K9),
     &   Q(K10),Q(K11),Q(K2),Q(K3),Q(K13),Q(K14),LCIRC,
     &   NUMR,NRING,MAXRIN,Q(K12),Q(K16),
     &   NR,NOUT)
@


1.11
log
@use chkmem instead of allocit call
@
text
@d205 1
a205 1
           IF (NOT.RUNTIME)  THEN
@


1.10
log
@add SP_ALLOC for allocit call
@
text
@d38 4
a41 8
         INTEGER*2  NUMR(3,1000)
#ifdef SP_UNIX
         INCLUDE 'CMBLOCK.INC' 
#else
         INCLUDE 'COMMON1:CMBLOCK.INC' 
#endif
#ifdef SP_ALLOC
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),NUMR
d44 2
a45 5
         LOGICAL         RUNTIME
#else
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),Q(1)
         EQUIVALENCE  (Q,NUMR)
#endif
a152 1
#ifdef SP_ALLOC
d156 1
a156 7
#else
         K1=1
         K2=K1+(3*NRING+3)/2
	K2=K2/2
        K2=K2*2+1
#endif
         K3=K2+NIMA
d159 1
a159 1
         K4=K3+3*NIMA
d162 1
a162 1
         K5=K4+MAX0(NSAM,2*NROW)
d165 1
a165 1
         K6=K5+NSAM*NROW
d168 1
a168 1
         K7=K6+NSAM*NROW
d171 1
a171 1
         K8=K7+NSAM*NROW
d174 1
a174 1
         K9=K8+NSAM*NROW
d177 1
a177 1
         K10=K9+NSAM*NROW
d180 1
a180 1
         K11=K10+NSAM*NROW
d183 1
a183 1
         K12=K11+NSAM*NROW
d186 1
a186 1
         K13=K12+4*MAXRIN
d189 1
a189 1
         K14=K13+LCIRC
d192 1
a192 1
         K15=K14+LCIRC
d195 1
a195 1
         K16=K15+NSAM*NROW
d198 2
a199 3
         L_MAINBUF=K16
         INCORE=.FALSE.
#ifdef SP_ALLOC
d201 88
a288 30
         CALL ALLOCIT(MEMTOT,RUNTIME,IPQ,'GALI',IRTFLG)
	IF(RUNTIME)  THEN
#else
         MEMTOT=1200+L_MAINBUF+NSAM*NROW*NIMA
C
         IF (MEMTOT .LT. MAXMEM)  THEN
#endif
         WRITE (NOUT,2500)  MAXMEM , MEMTOT
         WRITE(NOUT,*)  '   ***  In-core version  ***'
         DO  IMI=1,NIMA
         CALL GETIMA(Q(L_MAINBUF+NSAM*NROW*(IMI-1)),NSAM,NROW,IMI)
         ENDDO
         INCORE=.TRUE.
         ELSE
C reduce memory
         MEMTOT=MEMTOT-NSAM*NROW*NIMA
#ifdef SP_ALLOC
         CALL ALLOCIT(MEMTOT,RUNTIME,IPQ,'RF 3',IRTFLG)
	IF(RUNTIME)  THEN
#else
C
         IF (MEMTOT .LT. MAXMEM)  THEN
#endif
         WRITE (NOUT,2500)  MAXMEM , MEMTOT
	 ELSE
         CALL ERRT(6,'AP SR ',NE)
         RETURN
         ENDIF
         ENDIF
C
d294 3
a296 4
C
#ifdef SP_ALLOC
      CALL ALLOCIT(0,RUNTIME,IPQ,'GALI',IRTFLG)
#endif
d303 2
@


1.9
log
@/core/ fixed
@
text
@d40 5
a44 1
         INCLUDE 'CMBLOCK.INC'
a49 1
         INCLUDE 'COMMON1:CMBLOCK.INC'
d160 1
a160 1
#ifdef SP_UNIX
d214 1
a214 1
#ifdef SP_UNIX
d232 1
a232 1
#ifdef SP_UNIX
d252 1
a252 1
#ifdef SP_UNIX
@


1.8
log
@added () in PARAMETER STATEMENT
@
text
@d58 1
a58 2
         COMMON  /CORE/  K1,K2,K3,K4,K5,K6,K7,K8,K9,K10,K11,K12,
     &   K13,K14,K15,K16,L_MAINBUF,INCORE
@


1.7
log
@malloc
@
text
@d3 1
a3 1
C $$ GALI.FOR
d15 1
a16 8
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************
C
C $$ GALI.FOR
C
         SUBROUTINE GALI(MAXMEM)
C
d33 5
a37 1
         PARAMETER  NILMAX=9998
d63 1
a63 1
C
d65 1
a65 1
C
d67 1
a67 1
C
d70 1
a70 1
C
@


1.6
log
@retrieved older version
@
text
@d40 2
d44 4
d50 2
a52 1
         PARAMETER  NILMAX=9998
a54 1
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),Q(1)
a59 2
         INTEGER*2  NUMR(3,1000)
         EQUIVALENCE  (Q,NUMR)
d84 1
a84 1
         CALL  UNSAV(DOCFIL,K,INPIC,KP1,Q,1,LERR,K2)
d87 1
a87 1
         ILIST(NIMA)=Q(1)
d102 1
a102 1
         WRITE(NOUT,*) ' File not found'
d161 5
d170 1
d214 6
a221 1
         INCORE=.FALSE.
d223 1
d225 1
a225 1
         WRITE(NDAT,*)  '   ***  In-core version  ***'
d233 7
d241 3
d245 1
d250 1
a250 1
     &   Q(K1),NRING,MAXRIN,Q(K12),
d253 3
@


1.5
log
@runtime alloc
@
text
@a0 1

d3 1
a3 1
C  GALI.FOR
a14 15
C     GALI(MAXMEM)
C     GALI_P(NSAM,NROW,ILIST,NIMA,MODE,JACUP,
C     GETIMA(X,NSAM,NROW,IMI)
C     ALROSI(A,ATMP,B,C,REFER,NSAM,NROW,WRK,PARA,NOCHANGE,
C     ALROSF(A,ATMP,B,C,REFER,NSAM,NROW,WRK,PARA,NOCHANGE,
C     RTQS(X,OUT,NSAM,NROW,THETA,SHXI,SHYI)
C     SHFI_2(X,OUT,NSAM,NROW,ISHX,ISHY)
C     SUMAP(
C     BLOB(X,NSAM,NROW,NR)
C     FINDMX_F(D,NSAM,NROW,CMX,SX,SY,JACUP)
C     CROSRNG_F
C     OUTIM(X,NSAM,NROW,IT)
C     OUTPR(PARA,NIMA,IT)
C     UPDF(C,A,OUT,N,IMI)
C     DOUBLE PRECISION FUNCTION FNRM(X,N)
d16 1
d19 21
a39 3
 
        SUBROUTINE GALI(MAXMEM)

a44 5
C FOLLOWING LINE SAYS DO NOT MAKE ALL VARIABLE STATIC (IN MAKE)
CNO_SAVE

C        BE CAREFUL WITH THE COMMON, IT HAS TO AGREE WITH 64 BITS...
C        WATCH FOR NILMAX, IT'S IN GETIMA, OUTIM, AND OUTPR.
d46 14
a59 25

#ifdef SP_UNIX && ifndef __osf__
C        USE RUN-TIME ARRAY ALLOCATION FOR Q
         COMMON    DUMMY(80),BUF(1024),ILIST(NILMAX),NUMR(3,1000)
         INTEGER*2       NUMR
         DIMENSION Q(1)
         POINTER   (IPQ,Q) 
#else
C        USE ARRAY SPACE FROM COMMON BUFFER FOR Q
         COMMON          DUMMY(80),BUF(1024),ILIST(NILMAX),Q(1)
         INTEGER*2       NUMR(3,1000)
         EQUIVALENCE     (Q,NUMR)
#endif

         COMMON /FISPEC/ FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC,
     &                   NLET,NLETI,NLIMA,NLDOC
         CHARACTER*80    FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
         COMMON /MXR/    MAXRIN
         INTEGER*2       MAXRIN
         DIMENSION       PLIST(1)
         CHARACTER*1     NULL,MODE
         COMMON /CORE/   K1,K2,K3,K4,K5,K6,K7,K8,K9,K10,K11,K12,
     &                   K13,K14,K15,K16,L_MAINBUF,INCORE
         LOGICAL         INCORE, RUNTIME

d61 6
a66 3
          NULL = CHAR(0)
 
C        ASK FOR DATA FILE
d68 2
a69 2
     &      'Enter template for 2-D image name',IRTFLG)
 
d75 3
a77 3
         IF (NIMA .EQ. NILMAX)  THEN
            WRITE(NOUT,*) '  Too many images, list truncated'
            GOTO  779
d80 6
a85 6
         CALL  UNSAV(DOCFIL,K,INPIC,KP1,PLIST,1,LERR,K2)
         IF (LERR .EQ. 0)  THEN
            NIMA=NIMA+1
            ILIST(NIMA)=PLIST(1)
            K=K+1
            GOTO  778
d88 3
a90 3
         IF (NIMA.GT.0)  THEN
            WRITE(NOUT,2001) NIMA
2001        FORMAT('  Number of images =',i5)
d92 2
a93 2
            WRITE(NOUT,*)  '  No images !'
            RETURN
d95 5
a99 5
         CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
         CALL OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'R',NF,NSL)
         IF (NF.NE.2)  THEN
            WRITE(NOUT,*) ' File not found'
            RETURN
d102 1
a102 1
 
d104 20
a123 22
         IF (NSI.GE.NSAM)  THEN
            WRITE(NOUT,*) 
     &       ' Object size cannot be larger than window size'
            NSI=NSAM-2
            WRITE(NOUT,*) ' Object size set to: ',NSI
         ENDIF
         NSI = MAX0(1,NSAM-NSI)
C
         CALL RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
         IF (NR .GT. NSAM/2-1)  THEN
            NR = NSAM/2-1
            WRITE(NOUT,*) ' Last ring limited to: ',NR
         ENDIF
         MR    = MAX0(2,MIN0(NR,MR))
         ISKIP = 1
         MODE  = 'F'
         NRING = 0
         DO I=MR,NR,ISKIP
            NRING = NRING+1
            NUMR(1,NRING) = I
         ENDDO
 
d126 3
a128 2

C        templates for output files
d130 1
a130 1
     &      'Enter template for output',IRTFLG)
d132 5
a136 5
     &      'Enter template for output doc',IRTFLG)

C        CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
C           & 'Precision of peak location (0..100)')
C        JACUP=MAX0(0,MIN0(100,JACUP))
d138 5
a142 5

C   MEMORY DIVISION    K
C       NUMR           1  !INT*2
C       IMAGE          2
C       PARA           3
d148 6
a153 6
C       REFER          9
C       REFERN        10
C       REFERTMP      11
C       TEMP          12  !DOUBLE PRECISION
C       A_CIRC        13
C       REFER_CIRC    14
d155 2
a156 2


d159 2
a160 2
	 K2=K2/2
         K2=K2*2+1
d162 2
a163 2
	 K3=K3/2
         K3=K3*2+1
d165 2
a166 2
	 K4=K4/2
         K4=K4*2+1
d168 2
a169 2
	 K5=K5/2
         K5=K5*2+1
d171 2
a172 2
	 K6=K6/2
         K6=K6*2+1
d174 2
a175 2
	 K7=K7/2
         K7=K7*2+1
d177 2
a178 2
	 K8=K8/2
         K8=K8*2+1
d180 2
a181 2
	 K9=K9/2
         K9=K9*2+1
d183 2
a184 2
	 K10=K10/2
         K10=K10*2+1
d186 2
a187 2
	 K11=K11/2
         K11=K11*2+1
d189 2
a190 2
	 K12=K12/2
         K12=K12*2+1
d192 2
a193 2
	 K13=K13/2
         K13=K13*2+1
d195 2
a196 2
	 K14=K14/2
         K14=K14*2+1
d198 2
a199 2
	 K15=K15/2
         K15=K15*2+1
d201 2
a202 2
	 K16=K16/2
         K16=K16*2+1
d205 9
a213 13

         MEMWANT=L_MAINBUF+NSAM*NROW*NIMA
         CALL ALLOCIT(MEMWANT,RUNTIME,IPQ,'GALI',IRTFLG)
         IF (RUNTIME .OR. MEMTOT .LT. MAXMEM)  THEN
            IF (.NOT. RUNTIME) 
     &         WRITE (NOUT,2500)  MAXMEM , MEMTOT
2500           FORMAT (/,' MEMORY RESERVATION: YOU HAVE',
     &           ' RESERVED ',I8,',  YOU NEED  ',I8 / )
            WRITE(NDAT,*)  '   ***  In-core version  ***'
            DO  IMI=1,NIMA
              CALL GETIMA(Q(L_MAINBUF+NSAM*NROW*(IMI-1)),NSAM,NROW,IMI)
            ENDDO
            INCORE = .TRUE.
d215 3
a217 11
            MEMWANT=L_MAINBUF
            CALL ALLOCIT(MEMWANT,RUNTIME,IPQ,'GALI',IRTFLG)
C           REDUCE MEMORY
            MEMTOT = MEMTOT-NSAM*NROW*NIMA
            IF (RUNTIME .OR. MEMTOT .LT. MAXMEM)  THEN
               WRITE (NOUT,2500)  MAXMEM, MEMTOT
               INCORE=.FALSE.
            ELSE
               WRITE(NOUT,*)  '  Sorry, not enough memory !'         
               RETURN
            ENDIF
d219 1
a219 1

d221 5
a225 5
     &      Q(K4),Q(K5),Q(K6),Q(K7),Q(K8),Q(K15),Q(K9),
     &      Q(K10),Q(K11),Q(K2),Q(K3),Q(K13),Q(K14),LCIRC,
     &      NUMR,NRING,MAXRIN,Q(K12),
     &      NR,NOUT)

d227 3
d231 1
a231 5
     #      'end of computation',//' ',80('-')/)

C        FREE RUN-TIME ARRAY ALLOCATION FOR Q
         CALL ALLOCIT(0,RUNTIME,IPQ,'GALI',IRTFLG)

@


1.4
log
@nosave
@
text
@d1 1
d4 1
a4 1
C $$ GALI.FOR
d16 15
a31 1
C
d34 3
a36 21
C
C $$ GALI.FOR
C
         SUBROUTINE GALI(MAXMEM)
C
C         SUBROUTINE GALI(MAXMEM)
C         SUBROUTINE  GALI_P(NSAM,NROW,ILIST,NIMA,MODE,JACUP,
C         SUBROUTINE  GETIMA(X,NSAM,NROW,IMI)
C      SUBROUTINE  ALROSI(A,ATMP,B,C,REFER,NSAM,NROW,WRK,PARA,NOCHANGE,
C      SUBROUTINE  ALROSF(A,ATMP,B,C,REFER,NSAM,NROW,WRK,PARA,NOCHANGE,
C         SUBROUTINE  RTQS(X,OUT,NSAM,NROW,THETA,SHXI,SHYI)
C         SUBROUTINE  SHFI_2(X,OUT,NSAM,NROW,ISHX,ISHY)
C         SUBROUTINE SUMAP(
C         SUBROUTINE  BLOB(X,NSAM,NROW,NR)
C         SUBROUTINE  FINDMX_F(D,NSAM,NROW,CMX,SX,SY,JACUP)
C         SUBROUTINE  CROSRNG_F
C         SUBROUTINE  OUTIM(X,NSAM,NROW,IT)
C         SUBROUTINE OUTPR(PARA,NIMA,IT)
C         SUBROUTINE  UPDF(C,A,OUT,N,IMI)
C         DOUBLE PRECISION FUNCTION  FNRM(X,N)
C
d42 5
d48 25
a72 14
C be careful with the common, it has to agree with 64 bits...
C watch for NILMAX, it's in getima, outim and outpr.
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),Q(1)
         COMMON  /FISPEC/
     &   FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC,NLET,NLETI,NLIMA,NLDOC
         CHARACTER*80  FINPAT,FINPIC,DOCFIL,OUTIMA,OUTDOC
         COMMON /MXR/ MAXRIN
         INTEGER*2  MAXRIN
         INTEGER*2  NUMR(3,1000)
         EQUIVALENCE  (Q,NUMR)
         CHARACTER*1  NULL,MODE
         COMMON  /CORE/  K1,K2,K3,K4,K5,K6,K7,K8,K9,K10,K11,K12,
     &   K13,K14,K15,K16,L_MAINBUF,INCORE
         LOGICAL  INCORE
d74 3
a76 6
CNO_SAVE
C
         NULL=CHAR(0)
C
C  ASK FOR DATA FILE
C
d78 2
a79 2
     &   'Enter template for 2-D image name',IRTFLG)
C
d85 3
a87 3
         IF(NIMA.EQ.NILMAX)  THEN
         WRITE(NOUT,*) '  Too many images, list truncated'
         GOTO  779
d90 6
a95 6
         CALL  UNSAV(DOCFIL,K,INPIC,KP1,Q,1,LERR,K2)
         IF(LERR.EQ.0)  THEN
         NIMA=NIMA+1
         ILIST(NIMA)=Q(1)
         K=K+1
         GOTO  778
d98 3
a100 3
         IF(NIMA.GT.0)  THEN
         WRITE(NOUT,2001) NIMA
2001     FORMAT('  Number of images =',i5)
d102 2
a103 2
         WRITE(NOUT,*)  '  No images !'
         RETURN
d105 5
a109 5
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'R',NF,NSL)
         IF(NF.NE.2)  THEN
         WRITE(NOUT,*) ' File not found'
         RETURN
d112 1
a112 1
C
d114 22
a135 20
         IF(NSI.GE.NSAM)  THEN
         WRITE(NOUT,*) ' Object size cannot be larger than window size'
         NSI=NSAM-2
         WRITE(NOUT,*) ' Object size set to',NSI
         ENDIF
         NSI=MAX0(1,NSAM-NSI)
C
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING$')
         IF(NR.GT.NSAM/2-1)  THEN
         NR=NSAM/2-1
         WRITE(NOUT,*)  ' Last ring limited to ',NR
         ENDIF
         MR=MAX0(2,MIN0(NR,MR))
         ISKIP=1
         MODE='F'
         NRING=0
         DO  1  I=MR,NR,ISKIP
         NRING=NRING+1
1        NUMR(1,NRING)=I
C
d138 2
a139 3
C
C templates for output files
C
d141 1
a141 1
     &   'Enter template for output',IRTFLG)
d143 5
a147 5
     &   'Enter template for output doc',IRTFLG)
C
C     CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
C     & 'Precision of peak location (0..100)$')
C     JACUP=MAX0(0,MIN0(100,JACUP))
d149 5
a153 5
C
C   memory division    K
C       numr           1  !int*2
C       image          2
C       para           3
d159 6
a164 6
C       refer          9
C       refern        10
C       refertmp      11
C       temp          12  !double precision
C       a_circ        13
C       refer_circ    14
d166 2
a167 2
C
C
d170 2
a171 2
	K2=K2/2
        K2=K2*2+1
d173 2
a174 2
	K3=K3/2
        K3=K3*2+1
d176 2
a177 2
	K4=K4/2
        K4=K4*2+1
d179 2
a180 2
	K5=K5/2
        K5=K5*2+1
d182 2
a183 2
	K6=K6/2
        K6=K6*2+1
d185 2
a186 2
	K7=K7/2
        K7=K7*2+1
d188 2
a189 2
	K8=K8/2
        K8=K8*2+1
d191 2
a192 2
	K9=K9/2
        K9=K9*2+1
d194 2
a195 2
	K10=K10/2
        K10=K10*2+1
d197 2
a198 2
	K11=K11/2
        K11=K11*2+1
d200 2
a201 2
	K12=K12/2
        K12=K12*2+1
d203 2
a204 2
	K13=K13/2
        K13=K13*2+1
d206 2
a207 2
	K14=K14/2
        K14=K14*2+1
d209 2
a210 2
	K15=K15/2
        K15=K15*2+1
d212 2
a213 2
	K16=K16/2
        K16=K16*2+1
d216 13
a228 9
C
         INCORE=.FALSE.
         IF (MEMTOT .LT. MAXMEM)  THEN
         WRITE (NOUT,2500)  MAXMEM , MEMTOT
         WRITE(NDAT,*)  '   ***  In-core version  ***'
         DO  IMI=1,NIMA
         CALL GETIMA(Q(L_MAINBUF+NSAM*NROW*(IMI-1)),NSAM,NROW,IMI)
         ENDDO
         INCORE=.TRUE.
d230 11
a240 3
C reduce memory
         MEMTOT=MEMTOT-NSAM*NROW*NIMA
         WRITE (NOUT,2500)  MAXMEM , MEMTOT
d242 1
a242 1
C
d244 5
a248 5
     &   Q(K4),Q(K5),Q(K6),Q(K7),Q(K8),Q(K15),Q(K9),
     &   Q(K10),Q(K11),Q(K2),Q(K3),Q(K13),Q(K14),LCIRC,
     &   Q(K1),NRING,MAXRIN,Q(K12),
     &   NR,NOUT)
C
a249 3
         RETURN
2500     FORMAT (/,' MEMORY RESERVATION: YOU HAVE',
     #   ' RESERVED ',I8,',  YOU NEED  ',I8 / )
d251 5
a255 1
     #   'end of computation',//' ',80('-')/)
@


1.3
log
@nosave
@
text
@d47 1
@


1.2
log
@cpp_lines_added
@
text
@d45 2
a46 1
         PARAMETER  NILMAX=9999
d60 1
d158 2
d161 2
d164 2
d167 2
d170 2
d173 2
d176 2
d179 2
d182 2
d185 2
d188 2
d191 2
d194 2
d197 2
d200 2
@


1.1
log
@Initial revision
@
text
@d40 3
d44 1
@
