head	1.32;
access;
symbols
	pre_getangas:1.31
	GPL2010:1.31
	pre_GPL2010:1.30
	pre_var_equation:1.30
	pre_fftwrings:1.30
	pre_opfiles:1.30
	src:1.30
	best-code:1.30
	named-reg:1.30
	x-named-regs:1.29
	x:1.29
	v13-00:1.29
	pre_GPL:1.27
	prec_CA:1.27
	noindx:1.27
	Bproc:1.26
	oct21:1.22
	last77:1.20;
locks; strict;
comment	@c @;


1.32
date	2015.12.10.14.40.27;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.24.13.25.11;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.12.15.26.20;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.17.20.01.47;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.17.17.57.27;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.09.14.35.44;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.08.18.14.48;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.28.15.13.30;	author pawel;	state Exp;
branches;
next	1.24;

1.24
date	2000.03.28.14.56.00;	author pawel;	state Exp;
branches;
next	1.23;

1.23
date	99.11.17.18.15.41;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	99.07.07.21.00.09;	author pawel;	state Exp;
branches;
next	1.21;

1.21
date	99.05.13.19.43.23;	author pawel;	state Exp;
branches;
next	1.20;

1.20
date	98.08.19.14.09.00;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	98.08.19.14.05.21;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	98.07.23.16.22.10;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	98.06.16.15.57.32;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	98.06.01.14.31.01;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	98.06.01.13.10.26;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	98.05.01.16.05.49;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	98.05.01.15.40.52;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	98.04.22.21.03.01;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	98.04.22.17.20.36;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	98.04.22.14.35.08;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	98.04.22.13.50.55;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	98.04.21.19.55.43;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	98.04.16.21.27.37;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	98.03.31.20.04.18;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	98.03.31.14.43.19;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	98.03.27.18.56.16;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	98.03.25.19.13.35;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	98.03.23.18.44.51;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.03.23.18.21.57;	author pawel;	state Exp;
branches;
next	;


desc
@@


1.32
log
@detab
@
text
@C++*************************************************** 12/11/79 1/11/81 VAX
C
C CALC.F                           REWRITTEN    MAY 98 ARDEAN LEITH                           
C                     BETTER ERROR MESSAGES   APR 2002 ARDEAN LEITH
C                     REG_GET_BYNUM           NOV 2005 ARDEAN LEITH
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  CALC(IRPNIN,NRPN,VAL,PIXVAL,RETVAL,IRTFLG)
C
C  PURPOSE:   EVALUATES EXPRESSIONS IN THE POSTFIX FORM, RETURNS VALUE
C
C  PARAMETERS:
C       IRPNIN      ARRAY CONTAINS POSTFIX NOTATION              (SENT)
C       NRPN        NO. OF ELEMENTS USED IN IRPNIN               (SENT)
C       VAL         ARRAY CONTAINS VALUES ASSOCIATED WITH        (SENT)
C                   INDICES IN IRPN. 
C       PIXVAL      CURRENT P1 PIXEL VALUE                       (SENT)  
C       RETVAL      CONTAINS VALUE OF EXPRESSION                 (RET.)
C       IRTFLG      ERROR FLAG                                   (RET.)
C
C  NOTES:
C       IRPN        DENOTES
C       > 200       PIXEL POINTER
C       128...200   REGISTER POINTER
C       97..114     UNITARY OPERATOR (SIN, COS, ETC)
C       41..47,96   BINARY OPERATOR (+-/^*)
C       48...88     VAL POINTER
C       0           SKIP
C       <0          BVAL POINTER
C  
C--*********************************************************************

        SUBROUTINE CALC(IRPNIN,NRPN,VAL,PIXVAL,RETVAL,IRTFLG)

        COMMON /UNITS/    LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT

        PARAMETER         (IVALEN  = 40)
        PARAMETER         (IRPNLEN = 80)
        PARAMETER         (NFUNCT  = 16)

        DIMENSION         VAL(IVALEN)
C       BVAL IS USED TO AVOID OVERWRITING VAL EACH TIME CALC IS CALLED
        DIMENSION         BVAL(IVALEN)
        INTEGER           IRPNIN(IRPNLEN)
        DIMENSION         IRPN(IRPNLEN)
        LOGICAL           NOOP

C       SET DEFAULT ERROR RETURN FLAG
        IRTFLG = 1
        NOOP   = NRPN .EQ. 1

C       IRPN WILL BE DAMAGED SO THE INPUT MUST BE COPIED
        DO  N=1,NRPN
           IRPN(N) = IRPNIN(N)
        ENDDO

C       FOLLOWING LOOP IS EXECUTED FOR EACH OPERATION OR FUNCTION FOUND

2400    DO  N=1,NRPN
   
C          IRPNNOW IS CURRENT OPERATION OR VALUE POINTER           
           IRPNNOW = IRPN(N)

C          SKIP EVALUATING RPN POSITION IF IT IS ZERO
           IF (IRPNNOW .EQ. 0) GOTO 2001

           IF (IRPNNOW .GE. 201) THEN
C             PIXEL CONTENT POINTER, (IRPNNOW - 200) IS VAL POINTER
C             CONTENT OF VAL IS THE PIXEL NUMBER, (CURRENTLY 1 ONLY)
              LOC2       = LOC1
              LOC1       = IRPNNOW - 200
              BVAL(LOC1) = PIXVAL             
              IRPN(N)    = -LOC1
              NOOP       = .FALSE.
              GOTO 2400

           ELSEIF (IRPNNOW .GE. 128) THEN
C             REGISTER CONTENT POINTER, (IRPNNOW - 127) IS VAL POINTER
C             CONTENT OF VAL POSITION IS THE REGISTER NUMBER
              LOC2       = LOC1
              LOC1       = IRPNNOW - 127
              CALL REG_GET_BYNUM(INT(VAL(LOC1)),BVAL(LOC1),IRTFLG)
              NOOP       = .FALSE.
              IRPN(N)    = -LOC1
              GOTO 2400

           ELSEIF ((IRPNNOW .GT. 40 .AND. IRPNNOW .LT. 48) .OR.
     &              IRPNNOW  .EQ. 94) THEN
C             IRPNNOW IS AN OPERATOR (+-/^*), THAT USES TWO OPERANDS
C             WHICH ARE KEPT IN VAL ARRAY.
C             LOC1 & LOC2 ARE ALREADY SET WHEN PREVIOUS VAL POINTERS 
C             WERE ENCOUNTERED.

              IF (IRPN(LOC2) .LT. 0) THEN
C                IRPNNOW POINTS TO BVAL
                 ITEMP1 = -IRPN(LOC2)
                 VALUE1 = BVAL(ITEMP1)
              ELSE
C                IRPNNOW POINTS TO VAL
                 ITEMP1 = IRPN(LOC2) - 48
                 VALUE1 = VAL(ITEMP1)
              ENDIF

              IF (IRPN(LOC1) .LT. 0) THEN
C                IRPNNOW POINTS TO BVAL
                 ITEMP2 = -IRPN(LOC1)
                 VALUE2 = BVAL(ITEMP2)
              ELSE
C                IRPNNOW POINTS TO VAL
                 ITEMP2 = IRPN(LOC1) - 48
                 VALUE2 = VAL(ITEMP2)
              ENDIF

              IF (IRPNNOW .EQ. 43) THEN
C                ADDITION, ICHAR('+') = 43
                 BVAL(ITEMP1) = VALUE1 + VALUE2

              ELSEIF (IRPNNOW .EQ. 45) THEN
C                SUBTRACTION, ICHAR('-') = 45
                 BVAL(ITEMP1) = VALUE1 - VALUE2

              ELSEIF (IRPNNOW .EQ. 42) THEN
C                MULTIPLICATION, ICHAR('*') = 42
                 BVAL(ITEMP1) = VALUE1 * VALUE2

              ELSEIF (IRPNNOW .EQ. 47) THEN
C                DIVISION, ICHAR('/') = 47
                 IF (VALUE2 .EQ. 0.) THEN
                    CALL ERRT(43,'CALC - DIVISION BY ZERO',NE)
                    RETURN
                 ENDIF
                 BVAL(ITEMP1) = VALUE1 / VALUE2

              ELSEIF (IRPNNOW .EQ. 94) THEN
C                POWER, ICHAR('^') = 94
                 BVAL(ITEMP1) = VALUE1 ** VALUE2

              ELSE
C                UNKNOWN OPERATOR
                 CALL ERRT(43,'CALC - UNKNOWN OPERATOR',NE)
                 RETURN
              ENDIF
              IRPN(LOC2) = -ITEMP1
              IRPN(LOC1) = 0
              IRPN(N)    = 0
C             START RPN EVALUATION LOOP ANEW
              GOTO 2400

           ELSEIF (IRPNNOW .LT. 0 .OR. 
     &            (IRPNNOW .GE. 48 .AND. IRPNNOW .LE. 88)) THEN
C             IRPNOW IS A NUMERICAL POINTER TO BVAL OR VAL
C             CONTENT OF BVAL OR VAL POSITION IS THE NUMBER

              LOC2 = LOC1
              LOC1 = N
              GOTO 2001

           ELSE
C             IRPNNOW IS A SINGLE OPERAND FUNCTION (LIKE: SIN, RAN, ETC)
C             THE FUNCTION USES ONE VALUE FROM VAL ARRAY.  LOC1 IS
C             ALREADY SET WHEN PREVIOUS VAL POINTER ENCOUNTERED

              IF (IRPN(LOC1) .LT. 0) THEN
C                IRPNNOW POINTS TO BVAL
                 ITEMP2 = -IRPN(LOC1) 
                 VALUE2 = BVAL(ITEMP2)
              ELSE
C                IRPNNOW POINTS TO VAL
                 ITEMP2 = IRPN(LOC1) - 48
                 VALUE2 = VAL(ITEMP2)
              ENDIF

C             CURRENTLY FUNCTIONS DENOTED BY 'a-q', SO IFUNC IS: 1..15
C             ICHAR('a') = 97
              IFUNC  = IRPNNOW - 96
              IF (IFUNC .LE. 0 .OR. IFUNC .GT. NFUNCT) THEN
C                UNKNOWN FUNCTION INDICATOR ENCOUNTERED IN IRPN ARRAY
                 CALL ERRT(43,'CALC - UNKNOWN OPERATOR',NE)
                 RETURN
              ENDIF

C             EVALUATE THE SINGLE OPERAND FUNCTION
              GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16),IFUNC

C             PAD
1                NPOW  = INT(ALOG(VALUE2) / ALOG(2.0))
                 VALUE = 2**NPOW
                 IF (VALUE .GE. VALUE2)  THEN
                    BVAL(ITEMP2) = VALUE
                 ELSE
                    BVAL(ITEMP2) = 2 * VALUE
                 ENDIF
                 GOTO 1900

C             SINE
2                BVAL(ITEMP2) = SIN(VALUE2*0.017453293)
                 GOTO 1900

C             EXPONENTIATION
3               BVAL(ITEMP2) = EXP(VALUE2)
                GOTO 1900
                
C             LOG10
4                IF (VALUE2 .LE. 0.) THEN
                    CALL ERRT(43,
     &                 'CAN NOT GET LOG OF NEGATIVE NUMBER)',NE)
                    RETURN
                 ENDIF
                 BVAL(ITEMP2) = ALOG10(VALUE2)
                 GOTO 1900

C             COSINE
5                BVAL(ITEMP2) = COS(VALUE2*0.017453293)
                 GOTO 1900

C             SQRT        
6                IF (VALUE2 .LT. 0.) THEN
                    CALL ERRT(43,
     &                 'CAN NOT GET SQRT OF NEGATIVE NUMBER)',NE)
                    RETURN
                 ENDIF
                 BVAL(ITEMP2) = SQRT(VALUE2)
                 GOTO 1900

C             NATURAL LOG
7                IF (VALUE2 .LE. 0.0) THEN
                    CALL ERRT(43,
     &                 'CAN NOT GET LOG OF NEGATIVE NUMBER)',NE)
                    RETURN
                 ENDIF
                 BVAL(ITEMP2) = ALOG(VALUE2)
                 GOTO 1900

C             INT
8                BVAL(ITEMP2) = INT(VALUE2)
                 GOTO 1900

C             ABS
9                BVAL(ITEMP2) = ABS(VALUE2)
                 GOTO 1900

C             ATAN
10               BVAL(ITEMP2) = ATAN(VALUE2)*57.29578
                 GOTO 1900
        
C             ARC SIN
11               IF (ABS(VALUE2) .GT. 1.0) THEN
                    CALL ERRT(43,
     &                 'CAN NOT GET ASIN OF NUMBER > 1.0)',NE)
                    RETURN
                 ENDIF
                 BVAL(ITEMP2) = ASIN(VALUE2) * 57.29578
                 GOTO 1900

C             ARC COS
12               IF (ABS(VALUE2) .GT. 1.0) THEN
                    CALL ERRT(43,
     &                 'CAN NOT GET ACOS OF NUMBER > 1.0)',NE)
                    RETURN
                 ENDIF
                 BVAL(ITEMP2) = ACOS(VALUE2) * 57.29578
                 GOTO 1900

C             TANGENT
13               BVAL(ITEMP2) = TAN(VALUE2 * 0.017453293)
                 GOTO 1900
 
C             RANDOM NUMBER UNIFORM [0,1]
14               CONTINUE
                 CALL  RANDOM_NUMBER(VALUE)
                 BVAL(ITEMP2) = VALUE
                 GOTO 1900

C             RANDOM NUMBER NORMAL(0,1)
15               CONTINUE
                 BVAL(ITEMP2) = RANN(0.0,1.0)
                 GOTO 1900

C             UNITARY SIGN CHANGE (NEGATION)
16               BVAL(ITEMP2) = -VALUE2
C                GOTO 1900

1900          CONTINUE
C             CURRENT IRPN POSITION FINISHED
              IRPN(N)    = 0
C             IRPN SHOULD NOW POINT TO NEW BVAL LOCATION
              IRPN(LOC1) = -ITEMP2

C             START RPN EVALUATION LOOP ANEW
              GOTO 2400
           ENDIF

2001       CONTINUE
C          END OF EVALUATION LOOP -----------------------------------
        ENDDO


        IRTFLG = 0
        RETVAL = BVAL(1)
        IF (NOOP) RETVAL = VAL(1)

        END
@


1.31
log
@GPL_2010
@
text
@d53 1
a53 1
	SUBROUTINE CALC(IRPNIN,NRPN,VAL,PIXVAL,RETVAL,IRTFLG)
d61 1
a61 1
	DIMENSION         VAL(IVALEN)
d73 1
a73 1
	DO  N=1,NRPN
d107 1
a107 1
	   ELSEIF ((IRPNNOW .GT. 40 .AND. IRPNNOW .LT. 48) .OR.
d116 1
a116 1
	         ITEMP1 = -IRPN(LOC2)
d120 1
a120 1
	         ITEMP1 = IRPN(LOC2) - 48
d126 1
a126 1
	         ITEMP2 = -IRPN(LOC1)
d130 1
a130 1
	         ITEMP2 = IRPN(LOC1) - 48
d185 1
a185 1
	         ITEMP2 = -IRPN(LOC1) 
d189 1
a189 1
	         ITEMP2 = IRPN(LOC1) - 48
d206 2
a207 2
1   	         NPOW  = INT(ALOG(VALUE2) / ALOG(2.0))
	         VALUE = 2**NPOW
d209 1
a209 1
	            BVAL(ITEMP2) = VALUE
d211 1
a211 1
	            BVAL(ITEMP2) = 2 * VALUE
d220 1
a220 1
3	        BVAL(ITEMP2) = EXP(VALUE2)
d222 1
a222 1
		
d228 2
a229 2
	         ENDIF
	         BVAL(ITEMP2) = ALOG10(VALUE2)
d236 1
a236 1
C             SQRT  	  
d241 2
a242 2
	         ENDIF
	         BVAL(ITEMP2) = SQRT(VALUE2)
d250 2
a251 2
	         ENDIF
	         BVAL(ITEMP2) = ALOG(VALUE2)
d255 1
a255 1
8	         BVAL(ITEMP2) = INT(VALUE2)
d259 1
a259 1
9	         BVAL(ITEMP2) = ABS(VALUE2)
d263 1
a263 1
10	         BVAL(ITEMP2) = ATAN(VALUE2)*57.29578
d265 1
a265 1
	
d267 2
a268 2
11	         IF (ABS(VALUE2) .GT. 1.0) THEN
	            CALL ERRT(43,
d271 2
a272 2
	         ENDIF
	         BVAL(ITEMP2) = ASIN(VALUE2) * 57.29578
d276 2
a277 2
12	         IF (ABS(VALUE2) .GT. 1.0) THEN
	            CALL ERRT(43,
d280 2
a281 2
	         ENDIF
	         BVAL(ITEMP2) = ACOS(VALUE2) * 57.29578
d285 1
a285 1
13	         BVAL(ITEMP2) = TAN(VALUE2 * 0.017453293)
d300 1
a300 1
16	         BVAL(ITEMP2) = -VALUE2
d322 1
a322 1
	END
@


1.30
log
@native named registers
@
text
@a6 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d8 5
a12 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d14 1
a14 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d21 1
a21 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a22 1
C=*                                                                    *
d24 1
a24 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.29
log
@GPL License fixed
@
text
@d3 3
a5 2
C CALC.F                                             REWRITTEN MAY 98 AL                           
C                     BETTER ERROR MESSAGES APRIL 2002 ARDEAN LEITH
d106 1
a106 1
              CALL REG_GET(INT(VAL(LOC1)),BVAL(LOC1),.TRUE.,IRTFLG)
@


1.28
log
@HRI GPL License used
@
text
@a5 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d9 1
a9 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a28 6

C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.27
log
@better error msg.
@
text
@d7 24
@


1.26
log
@changes for reg_set
@
text
@d3 2
a4 2
C CALC.F                                             REWRITTEN MAY 98 al                           
C
d6 6
a11 6
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
d211 2
a212 1
                    CALL ERRT(43,'CALC - LOG',NE)
d224 2
a225 1
                    CALL ERRT(43,'CALC - SQRT',NE)
d233 2
a234 1
                    CALL ERRT(43,'CALC - LON',NE)
d254 2
a255 1
	            CALL ERRT(43,'CALC - ASIN',NE)
d263 2
a264 1
	            CALL ERRT(43,'CALC - ACOS',NE)
@


1.25
log
@fixed rnn
@
text
@a42 4
        PARAMETER         (MAXPARAM=129)
        PARAMETER         (MAXPARAMSEL=20)
        COMMON /PARAM/    PARAM(MAXPARAM),NSEL(MAXPARAMSEL)

d88 1
a88 1
              BVAL(LOC1) = PARAM(INT(VAL(LOC1))+1)
@


1.24
log
@rann added
@
text
@d275 2
a276 1
                 BVAL(ITEMP2) = RANN(0.0,1.0)
d281 1
a281 2
                 CALL  RANDOM_NUMBER(VALUE)
                 BVAL(ITEMP2) = VALUE
@


1.23
log
@common param had wrong length
@
text
@d49 1
d186 1
a186 1
              IF (IFUNC .LE. 0 .OR. IFUNC .GT. 15) THEN
d193 1
a193 1
              GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15),IFUNC
d273 1
a273 1
C             RANDOM NUMBER
d275 5
d285 1
a285 1
15	         BVAL(ITEMP2) = -VALUE2
a306 1
        RETURN
@


1.22
log
@*** empty log message ***
@
text
@a41 1
        COMMON /PARAM/    PARAM(103),NSEL(20)
d43 4
d301 1
@


1.21
log
@*** empty log message ***
@
text
@a40 1
CNO_SAVE
a41 1
        COMMON /RNDMSEED/ ISEED
a270 1
#ifdef SP_F90
a272 7
#else
#ifdef SP_UNIX
                 BVAL(ITEMP2) = RAN(ISEED)
#else
                 BVAL(ITEMP2) = RAND_P(ISEED)
#endif
#endif
@


1.20
log
@another bad /* for cpp rewritten
@
text
@d193 1
a193 1
C             LOG10
d211 1
a211 1
C             ARC LOG
@


1.19
log
@some cpp dont like /*
@
text
@d97 1
a97 1
C             IRPNNOW IS AN OPERATOR (+-/*^), THAT USES TWO OPERANDS
@


1.18
log
@bad ifdef
@
text
@d32 1
a32 1
C       41..47,96   BINARY OPERATOR (+-/*^)
@


1.17
log
@*** empty log message ***
@
text
@d277 1
a277 1
#if SP_UNIX
@


1.16
log
@*** empty log message ***
@
text
@d90 1
a90 1
              BVAL(LOC1) = PARAM(VAL(LOC1)+1)
@


1.15
log
@rewritten
@
text
@d14 1
a14 1
C  CALC(IRPN,VAL,NRPN,IRTFLG)
a307 1
        RETURN
@


1.14
log
@used ichar in irpn initialization
@
text
@d3 1
a3 1
C CALC.F                             
d14 1
a14 1
C  CALC(RPNARRAY,VAL,NVAL,IRTFLG)
d19 6
a24 5
C       RPNARRAY    CHAR. ARRAY CONTAINS POSTFIX NOTATION        (SENT)
C       VAL         ARRAY CONTAINS VALUES ASSOCIATED WITH   (SENT/RET.)
C                   INDICES IN RPNARRAY. ON RETURN,
C                   VAL(1) CONTAINS VALUE OF EXPRESSION
C       NVAL        NO. OF ELEMENTS IN RPNARRAY ARRAY            (SENT)
d27 10
d39 1
a39 1
	SUBROUTINE CALC(RPNARRAY,NVAL,VAL,IRTFLG)
d44 1
d46 2
a47 4
	DIMENSION       VAL(*)
        CHARACTER *81   RPNARRAY
        CHARACTER       CTEMP
        INTEGER         IRPN(81)
d49 7
d58 1
d60 3
a62 2
        DO I = 1, NVAL
           IRPN(I) = ICHAR(RPNARRAY(I:I))
d65 1
a65 2
2400    LOC1   = -1
        LOC2   = -1
d67 17
a83 2
	DO  N=1,NVAL
           ITEMP = IRPN(N)
d85 9
a93 2
C          SKIP EVALUATING RPN POITION IF IT IS ZERO
           IF (ITEMP .EQ. 0) GOTO 2001
d95 16
a110 2
C          ICHAR('a') = 97
           IFUNC = ITEMP - 96
d112 9
a120 3
C          CURRENTLY FUNCTIONS USE 'a-o' OR IFUNC IS: 1..15
	   IF (IFUNC .LE. 0) THEN
C             ITEMP IS NOT A FUNCTION LETTER, MAY BE OPERATOR (+-/*^)
d122 1
a122 1
              IF (ITEMP .EQ. 43 ) THEN
d124 1
a124 3

C                NOTE: ITEMP1 & ITEMP2 CAN NOT BE MOVED OUTSIDE 
C                BECAUSE LOC1 AND LOC2 MAY NOT BE SET IF OUTSIDE.
d126 1
a126 8
	         ITEMP1      = IRPN(LOC2) - 48
	         ITEMP2      = IRPN(LOC1) - 48
                 VAL(ITEMP1) = VAL(ITEMP1) + VAL(ITEMP2)
                 IRPN(LOC1)  = 0
                 IRPN(N)     = 0
                 GOTO 2400

              ELSEIF (ITEMP .EQ. 45) THEN
d128 1
a128 6
	         ITEMP1      = IRPN(LOC2) - 48
	         ITEMP2      = IRPN(LOC1) - 48
                 VAL(ITEMP1) = VAL(ITEMP1) - VAL(ITEMP2)
                 IRPN(LOC1)  = 0
                 IRPN(N)     = 0
                 GOTO 2400
d130 1
a130 1
              ELSEIF (ITEMP .EQ. 42) THEN
d132 1
a132 6
	         ITEMP1      = IRPN(LOC2) - 48
	         ITEMP2      = IRPN(LOC1) - 48
                 VAL(ITEMP1) = VAL(ITEMP1) * VAL(ITEMP2)
                 IRPN(LOC1)  = 0
                 IRPN(N)     = 0
                 GOTO 2400
d134 1
a134 1
              ELSEIF (ITEMP .EQ. 47) THEN
d136 1
a136 4
	         ITEMP1      = IRPN(LOC2) - 48
	         ITEMP2      = IRPN(LOC1) - 48
                 VALUE       = VAL(ITEMP2)
                 IF (VALUE.EQ. 0.) THEN
d140 1
a140 4
                 VAL(ITEMP1) = VAL(ITEMP1) / VALUE
                 IRPN(LOC1)  = 0
                 IRPN(N)     = 0
                 GOTO 2400
d142 1
a142 1
              ELSEIF (ITEMP .EQ. '^') THEN
d144 1
a144 6
	         ITEMP1      = IRPN(LOC2) - 48
	         ITEMP2      = IRPN(LOC1) - 48
                 VAL(ITEMP1) = VAL(ITEMP1) ** VAL(ITEMP2)
                 IRPN(LOC1)  = 0
                 IRPN(N)     = 0
                 GOTO 2400
d147 3
a149 4
C                HAS TO BE NUMERICAL POSITION ON THE STACK VAL.
                 LOC2 = LOC1
                 LOC1 = N
                 GOTO 2001
d151 5
d157 9
d167 22
a188 2
C             FOR MATH FUNCTIONS (SIN, COS, RAN, ETC)
	      ITEMP2 = IRPN(LOC1) - 48
d190 2
a191 2
C             IF (IFUNC .GT. 0 .AND. IFUNC .LT. 15) THEN
                 GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15), IFUNC
d194 1
a194 1
1   	         NPOW        = INT(ALOG(VAL(ITEMP2))/ALOG(2.0))
d196 2
a197 2
                 IF (VALUE .GE. VAL(ITEMP2))  THEN
	            VAL(ITEMP2) = VALUE
d199 1
a199 1
	            VAL(ITEMP2) = 2 * VALUE
d204 1
a204 1
2                VAL(ITEMP2) = SIN(VAL(ITEMP2)*0.017453293)
d208 2
a209 2
3	        VAL(ITEMP2) = EXP(VAL(ITEMP2))
                 GOTO 1900
d212 1
a212 2
4                VALUE = VAL(ITEMP2)
	         IF (VALUE .LE. 0.) THEN
d216 1
a216 1
	         VAL(ITEMP2) = ALOG10(VALUE)
d220 1
a220 1
5                VAL(ITEMP2) = COS(VAL(ITEMP2)*0.017453293)
d224 1
a224 2
6                VALUE = VAL(ITEMP2)
	         IF (VALUE .LT. 0.) THEN
d228 1
a228 1
	         VAL(ITEMP2) = SQRT(VALUE)
d231 2
a232 3
C             LOG10
7                VALUE = VAL(ITEMP2)
	         IF (VALUE .LE. 0.) THEN
d236 1
a236 1
	         VAL(ITEMP2) = ALOG(VALUE)
d240 1
a240 1
8	         VAL(ITEMP2) = INT(VAL(ITEMP2))
d244 1
a244 1
9	         VAL(ITEMP2) = ABS(VAL(ITEMP2))
d248 1
a248 1
10	         VAL(ITEMP2) = ATAN(VAL(ITEMP2))*57.29578
d252 1
a252 2
11	         VALUE = VAL(ITEMP2)
                 IF (ABS(VALUE) .GT. 1.0) THEN
d256 1
a256 1
	         VAL(ITEMP2) = ASIN(VALUE) * 57.29578
d260 1
a260 2
12	         VALUE = VAL(ITEMP2)
                 IF (ABS(VALUE) .GT. 1.0) THEN
d264 1
a264 1
	         VAL(ITEMP2) = ACOS(VALUE) * 57.29578
d267 2
a268 1
13	         VAL(ITEMP2) = TAN(VAL(ITEMP2) * 0.017453293)
d275 1
a275 1
                 VAL(ITEMP2) = VALUE
d278 1
a278 1
                 VAL(ITEMP2) = RAN(ISEED)
d280 1
a280 1
                 VAL(ITEMP2) = RAND_P(ISEED)
d286 1
a286 1
15	         VAL(ITEMP2) = -VAL(ITEMP2)
d290 6
a295 1
              IRPN(N) = 0
d303 1
d305 3
@


1.13
log
@used integer array instead of char array in rpn evaluation
@
text
@d43 1
a43 1
           IRPN(I) = RPNARRAY(I:I)
d64 4
@


1.12
log
@*** empty log message ***
@
text
@d19 1
a19 1
C       RPNARRAY    CHAR > ARRAY CONTAINS POSTFIX NOTATION       (SENT)
a25 4
C  NOTE:            TO ADD MORE MATH FUNCTIONS
C       1. LOOK FOR A COMMENT "ADD MORE MATH FUNCTIONS FOR CALCULATION"
C       2. INSERT YOUR MATH FUNCTION FOR CALCULATION
C
d31 2
a32 1
        COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
d37 1
a37 1
        COMMON   /RNDMSEED/   ISEED
d39 1
a39 1
C       SET ERROR RETURN FLAG
d42 6
a47 2
2400    LOC1=-1
        LOC2=-1
d50 62
a111 53
           CTEMP = RPNARRAY(N:N)
           IF(CTEMP.EQ.' ') GOTO 2001
C  ICHAR('a') = 97
           IFUNC = ICHAR(CTEMP)-96
C CURRENTLY FUNCTIONS a-o (1-15)
	   IF(IFUNC.LE.0) THEN
C             CTEMP IS NOT A FUNCTION LETTER
             IF (CTEMP .EQ. '+' ) THEN
C  ICHAR('0')=48
	      ITEMP1 = ICHAR(RPNARRAY(LOC2:LOC2)) - 48
	      ITEMP2 = ICHAR(RPNARRAY(LOC1:LOC1)) - 48
C  ADDITION
              VAL(ITEMP1) = VAL(ITEMP1) + VAL(ITEMP2)
              RPNARRAY(LOC1:LOC1) = ' '
              RPNARRAY(N:N) = ' '
              GOTO 2400
              ELSEIF (CTEMP .EQ. '-') THEN
	      ITEMP1 = ICHAR(RPNARRAY(LOC2:LOC2)) - 48
	      ITEMP2 = ICHAR(RPNARRAY(LOC1:LOC1)) - 48
C  SUBTRACTION
              VAL(ITEMP1) = VAL(ITEMP1) - VAL(ITEMP2)
              RPNARRAY(LOC1:LOC1) = ' '
              RPNARRAY(N:N) = ' '
              GOTO 2400
              ELSEIF (CTEMP .EQ. '*') THEN
	      ITEMP1 = ICHAR(RPNARRAY(LOC2:LOC2)) - 48
	      ITEMP2 = ICHAR(RPNARRAY(LOC1:LOC1)) - 48
C MULTIPLICATION
              VAL(ITEMP1) = VAL(ITEMP1) * VAL(ITEMP2)
              RPNARRAY(LOC1:LOC1) = ' '
              RPNARRAY(N:N) = ' '
              GOTO 2400
              ELSEIF (CTEMP .EQ. '/') THEN
	      ITEMP1 = ICHAR(RPNARRAY(LOC2:LOC2)) - 48
	      ITEMP2 = ICHAR(RPNARRAY(LOC1:LOC1)) - 48
C  DIVISION
              VALUE=VAL(ITEMP2)
                IF (VALUE.EQ. 0.) THEN
                 CALL ERRT(43,'CALC - DIVISION BY ZERO',NE)
                 RETURN
                ENDIF
              VAL(ITEMP1) =VAL(ITEMP1) / VALUE
              RPNARRAY(LOC1:LOC1) = ' '
              RPNARRAY(N:N) = ' '
              GOTO 2400
              ELSEIF (CTEMP .EQ. '^') THEN
C  POWER
	      ITEMP1 = ICHAR(RPNARRAY(LOC2:LOC2)) - 48
	      ITEMP2 = ICHAR(RPNARRAY(LOC1:LOC1)) - 48
              VAL(ITEMP1) = VAL(ITEMP1) ** VAL(ITEMP2)
              RPNARRAY(LOC1:LOC1) = ' '
              RPNARRAY(N:N) = ' '
              GOTO 2400
d113 6
a118 5
C HAS TO BE NUMERICAL POSITION ON THE STACK VAL.
              LOC2=LOC1
              LOC1=N
              GOTO 2001
             ENDIF
d120 2
a121 13
	    ITEMP2 = ICHAR(RPNARRAY(LOC1:LOC1)) - 48
C MATH FUNCTIONS
C           IF(IFUNC.GT.0.AND.IFUNC.LT.15) THEN
            GOTO (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15), IFUNC

1   	      NPOW        = INT(ALOG(VAL(ITEMP2))/ALOG(2.0))
	      VALUE = 2**NPOW
              IF(VALUE.GE.VAL(ITEMP2))  THEN
	      VAL(ITEMP2) = VALUE
              ELSE
	      VAL(ITEMP2) = 2*VALUE
              ENDIF
              GOTO 1900
d123 2
a124 2
2             VAL(ITEMP2) = SIN(VAL(ITEMP2)*0.017453293)
              GOTO 1900
d126 17
a142 2
3	      VAL(ITEMP2) = EXP(VAL(ITEMP2))
              GOTO 1900
d144 42
a185 35
4             VALUE = VAL(ITEMP2)
	      IF (VALUE .LE. 0.) THEN
                 CALL ERRT(43,'CALC - LOG',NE)
                 RETURN
	      ENDIF
	      VAL(ITEMP2) = ALOG10(VALUE)
              GOTO 1900

5             VAL(ITEMP2) = COS(VAL(ITEMP2)*0.017453293)
              GOTO 1900
  	  
6             VALUE = VAL(ITEMP2)
	      IF (VALUE.LT.0.) THEN
                 CALL ERRT(43,'CALC - SQRT',NE)
                 RETURN
	      ENDIF
	      VAL(ITEMP2) = SQRT(VALUE)
              GOTO 1900

7             VALUE = VAL(ITEMP2)
	      IF (VALUE .LE. 0.) THEN
                 CALL ERRT(43,'CALC - LON',NE)
                 RETURN
	      ENDIF
	      VAL(ITEMP2) = ALOG(VALUE)
              GOTO 1900

8	      VAL(ITEMP2) = INT(VAL(ITEMP2))
              GOTO 1900

9	      VAL(ITEMP2) = ABS(VAL(ITEMP2))
              GOTO 1900

10	      VAL(ITEMP2) = ATAN(VAL(ITEMP2))*57.29578
              GOTO 1900
d187 17
a203 15
11	      VALUE = VAL(ITEMP2)
              IF(ABS(VALUE) .GT. 1.0) THEN
	         CALL ERRT(43,'CALC - ASIN',NE)
                 RETURN
	      ENDIF
	      VAL(ITEMP2) = ASIN(VALUE)*57.29578
              GOTO 1900

12	      VALUE = VAL(ITEMP2)
              IF(ABS(VALUE) .GT. 1.0) THEN
	         CALL ERRT(43,'CALC - ACOS',NE)
                 RETURN
	      ENDIF
	      VAL(ITEMP2) = ACOS(VALUE)*57.29578
              GOTO 1900
d205 2
a206 2
13	      VAL(ITEMP2) = TAN(VAL(ITEMP2)*0.017453293)
              GOTO 1900
d208 2
d211 2
a212 2
14            CALL  RANDOM_NUMBER(VALUE)
              VAL(ITEMP2) = VALUE
d215 1
a215 1
14            VAL(ITEMP2) = RAN(ISEED)
d217 1
a217 1
14            VAL(ITEMP2) = RAND_P(ISEED)
d220 1
a220 1
              GOTO 1900
d222 3
a224 6
C  UNITARY change the sign
15	      VAL(ITEMP2) = -VAL(ITEMP2)
C             GOTO 1900
1900       CONTINUE
                RPNARRAY(N:N) = ' '
                GOTO 2400
d226 3
d231 1
a231 4



2001         CONTINUE
d236 1
@


1.11
log
@tan fixed
@
text
@d167 1
a167 1
	         CALL ERRT(43,'CALC - ACOSASIN',NE)
@


1.10
log
@*** empty log message ***
@
text
@d181 1
a181 1
13	      VAL(ITEMP2) = TAN(VAL(ITEMP2))
@


1.9
log
@TAN
@
text
@a39 1
	LOGICAL         SIGN_TEST,LETTER_TEST
@


1.8
log
@NEW VERSION
@
text
@d61 1
a61 1
C  PLUS SIGN
d69 1
a69 1
C  MINUS SIGN
d88 1
a88 2
                 WRITE(NOUT,*) ' *** DIVISION BY ZERO'
                 CALL ERRT(43,'CALC',NE)
d124 1
a124 1
2              VAL(ITEMP2) = SIN(VAL(ITEMP2)*0.017453293)
d130 1
a130 1
4              VALUE = VAL(ITEMP2)
d132 1
a132 1
                 CALL ERRT(43,'CALC',NE)
d138 1
a138 1
5               VAL(ITEMP2) = COS(VAL(ITEMP2)*0.017453293)
d141 1
a141 1
6              VALUE = VAL(ITEMP2)
d143 1
a143 1
                 CALL ERRT(43,'CALC',NE)
d149 6
a154 1
7	      VAL(ITEMP2) = ALOG(VAL(ITEMP2))
d166 3
a168 2
11	      IF (ABS(ITEMP2) .GT. 1) THEN
	         CALL ERRT(43,'CALC',NE)
d171 1
a171 1
	      VAL(ITEMP2) = ASIN(VAL(ITEMP2))*57.29578
d174 3
a176 2
12	      IF (ABS(ITEMP2).GT.1) THEN
	         CALL ERRT(43,'CALC',NE)
d179 1
a179 1
	      VAL(ITEMP2) = ACOS(VAL(ITEMP2))*57.29578
d182 1
a182 5
13	      IF (VAL(ITEMP2).LE.0.) THEN
		 CALL ERRT(43,'CALC',NE)
                 RETURN
	      ENDIF
	      VAL(ITEMP2) = ALOG(VAL(ITEMP2))
d186 1
a186 1
14              CALL  RANDOM_NUMBER(VALUE)
d190 1
a190 1
14              VAL(ITEMP2) = RAN(ISEED)
d192 1
a192 1
14              VAL(ITEMP2) = RAND_P(ISEED)
d199 1
a199 1
C              GOTO 1900
@


1.7
log
@OK?
@
text
@d14 1
a14 1
C  CALC(RPNARRAY,VAL,NVAL)
d32 1
a32 1
	SUBROUTINE CALC(RPNARRAY,VAL,NVAL,IRTFLG)
d37 1
a37 3
        PARAMETER       (IPOLEN = 40)

	DIMENSION       VAL(IPOLEN)
d41 1
a41 2

        DATA            PI/3.141592654/
d46 2
a47 1
	I = NVAL
d49 1
a49 1
24	DO  N=1,I
d51 5
a55 1
	   IF (.NOT. LETTER_TEST(CTEMP)) THEN
d57 5
a61 8
              IF (NRQ(CTEMP) .NE. -1) GOTO 13
	   ENDIF

	   ITEMP1 = ICHAR(RPNARRAY(N-2:N-2)) - ICHAR('0') 
	   ITEMP2 = ICHAR(RPNARRAY(N-1:N-1)) - ICHAR('0')

	   IF (CTEMP.EQ.'+') THEN
C             PLUS SIGN
d63 7
a69 3

	   ELSEIF (CTEMP.EQ.'-') THEN
C             MINUS SIGN
d71 7
a77 3
	     
           ELSEIF (CTEMP.EQ.'*') THEN
C             MULTIPLICATION
d79 9
a87 4

           ELSEIF (CTEMP.EQ.'/') THEN
C             DIVISION
              IF (VAL(ITEMP2).EQ. 0.) THEN
d91 31
d123 1
a123 6
              VAL(ITEMP1) =VAL(ITEMP1) / VAL(ITEMP2)

	   ELSEIF (CTEMP .EQ. '^') THEN
              VAL(ITEMP1) = VAL(ITEMP1) ** VAL(ITEMP2)

C          ADD YOUR MATH FUNCTIONS FOR CALCULATION
d125 2
a126 9
           ELSEIF (CTEMP .EQ. 'a') THEN      
   	      NPOW        = LOG(VAL(ITEMP2))
	      VAL(ITEMP2) = 2**NPOW 

 	   ELSEIF (CTEMP .EQ. 'b') THEN
	      VALUE =  VAL(ITEMP2) / 180.0 * PI
C             CHANGED TO DEGREES 7/89 MR
              VALUE = SIN(VAL(ITEMP2) / 180.0 * PI)
	      VAL(ITEMP2) = VALUE
d128 2
a129 2
           ELSEIF (CTEMP .EQ. 'c') THEN
	      VAL(ITEMP2) = EXP(VAL(ITEMP2))
d131 1
a131 1
           ELSEIF (CTEMP .EQ. 'd') THEN
d136 2
a137 1
	      VAL(ITEMP2) = ALOG10(VAL(ITEMP2))
d139 2
a140 5
           ELSEIF (CTEMP .EQ. 'e') THEN
	       VALUE =  VAL(ITEMP2) / 180.*PI
C              CHANGED TO DEGREES 7/89 MR
               VALUE       = COS(VAL(ITEMP2) / 180.0 * PI)
	       VAL(ITEMP2) = VALUE
d142 1
a142 1
           ELSEIF (CTEMP .EQ. 'f') THEN
d147 2
a148 1
	      VAL(ITEMP2) = SQRT(VAL(ITEMP2))
d150 2
a151 2
           ELSEIF (CTEMP .EQ. 'g') THEN
	      TEMP = MOD(VAL(ITEMP1),VAL(ITEMP2))
d153 2
a154 2
           ELSEIF (CTEMP .EQ. 'h') THEN
	      VAL(ITEMP2) = INT(VAL(ITEMP2))
d156 2
a157 2
           ELSEIF (CTEMP .EQ. 'i') THEN
	      IF (VALUE .LT. 0.0) VAL(ITEMP2) = -VAL(ITEMP2)
d159 2
a160 4
           ELSEIF (CTEMP .EQ. 'j') THEN
	      VALUE       = ATAN(VAL(ITEMP2))        
	      VALUE       = VALUE / PI * 180.0
	      VAL(ITEMP2) = VALUE
d162 1
a162 2
           ELSEIF (CTEMP .EQ. 'k') THEN
	      IF (ABS(ITEMP2) .GT. 1) THEN
d166 2
a167 3
	      VALUE = ASIN(VAL(ITEMP2))
	      VALUE = VALUE  /PI * 180.0
	      VAL(ITEMP2) = VALUE
d169 1
a169 2
	   ELSEIF (CTEMP .EQ. 'l') THEN
	      IF (ABS(ITEMP2).GT.1) THEN
d173 2
a174 3
	      VALUE = ACOS(VAL(ITEMP2))
	      VALUE = VALUE / PI * 180.0
	      VAL(ITEMP2) = VALUE
d176 1
a176 2
	   ELSEIF (CTEMP .EQ. 'm') THEN
	      IF (VAL(ITEMP2).LE.0.) THEN
d180 2
a181 1
	      VAL(ITEMP2) = LOG(VAL(ITEMP2))
d183 22
a204 16
	   ELSEIF (CTEMP .EQ. 'n') THEN
              VAL(ITEMP2) = RAND(VAL(ITEMP2))
	   ENDIF

C          THIS APPEARS TO 'POP' THE WHOLE RPNARRAY CHAR. ARRAY
	   IF (SIGN_TEST(CTEMP) .OR. CTEMP .EQ. 'g') THEN
              DO  L=N-1,I-2
                 RPNARRAY(L:L) = RPNARRAY(L+2:L+2)
              ENDDO
	      I = I - 2
	   ELSE
	      DO  L=N,I-1
                RPNARRAY(L:L) = RPNARRAY(L+1:L+1)
              ENDDO
              I = I - 1
	   ENDIF
a205 1
           GOTO 24
d207 1
a207 1
13         CONTINUE
@


1.6
log
@*** empty log message ***
@
text
@a182 1
        RETURN
a183 6






@


1.5
log
@cleaned up logic & added comments
@
text
@d37 1
a37 1
        PARAMETER       (POLEN = 40)
d39 1
a39 1
	DIMENSION       VAL(POLEN)
@


1.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
C CALC.F                  ADAPTED FROM CALC.F CHAR MAR 98 AL
d6 6
a11 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH                            *
d14 16
a29 10
C CALC(POLISH,VAL,COUNTER)
C       POLISH      ARRAY CONTAINS POSTFIX NOTATION
C       VAL         ARRAY CONTAINS ASSOCIATED WITH INDEX ON POLISH ARRAY
C       COUNTER     HOW MANY ELEMENTS IN POLISH ARRAY
C PURPOSE:   EVALUATES EXPRESSIONS IN THE POSTFIX FORM, RETURNS VALUE
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C                     TO ADD MORE MATH FUNCTIONS
C                     1. LOOK FOR A COMMENT "ADD MORE MATH FUNCTIONS FOR CALCULATION"
C                     2. INSERT YOUR MATH FUNCTION FOR CALCULATION
d31 2
a32 1
	SUBROUTINE CALC(POLISH,VAL,COUNTER)
a35 3
	COMMON /PARAM/  PARAM(103),NSEL(10)
        CHARACTER *80   FCHAR
	COMMON/FUNCTION/FCHAR
d37 1
a37 3
	DIMENSION      VAL(40)
        CHARACTER *81  POLISH
        CHARACTER      CTEMP,NEXT,JCHAR,CTEMP1,CTEMM1
d39 4
a42 3
	LOGICAL        GFLAG,ISDIGI,SIGN_TEST,LETTER_TEST
	INTEGER        COUNTER
        DATA           PI/3.141592654/,GFLAG/.FALSE./
d44 1
a44 1
	I = COUNTER
d46 2
d49 1
a49 5
24	DO 13 N=1,I
           CTEMP=POLISH(N:N)
	IF (.NOT. LETTER_TEST(CTEMP)) THEN
           IF (NRQ(CTEMP).NE.-1) GOTO 13
	ENDIF
d51 6
a56 2
	ITEMP1 = ICHAR(POLISH(N-2:N-2)) - ICHAR('0') 
	ITEMP2 = ICHAR(POLISH(N-1:N-1)) - ICHAR('0')
d58 2
d61 7
a67 6
        IF (CTEMP.EQ.'+') THEN
          VAL(ITEMP1) =VAL(ITEMP1)+VAL(ITEMP2)


        ELSEIF (CTEMP.EQ.'-') THEN
          VAL(ITEMP1) =VAL(ITEMP1)-VAL(ITEMP2)
d69 7
a75 6

        ELSEIF (CTEMP.EQ.'*') THEN
          VAL(ITEMP1) =VAL(ITEMP1)*VAL(ITEMP2)

        ELSEIF (CTEMP.EQ.'/') THEN
              IF(VAL(ITEMP2).EQ. 0.) THEN
d77 2
a78 1
		 CALL ERRT(43,'AR',NE)
d80 1
a80 1
             VAL(ITEMP1) =VAL(ITEMP1)/VAL(ITEMP2)
d82 2
a83 2
	 ELSEIF (CTEMP .EQ. '^') THEN
             VAL(ITEMP1) =VAL(ITEMP1)**VAL(ITEMP2)
d85 1
a85 1
C       Add YOUR MATH FUNCTIONS FOR CALCULATION
d87 3
a89 3
        ELSEIF (CTEMP .EQ. 'a') THEN      
   	    NPOW=LOG(VAL(ITEMP2))
	    VAL(ITEMP2) = 2**NPOW 
d91 5
a95 5
 	ELSEIF (CTEMP .EQ. 'b') THEN
		VALUE =  VAL(ITEMP2)/180.*PI
C       	CHANGED TO DEGREES 7/89 MR
        	VALUE = SIN(VAL(ITEMP2)/180.*PI)
		VAL(ITEMP2)=VALUE
d97 2
a98 2
        ELSEIF (CTEMP .EQ. 'c') THEN
		VAL(ITEMP2) = EXP(VAL(ITEMP2))
d100 12
a111 11
        ELSEIF (CTEMP .EQ. 'd') THEN
		IF (VALUE.LE.0.) THEN
		   CALL ERRT(43,'AR',NE)
		   ENDIF
		VAL(ITEMP2) = ALOG10(VAL(ITEMP2))

        ELSEIF (CTEMP .EQ. 'e') THEN
		VALUE =  VAL(ITEMP2)/180.*PI
C       	CHANGED TO DEGREES 7/89 MR
        	VALUE = COS(VAL(ITEMP2)/180.*PI)
		VAL(ITEMP2)=VALUE
d113 6
a118 9
	ELSEIF (CTEMP .EQ. 'f') THEN
		IF (VALUE.LT.0.) THEN
		    CALL ERRT(43,'AR',NE)
		   ENDIF
		VAL(ITEMP2) = SQRT(VAL(ITEMP2))

	ELSEIF (CTEMP .EQ. 'g') THEN
	   TEMP = MOD(VAL(ITEMP1),VAL(ITEMP2))

d120 2
a121 2
	ELSEIF (CTEMP .EQ. 'h') THEN
	   VAL(ITEMP2) = INT(VAL(ITEMP2))
d123 2
d126 2
a127 2
	ELSEIF (CTEMP .EQ. 'i') THEN
	   IF (VALUE.LT.0.0) VAL(ITEMP2) = -VAL(ITEMP2)
d129 4
a132 4
	ELSEIF (CTEMP .EQ. 'j') THEN
	   VALUE = ATAN(VAL(ITEMP2))        
	   VALUE = VALUE/PI*180.
	   VAL(ITEMP2) = VALUE
d134 27
a160 3
	ELSEIF (CTEMP .EQ. 'k') THEN
	   IF (ABS(ITEMP2).GT.1) THEN
	      CALL ERRT(43,'AR',NE)
d162 12
a173 7
	   VALUE = ASIN(VAL(ITEMP2))
	   VALUE = VALUE/PI*180.
	   VAL(ITEMP2) = VALUE

	ELSEIF (CTEMP .EQ. 'l') THEN
	   IF (ABS(ITEMP2).GT.1) THEN
	      CALL ERRT(43,'AR',NE)
a174 25
	   VALUE = ACOS(VAL(ITEMP2))
	   VALUE = VALUE/PI*180.
	   VAL(ITEMP2) = VALUE

        ELSEIF (CTEMP .EQ. 'm') THEN
	   IF (VAL(ITEMP2).LE.0.) THEN
		CALL ERRT(43,'AR',NE)
	      ENDIF
	   VAL(ITEMP2) = LOG(VAL(ITEMP2))
 
        ELSEIF (CTEMP .EQ. 'n') THEN
             VAL(ITEMP2) =RAND(VAL(ITEMP2))
      ENDIF

	IF (SIGN_TEST(CTEMP) .OR. CTEMP .EQ. 'g') THEN
           DO  L=N-1,I-2
             POLISH(L:L)=POLISH(L+2:L+2)
           ENDDO
	 I=I-2
	ELSE
	DO  L=N,I-1
             POLISH(L:L)=POLISH(L+1:L+1)
           ENDDO
           I=I-1
	ENDIF
d177 4
a180 1
13	CONTINUE
d182 2
@


1.3
log
@*** empty log message ***
@
text
@d1 25
a28 3
C                     1. look for a comment "ADD MORE MATH FUNCTIONS FOR CALCULATION"
C                     2. insert your math function for calculation

d39 2
a40 2
	INTEGER COUNTER
        DATA PI/3.141592654/,GFLAG/.FALSE./
a41 1
C       SET ERROR RETURN
d55 2
a56 2
           IF (CTEMP.EQ.'+') THEN
             TEMP=VAL(ITEMP1)+VAL(ITEMP2)
d59 2
a60 2
           ELSEIF (CTEMP.EQ.'-') THEN
             TEMP=VAL(ITEMP1)-VAL(ITEMP2)
d63 2
a64 2
           ELSEIF (CTEMP.EQ.'*') THEN
             TEMP=VAL(ITEMP1)*VAL(ITEMP2)
d66 1
a66 1
           ELSEIF (CTEMP.EQ.'/') THEN
d71 4
a74 1
              TEMP=VAL(ITEMP1)/VAL(ITEMP2)
d78 1
a78 1
      ELSEIF (CTEMP .EQ. 'a') THEN      
d103 1
a103 1
	 ELSEIF (CTEMP .EQ. 'f') THEN
d110 1
a110 1
        TEMP = MOD(VAL(ITEMP1),VAL(ITEMP2))
d114 1
a114 1
	VAL(ITEMP2) = INT(VAL(ITEMP2))
d118 1
a118 1
	IF (VALUE.LT.0.0) VAL(ITEMP2) = -VAL(ITEMP2)
d121 3
a123 4
	VALUE = ATAN(VAL(ITEMP2))        
C       ADDED ON 8/27/86 BY NAIK
        VALUE = VALUE/PI*180.
	VAL(ITEMP2) = VALUE
d126 2
a127 2
        IF (ABS(ITEMP2).GT.1) THEN
	 CALL ERRT(43,'AR',NE)
d129 3
a131 4
	
        VALUE = ASIN(VAL(ITEMP2))
        VALUE = VALUE/PI*180.
	VAL(ITEMP2) = VALUE
d134 2
a135 2
	IF (ABS(ITEMP2).GT.1) THEN
	 CALL ERRT(43,'AR',NE)
d137 3
a139 4
	
        VALUE = ACOS(VAL(ITEMP2))
        VALUE = VALUE/PI*180.
	VAL(ITEMP2) = VALUE
d147 3
a149 13
          ELSEIF(VAL(ITEMP1).LT.0.) THEN
              IV=VAL(ITEMP2)
              DIF=ABS(VAL(ITEMP2)-IV)
              IF(DIF.LT.0.001) THEN
                 TEMP=VAL(ITEMP1)**IV
              ELSE
                 WRITE(NOUT,*) ' *** UNDEFINED EXPONENTIATION'
		  CALL ERRT(43,'AR',NE)
              ENDIF

         ELSEIF (CTEMP .EQ. '^') THEN
              TEMP=VAL(ITEMP1)**VAL(ITEMP2)
            ENDIF
d151 1
a151 2
	if (SIGN_TEST(CTEMP) .OR. CTEMP .EQ. 'g') THEN
	   VAL(ITEMP1)=TEMP
d167 6
@


1.2
log
@*** empty log message ***
@
text
@a20 1
        IFLAG = -1
d54 4
d120 5
a124 1
C End by Evan
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
CNO_STATIC
@
