head	1.48;
access;
symbols
	pre_getangas:1.47
	GPL2010:1.44
	pre_GPL2010:1.43
	pre_var_equation:1.43
	pre_fftwrings:1.43
	pre_opfiles:1.43
	src:1.43
	best-code:1.42
	x-named-regs:1.42
	x:1.42
	v13-00:1.42
	pre_GPL:1.40
	prec_CA:1.40
	noindx:1.39
	Bproc:1.34
	oct21:1.32
	last77:1.31;
locks; strict;
comment	@c @;


1.48
date	2012.07.25.14.55.23;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2011.01.31.13.10.45;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2011.01.03.17.31.37;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2010.10.21.17.46.21;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.24.13.26.24;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.28.19.26.28;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.17.20.01.10;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.17.17.56.57;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.08.15.40.38;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.13.20.52.36;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.13.20.34.13;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.16.19.40.00;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2001.01.04.18.50.41;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.15.13.48.26;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2000.06.29.19.49.38;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	99.12.28.17.30.36;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	99.04.07.13.43.06;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	99.03.29.20.16.03;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	99.03.29.15.15.22;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	99.03.15.15.30.17;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	99.03.12.20.50.10;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	99.02.08.18.06.36;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	99.02.08.17.52.28;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	98.04.09.13.15.29;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	98.04.07.18.10.14;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	98.04.07.15.36.51;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	98.04.07.14.17.09;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	98.04.07.12.30.25;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	98.04.03.21.22.34;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	98.04.03.21.16.29;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	98.04.03.21.12.49;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	98.04.03.20.59.23;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	98.01.27.17.16.59;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	97.10.15.18.10.12;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	97.10.07.19.30.55;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	97.04.21.13.02.32;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	96.12.19.18.49.34;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	96.12.17.17.34.00;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	96.11.22.20.52.43;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	96.11.21.19.27.52;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	96.08.29.15.26.04;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	96.08.22.15.33.04;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	95.08.30.12.49.39;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	95.08.18.14.06.29;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	95.08.18.14.04.45;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	95.08.17.18.26.35;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	95.08.16.16.43.58;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	95.08.11.17.41.27;	author leith;	state Exp;
branches;
next	;


desc
@new runtime inline buffer alteration
@


1.48
log
@TOBEDEALLOC OVERFLOW BUG fixed   for deleting non-existing inline file
@
text
@
C++*********************************************************************
C
C OPENINLN.F       AUTHOR                                  ARDEAN LEITH
C                  INCREASED NUMINLNT               AUG 02 ARDEAN LEITH
C                  SUPPORTS INTEGER 8               OCT 10 ARDEAN LEITH                            
C                  TOBEDEALLOC OVERFLOW BUG         JUL 12 ARDEAN LEITH                            
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    OPENINLN(LUN,NUMBUF,NEEDNEW,NSAM,NWORDS8,NEEDERRT,IRTFLG))
C
C    PURPOSE:       TO OPEN A INLINE BUFFER FOR READING/WRITING 
C                   VIA REDLIN AND WRTLIN.
C
C    PARAMETERS:    LUN      EQUIVALENT LUN                    (SENT)
C                   NUMBUF   BUFFER NUMBER                     (SENT)
C                   NEEDNEW  LOGICAL FLAG THAT WANT NEW BUFFER (SENT)
C                   NSAM     LENGTH OF ROW USED IN BUFFER      (SENT)
C                   NWORDS8  SIZE OF BUFFER                    (SENT)
C                   NEEDERRT NEED TO CALL ERRT AND END IF ERROR(SENT)
C                   IRTFLG   ERROR FLAG                        (RETURNED)
C
C    NOTE:  jan 2011 should we zero the array so as to better detect
C           non-existing images??
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

      MODULE INLN_INFO

         SAVE

         INTEGER, PARAMETER    :: NUMINLNT = 99
         INTEGER, PARAMETER    :: NUMLUNST = 100

         TYPE REAL_POINTER
            REAL, POINTER      :: IPT(:) 
         END TYPE REAL_POINTER

         TYPE(REAL_POINTER)    :: LOCBUF(NUMINLNT)
         TYPE(REAL_POINTER)    :: LOCLUN(NUMLUNST)

         INTEGER               :: NSAMLUN(NUMLUNST)

         INTEGER, PARAMETER    :: I_8 = SELECTED_INT_KIND(12)
         INTEGER(KIND=I_8)     :: NWORDLUN(NUMLUNST)

      END MODULE INLN_INFO

C     ---------------- OPENINLN -----------------------------

      SUBROUTINE OPENINLN(LUN,NUMBUF,NEEDNEW,NSAM,NWORDS8,
     &                    NEEDERRT,IRTFLG)

      USE INLN_INFO
      INCLUDE 'INLN_INFO.INC'

      INCLUDE 'CMBLOCK.INC'

      LOGICAL           :: NEEDNEW,NEEDERRT,DUPED
      INTEGER           :: LUN,NUMBUF,NSAM,IRTFLG
      INTEGER(KIND=I_8) :: NWORDS8
      INTEGER           :: NDEALLOC
      REAL,  POINTER    :: RPOINTER(:)
      INTEGER(KIND=I_8) :: NWORDBUF(NUMINLN)
      INTEGER           :: TOBEDEALLOC(NUMINLN)

      SAVE NWORDBUF,TOBEDEALLOC,NDEALLOC

      DATA NDEALLOC/0/

      IRTFLG = 1
      IF (LUN .LE. 0 .OR. LUN .GT. 100) THEN
C        NO SUCH LUN
         CALL ERRT(102,'PGM ERROR, BAD LUN IN OPENINLN',LUN)
         RETURN

      ELSEIF (NUMBUF .LE. 0 .OR. NUMBUF .GT. NUMINLN) THEN
C        NO SUCH BUFFER
         ITEMP = NUMINLN
         WRITE(NOUT,90) ITEMP,NUMBUF
90       FORMAT(' *** INLINE BUFFERS AVAILABLE:  1...',I3,
     &          ' BUT YOU WANTED: ',I4)
         CALL ERRT(100,'OPENINLN',NE)
         RETURN
      ENDIF

      IF (NEEDNEW .AND. (NSAM == 0 .OR. NWORDS8 == 0))THEN
C        WANT TO DEALLOCATE AND CLOSE AN OPEN INLINE BUFFER,
C        BUT WE WILL WAIT TILL NEXT ALLOCATE TO ACTUALLY 
C        DEALLOCATE, SO AS TO MINIMIZE MEMORY LEAK

         IF (NDEALLOC > 0) THEN
            DO I = 1,NDEALLOC
               IF ( NUMBUF  == TOBEDEALLOC(I)) THEN
C                 ALREADY IN LIST, DO NOT ADD DUPLICATE
                  IRTFLG = 0
                  RETURN
               ENDIF
            ENDDO
         ENDIF

C        PUT BUFFER NUMBER ON DELETION LIST
         NDEALLOC               = NDEALLOC + 1
         TOBEDEALLOC(NDEALLOC)  = NUMBUF

C        ADDED DEC 06 FOR BUFFER IN AND OUT USE al
         NWORDBUF(NUMBUF)  = 0
         NSAMBUF(NUMBUF)   = 0
         IRECBUF(NUMBUF)   = 0
         LABRECBUF(NUMBUF) = 0
         IRTFLG            = 0
         RETURN

      ELSEIF (NDEALLOC > 0) THEN
C        DEALLOCATE ALL BUFFERS ON DELETION LIST

         DO I = 1,NDEALLOC
            NTEMP = TOBEDEALLOC(I)
            DUPED = .FALSE.
            IF (I > 1) THEN
               DO J=1,I-1
                  IF (TOBEDEALLOC(J) == NTEMP) DUPED = .TRUE.
               ENDDO
            ENDIF  
            IF (.NOT. DUPED) THEN     
               RPOINTER => LOCBUF(NTEMP)%IPT
               IF (ASSOCIATED(RPOINTER)) THEN
                  DEALLOCATE(RPOINTER,STAT=IRTFLGT)
               ENDIF

C              ZERO BUFFER SIZE, POINTER, NSAM, ETC...
               NULLIFY(LOCBUF(NTEMP)%IPT)
               NWORDBUF(NTEMP)  = 0
               NSAMBUF(NTEMP)   = 0
               IRECBUF(NTEMP)   = 0
               LABRECBUF(NTEMP) = 0
            ENDIF
         ENDDO
         NDEALLOC = 0
      ENDIF

1111  CONTINUE
      IF (NEEDNEW .AND. 
     &   (ASSOCIATED(LOCBUF(NUMBUF)%IPT)) .AND.
     &    (NWORDBUF(NUMBUF) .NE. NWORDS8)) THEN
C        FREE EXISTING SPACE ALLOCATION FOR THIS FILE
         RPOINTER => LOCBUF(NUMBUF)%IPT
         DEALLOCATE(RPOINTER,STAT=IRTFLGT)
         IF (IRTFLGT .NE. 0) RETURN

         NWORDBUF(NUMBUF) = 0
         NULLIFY(LOCBUF(NUMBUF)%IPT) 
      ENDIF

      IF (NEEDNEW .AND. .NOT. ASSOCIATED(LOCBUF(NUMBUF)%IPT)) THEN
C        MUST ALLOCATE SPACE FOR THIS BUFFER
         !print *,' allocating: ',nwords8

         ALLOCATE(RPOINTER(NWORDS8),STAT=IRTFLGT)
         IF (IRTFLGT .NE. 0) THEN
            WRITE(NOUT,92) NWORDS8,NUMBUF  
92          FORMAT(' *** CAN NOT ALLOCATE:',I12,
     &             '  WORDS FOR INLINE FILE: _',I1)  
            CALL ERRT(102,'ALLOCATION FAILED FOR INLINE FILE',NUMBUF)
            RETURN
         ENDIF

         LOCBUF(NUMBUF)%IPT => RPOINTER
         NWORDBUF(NUMBUF)   = NWORDS8
         NSAMBUF(NUMBUF)    = NSAM
         !print *,' nwordbuf(',numbuf,'):',NWORDBUF(NUMBUF)
      ENDIF

      RPOINTER        => LOCBUF(NUMBUF)%IPT
      LOCLUN(LUN)%IPT => RPOINTER
      ISINLINE(LUN)   =  .TRUE.

      IF (.NOT. NEEDNEW) THEN
C        RETRIEVE RECORD LENGTH FROM PREVIOUSLY SET VALUE
         NSAM = NSAMBUF(NUMBUF)
         IF (NSAM .LE. 0) THEN
C           NO PREVIOUS RUN-TIME FILE AVAILABLE
            WRITE(NOUT,93) NUMBUF
93          FORMAT(' *** NO EXISTING INLINE BUFFER: ',I3)
            IF (NEEDERRT) 
     &         CALL ERRT(102,'NO EXISTING INLINE BUFFER',NUMBUF)
            RETURN
         ENDIF
      ENDIF

C     SET LENGTH OF RECORD AND BUFFER FOR THIS LUN
      NSAMLUN(LUN)    = NSAM
      NWORDLUN(LUN)   = NWORDBUF(NUMBUF)
      LOCLUN(LUN)%IPT => LOCBUF(NUMBUF)%IPT
      ISINLINE(LUN)   =  .TRUE.
      !print *,' nwordlun(',lun,'):',NWORDLUN(LUN)

      IF (NWORDS8 > NWORDLUN(LUN)) THEN
C        NOT ENOUGH SPACE IN BUFFER
         WRITE(NOUT,94) NUMBUF,NWORDLUN(LUN),NWORDS8
94       FORMAT(' *** INLINE BUFFER: ',I4,
     &          '  LIMITED TO:  ',     I12,
     &          ' WORDS, WANTED: ',    I12)
         CALL ERRT(100,'INLINE BUFFER OVERFLOW',NE)
         RETURN
      ENDIF

      IRTFLG = 0

      RETURN
      END



C++********************************************************************
C   CLOSEINLN.F                                
C **********************************************************************
C
C     CLOSEINLN(LUN,IRTFLG)
C
C     PURPOSE:    CLOSE AN INLN BUFFER USE
C
C **********************************************************************

       SUBROUTINE CLOSEINLN(LUN,IRTFLG)

       USE INLN_INFO
       INCLUDE 'INLN_INFO.INC'

       NULLIFY(LOCLUN(LUN)%IPT)
       ISINLINE(LUN) = .FALSE.

       IRTFLG = 0
       RETURN
       END


C++********************************************************************
C   INLN_WRTLIN.F                                
C **********************************************************************
C
C     INLN_WRTLIN(LUN,BUF,NB,NREC)
C
C     PURPOSE:    READ A LINE OF FLOATING POINT NUMBERS FROM BUFFER
C
C     PARAMETERS:
C        LUN    LOGICAL UNIT NUMBER OF FILE BEING READ
C        BUF    BUFFER WHERE RECORD IS READ IN
C        NB     NUMBER OF VALUES IN RECORD TO BE READ
C        NREC   RECORD TO BE READ
C 
C        IERR   ERROR CODE 1 IS RETURNED IN CASE OF ERROR
C               IERR IS DEFINED IN COMMON /IOERR/IERR
C 
C       MANY COMMANDS IN SPIDER READ A FILE, MANIPULATE THE DATA, AND
C       WRITE THE RESULTS INTO A FILE, ONLY TO HAVE THE NEXT COMMAND
C       READ THE DATA BACK AGAIN IN CORE TO MANIPULATE IT AND STORE
C       IT BACK TO A FILE THEN START THE CYCLE AGAIN...
C       TO SPEED UP THE PROCESS, THE USER HAS THE ABILITY TO HAVE THAT 
C       DATA KEPT IN INCORE MEMORY UNTIL HE/SHE DECIDES THAT HE/SHE 
C       WANTS IT IN A FILE.
C
C       DATA FROM A FILE IS STORED EXACTLY THE SAME WAY AS IT IS IN A
C       DISK FILE (I.E: A HEADER FOLLOWED BY NROWS OF DATA OF LENGTH NSAMS
C       REPEATED NSLICE TIMES).
C 
C--*******************************************************************

      SUBROUTINE INLN_WRTLIN(LUN,BUF,NB,NREC)

C     USE INLINE BUFFER COMMON AREA
      USE INLN_INFO

      REAL   BUF(NB)

      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

      REAL, POINTER :: IPTNOW(:)
      INTEGER *8    :: IGO

      IPTNOW => LOCLUN(LUN)%IPT

C     GET THE CORRECT OFFSET INTO THE BUFFER.
C     IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN)  
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) 
      IGO = IGO * NSAMLUN(LUN)  

      IF ((IGO + NB - 1 ) > NWORDLUN(LUN)) THEN
C        GOES OUT OF RESERVED BUFFER!
         WRITE(NOUT,"(A,I3,A,I6,A,I5,A,I4,A,I6,A,I6,A,I12)") 
     &      '*** INLN_WRTLIN ARRAY OVERFLOW, LUN: ',LUN,
     &      '   LENGTH:',        IGO + NB,
     &      '   NREC: ',         NREC,
     &      '   LUNARA(LUN) :',  LUNARA(LUN),
     &      '   LUNSTK(LUN):',   LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :', NSAMLUN(LUN),  
     &      '   NWORDLUN(LUN) :',NWORDLUN(LUN)  
         CALL ERRT(102,'INLINE BUFFER OVERFLOW ON LUN',LUN)
         IERR = 1
         RETURN

      ELSEIF (IGO < 0) THEN
C        BEFORE RESERVED BUFFER!
         WRITE(NOUT,"(A,I3,A,I6,A,I5,A,I5,A,I6,A,I6,A,I12)") 
     &      '*** INLN_WRTLIN ARRAY UNDERFLOW, LUN: ',LUN,
     &      '   IGO:',          IGO,
     &      '   NREC: ',        NREC,
     &      '   LUNARA(LUN) :', LUNARA(LUN),
     &      '   LUNSTK(LUN):',  LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :',NSAMLUN(LUN)  
         CALL ERRT(100,'WRTLIN',NE)
         IERR = 1
         RETURN
      ENDIF

C     WRITE THE BUFFER (THERE MAY BE A FASTER WAY TO DO THIS!!)
      DO I= 1,NB
         IPTNOW(IGO + I) = BUF(I) 
      ENDDO
      IERR = 0

      RETURN
      END




C++*********************************************************************
C   INLN_REDLIN.FOR                                 MAHIEDDINE LADJADJ
C **********************************************************************
C
C     INLN_REDLIN(LUN,BUF,NB,NREC)
C
C     PURPOSE:    READ A LINE OF FLOATING POINT NUMBERS FROM BUFFER
C
C     PARAMETERS:
C        LUN    LOGICAL UNIT NUMBER OF FILE BEING READ
C        BUF    BUFFER WHERE RECORD IS READ IN
C        NB     NUMBER OF VALUES IN RECORD TO BE READ
C        NREC   RECORD TO BE READ
C
C        IERR   ERROR CODE 1 IS RETURNED IN CASE OF ERROR
C               IERR IS DEFINED IN COMMON /IOERR/IERR
C 
C       MANY COMMANDS IN SPIDER READ A FILE, MANIPULATE THE DATA, AND
C       WRITE THE RESULTS INTO A FILE, ONLY TO HAVE THE NEXT COMMAND
C       READ THE DATA BACK AGAIN IN CORE TO MANIPULATE IT AND STORE
C       IT BACK TO A FILE THEN START THE CYCLE AGAIN...
C       TO SPEED UP THE PROCESS, THE USER HAS THE ABILITY TO HAVE THAT 
C       DATA KEPT IN INCORE MEMORY UNTIL HE DECIDES THAT HE WANTS IT IN
C       A FILE. FOR THAT, SPIDER OFFERS AN INCORE MEMORY IN A COMMON BLOCK
C       BUFFER:
C
C       THIS BUFFER CAN BE SUBDIVIDED INTO TWO PART TO HOLD TWO FILES, 
C       CALLED INFILES.
C       BY DEFAULT, THE INFILES ARE CALLED ___1 AND ___2. 
C
C       DATA FROM A FILE IS STORED EXACTLY THE SAME WAY AS IT IS IN 
C       DISK FILE (I.E: A HEADER FOLLOWED BY NROWS OF DATA OF LENGTH NSAMS
C       REPEATED NSLICE TIMES).
C 
C--*******************************************************************

      SUBROUTINE INLN_REDLIN(LUN,BUF,NB,NREC)

C     USE INLINE BUFFER COMMON AREA
      USE INLN_INFO

      REAL            BUF(NB)
      COMMON /IOERR/  IERR
      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

      REAL,  POINTER :: IPTNOW(:)
      INTEGER * 8    :: IGO

      IPTNOW  => LOCLUN(LUN)%IPT

C     GET THE CORRECT OFFSET INTO THE BUFFER.
C     IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN)
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) 
      IGO = IGO * NSAMLUN(LUN)

      IF ((IGO + NB - 1) > NWORDLUN(LUN)) THEN
C        GOES OUT OF RESERVED BUFFER!
         WRITE(NOUT,"(A,I5,A,I12)") 
     &          '*** INLN_REDLIN READS BEYOND BUFFER, LUN: ',LUN,
     &          ' LENGTH:' ,IGO + NB
         IERR = 1
         RETURN
      ENDIF

C     READ THE BUFFER (THERE MAY BE A FASTER WAY TO DO THIS!!)
      DO I= 1,NB
         BUF(I) = IPTNOW(IGO + I)
      ENDDO
      IERR = 0

      RETURN
      END

C++*********************************************************************
C   INLN_WRTVOX.F           NEW                    SEPT 03 ARDEAN LEITH                     
C **********************************************************************
C
C  INLN_WRTVOX(LUN,NROW,BUF,NB,IX,IY,IZ,IRTFLG)
C
C   PURPOSE:    WRITE A FLOATING POINT NUMBERS INTO INCORE 'FILE'
C
C   PARAMETERS:
C        LUN      LOGICAL UNIT NUMBER OF FILE BEING WRITTEN
C        BUF      BUFFER WHERE VALUE IS KEPT
C        NB       NUMBER OF VALUES TO BE WRITTEN
C        IX,IY,IZ LOCATION
C 
C        IERR   ERROR CODE 1 IS RETURNED IN CASE OF ERROR
C 
C--*******************************************************************

      SUBROUTINE INLN_WRTVOX(LUN,NROW,BUF,NB,IX,IY,IZ,IRTFLG)

C     USE INLINE BUFFER COMMON AREA
      USE INLN_INFO

      REAL   BUF(NB)

      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

      REAL, POINTER :: IPTNOW(:)
      INTEGER * 8   :: IGOM1

      IPTNOW => LOCLUN(LUN)%IPT

C     GET THE CORRECT OFFSET INTO THE BUFFER.
C     IGOM1 = (LUNARA(LUN) + LUNSTK(LUN) + (IZ - 1) * NROW + (IY-1)) * 
C    &       NSAMLUN(LUN) + IX - 1

      IGOM1 = (LUNARA(LUN) + LUNSTK(LUN) + (IZ - 1) * NROW + (IY-1)) 
      IGOM1 = IGOM1 * NSAMLUN(LUN) + IX - 1

      IF ((IGOM1 + NB) > NWORDLUN(LUN)) THEN
C        GOES OUT OF RESERVED BUFFER!
         WRITE(NOUT,"(A,3I6,A,I12,A,I12,A,I4)") 
     &      '*** INLN_WRTVOX OVERFLOW AT VOXEL: ', IX,IY,IZ,
     &      '   OVERFLOW LOCATION: ',              IGOM1+NB,  
     &      '   AVAILABLE LENGTH: ',               NWORDLUN(LUN)  
         CALL ERRT(102,'OVERFLOW IN INLN_WRTVOX, LUN',LUN)
         IERR = 1
         RETURN

      ELSEIF (IGOM1 < 0) THEN
C        BEFORE RESERVED BUFFER!
         WRITE(NOUT,"(A,3I6,A,I12,A,I12,A,I4)") 
     &      '*** INLN_WRTVOX UNDERFLOW AT VOXEL: ', IX,IY,IZ,
     &      '   OVERFLOW LOCATION: ',               IGOM1+NB,  
     &      '   AVAILABLE LENGTH: ',                NWORDLUN(LUN)  
         CALL ERRT(102,'UNDERFLOW IN INLN_WRTVOX, LUN',LUN)
         IERR = 1
         RETURN
      ENDIF

C     WRITE THE BUFFER (THERE MAY BE A FASTER WAY TO DO THIS!!)
      DO I= 1,NB
         IPTNOW(IGOM1 + I) = BUF(I) 
      ENDDO
      IERR = 0

      RETURN
      END




C++*********************************************************************
C   INLN_REDVOX.F           NEW                    SEPT 03 ARDEAN LEITH                     
C **********************************************************************
C
C     INLN_REDVOX(LUN,NROW,BUF,NB,IX,IY,IZ,IRTFLG)
C
C     PURPOSE:    READ A LINE OF FLOATING POINT NUMBERS FROM BUFFER
C
C     PARAMETERS:
C        LUN      LOGICAL UNIT NUMBER OF FILE BEING WRITTEN
C        BUF      BUFFER WHERE VALUE IS KEPT
C        NB       NUMBER OF VALUES TO BE WRITTEN
C        IX,IY,IZ LOCATION
C
C        IRTFLG   ERROR CODE 1 IS RETURNED IN CASE OF ERROR
C 
C--*******************************************************************

      SUBROUTINE INLN_REDVOX(LUN,NROW,BUF,NB,IX,IY,IZ,IRTFLG)

C     USE INLINE BUFFER COMMON AREA
      USE INLN_INFO

      REAL            BUF(NB)

      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

      REAL, POINTER :: IPTNOW(:)
      INTEGER * 8   :: IGOM1

      IPTNOW  => LOCLUN(LUN)%IPT

C     GET THE CORRECT OFFSET INTO THE BUFFER.
C     IGOM1 = (LUNARA(LUN) + LUNSTK(LUN) + (IZ - 1) * NROW + (IY-1)) * 
C     &       NSAMLUN(LUN) + IX - 1

      IGOM1 = (LUNARA(LUN) + LUNSTK(LUN) + (IZ - 1) * NROW + (IY-1)) 
      IGOM1 = IGOM1 * NSAMLUN(LUN) + IX - 1 

      IF ((IGOM1 + NB) > NWORDLUN(LUN)) THEN
         WRITE(NOUT,"(A,3I6,A,I12,A,I12,A,I4)") 
     &      '*** INLN_REDVOX READS BEYOND BUFFER AT VOXEL:',IX,IY,IZ,
     &      '   LOCATION:',                             IGOM1+NB,  
     &      '   AVAILABLE LENGTH: ',                    NWORDLUN(LUN)  
         IRTFLG = 1
         RETURN
      ENDIF

C     READ THE BUFFER (THERE MAY BE A FASTER WAY TO DO THIS!!)
      DO I= 1,NB
         BUF(I) = IPTNOW(IGOM1 + I)
      ENDDO

C      CALL memcpy_(IPTNOW(IGOM1 + 1),BUF(1),NB*4) DOES NOT WORK!!

      IRTFLG = 0

      RETURN
      END



@


1.47
log
@note added
@
text
@d7 1
d12 1
a12 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d108 1
a108 1
      IF (NEEDNEW .AND. (NSAM .EQ. 0 .OR. NWORDS8 .EQ. 0))THEN
d113 10
d128 5
a132 6
         NWORDBUF(NUMBUF)       = 0
         NSAMBUF(NUMBUF)        = 0
         IRECBUF(NUMBUF)        = 0
         LABRECBUF(NUMBUF)      = 0

         IRTFLG                 = 0
d135 1
a135 1
      ELSEIF (NDEALLOC .GT. 0) THEN
d141 1
a141 1
            IF (I .GT. 1) THEN
d143 1
a143 1
                  IF (TOBEDEALLOC(J) .EQ. NTEMP) DUPED = .TRUE.
@


1.46
log
@WRITE(NOUT,"(
/
@
text
@d42 3
@


1.45
log
@INTEGER * 8 on lengths INTEGER * 8 nwords parameter
@
text
@d299 1
a299 1
         WRITE(NOUT,"A,I3,A,I6,A,I5,A,I4,A,I6,A,I6,A,I12") 
d313 1
a313 1
         WRITE(NOUT,"A,I3,A,I6,A,I5,A,I5,A,I6,A,I6,A,I12") 
d395 1
a395 1
         WRITE(NOUT,"A,I5,A,I12") 
d453 1
a453 1
         WRITE(NOUT,"A,3I6,A,I12,A,I12,A,I4") 
d463 1
a463 1
         WRITE(NOUT,"A,3I6,A,I12,A,I12,A,I4") 
d525 1
a525 1
         WRITE(NOUT,"A,3I6,A,I12,A,I12,A,I4") 
@


1.44
log
@GPL_2010
@
text
@d4 3
a6 3
C OPENINLN.F                                    AUTHOR: A. LEITH
C                  INCREASED NUMINLNT     AUG 02 ARDEAN LEITH
C                                  
d29 1
a29 1
C    OPENINLN(LUN,NUMBUF,NEEDNEW,NSAM,NWORDS,NEEDERRT,IRTFLG))
d38 1
a38 1
C                   NWORDS   SIZE OF BUFFER                    (SENT)
d49 2
a50 2
         INTEGER, PARAMETER :: NUMINLNT = 99
         INTEGER, PARAMETER :: NUMLUNST = 100
d53 1
a53 1
            REAL, DIMENSION(:), POINTER :: IPT 
d56 2
a57 2
         TYPE(REAL_POINTER), DIMENSION(NUMINLNT) :: LOCBUF
         TYPE(REAL_POINTER), DIMENSION(NUMLUNST) :: LOCLUN
d59 4
a62 2
         INTEGER, DIMENSION(NUMLUNST) :: NSAMLUN
         INTEGER, DIMENSION(NUMLUNST) :: NWORDLUN
d68 1
a68 1
      SUBROUTINE OPENINLN(LUN,NUMBUF,NEEDNEW,NSAM,NWORDS,
d76 7
a82 6
      LOGICAL                     :: NEEDNEW,NEEDERRT,DUPED
      INTEGER                     :: LUN,NUMBUF,NSAM,NWORDS,IRTFLG
      INTEGER                     :: NDEALLOC
      REAL, DIMENSION(:), POINTER :: RPOINTER
      INTEGER, DIMENSION(NUMINLN) :: NWORDBUF
      INTEGER, DIMENSION(NUMINLN) :: TOBEDEALLOC
d91 1
a91 3
         WRITE(NOUT,91) LUN
91       FORMAT(' *** PGM ERROR, BAD LUN IN OPENINLN: ',I3)
         CALL ERRT(100,'OPENINLN',NE)
d104 1
a104 1
      IF (NEEDNEW .AND. (NSAM .EQ. 0 .OR. NWORDS .EQ. 0))THEN
d151 3
a153 2
      IF (NEEDNEW .AND. (ASSOCIATED(LOCBUF(NUMBUF)%IPT)) .AND.
     &    (NWORDBUF(NUMBUF) .NE. NWORDS)) THEN
d165 3
a167 1
         ALLOCATE(RPOINTER(NWORDS),STAT=IRTFLGT)
d169 4
a172 3
            WRITE(NOUT,92) NUMBUF  
92          FORMAT(' *** ALLOCATION FOR INLINE FILE: _',I1,'  FAILED')  
            CALL ERRT(102,'OPENINLN CAN NOT ALLOCATE',NWORDS)
d177 1
a177 1
         NWORDBUF(NUMBUF)   = NWORDS
d179 1
d184 1
a184 1
      ISINLINE(LUN) =  .TRUE.
d193 2
a194 1
            IF (NEEDERRT) CALL ERRT(100,'OPENINLN',NE)
d204 1
d206 1
a206 1
      IF (NWORDS .GT. NWORDLUN(LUN)) THEN
d208 1
a208 1
         WRITE(NOUT,94) NUMBUF,NWORDLUN(LUN),NWORDS
d210 3
a212 2
     &          '  LIMITED TO:  ',I8,' WORDS, WANTED: ',I8)
         CALL ERRT(100,'OPENINLN',NE)
a225 1
C **********************************************************************
d227 1
a227 1
C     CLOSEINLN
a248 1
C **********************************************************************
d287 2
a288 1
      REAL, DIMENSION(:), POINTER :: IPTNOW
d293 3
a295 1
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN)  
d297 1
a297 1
      IF ((IGO + NB - 1 ) .GT. NWORDLUN(LUN)) THEN
d299 9
a307 5
         WRITE(NOUT,*) '*** INLN_WRTLIN ARRAY OVERFLOW, LUN: ',LUN,
     &      '   LENGTH:',IGO + NB,'   NREC: ',NREC,
     &      '   LUNARA(LUN) :',LUNARA(LUN),'  LUNSTK(LUN):',LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :',NSAMLUN(LUN)  
         CALL ERRT(100,'WRTLIN',NE)
d311 1
a311 1
      ELSEIF (IGO .LT. 0) THEN
d313 6
a318 3
         WRITE(NOUT,*) '*** INLN_WRTLIN ARRAY UNDERFLOW, LUN: ',LUN,
     &      '   IGO:',IGO,'   NREC: ',NREC,
     &      '   LUNARA(LUN) :',LUNARA(LUN),'  LUNSTK(LUN):',LUNSTK(LUN),  
a339 1
C **********************************************************************
d383 2
a384 1
      REAL, DIMENSION(:), POINTER :: IPTNOW
d389 3
a391 1
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN)
d393 1
a393 1
      IF ((IGO + NB - 1) .GT. NWORDLUN(LUN)) THEN
d395 3
a397 2
         WRITE(NOUT,*) '*** INLN_REDLIN READS BEYOND BUFFER,LUN: ',LUN,
     &       'LENGTH:' ,IGO + NB
a413 1
C **********************************************************************
a426 1
C 
d439 2
a440 1
      REAL, DIMENSION(:), POINTER :: IPTNOW
d445 2
a446 2
      IGOM1 = (LUNARA(LUN) + LUNSTK(LUN) + (IZ - 1) * NROW + (IY-1)) * 
     &       NSAMLUN(LUN) + IX - 1
d448 4
a451 1
      IF ((IGOM1 + NB) .GT. NWORDLUN(LUN)) THEN
d453 5
a457 5
         WRITE(NOUT,*) '*** INLN_WRTVOX OVERFLOW;  ',
     &      '   VOXEL: ',IX,IY,IZ,
     &      '   OVERFLOW LOCATION: ',IGOM1+NB,  
     &      '   AVAILABLE LENGTH: ',NWORDLUN(LUN)  
         CALL ERRT(102,'INLN_WRTVOX, LUN',LUN)
d461 1
a461 1
      ELSEIF (IGOM1 .LT. 0) THEN
d463 5
a467 5
         WRITE(NOUT,*) '*** INLN_WRTVOX UNDERFLOW AT; ', 
     &      '   VOXEL: ',IX,IY,IZ,
     &      '   OVERFLOW LOCATION: ', IGOM1+NB,  
     &      '   AVAILABLE LENGTH: ',NWORDLUN(LUN)  
         CALL ERRT(102,'INLN_WRTVOX, LUN',LUN)
a486 1
C **********************************************************************
d512 2
a513 1
      REAL, DIMENSION(:), POINTER :: IPTNOW
d518 5
a522 2
      IGOM1 = (LUNARA(LUN) + LUNSTK(LUN) + (IZ - 1) * NROW + (IY-1)) * 
     &       NSAMLUN(LUN) + IX - 1
d524 5
a528 5
      IF ((IGOM1 + NB) .GT. NWORDLUN(LUN)) THEN
         WRITE(NOUT,*) '*** INLN_REDVOX READS BEYOND BUFFER;  ',
     &      '   VOXEL: ',IX,IY,IZ,
     &      '   LOCATION: ',IGOM1+NB,  
     &      '   AVAILABLE LENGTH: ',NWORDLUN(LUN)  
@


1.43
log
@added NWORDBUF(NUMBUF)       = 0
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
a216 23
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
a240 23
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
a322 23
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
a393 23
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
a464 23
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
@


1.42
log
@GPL License fixed
@
text
@d115 7
@


1.41
log
@HRI GPL License used
@
text
@a7 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d11 1
a11 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a30 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
a213 2
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      **
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
d217 1
a217 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a236 6

C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
a260 2
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      **
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
d264 1
a264 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a283 6

C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
a365 2
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      **
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
d369 1
a369 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a388 6

C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
a459 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d463 1
a463 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a482 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
a553 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d557 1
a557 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a576 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.40
log
@inln_redvox ...
@
text
@d9 24
d221 1
d223 24
d276 1
d278 24
d389 1
d391 24
d492 24
d593 24
@


1.39
log
@numinlnt
@
text
@a275 3
      ILOC   = 0
C     RUN-TIME ALLOCATION SPECIFIC CODE LINE ENDS

d277 1
a277 1
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN) + ILOC 
d279 1
a279 1
      IF ((IGO + NB - 1 - ILOC) .GT. NWORDLUN(LUN)) THEN
d289 1
a289 1
      ELSEIF (IGO .LT. ILOC) THEN
a354 1

a368 3
      ILOC = 0
C     RUN-TIME ALLOCATION SPECIFIC CODE LINE ENDS

d370 1
a370 1
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN) + ILOC 
d372 1
a372 1
      IF ((IGO + NB - 1 - ILOC) .GT. NWORDLUN(LUN)) THEN
d374 1
a374 1
         WRITE(NOUT,*) '*** INLN_REDLIN ARRAY OVERFLOW, LUN: ',LUN,
d388 142
@


1.38
log
@increased NUMINLNT
@
text
@d5 2
a6 1
C                                           
d8 6
a13 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND      *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.   *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR  *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR*
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 		       *
d16 1
a16 1
C    OPENINLN()
@


1.37
log
@added lunarb to common /lunara/
@
text
@d36 1
a36 1
         INTEGER, PARAMETER :: NUMINLNT = 9
@


1.36
log
@remoed unused F90ALLOC.INC
@
text
@d270 1
a270 1
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
d367 1
a367 1
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
@


1.35
log
@addeed better alloc error msg.
@
text
@a59 1
      INCLUDE 'F90ALLOC.INC'
@


1.34
log
@check on associated before delayed deallocate
@
text
@d146 3
a148 1
            CALL ERRT(45,'OPENINLN',NE)
@


1.33
log
@only deallocates upon next allocation of inline buffer
also removed allocmem call
@
text
@d115 3
a117 2
               DEALLOCATE(RPOINTER,STAT=IRTFLGT)
               IF (IRTFLGT .NE. 0) RETURN
@


1.32
log
@missinG C on comment
@
text
@a31 2
#ifdef SP_F90
C     -------------------- F90 SPECIFIC CODE FOLLOWS -----------
d62 1
a62 1
      LOGICAL                     :: NEEDNEW,NEEDERRT
d64 1
d67 1
d69 1
a69 1
      SAVE NWORDBUF
d71 2
d92 35
a126 13
C        WANT TO DEALLOCATE AND CLOSE AN OPEN INLINE BUFFER
         RPOINTER => LOCBUF(NUMBUF)%IPT
         CALL DEALLOCMEM_R(RPOINTER,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN

C        ZERO BUFFER SIZE, POINTER, NSAM, ETC...
         NULLIFY(LOCBUF(NUMBUF)%IPT)
         NWORDBUF(NUMBUF)  = 0
         NSAMBUF(NUMBUF)   = 0
         IRECBUF(NUMBUF)   = 0
         LABRECBUF(NUMBUF) = 0
         IRTFLG            = 0
         RETURN
d129 1
d134 3
a136 2
         CALL DEALLOCMEM_R(RPOINTER,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
d143 5
a147 3
         MEMWANT = NWORDS 
         CALL ALLOCMEM(MEMWANT,RPOINTER,.TRUE.,'OPENINLN',IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
a189 105
#else
C     ----------------- F77 SPECIFIC CODE FOLLOWS -------------------

      SUBROUTINE OPENINLN(LUN,NUMBUF,NEEDNEW,NSAM,NWORDS,
     &                    NEEDERRT,IRTFLG)

      INCLUDE 'CMBLOCK.INC'

      PARAMETER       (NUMINLN = 9)
#if defined(SP_SUN4) || defined(SP_NT)
        INTEGER * 4     LOCLUN,LOCBUF
#else
        INTEGER * 8     LOCLUN,LOCBUF
#endif

      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)
      COMMON /LUNARC/ LOCBUF(NUMINLN), NWORDBUF(NUMINLN), 
     &                NSAMBUF(NUMINLN),IRECBUF(NUMINLN),
     &                LABRECBUF(NUMINLN)

      LOGICAL         NEEDNEW,NEEDERRT
      POINTER         (RPOINTER,DUMMY)

      IRTFLG = 1
      IF (LUN .LE. 0 .OR. LUN .GT. 100) THEN
C        NO SUCH LUN
         WRITE(NOUT,91) LUN
91       FORMAT(' *** PGM ERROR, BAD LUN IN OPENINLN: ',I3)
         CALL ERRT(100,'OPENINLN',NE)
         RETURN

      ELSEIF (NUMBUF .LE. 0 .OR. NUMBUF .GT. NUMINLN) THEN
C        NO SUCH BUFFER
         ITEMP = NUMINLN
         WRITE(NOUT,90) ITEMP,NUMBUF
90       FORMAT(' *** INLINE BUFFERS AVAILABLE:  1...',I3,
     &          ' BUT YOU WANTED: ',I4)
         CALL ERRT(100,'OPENINLN',NE)
         RETURN
      ENDIF

      IF (NEEDNEW .AND. (NSAM .EQ. 0 .OR. NWORDS .EQ. 0))THEN
C        WANT TO DEALLOCATE AND CLOSE AN OPEN INLINE BUFFER
         RPOINTER = LOCBUF(NUMBUF)

         CALL DEALLOCMEM(RPOINTER,IRTFLG)
         NWORDBUF(NUMBUF)  = 0
         LOCBUF(NUMBUF)    = 0 
         NSAMBUF(NUMBUF)   = 0
         IRECBUF(NUMBUF)   = 0
         LABRECBUF(NUMBUF) = 0
         IRTFLG = 0
         RETURN
      ENDIF

      IF (NEEDNEW .AND. (LOCBUF(NUMBUF) .GT. 0) .AND.
     &   (NWORDBUF(NUMBUF) .NE. NWORDS)) THEN
C        FREE EXISTING SPACE ALLOCATION FOR THIS FILE
         RPOINTER = LOCBUF(NUMBUF)
         CALL DEALLOCMEM(RPOINTER,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
         NWORDBUF(NUMBUF) = 0
         LOCBUF(NUMBUF)   = 0 
      ENDIF

      IF (NEEDNEW .AND. LOCBUF(NUMBUF) .EQ. 0) THEN
C        MUST ALLOCATE SPACE FOR THIS BUFFER
         MEMWANT = NWORDS 
         CALL ALLOCMEM(MEMWANT,RPOINTER,.TRUE.,'OPENINLN',IRTFLG)
         IF (IRTFLG .NE. 0) RETURN
         LOCBUF(NUMBUF)   = RPOINTER
         NWORDBUF(NUMBUF) = NWORDS
         NSAMBUF(NUMBUF)  = NSAM
      ENDIF

      RPOINTER    = LOCBUF(NUMBUF)
      LOCLUN(LUN) = RPOINTER

      IF (.NOT. NEEDNEW) THEN
C        RETRIEVE RECORD LENGTH FROM PREVIOUSLY SET VALUE
         NSAM = NSAMBUF(NUMBUF)
         IF (NSAM .LE. 0) THEN
C           NO PREVIOUS RUN-TIME FILE AVAILABLE
            WRITE(NOUT,93) NUMBUF
93          FORMAT(' *** NO EXISTING INLINE BUFFER: ',I3)
            IF (NEEDERRT) CALL ERRT(100,'OPENINLN',NE)
            RETURN
         ENDIF
      ENDIF

C     SET LENGTH OF RECORD AND BUFFER FOR THIS LUN
      NSAMLUN(LUN)  = NSAM
      NWORDLUN(LUN) = NWORDBUF(NUMBUF)
      LOCLUN(LUN)   = LOCBUF(NUMBUF)

      IF (NWORDS .GT. NWORDLUN(LUN)) THEN
C        NOT ENOUGH SPACE IN BUFFER
         WRITE(NOUT,94) NUMBUF,NWORDLUN(LUN),NWORDS
94       FORMAT(' *** INLINE BUFFER: ',I4,
     &          '  LIMITED TO:  ',I8,' WORDS, WANTED: ',I8)
         CALL ERRT(100,'OPENINLN',NE)
         RETURN
      ENDIF

      IRTFLG = 0
a190 3
      RETURN
      END
#endif
d205 1
a205 1
C     PURPOSE:    READ A LINE OF FLOATING POINT NUMBERS FROM BUFFER
d209 1
a209 2
      SUBROUTINE CLOSEINLN(LUN,IRTFLG)

a210 2
#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------
a216 16
C     ----------- F90 SPECIFIC CODE ENDS ---------------------
#else
C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------

#if defined(SP_SUN4) || defined(SP_NT)
       INTEGER * 4     LOCLUN
#else
       INTEGER * 8     LOCLUN
#endif
       COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)

       LOCLUN(LUN) = 0

C     ----------- F77 SPECIFIC CODE ENDS ---------------------
#endif

d251 2
a252 7
C       DATA KEPT IN INCORE MEMORY UNTIL HE DECIDES THAT HE WANTS IT IN
C       A FILE. FOR THAT, SPIDER OFFERS AN INCORE MEMORY IN A COMMON BLOCK
C       BUFFER:
C
C       ON VAX SYSTEMS, SPIDER OFFERS AN INCORE MEMORY IN A COMMON 
C       BLOCK.  THIS BUFFER CAN BE SUBDIVIDED INTO TWO PARTS TO HOLD 
C       AT MOST TWO FILES, FILES ARE CALLED _1 AND _2. 
a259 3
#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------

a310 59
#else
C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------


      SUBROUTINE INLN_WRTLIN(LUN,BUF,NB,NREC)

      REAL   BUF(NB)

      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)

#if defined(SP_SUN4) || defined(SP_NT)
      INTEGER * 4     LOCLUN
#else
      INTEGER * 8     LOCLUN
#endif

      POINTER (IPT,Q)
      DIMENSION Q(1)

      IPT  = LOCLUN(LUN)
      ILOC = 0
C     RUN-TIME ALLOCATION SPECIFIC CODE LINE ENDS

C     GET THE CORRECT OFFSET INTO THE BUFFER.
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN) + ILOC 

      IF ((IGO + NB - 1 - ILOC) .GT. NWORDLUN(LUN)) THEN
C        GOES OUT OF RESERVED BUFFER!
         WRITE(NOUT,*) '*** INLN_WRTLIN ARRAY OVERFLOW, LUN: ',LUN,
     &      '   LENGTH:',IGO + NB,'   NREC: ',NREC,
     &      '   LUNARA(LUN) :',LUNARA(LUN),'  LUNSTK(LUN):',LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :',NSAMLUN(LUN)  
         CALL ERRT(100,'WRTLIN',NE)
         IERR = 1
         RETURN

      ELSEIF (IGO .LT. ILOC) THEN
C        BEFORE RESERVED BUFFER!
         WRITE(NOUT,*) '*** INLN_WRTLIN ARRAY UNDERFLOW, LUN: ',LUN,
     &      '   IGO:',IGO,'   NREC: ',NREC,
     &      '   LUNARA(LUN) :',LUNARA(LUN),'  LUNSTK(LUN):',LUNSTK(LUN),  
     &      '   NSAMLUN(LUN) :',NSAMLUN(LUN)  
         CALL ERRT(100,'WRTLIN',NE)
         IERR = 1
         RETURN
      ENDIF

C     WRITE THE BUFFER (THERE MAY BE A FASTER WAY TO DO THIS!!)
      DO I= 1,NB
         Q(IGO + I) = BUF(I) 
      ENDDO
      IERR = 0

      RETURN
      END

#endif
a356 3
#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------

a394 46
#else
C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------



      SUBROUTINE INLN_REDLIN(LUN,BUF,NB,NREC)

      REAL            BUF(NB)
      COMMON /IOERR/  IERR
      COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT
      COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)

#if defined(SP_SUN4) || defined(SP_NT)
        INTEGER * 4     LOCLUN
#else
        INTEGER * 8     LOCLUN
#endif

      POINTER      (IPT,Q)
      DIMENSION    Q(1)

      IPT  = LOCLUN(LUN)
      ILOC = 0

C     GET THE CORRECT OFFSET INTO THE BUFFER.
      IGO = (LUNARA(LUN) + LUNSTK(LUN) + NREC - 1) * NSAMLUN(LUN) + ILOC 

      IF ((IGO + NB - 1 - ILOC) .GT. NWORDLUN(LUN)) THEN
C        GOES OUT OF RESERVED BUFFER!
         WRITE(NOUT,*) '*** INLN_REDLIN ARRAY OVERFLOW, LUN: ',LUN,
     &       'LENGTH:' ,IGO + NB
         IERR = 1
         RETURN
      ENDIF

C     READ THE BUFFER (THERE MAY BE A FASTER WAY TO DO THIS!!)
      DO I= 1,NB
         BUF(I) = Q(IGO + I)
      ENDDO
      IERR = 0

      RETURN
      END

#endif
@


1.31
log
@USE INLN_INFO ALTERED
@
text
@d302 1
a302 1
     ----------- F77 SPECIFIC CODE FOLLOWS ------------------
@


1.30
log
@used allocmem for better error trapping
@
text
@a33 1

d38 3
a40 2
         INTEGER, PARAMETER :: NUMINLN = 9
         INTEGER, PARAMETER :: NUMLUNS = 100
d45 2
a46 7
         TYPE(REAL_POINTER), DIMENSION(NUMINLN) :: LOCBUF
         TYPE(REAL_POINTER), DIMENSION(NUMLUNS) :: LOCLUN

         REAL, DIMENSION(:), POINTER :: RPOINTER

         INTEGER, DIMENSION(NUMLUNS) :: NSAMLUN
         INTEGER, DIMENSION(NUMLUNS) :: NWORDLUN
d48 2
a49 4
         INTEGER, DIMENSION(NUMINLN) :: NSAMBUF
         INTEGER, DIMENSION(NUMINLN) :: NWORDBUF
         INTEGER, DIMENSION(NUMINLN) :: IRECBUF
         INTEGER, DIMENSION(NUMINLN) :: LABRECBUF
d59 1
d64 4
a67 2
      LOGICAL :: NEEDNEW,NEEDERRT
      INTEGER :: LUN,NUMBUF,NSAM,NWORDS,IRTFLG
d69 2
d128 1
d146 1
d270 339
@


1.29
log
@removed SP_ALLOC
@
text
@d48 1
a48 1
         REAL, DIMENSION(:), POINTER :: IPOINTER
d70 1
a70 1
      LOGICAL :: NEEDNEW,RUNTIME,NEEDERRT
d93 3
a95 4
         IPOINTER => LOCBUF(NUMBUF)%IPT

         RUNTIME = .TRUE.
         CALL ALLOCIT(0,RUNTIME,IPOINTER,'OPENINLN',IRTFLG)
d110 2
a111 3
         IPOINTER => LOCBUF(NUMBUF)%IPT
         RUNTIME  = .TRUE.
         CALL ALLOCIT(0,RUNTIME,IPOINTER,'OPENINLN',IRTFLG)
d120 4
a123 3
         CALL ALLOCIT(MEMWANT,RUNTIME,IPOINTER,'OPENINLN',IRTFLG)
         IF (.NOT. RUNTIME .OR. (IRTFLG .NE. 0)) RETURN
         LOCBUF(NUMBUF)%IPT => IPOINTER
d128 2
a129 2
      IPOINTER        => LOCBUF(NUMBUF)%IPT
      LOCLUN(LUN)%IPT => IPOINTER
d182 2
a183 2
      LOGICAL         NEEDNEW,RUNTIME,NEEDERRT
      POINTER         (IPOINTER,DUMMY)
d205 1
a205 1
         IPOINTER = LOCBUF(NUMBUF)
d207 1
a207 2
         RUNTIME = .TRUE.
         CALL ALLOCIT(0,RUNTIME,IPOINTER,'OPENINLN',IRTFLG)
d218 1
a218 1
     &    (NWORDBUF(NUMBUF) .NE. NWORDS)) THEN
d220 2
a221 3
         IPOINTER = LOCBUF(NUMBUF)
         RUNTIME  = .TRUE.
         CALL ALLOCIT(0,RUNTIME,IPOINTER,'OPENINLN',IRTFLG)
d230 3
a232 3
         CALL ALLOCIT(MEMWANT,RUNTIME,IPOINTER,'OPENINLN',IRTFLG)
         IF (.NOT. RUNTIME .OR. (IRTFLG .NE. 0)) RETURN
         LOCBUF(NUMBUF)   = IPOINTER
d237 2
a238 2
      IPOINTER    = LOCBUF(NUMBUF)
      LOCLUN(LUN) = IPOINTER
@


1.28
log
@removed USEINLN
@
text
@a107 1
C     RUN-TIME ALLOCATION SPECIFIC CODE FOLLOWS
a170 2
#ifdef SP_ALLOC
C     RUN-TIME ALLOCATION SPECIFIC CODE  FOLLOWS -------
a176 7
C     RUN-TIME ALLOCATION SPECIFIC CODE  ENDS------------
#else
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE  FOLLOWS-----
      PARAMETER       (NUMINLN = 2)
      INTEGER * 4     LOCLUN,LOCBUF
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE  ENDS--------
#endif
d207 1
a207 2
#ifdef SP_ALLOC
C        RUN-TIME ALLOCATION SPECIFIC CODE FOLLOWS
a214 8
C        RUN-TIME ALLOCATION SPECIFIC CODE ENDS
#else
C        NON RUN-TIME ALLOCATION SPECIFIC CODE FOLLOWS
         NSAMBUF(NUMBUF)   = 0
         IRECBUF(NUMBUF)   = 0
         LABRECBUF(NUMBUF) = 0
C        NON RUN-TIME ALLOCATION SPECIFIC CODE ENDS
#endif
a218 2
#ifdef SP_ALLOC
C     RUN-TIME ALLOCATION SPECIFIC CODE FOLLOWS
a241 9
C     RUN-TIME ALLOCATION SPECIFIC CODE ENDS

#else
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE FOLLOWS
      IF (NEEDNEW ) THEN
         NSAMBUF(NUMBUF) = NSAM
      ENDIF
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE ENDS
#endif
@


1.27
log
@duplicate line in module removed
@
text
@a47 1
         LOGICAL                     :: USEINLN
a65 1
CNO_SAVE
d188 1
a188 2
      LOGICAL USEINLN
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
@


1.26
log
@added SAVE to inln_info module
@
text
@d46 1
a46 1
         TYPE(REAL_POINTER), DIMENSION(100)     :: LOCLUN
d48 1
a48 1
         LOGICAL :: USEINLN
d53 2
a55 2
         INTEGER, DIMENSION(NUMINLN) :: NWORDBUF
         INTEGER, DIMENSION(NUMINLN) :: NSAMBUF
@


1.25
log
@bug in INTEGER*8 for locbuf fixed
@
text
@d37 2
@


1.24
log
@cosmetic
@
text
@d165 1
a165 1
C     ----------------- F77 SPECIFIC CODE FOLLOWS --------------
d173 1
a173 1
C     RUN-TIME ALLOCATION SPECIFIC CODE  FOLLOWS
d176 1
a176 1
        INTEGER * 4     LOCLUN
d178 1
a178 1
        INTEGER * 8     LOCLUN
d180 1
a180 2

C     RUN-TIME ALLOCATION SPECIFIC CODE  ENDS
d182 1
a182 1
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE  FOLLOWS
a183 1

d185 1
a185 1
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE  ENDS
@


1.23
log
@bad pointer asignment in f90
@
text
@d70 2
a71 2
      LOGICAL ::      NEEDNEW,RUNTIME,NEEDERRT
      INTEGER ::      LUN,NUMBUF,NSAM,NWORDS,IRTFLG
@


1.22
log
@ifdef SP_SUN4 added
@
text
@d130 2
a131 2
      IPOINTER        = LOCBUF(NUMBUF)%IPT
      LOCLUN(LUN)%IPT = IPOINTER
d148 1
a148 1
      LOCLUN(LUN)%IPT = LOCBUF(NUMBUF)%IPT
@


1.21
log
@f90 changes
@
text
@d175 2
a176 2
#ifdef SP_NT
      INTEGER LOCLUN,LOCBUF
d178 1
a178 1
      INTEGER * 8     LOCLUN,LOCBUF
@


1.20
log
@restored version 1.16
@
text
@d32 135
d306 1
@


1.19
log
@restoreed version 1.17
@
text
@a34 5
#ifdef SP_F90
      INCLUDE 'F90ALLOC.INC' 
#endif


@


1.18
log
@*** empty log message ***
@
text
@a34 2
CNO_SAVE

d36 1
a36 3
      INCLUDE 'F90ALLOC.INC'
#else
      POINTER         (IPOINTER,DUMMY)
d67 1
@


1.17
log
@added include F90ALLOC.INC
@
text
@d35 2
d38 3
a40 1
      INCLUDE 'F90ALLOC.INC' 
a70 1
      POINTER         (IPOINTER,DUMMY)
@


1.16
log
@ used 4 byte pointers on nt
@
text
@d35 5
@


1.15
log
@neederrt mispelled
@
text
@d40 5
a45 1
      INTEGER * 8     LOCLUN,LOCBUF
@


1.14
log
@added neederrt parameter to openinln call
@
text
@d57 1
a57 1
      LOGICAL         NEEDNEW,RUNTIME,NEEDERT
@


1.13
log
@changed I6 print format to i8
@
text
@d21 7
a27 6
C    PARAMETERS:    LUN      EQUIVALENT LUN
C                   NUMBUF   BUFFER NUMBER
C                   NEEDNEW  LOGICAL FLAG THAT WANT NEW BUFFER
C                   NSAM     LENGTH OF ROW USED IN BUFFER
C                   NWORDS   SIZE OF BUFFER
C                   IRTFLG   ERROR FLAG
d32 2
a33 1
      SUBROUTINE OPENINLN(LUN,NUMBUF,NEEDNEW,NSAM,NWORDS,IRTFLG)
d57 1
a57 1
      LOGICAL         NEEDNEW,RUNTIME
d64 1
a64 1
91       FORMAT(' *** PGM ERROR, BAD LUN IN OPENINLN',I3)
d143 2
a144 2
93          FORMAT(' *** NO EXISTING INLINE BUFFER:',I3)
            CALL ERRT(100,'OPENINLN',NE)
@


1.12
log
@runtime must be variable in allocit call
@
text
@d155 2
a156 2
94       FORMAT(' *** INLINE BUFFER: ',I3,
     &          '  LIMITED TO:  ',I6,' WORDS, WANTED: ',I6)
@


1.11
log
@added labrecbuf
@
text
@d79 3
d83 2
a87 4
#ifdef SP_ALLOC
C        RUN-TIME ALLOCATION SPECIFIC CODE FOLLOWS
         NWORDBUF(NUMBUF) = 0
         LOCBUF(NUMBUF)   = 0 
d89 6
d106 1
@


1.10
log
@set irecbuf
@
text
@d52 2
a53 1
     &                NSAMBUF(NUMINLN),IRECBUF(NUMINLN)
d80 3
a82 2
         NSAMBUF(NUMBUF) = 0
         IRECBUF(NUMBUF) = 0
@


1.9
log
@added useinln to lunarb
@
text
@d52 1
a52 1
     &                NSAMBUF(NUMINLN)
d80 1
@


1.8
log
@bug in neednew returning not runtime if deallocacte existing buffer
@
text
@d49 2
a50 1
      COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)
@


1.7
log
@added error info
@
text
@d4 1
a4 1
C OPENINLN.F
d18 2
a19 2
C    PURPOSE:       TO OPEN A INLINE BUFFER FOR RANDOM 
C                   ACCESS READING/WRITING VIA REDLIN AND WRTLIN.
d21 6
a26 1
C    PARAMETERS:
a27 2
C    VARIABLES:  
C
d74 1
a74 1
      IF (NEEDNEW .AND. ( NSAM .EQ. 0 .OR. NWORDS .EQ. 0))THEN
d96 1
a96 1
         IF (.NOT. RUNTIME .OR. (IRTFLG .NE. 0)) RETURN
@


1.6
log
@ipointer not defined before free!
@
text
@d139 1
a139 1
         WRITE(NOUT,94) NUMBUF,NWORDLUN(LUN)
d141 1
a141 1
     &          '  LIMITED TO:  ',I6,' WORDS')
@


1.5
log
@itemp wrong
@
text
@d73 1
d91 1
@


1.4
log
@itemp not defined at end
@
text
@d137 1
a137 2
         ITEMP = NUMINLN
         WRITE(NOUT,94) NUMBUF,ITEMP
@


1.3
log
@fixed integer 8 in inline buffer (not available on non-alpha)
@
text
@d137 1
@


1.2
log
@added better error traps
@
text
@d33 1
a33 1
C     RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
d35 3
d39 1
a39 1
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE LINE FOLLOWS
d41 3
a45 1
      INTEGER * 8     LOCLUN,LOCBUF
@


1.1
log
@Initial revision
@
text
@d49 1
a49 1
      IF (LUN .GT. 100) THEN
d52 1
a52 1
91       FORMAT(' *** PGM ERROR BAD LUN IN OPENINLN',I3)
d56 1
a56 1
      ELSEIF (NUMBUF .GT. NUMINLN) THEN
d60 2
a61 2
90       FORMAT(' *** INLINED BUFFERS LIMITED TO:  1...',I3,
     &          ' BUT WANTED: ',I4)
d66 14
d110 1
a110 1
C     NON-RUN-TIME ALLOCATION SPECIFIC CODE FOLLOWS
d116 7
a128 1

@
