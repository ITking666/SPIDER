head	1.39;
access;
symbols;
locks; strict;
comment	@c @;


1.39
date	2014.08.08.16.11.33;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2012.10.26.15.02.05;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2012.05.14.16.44.42;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.12.19.28.45;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.30.14.53.17;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.13.17.14.56;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2012.01.11.14.37.08;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.03.17.26.18;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2011.12.30.19.14.09;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.30.18.19.42;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.30.14.32.37;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.30.14.28.13;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2011.12.29.19.57.32;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2011.12.29.19.55.36;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.28.20.13.53;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.23.17.49.07;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.23.14.03.37;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.19.15.04.20;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2011.12.19.13.50.03;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2011.12.09.13.27.09;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2011.10.31.19.45.44;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2011.10.31.19.43.25;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2011.10.05.16.24.21;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2011.10.05.15.49.45;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.21.18.54.58;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.01.13.21.30;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2011.08.02.13.59.00;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.29.15.28.30;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.25.16.00.11;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.25.14.19.37;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2011.06.10.16.34.43;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2011.06.02.15.50.23;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2011.06.02.15.31.00;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.02.15.29.41;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2011.05.24.17.49.36;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2011.05.24.17.30.31;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2011.05.24.15.12.31;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2011.05.24.12.52.45;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2011.05.23.19.49.05;	author leith;	state Exp;
branches;
next	;


desc
@@


1.39
log
@cosmetic
@
text
@C **********************************************************************
C                                                                      *
C RTSF       NEW                         MAY 2011  Gregory Kishchenko  * 
C            SPLINE                      JUL 2011  ArDean Leith        *
C            OMP                         OCT 2011  ArDean Leith        * 
C            USED FBS2                   MAY 2011  Gregory Kishchenko  *
C            SCALE BUG                   DEC 2011  Gregory Kishchenko  *
C            SPEEDUP                     JAN 2012  ArDean Leith        *
C            RTSF_PAD                    JAN 2012  ArDean Leith        *
C            RYE1 BUG                    MAY 2012  ArDean Leith        *
C                                                                      *
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2014  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C                                                                      * 
C   RTSF(BUF1,BUF2, NXLD,NX,NY,                                        *
C        THETAT,SCLI,SHX,SHY, IRTFLG)                                  *
C                                                                      *  
C   RTSF_PAD(XIMG,BUFOUT, NX,NY, NXP,NYP,                              *
C            THETA,SCLI,SHXI,SHYI, IRTFLG)                             *
C                                                                      *
C   PARAMETERS: BUF1         INPUT ARRAY                         INPUT *
C               BUF2         OUTPUT ARRAY                        OUTPUT*
C               THETAT       ANGLE                               INPUT *
C               SCLI         SCALE FACTOR                        INPUT *
C               SHXI,SHYI    SHIFTS                              INPUT *
C               IRTFLG       ERROR FLAG                          INPUT *
C                                                                      *
C   VARIABLES:  X1   - D/DX DERIVATIVE                                 *
C               Y1   - D/DY DERIVATIVE                                 *
C               XY2  - D2/DXDY DERIVATIVE                              *
C                                                                      *
C   PURPOSE:    Image rotation, shift, & scale                         *
C               Using 2D Fourier-based bicubic spline interpolation    *
c               between pixels.                                        *
C               Algorithm is fairly fast and preserves fine details    *
c               of  images                                             *
C                                                                      *
C   If the values of a function F(X) and its first derivatives F'(X)   *
C   are known at X=0 and X=1, the function can be interpolated on the  *
C   interval [0,1] as a third degree polynomial (cubic                 *
C   interpolation formula):                                            *
C                                                                      *
C      F(X)=A0 + A1*X + A2*X**2 + A3*X**3                              *
C                                                                      *
C       where A0, A1, A2, and A3 are given by                          *
C       A0 = F(0)                                                      *
C       A1 = F'(0)                                                     *
C       A2 = 3*(F(1)-F(0) - 2*F'(0) - F'(1)                            *
C       A3 = 2*(F(0)-F(1)) + F'(0) + F'(1)                             *
C                                                                      *
C     In order to interpolate a two dimensional grid [0,1] × [0,1], we *
C   sequentially used 1D cubic interpolation formula. First,  we       *
C   interpolated the intensities and normal to boundaries first        *
C   derivatives at two horizontal boundary lines [0,0]-[1,0] and       *
C   [0,1]-[1,1].                                                       *
C     For intensities' interpolation the intensities and tangential    *
C   first derivatives in grid nodes were used.                         *
C     For normal derivatives' interpolation the normal derivatives and *
C   cross-derivatives in grid nodes were used.                         *
C     Thereafter we carried out the vertical cubic interpolation on    *
C   line between 2 horizontal line with a given value of X to obtain   *
C   the intensity on vertical coordinate Y inside the square cell.     *
C   This last procedure was done using previously interpolated values  *
C   of intensities and their first normal derivatives across cell      *
C   boundaries.                                                        *
C       The first derivatives dF/dX, dF/dY and a cross-derivative      *
C   d2F/dXdY  in grid nodes were obtained by calculating 2D            *
C   Fourier transform of image, and then calculating the inverse       *
C   Fourier transform of {ik*F(k,l)}, il*F(k,l)}, and {ikl*F(k,l)}.    *
C      This well-known formula is computationally efficient and very   *
C   convenient for calculating the derivatives of a  function defined  *
C   as a discrete data set, and allows to calculate the derivative in  *
C   any local point without the finite difference approximation        *
C   involving the data from neighboring points.                        * 
C                                                                      *
C      The result of this interpolation is similar to those of         *
C   standard bicubic spline interpolation (the densities and their     *
C   both derivatives are continuous at boundaries), but has fewer      *
C   interpolation artifacts, preserving the fine details and sharp     *
C   boundaries from blurring, because our algorithm involves the       *
C   densities and three partial derivatives just from 4 pixels         *
C   surrounding the area for interpolation instead 16 pixels as in     *
C   standard algorithm with the finite difference approximation.       *
C                                                                      *
C23456789012345678901234567890123456789012345678901234567890123456789012
C***********************************************************************

C      INPUT: FFT PADDED  OUTPUT: UNPADDED

       SUBROUTINE RTSF(BUF1, BUF2,
     &                 NXLD, NX,  NY,
     &                 THETAT,SCLI, SHXI,SHYI, IRTFLG)

       IMPLICIT NONE

       REAL              :: BUF1(NXLD,NY)
       REAL              :: BUF2(NX,  NY)
       INTEGER           :: NXLD, NX, NY
       REAL              :: THETAT,SCLI,SCL
       REAL              :: THETA, COSTH, SINTH
       REAL              :: SHXI,SHYI
       INTEGER           :: IRTFLG

       INTEGER           :: CX, CY, BNDI, BNDJ
       INTEGER           :: I,J,K,IX,IY
       INTEGER           :: I4,J4
       INTEGER           :: INV,MWANT
       REAL              :: FI,FJ
       REAL              :: XOLD,YOLD, FICX,FJCY
       REAL              :: SHX,SHY,YCOD,YSID
       REAL              :: FY,FX,FX0,FY0,FY1,FY2,FX1,FX2,SHYPNY,SHXPNX

       REAL              :: fbs2

       REAL, ALLOCATABLE :: F0(:,:)
       REAL, ALLOCATABLE :: X1(:,:)
       REAL, ALLOCATABLE :: Y1(:,:)
       REAL, ALLOCATABLE :: XY2(:,:)

       REAL, PARAMETER   :: PI = 3.14159265358979323846

       ALLOCATE (F0 (NXLD, NY),
     &           X1 (NXLD, NY),
     &           Y1 (NXLD, NY),
     &           XY2(NXLD, NY),
     &           STAT=IRTFLG)
       IF (IRTFLG .NE. 0) THEN 
          MWANT = 4* NXLD*NY 
          CALL ERRT(46,'RTSF, F0...',MWANT)
          RETURN
       ENDIF 

       ! ARRAY ASSIGNMENT FOR PADDED ARRAY
       F0 = BUF1

       CALL FBS2_PREP(F0, X1,Y1,XY2, NXLD, NX,NY, IRTFLG)

C      CREATE TRANSFORMATION MATRIX
       THETA = THETAT * PI / 180
       COSTH = COS(THETA)
       SINTH = SIN(THETA)

C      SPIDER IMAGE CENTER
       CX    = NX / 2 + 1
       CY    = NY / 2 + 1

C      CONSTRAIN SHIFT TO CIRCULAR BOUNDARY
       SHX = MODULO(SHXI, FLOAT(NX))
       SHY = MODULO(SHYI, FLOAT(NY))

       IF (SCLI == 1.0) THEN !-----------------------------------------

         FY0    = - SHY - CY
         FY1    = - SHY + NY - CY
         FY2    = - SHY - NY - CY

         FX0    = - SHX - CX
         FX1    = - SHX + NX - CX
         FX2    = - SHX - NX - CX

         SHYPNY = SHY + NY
         SHXPNX = SHX + NX

c$omp    parallel do private(iy,fy,ycod,ysid, ix,fx, xold,yold)
         DO IY=1, NY
            FY = IY + FY0 
            IF ((IY-1) <  SHY)    FY = IY + FY1 
            IF ((IY-1) >= SHYPNY) FY = IY + FY2 

            YCOD =  COSTH * FY + CY
            YSID = -SINTH * FY + CX

            DO IX=1, NX
              FX = IX + FX0 
              IF ((IX-1) <  SHX)    FX = IX + FX1
              IF ((IX-1) >= SHXPNX) FX = IX + FX2

              XOLD    = COSTH * FX + YSID
              YOLD    = SINTH * FX + YCOD

              BUF2(IX,IY) = FBS2(XOLD,YOLD, NXLD,NX,NY, BUF1,NXLD,
     &                           X1,Y1,XY2, .TRUE.)
            ENDDO
          ENDDO

       ELSE !------------------------------------------- Needs speedup

         SCL   = 1 / SCLI

         IF (SCLI >= 1) THEN
            BNDI = INT(NX*(SCLI-1)/2)
            BNDJ = INT(NY*(SCLI-1)/2)
         ELSE
            BNDI = INT(NX*(SCLI-1)/2) - 1
            BNDJ = INT(NY*(SCLI-1)/2) - 1
         ENDIF

C        'RT SQ' OMP GAVE TIME: 3 ON 8 PROCS VS  6 ON 1
C        'RT SF' OMP GAVE TIME: 7 ON 8 PROCS VS 21 ON 1

c$omp    parallel do private(j,fj,fjcy,j4,i,fi,ficx,i4,xold,yold)
         DO J=BNDJ, NY*SCLI-BNDJ-1
            FJ   = MODULO(INT(J - BNDJ - SHY), NY) + BNDJ
            FJCY = FJ * SCL - CY + 1
            J4   = MODULO(J - BNDJ, NY) + 1

               DO I=BNDI, NX*SCLI-BNDI-1
                 FI   = MODULO(INT(I - BNDI- SHX), NX) + BNDI
                 FICX = FI * SCL - CX + 1
                 I4   = MODULO(I - BNDI, NX)+1

                 XOLD = COSTH*FICX - SINTH*FJCY + CX
                 YOLD = SINTH*FICX + COSTH*FJCY + CY

                 !if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                 !   write(6,*) ' bad index:',i,j,i4,j4,x,y
                 !   stop
                 !endif

                 BUF2(I4,J4) = FBS2(XOLD,YOLD, NXLD,NX,NY, BUF1,NXLD,
     &                        X1,Y1,XY2, .TRUE.)
              ENDDO
          ENDDO
       ENDIF

       IF (ALLOCATED(F0))  DEALLOCATE(F0)
       IF (ALLOCATED(X1))  DEALLOCATE(X1)
       IF (ALLOCATED(Y1))  DEALLOCATE(Y1)
       IF (ALLOCATED(XY2)) DEALLOCATE(XY2)

       END

C      -------------------- RTSF_BACK ---------------------------------

C      INPUT: FFT PADDED  OUTPUT: UNPADDED

       SUBROUTINE RTSF_BACK(BUF1, BUF2,
     &                      NXLD, NX,  NY,
     &                      THETAT,SCLI,SHXI,SHYI, 
     &                      USEBACK,BACK,  IRTFLG)

       IMPLICIT NONE

       REAL              :: BUF1(NXLD,NY)
       REAL              :: BUF2(NX,  NY)
       INTEGER           :: NXLD, NX, NY
       REAL              :: THETAT,SCLI,SCL
       REAL              :: THETA,COSTH, SINTH
       REAL              :: SHXI,SHYI
       LOGICAL           :: USEBACK
       REAL              :: BACK
       INTEGER           :: IRTFLG

       INTEGER           :: CX, CY, BNDI, BNDJ
       INTEGER           :: I,J,K,IX,IY
       INTEGER           :: I4,J4
       INTEGER           :: INV,MWANT
       REAL              :: FI,FJ
       REAL              :: XOLD,YOLD
       REAL              :: FICX,FJCY
       REAL              :: SHX,SHY,YCOD,YSID
       REAL              :: FY,FX,FX0,FY0,FY1,FY2,FX1,FX2,SHYPNY,SHXPNX

       REAL              :: fbs2

       REAL, ALLOCATABLE :: F0 (:,:)
       REAL, ALLOCATABLE :: X1 (:,:)
       REAL, ALLOCATABLE :: Y1 (:,:)
       REAL, ALLOCATABLE :: XY2(:,:)

       REAL, PARAMETER   :: PI = 3.14159265358979323846

       ALLOCATE (F0 (NXLD, NY),
     &           X1 (NXLD, NY),
     &           Y1 (NXLD, NY),
     &           XY2(NXLD, NY),
     &           STAT=IRTFLG)
       IF (IRTFLG .NE. 0) THEN 
          MWANT = 4* NXLD*NY 
          CALL ERRT(46,'RTSF_BACK, F0...',MWANT)
          RETURN
       ENDIF 

       ! ARRAY ASSIGNMENT
       F0  = BUF1

       CALL FBS2_PREP(F0, X1,Y1,XY2, NXLD, NX,NY, IRTFLG)

C      CREATE TRANSFORMATION MATRIX
       THETA = THETAT * PI / 180
       COSTH = COS(THETA)
       SINTH = SIN(THETA)

C      SPIDER IMAGE CENTER
       CX    = NX / 2 +1
       CY    = NY / 2 +1

C      CONSTRAIN SHIFT TO CIRCULAR BOUNDARY
       SHX = MODULO(SHXI, FLOAT(NX))
       SHY = MODULO(SHYI, FLOAT(NY))

       IF (SCLI == 1.0) THEN !-----------------------------------------

         FY0    = - SHY - CY
         FY1    = - SHY + NY - CY
         FY2    = - SHY - NY - CY

         FX0    = - SHX - CX
         FX1    = - SHX + NX - CX
         FX2    = - SHX - NX - CX

         SHYPNY = SHY + NY
         SHXPNX = SHX + NX

c$omp    parallel do private(iy,fy,ycod,ysid, ix,fx, xold,yold)
         DO IY=1, NY
            FY = IY + FY0 
            IF ((IY-1) <  SHY)    FY = IY + FY1 
            IF ((IY-1) >= SHYPNY) FY = IY + FY2 

            YCOD =  COSTH * FY + CY
            YSID = -SINTH * FY + CX

            DO IX=1, NX
              FX = IX + FX0 
              IF ((IX-1) <  SHX)    FX = IX + FX1
              IF ((IX-1) >= SHXPNX) FX = IX + FX2

              XOLD    = COSTH * FX + YSID
              YOLD    = SINTH * FX + YCOD

              IF  (USEBACK .AND. 
     &            (XOLD < 1 .OR. XOLD > NX .OR. 
     &             YOLD < 1 .OR. YOLD > NY)) THEN
C                CORNER LOCATION IN NEW IMAGE
                 BUF2(IX,IY) = BACK     
                 CYCLE
              ENDIF

              BUF2(IX,IY) = FBS2(XOLD,YOLD, NXLD,NX,NY, BUF1,NXLD,
     &                             X1,Y1,XY2, .TRUE.)
            ENDDO
          ENDDO
      
       ELSE !------------------------------------------ Needs speedup

          SCL   = 1 / SCLI

          IF (SCLI >= 1) THEN
             BNDI = INT(NX*(SCLI-1)/2)
             BNDJ = INT(NY*(SCLI-1)/2)
          ELSE
             BNDI = INT(NX*(SCLI-1)/2) -1
             BNDJ = INT(NY*(SCLI-1)/2) -1
          ENDIF

C         'RT SQ' OMP GAVE TIME:   ON 8 PROCS VS    ON 1
C         'RT SF' OMP GAVE TIME:   ON 8 PROCS VS    ON 1

c$omp     parallel do private(j,fj,fjcy,j4, i,fi,ficx,i4, xold,yold)
          DO J=BNDJ, NY*SCLI-BNDJ-1

             FJ   = MODULO(INT(J - BNDJ- SHY), NY) + BNDJ
             FJCY = FJ*SCL - CY + 1
             J4   = MODULO(J - BNDJ, NY)+1

              DO I=BNDI, NX*SCLI-BNDI-1
                 FI   = MODULO(INT(I - BNDI- SHX), NX) + BNDI
                 FICX = FI * SCL - CX + 1
                 I4   = MODULO(I - BNDI, NX) + 1

                 XOLD = COSTH*FICX - SINTH*FJCY + CX
                 YOLD = SINTH*FICX + COSTH*FJCY + CY

                 IF  (USEBACK .AND. 
     &               (XOLD < 1 .OR. XOLD > NX .OR. 
     &                YOLD < 1 .OR. YOLD > NY)) THEN
C                   CORNER LOCATION IN NEW IMAGE
                    BUF2(I4,J4) = BACK     
                    CYCLE
                 ENDIF

                 BUF2(I4,J4) = FBS2(XOLD,YOLD, NXLD,NX,NY, BUF1,NXLD,
     &                           X1,Y1,XY2, .TRUE.)
             ENDDO
          ENDDO
       ENDIF

       IF (ALLOCATED(F0))  DEALLOCATE(F0)
       IF (ALLOCATED(X1))  DEALLOCATE(X1)
       IF (ALLOCATED(Y1))  DEALLOCATE(Y1)
       IF (ALLOCATED(XY2)) DEALLOCATE(XY2)

       END


C      -------------------- RTSF_PADIN ---------------------------------

C      INPUT: FFT or 2xFFT PADDED,   OUTPUT: UNPADDED

       SUBROUTINE RTSF_PADIN(BUF1, BUF2,
     &                 NXLD, NX,  NY, NXP,
     &                 THETAT,SCLI, SHXI,SHYI, IRTFLG)

       IMPLICIT NONE

       REAL              :: BUF1(NXP,NY)
       REAL              :: BUF2(NX, NY)
       INTEGER           :: NXLD, NX, NY, NXP
       REAL              :: THETAT,SCLI,SCL
       REAL              :: THETA, COSTH, SINTH
       REAL              :: SHXI,SHYI
       INTEGER           :: IRTFLG

       INTEGER           :: CX, CY, BNDI, BNDJ
       INTEGER           :: I,J,K,IX,IY
       INTEGER           :: I4,J4
       INTEGER           :: INV,MWANT
       REAL              :: FI,FJ
       REAL              :: XOLD,YOLD, FICX,FJCY
       REAL              :: SHX,SHY,YCOD,YSID
       REAL              :: FY,FX,FX0,FY0,FY1,FY2,FX1,FX2,SHYPNY,SHXPNX

       REAL              :: fbs2

       REAL, ALLOCATABLE :: F0(:,:)
       REAL, ALLOCATABLE :: X1(:,:)
       REAL, ALLOCATABLE :: Y1(:,:)
       REAL, ALLOCATABLE :: XY2(:,:)

       REAL, PARAMETER   :: PI = 3.14159265358979323846

       ALLOCATE (F0 (NXLD, NY),
     &           X1 (NXLD, NY),
     &           Y1 (NXLD, NY),
     &           XY2(NXLD, NY),
     &           STAT=IRTFLG)
       IF (IRTFLG .NE. 0) THEN 
          MWANT = 4* NXLD*NY 
          CALL ERRT(46,'RTSF, F0...',MWANT)
          RETURN
       ENDIF 

       ! ARRAY ASSIGNMENT FOR PADDED ARRAY
       F0 = BUF1(1:NXLD,1:NY)

       CALL FBS2_PREP(F0, X1,Y1,XY2, NXLD, NX,NY, IRTFLG)

C      CREATE TRANSFORMATION MATRIX
       THETA = THETAT * PI / 180
       COSTH = COS(THETA)
       SINTH = SIN(THETA)

C      SPIDER IMAGE CENTER
       CX    = NX / 2 + 1
       CY    = NY / 2 + 1

C      CONSTRAIN SHIFT TO CIRCULAR BOUNDARY
       SHX = MODULO(SHXI, FLOAT(NX))
       SHY = MODULO(SHYI, FLOAT(NY))

       IF (SCLI == 1.0) THEN !-----------------------------------------

         FY0    = - SHY - CY
         FY1    = - SHY + NY - CY
         FY2    = - SHY - NY - CY

         FX0    = - SHX - CX
         FX1    = - SHX + NX - CX
         FX2    = - SHX - NX - CX

         SHYPNY = SHY + NY
         SHXPNX = SHX + NX

c$omp    parallel do private(iy,fy,ycod,ysid, ix,fx, xold,yold)
         DO IY=1, NY
            FY = IY + FY0 
            IF ((IY-1) <  SHY)    FY = IY + FY1 
            IF ((IY-1) >= SHYPNY) FY = IY + FY2 

            YCOD =  COSTH * FY + CY
            YSID = -SINTH * FY + CX

            DO IX=1, NX
              FX = IX + FX0 
              IF ((IX-1) <  SHX)    FX = IX + FX1
              IF ((IX-1) >= SHXPNX) FX = IX + FX2

              XOLD    = COSTH * FX + YSID
              YOLD    = SINTH * FX + YCOD

              BUF2(IX,IY) = FBS2(XOLD,YOLD, NXLD,NX,NY, BUF1,NXP,
     &                           X1,Y1,XY2, .TRUE.)
            ENDDO
          ENDDO

       ELSE !------------------------------------------- Needs speedup

         SCL   = 1 / SCLI

         IF (SCLI >= 1) THEN
            BNDI = INT(NX*(SCLI-1)/2)
            BNDJ = INT(NY*(SCLI-1)/2)
         ELSE
            BNDI = INT(NX*(SCLI-1)/2) - 1
            BNDJ = INT(NY*(SCLI-1)/2) - 1
         ENDIF

C        'RT SQ' OMP GAVE TIME: 3 ON 8 PROCS VS  6 ON 1
C        'RT SF' OMP GAVE TIME: 7 ON 8 PROCS VS 21 ON 1

c$omp    parallel do private(j,fj,fjcy,j4,i,fi,ficx,i4,xold,yold)
         DO J=BNDJ, NY*SCLI-BNDJ-1
            FJ   = MODULO(INT(J - BNDJ - SHY), NY) + BNDJ
            FJCY = FJ * SCL - CY + 1
            J4   = MODULO(J - BNDJ, NY) + 1

               DO I=BNDI, NX*SCLI-BNDI-1
                 FI   = MODULO(INT(I - BNDI- SHX), NX) + BNDI
                 FICX = FI * SCL - CX + 1
                 I4   = MODULO(I - BNDI, NX)+1

                 XOLD = COSTH*FICX - SINTH*FJCY + CX
                 YOLD = SINTH*FICX + COSTH*FJCY + CY

                 !if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                 !   write(6,*) ' bad index:',i,j,i4,j4,x,y
                 !   stop
                 !endif

                 BUF2(I4,J4) = FBS2(XOLD,YOLD, NXLD,NX,NY, BUF1,NXLD,
     &                        X1,Y1,XY2, .TRUE.)
              ENDDO
          ENDDO
       ENDIF

       IF (ALLOCATED(F0))  DEALLOCATE(F0)
       IF (ALLOCATED(X1))  DEALLOCATE(X1)
       IF (ALLOCATED(Y1))  DEALLOCATE(Y1)
       IF (ALLOCATED(XY2)) DEALLOCATE(XY2)

       END



C******************************** RTSF_PAD ****************************

C        INPUT: UNPADDED  OUTPUT: PADDED 

         SUBROUTINE RTSF_PAD(XIMG,BUFOUT, NX,NY, NXP,NYP,
     &                       THETA,SCLI,SHXI,SHYI, IRTFLG)

         IMPLICIT NONE
         REAL              :: XIMG(NX,NY)
         REAL              :: BUFOUT(NXP,NYP)
         INTEGER           :: NX,NY, NXP,NYP
         REAL              :: THETA,SCLI,SHXI,SHYI
         INTEGER           :: IRTFLG

         REAL              :: SHX,SHY,RY1,RX1,RY2,RX2,COD,SID,XI
         REAL              :: CODDSCLI,SIDDSCLI,FIXCENMSHX,FIYCENMSHY 
         REAL              :: RYE2,RYE1,RXE2,RXE1,YI
         REAL              :: YCOD,YSID,YOLD,XOLD
         INTEGER           :: IYCEN,IXCEN,IX,IY,MWANT,NXLD

         LOGICAL           :: CHKBOUND = .TRUE.

         REAL, ALLOCATABLE :: F0 (:,:)
         REAL, ALLOCATABLE :: X1 (:,:)
         REAL, ALLOCATABLE :: Y1 (:,:)
         REAL, ALLOCATABLE :: XY2(:,:)

	 REAL, PARAMETER   :: QUADPI = 3.14159265358979323846
	 REAL, PARAMETER   :: DGR_TO_RAD = (QUADPI/180)

         REAL              :: fbs2,quadri

         NXLD = NX + 2 - MOD(NX,2)       ! PAD FOR FFTW

         ALLOCATE (F0 (NXLD, NY),
     &             X1 (NXLD, NY),
     &             Y1 (NXLD, NY),
     &             XY2(NXLD, NY),
     &             STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN 
            MWANT = 4* NXLD*NY 
            CALL ERRT(46,'RTSF_PAD, F0...',MWANT)
            RETURN
         ENDIF 

         ! ARRAY ASSIGNMENT
         F0(1:NX,1:NY) = XIMG(1:NX,1:NY)

         CALL FBS2_PREP(F0, X1,Y1,XY2, NXLD, NX,NY, IRTFLG)

C        SHIFT WITHIN IMAGE BOUNDARY
         SHX = MOD(SHXI,FLOAT(NX))
         SHY = MOD(SHYI,FLOAT(NY))

C        SPIDER IMAGE CENTER
         IXCEN = NX/2+1
         IYCEN = NY/2+1

C        IMAGE DIMENSIONS AROUND ORIGIN
         RX1   = -NX/2
         RX2   =  NX/2
         RY1   = -NY/2
         RY2   =  NY/2

         IF (MOD(NX,2) == 0) THEN
            RX2  =  RX2 - 1.0
            RXE1 = -NX
            RXE2 =  NX
         ELSE
            RXE1 = -NX - 1
            RXE2 =  NX + 1
         ENDIF

         IF (MOD(NY,2) == 0) THEN
            RY2  =  RY2 - 1.0
            RYE1 = -NY 
            RYE2 =  NY
         ELSE
            RYE1 = -NY - 1
            RYE2 =  NY + 1

         ENDIF

C        CREATE TRANSFORMATION MATRIX
         COD = COS(THETA * DGR_TO_RAD)
         SID = SIN(THETA * DGR_TO_RAD)

C        ADJUST FOR SCALING
         CODDSCLI = COD / SCLI
         SIDDSCLI = SID / SCLI

C        -(CENTER PLUS SHIFT)
         FIXCENMSHX = -IXCEN - SHX
         FIYCENMSHY = -IYCEN - SHY

c$omp    parallel do private(iy,yi,ycod,ysid, ix,xi,xold,yold)
         DO IY=1,NY
            YI = IY + FIYCENMSHY
            IF (YI < RY1) YI = MIN(YI+RYE2, RY2)
            IF (YI > RY2) YI = MAX(YI+RYE1, RY1)

            YCOD =  YI * CODDSCLI + IYCEN
            YSID = -YI * SIDDSCLI + IXCEN

            DO IX=1,NX
               XI = IX + FIXCENMSHX                           
               IF (XI  <  RX1) XI = MIN(XI+RXE2, RX2)   
               IF (XI  >  RX2) XI = MAX(XI+RXE1, RX1) 
 
               YOLD          = XI * SIDDSCLI + YCOD  
               XOLD          = XI * CODDSCLI + YSID 
 
               BUFOUT(IX,IY) = FBS2(XOLD,YOLD, NXLD,NX,NY, 
     &                              XIMG,NX,
     &                              X1,Y1,XY2, CHKBOUND)
            ENDDO
         ENDDO

         !call chkfile('jnk-rot-1',98,1,nx,ny,1, bufout,irtflg)

         IF (ALLOCATED(F0))  DEALLOCATE(F0)
         IF (ALLOCATED(X1))  DEALLOCATE(X1)
         IF (ALLOCATED(Y1))  DEALLOCATE(Y1)
         IF (ALLOCATED(XY2)) DEALLOCATE(XY2)

         IRTFLG = 0

         END



@


1.38
log
@sub: RTSF_PADIN added for denoise use first
@
text
@d3 1
a3 1
C RTSF       NEW                         MAY 2011  GREGORY KISHCHENKO  * 
d6 2
a7 2
C            USED FBS2                   MAY 2011  GREGORY KISHCHENKO  *
C            SCALE BUG                   DEC 2011  GREGORY KISHCHENKO  *
d16 1
a16 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d33 13
a45 13
C                                                                      
C   RTSF(BUF1,BUF2, NXLD,NX,NY,
C        THETAT,SCLI,SHX,SHY, IRTFLG)            
C                                                                     
C   RTSF_PAD(XIMG,BUFOUT, NX,NY, NXP,NYP,
C            THETA,SCLI,SHXI,SHYI, IRTFLG)
C
C   PARAMETERS: BUF1         INPUT ARRAY                         INPUT 
C               BUF2         OUTPUT ARRAY                       OUTPUT 
C               THETAT       ANGLE                               INPUT
C               SCLI         SCALE FACTOR                        INPUT
C               SHXI,SHYI    SHIFTS                              INPUT
C               IRTFLG       ERROR FLAG                          INPUT                   
d93 1
a93 1
C   involving the data from neighboring points.                        *                        *
@


1.37
log
@RYE1 BUG
@
text
@d10 2
a11 2
C            RYE1 BUG                    MAY 2012  ArDean Leith
C                                                           *
d33 13
d47 3
a49 8
C   RTSF(BUF1,BUF2, NXLD,NX,NY, THETAT,SCLI,SHX,SHY, IRTFLG)           *
C                                                                      *
C   PARAMETERS: BUF1(I,J) - INPUT ARRAY                                *
C               BUF2(I,J) - OUTPUT ARRAY                               *
C                                                                      *
C   VARIABLES:  X1(I,J)   - D/DX DERIVATIVE                            *
C               Y1(I,J)   - D/DY DERIVATIVE                            *
C               XY2(I,J)  - D2/DXDY DERIVATIVE                         *
d107 2
d254 1
d415 153
a567 1
C******************************** RTSF_PAD *****************************
a692 1

@


1.36
log
@int() inside modulo for Intel compiler
@
text
@d10 2
a11 1
C                                                                      *
d480 1
a480 1
            RY2  = -NY - 1
@


1.35
log
@deaallocates were missing
@
text
@d211 1
a211 1
            FJ   = MODULO(J - BNDJ - SHY, NY) + BNDJ
d216 1
a216 1
                 FI   = MODULO(I - BNDI- SHX, NX) + BNDI
d370 1
a370 1
             FJ   = MODULO(J - BNDJ- SHY, NY) + BNDJ
d375 1
a375 1
                 FI   = MODULO(I - BNDI- SHX, NX) + BNDI
@


1.34
log
@F0(1:NX,1:NY) = XIMG(1:NX,1:NY)
@
text
@d431 1
a431 1
         REAL            :: fbs2,quadri
d520 5
@


1.33
log
@RTSF_PAD
@
text
@d409 13
a421 14
         REAL            :: XIMG(NX,NY)
         REAL            :: BUFOUT(NXP,NYP)
         INTEGER         :: NX,NY, NXP,NYP
         REAL            :: THETA,SCLI,SHXI,SHYI
         INTEGER         :: IRTFLG

	 REAL, PARAMETER :: QUADPI = 3.14159265358979323846
	 REAL, PARAMETER :: DGR_TO_RAD = (QUADPI/180)
         REAL            :: SHX,SHY,RY1,RX1,RY2,RX2,COD,SID,XI
         REAL            :: CODDSCLI,SIDDSCLI,FIXCENMSHX,FIYCENMSHY 
         REAL            :: RYE2,RYE1,RXE2,RXE1,YI
         REAL            :: YCOD,YSID,YOLD,XOLD
         INTEGER         :: IYCEN,IXCEN,IX,IY,MWANT,NXLD
         LOGICAL         :: CHKBOUND = .TRUE.
d428 4
a431 1
         REAL            :: fbs2
d433 1
a433 1
         NXLD   = NX + 2 - MOD(NX,2)  ! PAD FOR FFTW
d447 1
a447 1
         F0  = XIMG
d452 2
a453 2
         SHX   = AMOD(SHXI,FLOAT(NX))
         SHY   = AMOD(SHYI,FLOAT(NY))
d456 1
a457 1
         IXCEN = NX/2+1
d511 2
a512 1
               XOLD          = XI * CODDSCLI + YSID  
d514 1
a514 1
     &                              XIMG,NXLD,
d519 2
d522 1
@


1.32
log
@speedup
@
text
@d9 1
d402 120
@


1.31
log
@speed up by removing YSID from inner loop
@
text
@d8 1
d14 1
a14 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d116 1
a116 1
       REAL              :: X,Y, FICX,FJCY
d118 1
d160 12
a171 1
c$omp    parallel do private(j,fj,fjcy,ycod,ysid, i,fi,ficx, x,y)
d173 3
a175 3
            FJ = IY - SHY 
            IF ((IY-1) < SHY)         FJ = IY - SHY + NY 
            IF ((IY-1) >= (SHY + NY)) FJ = IY - SHY - NY 
d177 2
a178 4
            FJCY = FJ - CY

            YCOD =  COSTH * FJCY + CY
            YSID = -SINTH * FJCY + CX
d181 3
a183 3
              FI = IX - SHX 
              IF ((IX-1) < SHX)         FI = IX - SHX + NX
              IF ((IX-1) >= (SHX + NX)) FI = IX - SHX - NX
d185 2
a186 1
              FICX = FI - CX
d188 3
a190 10
              X    = COSTH * FICX + YSID
              Y    = SINTH * FICX + YCOD

              !if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
              !  write(6,*) ' bad index:',i,j,i4,j4,x,y
              !  stop
              !endif

              BUF2(IX,IY) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
     &                             X1,Y1,XY2, .TRUE.)
a191 2
       ENDDO

d193 1
d195 1
d197 29
a225 1
       ELSE !-------------------------------------------------
d227 1
a227 33
       SCL   = 1 / SCLI

       IF (SCLI >= 1) THEN
          BNDI = INT(NX*(SCLI-1)/2)
          BNDJ = INT(NY*(SCLI-1)/2)
       ELSE
          BNDI = INT(NX*(SCLI-1)/2) - 1
          BNDJ = INT(NY*(SCLI-1)/2) - 1
       ENDIF

C      'RT SQ' OMP GAVE TIME: 3 ON 8 PROCS VS  6 ON 1
C      'RT SF' OMP GAVE TIME: 7 ON 8 PROCS VS 21 ON 1

c$omp  parallel do private(j,fj,fjcy,j4,i,fi,ficx,i4,x,y)
       DO J=BNDJ, NY*SCLI-BNDJ-1
         FJ   = MODULO(J - BNDJ - SHY, NY) + BNDJ
         FJCY = FJ * SCL - CY + 1
         J4   = MODULO(J - BNDJ, NY) + 1

           DO I=BNDI, NX*SCLI-BNDI-1
             FI   = MODULO(I - BNDI- SHX, NX) + BNDI
             FICX = FI * SCL - CX + 1
             I4   = MODULO(I - BNDI, NX)+1

             X    = COSTH*FICX - SINTH*FJCY + CX
             Y    = SINTH*FICX + COSTH*FJCY + CY

             !if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
             !   write(6,*) ' bad index:',i,j,i4,j4,x,y
             !   stop
             !endif

             BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
d229 1
a230 2
       ENDDO

d265 1
a265 1
       REAL              :: X,Y
d268 1
d310 7
a316 33
c$omp    parallel do private(j,fj,fjcy,ycod,ysid, i,fi,ficx, x,y)
         DO IY=1, NY
            FJ = IY - SHY 
            IF ((IY-1) < SHY)         FJ = IY - SHY + NY 
            IF ((IY-1) >= (SHY + NY)) FJ = IY - SHY - NY 

            FJCY = FJ - CY

            YCOD =  COSTH * FJCY + CY
            YSID = -SINTH * FJCY + CX

              DO IX=1, NX
                FI = IX - SHX 
                IF ((IX-1) <   SHX)       FI = IX - SHX + NX
                IF ((IX-1) >= (SHX + NX)) FI = IX - SHX - NX

                FICX = FI - CX

                X    = COSTH * FICX + YSID
                Y    = SINTH * FICX + YCOD

                !if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                !  write(6,*) ' bad index:',i,j,i4,j4,x,y
                !  stop
                !endif

                IF  (USEBACK .AND. 
     &              (X < 1 .OR. X > NX .OR. 
     &               Y < 1 .OR. Y > NY)) THEN
C                  CORNER LOCATION IN NEW IMAGE
                   BUF2(IX,IY) = BACK     
                   CYCLE
                ENDIF
d318 2
a319 6
                BUF2(IX,IY) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
     &                             X1,Y1,XY2, .TRUE.)
             ENDDO
          ENDDO
       
       ELSE !-------------------------------------------------
d321 5
a325 1
       SCL   = 1 / SCLI
d327 2
a328 7
       IF (SCLI >= 1) THEN
          BNDI = INT(NX*(SCLI-1)/2)
          BNDJ = INT(NY*(SCLI-1)/2)
       ELSE
          BNDI = INT(NX*(SCLI-1)/2) -1
          BNDJ = INT(NY*(SCLI-1)/2) -1
       ENDIF
d330 4
a333 13
C      'RT SQ' OMP GAVE TIME:   ON 8 PROCS VS    ON 1
C      'RT SF' OMP GAVE TIME:   ON 8 PROCS VS    ON 1

c$omp  parallel do private(j,fj,fjcy,j4, i,fi,ficx,i4, x,y)
       DO J=BNDJ, NY*SCLI-BNDJ-1
          FJ   = MODULO(J - BNDJ- SHY, NY) + BNDJ
          FJCY = FJ*SCL - CY + 1
          J4   = MODULO(J - BNDJ, NY)+1

           DO I=BNDI, NX*SCLI-BNDI-1
              FI   = MODULO(I - BNDI- SHX, NX) + BNDI
              FICX = FI * SCL - CX + 1
              I4   = MODULO(I - BNDI, NX) + 1
d335 2
a336 2
              X    = COSTH*FICX - SINTH*FJCY + CX
              Y    = SINTH*FICX + COSTH*FJCY + CY
d339 2
a340 2
     &            (X < 1 .OR. X > NX .OR. 
     &             Y < 1 .OR. Y > NY)) THEN
d342 1
a342 1
                 BUF2(I4,J4) = BACK     
d346 44
a389 1
              BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
d391 1
a392 2
       ENDDO

@


1.30
log
@cosmetic, FLOAT(, omp lists
@
text
@d111 1
a111 1
       INTEGER           :: I,J,K
d116 1
a116 1
       REAL              :: SHX,SHY
d143 1
a144 1

d148 1
d152 1
d158 5
a162 5
c$omp    parallel do private(j,fj,fjcy,j4,i,fi,ficx,i4,x,y)
         DO J=0, NY-1
            FJ = J - SHY + 1
            IF (J < SHY)         FJ = J - SHY + NY + 1
            IF (J >= (SHY + NY)) FJ = J - SHY - NY + 1
a164 1
            J4   = J  + 1
d166 7
a172 4
              DO I=0, NX-1
                FI = I - SHX + 1
                IF (I < SHX)         FI = I - SHX + NX+1
                IF (I >= (SHX + NX)) FI = I - SHX - NX + 1
d174 1
a174 2
                FICX = FI - CX
                I4   = I + 1
d176 2
a177 2
                X    = COSTH*FICX - SINTH*FJCY + CX
                Y    = SINTH*FICX + COSTH*FJCY + CY
d179 4
a182 4
                !if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                !  write(6,*) ' bad index:',i,j,i4,j4,x,y
                !  stop
                !endif
d184 1
a184 1
                BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
d209 1
a209 1
         FJ = MODULO(J - BNDJ- SHY, NY) + BNDJ
d211 1
a211 1
         J4 = MODULO(J - BNDJ, NY) + 1
d215 1
a215 1
             FICX = FI*SCL - CX + 1
d261 1
a261 1
       INTEGER           :: I,J,K
d267 1
a267 1
       REAL              :: SHX,SHY
d294 1
a295 1

d299 1
d303 1
d309 15
a323 13
c$omp    parallel do private(j,fj,fjcy,j4, i,fi,ficx,i4,x,y)
         DO J=0, NY-1
            FJ = J - SHY + 1
            IF (J <   SHY)       FJ = J - SHY + NY + 1
            IF (J >= (SHY + NY)) FJ = J - SHY - NY + 1

            FJCY = FJ-CY
            J4   = J + 1

              DO I=0, NX-1
                FI = I - SHX+1
                IF (I < SHX)         FI = I - SHX + NX + 1
                IF (I >= (SHX + NX)) FI = I - SHX - NX + 1
a325 1
                I4   = I + 1
d327 7
a333 2
                X    = COSTH*FICX - SINTH*FJCY + CX
                Y    = SINTH*FICX + COSTH*FJCY + CY
d339 1
a339 1
                   BUF2(I4,J4) = BACK     
d343 1
a343 1
                BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
d356 2
a357 2
          BNDI = INT(NX*(SCLI-1)/2)-1
          BNDJ = INT(NY*(SCLI-1)/2)-1
d363 1
a363 1
c$omp  parallel do private(j,fj,fjcy,j4,i,fi,ficx,i4,x,y)
@


1.29
log
@gpk changes
@
text
@d98 1
a98 1
     &                 THETAT,SCLI, SHX,SHY, IRTFLG)
d107 1
a107 1
       REAL              :: SHX,SHY
d116 1
d151 2
a152 2
       SHX = MODULO(SHX, NX)
       SHY = MODULO(SHY, NY)
d166 14
a179 14
                 FI = I - SHX + 1
                 IF (I < SHX)         FI = I - SHX + NX+1
                 IF (I >= (SHX + NX)) FI = I - SHX - NX + 1

                 FICX = FI - CX
                 I4   = I + 1

                X = COSTH*FICX - SINTH*FJCY + CX
                Y = SINTH*FICX + COSTH*FJCY + CY

                if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                  write(6,*) ' bad index:',i,j,i4,j4,x,y
                  stop
                endif
d204 2
a205 3
c$omp     parallel do private(j,fj,fjcy,j4,i,fi,ficx,i4,x,y)

      DO J=BNDJ, NY*SCLI-BNDJ-1
d207 1
a207 1
         FJCY = FJ*SCL - CY + 1
d211 11
a221 11
              FI = MODULO(I - BNDI- SHX, NX) + BNDI
              FICX = FI*SCL - CX + 1
              I4 = MODULO(I - BNDI, NX)+1

             X = COSTH*FICX - SINTH*FJCY + CX
             Y = SINTH*FICX + COSTH*FJCY + CY

             if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                write(6,*) ' bad index:',i,j,i4,j4,x,y
                stop
             endif
d242 1
a242 1
     &                      THETAT,SCLI,SHX,SHY, 
d252 1
a252 1
       REAL              :: SHX,SHY
d264 1
d299 2
a300 2
       SHX = MODULO(SHX, NX)
       SHY = MODULO(SHY, NY)
d304 1
a304 2
c$omp     parallel do private(j,fj,fjcy,j4,i,fi,ficx,i4,x,y)

d314 3
a316 3
                 FI = I - SHX+1
                 IF (I < SHX)         FI = I - SHX + NX + 1
                 IF (I >= (SHX + NX)) FI = I - SHX - NX + 1
d318 2
a319 2
                 FICX = FI - CX
                 I4   = I + 1
d328 1
a328 1
                   BUF2(I4,J4) = BACK     ! SEEMS TO WORK OCT 11 al
d334 1
a335 1
       ENDDO
d352 2
a353 3
c$omp  parallel do private(i,fi,ficx,i4,j,fj,fjcy,j4,x,y)

      DO J=BNDJ, NY*SCLI-BNDJ-1
d360 1
a360 1
              FICX = FI*SCL - CX + 1
d370 1
a370 1
                 BUF2(I4,J4) = BACK     ! SEEMS TO WORK OCT 11 al
@


1.28
log
@*** empty log message ***
@
text
@d3 3
a5 4
C RTSF       NEW                         MAY 2011  GREGORY KISHCHENKO  *
C            RENAMED                     JUN 2011  ArDean Leith        *                                                                     *
C            SPLINE                      JUL 2011  ArDean Leith        *                                                                     *
C            OMP                         OCT 2011  ArDean Leith        *                                                                     *
d14 1
a14 1
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NROW 12204.    *
d20 1
a20 1
C=* License, or (at your option) aNROW later version.                  *
d23 1
a23 1
C=* but WITHOUT ANROW WARRANTY; without even the implied warranty of   *
d41 1
a41 1
C               Using 2d fourier-based bicubic spline interpolation    *
d155 13
a167 13
c$omp     parallel do private(i,fi,ficx,i4,j,fj,fjcy,j4,x,y)
          DO I=0, NX-1
             FI = I - SHX + 1
             IF (I < SHX)         FI = I - SHX + NX+1
             IF (I >= (SHX + NX)) FI = I - SHX - NX + 1

             FICX = FI - CX
             I4   = I + 1

             DO J=0, NY-1
                FJ = J - SHY + 1
                IF (J < SHY)         FJ = J - SHY + NY + 1
                IF (J >= (SHY + NY)) FJ = J - SHY - NY + 1
d169 2
a170 2
                FJCY = FJ - CY
                J4   = J  + 1
d203 1
a203 1
c$omp  parallel do private(i,fi,ficx,i4,j,fj,fjcy,j4,x,y)
d205 9
a213 11
       DO I=BNDI, NX*SCLI-BNDI-1
          FI = MODULO(I - BNDI- SHX, NX) + BNDI
          FI = FI*SCL+1
          FICX = FI-CX
          I4 = MODULO(I - BNDI, NX)+1

          DO J=BNDJ, NY*SCLI-BNDJ-1
             FJ = MODULO(J - BNDJ- SHY, NY) + BNDJ
             FJ = FJ*SCL+1
             FJCY = FJ-CY
             J4 = MODULO(J - BNDJ, NY) + 1
d303 14
a316 12
          DO I=0, NX-1
             FI = I - SHX+1
             IF (I < SHX)         FI = I - SHX + NX + 1
             IF (I >= (SHX + NX)) FI = I - SHX - NX + 1

             FICX = FI - CX
             I4   = I + 1

             DO J=0, NY-1
                FJ = J - SHY + 1
                IF (J <   SHY)       FJ = J - SHY + NY + 1
                IF (J >= (SHY + NY)) FJ = J - SHY - NY + 1
d318 2
a319 2
                FJCY = FJ-CY
                J4   = J + 1
d354 9
a362 11
       DO I=BNDI, NX*SCLI-BNDI-1
          FI   = MODULO(I - BNDI- SHX, NX) + BNDI
          FI   = FI*SCL+1
          FICX = FI - CX
          I4   = MODULO(I - BNDI, NX) + 1

          DO J=BNDJ, NY*SCLI-BNDJ-1
              FJ   = MODULO(J - BNDJ- SHY, NY) + BNDJ
              FJ   = FJ * SCL + 1
              FJCY = FJ - CY
              J4   = MODULO(J - BNDJ, NY)+1
d382 1
a382 1
888    IF (ALLOCATED(F0))  DEALLOCATE(F0)
@


1.27
log
@gpk's speedup (correct version)
@
text
@d8 1
d39 1
a39 1
C               XY2(I,J)   - D2/DXDY DERIVATIVE                        *
d115 2
a116 3
       REAL              :: FI,FJ,DEL
       REAL              :: X,Y
       REAL              :: FICX,FJCY
d148 39
a186 2
       CX    = NX / 2 +1
       CY    = NY / 2 +1
a187 2
        SHX = MODULO(SHX, NX)
        SHY = MODULO(SHY, NY)
d189 1
a189 3
          IF (SCLI.EQ.1) THEN
               GOTO 777
          ENDIF
d197 2
a198 2
          BNDI = INT(NX*(SCLI-1)/2)-1
          BNDJ = INT(NY*(SCLI-1)/2)-1
d204 1
a204 1
ccc$omp  parallel do private(i,fi,fi,i4,j,fj,fj,j4,x,y)
d207 5
a211 4
              FI = MODULO(I - BNDI- SHX, NX) + BNDI
              FI = FI*SCL+1
              FICX = FI-CX
              I4 = MODULO(I - BNDI, NX)+1
d213 4
a216 4
                 FJ = MODULO(J - BNDJ- SHY, NY) + BNDJ
                 FJ = FJ*SCL+1
                 FJCY = FJ-CY
                 J4 = MODULO(J - BNDJ, NY)+1
d218 2
a219 2
              X = COSTH*FICX - SINTH*FJCY + CX
              Y = SINTH*FICX + COSTH*FJCY + CY
d221 1
a221 1
              if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
d224 1
a224 1
              endif
d226 1
a226 1
              BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
d231 1
a231 22
          GOTO 888

777          DO I=0, NX-1
                 FI = I - SHX+1
             IF (I.LT.SHX) THEN
                 FI = I - SHX + NX+1
             ENDIF
             IF (I.GE.(SHX + NX)) THEN
                 FI = I - SHX - NX+1
             ENDIF
             FICX = FI-CX
             I4 = I + 1
                   DO J=0, NY-1
                       FJ = J - SHY+1
                   IF (J.LT.SHY) THEN
                       FJ = J - SHY + NY+1
                   ENDIF
                   IF (J.GE.(SHY + NY)) THEN
                       FJ = J - SHY - NY+1
                   ENDIF
             FJCY = FJ-CY
             J4 = J + 1
d233 4
a236 18
              X = COSTH*FICX - SINTH*FJCY + CX
              Y = SINTH*FICX + COSTH*FJCY + CY

              if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                write(6,*) ' bad index:',i,j,i4,j4,x,y
                stop
              endif

              BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
     &                        X1,Y1,XY2, .TRUE.)

          ENDDO
       ENDDO

888       IF (ALLOCATED(F0))  DEALLOCATE(F0)
          IF (ALLOCATED(X1))  DEALLOCATE(X1)
          IF (ALLOCATED(Y1))  DEALLOCATE(Y1)
          IF (ALLOCATED(XY2)) DEALLOCATE(XY2)
d301 2
a302 2
        SHX = MODULO(SHX, NX)
        SHY = MODULO(SHY, NY)
d304 35
a338 3
          IF (SCLI.EQ.1) THEN
               GOTO 777
          ENDIF
d353 1
a353 1
ccc$omp  parallel do private(i,fi,fi,i4,j,fj,fj,j4,x,y)
d356 5
a360 4
              FI = MODULO(I - BNDI- SHX, NX) + BNDI
              FI = FI*SCL+1
              FICX = FI-CX
              I4 = MODULO(I - BNDI, NX)+1
d362 4
a365 4
                 FJ = MODULO(J - BNDJ- SHY, NY) + BNDJ
                 FJ = FJ*SCL+1
                 FJCY = FJ-CY
                 J4 = MODULO(J - BNDJ, NY)+1
d367 2
a368 2
              X = COSTH*FICX - SINTH*FJCY + CX
              Y = SINTH*FICX + COSTH*FJCY + CY
d373 1
a373 1
C                CORNER LOCATION
a379 1

d383 1
a383 39
          GOTO 888

777          DO I=0, NX-1
                 FI = I - SHX+1
             IF (I.LT.SHX) THEN
                 FI = I - SHX + NX+1
             ENDIF
             IF (I.GE.(SHX + NX)) THEN
                 FI = I - SHX - NX+1
             ENDIF
             FICX = FI-CX
             I4 = I + 1
                   DO J=0, NY-1
                       FJ = J - SHY+1
                   IF (J.LT.SHY) THEN
                       FJ = J - SHY + NY+1
                   ENDIF
                   IF (J.GE.(SHY + NY)) THEN
                       FJ = J - SHY - NY+1
                   ENDIF
             FJCY = FJ-CY
             J4 = J + 1

              X = COSTH*FICX - SINTH*FJCY + CX
              Y = SINTH*FICX + COSTH*FJCY + CY

              IF  (USEBACK .AND. 
     &            (X < 1 .OR. X > NX .OR. 
     &             Y < 1 .OR. Y > NY)) THEN
C                CORNER LOCATION
                 BUF2(I4,J4) = BACK     ! SEEMS TO WORK OCT 11 al
                 CYCLE
              ENDIF

              BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
     &                        X1,Y1,XY2, .TRUE.)

          ENDDO
       ENDDO
@


1.26
log
@gpk's speedup
@
text
@d116 1
a147 2
       SCL   = 1 / SCLI

d151 9
d164 2
a165 2
          BNDI = INT(NX*(SCLI-1)/2) - 1
          BNDJ = INT(NY*(SCLI-1)/2) - 1
d171 20
d192 4
a195 1
       write(6,*) 'NX,SCLI:',NX,SCLI
d197 1
a197 4
       write(6,*) 'bndi,NX*SCLI-BNDI-1:',bndi,NX*SCLI-BNDI-1
 cNX,SCLI:          152    1.000000
 cbndi,NX*SCLI-BNDI-1:            0    151.0000
 cfi,i4:    149.1214                1
d199 20
a218 12
c$omp  parallel do private(i,fi,i4,j,fj,j4)
       DO I=BNDI, NX*SCLI-BNDI-1
          FI = MODULO(I - BNDI - SHX, NX) + BNDI
          FI = FI * SCL + 1
          I4 = MODULO(I - BNDI, NX) + 1
          write(6,*) 'fi,i4:',fi,i4
          stop

          DO J=BNDJ, NY*SCLI-BNDJ -1
             FJ = MODULO(J - BNDJ - SHY, NY) + BNDJ
             FJ = FJ * SCL + 1
             J4 = MODULO(J - BNDJ, NY) + 1
d220 2
a221 2
             X  = COSTH*(FI-CX) - SINTH*(FJ-CY) + CX
             Y  = SINTH*(FI-CX) + COSTH*(FJ-CY) + CY
d223 2
a224 2
             if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                write(6,*) ' Bad index:',i,j,i4,j4,x,y
d226 4
a229 1
             endif
a230 2
             BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
     &                          X1,Y1,XY2, .TRUE.)
d234 4
a237 4
       IF (ALLOCATED(F0))  DEALLOCATE(F0)
       IF (ALLOCATED(X1))  DEALLOCATE(X1)
       IF (ALLOCATED(Y1))  DEALLOCATE(Y1)
       IF (ALLOCATED(XY2)) DEALLOCATE(XY2)
d267 1
d299 5
a303 1
       SCL   =  1 / SCLI
d305 3
a307 1
       !write(6,*),'scli, scl =', scli, scl,' theta:',theta
d309 1
a309 2
       CX    = NX / 2 +1
       CY    = NY / 2 +1
d322 1
a322 6
c$omp  parallel do private(i,fi,i4,j,fj,j4)

       DO I=BNDI, NX*SCLI-BNDI - 1
          FI = MODULO(I - BNDI- SHX, NX) + BNDI
          FI = FI * SCL + 1
          I4 = MODULO(I - BNDI, NX) + 1
d324 5
d330 4
a333 3
              FJ = MODULO(J - BNDJ- SHY, NY) + BNDJ
              FJ = FJ * SCL + 1
              J4 = MODULO(J - BNDJ, NY)+1
d335 2
a336 2
              X  = COSTH*(FI-CX) - SINTH*(FJ-CY) + CX
              Y  = SINTH*(FI-CX) + COSTH*(FJ-CY) + CY
d352 41
a392 1
       IF (ALLOCATED(F0))  DEALLOCATE(F0)
@


1.25
log
@gpk's latest scale bug fix
@
text
@d156 2
a157 2
          BNDI = INT(NX*(SCLI-1)/2)-1
          BNDJ = INT(NY*(SCLI-1)/2)-1
a162 1
ccc$omp  parallel do private(i,fi,i4,j,fj,j4)
d164 8
d173 10
a182 7
              FI = MODULO(I - BNDI- SHX, NX) + BNDI
              FI = FI*SCL+1
              I4 = MODULO(I - BNDI, NX)+1
          DO J=BNDJ, NY*SCLI-BNDJ-1
                 FJ = MODULO(J - BNDJ- SHY, NY) + BNDJ
                 FJ = FJ*SCL+1
                 J4 = MODULO(J - BNDJ, NY)+1
d184 2
a185 2
              X = COSTH*(FI-CX) - SINTH*(FJ-CY) + CX
              Y = SINTH*(FI-CX) + COSTH*(FJ-CY) + CY
d187 2
a188 2
              if (i4 < 1 .or. i4 > nx .or. j4 < 1 .or. j4 > ny ) THEN
                write(6,*) ' bad index:',i,j,i4,j4,x,y
d190 1
a190 1
              endif
d192 2
a193 2
              BUF2(I4,J4) = FBS2(X,Y, NXLD,NX,NY, BUF1,NXLD,
     &                        X1,Y1,XY2, .TRUE.)
d279 6
a284 1
ccc$omp  parallel do private(i,fi,i4,j,fj,j4)
a285 4
       DO I=BNDI, NX*SCLI-BNDI-1
              FI = MODULO(I - BNDI- SHX, NX) + BNDI
              FI = FI*SCL+1
              I4 = MODULO(I - BNDI, NX)+1
d287 3
a289 3
                 FJ = MODULO(J - BNDJ- SHY, NY) + BNDJ
                 FJ = FJ*SCL+1
                 J4 = MODULO(J - BNDJ, NY)+1
d291 2
a292 2
              X = COSTH*(FI-CX) - SINTH*(FJ-CY) + CX
              Y = SINTH*(FI-CX) + COSTH*(FJ-CY) + CY
@


1.24
log
@typos
@
text
@a7 1
C            SCL BUG                     DEC 2011  GREGORY KISHCHENKO  *
d14 1
a14 1
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
d20 1
a20 1
C=* License, or (at your option) any later version.                    *
d23 1
a23 1
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
d39 1
a39 1
C                                                                      *                                              *
d114 1
a114 1
       REAL              :: FI,FJ
d153 2
a154 2
          BNDI = INT(NX*(SCLI-1)*0.5 + SCLI)
          BNDJ = INT(NY*(SCLI-1)*0.5 + SCLI)
d156 2
a157 2
          BNDI = INT((SCLI-1)*(NX-2)*0.5)
          BNDJ = INT((SCLI-1)*(NY-2)*0.5)
d163 1
a163 1
c$omp  parallel do private(i,fi,i4,j,fj,j4,x,y)
d165 8
a172 7
       DO I=BNDI, NX + BNDI-1
          FI = (I - SHX) * SCL
          I4 = MODULO(I - BNDI, NX) + 1

          DO J=BNDJ, NY + BNDJ-1
              FJ = (J - SHY) * SCL
              J4 = MODULO(J - BNDJ, NY) + 1
d174 2
a175 2
              X  = COSTH*(FI-CX) - SINTH*(FJ-CY) + CX
              Y  = SINTH*(FI-CX) + COSTH*(FJ-CY) + CY
d183 1
a183 1
     &                           X1,Y1,XY2, .TRUE.)
d259 2
a260 2
          BNDI = INT(NX*(SCLI-1)*0.5 + SCLI)
          BNDJ = INT(NY*(SCLI-1)*0.5 + SCLI)
d262 2
a263 2
          BNDI = INT((SCLI-1)*(NX-2)*0.5)
          BNDJ = INT((SCLI-1)*(NY-2)*0.5)
d269 10
a278 8
c$omp  parallel do private(i,fi,i4,j,fj,j4,x,y)
       DO I=BNDI, NX + BNDI-1
          FI = (I - SHX) * SCL
          I4 = MODULO(I - BNDI, NX) + 1

          DO J=BNDJ, NY + BNDJ-1
              FJ = (J - SHY) * SCL
              J4 = MODULO(J - BNDJ, NY) + 1
d280 2
a281 2
              X  = COSTH*(FI-CX) - SINTH*(FJ-CY) + CX
              Y  = SINTH*(FI-CX) + COSTH*(FJ-CY) + CY
@


1.23
log
@gpk's scale bug fix
@
text
@d15 1
a15 1
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NROW 12204.    *
d21 1
a21 1
C=* License, or (at your option) aNROW later version.                  *
d24 1
a24 1
C=* but WITHOUT ANROW WARRANTY; without even the implied warranty of   *
@


1.22
log
@fbs2 parameter added, cosmetic
@
text
@d8 1
d32 1
a32 1
C   RTSF(BUF1,BUF2, NXLD,NX,NY, THETA,SCLI,SHX,SHY, IRTFLG)          *
d99 1
a99 1
     &                 THETA,SCLI, SHX,SHY, IRTFLG)
d106 2
a107 1
       REAL              :: THETA,SCLI,SCL
d113 1
a113 1
       INTEGER           :: I2,J2,I4,J4
d115 1
d117 2
a118 4
       REAL              :: FI,FJ, FI2,FJ2
       REAL              :: COSTH, SINTH
       REAL              :: C1, C2
       REAL              :: FBS2
a140 1

d143 1
a143 1
       THETA = THETA*PI/180
d150 2
a151 2
       CX    = NX / 2
       CY    = NY / 2
d153 3
a155 3
       IF ((SCLI-1) >= 0) THEN
          BNDI = INT(NX*(SCLI-1)/2)
          BNDJ = INT(NY*(SCLI-1)/2)
d157 2
a158 2
          BNDI = INT(NX*(SCLI-1)/2)-1
          BNDJ = INT(NY*(SCLI-1)/2)-1
d164 1
a164 11
c$omp  parallel do private(i,fi,j,fj,fi2,fj2,x,y,i4,j4)

       DO I=BNDI, NX*SCLI-BNDI-1
          FI = I * SCL
          I4 = MODULO(I - BNDI-1,NX)

          DO J=BNDJ, NY*SCLI-BNDJ-1
              FJ  = J * SCL

              FI2 = COSTH*(FI-CX) - SINTH*(FJ-CY) + CX
              FJ2 = SINTH*(FI-CX) + COSTH*(FJ-CY) + CY
d166 15
a180 4
              X   = FI2 - SHX
              Y   = FJ2 - SHY

              J4  = MODULO(J - BNDJ-1,NY)
d183 1
a183 2
     &                        X1,Y1,XY2, .TRUE.)

d199 1
a199 1
     &                      THETA,SCLI,SHX,SHY, 
d207 2
a208 1
       REAL              :: THETA,SCLI,SCL
d216 1
a216 1
       INTEGER           :: I2,J2,I4,J4
d218 1
a219 4
       REAL              :: FI,FJ, FI2,FJ2
       REAL              :: COSTH, SINTH
       REAL              :: C1, C2
       REAL              :: FBS2
d221 5
a225 3
       REAL, ALLOCATABLE :: F0(:,:)
       REAL, ALLOCATABLE :: X1(:,:)
       REAL, ALLOCATABLE :: Y1(:,:)
d246 1
a246 1
       THETA = THETA*PI/180
d253 1
a253 2
       CX    = NX / 2
       CY    = NY / 2
d255 6
a260 3
       IF ((SCLI-1) >= 0) THEN
          BNDI = INT(NX*(SCLI-1)/2)
          BNDJ = INT(NY*(SCLI-1)/2)
d262 2
a263 2
          BNDI = INT(NX*(SCLI-1)/2)-1
          BNDJ = INT(NY*(SCLI-1)/2)-1
d269 19
a287 16
c$omp  parallel do private(i,fi,i4,j,fj,fi2,fj2,x,y,j4)

       DO I=BNDI, NX*SCLI-BNDI-1
          FI  = I * SCL
          I4  = MODULO(I - BNDI-1,NX)

          DO J=BNDJ, NY*SCLI-BNDJ-1
              FJ  = J * SCL

              FI2 = COSTH*(FI-CX) - SINTH*(FJ-CY) + CX
              FJ2 = SINTH*(FI-CX) + COSTH*(FJ-CY) + CY

              X   = FI2 - SHX
              Y   = FJ2 - SHY

              J4  = MODULO(J - BNDJ-1,NY)
@


1.21
log
@gpk used fbs2 call now
@
text
@d98 1
a98 1
     &                 THETA,SCLI,SHX,SHY, IRTFLG)
d102 4
a105 2
       REAL              :: BUF1(0:NXLD-1,0:NY-1)
       REAL              :: BUF2(0:NX-1,  0:NY-1)
a106 2
       REAL              :: THETA,SCLI,SCL
       INTEGER           :: NXLD, NX, NY
d108 1
d111 1
a111 1
       INTEGER           :: I2,J2,I3,J3,I4,J4
a113 2
       REAL              :: A0, A1, A2, A3
       REAL              :: AX, BX, DAX, DBX
a118 1
       REAL, ALLOCATABLE :: BUF10(:,:)
d126 4
a129 5
       ALLOCATE (BUF10 (0:NX-1, 0:NY-1),
     &           F0 (0:NXLD-1, 0:NY-1),
     &           X1 (0:NXLD-1, 0:NY-1),
     &           Y1 (0:NXLD-1, 0:NY-1),
     &           XY2(0:NXLD-1, 0:NY-1),
d137 2
a138 2
       ! ARRAY ASSIGNMENT
       F0  = BUF1
a139 6
c$omp  parallel do private(j,i)
       DO J=0, NY-1
          DO I= 0, NX-1
             BUF10(I,J) = BUF1(I,J)
          ENDDO
       ENDDO
d148 1
a148 1
       SCL = 1/SCLI
d150 2
a151 2
       CX = NX/2
       CY = NY/2
d153 1
a153 1
       IF ((SCLI-1) .GE. 0) THEN
d168 1
d176 2
a177 2
              X = FI2 - SHX
              Y = FJ2 - SHY
d179 1
a179 2
              I4 = MODULO(I - BNDI-1,NX)
              J4 = MODULO(J - BNDJ-1,NY)
d181 1
a181 1
              BUF2(I4,J4) = FBS2(X, Y, NXLD,NX,NY, BUF10,
d198 3
a200 3
     &                 NXLD, NX,  NY,
     &                 THETA,SCLI,SHX,SHY, 
     &                 USEBACK,BACK,  IRTFLG)
d204 5
d211 1
a212 6
       REAL              :: BUF1(0:NXLD-1,0:NY-1)
       REAL              :: BUF2(0:NX-1,  0:NY-1)
       REAL              :: SHX,SHY
       REAL              :: THETA,SCLI,SCL
       INTEGER           :: NXLD, NX, NY
       INTEGER           :: IRTFLG
d215 1
a215 1
       INTEGER           :: I2,J2,I3,J3,I4,J4
a217 2
       REAL              :: A0, A1, A2, A3
       REAL              :: AX, BX, DAX, DBX
a222 1
       REAL, ALLOCATABLE :: BUF10(:,:)
d230 4
a233 4
       ALLOCATE (F0 (0:NXLD-1, 0:NY-1),
     &           X1 (0:NXLD-1, 0:NY-1),
     &           Y1 (0:NXLD-1, 0:NY-1),
     &           XY2(0:NXLD-1, 0:NY-1),
a242 6
c$omp  parallel do private(j,i)
       DO J=0, NY-1
          DO I= 0, NX-1
             BUF10(I,J) = BUF1(I,J)
          ENDDO
       ENDDO
d251 1
a251 1
       SCL = 1/SCLI
d253 2
a254 2
       CX = NX/2
       CY = NY/2
d256 1
a256 1
       IF ((SCLI-1) .GE. 0) THEN
d267 1
a267 2
c$omp  parallel do private(i,fi,j,fj,fi2,fj2,x,y,
c$omp&                     i4,j4)
d270 2
a271 1
          FI  = I*SCL
d274 1
a274 1
              FJ  = J*SCL
d279 2
a280 2
              X = FI2 - SHX
              Y = FJ2 - SHY
d282 1
a282 2
              I4 = MODULO(I - BNDI-1,NX)
              J4 = MODULO(J - BNDJ-1,NY)
d284 2
a285 2
              BUF2(I4,J4) = FBS2(X, Y, NXLD,NX,NY, BUF10,
     &                        X1,Y1,XY2, .TRUE.)
@


1.20
log
@CALL FBS_PREP --> CALL FBS2_PREP
@
text
@d7 2
a8 1
C            FBS2                        DEC 2011  ARDEAN LEITH        *
d31 1
a31 1
C   RTSF(BUF1,BUF2, NXLD,NX,NY, THETA,SCLI,SHXI,SHYI, IRTFLG)          *
d98 1
a98 1
     &                 THETA,SCLI,SHXI,SHYI, IRTFLG)
d104 2
a106 2
       REAL              :: SHXI,SHYI
       REAL              :: THETA,SCLI,SCL
a107 1

d112 1
a112 1
       REAL              :: DX,DY
d114 1
a114 1
       REAL              :: ADX, BDX, DADX, DBDX
d118 3
a120 1
       
d128 2
a129 1
       ALLOCATE (F0 (0:NXLD-1, 0:NY-1),
d143 7
a151 1
       !WRITE(6,*) 'THETA = ', THETA
a158 2
       !write(6,*),'scli, scl =', scli, scl,' theta:',theta

d173 2
a174 2
c$omp  parallel do private(i,fi,j,fj,fi2,fj2,i2,j2,dx,dy,i3,j3,
c$omp&                     a0,a1,a2,a3,adx, bdx,dadx,dbdx,i4,j4)
d176 1
a176 1
          FI  = I*SCL
d179 1
a179 1
              FJ  = J*SCL
d184 2
a185 51
              IF (FI2 .GE. 0) THEN
                 I2 = INT(FI2)
              ELSE
                 I2 = INT(FI2) - 1
              ENDIF

              IF (FJ2 .GE. 0) THEN
                 J2 = INT(FJ2)
              ELSE
                 J2 = INT(FJ2) - 1
              ENDIF

              DX = FI2 - I2
              DY = FJ2 - J2

              I2 = MODULO(I2,NX)
              J2 = MODULO(J2,NY)
              I3 = MODULO(I2+1,NX)
              J3 = MODULO(J2+1,NY)


C            --Sequential algorithm for 16-term bicubic spline--

              A0  = BUF1(I2,J2)
              A1  = X1(I2,J2)
              A2  = 3*(BUF1(I3,J2)-A0) - 2*A1 - X1(I3,J2)
              A3  = 2*(A0-BUF1(I3,J2)) +   A1 + X1(I3,J2)
              ADX = A0 + A1*DX + A2*DX**2 + A3*DX**3

              A0 = BUF1(I2,J3)
              A1 = X1(I2,J3)
              A2 = 3*(BUF1(I3,J3)-A0) - 2*A1 - X1(I3,J3)
              A3 = 2*(A0-BUF1(I3,J3)) +   A1 + X1(I3,J3)
              BDX = A0 + A1*DX + A2*DX**2 + A3*DX**3

              A0  = Y1(I2,J2)
              A1  = XY2(I2,J2)
              A2  = 3*(Y1(I3,J2)-A0) -2*A1 - XY2(I3,J2)
              A3  = 2*(A0-Y1(I3,J2)) +  A1 + XY2(I3,J2)
              DADX = A0 + A1*DX + A2*DX**2 + A3*DX**3

              A0 = Y1(I2,J3)
              A1 = XY2(I2,J3)
              A2 = 3*(Y1(I3,J3)-A0) - 2*A1 - XY2(I3,J3)
              A3 = 2*(A0-Y1(I3,J3)) +   A1 + XY2(I3,J3)
              DBDX = A0 + A1*DX + A2*DX**2 + A3*DX**3

              A0 = ADX
              A1 = DADX
              A2 = 3*(BDX - ADX) - 2*DADX - DBDX
              A3 = 2*(ADX - BDX) +   DADX + DBDX
d187 2
a188 2
              I4 = MODULO(I+SHXI-BNDI,NX)
              J4 = MODULO(J+SHYI-BNDJ,NY)
d190 2
a191 1
              BUF2(I4,J4) = A0+A1*DY+A2*DY**2+A3*DY**3
d208 1
a208 1
     &                 THETA,SCLI,SHXI,SHYI, 
d213 3
d218 2
a220 4
       REAL              :: SHXI,SHYI
       REAL              :: THETA,SCLI,SCL
       LOGICAL           :: USEBACK
       REAL              :: BACK
a221 1

d226 1
a226 2

       REAL              :: DX,DY
d228 2
a229 2
       REAL              :: ADX, BDX, DADX, DBDX
       REAL              :: FI, FJ, FI2,FJ2
d232 3
a234 1
       
d255 7
a263 1
       !WRITE(6,*) 'THETA = ', useback
a270 2
       !write(6,*),'scli, scl =', scli, scl,' theta:',theta

d285 2
a286 2
c$omp  parallel do private(i,fi,i4,j,fj,j4,fi2,fj2,i2,j2,dx,dy,i3,j3,
c$omp&                     a0,a1,a2,a3,adx,bdx,dadx,dbdx)
d289 1
a289 2
          FI = I*SCL
          I4 = MODULO(I+SHXI-BNDI,NX)
a292 1
              J4  = MODULO(J+SHYI-BNDJ,NY)
d297 5
a301 59
              IF  (USEBACK .AND. 
     &            (FI2 < 1 .OR. FI2 > NY .OR. 
     &             FJ2 < 1 .OR. FJ2 > NX)) THEN
C                CORNER LOCATION
                 BUF2(I4,J4) = BACK     ! SEEMS TO WORK OCT 11 al
                 CYCLE
              ENDIF

              IF (FI2 .GE. 0) THEN
                 I2 = INT(FI2)
              ELSE
                 I2 = INT(FI2) - 1
              ENDIF

              IF (FJ2 .GE. 0) THEN
                 J2 = INT(FJ2)
              ELSE
                 J2 = INT(FJ2) - 1
              ENDIF

              DX = FI2 - I2
              DY = FJ2 - J2

              I2 = MODULO(I2,  NX)
              J2 = MODULO(J2,  NY)
              I3 = MODULO(I2+1,NX)
              J3 = MODULO(J2+1,NY)

C
C            --Sequential algorithm for 16-term bicubic spline--

              A0  = BUF1(I2,J2)
              A1  = X1(I2,J2)
              A2  = 3*(BUF1(I3,J2)-A0) - 2*A1 - X1(I3,J2)
              A3  = 2*(A0-BUF1(I3,J2)) +   A1 + X1(I3,J2)
              ADX = A0 + A1*DX + A2*DX**2 + A3*DX**3

              A0 = BUF1(I2,J3)
              A1 = X1(I2,J3)
              A2 = 3*(BUF1(I3,J3)-A0) - 2*A1 - X1(I3,J3)
              A3 = 2*(A0-BUF1(I3,J3)) +   A1 + X1(I3,J3)
              BDX = A0 + A1*DX + A2*DX**2 + A3*DX**3

              A0  = Y1(I2,J2)
              A1  = XY2(I2,J2)
              A2  = 3*(Y1(I3,J2)-A0) -2*A1 - XY2(I3,J2)
              A3  = 2*(A0-Y1(I3,J2)) +  A1 + XY2(I3,J2)
              DADX = A0 + A1*DX + A2*DX**2 + A3*DX**3

              A0 = Y1(I2,J3)
              A1 = XY2(I2,J3)
              A2 = 3*(Y1(I3,J3)-A0) - 2*A1 - XY2(I3,J3)
              A3 = 2*(A0-Y1(I3,J3)) +   A1 + XY2(I3,J3)
              DBDX = A0 + A1*DX + A2*DX**2 + A3*DX**3

              A0 = ADX
              A1 = DADX
              A2 = 3*(BDX - ADX) - 2*DADX - DBDX
              A3 = 2*(ADX - BDX) +   DADX + DBDX
d303 2
a304 1
              BUF2(I4,J4) = A0+A1*DY+A2*DY**2+A3*DY**3
@


1.19
log
@comment
@
text
@d7 1
d140 1
a140 1
       CALL FBS_PREP(F0, X1,Y1,XY2, NXLD, NX,NY, IRTFLG)
d295 1
a295 1
       CALL FBS_PREP(F0, X1,Y1,XY2, NXLD, NX,NY, IRTFLG)
@


1.18
log
@omp added, fbs_prep used
@
text
@d6 1
d319 1
@


1.17
log
@IF  (USEBACK .AND.
@
text
@d28 1
a28 1
C   RTSF                                                                  *
d30 7
d97 2
d109 1
a109 1
       INTEGER           :: INV
d111 1
a111 1
       REAL              :: A0, A1, A2, A3, B1
d113 1
a113 1
       REAL              :: IR, JR, IR2,JR2
a116 3
       REAL              :: WX(0:NXLD-1)
       REAL              :: WY(0:NY-1)

a134 3
       !WRITE(6,*) 'THETA = ', THETA
       THETA = THETA*PI/180

d138 1
a138 2
       INV = 1
       CALL FMRS(F0, NX,NY,1, 0.0D0, .TRUE.,.TRUE., INV, IRTFLG)
d140 2
a141 44
       A4 = 2*PI/REAL(NXLD)

       DO K=0,NXLD/2-1
          WX(K) = K*A4
       ENDDO
       WX(NXLD/2) = 0

       A4 = 2*PI/NY
       DO J=0,NY/2-1
          WY(J) = J*A4
       ENDDO
       WY(NY/2) = 0

       DO J=NY/2+1,NY-1
          WY(J) = (J-NY)*A4
       ENDDO


       DO K=0,NXLD/2-1
          A4 = WX(K)
          DO J=0,NY-1
             X1(2*K,J)   =  F0(2*K+1,J) * A4
             X1(2*K+1,J) = -F0(2*K,J)   * A4
          ENDDO
       ENDDO

       DO J=0,NY-1
          A4 = WY(J)
          DO K=0,NXLD/2-1
             Y1(2*K,J)   =  F0(2*K+1,J) * A4
             Y1(2*K+1,J) = -F0(2*K,J)   * A4
               XY2(2*K,J)   =  X1(2*K+1,J) * A4
               XY2(2*K+1,J) = -X1(2*K,J)   * A4
          ENDDO
       ENDDO

       INV = -1
       CALL FMRS(X1, NX,NY,1, 0.0D0, .TRUE.,.TRUE., INV, IRTFLG)

       INV = -1
       CALL FMRS(Y1, NX,NY,1, 0.0D0, .TRUE.,.TRUE., INV, IRTFLG)

       INV = -1
       CALL FMRS(XY2, NX,NY,1, 0.0D0, .TRUE., .TRUE., INV, IRTFLG)
d161 5
d167 1
a167 1
          IR  = I*SCL
d170 1
a170 1
              JR  = J*SCL
d172 2
a173 2
              IR2 = COSTH*(IR-CX) - SINTH*(JR-CY) + CX
              JR2 = SINTH*(IR-CX) + COSTH*(JR-CY) + CY
d175 2
a176 2
              IF (IR2 .GE. 0) THEN
                 I2 = INT(IR2)
d178 1
a178 1
                 I2 = INT(IR2) - 1
d181 2
a182 2
              IF (JR2 .GE. 0) THEN
                 J2 = INT(JR2)
d184 1
a184 1
                 J2 = INT(JR2) - 1
d187 2
a188 2
              DX = IR2 - I2
              DY = JR2 - J2
d195 1
a195 17
C             BICUBIC POLYNOMIAL INTERPOLATION:
C             F(dX)=A0 + A1*dX + A2*dX**2 + A3*dX**3
C             where dX is (X-i)
C
C             if F(i), and its derivative F'(i) are known,
C             A0, A1, A2, and A3 is given by
C             A0 = F(i)
C             A1 = F'(i)
C             A2 = 3*(F(i+1)-F(i) - 2*F'(i) - F'(i+1)
C             A3 = 2*(F(i)-F(i+1)) + F'(i) + F'(i+1)
C      
C             BUF1(I,J) - input array
C             BUF2(I,J) - output array
C             X1(I,J) - d/dX derivative
C             Y1(I,J) - d/dY derivative
C             XY2(I,J) - d2/dXdY derivative
C
a223 1
C             B1 = DBDX
d250 2
d264 2
a265 1
       INTEGER           :: INV
d267 1
a267 1
       REAL              :: A0, A1, A2, A3, B1
d269 1
a269 1
       REAL              :: IR, JR, IR2,JR2
a272 3
       REAL              :: WX(0:NXLD-1)
       REAL              :: WY(0:NY-1)

d287 1
a287 1
          CALL ERRT(46,'RTSF, F0...',MWANT)
a290 3
       !WRITE(6,*) 'THETA = ', useback
       THETA = THETA*PI/180

d293 1
d295 2
a296 47
       INV = +1
       CALL FMRS(F0, NX,NY,1, 0.0D0, .TRUE.,.TRUE., INV, IRTFLG)

       A4 = 2*PI/REAL(NXLD)

       DO K=0,NXLD/2-1
          WX(K) = K*A4
       ENDDO
       WX(NXLD/2) = 0

       A4 = 2*PI/NY
       DO J=0,NY/2-1
          WY(J) = J*A4
       ENDDO
       WY(NY/2) = 0

       DO J=NY/2+1,NY-1
          WY(J) = (J-NY)*A4
       ENDDO


       DO K=0,NXLD/2-1
          A4 = WX(K)
          DO J=0,NY-1
             X1(2*K,J)   =  F0(2*K+1,J) * A4
             X1(2*K+1,J) = -F0(2*K,J)   * A4
          ENDDO
       ENDDO

       DO J=0,NY-1
          A4 = WY(J)
          DO K=0,NXLD/2-1
             Y1(2*K,J)   =  F0(2*K+1,J) * A4
             Y1(2*K+1,J) = -F0(2*K,J)   * A4
               XY2(2*K,J)   =  X1(2*K+1,J) * A4
               XY2(2*K+1,J) = -X1(2*K,J)   * A4
          ENDDO
       ENDDO

       INV = -1
       CALL FMRS(X1,  NX,NY,1, 0.0D0, .TRUE.,.TRUE., INV, IRTFLG)

       INV = -1
       CALL FMRS(Y1,  NX,NY,1, 0.0D0, .TRUE.,.TRUE., INV, IRTFLG)

       INV = -1
       CALL FMRS(XY2, NX,NY,1, 0.0D0, .TRUE., .TRUE., INV, IRTFLG)
d316 5
d322 1
a322 1
          IR = I*SCL
a324 4
! not tested yet al
!c$omp     parallel do private(j,jr,j4,ir2,jr2,i2,j2,dx,dy,i3,j3,
!c$omp&                        a0,a1,a2,a3,adx,bdx,dadx,dbdx)

d326 1
a326 1
              JR  = J*SCL
d329 2
a330 2
              IR2 = COSTH*(IR-CX) - SINTH*(JR-CY) + CX
              JR2 = SINTH*(IR-CX) + COSTH*(JR-CY) + CY
d333 2
a334 2
     &            (IR2 < 1 .OR. IR2 > NY .OR. 
     &             JR2 < 1 .OR. JR2 > NX)) THEN
d340 2
a341 2
              IF (IR2 .GE. 0) THEN
                 I2 = INT(IR2)
d343 1
a343 1
                 I2 = INT(IR2) - 1
d346 2
a347 2
              IF (JR2 .GE. 0) THEN
                 J2 = INT(JR2)
d349 1
a349 1
                 J2 = INT(JR2) - 1
d352 2
a353 2
              DX = IR2 - I2
              DY = JR2 - J2
a359 16
C             BICUBIC POLYNOMIAL INTERPOLATION:
C             F(dX)=A0 + A1*dX + A2*dX**2 + A3*dX**3
C             where dX is (X-i)
C
C             if F(i), and its derivative F'(i) are known,
C             A0, A1, A2, and A3 is given by
C             A0 = F(i)
C             A1 = F'(i)
C             A2 = 3*(F(i+1)-F(i) - 2*F'(i) - F'(i+1)
C             A3 = 2*(F(i)-F(i+1)) + F'(i) + F'(i+1)
C      
C             BUF1(I,J) - input array
C             BUF2(I,J) - output array
C             X1(I,J) - d/dX derivative
C             Y1(I,J) - d/dY derivative
C             XY2(I,J) - d2/dXdY derivative
@


1.16
log
@added rtsf_back.f
@
text
@d343 1
a343 1
       !WRITE(6,*) 'THETA = ', THETA
d430 3
a432 2
              IF (IR2 < 1 .OR. IR2 > NY .OR. 
     &            JR2 < 1 .OR. JR2 > NX) THEN
@


1.15
log
@cosmetic
@
text
@d293 223
@


1.14
log
@() in if
@
text
@d30 5
a34 5
C   PURPOSE:    IMAGE ROTATION, SHIFT, & SCALE                         *
C               USING 2D FOURIER-BASED BICUBIC SPLINE INTERPOLATION    *
C               BETWEEN PIXELS.                                        *
C               ALGORITHM IS FAIRLY FAST AND PRESERVES FINE DETAILS    *
C               OF  IMAGES                                             *
d187 3
a189 1
       !WRITE(6,*),'SCLI, SCL =', SCLI, SCL
@


1.13
log
@IF (SCLI-1 .GE. 0) THEN ...
@
text
@d191 1
a191 1
       IF (SCLI-1 .GE. 0) THEN
@


1.12
log
@comments
@
text
@d94 1
a94 1
       REAL              :: THETA,SCLI
d106 1
a106 1
       REAL              :: SCL, C1, C2
d190 8
a197 2
       BNDI = INT(NX*(SCLI-1)/2)
       BNDJ = INT(NY*(SCLI-1)/2)
@


1.11
log
@x1 typo
@
text
@d49 15
a63 13
C      In order to interpolate a two dimensional grid [0,1] x [0,1],   *
C   we sequentially used 1D cubic interpolation formula. First,        *
C   we interpolated the intensities at two horizontal boundary         *
C   lines [0,0]-[1,0] and [0,1]-[1,1] using intensities and normal     *
C   to boundaries first derivatives in grid nodes. Thus we obtained    *
C   the intensities at two boundary lines of square cell.              *
C      Thereafter we carried out cubic interpolation in vertical line  *
C    between 2 horizontal line with a given value of X to obtain       *
C    the intensities inside the square cell.                           *
C       The last procedure was done using previously interpolated      *
C    values of intensities and their first normal derivatives across   *
C    cell boundaries (which was also approximated by cubic             *
C    interpolation at boundaries).                                     *
d68 5
a72 5
C      This well-known formula is very convenient for calculating      *
C   the derivatives of a  function defined as a discrete data set,     *
C   and allows to calculate the derivative in any local point          *
C   without the finite difference approximation involving the          *
C   data from neighboring points.                                      *
d239 1
a239 1
C            --Sequential algorithm for 16-term bicubic polynomial--
@


1.10
log
@spline used
@
text
@d277 1
a277 1
       IF (ALLOCATED(F0))  DEALLOCATE(FO)
d279 1
a279 1
       IF (ALLOCATED(X2))  DEALLOCATE(X2)
@


1.9
log
@interp bug
@
text
@d5 1
d28 1
a28 1
C   RTSF                                                               *
d31 1
a31 1
C               USING 2D FOURIER-BASED POLYNOMIAL INTERPOLATION        *
d36 1
a36 1
C   If the values of a function F(X) and its first derivatives F'(0)   *
d38 1
a38 1
C   interval [0,1] using a third degree polynomial (cubic              *
d49 22
a70 22
C      In order to interpolate a two dimensional grid, we used this    *
C   cubic interpolation formula. We interpolated the area              *
C   [0,1] x [0,1] by first interpolating 2 vertical lines [0,0]-[0,1]  *
C   and [1,0]-[1,1], and 2 horizontal lines [0,0]-[1,0] and            *
C   [0,1]-[1,1], and thus obtained the values of function at 4         *
C   boundaries' lines of square cell. After that we repeated the       *
C   same procedure to obtain the values inside the square cell. This   *
C   was done using the obtained values of function and first           *
C   derivatives  at boundaries in perpendicular to boundaries          *
C   directions which were approximated by linear interpolation. The    *
C   final result depends of direction (vertical or horizontal) in      *
C   which last interpolation was done. Therefore, we carried out       *
C   interpolation in both direction, and then averaged the obtained    *
C   values.                                                            *
C                                                                      *
C      The first derivatives dF/dX and dF/dY were obtained by          *
C   by calculating Fourier transform {F}, and then calculating the     *
C   inverse Fourier transform of {ik*F(k)}. This well-known formula is *
C   very convenient for calculating the derivatives of a  function     *
C   defined as a discrete data set, and allows to obtain the           *
C   derivative in any local point without involving the data from      *
C   neighboring points (and therefore spatial averaging).              *
d73 2
a74 2
C   standard bicubic interpolation (the densities and their            *
C   derivatives are continuous at boundaries), but has fewer           *
d77 3
a79 2
C   densities and their derivatives just from 4 pixels surrounding     *
C   the  point of interest instead 16 pixels as in standard algorithm. *
d89 1
a89 1
       REAL              :: BUF2(0:NX-1,0:NY-1)
d96 1
a96 1
       INTEGER           :: I,J,K1,K2
d100 2
a101 2
       REAL              :: A0, A1, A2, A3, B1, C1
       REAL              :: ADX,BDX, ADY, BDY
d112 1
d116 4
a119 3
       ALLOCATE (F0(0:NXLD-1, 0:NY-1),
     &           X1(0:NXLD-1, 0:NY-1),
     &           Y1(0:NXLD-1, 0:NY-1),
d122 1
a122 1
          MWANT = 3* NXLD*NY 
d126 5
a130 1
 
d132 1
d136 1
a136 1
       A4 = 2*PI/NXLD
d153 1
d167 2
d178 3
a180 1
       THETA = THETA*PI/180
d224 1
a224 1
C             if F(ARG), and its derivarive F'(ARG) are known,
d235 3
a238 2
C             Interpolation at  horizontal line [I,J]-[I+1,J]
C             F(I+dX,Y=J) = A0 + A1*dX + A2*dX**2 + A3*dX**3
d241 2
a242 2
              A2  = 3*(BUF1(I3,J2)-A0)-2*A1-X1(I3,J2)
              A3  = 2*(A0-BUF1(I3,J2))+A1+X1(I3,J2)
a244 3
C             Interpolation at horizontal line [I,J+1]-[I+1,J+1]
C             F(I+dX,Y=J+1) = A0 + A1*dX + A2*dX**2 + A3*dX**3

d251 12
a262 2
C             (1) Interpolation at vertical line [I+dX,J]-[I+dX,J+1]
C             F(I+dX,Y=J+DY) = A0 + A1*dY + A2*dY**2 + A3*dY**3
d264 4
a267 31
              A1 = Y1(I2,J2)*(1-DX) + Y1(I3,J2)*DX
              B1 = Y1(I2,J3)*(1-DX) + Y1(I3,J3)*DX
              A2 = 3*(BDX - ADX) - 2*A1 - B1
              A3 = 2*(ADX - BDX) +   A1 + B1
              C1 = A0+A1*DY+A2*DY**2+A3*DY**3

C             Interpolation at vertical line [I,J]-[I,J+1]
C             F(I,J+DY)=A0 + A1*dY + A2*dY**2 + A3*dY**3

              A0  = BUF1(I2,J2)
              A1  = Y1(I2,J2)
              A2  = 3*(BUF1(I2,J3)-A0) - 2*A1 - Y1(I2,J3)
              A3  = 2*(A0-BUF1(I2,J3)) +   A1 + Y1(I2,J3)
              ADY = A0 + A1*DY + A2*DY**2 + A3*DY**3

C             Interpolation at vertical line [I+1,J]-[I+1,J+1]
C             F(I+1,J+DY) = A0 + A1*dY + A2*dY**2 + A3*dY**3
              A0  = BUF1(I3,J2)
              A1  = Y1(I3,J2)
              A2  = 3*(BUF1(I3,J3)-A0) - 2*A1 - Y1(I3,J3)
              A3  = 2*(A0-BUF1(I3,J3)) +   A1 + Y1(I3,J3)
              BDY = A0+A1*DY+A2*DY**2+A3*DY**3

C             (2) Interpolation at horizontal line [I,J+dY]-[I+1,J+dY]
C             and averaging of interpolated values in both direction
C             F(I+dX,Y = J+DY)=A0 + A1*dX + A2*dX**2 + A3*dX**3
              A0 = ADY + C1
              A1  = X1(I2,J2)*(1-DY) + X1(I2,J3)*DY
              B1  = X1(I3,J2)*(1-DY) + X1(I3,J3)*DY
              A2 = 3*(BDY - ADY) - 2*A1 - B1
              A3 = 2*(ADY - BDY) +   A1 + B1
d272 1
a272 1
              BUF2(I4,J4) = 0.5*(A0+A1*DX+A2*DX**2+A3*DX**3)
d276 5
@


1.8
log
@renamed, cosmetic changes
@
text
@d26 6
a31 5
C
C   RTSF 
C
C   PURPOSE:    IMAGE ROTATION, SHIFT, & SCALE
C               USING 2D FOURIER-BASED SPLINE BETWEEN PIXELS.          *
d98 1
a98 1
       REAL              :: A0, A1, A2, A3, B1, A4
d221 1
a221 1
C
a223 1

d235 2
a236 2
              A2 = 3*(BUF1(I3,J3)-A0)-2*A1-X1(I3,J3)
              A3 = 2*(A0-BUF1(I3,J3))+A1+X1(I3,J3)
a240 1

d242 2
a243 2
              A1 = Y1(I2,J2)*DX + Y1(I3,J2)*(1-DX)
              B1 = Y1(I2,J3)*DX + Y1(I3,J3)*(1-DX)
d245 2
a246 3
              A3 = 2*(ADX - BDX) + A1 + B1

              A4 = A0+A1*DY+A2*DY**2+A3*DY**3
d253 2
a254 2
              A2  = 3*(BUF1(I2,J3)-A0) - 2  * A1 - Y1(I2,J3)
              A3  = 2*(A0-BUF1(I2,J3)) + A1 + Y1(I2,J3)
a258 1

d261 2
a262 2
              A2  = 3*(BUF1(I3,J3)-A0)-2*A1-Y1(I3,J3)
              A3  = 2*(A0-BUF1(I3,J3))+A1+Y1(I3,J3)
d268 3
a270 4

              A0 = ADY + A4
              A1 = X1(I2,J2)*DY + X1(I2,J3)*(1-DY)
              B1 = X1(I3,J2)*DY + X1(I3,J3)*(1-DY)
d272 1
a272 1
              A3 = 2*(ADY - BDY) + A1 + B1
@


1.7
log
@*** empty log message ***
@
text
@d3 2
a4 2
C RTKSQ       NEW                         MAY 2011  GREGORY KISHCHENKO *
C                                                                      *
d27 1
a27 1
C   RTKSQ 
d81 21
a101 20
       SUBROUTINE RTKSQ(BUF1, BUF2,
     &                  NXLD, NX,  NY,
     &                  THETA,SCLI,SHXI,SHYI, IRTFLG)

       REAL    :: BUF1(0:NXLD-1,0:NY-1)
       REAL    :: BUF2(0:NX-1,0:NY-1)
       INTEGER :: NXLD, NX, NY
       REAL    :: SHXI,SHYI
       REAL    :: THETA,SCLI
       INTEGER :: IRTFLG
       INTEGER :: CX, CY, BNDI, BNDJ
       INTEGER :: I,J,K1,K2
       INTEGER :: I2,J2,I3,J3,I4,J4
       INTEGER :: INV
       REAL    :: DX,DY
       REAL    :: A0, A1, A2, A3, B1, A4
       REAL    :: ADX,BDX, ADY, BDY
       REAL    :: IR, JR, IR2,JR2
       REAL    :: COSTH, SINTH
       REAL    :: SCLI, SCL, C1, C2
d103 2
a104 6
       REAL    :: WX(0:NXLD-1)
       REAL    :: WY(0:NY-1)

       !REAL    :: F0(0:NXLD-1, 0:NY-1)
       !REAL    :: X1(0:NXLD-1, 0:NY-1)
       !REAL    :: Y1(0:NXLD-1, 0:NY-1)
d110 1
a110 1
       REAL, PARAMETER :: PI = 3.14159265358979323846
d118 1
a118 1
          CALL ERRT(46,'RTKSQ, F0...',MWANT)
d146 2
a147 2
               X1(2*K,J)   =  F0(2*K+1,J) * A4
               X1(2*K+1,J) = -F0(2*K,J)   * A4
d154 2
a155 2
               Y1(2*K,J)   =  F0(2*K+1,J) * A4
               Y1(2*K+1,J) = -F0(2*K,J)   * A4
d169 12
a180 11
         SCL = 1/SCLI
         WRITE(6,*),'SCLI, SCL =', SCLI, SCL
           CX = NX/2
           CY = NY/2
         BNDI = INT(NX*(SCLI-1)/2)
         BNDJ = INT(NY*(SCLI-1)/2)

      DO I=BNDI, NX*SCLI-BNDI-1
       IR  = I*SCL
      DO J=BNDJ, NY*SCLI-BNDJ-1
       JR  = J*SCL
d182 2
a183 2
       IR2 = COSTH*(IR-CX)-SINTH*(JR-CY) + CX
       JR2 = SINTH*(IR-CX)+COSTH*(JR-CY) + CY
@


1.6
log
@*** empty log message ***
@
text
@d1 1
a1 1
C ++********************************************************************
d66 1
a66 1
C   defined as a discrete data set, and allows to calculate the        *
d76 1
a76 2
C   the  point of interest instead 16 pixels as in standard            *
C   algorithm.                                                         *
d91 1
a91 2
       INTEGER :: ICENT, KCENT

d93 1
a93 1
       INTEGER :: I2,J2,I3,J3
d100 1
a100 1
       REAL    :: SCL
d130 1
a131 1
C         WX(K) = 2*PI*K/NXLD
a137 1
C         WY(J) = 2*PI*J/NY
a142 1
C         WY(J) = 2*PI*(J-NY)/NY
a145 9
C       DO K=0,NXLD/2-1
C          DO J=0,NY-1
C               X1(2*K,J)   =  F0(2*K+1,J) * WX(K)
C               X1(2*K+1,J) = -F0(2*K,J)   * WX(K)
C               Y1(2*K,J)   =  F0(2*K+1,J) * WY(J)
C               Y1(2*K+1,J) = -F0(2*K,J)   * WY(J)
C          ENDDO
C       ENDDO

d168 1
a170 2
         ICENT = NX/2
         KCENT = NY/2
d173 5
d179 1
a179 2
C       DO I=0, NX2-1
       DO I=0, NX-1
d181 2
a182 3
C          DO J=0, NY2-1
          DO J=0, NY-1
          JR  = J*SCL
d184 2
a185 2
          IR2 = COSTH*(IR-ICENT-SHXI) - SINTH*(JR-KCENT-SHYI) + ICENT+SHXI
          JR2 = SINTH*(IR-ICENT-SHXI) + COSTH*(JR-KCENT-SHYI) + KCENT+SHYI
d201 1
a227 2
C             A2  = 3*(BUF1(I3,J2)-BUF1(I2,J2))-2*X1(I2,J2)-X1(I3,J2)
C             A3  = 2*(BUF1(I2,J2)-BUF1(I3,J2))+X1(I2,J2)+X1(I3,J2)
a236 2
C             A2 = 3*(BUF1(I3,J3)-BUF1(I2,J3))-2*X1(I2,J3)-X1(I3,J3)
C             A3 = 2*(BUF1(I2,J3)-BUF1(I3,J3))+X1(I2,J3)+X1(I3,J3)
a249 1
C             BUF2(I,J) = A0+A1*DY+A2*DY**2+A3*DY**3
a256 2
C             A2  = 3*(BUF1(I2,J3)-BUF1(I2,J2))-2*Y1(I2,J2)-Y1(I2,J3)
C             A3  = 2*(BUF1(I2,J2)-BUF1(I2,J3))+Y1(I2,J2)+Y1(I2,J3)
a265 2
C             A2  = 3*(BUF1(I3,J3)-BUF1(I3,J2))-2*Y1(I3,J2)-Y1(I3,J3)
C             A3  = 2*(BUF1(I3,J2)-BUF1(I3,J3))+Y1(I3,J2)+Y1(I3,J3)
a273 1
C             A0 = ADY + BUF2(I,J)
d280 4
a283 1
              BUF2(I,J) = 0.5*(A0+A1*DX+A2*DX**2+A3*DX**3)
@


1.5
log
@*** empty log message ***
@
text
@d76 1
a76 1
C   the  point of interest instead 16 pixels as in in standard         *
d82 1
a82 1
       SUBROUTINE RTSQK(BUF1, BUF2,
d92 1
d98 1
a98 1
       REAL    :: A0, A1, A2, A3, B1
d100 1
a100 1
       REAL    :: IR2,JR2
d102 2
a103 1

d183 4
d188 1
d190 2
a191 1

d193 1
d195 2
a196 2
              IR2 = COSTH *(I-SHXI) - SINTH * (J-SHYI) + SHXI
              JR2 = SINTH *(I-SHXI) + COSTH * (J-SHYI) + SHYI
@


1.4
log
@as installed
@
text
@d3 1
a3 1
C RTKSQ       NEW                          MAY 2011  GREGORY KISCHENKO *
@


1.3
log
@*** empty log message ***
@
text
@d96 1
a96 1
       REAL    :: PI,DX,DY
d104 8
a111 3
       REAL    :: F0(0:NXLD-1,0:NY-1)
       REAL    :: X1(0:NXLD-1,0:NY-1)
       REAL    :: Y1(0:NXLD-1,0:NY-1)
d115 10
d131 1
a131 1
C          WX(K) = 2*PI*K/NXLD
d138 1
a138 1
C          WY(J) = 2*PI*J/NY
d144 1
a144 1
C          WY(J) = 2*PI*(J-NY)/NY
d229 2
a230 2
C              A2  = 3*(BUF1(I3,J2)-BUF1(I2,J2))-2*X1(I2,J2)-X1(I3,J2)
C              A3  = 2*(BUF1(I2,J2)-BUF1(I3,J2))+X1(I2,J2)+X1(I3,J2)
d240 2
a241 2
C              A2 = 3*(BUF1(I3,J3)-BUF1(I2,J3))-2*X1(I2,J3)-X1(I3,J3)
C              A3 = 2*(BUF1(I2,J3)-BUF1(I3,J3))+X1(I2,J3)+X1(I3,J3)
d255 1
a255 1
C              BUF2(I,J) = A0+A1*DY+A2*DY**2+A3*DY**3
d263 4
a266 4
C              A2  = 3*(BUF1(I2,J3)-BUF1(I2,J2))-2*Y1(I2,J2)-Y1(I2,J3)
C              A3  = 2*(BUF1(I2,J2)-BUF1(I2,J3))+Y1(I2,J2)+Y1(I2,J3)
              A2  = 3*(BUF1(I2,J3)-A0))-2*A1-Y1(I2,J3)
              A3  = 2*(A0-BUF1(I2,J3))+A1+Y1(I2,J3)
d274 2
a275 2
C              A2  = 3*(BUF1(I3,J3)-BUF1(I3,J2))-2*Y1(I3,J2)-Y1(I3,J3)
C              A3  = 2*(BUF1(I3,J2)-BUF1(I3,J3))+Y1(I3,J2)+Y1(I3,J3)
d284 1
a284 1
C              A0 = ADY + BUF2(I,J)
@


1.2
log
@*** empty log message ***
@
text
@d114 1
d116 2
a117 1
          WX(K) = 2*PI*K/NXLD
d121 1
d123 2
a124 1
          WY(J) = 2*PI*J/NY
d129 2
a130 1
          WY(J) = 2*PI*(J-NY)/NY
d133 9
d143 1
d145 4
a148 2
               X1(2*K,J)   =  F0(2*K+1,J) * WX(K)
               X1(2*K+1,J) = -F0(2*K,J)   * WX(K)
d150 5
a154 2
               Y1(2*K,J)   =  F0(2*K+1,J) * WY(J)
               Y1(2*K+1,J) = -F0(2*K,J)   * WY(J)
d214 4
a217 2
              A2  = 3*(BUF1(I3,J2)-BUF1(I2,J2))-2*X1(I2,J2)-X1(I3,J2)
              A3  = 2*(BUF1(I2,J2)-BUF1(I3,J2))+X1(I2,J2)+X1(I3,J2)
d225 4
a228 2
              A2 = 3*(BUF1(I3,J3)-BUF1(I2,J3))-2*X1(I2,J3)-X1(I3,J3)
              A3 = 2*(BUF1(I2,J3)-BUF1(I3,J3))+X1(I2,J3)+X1(I3,J3)
d239 3
a241 1
              BUF2(I,J) = A0+A1*DY+A2*DY**2+A3*DY**3
d248 4
a251 2
              A2  = 3*(BUF1(I2,J3)-BUF1(I2,J2))-2*Y1(I2,J2)-Y1(I2,J3)
              A3  = 2*(BUF1(I2,J2)-BUF1(I2,J3))+Y1(I2,J2)+Y1(I2,J3)
d259 4
a262 2
              A2  = 3*(BUF1(I3,J3)-BUF1(I3,J2))-2*Y1(I3,J2)-Y1(I3,J3)
              A3  = 2*(BUF1(I3,J2)-BUF1(I3,J3))+Y1(I3,J2)+Y1(I3,J3)
d269 2
a270 1
              A0 = ADY + BUF2(I,J)
d275 1
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
C IMAGE ROTATION                                                       *
d9 1
a9 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d26 7
a32 6
C   PURPOSE:                                                           *
C   IMAGE ROTATION                                                     *
C   USING 2D FOURIER-DASED BICUBIC INTERPOLATION BETWEEN PIXELS.       *
C                                                                      *
C   Algorithm is fairly fast and preserving the fine details of        *
C   images                                                             *
a80 2
C
C       --------------------- FOUR1A_FPGK -----------------------
d82 3
a84 85
        SUBROUTINE FOUR1A_FPGK

        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC' 
        INCLUDE 'CMLIMIT.INC'
        

        CHARACTER (LEN=MAXNAM) :: FILNAM
        CHARACTER (LEN=1)      :: NULL = CHAR(0)

        REAL, ALLOCATABLE      :: BUF(:,:),BUF1(:,:),BUF2(:,:)  
 
	INTEGER, PARAMETER     :: LUN1 = 50
	INTEGER, PARAMETER     :: LUN2 = 51

	INTEGER                :: IFORM1,NSAM1,NROW1,NSLICE1,MAXIM1
	INTEGER                :: IFORM2,NSAM2,NROW2,NSLICE2,MAXIM2
	INTEGER                :: IRTFLG,NLETO,IT,NXLD,MWANT

        REAL                   :: SCALEX,SCALEY,SCALET

C       OPEN OLD FILE
        MAXIM1   = 0       
        CALL OPFILEC(0,.TRUE.,FILNAM,LUN1,'O',IFORM,
     &               NSAM1,NROW1,NSLICE1,
     &               MAXIM1,'INPUT',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C	GET OUTPUT FILE  NAME
        CALL FILERD(FILNAM,NLETO,NULL,'OUTPUT',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999



C        IT      = 8
C        IT      = 1

C        NSAM2   = NSAM1 * IT
C        NROW2   = NROW1 * IT
        NSAM2   = NSAM1
        NROW2   = NROW1
        NSLICE2 = 1

C	OPEN THE OUTPUT FILE
        MAXIM2 = 0
	CALL OPFILEC(LUN1,.FALSE.,FILNAM,LUN2,'U',IFORM,
     &             NSAM2,NROW2,NSLICE2, 
     &             MAXIM2,'OUTPUT',.TRUE.,IRTFLG)
	IF (IRTFLG .NE. 0) GOTO 9999

C        2D CASE
         NXLD   = NSAM1 + 2 - MOD(NSAM1,2)

         ALLOCATE (BUF( NXLD, NROW1), 
     &             BUF1(NXLD, NROW1),  
     &             BUF2(NSAM2,NROW2), STAT=IRTFLG)
         IF (IRTFLG.NE.0) THEN 

              MWANT = 2*NXLD*NROW1 + NSAM2*NROW2
              CALL ERRT(46,'FOUR1A_FP, BUF...',MWANT)
              GOTO 9999
         ENDIF 

C        READ INPUT IMAGE
         CALL READV(LUN1,BUF1,NXLD,NROW1,NSAM1,NROW1,NSLICE2)

C         CALL FINTGK(BUF1, BUF,  BUF2,
         CALL ROTCUBIC(BUF1, BUF,  BUF2,
     &               NXLD, NSAM1,NROW1,
C     &               NSAM2,NROW2, IT, IRTFLG)
     &               NSAM2,NROW2, IRTFLG)
         IF (IRTFLG .NE. 0) GOTO 9999

C        WRITE OUTPUT IMAGE
         CALL WRITEV(LUN2,BUF2,NSAM2,NROW2,NSAM2,NROW2,NSLICE2)

C        IMAGE FILE HEADER FOR PIXSIZ HAS CHANGED
         SCALEX = FLOAT(NSAM1)   / FLOAT(NSAM2)
         SCALEY = FLOAT(NROW1)   / FLOAT(NROW2)
         SCALET = SCALEX
         IF (SCALEY .NE. SCALEX) SCALET = 0.0   ! X NOT SAME AS Y

C        UPDATE THE INCORE HEADER VALUE & FILE HEADER FOR PIXSIZ
         CALL SETPRMS(LUN2, SCALET,IRTFLG)
d86 6
a91 18

9999    IF (ALLOCATED(BUF))  DEALLOCATE (BUF)
        IF (ALLOCATED(BUF1)) DEALLOCATE (BUF1)
        IF (ALLOCATED(BUF2)) DEALLOCATE (BUF2)

        CLOSE (LUN2)
        CLOSE (LUN1)

        END




C      ******************************* FINTGK *******************

       SUBROUTINE  ROTCUBIC(BUF1, BUF,  BUF2,
     &                    NXLD,NX,  NY,
     &                    NX2, NY2,IRTFLG)
d95 9
a103 14
       INTEGER :: NX, NY, NX2, NY2, NXLD
       INTEGER    ITX
       INTEGER    INV
       INTEGER :: SHXI,SHYI
         REAL    :: PI,DX,DY
         REAL    :: A0, A1, A2, A3, B1
         REAL    :: ADX,BDX, ADY, BDY
         REAL    :: IR2,JR2
         REAL    :: THETA
       REAL    :: BUF1(0:NXLD-1,0:NY-1)
       REAL    :: BUF (0:NXLD-1,0:NY-1)
       REAL    :: BUF2(0:NX2-1,0:NY2-1)
         REAL    :: WX(0:NXLD-1)
         REAL    :: WY(0:NY-1)
d108 1
a108 7
       PI = 3.14159274
C       SET THE VALUE OF THETA IN DEGREES
C       SET THE ROTATION CENTER
        THETA = 33
        THETA = THETA*PI/180
        SHXI=NX/2
        SHYI=NY/2
d110 1
a110 4
       WRITE(6,*) 'NX, NXLD, NX2 =',NX, NXLD, NX2
       WRITE(6,*) 'NY, NY2 =',NY, NY2

       F0 = BUF1
d112 1
a112 1
       CALL FMRS(F0, NX,NY,1, 0.0D0, .TRUE., .TRUE., INV, IRTFLG)
d117 2
a118 1
          WX(NXLD/2) = 0
d122 2
a123 1
          WY(NY/2) = 0
d127 10
a136 8
           DO K=0,NXLD/2-1
             DO J=0,NY-1
               X1(2*K,J)   = F0(2*K+1,J)*WX(K)
               X1(2*K+1,J) = -F0(2*K,J)*WX(K)
               Y1(2*K,J)   = F0(2*K+1,J)*WY(J)
               Y1(2*K+1,J) = -F0(2*K,J)*WY(J)
             ENDDO
           ENDDO
d139 1
a139 1
       CALL FMRS(X1, NX,NY,1, 0.0D0, .TRUE., .TRUE., INV, IRTFLG)
d142 8
a149 2
       CALL FMRS(Y1, NX,NY,1, 0.0D0, .TRUE., .TRUE., INV, IRTFLG)
C      ------------------------------------------------
d151 5
a155 6
          DO I=0, NX-1
             DO J=0, NY-1
              IR2=COS(THETA)*(I-SHXI)-SIN(THETA)*(J-SHYI)+SHXI
              JR2=SIN(THETA)*(I-SHXI)+COS(THETA)*(J-SHYI)+SHYI
              IF(IR2.GE.0) THEN
              I2=INT(IR2)
d157 1
a157 1
              I2=INT(IR2)-1
d159 3
a161 2
              IF(JR2.GE.0) THEN
              J2=INT(JR2)
d163 1
a163 1
              J2=INT(JR2)-1
d165 11
a175 10
              DX=IR2-I2
              DY=JR2-J2
              I2=MODULO(I2,NX)
              J2=MODULO(J2,NY)
              I3=MODULO(I2+1,NX)
              J3=MODULO(J2+1,NY)

C      BICUBIC POLYNOMIAL INTERPOLATION:
C      F(dX)=A0 + A1*dX + A2*dX**2 + A3*dX**3
C      where dX is (X-i)
d177 6
a182 6
C      if F(ARG), and its derivarive F'(ARG) are known,
C      A0, A1, A2, and A3 is given by
C       A0 = F(i)
C       A1 = F'(i)
C       A2 = 3*(F(i+1)-F(i) - 2*F'(i) - F'(i+1)
C       A3 = 2*(F(i)-F(i+1)) + F'(i) + F'(i+1)
d184 61
a244 55
C       BUF1(I,J) - input array
C       BUF2(I,J) - output array
C       X1(I,J) - d/dX derivative
C       Y1(I,J) - d/dY derivative

C      Interpolation at  horizontal line [I,J]-[I+1,J]
C      F(I+dX,Y=J)=A0 + A1*dX + A2*dX**2 + A3*dX**3
       A0 = BUF1(I2,J2)
       A1 = X1(I2,J2)
       A2 = 3*(BUF1(I3,J2)-BUF1(I2,J2))-2*X1(I2,J2)-X1(I3,J2)
       A3 = 2*(BUF1(I2,J2)-BUF1(I3,J2))+X1(I2,J2)+X1(I3,J2)
       ADX = A0 + A1*DX + A2*DX**2 + A3*DX**3

C      Interpolation at horizontal line [I,J+1]-[I+1,J+1]
C      F(I+dX,Y=J+1)=A0 + A1*dX + A2*dX**2 + A3*dX**3
       A0 = BUF1(I2,J3)
       A1 = X1(I2,J3)
       A2 = 3*(BUF1(I3,J3)-BUF1(I2,J3))-2*X1(I2,J3)-X1(I3,J3)
       A3 = 2*(BUF1(I2,J3)-BUF1(I3,J3))+X1(I2,J3)+X1(I3,J3)
       BDX = A0 + A1*DX + A2*DX**2 + A3*DX**3

C      (1) Interpolation at vertical line [I+dX,J]-[I+dX,J+1]
C      F(I+dX,Y=J+DY)=A0 + A1*dY + A2*dY**2 + A3*dY**3
       A0 = ADX
       A1 = Y1(I2,J2)*DX + Y1(I3,J2)*(1-DX)
       B1 = Y1(I2,J3)*DX + Y1(I3,J3)*(1-DX)
       A2 = 3*(BDX - ADX) - 2*A1 - B1
       A3 = 2*(ADX - BDX) + A1 + B1
       BUF2(I,J)=A0+A1*DY+A2*DY**2+A3*DY**3

C      Interpolation at vertical line [I,J]-[I,J+1]
C      F(I,J+DY)=A0 + A1*dY + A2*dY**2 + A3*dY**3
       A0 = BUF1(I2,J2)
       A1 = Y1(I2,J2)
       A2 = 3*(BUF1(I2,J3)-BUF1(I2,J2))-2*Y1(I2,J2)-Y1(I2,J3)
       A3 = 2*(BUF1(I2,J2)-BUF1(I2,J3))+Y1(I2,J2)+Y1(I2,J3)
       ADY = A0 + A1*DY + A2*DY**2 + A3*DY**3

C      Interpolation at vertical line [I+1,J]-[I+1,J+1]
C      F(I+1,J+DY)=A0 + A1*dY + A2*dY**2 + A3*dY**3
       A0 = BUF1(I3,J2)
       A1 = Y1(I3,J2)
       A2 = 3*(BUF1(I3,J3)-BUF1(I3,J2))-2*Y1(I3,J2)-Y1(I3,J3)
       A3 = 2*(BUF1(I3,J2)-BUF1(I3,J3))+Y1(I3,J2)+Y1(I3,J3)
       BDY = A0+A1*DY+A2*DY**2+A3*DY**3

C      (2) Interpolation at horizontal line [I,J+dY]-[I+1,J+dY]
C      and averaging of interpolated values in both direction
C      F(I+dX,Y=J+DY)=A0 + A1*dX + A2*dX**2 + A3*dX**3
       A0 = ADY + BUF2(I,J)
       A1 = X1(I2,J2)*DY + X1(I2,J3)*(1-DY)
       B1 = X1(I3,J2)*DY + X1(I3,J3)*(1-DY)
       A2 = 3*(BDY - ADY) - 2*A1 - B1
       A3 = 2*(ADY - BDY) + A1 + B1
       BUF2(I,J)=0.5*(A0+A1*DX+A2*DX**2+A3*DX**3)
d246 2
a247 2
                ENDDO
             ENDDO
a248 1
          RETURN
@
