head	1.51;
access;
symbols
	pre_getangas:1.47
	GPL2010:1.46
	pre_GPL2010:1.45
	pre_var_equation:1.45
	pre_fftwrings:1.42
	pre_opfiles:1.42
	src:1.42
	best-code:1.42
	x-named-regs:1.42
	x:1.42
	v13-00:1.42
	pre_GPL:1.40
	prec_CA:1.38
	noindx:1.33
	Bproc:1.30
	oct21:1.29
	last77:1.27;
locks; strict;
comment	@c @;


1.51
date	2015.01.20.19.26.14;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2014.06.02.12.04.33;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.26.16.47.06;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2011.02.18.15.55.06;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2010.10.21.17.44.55;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.24.13.26.24;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2009.03.03.14.37.06;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.31.15.19.23;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2008.10.17.12.49.15;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2005.10.17.19.51.44;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.17.17.49.07;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.30.16.42.32;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.05.14.27.48;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.10.19.26.21;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.28.19.23.10;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.18.16.03.55;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.10.19.57.15;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.23.15.51.28;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.20.15.19.02;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.23.15.45.26;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.20.16.51.13;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	99.12.08.16.03.38;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	99.09.13.16.27.30;	author pawel;	state Exp;
branches;
next	1.28;

1.28
date	99.04.09.17.04.53;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	99.03.29.20.16.01;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	99.03.12.20.49.58;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	99.02.19.17.00.16;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	99.01.22.13.46.54;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	99.01.08.16.42.03;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	98.04.07.14.19.41;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	98.01.28.16.00.57;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	98.01.27.17.13.57;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	98.01.26.14.52.59;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	98.01.21.20.42.41;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	98.01.12.20.29.49;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	97.12.11.21.18.19;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	97.12.10.21.19.15;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	97.12.08.16.59.10;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	97.12.01.21.42.43;	author liy;	state Exp;
branches;
next	1.12;

1.12
date	97.10.14.15.25.11;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	97.10.07.19.28.27;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	97.10.03.18.45.35;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	97.05.16.18.17.33;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	97.05.12.13.07.27;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	97.05.08.18.05.02;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	97.05.08.14.54.22;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	97.05.06.16.46.29;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	97.01.22.17.34.39;	author mladjadj;	state Exp;
branches;
next	1.3;

1.3
date	96.12.18.20.47.16;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	96.09.26.16.24.27;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	96.09.26.16.15.35;	author leith;	state Exp;
branches;
next	;


desc
@stacks introduced
@


1.51
log
@NZ LIMITED TO 100000 BUG
@
text
@
C++*********************************************************************
C
C OPENFIL.F       ADAPTED FROM OPEN3.FOR            OCT 88 ArDean Leith
C                 LONG FILENAMES                    OCT 88 ArDean Leith
C                 MERGED WITH OPENF                 AUG 96 ArDean Leith
C                 -1, -3 & -7 FOURIER REMOVED       AUG 96 ArDean Leith
C                 F90 CHANGES                       APR 98 ArDean Leith
C                 USED LUNHDR                       JAN 99 ArDean Leith
C                 INDEXED STACKS                    JAN 03 ArDean Leith
C                 HEADER COPY                       FEB 03 ArDean Leith
C                 ENDEDNESS                         FEB 03 ArDean Leith
C                 REMOVED IRTFLG INPUT              APR 04 ARDEAN LEITH
C                 MPI OPEN BUG & BCAST CHANGES      OCT 08 ARDEAN LEITH
C                 OPENINLN INTEGER*8                OCT 10 ARDEAN LEITH
C                 NZ LIMITED TO 100000 BUG          JAN 15 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    OPENFIL(LUNT,FILNAM,LUN,NX,NY,NZ,NSTACK,DISP,IRTFLG)
C
C    PURPOSE:       OPEN NEW OR EXISTING DATA FILE FOR RANDOM 
C                   ACCESS READING/WRITING.  CALLED FOR REGULAR FILES
C                   AND OVERALL STACK HEADERS.  THIS ROUTINE IS NOT
C                   CALLED FOR CREATING STACKED IMAGES WITHIN A
C                   STACK (ONLY FOR THE OVERALL STACK).  NEITHER
C                   IS IT USED FOR INLINE STACKS! 
C
C    PARAMETERS:
C        LUNT       UNIT TO COPY HEADER VALUES FROM               (SENT)
C        FILNAM     CHARACTER ARRAY, CONTAINING FILE NAME         (SENT)
C        LUN        LOGICAL UNIT NUMBER FOR FILNAM.               (SENT)
C        NX,NY      DIMENSIONS OF FILE                (SENT OR RETURNED)
C        NZ         NUMBER OF SLICES IN IMAGE         (SENT OR RETURNED)
C        NSTACK     STACK INDICATOR                    (SENT / RETURNED)
C                   ON INPUT: 
C                      FOR NEW FILE  0 : NOT A STACK, 
C                                   >0 : REGULAR STACK
C                                   <0 : INDEXED STACK, MAX TOTAL IMAGES
C                   ON OUTPUT: 
C                      -2  :  NOT A STACK 
C                      >=0 :  MAX IMAGE NUMBER NOW IN STACK.
C 
C        DISP       CHARACTER VARIABLE CONTAINING DISPOSITION     (SENT)
C                   SEE OPFIL.F FOR POSSIBLE VALUES            
C        KEEPEXT    TO KEEP EXTENSION                             (SENT)
C        IRTFLG     ERROR RETURN FLAG.                        (RETURNED)
C                     0 : NORMAL RETURN
C                     1 : ERROR RETURN
C                     5 : NOT A SPIDER INPUT IMAGE
C
C    CODING:   BASED ON IMAGE PARAMETERS NX,NY, & NZ,  A
C              NEW FILE IS OPENED WITH IREC RECORDS, EACH NX * 4 
C              BYTES LONG.  IREC ALLOWS SPACE FOR THE 3-D DISTRIBUTION,
C              PLUS NORMAL IMAGE HEADER.
C
C    VARIABLES: ITYPE (TYPE)  FILE TYPE SPECIFIER. 
C               +1    R     2-D IMAGE
C               +3    R3    3-D VOLUME FILE
C               -11   O2    2-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -12   E2    2-D FOURIER TRANSFORM, MIXED RADIX EVEN
C               -21   O3    3-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -22   E3    3-D FOURIER TRANSFORM, MIXED RADIX EVEN
C
C    CALL TREE:  SEE OPFILEC
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

	SUBROUTINE OPENFIL(LUNT,FILNAM,LUN,NX,NY,NZ,NSTACK,
     &                     ITYPE,DISP,KEEPEXT,IRTFLG)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'LABLOCK.INC'

        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

        CHARACTER(LEN=*)             :: FILNAM
        CHARACTER(LEN=MAXNAM)        :: FILNM
        CHARACTER(LEN=2*MAXNAM)      :: MSG
        CHARACTER(LEN=1)             :: NULL,DISP
        LOGICAL                      :: EX,CALLERRT,OPENED,KEEPEXT
        INTEGER, PARAMETER           :: I_8 = SELECTED_INT_KIND(12)
	INTEGER(KIND=I_8)            :: NWORDS8
        INTEGER(KIND=I_8), PARAMETER :: ZERO_8 = 0

#ifdef USE_MPI
        include 'mpif.h' 
        LOGICAL            :: ONLYONE_RED,ONLYONE_WRT
        COMMON /COMM_MPI/ONLYONE_RED,ONLYONE_WRT

        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
        IF (.NOT. ONLYONE_RED) MYPID = -1  !KLUDGE FOR 'AP REF'
#else 
        MYPID = -1    
#endif    
        NULL = CHAR(0)

C       SET FLAG FOR ERRONEOUS RETURN
        IRTFLG = 1
       
C	CHECK IF USER WANTS TO USE THE IN-LINE BUFFER.
        INLNED = 0
        IF (FILNAM(1:1) == '_') THEN
           CALL INLNBUF(FILNAM,NLET,INLNED,IRTFLGT)
           IF (IRTFLGT .NE. 0)  RETURN

	   IF (DISP == 'U' .OR. DISP == 'N') THEN
	      EX = .FALSE.
	   ELSE
	      EX = .TRUE.
	   ENDIF
           FILNM = FILNAM(1:NLET)

        ELSE
C          USE REGULAR FILE
           INLNED = 0
	   LUNC   = LUN

C          NULLIFY THE INLINE POINTER (CLOSEINLN IS INSIDE OPENINLN.F)
           CALL CLOSEINLN(LUN,IRTFLGT)

           IF (KEEPEXT) THEN
              FILNM = FILNAM
              NLET  = lnblnk(FILNM)
           ELSE
              CALL FILNAMANDEXT(FILNAM,DATEXC,FILNM,NLET,.TRUE.,IRTFLGT)
	      IF (IRTFLGT .NE.0) RETURN
           ENDIF

C          SEE IF FILE EXISTS NOW
           IF (MYPID <= 0) THEN
              INQUIRE(FILE=FILNM(1:NLET),IOSTAT=IER,EXIST=EX)
           ENDIF

#ifdef USE_MPI
           IF (ONLYONE_RED) THEN
              CALL BCAST_MPI('OPENFIL','EX', EX,1,'L',ICOMM)
              CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
           ENDIF
#endif
           IF (IER .NE. 0) THEN
              MSG =  'OPENFIL; INQUIRY ERROR: ' // FILNM(1:NLET)
              CALL ERRT(101,MSG,NE)
              RETURN
           ENDIF
        ENDIF

C       SET ACTUAL LUN FOR THIS FILE
        LUNARB(LUN) = LUN

        CALLERRT = (DISP(1:1) .NE. 'Z' .AND. DISP(1:1) .NE. 'E')

10	IF (DISP == 'U' .OR. DISP == 'N') THEN
C         USER WANTS A NEW FILE TO WRITE INTO ---------------------- NEW

          IF (EX) THEN
C           FILE IS IS OPENED WITH 'UNKNOWN' BUT ALREADY EXISTS; IT WILL
C           BE REPLACED.  OLD FILES ARE DELETED FIRST 
            IF (MYPID <= 0) THEN
               OPEN(UNIT=LUN,FILE=FILNM(1:NLET),STATUS='OLD')
               CLOSE(UNIT=LUN,STATUS='DELETE',IOSTAT=IER)
            ENDIF
#ifdef USE_MPI
            IF (ONLYONE_RED)
     &         CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
#endif

	    IF (IER .NE. 0) THEN
               MSG =  'OPENFIL; DELETING FILE: ' // FILNM(1:NLET)
               CALL ERRT(101,MSG,NE)
               RETURN
            ENDIF
          ENDIF

C         INITIALIZE HEADER OBJECT FOR NEW IMAGE 
          CALL LUNSETHDR(LUNT,LUN,NX,NY,NZ,ITYPE,NSTACK,IRTFLGT)

C         SET FMIN.... TO AVOID FLT. PT. ERROR ON DEC
          CALL LUNSETSTAT(LUN,0,0.0,0.0,0.0,0.0,IRTFLGT)

	  IF (INLNED == 0) THEN
C	     REGULAR FILE, NOT INLINE FILE

             LENREC = LENOPENFILE(NX*4)
             IF (MYPID <= 0) THEN
                OPEN(LUN,FILE=FILNM(1:NLET),STATUS='NEW',
     &               FORM='UNFORMATTED',
     &               ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
             ENDIF
#ifdef USE_MPI
             IF (ONLYONE_RED) THEN
                CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
             ENDIF
#endif
             IF (IER .NE. 0) THEN        
                MSG = 'OPENFIL; OPENING FILE: ' // FILNM(1:NLET)
                CALL ERRT(101,MSG,NE)
                RETURN
             ENDIF

C            FOR USING NEW FILE ON OLDER SPIDER RELEASES
             CALL LUNSET25(LUN,-1,IRTFLGT)

          ELSE
C            SET UP INLINE BUFFER AND TIE IT TO LUN

C            SAVE ISTACK IN NON-VOLATILE PART OF HEADER OBJECT
             CALL LUNGETISTACK(LUN,ISTACK,IRTFLGT)
             CALL LUNSETSTKALL(LUN,ISTACK,IRTFLGT)

             CALL LUNGETLAB(LUN,LABREC,INDXREC,NRECS,LABBYT,
     &                      LENBYT,IRTFLGT)
             IF (IRTFLGT .NE. 0) THEN
                write(6,*) 'nrecs,indxrec,lenbyt,errorflag:'
                write(6,*)  nrecs,indxrec,lenbyt,irtflgt
                RETURN
             ENDIF

             NWORDS8 = (NRECS + INDXREC) * LENBYT / 4

             CALL OPENINLN(LUN,INLNED,.TRUE.,NX,NWORDS8,
     &                     .TRUE.,IRTFLGT)
             IF (IRTFLGT .NE. 0)  RETURN
	  ENDIF

C         PUSH HEADER OBJECT INFO INTO NEW FILE
          CALL LUNWRTHED(LUN,NX,0,IRTFLGT)

          GOTO 2000

C         --------------------------------------------------------- OLD

	ELSEIF (DISP == 'O' .OR. DISP == 'K' .OR.
     &          DISP == 'Z' .OR. 
     &          DISP == 'E' .OR. DISP == 'M') THEN

C         FILE EXISTS, AND IS ACCESSED WITH 'OLD', OPEN THE FILE

	  IF (.NOT. EX) THEN
C            ERROR -- FILE DOES NOT EXIST, BUT BEING OPENED WITH 'OLD
             IF (MYPID <= 0)
     &             WRITE(NOUT,*) '*** FILE NOT FOUND: ',FILNM(1:NLET)

#ifdef USE_MPI
c            write(6,*) ' openfil; ',mypid, ' not found: ',filnm(1:nlet)
#endif

C	     FOR DISP=Z, DO NOT STOP THE BATCH JOB BY CALLING ERRT
             IF (CALLERRT) THEN
                MSG = 'OPENFIL; FILE NOT FOUND: ' // FILNM(1:NLET)
                CALL ERRT(101,MSG,NE)
             ENDIF
             RETURN
          ENDIF

          IF (INLNED .NE. 0) THEN
C            USE EXISTING INLINE BUFFER, TIE IT TO LUN & RETRIEVE NX
             CALL OPENINLN(LUN,INLNED,.FALSE.,NX,ZERO_8,
     &                     CALLERRT,IRTFLGT)
             IF (IRTFLGT .NE. 0)  RETURN
          ELSE
C            REGULAR FILE ACCESS

             LENREC = LENOPENFILE(256*4)
             IF (MYPID <= 0) THEN
                OPEN(LUN,FILE=FILNM(1:NLET),STATUS='OLD',
     &               ACCESS='DIRECT',
     &              FORM='UNFORMATTED',RECL=LENREC,IOSTAT=IER)
             ENDIF
#ifdef USE_MPI
             IF (ONLYONE_RED) THEN
                CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
             ENDIF
#endif

             IF (IER .NE. 0) THEN        
C               SEE IF FILE ALREADY OPEN ON DIFFERENT LUN
                IF (MYPID <= 0) THEN
                   INQUIRE(FILE=FILNM(1:NLET),IOSTAT=IER,OPENED=OPENED,
     &                     NUMBER=LUNOPENED)
                ENDIF
#ifdef USE_MPI
                IF (ONLYONE_RED) THEN
                  CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
                  CALL BCAST_MPI('OPENFIL','OPENED',OPENED,1,'L',ICOMM)
                  CALL BCAST_MPI('OPENFIL','LUNOPENED',LUNOPENED,1,
     &                           'I',ICOMM)
                ENDIF
#endif
                IF (OPENED) THEN
C                  MUST REDIRECT OLD LUNS TO CURRENT LUN, 
                   IF (MYPID <= 0)  CLOSE(LUNOPENED)
                   DO I = 1,100
                      IF (LUNARB(I) == LUNOPENED) LUNARB(I) = LUN
                   ENDDO

C                  NOW WE CAN REOPEN THIS SAME FILE ON LUN
                   IF (MYPID <= 0) THEN
                      OPEN(LUN,FILE=FILNM(1:NLET),STATUS='OLD',
     &                     ACCESS='DIRECT',
     &                     FORM='UNFORMATTED',RECL=LENREC,IOSTAT=IER)
                   ENDIF
#ifdef USE_MPI
                   IF (ONLYONE_RED) THEN
                      CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
                   ENDIF
#endif
                ELSE
C                  UNKNOWN ERROR
                   MSG = 'OPENFIL; OPENING FILE: ' // FILNM(1:NLET)
                   CALL ERRT(101,MSG,NE)
                   RETURN
                ENDIF
             ENDIF
     	  ENDIF

C         READ OVERALL HEADER FROM FILE 
          CALL LUNREDHED(LUN,256,0,.TRUE.,IRTFLGT)
          IF (IRTFLGT .NE. 0 .AND. MYPID <= 0) 
     &       WRITE(NOUT,*) '*** ERROR READING HEADER OF: ',FILNM(:NLET)
          IF (IRTFLGT .NE. 0) RETURN

C         NEED ITYPE
          CALL LUNGETTYPE(LUN,ITYPE,IRTFLGT)

          IF (ITYPE == -1 .OR. ITYPE == -3 .OR. ITYPE == -7) THEN
C           WANT TO READ OBSOLETE FORMAT FOURIER FILE
            WRITE(NOUT,96)
96          FORMAT(' *** CAN NOT READ OBSOLETE FOURIER FORMAT',/,
     &          '*** CONVERT FOURIER FILE TO REAL FORMAT USING ',
     &          'ORIGINAL VERSION OF SPIDER.'/)
             CALL ERRT(100, 'OPENFIL',NE)
             RETURN
          ENDIF

C         NEED NX VALUE 
          CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLGT)
          IF (IRTFLGT .NE. 0) RETURN

          !print *, 'READING HEADER OF: ',FILNM(:NLET)
          !print *, 'NX...: ',LUN,NX,NY,NZ,itype

          IF (ITYPE == 0 .OR. 
     &       NX <= 0     .OR. NY <= 0     .OR. NZ <= 0 .OR.
     &       NX > 10000000 .OR. NY > 10000000 .OR. 
     &       NZ > 10000000) THEN
C           NOT A NATIVE SPIDER IMAGE

C           FLIP BYTES IN HEADER OBJECT 
            CALL LUNFLIPHDR(LUN,IRTFLGT)
            CALL LUNSETFLIP(LUN,1,IRTFLG)

C           NEED ITYPE & SIZE
            CALL LUNGETTYPE(LUN,ITYPE,IRTFLGT)
            CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLGT)
            IF (IRTFLGT .NE. 0) RETURN

            IF (ITYPE == 0 ) THEN
C              PROBABLY NOT A SPIDER IMAGE
               IF (CALLERRT) THEN
                 CALL ERRT(102,'INVALID HEADER, BAD FILE TYPE',ITYPE)
               ENDIF
               IRTFLG = 5   ! RETURN ERROR FLAG FOR NON-SPIDER IMAGE

            ELSEIF ( NY <= 0 ) THEN
C              PROBABLY NOT A SPIDER IMAGE
               IF (CALLERRT) THEN
                 CALL ERRT(101,'INVALID HEADER, NX',NX)
               ENDIF
               IRTFLG = 5   ! RETURN ERROR FLAG FOR NON-SPIDER IMAGE

            ELSEIF ( NY <= 0 ) THEN
C              PROBABLY NOT A SPIDER IMAGE
               IF (CALLERRT) THEN
                 CALL ERRT(101,'INVALID HEADER, NY',NY)
               ENDIF
               IRTFLG = 5   ! RETURN ERROR FLAG FOR NON-SPIDER IMAGE

            ELSEIF ( NZ <= 0 ) THEN
C              PROBABLY NOT A SPIDER IMAGE
               IF (CALLERRT) THEN
                 CALL ERRT(101,'INVALID HEADER, NZ',NX)
               ENDIF
               IRTFLG = 5   ! RETURN ERROR FLAG FOR NON-SPIDER IMAGE

             ELSEIF (NX > 1000000) THEN
C              PROBABLY NOT A SPIDER IMAGE
               IF (CALLERRT) THEN
                 CALL ERRT(102,
     &              'INVALID HEADER, NX (LIMIT=10000000)',NX)
               ENDIF
               IRTFLG = 5   ! RETURN ERROR FLAG FOR NON-SPIDER IMAGE

             ELSEIF (NY > 1000000) THEN
C              PROBABLY NOT A SPIDER IMAGE
               IF (CALLERRT) THEN
                 CALL ERRT(102,
     &              'INVALID HEADER, NY (LIMIT=10000000)',NY)
               ENDIF
               IRTFLG = 5   !RETURN ERROR FLAG FOR NON-SPIDER IMAGE

             ELSEIF (NZ > 1000000) THEN
C              PROBABLY NOT A SPIDER IMAGE
               IF (CALLERRT) THEN
                 CALL ERRT(102,
     &              'INVALID HEADER, NZ (LIMIT=10000000)',NZ)
               ENDIF
               IRTFLG = 5   ! RETURN ERROR FLAG FOR NON-SPIDER IMAGE
            ENDIF

            IF (IRTFLG == 5) THEN
C              RETURN ERROR FLAG FOR NON-SPIDER IMAGE
               FILNAM = FILNM(1:NLET)
               RETURN
            ENDIF 

            IF (VERBOSE) 
     &         WRITE(NOUT,*) ' NON-NATIVE BYTE ORDERED SPIDER FILE'
          ENDIF


C         ON UNIX, REOPEN THE FILE WITH FINAL RECORD LENGTH
          IF (INLNED == 0) THEN
             CLOSE(LUN)
             LENREC = LENOPENFILE(NX*4)
             IF (MYPID <= 0) THEN
  	        OPEN(LUN,FILE=FILNM(1:NLET),STATUS='OLD',
     &               FORM='UNFORMATTED',
     &               ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
             ENDIF
#ifdef USE_MPI
             IF (ONLYONE_RED) THEN
                CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
             ENDIF
#endif
             IF (IER .NE. 0) THEN        
                MSG = 'OPENFIL; REOPENING FILE: ' // FILNM(1:NLET)
                CALL ERRT(101,MSG,NE)
                RETURN
             ENDIF
          ENDIF

        ELSE
           MSG = 'OPENFIL; PGM. ERROR, UNKNOWN DISP: ' // DISP
           CALL ERRT(101,MSG,NE)
           RETURN
        ENDIF

2000	CONTINUE

C       SAVE ISTACK IN NON-VOLATILE PART OF HEADER OBJECT
        CALL LUNGETISTACK(LUN,ISTACK,IRTFLGT)
        CALL LUNSETSTKALL(LUN,ISTACK,IRTFLGT)

C       SAVE MAXIM IN NON-VOLATILE PART OF HEADER OBJECT
        CALL LUNCOPYMAXIM(LUN,MAXIM,IRTFLGT)

C       SET FINAL LUNARA OFFSET VALUE FOR USE BY REDLIN/WRTLIN.
C       FOR INDEXED STACKS THIS INCLUDES INDEX OFFSET
        IF (ISTACK .NE. 0) THEN
           CALL LUNSETIMGOFF(LUN,0,NX,IRTFLGT)
        ELSE
           IVAL = 1
           CALL LUNSETIMGOFF(LUN,IVAL,NX,IRTFLGT)
        ENDIF

C       PUT COMMON VALUES INTO COMMON AREA (NOT NEEDED IN FUTURE?)
        CALL LUNSETCOMMON(LUN,IRTFLGT)

C       WRITE OUT FILE OPENING INFO
        CALL LUNSAYINFO(LUN,IRTFLGT)
      
C       NEED TO RETURN NSTACK & MAXIM 
        IF (ISTACK .NE. 0) THEN
C          RETURN CURRENT HIGHEST IMAGE NUMBER IN NSTACK
           NSTACK = MAXIM
        ELSE
C          NOT A STACK, RETURN -2
           NSTACK = -2
        ENDIF

C       SET FLAG FOR NORMAL RETURN	
        IRTFLG = 0
        RETURN

	END
@


1.50
log
@RETURN ERROR FLAG 5 FOR NON-SPIDER FILE
return FILNAM = FILNM(1:NLET)
@
text
@d16 1
d22 1
a22 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d367 3
a369 3
     &       NX <= 0      .OR. NY <= 0   .OR. NZ <= 0 .OR.
     &       NX > 100000 .OR. NY > 100000 .OR. 
     &       NZ > 100000) THEN
d379 22
d402 24
a425 4
            IF (IRTFLGT .NE. 0) RETURN
            IF (ITYPE == 0 .OR. 
     &         NX <= 0     .OR. NY <= 0     .OR. NZ <= 0 .OR.
     &         NX > 100000 .OR. NY > 100000 .OR. NZ > 100000) THEN
d428 2
a429 1
                 CALL ERRT(101,'INVALID HEADER, NOT A SPIDER IMAGE?',NE)
d431 4
a435 1
               IRTFLG = 5
d438 2
a439 1
            ENDIF
d443 1
@


1.49
log
@verbose: NON-NATIVE BYTE ORDERED....
nx
@
text
@d52 2
a53 2
C        NX,NY  DIMENSIONS OF FILE                (SENT OR RETURNED)
C        NZ     NUMBER OF SLICES IN IMAGE         (SENT OR RETURNED)
d381 2
a382 3
     &         NX <= 0  .OR. NY <= 0 .OR. NZ <= 0 .OR.
     &         NX   > 100000 .OR. NY > 100000 .OR. 
     &         NZ > 100000) THEN
d387 3
@


1.48
log
@IF (IRTFLGT .NE. 0) THEN
>                 write(6,*) 'nrecs,indxrec,lenbyt,errorflag:'
>                 write(6,*)  nrecs,indxrec,lenbyt,irtflgt
>                 RETURN
@
text
@d39 1
a39 1
C    OPENFIL(LUNT,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,DISP,IRTFLG)
d52 2
a53 2
C        NSAM,NROW  DIMENSIONS OF FILE                (SENT OR RETURNED)
C        NSLICE     NUMBER OF SLICES IN IMAGE         (SENT OR RETURNED)
d71 2
a72 2
C    CODING:   BASED ON IMAGE PARAMETERS NSAM,NROW, & NSLICE,  A
C              NEW FILE IS OPENED WITH IREC RECORDS, EACH NSAM * 4 
d89 1
a89 1
	SUBROUTINE OPENFIL(LUNT,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,
d125 1
a125 1
        IF (FILNAM(1:1) .EQ. '_') THEN
d129 1
a129 1
	   IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d153 1
a153 1
           IF (MYPID .LE. 0) THEN
d175 1
a175 1
10	IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d181 1
a181 1
            IF (MYPID .LE. 0) THEN
d198 1
a198 1
          CALL LUNSETHDR(LUNT,LUN,NSAM,NROW,NSLICE,ITYPE,NSTACK,IRTFLGT)
d203 1
a203 1
	  IF (INLNED .EQ. 0) THEN
d206 2
a207 2
             LENREC = LENOPENFILE(NSAM*4)
             IF (MYPID .LE. 0) THEN
d243 1
a243 1
             CALL OPENINLN(LUN,INLNED,.TRUE.,NSAM,NWORDS8,
d249 1
a249 1
          CALL LUNWRTHED(LUN,NSAM,0,IRTFLGT)
d255 3
a257 3
	ELSEIF (DISP .EQ. 'O' .OR. DISP .EQ. 'K' .OR.
     &          DISP .EQ. 'Z' .OR. 
     &          DISP .EQ. 'E' .OR. DISP .EQ. 'M') THEN
d263 1
a263 1
             IF (MYPID .LE. 0)
d279 2
a280 2
C            USE EXISTING INLINE BUFFER, TIE IT TO LUN & RETRIEVE NSAM
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,ZERO_8,
d287 1
a287 1
             IF (MYPID .LE. 0) THEN
d300 1
a300 1
                IF (MYPID .LE. 0) THEN
d314 1
a314 1
                   IF (MYPID .LE. 0)  CLOSE(LUNOPENED)
d316 1
a316 1
                      IF (LUNARB(I) .EQ. LUNOPENED) LUNARB(I) = LUN
d320 1
a320 1
                   IF (MYPID .LE. 0) THEN
d341 1
a341 1
          IF (IRTFLGT .NE. 0 .AND. MYPID .LE. 0) 
d348 1
a348 1
          IF (ITYPE .EQ. -1 .OR. ITYPE .EQ. -3 .OR. ITYPE .EQ. -7) THEN
d358 2
a359 2
C         NEED NSAM VALUE 
          CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLGT)
d363 1
a363 1
          !print *, 'nsam...: ',LUN,NSAM,NROW,NSLICE,itype
d365 4
a368 4
          IF (ITYPE .EQ. 0 .OR. 
     &       NSAM .LE. 0      .OR. NROW .LE. 0   .OR. NSLICE .LE. 0 .OR.
     &       NSAM .GT. 100000 .OR. NROW .GT. 100000 .OR. 
     &       NSLICE .GT. 100000) THEN
d377 1
a377 1
            CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLGT)
d380 4
a383 4
            IF (ITYPE .EQ. 0 .OR. 
     &         NSAM .LE. 0  .OR. NROW .LE. 0 .OR. NSLICE .LE. 0 .OR.
     &         NSAM .GT. 100000 .OR. NROW .GT. 100000 .OR. 
     &         NSLICE .GT. 100000) THEN
d390 2
a391 1
            WRITE(NOUT,*) ' NON-NATIVE BYTE ORDERED SPIDER FILE'
d395 1
a395 1
          IF (INLNED .EQ. 0) THEN
d397 2
a398 2
             LENREC = LENOPENFILE(NSAM*4)
             IF (MYPID .LE. 0) THEN
d433 1
a433 1
           CALL LUNSETIMGOFF(LUN,0,NSAM,IRTFLGT)
d436 1
a436 1
           CALL LUNSETIMGOFF(LUN,IVAL,NSAM,IRTFLGT)
@


1.47
log
@OPENINLN INTEGER*8
@
text
@d235 6
a242 3
             !write(6,*) 'nrecs,indxrec,lenbyt,nwords8'
             !write(6,*) nrecs,indxrec,lenbyt,nwords8

d341 3
a343 4
          IF (IRTFLGT .NE. 0 .AND. MYPID .LE. 0) THEN
             WRITE(NOUT,*) '*** ERROR READING HEADER OF: ',FILNM(:NLET)
             RETURN
          ENDIF
d361 3
@


1.46
log
@GPL_2010
@
text
@d15 1
d98 8
a105 5
        CHARACTER(LEN=*)        :: FILNAM
        CHARACTER(LEN=MAXNAM)   :: FILNM
        CHARACTER(LEN=2*MAXNAM) :: MSG
        CHARACTER(LEN=1)        :: NULL,DISP
        LOGICAL                 :: EX,CALLERRT,OPENED,KEEPEXT
d187 1
a187 1
     &            CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
d235 1
a235 1
             NWORDS   = (NRECS + INDXREC) * LENBYT / 4
d237 4
a240 1
             CALL OPENINLN(LUN,INLNED,.TRUE.,NSAM,NWORDS,
d277 2
a278 1
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,0,CALLERRT,IRTFLGT)
@


1.45
log
@renamed usebcast to  onlyone_red in: comm_mpi like other routines
@
text
@a16 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d18 5
a22 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d24 1
a24 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d29 1
a29 1
C=* This program is distributed in the hope that it will be useful,    *
d31 1
a31 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a32 1
C=*                                                                    *
d34 1
a34 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.44
log
@mpi changes
@
text
@d109 2
a110 2
        LOGICAL            :: USEBCAST
        COMMON /COMM_MPI/USEBCAST
d114 1
a114 1
        IF (.NOT. USEBCAST) MYPID = -1  !KLUDGE FOR 'AP REF'
d158 2
a159 2
           IF (USEBCAST) THEN
              CALL BCAST_MPI('OPENFIL','EX',EX,1,'L',ICOMM)
d186 2
a187 1
            IF (USEBCAST)CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
d213 1
a213 1
             IF (USEBCAST) THEN
d286 1
a286 1
             IF (USEBCAST) THEN
d298 1
a298 1
                IF (USEBCAST) THEN
d319 1
a319 1
                   IF (USEBCAST) THEN
d394 1
a394 1
             IF (USEBCAST) THEN
@


1.43
log
@mpi changes
@
text
@d101 5
a105 4
        CHARACTER(LEN=*)      :: FILNAM
        CHARACTER(LEN=MAXNAM) :: FILNM
        CHARACTER(LEN=1)      :: NULL,DISP
        LOGICAL               :: EX,CALLERRT,OPENED,KEEPEXT
d109 4
a112 1
        ICOMM   = MPI_COMM_WORLD 
d114 1
d158 4
a161 2
           CALL BCAST_MPI('OPENFIL','EX',EX,1,'L',ICOMM)
           CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
d164 2
a165 2
              WRITE(NOUT,*) '*** FILE INQUIRY ERROR: ',FILNM(1:NLET)
              CALL ERRT(100,'OPENFIL',NE)
d186 1
a186 1
            CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
d190 2
a191 2
               WRITE(NOUT,*) '*** ERROR DELETING FILE: ', FILNM(1:NLET)
               CALL ERRT(100,'OPENFIL',NE)
d212 3
a214 1
             CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
d217 2
a218 2
                WRITE(NOUT,*) '*** ERROR OPENING FILE: ',FILNM(1:NLET)
                CALL ERRT(100,'OPENFIL',NE)
d255 1
a255 1
C            ERROR -- FILE DOES NOT EXIST, BUT BEING OPENED WITH 'OLD'
d259 4
d264 4
a267 1
             IF (CALLERRT) CALL ERRT(100,'OPENFIL',NE)
d285 3
a287 1
             CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
d297 6
a302 4
                CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
                CALL BCAST_MPI('OPENFIL','OPENED',OPENED,1,'L',ICOMM)
                CALL BCAST_MPI('OPENFIL','LUNOPENED',LUNOPENED,1,
     &                         'I',ICOMM)
d318 3
a320 1
                   CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
d324 2
a325 3
                   IF (MYPID .LE. 0)  
     &             WRITE(NOUT,*)'*** ERROR OPENING FILE: ',FILNM(1:NLET)
                   CALL ERRT(100,'OPENFIL',NE)
d393 3
a395 1
             CALL BCAST_MPI('OPENFIL','IER',IER,1,'I',ICOMM)
d398 2
a399 2
                WRITE(NOUT,*)'*** ERROR REOPENING FILE: ',FILNM(1:NLET)
                CALL ERRT(100,'OPENFIL',NE)
d405 3
a407 3
          WRITE(NOUT,*)'*** PGM. ERROR: UNKNOWN DISP IN OPENFIL: ',DISP
          CALL ERRT(100,'OPENFIL',NE)
          RETURN
@


1.42
log
@GPL License fixed
@
text
@d14 1
d18 1
a18 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a81 1
C               -9    FS    3-D SIMPLE FORMAT FOURIER (MICHAEL'S FORMAT)
d101 5
a105 4
        CHARACTER(LEN=*) ::       FILNAM
        CHARACTER(LEN=MAXNAM) ::  FILNM
        CHARACTER(LEN=1) ::       NULL,DISP
	LOGICAL  ::               EX,CALLERRT,OPENED,KEEPEXT
d108 2
a109 4
        INTEGER MYPID, COMM, MPIERR
        COMM   = MPI_COMM_WORLD 
        MPIERR = 0  
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
d125 1
a125 1
	     EX  = .FALSE.
d127 1
a127 1
	     EX  = .TRUE.
d133 2
a134 2
           INLNED      = 0
	   LUNC        = LUN
a147 1
#ifdef USE_MPI
d151 4
a154 12
           CALL MPI_BCAST(EX,1,MPI_LOGICAL,0,COMM,MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) ' OPENFIL: FAILED TO BCAST EX'
              STOP
           ENDIF
           CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
           IF (MPIERR .NE. 0) THEN
              WRITE(0,*) ' OPENFIL: FAILED TO BCAST IER'
              STOP
           ENDIF
#else
	   INQUIRE(FILE=FILNM(1:NLET),IOSTAT=IER,EXIST=EX)
d174 1
a174 2
#ifdef USE_MPI
            IF (MYPID .EQ. 0) THEN
d178 2
a179 8
            CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
            IF (MPIERR .NE. 0) THEN
               WRITE(0,*) ' OPENFIL: FAILED TO BCAST IER'
               STOP
            ENDIF
#else
            OPEN(UNIT=LUN,FILE=FILNM(1:NLET),STATUS='OLD')
            CLOSE(UNIT=LUN,STATUS='DELETE',IOSTAT=IER)
d199 1
a199 2
#ifdef USE_MPI
             IF (MYPID .EQ. 0) THEN
d204 2
a205 9
             CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) ' OPENFIL: FAILED TO BCAST IER'
                STOP
             ENDIF
#else
	     OPEN(LUN,FILE=FILNM(1:NLET),STATUS='NEW',
     &            FORM='UNFORMATTED',
     &            ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
d247 2
a248 1
             WRITE(NOUT,*) '*** FILE NOT FOUND: ',FILNM(1:NLET)
d263 5
d269 1
a269 10
             OPEN(LUN,FILE=FILNM(1:NLET),STATUS='OLD',ACCESS='DIRECT',
     &           FORM='UNFORMATTED',RECL=LENREC,IOSTAT=IER)
             CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) ' OPENDOC: FAILED TO BCAST IER'
                STOP
             ENDIF
#else
             OPEN(LUN,FILE=FILNM(1:NLET),STATUS='OLD',ACCESS='DIRECT',
     &           FORM='UNFORMATTED',RECL=LENREC,IOSTAT=IER)
d274 1
a274 2
#ifdef USE_MPI
                IF (MYPID .EQ. 0) THEN
d278 5
a282 18
                CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
                IF (MPIERR .NE. 0) THEN
                   WRITE(0,*) ' OPENFIL: FAILED TO BCAST IER'
                   STOP
                ENDIF
                CALL MPI_BCAST(OPENED,1,MPI_LOGICAL,0,COMM,MPIERR)
                IF (MPIERR .NE. 0) THEN
                   WRITE(0,*) ' OPENFIL: FAILED TO BCAST OPENED'
                   STOP
                ENDIF
                CALL MPI_BCAST(LUNOPENED,1,MPI_INTEGER,0,COMM,MPIERR)
                IF (MPIERR .NE. 0) THEN
                   WRITE(0,*) ' OPENFIL: FAILED TO BCAST LUNOPENED'
                   STOP
                ENDIF
#else
	        INQUIRE(FILE=FILNM(1:NLET),IOSTAT=IER,OPENED=OPENED,
     &                  NUMBER=LUNOPENED)
d286 1
a286 1
                   CLOSE(LUNOPENED)
d292 1
a292 2
#ifdef USE_MPI
                   IF (MYPID .EQ. 0) THEN
d297 2
a298 9
                   CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
                   IF (MPIERR .NE. 0) THEN
                      WRITE(0,*) ' OPENDOC: FAILED TO BCAST IER'
                      STOP
                   ENDIF
#else
                   OPEN(LUN,FILE=FILNM(1:NLET),STATUS='OLD',
     &                 ACCESS='DIRECT',
     &                FORM='UNFORMATTED',RECL=LENREC,IOSTAT=IER)
d302 2
a303 1
                   WRITE(NOUT,*)'*** ERROR OPENING FILE: ',FILNM(1:NLET)
d310 1
a310 1
C         READ OVERALL HEADER FROM FILE            	       
d312 1
a312 1
          IF (IRTFLGT .NE. 0) THEN
d366 1
a366 2
#ifdef USE_MPI
             IF (MYPID .EQ. 0) THEN
d371 2
a372 9
             CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
             IF (MPIERR .NE. 0) THEN
                WRITE(0,*) ' OPENFIL: FAILED TO BCAST IER'
                STOP
             ENDIF
#else
	     OPEN(LUN,FILE=FILNM(1:NLET),STATUS='OLD',
     &             FORM='UNFORMATTED',
     &             ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
d375 1
a375 1
                WRITE(NOUT,*) '*** ERROR REOPENING FILE: ',FILNM(1:NLET)
@


1.41
log
@HRI GPL License used
@
text
@a15 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d19 1
a19 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a38 6

C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.40
log
@mpi
@
text
@d17 24
@


1.39
log
@IRTFLG input removed
@
text
@d88 9
a96 1

d132 15
d148 1
d167 11
a177 1

d180 1
d199 12
d214 1
d270 9
d281 1
d285 21
a305 1

d308 1
d317 12
d332 1
d398 12
a409 1

d413 1
@


1.38
log
@iflip removed
@
text
@d13 1
d50 2
a51 4
C        IRTFLG     ERROR RETURN FLAG.                   (SENT/RETURNED)
C                   ON INPUT: 
C                     9 : KEEPS INCOMING EXTENSION
C                   ON OUTPUT: 
d76 1
a76 1
     &                     ITYPE,DISP,IRTFLG)
d87 1
a87 1
	LOGICAL  ::               EX,NEWDAT,CALLERRT,OPENED,KEEPEXT
a90 5
C       TO KEEP OLD DATE
        NEWDAT  = (IRTFLG .GE. 0) 
C       TO KEEP EXTENSION
        KEEPEXT =  (IRTFLG .EQ. 9)
        
@


1.37
log
@endedness
@
text
@d288 1
a288 2
            IFLIP = 1
            CALL LUNSETFLIP(LUN,IFLIP,IRTFLG)
@


1.36
log
@opfilec
@
text
@d12 1
d53 3
a55 2
C                     0 NORMAL RETURN
C                     1 ERROR RETURN
d71 1
a71 1
C    CALL TREE:  SEE OPFIL
a203 1
C         --------------------------------------------------------- OLD
d249 1
a249 2
                   WRITE(NOUT,*) 
     &                  '*** ERROR OPENING FILE: ',FILNM(1:NLET)
d280 29
d344 2
a345 1
           CALL LUNSETIMGOFF(LUN,1,NSAM,IRTFLGT)
@


1.35
log
@stack bug
@
text
@d11 1
d22 1
a22 1
C    OPENFIL(FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,DISP,IRTFLG)
d32 1
d74 1
a74 1
	SUBROUTINE OPENFIL(FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,
d142 1
a142 1
C         USER WANTS A NEW FILE TO WRITE INTO ----------------------NEW
d159 1
a159 1
          CALL LUNSETHDR(LUN,NSAM,NROW,NSLICE,ITYPE,NSTACK,IRTFLGT)
@


1.34
log
@indexed stacks
@
text
@d181 4
@


1.33
log
@can keep extension
@
text
@d10 1
d13 6
a18 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK        *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND     *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.  *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS *
C *    OR USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN        *
C *    APPROVAL OF THE CENTER FOR LABORATORIES AND RESEARCH            *
d21 1
a21 1
C    OPENFIL(FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,IMUSED,DISP,IRTFLG)
d36 8
a43 4
C                   ON INPUT FOR NEW FILE -2 IS NOT A STACK, 0 IS A
C                   STACK, ON OUTPUT RETURNS -2 IF NOT A STACK,  
C                   OR MAX. NUMBER OF IMAGE IN STACK. 
C        IMUSED     USED IMAGE STACK INDICATOR                (RETURNED)
d47 5
a51 3
C                     9 ON INPUT: KEEPS INCOMING EXTENSION
C                     0 ON OUTPUT NORMAL RETURN
C                     1 ON OUTPUT ERROR RETURN
d67 2
d73 1
a73 1
     &                     ITYPE,IMUSED,DISP,IRTFLG)
d81 1
a81 1
        CHARACTER(LEN=*) ::      FILNAM
d92 1
a92 1

d157 2
a158 3
          ISTACK = 0
          IF (NSTACK .NE. -2) ISTACK = 2
          CALL LUNSETHDR(LUN,NSAM,NROW,NSLICE,ITYPE,ISTACK,IRTFLGT)
a161 3
C         PUT IMAGE NUMBER IN HEADER OBJECT (THIS IS OVERALL HEADER) 
          CALL LUNSETIMGNUM(LUN,0,IRTFLGT)

d175 3
d181 3
a183 2
             CALL LUNGETLAB(LUN,LABREC,NRECS,LABBYT,LENBYT,IRTFLGT)
             NWORDS   = NRECS * LENBYT / 4
d191 1
a191 1
          CALL LUNWRTHED(LUN,0,IRTFLGT)
d250 2
a251 2
C         READ HEADER FROM FILE            	       
          CALL LUNREDHED(LUN,256,.TRUE.,IRTFLGT)
d258 1
a258 1
          CALL LUNGETTYPE(LUN,ITYPE,ISTACK,IRTFLGT)
d271 1
a271 1
          CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,ISTACK,IRTFLGT)
d297 14
a310 5
C       PUT IMAGE NUMBER IN HEADER OBJECT (THIS IS OVERALL HEADER) 
        CALL LUNSETIMGNUM(LUN,0,IRTFLGT)

C       SET FINAL LUNARA OFFSET VALUE FOR USE BY REDLIN/WRTLIN
        CALL LUNSETOFFSET(LUN,IRTFLGT)
d318 3
a320 4
C       NEED TO RETURN NSTACK & IMUSED & MAXIM 
        CALL LUNGETSTK(LUN,ISTACK,IMUSED,MAXIM,IRTFLGT)
        IF (ISTACK .GT. 0) THEN
C          IS A STACK FILE, RETURN MAX. NO. OF USED IMAGES IN NSTACK
@


1.32
log
@virtual lun
@
text
@d42 4
a45 3
C        IRTFLG     ERROR RETURN FLAG.                        (RETURNED)
C                   IRTFLG = 0    FOR NORMAL RETURN
C                   IRTFLG = 1    FOR ERROR RETURN
d67 1
d73 4
a76 4
        CHARACTER *(*)  FILNAM
        CHARACTER * 81  FILNM,FILOP
        CHARACTER * 1   NULL,DISP
	LOGICAL         EX,NEWDAT,CALLERRT,OPENED
d81 3
a83 2
        NEWDAT = .TRUE.
        IF (IRTFLG .LT. 0) NEWDAT = .FALSE.
d109 7
a115 2
           CALL FILNAMANDEXT(FILNAM,DATEXC,FILNM,NLET,.TRUE.,IRTFLGT)
	   IF (IRTFLGT .NE.0) RETURN
@


1.31
log
@added (1:NLET) after FILNM (??)
@
text
@d69 2
d72 1
a72 1
        CHARACTER * 81  FILNM
d74 1
a74 1
	LOGICAL         EX,NEWDAT,CALLERRT
d118 3
d209 22
a230 3
                WRITE(NOUT,*) '*** ERROR OPENING FILE: ',FILNM(1:NLET)
                CALL ERRT(100,'OPENFIL',NE)
                RETURN
@


1.30
log
@set fmin... to avoid flt pt error on dec
@
text
@d108 1
a108 1
	   INQUIRE(FILE=FILNM,IOSTAT=IER,EXIST=EX)
d125 1
a125 1
            OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD')
d149 2
a150 1
	     OPEN(LUN,FILE=FILNM,STATUS='NEW',FORM='UNFORMATTED',
d200 1
a200 1
             OPEN(LUN,FILE=FILNM,STATUS='OLD',ACCESS='DIRECT',
d239 2
a240 1
	     OPEN(LUN,FILE=FILNM,STATUS='OLD',FORM='UNFORMATTED',
@


1.29
log
@*** empty log message ***
@
text
@d139 2
@


1.28
log
@should have used irtflgt
@
text
@a73 2
	DATA NSAMAX/17008/

@


1.27
log
@USE INLN_INFO ALTERED
@
text
@d104 1
a104 1
           CALL CLOSEINLN(LUN,IRTFLG)
d160 1
a160 1
             CALL LUNGETLAB(LUN,LABREC,NRECS,LABBYT,LENBYT,IRTFLG)
@


1.26
log
@removed USEINLN
@
text
@a65 19
CNO_SAVE

#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------
C       USE INLINE BUFFER COMMON AREA
        USE INLN_INFO
C     ----------- F90 SPECIFIC CODE ENDS ---------------------
#else
C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------
#if defined(SP_SUN4) || defined(SP_NT)
        INTEGER * 4     LOCLUN
#else
        INTEGER * 8     LOCLUN
#endif
        COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)
C     ----------- F77 SPECIFIC CODE ENDS ---------------------
#endif


d103 13
a115 20
#ifdef SP_F90
C     ----------- F90 SPECIFIC CODE FOLLOWS ------------------
           NULLIFY(LOCLUN(LUN)%IPT)
C     ----------- F90 SPECIFIC CODE ENDS ---------------------
#else
C     ----------- F77 SPECIFIC CODE FOLLOWS ------------------
           LOCLUN(LUN) = 0
C     ----------- F77 SPECIFIC CODE ENDS ---------------------
#endif

          CALL FILNAMANDEXT(FILNAM,DATEXC,FILNM,NLET,.TRUE.,IRTFLGT)
	  IF (IRTFLGT .NE.0) RETURN

C         SEE IF FILE EXISTS NOW
	  INQUIRE(FILE=FILNM,IOSTAT=IER,EXIST=EX)
          IF (IER .NE. 0) THEN
             WRITE(NOUT,*) '*** FILE INQUIRY ERROR: ',FILNM(1:NLET)
             CALL ERRT(100,'OPENFIL',NE)
             RETURN
          ENDIF
@


1.25
log
@lunsethdr used
@
text
@d80 1
a80 2
        LOGICAL         USEINLN
        COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
d106 1
a106 1
        IF (USEINLN .AND. FILNAM(1:1) .EQ. '_') THEN
@


1.24
log
@removed VMS specific stuff
@
text
@d4 7
a10 5
C OPENFIL.FOR  -- ADAPTED FROM OPEN3.FOR               OCT 88 al
C                 LONG FILENAMES                       OCT 88 al
C                 MERGED WITH OPENF                    AUG 96 al
C                 -1, -3 & -7 FOURIER FORMATS REMOVED  AUG 96 al
C                 F90 CHANGES                          APR 98 al
d21 1
a21 1
C    OPENFIL(BUF,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,IMUSED,DISP,NF)
d24 2
a25 1
C                   ACCESS READING/WRITING.  THIS ROUTINE IS NOT
d28 1
a28 1
C                   IS IT USED FOR INLINE STACKS!
a30 1
C        BUF        WORKING BUFFER FOR READ/WRITE                 (SENT)
d42 3
a44 3
C        NF         ERROR RETURN FLAG.                        (RETURNED)
C                   NF = 2    FOR NORMAL RETURN
C                   NF = 1    FOR ERROR RETURN
d51 1
a51 1
C    VARIABLES: IFORM (TYPE)  FILE TYPE SPECIFIER. 
d63 2
a64 2
	SUBROUTINE OPENFIL(BUF,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,
     &                     IMUSED,DISP,NF)
d85 1
a88 5
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
        COMMON /IOERR/  IERR

        DIMENSION       BUF(*)
        
d91 2
a92 2
        CHARACTER * 1   NULL,DISP,DSP
	LOGICAL         EX,NEWDAT,NEEDERRT
d94 1
a94 1
	DATA NSAMAX/16384/
d100 1
a100 1
        IF (NF .LT. 0) NEWDAT = .FALSE.
d103 1
a103 2
        NF     = 1
        IERR   = 0
a104 6
        IF (LUN .LE. 0 .OR. LUN .GT. 100) THEN
           WRITE(NOUT,*)
     &         '*** PGM. ERROR: LUN MUST BE 1...100, SET TO 99'
           LUN = 99
        ENDIF

d108 2
a109 2
           CALL INLNBUF(FILNAM,NLET,INLNED,IRTFLG)
           IF (IRTFLG .NE. 0)  RETURN
d133 2
a134 9
           IF (DATEXC .EQ. NULL) THEN
              FILNM = FILNAM
           ELSE
              CALL FILCAN(FILNM,NLET,NULL,NULL,FILNAM,DATEXC,IER)
	      IF (IER .NE.0) THEN
                 CALL ERRT(100,'OPENFIL',NE)
                 RETURN
              ENDIF
          ENDIF
d145 1
d164 4
a167 21
	  IF (NSAM .EQ. 0 .OR. NROW .EQ. 0) THEN
C           FOR NEW FILES, NON-ZERO NSAM, NROW NEED TO BE SUPPLIED
2060	    WRITE(NOUT,*) '*** RECORD INFO MISSING: ',FILNM(1:NLET)
            CALL ERRT(100,'OPENFIL',NE)
            RETURN

          ELSEIF (NSAM .GT. NSAMAX) THEN
C           EXCESSIVE ROW LENGTH 
            WRITE(NOUT,*) '*** ROWLENGTH MUST BE <=:',NSAMAX
            CALL ERRT(100,'OPENFIL',NE)
            RETURN

          ELSEIF (NSLICE .EQ. 0) THEN
C           NEW FILES NEED A NON ZERO SLICE NUMBER FOR FILE FORMAT FLAG
            NSLICE = 1

          ELSEIF (NSLICE .LT. 0) THEN
C           WANT TO CREATE OBSOLETE SHORT HEADER FILE
            WRITE(NOUT,*) 'WARNING:  NO SHORT HEADER FILES ON UNIX.'
            NSLICE = -NSLICE
          ENDIF
d169 2
a170 6
          IF (IFORM .EQ. -1 .OR. IFORM .EQ. -3 .OR. IFORM .EQ. -7) THEN
C           WANT TO CREATE OBSOLETE FOURIER FILE
            CALL ERRT(101,
     &         'CAN NOT CREATE OBSOLETE FOURIER FORMAT FILE',NE)
            RETURN
          ENDIF
d172 2
a173 11
          DSP = 'N'

C         ADJUST NUMBER OF HEADER RECORDS TO HAVE >=256*4 BYTES IN HEADER

C         STANDARD SPIDER FLOATING POINT FILES
          LENBYT = NSAM * 4
          LABREC = 1024 / LENBYT
          IF (MOD(1024,LENBYT) .NE. 0) LABREC = LABREC + 1
          LABBYT = LABREC * LENBYT

          IREC = NROW * NSLICE + LABREC
d175 1
a175 9
	  IF (INLNED .EQ. 0) THEN
C	     REGULAR FILE
#ifdef __osf__
C            RECL IS IN UNITS OF FLOATS ON OSF 
             LENREC = NSAM
#else
C            RECL IS IN UNITS OF BYTES ON SGI AND SUN
             LENREC = NSAM * 4
#endif
d186 4
a189 2
             NWORDS   = IREC * LENBYT / 4
             NEEDERRT = .TRUE.
d191 2
a192 2
     &                     NEEDERRT,IRTFLG)
             IF (IRTFLG .NE. 0)  RETURN
d195 2
a196 68
          BUF(1) = NSLICE
          BUF(2) = NROW
          BUF(3) = IREC
C         BUF(4) USED TO CONTAIN NHISTREC
          BUF(4) = 0
          BUF(5) = IFORM
          IMAMI  = 0
          BUF(6) = IMAMI
          
          DO K= 6,212
C            ZERO UNUSED BUF VARIABLES
             BUF(K)=0
          ENDDO

          BUF(12) = NSAM
          BUF(13) = LABREC
          BUF(22) = LABBYT 
          BUF(23) = LENBYT
C         BUF(24) IS A STACK INDICATOR
          IF (NSTACK .NE. -2) THEN
C            NEW IMAGE IS BARE STACK OR STACKED IMAGE
C            SET BUF(24) > 0 FOR STACK 
             BUF(24) = 2
          ELSE
C            NOT A STACK
             BUF(24) = 0
          ENDIF
C         SET USED IMAGE INDICATOR  (BUF(25)) TO FLAG FOR GOOD STACK
          BUF(25) = -1.0
          BUF(26) = 0

C         ADDED JULY 88 al
          IF (IANGLE .NE. 0) THEN
             BUF(14) = IANGLE
             BUF(15) = PHI
             BUF(16) = THETA
             BUF(17) = PSI
          ENDIF

          IF (KANGLE .NE.0) THEN
             BUF(30) = KANGLE
             BUF(31) = PHI2
             BUF(32) = THETA2
             BUF(33) = PSI2
             BUF(34) = PHI1
             BUF(35) = THETA1
             BUF(36) = PSI1
          ENDIF

C         COPY MOST RECENT HDR_VALS INTO LOCATIONS 37..101
          DO I = 1,64
             BUF(36+I) = HDR_VALS(I)
          ENDDO

C         SET CURRENT DATE AND TIME & TITLE
          CALL DATTIMTIT(BUF,.FALSE.,NEWDAT,LENTIT,IRTFLG)

C         WRITE HEADER RECORDS INTO FILE	    
          LUNARA(LUN) = 0

          ILOC = 1
          DO I = 1,LABREC
             CALL WRTLIN(LUN,BUF(ILOC),NSAM,I)
             ILOC = ILOC + NSAM
          ENDDO

C         SET FINAL LUNARA OFFSET VALUE FOR USE BY REDLIN/WRTLIN
          LUNARA(LUN) = LABREC
d214 1
a214 4
             IF (DISP .EQ. 'Z' .AND. 
     $          (IPROC .NE. 0 .OR. COPT  .EQ. 'B')) RETURN
     
             CALL ERRT(100,'OPENFIL',NE)
d220 2
a221 3
             NEEDERRT = DISP(1:1) .NE. 'Z'
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,0,NEEDERRT,IRTFLG)
             IF (IRTFLG .NE. 0)  RETURN
d225 3
a228 9
#if defined(__osf__) || defined(osf_ieee)
C            REGULAR FILE ACCESS, RECL IS IN 4 BYTE WORDS
             OPEN(LUN,FILE=FILNM,STATUS='OLD',ACCESS='DIRECT',
     &           FORM='UNFORMATTED',RECL=256,IOSTAT=IER)
#else
C            REGULAR FILE ACCESS, RECL IS IN BYTES
             OPEN(LUN,FILE=FILNM,STATUS='OLD',ACCESS='DIRECT',
     &           FORM='UNFORMATTED',RECL=1024,IOSTAT=IER)
#endif
d237 2
a238 6
          LUNARA(LUN) = 0
          IERR        = 0

C         ALL OF USED HEADER CAN BE READ IN ON UNIX IN ONE READ
          CALL REDLIN(LUN,BUF,256,1)
          IF (IERR .NE. 0) THEN
a239 1
             CALL ERRT(100,'OPENFIL',NE)
d243 2
a244 2
          CALL OPENGETHDR(BUF,IDUM,NROW,NSLICE,NSTACK,IFORM,
     &                    IDUM,IDUM,LABBYT,LENBYT,IMUSED,LENTIT)
d246 1
a246 1
          IF (IFORM .EQ. -1 .OR. IFORM .EQ. -3 .OR. IFORM .EQ. -7) THEN
d253 1
a253 1
            IF (DISP .NE. 'E') RETURN
d256 3
a258 12
C         ON UNIX MUST GET NSAM FROM HEADER LOCATION 12
          NSAM   = BUF(12)
          IF (LENBYT .LE. 0) LENBYT = NSAM * 4
          LABREC = BUF(13)

C         CORRECT UNREASONABLE LABREC (BAD VALUE ONCE)        
          LABRECT = 1024 / LENBYT
          IF (MOD(1024,LENBYT) .NE. 0) LABRECT = LABRECT + 1
          IF (LABRECT .LE. 0 .OR. LABREC .NE. LABRECT) THEN
C             UNREASONABLE LABREC NUMBER SO DEFAULT IT
              LABREC = LABRECT
          ENDIF
d263 2
a264 10
#ifdef __osf__
C            ALPHA OSF (UNIX) SPECIFIC STATEMENTS FOLLOW
C            RECL IS IN UNITS OF FLOATS ON OSF
             LENREC = NSAM 
	     OPEN(LUN,FILE=FILNM,STATUS='OLD',FORM='UNFORMATTED',
     &             ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
#else
C            NON ALPHA OSF (UNIX) SPECIFIC STATEMENTS FOLLOW
C            RECL IS IN UNITS OF BYTES 
             LENREC = NSAM * 4
a266 1
#endif
a273 5
C         SET HEADER RECORD OFFSET IN LUNARA
          LUNARA(LUN) = LABREC

          DSP = 'O'

d281 22
a302 4
C       WRITE OUT FILE OPENING INFO, SET IMGNUM TO OVERALL FILE
        IMGNUM = 0
        CALL OPENINFO(FILNAM,NLET,NSAM,NROW,NSLICE,IMGNUM,NSTACK,
     &                LENTIT,DSP,LABBYT,IRTFLG)
d305 1
a305 1
        NF = 2
@


1.23
log
@added paremeter to opengethdr call
@
text
@a152 5
#ifdef SP_VMS
	  INQUIRE(FILE=FILNM,IOSTAT=IER,EXIST=EX,RECL=NSAMO)
C         RECL RETURNED IS IN BYTES ON VAX/VMS
          NSAMO = NSAMO / 4
#else
a153 1
#endif
a168 4
#ifdef SP_VMS
            OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',DISPOSE='DELETE')
            CLOSE(UNIT=LUN,DISPOSE='DELETE',IOSTAT=IER)
#else
d171 1
a171 1
#endif
a196 5
#ifdef SP_VMS
            CALL ERRT(100,
     &         'CAN NO LONGER CREATE OBSOLETE SHORT HEADER FILE',NE)
            RETURN
#else
a198 1
#endif
a221 18
#ifdef SP_VMS
             CLOSE (LUN)
             NBLOCK = FLOAT(NSAM) / 512.0 * FLOAT(IREC) + 1.0

C            RECL IS IN UNITS OF FLOATS ON VAX
             LENREC = NSAM
	     OPEN(UNIT=LUN,FILE=FILNM,STATUS='NEW',RECORDTYPE='FIXED',
     &          ACCESS='DIRECT',FORM='UNFORMATTED',
     &          BLOCKSIZE=16384,BUFFERCOUNT=4, 
     &          RECL=LENREC,INITIALSIZE=NBLOCK,
     &          IOSTAT=IER)

C            ACTIVATE FOLLOWING LINE IF YOU NEED MORE INFO ON OPEN
C            ERROR. THE CALL TO LIB$SIGNAL STOPS THE PROGRAM AND 
C            PRINTS AN INFORMATIVE ERROR MESSAGE.
C            IF (IER .NE. 0) CALL LIB$SIGNAL(%VAL(IER))

#else
a224 2
	     OPEN(LUN,FILE=FILNM,STATUS='NEW',FORM='UNFORMATTED',
     &            ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
d228 1
a230 2
#endif
#endif
a245 3
#ifdef SP_VMS
          BUF(1) = -NSLICE
#else
a246 1
#endif
a345 8
#ifdef SP_VMS
C            NSAM IS GOTTEN FROM INQUIRY ON VAX
             NSAM = NSAMO

C            OPEN FOR READ / WRITE
             OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',
     &              RECORDTYPE='FIXED', ACCESS='DIRECT', IOSTAT=IER)
C            IF (IER .NE. 0) CALL LIB$SIGNAL(%VAL(IER))
a346 6
             IF (IER .NE. 0) THEN         
                WRITE(NOUT,*) '*** ERROR OPENING FILE: ',FILNM(1:NLET)
                CALL ERRT(100,'OPENFIL',NE)
                RETURN
             ENDIF
#else
a360 1
#endif
a366 21
#ifdef SP_VMS
C         FIND NUMBER OF RECORDS IN HEADER
          LABREC = 256 / NSAM
          IF (MOD(256,NSAM) .NE. 0) LABREC = LABREC + 1

C         READ IN HEADER
          ILOC = 1
          DO I = 1,LABREC
             CALL REDLIN(LUN,BUF(ILOC),NSAM,I)
             ILOC = ILOC + NSAM
          ENDDO

          IF (BUF(1) .GT. 0) THEN
C            A POSITIVE VALUE FOR NSLICE ON VAX IS FLAG FOR OLD
C            OBSOLETE SHORT HEADER FORMAT
             WRITE(NOUT,*) 
     &           'WARNING, THIS MAY BE OBSOLETE SHORT HEADER FILE'
             WRITE(NOUT,*) 'USE "COPYFROM SHORT" TO CONVERT.'
             CALL ERRT(100,'OPENFIL',NE)
          ENDIF
#else
d374 1
a374 1
#endif
a387 6
#ifdef SP_VMS
C         CHECK TO SEE IF IREC IS REASONABLE
          IRECMIN = NROW * NSLICE + LABREC
          IF (IREC .LT. IRECMIN) IREC = IRECMIN
          IF (LENBYT .LE. 0) LENBYT = NSAM * 4
#else
a422 1
#endif
@


1.22
log
@f90 changes
@
text
@d453 1
a453 1
     &                    IDUM,LABBYT,LENBYT,IMUSED,LENTIT)
@


1.21
log
@comment
@
text
@d4 3
a6 3
C OPENFIL.FOR  -- ADAPTED FROM OPEN3.FOR OCT 88 al
C                 LONG FILENAMES         OCT 88 al
C                 MERGED WITH OPENF      AUG 96 al
d8 1
a8 1
C
a63 2
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'LABLOCK.INC'
d66 5
a70 4
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100)

#ifdef SP_SUN4 
        INTEGER * 4     LOCLUN
d72 2
a73 2
#ifdef SP_ALLOC
#ifdef SP_NT
d78 3
d82 3
a84 1
#endif
d86 1
a86 2
        LOGICAL         USEINLN
        COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
d131 7
d139 2
@


1.20
log
@used 4 byte pointers on nt
@
text
@d293 1
a293 1
C         BUF(25) IS A STACK INDICATOR
@


1.19
log
@comment wrong
@
text
@d74 3
d78 1
@


1.18
log
@used opengethdr
@
text
@d39 1
a39 1
C                   SEE OPEFB FOR POSSIBLE VALUES            
@


1.17
log
@for nstack retrieval of max img. number
@
text
@d19 1
a19 1
C    OPENFIL(BUF,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,NUSED,DISP,NF)
d37 1
a37 1
C        NUSED      USED IMAGE STACK INDICATOR                (RETURNED)
d62 1
a62 1
     &                     NUSED,DISP,NF)
a86 1
        INTEGER         LABREC,LABBYT
d436 2
a438 6
          NSLICE   = ABS(BUF(1)) + 0.5
          NROW     = BUF(2) + 0.5
          IREC     = BUF(3) + 0.5
          IFORM    = BUF(5)
          IF (BUF(5) .LT. 0.0) IFORM = BUF(5) - 0.5

a448 4
          IF (IABS(IFORM) .EQ. 1) NSLICE = 1
          LABBYT = BUF(22)
          LENBYT = BUF(23)

d464 2
a465 28
C            UNREASONABLE LABREC NUMBER SO DEFAULT IT
             LABREC = LABRECT
          ENDIF
#endif

C         BUF(4) USED TO CONTAIN NHISTREC
          NHISTREC = 0
          IMAMI    = BUF(6) + 0.5
          FMAX     = BUF(7)
          FMIN     = BUF(8)
          AV       = BUF(9)
          SIG      = BUF(10)
C         IHIST NO LONGER USED
          IHIST    = 0
          IANGLE   = BUF(14)+ 0.5
          PHI      = BUF(15)
          THETA    = BUF(16)
          PSI      = BUF(17)
          XOFF     = BUF(18)
          YOFF     = BUF(19)
          ZOFF     = BUF(20)
          SCALE    = BUF(21)
          IF (BUF(24) .GT. 0) THEN
C            IS A STACK FILE, RETURN MAX. NO. OF USED IMAGES IN NSTACK
             NSTACK   = BUF(26)
          ELSE
C            NOT A STACK, RETURN -2
             NSTACK   = -2
a466 16
          NUSED    = BUF(25)

          KANGLE   = BUF(30)+ 0.5
          PHI2     = BUF(31)
          THETA2   = BUF(32)
          PSI2     = BUF(33)
          PHI1     = BUF(34)
          THETA1   = BUF(35)
          PSI1     = BUF(36)

          DO I = 1,64
             HDR_VALS(I) = BUF(36+I)
          ENDDO

C         GET  DATE, TIME, & TITLE
          CALL DATTIMTIT(BUF,.TRUE.,.FALSE.,LENTIT,IRTFLG)
a467 1
#ifndef SP_VMS
@


1.16
log
@returns imused and nstack now
@
text
@d22 4
a25 1
C                   ACCESS READING/WRITING.
d28 4
a31 5
C        BUF        WORKING BUFFER FOR READ/WRITE            (SENT)
C        FILNAM     CHARACTER ARRAY, CONTAINING FILE NAME    (SENT)
C        LUN        LOGICAL UNIT NUMBER FOR FILNAM.          (SENT)
C        NSAM,NROW  DIMENSIONS OF FILE - INPUT OR OUTPUT PARAMETERS
C                       OF OPEN, DEPENDING ON DISP.
d33 10
a42 4
C        NSTACK     STACK INDICATOR                   (SENT OR RETURNED)
C        NUSED      USED IMAGE STACK INDICATOR        ( RETURNED)
C        DISP       CHARACTER  CONTAINING ONE OF THE FOLLOWING (SENT)
C                   DISPOSITION SPECIFICATIONS:
a43 25
C                   'O'    -    FILE IS ASSUMED TO EXIST.  NSAM AND
C                               NROW AND HEADER INFO (IN COMMON) ARE 
C                               RETURNED TO THE CALLING PROGRAM. 
C                   'Z'    -    THE FILE IS ASSUMED TO EXIST; NSAM AND
C                               NROW AND HEADER INFO (IN COMMON) ARE 
C                               RETURNED TO THE CALLING PROGRAM.
C                               IF FILE DOES NOT EXIST THEN BATCH DOES
C                               NOT STOP!!! (ONLY DIFFERENCE FROM 'O'). 
C                   'E'    -    THE FILE IS ASSUMED TO EXIST; NSAM AND
C                               NROW AND HEADER INFO (IN COMMON) ARE 
C                               RETURNED TO THE CALLING PROGRAM.
C                               DO NOT STOP IF HEADER OPENING ERROR
C                               (ONLY DIFFERENCE FROM 'O'). 
C                   'N'    -    WANT NEW FILE. NSAM, NROW, NSLICE, AND
C                               IFORM ARE NEEDED.
C                   'U'    -    IT IS NOT KNOWN IF THE FILE EXISTS.  
C                               IF THE FILE EXISTS, IT WILL BE REPLACED.
C                               NSAM, NROW, NSLICE, AND IFORM VALUES 
C                               ARE NEEDED. 
C                   'K & M'-    NO LONGER USED.
C
C        NF                     ERROR RETURN FLAG.       (RETURNED)
C                               NF = 2    NORMAL RETURN
C                               NF = 1    ERROR RETURN
C
a85 1
        CHARACTER * 2   TYPE
d290 9
a298 1
          BUF(24) = NSTACK
d301 1
d495 7
a501 1
          NSTACK   = BUF(24)
d555 5
a559 57
2000	IF (IFORM .EQ. -2) THEN
            TYPE = 'P '
        ELSEIF (IFORM .EQ. -9) THEN
            TYPE = 'FS'
        ELSEIF (IFORM .EQ. -11) THEN
            TYPE = 'O2'
        ELSEIF (IFORM .EQ. -12) THEN
            TYPE = 'E2'
        ELSEIF (IFORM .EQ. -21) THEN
            TYPE = 'O3'
        ELSEIF (IFORM .EQ. -22) THEN
            TYPE = 'E3'
	ELSEIF (IFORM .EQ. 0)  THEN
            TYPE = 'D '
        ELSEIF (NSTACK .EQ. 3)  THEN
            TYPE = 'S3'
        ELSEIF (NSTACK .EQ. 2)  THEN
            TYPE = 'S2'
        ELSEIF (IFORM .EQ. 3)  THEN
            TYPE = 'R3'
        ELSE
            TYPE = 'R '
        ENDIF

	IF (N_VERBOSE .EQ. 1 .AND. IFOUND .NE. -4) THEN
C         PRINT FILE OPENING INFORMATION
          IF (LENTIT .LE. 0) THEN
             WRITE(NOUT,*) FILNM(:NLET)
          ELSEIF (LENTIT + NLET .LT. 70) THEN
             WRITE(NOUT,*) FILNM(:NLET),'     /',CTIT(:LENTIT)
          ELSE
             WRITE(NOUT,*) FILNM(:NLET)
             LENT = MIN(80,LENTIT)
             WRITE(NOUT,*) CTIT(1:LENT)
             IF (LENTIT .GT. 80)  WRITE(NOUT,*) CTIT(81:LENTIT)
          ENDIF

          IF (NSLICE .GT. 1) THEN
             WRITE(NOUT,2098) TYPE,NSAM,NROW,NSLICE,CDAT,CTIM,DSP,
     &                        LABBYT
2098	     FORMAT(' (',A,')',3I5,' CREATED ',A,' AT ',A,2X,A,
     &             ' HEADER BYTES:',I5)

          ELSE
             WRITE(NOUT,2099)TYPE,NSAM,NROW,CDAT,CTIM,DSP,LABBYT
2099         FORMAT(' (',A,')',2I5,' CREATED ',A,' AT ',A,2X,A,
     &             ' HEADER BYTES:',I5)
          ENDIF
        ENDIF

        PARAM(2) = NSAM
	PARAM(3) = NROW
	PARAM(4) = FMAX
	PARAM(5) = FMIN
	PARAM(6) = AV
	PARAM(7) = SIG
	PARAM(8) = NSLICE
@


1.15
log
@nstack changed
@
text
@d19 1
a19 1
C    OPENFIL(BUF,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,DISP,NF)
d25 3
a27 3
C        BUF        WORKING BUFFER FOR READ/WRITE
C        FILNAM     CHARACTER ARRAY, CONTAINING FILE NAME 
C        LUN        LOGICAL UNIT NUMBER TO BE ASSIGNED TO FILNAM.
d30 1
a30 1
C        NSLICE     NUMBER OF SLICES IN IMAGE 
d32 2
a33 1
C        DISP       CHARACTER  CONTAINING ONE OF THE FOLLOWING 
d57 1
a57 1
C        NF                     ERROR RETURN FLAG.
a60 6
C        NSLICE                 NUMBER OF PLANES, EACH CONTAINING 
C                               NSAM * NROW ELEMENTS. IF NSLICE IS <0 
C                               (ON VMS VERSION) A SHORT HEADER 
C                               FORMAT FILE WAS DESIRED (NO LONGER 
C                               SUPPORTED).
C
d79 1
a79 1
     &                     DISP,NF)
d99 1
a99 1
        DIMENSION      BUF(*)
d101 6
a106 6
        CHARACTER *(*) FILNAM
        CHARACTER * 81 FILNM
        CHARACTER * 2  TYPE
        CHARACTER * 1  NULL,DISP,DSP
        INTEGER        LABREC,LABBYT
	LOGICAL        EX,NEWDAT,NEEDERRT
@


1.14
log
@type output msg. changed
@
text
@d30 2
d577 1
a577 1
        ELSEIF (IFORM .EQ. 3 .AND. NSTACK .EQ. 3)  THEN
d579 1
a579 1
        ELSEIF (IFORM .EQ. 1 .AND. NSTACK .EQ. 2)  THEN
@


1.13
log
@correct the stack structure
@
text
@d70 2
a71 9
C                0     D    DATA FILE (UNUSED?)
C               +1     R    2-D IMAGE
C               +3     R3   3-D FILE
C               +4     S    STACKED FILE
C               +R     SE   STACKED IMAGE
C               +8     8    8 BIT BLACK AND WHITE FILE (UNUSED)
C               +11    C    8 BIT COLOR FILE (UNUSED)
C               +12   -     8 BIT RUNLENGTH BLACK AND WHITE FILE (UNUSED?)
C               +16   16    16 BIT BLACK AND WHITE FILE (UNUSED)
d312 2
a313 2
C         SET USED IMAGE INDICATOR  (BUF(25)) TO IN-USE
          BUF(25) = 1.0
a508 6
          IF (NSTACK .GT. 1 .AND. NUSED .EQ. 0) THEN
C            THIS IMAGE IS NO LONGER IN USE
             WRITE(NOUT,*)'*** THIS IMAGE FROM STACK NO LONGER IN USE'
             CALL ERRT(100,'OPENFIL',NE)
             IF (DISP .NE. 'E') RETURN
          ENDIF
d575 4
a580 2
        ELSEIF (IFORM .EQ. 4)  THEN
            TYPE = 'S'
@


1.12
log
@f90
@
text
@d590 2
@


1.11
log
@added neederrt parameter to openinln call
@
text
@a117 1
        DATA NULL /0/
d119 2
@


1.10
log
@res openfb openfil openinstk
removed readonly
@
text
@d116 1
a116 1
	LOGICAL        EX,NEWDAT
d288 4
a291 2
             NWORDS = IREC * LENBYT / 4
             CALL OPENINLN(LUN,INLNED,.TRUE.,NSAM,NWORDS,IRTFLG)
d384 2
a385 1
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,0,IRTFLG)
@


1.9
log
@altered disp=z handling
@
text
@a35 4
C                   'R'    -    THE FILE IS ASSUMED TO EXIST; NSAM AND
C                               NROW AND HEADER INFO (IN COMMON) ARE 
C                               RETURNED TO THE CALLING PROGRAM.
C                               FILE IS OPENED AS READONLY. 
d363 1
a363 1
     &          DISP .EQ. 'Z' .OR. DISP .EQ. 'R' .OR.
d390 3
a392 3
             IF (DISP .EQ. 'O')  THEN
C               OPEN FOR READ / WRITE
                OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',
d394 1
a394 1
C               IF (IER .NE. 0) CALL LIB$SIGNAL(%VAL(IER))
a395 6
             ELSEIF (DISP .EQ. 'R')  THEN
C               READ-ONLY
                OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',
     &               RECORDTYPE='FIXED', READONLY,ACCESS='DIRECT',
     &               IOSTAT=IER)
             ENDIF
@


1.8
log
@added 256 recl on open for osf
@
text
@d135 1
a135 1
     &     '*** PGM. ERROR: LUN MUST BE 1...100, SET TO 99'
d146 1
a146 1
	     EX = .FALSE.
d148 1
a148 1
	     EX = .TRUE.
d163 1
a163 1
                 CALL ERRT(100,'OPENFB',NE)
d178 1
a178 1
             CALL ERRT(100,'OPENFB',NE)
a182 13
	IF (.NOT. EX .AND. (DISP .EQ. 'O' .OR. DISP .EQ. 'M' .OR.
     &                      DISP .EQ. 'Z' .OR. DISP .EQ. 'K' .OR.
     &                      DISP .EQ. 'E')) THEN
C          ERROR -- FILE DOES NOT EXIST, BUT IS BEING OPENED WITH 'OLD'
           WRITE(NOUT,*) '*** NOT FOUND: ',FILNM(1:NLET)

C	   FOR DISP=Z, DO NOT STOP THE BATCH JOB BY CALLING ERRT
           IF (DISP .EQ. 'Z' .AND. 
     $         (IPROC .NE. 0 .OR. COPT  .EQ. 'B')) RETURN
     
           CALL ERRT(100,'OPENFB',NE)
           RETURN
        ENDIF
d200 1
a200 1
               CALL ERRT(100,'OPENFB',NE)
d208 1
a208 1
            CALL ERRT(100,'OPENFB',NE)
d214 1
a214 1
            CALL ERRT(100,'OPENFB',NE)
d286 1
a286 1
                CALL ERRT(100,'OPENFB',NE)
a345 1

d363 2
a364 2


d368 2
a369 3
     &          DISP .EQ. 'E') THEN
C         --------------------------------------------------------- OLD
C         --------------------------------------------------------- OLD
d372 12
d408 1
a408 1
                CALL ERRT(100,'OPENFB',NE)
d423 1
a423 1
                CALL ERRT(100,'OPENFB',NE)
d451 1
a451 1
             CALL ERRT(100,'OPENFB',NE)
d458 1
a458 1
             CALL ERRT(100,'OPENFB',NE)
d475 1
a475 1
             CALL ERRT(100, 'OPENFB',NE)
d525 1
a525 1
             CALL ERRT(100,'OPENFB',NE)
d563 1
a563 1
                CALL ERRT(100,'OPENFB',NE)
d575 3
a577 2
           CALL ERRT(101,'PGM. ERROR: UNKNOWN DISP FOR OPENFB',NE)
           RETURN
@


1.7
log
@changed STACK test to NSTACK of > 1
@
text
@d415 5
d423 1
@


1.6
log
@added disp = e
@
text
@d519 1
a519 1
          IF (NSTACK .GT. 0 .AND. NUSED .EQ. 0) THEN
@


1.5
log
@better comments for Z disp, UNSUSED buffer  position
@
text
@d45 5
d184 2
a185 1
     &                      DISP .EQ. 'Z' .OR. DISP .EQ. 'K')) THEN
d381 2
a382 1
     &          DISP .EQ. 'Z' .OR. DISP .EQ. 'R' ) THEN
d385 1
a385 2
C         FILE EXISTS, AND IS ACCESSED WITH 'OLD'
C         OPEN THE FILE
d473 1
a473 1
            RETURN
d523 1
a523 1
             RETURN
@


1.4
log
@added a ZOLD format so that a missing file from the serie does not stop the processin errt.f
@
text
@d39 6
a44 2
C                               FILE IS OPENED AS READONLY - MULTIREAD
C                               IS POSSIBLE. 
d183 2
a184 2
C	   for disp=Z, do not stop the batch job by calling errt
           IF(DISP .EQ. 'Z' .AND. 
d249 1
a249 1
C         ADJUST NUMBER OF HEADER RECORDS TO HAVE .=256*4 BYTES IN HEADER
d327 1
a327 1
C         SET STACKED IMAGE INDICATOR
d397 1
a397 1
             ELSEIF (DISP .EQ. 'R' .OR. DISP .EQ. 'Z')  THEN
@


1.3
log
@fixed lunara common
@
text
@d175 1
a175 1
     &                      DISP .EQ. 'K')) THEN
d178 5
d371 1
a371 1
     &          DISP .EQ. 'R' ) THEN
d393 1
a393 1
             ELSEIF (DISP .EQ. 'R')  THEN
@


1.2
log
@en
nsam used befor set on unix if lenbyt undefined in file
@
text
@d90 1
a90 1
        COMMON /LUNARA/ LUNARA(100)
@


1.1
log
@Initial revision
@
text
@d462 2
a463 3
          LENBYT   = BUF(23)
          IF (LENBYT .LE. 0) LENBYT = NSAM * 4
          LABBYT   = BUF(22)
d469 1
d473 1
@
