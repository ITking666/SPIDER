head	1.33;
access;
symbols
	pre_mrcs:1.33
	healthdept_2018:1.33
	pre_getangas:1.32
	GPL2010:1.32
	pre_GPL2010:1.31
	pre_var_equation:1.30
	pre_fftwrings:1.30
	pre_opfiles:1.30
	src:1.30
	best-code:1.30
	named-reg:1.29
	x-named-regs:1.28
	x:1.28
	v13-00:1.28
	pre_GPL:1.26
	prec_CA:1.26
	noindx:1.26
	Bproc:1.22
	oct21:1.18
	last77:1.18;
locks; strict;
comment	@c @;


1.33
date	2018.10.03.14.34.12;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.24.13.26.30;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2009.11.09.13.50.38;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.19.15.59.54;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.12.15.28.37;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.17.20.52.36;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.17.18.42.59;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2002.08.07.15.54.54;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.07.14.30.59;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.01.16.17.59;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.20.16.41.40;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.08.18.14.34;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2000.03.28.14.56.19;	author pawel;	state Exp;
branches;
next	1.20;

1.20
date	2000.01.31.15.22.43;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	99.11.10.23.10.04;	author yuchen;	state Exp;
branches;
next	1.18;

1.18
date	98.10.14.15.31.00;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	98.06.02.15.02.14;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	98.06.02.14.15.02;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	98.06.01.13.10.32;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	98.04.23.12.55.38;	author pawel;	state Exp;
branches;
next	1.13;

1.13
date	98.04.22.15.22.21;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	98.04.22.13.50.39;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	98.04.21.19.55.55;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	98.04.16.21.26.23;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	98.04.15.18.45.08;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	98.04.15.17.47.08;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	98.04.10.20.04.21;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	98.03.31.20.12.53;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	98.03.31.14.43.29;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	98.03.27.18.55.51;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	98.03.25.19.13.46;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	98.03.23.18.35.18;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.03.23.18.20.34;	author pawel;	state Exp;
branches;
next	;


desc
@@


1.33
log
@email_health_dept
@
text
@C++********************************************************************* 
C
C POLISH.F                    
C              CHANGED SOME ARRAYS FROM CHAR. TO INT FOR IBM JAN 2000 AL
C              READ(EXPR,FMTR LEAK                           AUG 2002 AL
C              SIMPLIFIED NUMBER INTERPRETATION              AUG 2002 AL
C              STACK LEVEL & LOWERCASE                       DEC 2005 AL
C              REMOVED: 'NO REGSITER VAR.......              NOV 2009 AL
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2010  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  POLISH(ILEVEL,EXPR,NLET,IPOLSH,NPOL,VAL,NVAL,IRTFLG)
C
C  PURPOSE: PARSE INFIX EXPESSION INTO POSTFIX EXPESSION
C
C  PARAMETERS:
C	ILEVEL     STACK LEVEL                                   (SENT)
C       EXPR       CHARACTER STRING CONTAINING EXPRESSION        (SENT)
C	NLET       LENGTH OF EXPR                                (SENT)
C	IPOLSH     INT ARRAY RETURNS POSTFIX EXPRESSION      (RETURNED)
C       NPOL       NO. OF ELEMENTS IN IPOLSH ARRAY           (RETURNED)
C       VAL        ARRAY STORES VALUES WHICH INDEX BY        (RETURNED)
C                        POLISH'S ELEMENTS
C       NVAL       NO. OF ELEMENTS USED IN VAL               (RETURNED)
C       IRTFLG     ERROR FLAG                                (RETURNED)
C
C FOR VAL INDEX
C ASCII(N) - ASCII(0) FOR N FROM 1 TO Z ON THE ASCII TABLE
C FOR MATH FUNCTION ARGUMENTS
C       PAD -> a       
C       SIN -> b
C       EXP -> c
C       LOG -> d
C       COS -> e
C       SQR -> f
C       LON -> g (NATURAL LOGARITHM)
C       INT -> h
C       ABS -> i
C       ATA -> j
C       ASI -> k
C       ACO -> l 
C       TAN -> m
C       RAN -> n   [0,1] uniform distribution
C       RNN -> o   (0,1) normal distribution
C       CHANGE THE SIGN -> p
C
C THE SUBROUTINE TRANSFORMS THE EXPRESSION FROM A TOKEN TO A SINGLE
C FOR EXAMPLE EXPRESSION 43+COS(6) -> 1+e(2)
C CONVERT FROM INFIX TO POSTFIX NOTATION
C  12E+	
C
C  NOTE:  TO ADD A NEW MATH FUNCTION:
C     1. CHOOSE A SEQUENTIAL LETTER FOR SUBSTITUTING A MATH FUNCTION
C
C **********************************************************************

	SUBROUTINE POLISH(ILEVEL,EXPR,NLET,IPOLSH,NPOL,
     &                        VAL,NVAL,IRTFLG)

        COMMON /UNITS/  LUNC,NIN,NOUT,NECHO,IFOUND,NPROC,NDAT

        CHARACTER(LEN=*)  :: EXPR

        INTEGER,PARAMETER :: IVALEN  = 40  ! RPN LENGTH LIMIT
        INTEGER,PARAMETER :: IRPNLEN = 80  ! RPN LENGTH LIMIT
        INTEGER,PARAMETER :: NFUNC  = 15   ! 

	INTEGER           :: IPOLSH(IRPNLEN),IEXPR1(IRPNLEN)
	INTEGER           :: ISTACK(IRPNLEN),ISTP(10)
        REAL              :: VAL(IVALEN)
	LOGICAL           :: FP,BGS,UNITARY,POWER

        CHARACTER *80   MSG
        CHARACTER *7    FRMT
        CHARACTER *3    TCHR
        CHARACTER *1    CTEMP,CNEXT,MINUS
	CHARACTER *3    FUNT(NFUNC)

	DATA  FUNT/
     &  'PAD','SIN','EXP','LOG','COS','SQR','LON','INT',
C         a     b     c     d     e     f     g     h
     &  'ABS','ATA','ASI','ACO','TAN','RAN','RNN'/
C         i     j     k     l     m     n     o
C       'p'  RESERVED FOR UNITARY OPERATIONS!
	DATA  MINUS/'p'/

C       SET ERROR RETURN
        IRTFLG = 1

        IEXPR1  = 0
        ISTACK  = 0
        IPOLSH  = 0

	K       = 1
	J       = 1
	I       = 0
	BGS     = .TRUE.
	UNITARY = .FALSE.

C       POSITION ON A STACK (ISTP) OF UNITARY OPERATIONS
	LISTP   = 0

C       PARANTHESIS NESTING LEVEL IS ON THE STACK
        POWER = .FALSE.
        LPOW  = 0

C       -------------- LOOP ----------------------------------------
C       LEXICAL ANALYSIS	
40	I = I + 1
	IF (I .GT. NLET) GOTO 41

        CTEMP = EXPR(I:I)

C       ALL THE SPACES ARE ASSUMED TO BE REMOVED

	IF (BGS) THEN
           IF (CTEMP.EQ. '+')  THEN
C             IGNORE UNITARY +
	      GOTO 41

           ELSEIF (CTEMP.EQ.'-')  THEN
C             UNITARY OPERATION   MINUS SIGN
              IEXPR1(K)   = ICHAR(MINUS)
              IEXPR1(K+1) = ICHAR('(')
              K = K + 2
C             HERE PUSH ON STACK
              LISTP = LISTP+1
              ISTP(LISTP) = 0
              UNITARY     = .TRUE.
              I           = I + 1
	      IF (I .GT. NLET)  THEN
                 CALL ERRT(101,' EXPRESSION CANNOT END WITH -',NE)
                 RETURN
              ENDIF
              CTEMP = EXPR(I:I)

           ELSE
              BGS = .FALSE.           
           ENDIF
	ENDIF

	IF (CTEMP .EQ. '(') THEN
C          LEFT PARENTHESIS
           IF (POWER) LPOW = LPOW+1
           IF (UNITARY) THEN
C             BEGIN NEW EXPRESSION
              ISTP(LISTP) = ISTP(LISTP)+1
              BGS = .TRUE.
           ELSE
              BGS = .TRUE.
           ENDIF
           IEXPR1(K) = ICHAR(CTEMP)
           K          = K + 1
           GOTO 41

	ELSEIF (CTEMP.EQ.')') THEN
C          RIGHT PARENTHESIS
           IEXPR1(K) = ICHAR(CTEMP)
           K          = K + 1
           IF (UNITARY)  THEN
              BGS = .FALSE.
C             POP FROM THE STACK, IF END OF STACK UNITARY=.FALSE.
              ISTP(LISTP) = ISTP(LISTP)-1
              IF (ISTP(LISTP) .EQ. 0)  THEN
                 LISTP = MAX(LISTP-1,0)
                 IF (LISTP .EQ. 0)  UNITARY = .FALSE.
C                SEE IF THE NEXT OPERATION IS '**', IF YES DO NOTHING
                 IF (I+2 .LE. NLET) THEN
                    IF (EXPR(I+1:I+2) .EQ. '**')  THEN
                       IF (POWER)  THEN
                          CALL ERRT(101,
     &                       'TOO MANY NESTED POWER OPERATORS',NE)
                          RETURN
                       ENDIF
                       POWER = .TRUE.
                       LPOW  = 0
                       GOTO 41
                    ENDIF
                 ENDIF
                 IEXPR1(K) = ICHAR(')')
                 K         = K + 1
              ENDIF
           ENDIF
           IF (POWER) THEN
              LPOW = LPOW-1
              IF (LPOW .EQ. 0)  THEN
                 POWER = .FALSE.
                 IEXPR1(K) = ICHAR(')')
                 K         = K + 1
              ENDIF
           ENDIF
           GOTO 41

        ELSEIF (I+1 .LE. NLET)  THEN
           IF (EXPR(I:I+1) .EQ. '**') THEN
              IEXPR1(K) = ICHAR('^')
              K         = K+1
              I         = I+1
              GOTO 41
           ENDIF
        ENDIF

        IF (CTEMP  .EQ. '[') THEN
C          [] IS RESERVED FOR REGISTERS (SYMBOLS ALREADY SUBSTTUTED OUT)

           CALL REG_GET_VAR(ILEVEL,EXPR(I:),.FALSE.,VALDUM,
     &                      IREG,IENDVAR,IER)
	   IF (IER .NE. 0) RETURN

           I         = I + IENDVAR - 1 

          VAL(J)     = IREG
          IEXPR1(K)  = (127+J)
          J          = J+1
          K          = K+1

          IF (UNITARY) THEN
             IF (BGS) THEN
                BGS = .FALSE.
C               POP FROM THE STACK, IF END OF STACK UNITARY= .FALSE.
                LISTP = MAX(LISTP-1,0)
                IF (LISTP .EQ. 0)  UNITARY= .FALSE.
C               SEE IF THE NEXT OPERATION IS '**', IF YES DO NOTHING
                IF (I+2 .LE. NLET) THEN
                   IF (EXPR(I+1:I+2) .EQ. '**')  THEN
                      IF (POWER)  THEN
                         CALL ERRT(101,
     &                   'TOO MANY NESTED POWER OPERATORS',NE)
                         RETURN
                      ENDIF
                      POWER = .TRUE.
                      LPOW  = 0
                      GOTO 41
                   ENDIF
                ENDIF
                IEXPR1(K) = ICHAR(')')
                K         = K + 1
             ENDIF
          ENDIF
          IF (POWER .AND. LPOW .EQ.0) THEN
             POWER = .FALSE.
             IEXPR1(K) = ICHAR(')')
             K         = K + 1
          ENDIF
	
        ELSEIF (CTEMP .GE. 'A') THEN

C          MATH FUNCTIONS PARSING BEGINS HERE
C          SUBSTITUTE LETTERS FOR MATH FUNCTIONS
	
           IF (I+2 .LE. NLET)  THEN
              TCHR = EXPR(I:I+2)
              CALL SSUPCAS(TCHR)  !COULD BE LOWERCASE
              DO  L=1,NFUNC
                 IF (TCHR .EQ. FUNT(L)) GOTO  51
              ENDDO
              GOTO 52

C             CODE FUNCTION BY A SMALL LETTER
51            IEXPR1(K) = (L - 1 + ICHAR('a'))
	      K = K+1
	      I = I+2
              GOTO 41

           ENDIF
52         IF (I+1 .LE. NLET)  THEN
              IF (EXPR(I:I+1) .EQ. 'P1' .OR. EXPR(I:I+1) .EQ. 'p1') THEN
C                PIXEL OPERATIONS FOR 'AR' USE
                 IF (J .GT. IVALEN)  THEN
                    CALL ERRT(101,'EXPRESSION TOO LONG',NE)
                    RETURN
                 ENDIF

C                RESERVE PLACE FOR PIXEL IN VAL ARRAY
                 VAL(J)    = 1.0
                 IEXPR1(K) = (200+J)
                 K = K+1
                 I = I+1
                 J = J+1
                 IF (UNITARY)  THEN
                    IF (BGS) THEN
                       BGS = .FALSE.
C                      POP FROM THE STACK, IF END OF STACK UNITARY= .FALSE.
                       LISTP = MAX(LISTP-1,0)
                       IF (LISTP .EQ. 0)  UNITARY = .FALSE.
C                      SEE IF THE NEXT OPERATION IS '**', 
C                      IF YES DO NOTHING
                       IF (I+2 .LE. NLET) THEN
                          IF (EXPR(I+1:I+2) .EQ. '**')  THEN
                             IF (POWER)  THEN
                                CALL ERRT(101,
     &                          'TOO MANY NESTED POWER OPERATORS',NE)
                                RETURN
                             ENDIF
                             POWER = .TRUE.
                             LPOW  = 0
                             GOTO 41
                          ENDIF
                       ENDIF
                       IEXPR1(K) = ICHAR(')')
                       K         = K + 1
                    ENDIF
                 ENDIF
                 IF (POWER .AND. LPOW .EQ. 0) THEN
                    POWER     = .FALSE.
                    IEXPR1(K) = ICHAR(')')
                    K         = K + 1
                 ENDIF
                 GOTO 41
              ENDIF
           ENDIF

       ELSEIF (CTEMP .EQ. '+' .OR. CTEMP .EQ. '-' .OR.
     &         CTEMP .EQ. '*' .OR. CTEMP .EQ. '/' .OR.
     &         CTEMP .EQ. '^') THEN
C         ARITHMETIC OPERATION +-*/
          IEXPR1(K) = ICHAR(EXPR(I:I))
          K         = K + 1

       ELSEIF (CTEMP .EQ.'.' .OR. (CTEMP.GE.'0'.AND.CTEMP.LE.'9')) THEN
C         A NUMBER IN EXPRESSION

          IGO  = I
          INOT = VERIFY(EXPR(IGO:NLET),'.Ee0123456789')
          I    = NLET
          IF (INOT .GT. 0) THEN
             I = IGO + INOT - 2
             IF (EXPR(I:I) .EQ. 'E' .OR. EXPR(I:I) .EQ. 'e') THEN
C               CAN HAVE INCLUDED '+" or '-'
                INOT  = VERIFY(EXPR(I+2:NLET),'.Ee0123456789')
                IF (INOT .GT. 0) THEN
                   I = I + INOT
                ELSE
                   I = NLET
                ENDIF
             ENDIF
          ENDIF

c          WRITE(NOUT,9009) INOT,IGO,I,EXPR(IGO:I)
c9009      FORMAT('inot: ',i2,'  EXPR(',i2,':',i2,') :'A)

C         EVALUATE THE NUMBER
          IF (J .GT. IVALEN)  THEN
              CALL ERRT(101,'EXPRESSION TOO LONG',NE)
              RETURN
          ENDIF
          IEXPR1(K) = (J+48)
          READ(EXPR(IGO:I),'(F20.0)',IOSTAT=IER) VAL(J)

	   IF (IER .NE. 0)  THEN
              WRITE(NOUT,*) 'IN EXPRESSION: ',EXPR(IGO:I)
              CALL ERRT(101,'READING NUMBER',NE)
              RETURN
           ENDIF

	   J = J + 1
	   K = K + 1

 30	   FORMAT(I1)
        
           IF (UNITARY)  THEN
              IF (BGS) THEN
                 BGS = .FALSE.
C                POP FROM STACK, IF END OF STACK UNITARY= .FALSE.
                 LISTP = MAX(LISTP-1,0)
                 IF (LISTP .EQ.0)  UNITARY= .FALSE.
C                SEE IF THE NEXT OPERATION IS '**', IF YES DO NOTHING
                 IF (I+2 .LE. NLET) THEN
                    IF (EXPR(I+1:I+2) .EQ. '**')  THEN
                       IF (POWER)  THEN
                          CALL ERRT(101,
     &                       'TOO MANY NESTED POWER OPERATORS',NE)
                          RETURN
                       ENDIF
                       POWER= .TRUE.
                       LPOW=0
                       GOTO 41
                    ENDIF
                 ENDIF
                 IEXPR1(K) = ICHAR(')')
                 K          = K + 1
              ENDIF
           ENDIF
           IF (POWER .AND. LPOW .EQ.0) THEN
              POWER= .FALSE.
              IEXPR1(K) = ICHAR(')')
              K          = K + 1
           ENDIF
        ELSE
C          UNEXPECTED CHARACTER IN THE EXPRESSION
           MSG = 'UNEXPECTED CHARACTER IN EXPRESSION: '//CTEMP//CHAR(0)
           NCHARE = lnblnkn(MSG)
           CALL ERRT(101,MSG(:NCHARE),NE)
           RETURN
        ENDIF

C       END OF NUMBER PROCESSING LOOP

41	IF (I .LT. NLET) GOTO 40

C       --------------------- END LOOP ------------------------

C       CONVERT FROM INFIX TO POSTFIX
C       SYNTAX ANALYSIS
        NVAL       = J-1
        IEXPR1(K)  = ICHAR(')')
	NCHAR2     = K+1
	IPNT       = 1
	ITOP       = 1
	ISTACK(1)  = ICHAR('(')
	IRANK      = 0
	I          = 0

4	NEXT = IEXPR1(IPNT)
	IPNT = IPNT+1
	IF (IPNT .GT. NCHAR2) THEN
C          ALL DONE, CAN RETURN NOW
	   IF (ITOP .NE.0) THEN
	      CALL ERRT(43,'POLISH',NE)
              RETURN
	   ENDIF
           J      = 1
           IRTFLG = 0
           NPOL   = I
           RETURN
        ENDIF

	IF (ITOP .LT. 1)  THEN
           WRITE(NOUT,*) ' *** INVALID EXPRESSION: ',EXPR
	   CALL ERRT(101,'INVALID ARITHMETIC EXPRESSION',NE)
           RETURN
	ENDIF

7       CONTINUE
        IF (NEXT .EQ. ICHAR('+') .OR. NEXT.EQ. ICHAR('-')) THEN
          NFQT = 1
        ELSEIF (NEXT .EQ. ICHAR('*') .OR. 
     &          NEXT .EQ. ICHAR('/')) THEN
          NFQT = 3
        ELSEIF (NEXT .EQ. ICHAR('^')) THEN
          NFQT = 6
        ELSEIF (NEXT .EQ. ICHAR('(')) THEN
          NFQT = 9
        ELSEIF (NEXT .EQ. ICHAR(')')) THEN
          NFQT = 0
        ELSE
          NFQT = 7
        ENDIF

        ITEMP = ISTACK(ITOP)
        IF (ITEMP .EQ. ICHAR('+') .OR. ITEMP .EQ. ICHAR('-')) THEN
           NGQT = 2
        ELSEIF (ITEMP .EQ. ICHAR('*') .OR. ITEMP .EQ. ICHAR('/')) THEN
            NGQT = 4
        ELSEIF (ITEMP .EQ. ICHAR('^')) THEN
            NGQT = 5
        ELSEIF (ITEMP .EQ. ICHAR('(')) THEN
            NGQT = 0
        ELSE
            NGQT = 8
        ENDIF

 	IF (NFQT .LE. NGQT) THEN
           IF (NFQT .NE. NGQT) THEN
              I          = I + 1
              IPOLSH(I)  = ITEMP
              NRQT       = 1
              IF (ITEMP .EQ. ICHAR('+') .OR. ITEMP .EQ. ICHAR('-') .OR.
     &            ITEMP .EQ. ICHAR('*') .OR. ITEMP .EQ. ICHAR('/') .OR.
     &            ITEMP .EQ. ICHAR('^')) NRQT = -1

              IRANK = IRANK + NRQT
              IF (IRANK .LE. 0)   THEN
		 CALL ERRT(43,'POLISH',NE)
                 RETURN	
	      ENDIF
              ITOP = ITOP - 1
              GOTO 7
           ENDIF
           ITOP = ITOP - 1
        ELSE
           ITOP         = ITOP+1
           ISTACK(ITOP) = NEXT
        ENDIF
	GOTO 4

	END

@


1.32
log
@GPL_2010
@
text
@d15 1
a15 1
C=* Email: spider@@wadsworth.org                                        *
@


1.31
log
@removed: NO REGISTER VAR.....
@
text
@d10 4
a13 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
d24 1
a24 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a25 1
C=*                                                                    *
@


1.30
log
@bad e exponent handling
@
text
@d8 1
a8 1
C
d10 5
a14 5
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d16 1
a16 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d21 1
a21 1
C=* This program is distributed in the hope that it will be useful,    *
d27 1
a27 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d227 1
a227 5
	   IF (IER .NE. 0)  THEN
C             ERRT CALLED IN REG_GET_VAR
              WRITE(NOUT,*)'  *** NO REGISTER VARIABLE: ',EXPR(I:)
              RETURN
           ENDIF
d229 1
a229 1
           I = I + IENDVAR - 1 
@


1.29
log
@native named registers
@
text
@d229 1
a229 1
           CALL REG_GET_VAR(ILEVEL,EXPR(I:),.TRUE.,VALDUM,
d232 1
d351 1
a351 1
          INOT = VERIFY(EXPR(IGO:NLET),'.E0123456789')
d355 1
a355 1
             IF (EXPR(I:I) .EQ. 'E') THEN
d357 1
a357 1
                INOT  = VERIFY(EXPR(I+2:NLET),'.E0123456789')
@


1.28
log
@GPL License fixed
@
text
@d7 1
d35 1
a35 1
C  POLISH(EXPR,NLET,IPOLSH,NPOL,VAL,NVAL,IRTFLG)
d39 3
a41 2
C  VARIABLES:
C	EXPR       CHARACTER STRING CONTAINING EXPRESSION        (SENT)
d80 2
a81 1
	SUBROUTINE POLISH(EXPR,NLET,IPOLSH,NPOL,VAL,NVAL,IRTFLG)
d85 12
a96 5
        PARAMETER       (IVALEN = 40)
        PARAMETER       (IRPNLEN = 80)
        PARAMETER       (NFUNC = 15)
        CHARACTER *(*)  EXPR
	INTEGER         IPOLSH(IRPNLEN),IEXPR1(IRPNLEN),ISTACK(IRPNLEN)
d99 2
a100 5
	INTEGER         ISTP(10)
	DIMENSION       VAL(IVALEN)
        CHARACTER * 1   CTEMP,CNEXT,MINUS
	CHARACTER*3     FUNT(NFUNC)
	LOGICAL         FP,BGS,UNITARY,POWER
d155 1
a155 2
                 CALL ERRT(101,
     &              ' EXPRESSION CANNOT END WITH -',NE)
d226 2
a227 3
        IF (CTEMP  .EQ. 'X') THEN
C          FIRST LETTER X IS RESERVED FOR REGISTERS
C          NO FUNCTIONS BEGIN WITH 'X'
d229 2
a230 1
           CALL REGPARSE(EXPR(I:),IREG,IRGO,IREND,.TRUE.,IER)
d232 1
a232 1
              CALL ERRT(101,'NO REGISTER NUMBER',NE)
d235 2
a236 1
           I = I + IREND - 1
d275 1
a275 1
C          SUBSTITUE LETTERS FOR MATH FUNCTIONS
d279 1
d293 1
a293 1
              IF (EXPR(I:I+1) .EQ. 'P1') THEN
d417 3
a419 3
           NC = ICHAR(CTEMP)
           CALL ERRT(102,'UNEXPECTED CHARACTER IN EXPRESSION (ICHAR): ',
     &               NC)
d455 2
a456 1
	   CALL ERRT(43,'POLISH',NE)
@


1.27
log
@HRI GPL License used
@
text
@a8 2
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      **
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
d12 1
a12 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a31 6

C *  COPYRIGHT (C)1985, 2001 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
@


1.26
log
@debug output removed
@
text
@d9 1
d11 24
@


1.25
log
@fmrt leak & simplified number interpretation
@
text
@d340 2
a341 2
          WRITE(NOUT,9009) INOT,IGO,I,EXPR(IGO:I)
9009      FORMAT('inot: ',i2,'  EXPR(',i2,':',i2,') :'A)
@


1.24
log
@beter error msg. for unknown cahr in expression
@
text
@d5 2
d166 1
a166 1
                 IF (LISTP .EQ.0)  UNITARY = .FALSE.
d168 1
a168 1
                 IF (I+2.LE.NLET) THEN
d181 1
a181 1
                 K          = K + 1
d189 1
a189 1
                 K          = K + 1
d197 2
a198 2
              K          = K+1
              I          = I+1
d239 1
a239 1
                K          = K + 1
d245 1
a245 1
             K          = K + 1
d265 1
d276 1
a276 1
                 VAL(J)     = 1.0
d302 1
a302 1
                       K          = K + 1
d306 1
a306 1
                    POWER = .FALSE.
d308 1
a308 1
                    K          = K + 1
d319 1
a319 1
          K          = K + 1
d323 14
a336 8
          IBEGIN=I
          IF (CTEMP .EQ.'.')  THEN
C            FP INDICATES FLOATING POINT NUMBER
             FP = .TRUE.
             I  = I+1
             IF (I .GT .NLET)  THEN
                CALL ERRT(101,'SINGLE DOT',NE)
                RETURN
a337 2
          ELSE
             FP = .FALSE.
d339 3
a341 46
C         LEADING DIGITS FOR FP, 
C         OR DIGITS AFTER SINGLE DOT FOR FP, OR WHOLE INT
          DO WHILE (I+1 .LE. NLET .AND.
     &       (EXPR(I+1:I+1) .GE. '0' .AND. EXPR(I+1:I+1) .LE. '9'))
             I = I + 1
          ENDDO
          IF (I .EQ. NLET)  GOTO 28
          IF (EXPR(I+1:I+1) .EQ.'.')  THEN
             IF (FP)  THEN
                CALL ERRT(101,'SECOND DOT',NE)
                RETURN
             ELSE
                FP = .TRUE.
                 I = I + 1
                 IF (I .EQ. NLET)  GOTO 28
C                DIGITS AFTER SINGLE DOT FOR FP
                 DO WHILE (I+1 .LE. NLET .AND.
     &              (EXPR(I+1:I+1).GE.'0' .AND. EXPR(I+1:I+1) .LE. '9'))
                    I = I + 1
                 ENDDO
              ENDIF
           ELSEIF (FP .AND.(EXPR(I+1:I+1) .NE. 'E'))  THEN
              GOTO  28
           ENDIF
           IF (I .EQ. NLET)  GOTO 28
           I = I + 1
C          AFTER DOT, CERTAINLY FP
           IF (EXPR(I:I) .EQ. '.')  THEN
              CALL ERRT(101,'SECOND DOT',NE)
              RETURN
           ELSEIF (EXPR(I:I) .EQ.'E')  THEN
              I = I + 1
              IF (EXPR(I:I) .EQ.'+' .OR. EXPR(I:I) .EQ.'-') I = I + 1
              IF (I .EQ.NLET .AND.
     &            (EXPR(I:I).LT.'0' .OR. EXPR(I:I).GT.'9'))  THEN
                 CALL ERRT(101,'WRONG CHARACTER AFTER E',NE)
                 RETURN
              ENDIF
C             DIGITS AFTER E
              DO WHILE (I+1 .LE.NLET .AND.
     &            (EXPR(I+1:I+1) .GE. '0' .AND. EXPR(I+1:I+1) .LE. '9'))
                 I = I + 1
              ENDDO
           ELSE
              I = I - 1
           ENDIF
d343 2
a344 2
C          EVALUATE THE NUMBER
28         IF (J .GT.IVALEN)  THEN
d347 3
a349 28
           ENDIF
           IEXPR1(K) = (J+48)
	   IS = I - IBEGIN + 1
	   IF (IS .LT. 10) THEN
	      IF (FP) THEN
C                FLOATING POINT
	         FRMT = '(F .1)'
	         WRITE(FRMT(3:3),'(I1)') IS
	         READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) VAL(J)
	      ELSE
C                INTEGER
	         FRMT = '(I )'
	         WRITE(FRMT(3:3),'(I1)') IS
	         READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) ITEMP1
	         VAL(J) = ITEMP1 
	      ENDIF
	   ELSE
	      IF (FP) THEN
	         FRMT = '(F  .1)'
	         WRITE(FRMT(3:4),'(I2)') IS
	         READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) VAL(J)
	      ELSE
	         FRMT = '(I  )'
	         WRITE(FRMT(3:4),'(I2)') IS
	         READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) ITEMP1
	         VAL(J) = ITEMP1 
	      ENDIF 
	   ENDIF
d352 1
d357 2
a358 2
	   J = J+1
	   K = K+1
d363 1
a363 1
              IF (BGS)  THEN
d366 1
a366 1
                 LISTP=MAX(LISTP-1,0)
d369 1
a369 1
                 IF (I+2 .LE.NLET) THEN
d373 1
a373 1
     &                     'TOO MANY NESTED POWER OPERATORS',NE)
@


1.23
log
@removed " used '
@
text
@d8 1
a8 1
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
d452 3
a454 1
           CALL ERRT(101,'UNEXPECTED CHARACTER IN EXPRESSION',NE)
@


1.22
log
@changes for reg_set
@
text
@d389 2
a390 2
	         FRMT = "(F .1)"
	         WRITE(FRMT(3:3),"(I1)") IS
d394 2
a395 2
	         FRMT = "(I )"
	         WRITE(FRMT(3:3),"(I1)") IS
d401 2
a402 2
	         FRMT = "(F  .1)"
	         WRITE(FRMT(3:4),"(I2)") IS
d405 2
a406 2
	         FRMT = "(I  )"
	         WRITE(FRMT(3:4),"(I2)") IS
@


1.21
log
@rann added
@
text
@d87 3
a89 3
           IEXPR1  = 0
           ISTACK  = 0
           IPOLSH  = 0
d117 1
d119 1
a119 1
C       UNITARY OPERATION   MINUS SIGN
d134 1
d145 2
a146 2
              ISTP(LISTP)=ISTP(LISTP)+1
              BGS=.TRUE.
d148 1
a148 1
              BGS=.TRUE.
d192 1
a192 1
        ELSEIF (I+1.LE.NLET)  THEN
d194 4
a197 4
           IEXPR1(K) = ICHAR('^')
           K          = K+1
           I          = I+1
           GOTO 41
d199 1
a199 1
         ENDIF
d205 1
a205 2
           IER = 1
           IF (I+1 .LE. NLET) READ(EXPR(I+1:I+1),30,IOSTAT=IER) IREG
d207 2
a208 2
               CALL ERRT(101,'NO REGISTER NUMBER',NE)
               RETURN
d210 1
a210 12
     
           IF (I+2 .LE. NLET)  THEN
             CNEXT = EXPR(I+2:I+2)
             IF (CNEXT .GE. '0' .AND .CNEXT .LE. '9') THEN
C               HAVE 2ND DIGIT IN REGISTER NUMBER
                READ(CNEXT,30,IOSTAT=IER) IVAL1
                IF (IER .EQ. 0)  THEN
                   IREG = 10 * IREG + IVAL1
                   I    = I + 1
                ENDIF
             ENDIF
          ENDIF
a215 1
          I          = I+1
@


1.20
log
@replaced use of ICHAR with integer assignments (fails on ibm mp)
@
text
@d44 4
a47 3
C       TAN ->  m
C       RAN -> n
C       CHANGE THE SIGN -> o
d65 1
a65 1
        PARAMETER       (NFUNC = 14)
d72 1
a72 1
        CHARACTER * 1   CTEMP,CNEXT
d79 4
a82 3
     &  'ABS','ATA','ASI','ACO','TAN','RAN'/
C         i     j     k     l     m     n
C       'o'  RESERVED FOR UNITARY OPERATIONS!
d87 3
a89 5
	DO  I=1,IRPNLEN
           IEXPR1(I)  = 0
           ISTACK(I)  = 0
           IPOLSH(I)  = 0
        ENDDO
d118 2
a119 2
C             MINUS SIGN
              IEXPR1(K)   = ICHAR('o')
@


1.19
log
@a
@
text
@d1 1
a1 1
C++******************************************************************* 
d4 1
d48 1
a48 1
C THE SUBROUTINE TRANSFORM THE EXPRESSION FROM TOKEN TO A SINGLE
a61 1

d66 1
a66 1
	INTEGER         IPOLSH(IRPNLEN)
d71 1
a71 2
        CHARACTER *80   POLSH,EXPR1,STACK
        CHARACTER * 1   CTEMP,NEXT
d86 3
a88 3
           EXPR1(I:I) = ' '
           STACK(I:I) = ' '
           POLSH(I:I) = ' '
d119 2
a120 1
              EXPR1(K:K+1) = 'o('
d148 1
a148 1
           EXPR1(K:K) = CTEMP
d154 1
a154 1
           EXPR1(K:K) = CTEMP
d176 1
a176 1
                 EXPR1(K:K) = ')'
d184 1
a184 1
                 EXPR1(K:K) = ')'
d192 1
a192 1
           EXPR1(K:K) = '^'
d211 2
a212 2
             NEXT = EXPR(I+2:I+2)
             IF (NEXT .GE. '0' .AND .NEXT .LE. '9') THEN
d214 1
a214 1
                READ(NEXT,30,IOSTAT=IER) IVAL1
d223 1
a223 1
          EXPR1(K:K) = CHAR(127+J)
d247 1
a247 1
                EXPR1(K:K) = ')'
d253 1
a253 1
             EXPR1(K:K) = ')'
d270 1
a270 1
51            EXPR1(K:K) = CHAR(L - 1 + ICHAR('a'))
d285 1
a285 1
                 EXPR1(K:K) = CHAR(200+J)
d309 1
a309 1
                       EXPR1(K:K) = ')'
d315 1
a315 1
                    EXPR1(K:K) = ')'
a321 2


d326 1
a326 1
          EXPR1(K:K) = EXPR(I:I)
d395 1
a395 1
           EXPR1(K:K) = CHAR(J+48)
d452 1
a452 1
                 EXPR1(K:K) = ')'
d458 1
a458 1
              EXPR1(K:K) = ')'
d475 2
a476 2
        NVAL=J-1
	EXPR1(K:K) = ')'
d480 1
a480 1
	STACK(1:1) = '('
d484 1
a484 1
4	NEXT = EXPR1(IPNT:IPNT)
d487 1
a494 5

C          CONVERT CHARACTER RETURN TO INTEGER VALUES
           DO I = 1, NPOL
              IPOLSH(I) = ICHAR(POLSH(I:I))
           ENDDO
d504 1
a504 1
        IF (NEXT .EQ.'+' .OR. NEXT.EQ.'-') THEN
d506 2
a507 1
        ELSEIF (NEXT .EQ.'*' .OR. NEXT .EQ. '/') THEN
d509 1
a509 1
        ELSEIF (NEXT .EQ. '^') THEN
d511 1
a511 1
        ELSEIF (NEXT .EQ. '(') THEN
d513 1
a513 1
        ELSEIF (NEXT .EQ. ')') THEN
d519 2
a520 2
        CTEMP = STACK(ITOP:ITOP)
        IF (CTEMP .EQ. '+' .OR. CTEMP .EQ. '-') THEN
d522 1
a522 1
        ELSEIF (CTEMP .EQ. '*' .OR. CTEMP .EQ. '/') THEN
d524 1
a524 1
        ELSEIF (CTEMP .EQ. '^') THEN
d526 1
a526 1
        ELSEIF (CTEMP .EQ. '(') THEN
d535 1
a535 1
              POLSH(I:I) = CTEMP
d537 3
a539 3
              IF (CTEMP .EQ. '+' .OR. CTEMP .EQ. '-' .OR.
     &            CTEMP .EQ. '*' .OR. CTEMP .EQ. '/' .OR.
     &            CTEMP .EQ. '^') NRQT = -1
d541 1
a541 1
              IRANK      = IRANK + NRQT
d551 2
a552 2
           ITOP = ITOP+1
           STACK(ITOP:ITOP) = NEXT
@


1.18
log
@reading long numbers (=>10) fixed
@
text
@d60 1
a60 1
CNO_SAVE
@


1.17
log
@changed error msgs
@
text
@d414 4
a421 4
	      ELSE
	         FRMT = "(F  .1)"
	         WRITE(FRMT(3:4),"(I2)") IS
	         READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) VAL(J)
@


1.16
log
@p1 handling was wrong
@
text
@d128 1
a128 1
                 CALL ERRT(43,
d167 1
a167 1
                          CALL ERRT(43,
d206 1
a206 1
               CALL ERRT(43,'NO REGISTER NUMBER',NE)
d238 1
a238 1
                         CALL ERRT(43,
d279 1
a279 1
                    CALL ERRT(43,'EXPRESSION TOO LONG',NE)
d300 1
a300 1
                                CALL ERRT(43,
d339 1
a339 1
                CALL ERRT(43,'SINGLE DOT',NE)
d354 1
a354 1
                CALL ERRT(43,'SECOND DOT',NE)
d373 1
a373 1
              CALL ERRT(43,'POLISH - SECOND DOT',NE)
d380 1
a380 1
                 CALL ERRT(43,'WRONG CHARACTER AFTER E',NE)
d394 1
a394 1
              CALL ERRT(43,'EXPRESSION TOO LONG',NE)
d426 1
a426 1
              CALL ERRT(43,'READING NUMBER',NE)
d445 1
a445 1
                          CALL ERRT(43,
d465 1
a465 1
           CALL ERRT(43,'UNEXPECTED CHARACTER IN EXPRESSION',NE)
@


1.15
log
@changed register and pixel handling
@
text
@d287 1
a287 1
                 I = I+2
@


1.14
log
@I hope it finally works!
@
text
@d14 1
a14 1
C  POLISH(EXPRT,NLET,POLSH,NPOL,VAL,NVAL,INDPL,NPIX,IRTFLG)
d19 1
a19 1
C	EXPRT      CHARACTER STRING CONTAINING EXPRESSION        (SENT)
d21 2
a22 1
C	POLSH      CHAR. STRING RETURNS POSTFIX EXPRESSION   (RETURNED)
d24 2
a25 4
C                        POLSH'S ELEMENTS
C       NVAL       NO. OF ELEMENTS IN VAL                    (RETURNED)
C       INDPL      INDICES FOR PIXEL VALUES                  (RETURNED)
C       NPIX       COUNTER FOR PIXEL VALUES                  (RETURNED)
d37 1
a37 1
C       LON -> g (natural logarithm)
d45 1
a45 1
C       change the sign -> o
d53 1
a53 3
C     1. LOOK FOR A COMMENT "ADD MORE MATH FUNCTIONS FOR PARSING"
C     2. INSERT YOUR MATH FUNCTION FOR PARSING
C     3. CHOOSE A SEQUENTIAL LETTER FOR SUBSTITUTING A MATH FUNCTION
d57 1
a57 1
	SUBROUTINE POLISH(EXPR,NLET,POLSH,NPOL,VAL,NVAL,INDPL,NPIX,IRTFLG)
d60 1
a60 1
	COMMON /PARAM/  PARAM(103),NSEL(20)
d62 2
a63 1
        PARAMETER       (IPOLEN = 40)
d66 1
a66 1
        CHARACTER *(*)  POLSH
d69 3
a71 3
	INTEGER         INDPL(IPOLEN),ISTP(10)
	DIMENSION       VAL(IPOLEN)
        CHARACTER *81   EXPR1,STACK
d75 1
d81 1
a81 2
C 'o'  reserved for unitary operations!
CNO_SAVE
d86 1
a86 5
C       INITIALIZE PIXEL SUBSTITUTION COUNTER
 	NPIX = 0


	DO  I=1,81
d92 13
a104 10
	K    = 1
	J    = 1
	I    = 0
	BGS = .TRUE.
	UNITARY=.FALSE.
C  Position on a stack (ISTP) of unitary operations
	LISTP=0
C  Paranthesis nesting level is on the stack
        POWER=.FALSE.
        LPOW=0
d114 19
a132 17
	IF(BGS) THEN
           IF(CTEMP.EQ.'+')  THEN
C  IGNORE UNITARY +
	   GOTO 41
           ELSEIF(CTEMP.EQ.'-')  THEN
           EXPR1(K:K+1) = 'o('
           K = K+2
C HERE PUSH ON STACK
           LISTP=LISTP+1
           ISTP(LISTP)=0
           UNITARY=.TRUE.
           I = I + 1
	   IF(I .GT. NLET)  THEN
            CALL  ERRT(43,'POLISH - expression cannot end with -',NE)
            RETURN
           ENDIF
           CTEMP = EXPR(I:I)
d134 1
a134 1
           BGS=.FALSE.           
d138 7
a144 6
	IF (CTEMP.EQ.'(') THEN
           IF(POWER) LPOW=LPOW+1
           IF(UNITARY)  THEN
C  BEGIN NEW EXPRESSION
           ISTP(LISTP)=ISTP(LISTP)+1
           BGS=.TRUE.
d146 1
a146 1
           BGS=.TRUE.
d153 1
d156 19
a174 17
           IF(UNITARY)  THEN
           BGS=.FALSE.
C POP FROM THE STACK, IF END OF STACK UNITARY=.FALSE.
           ISTP(LISTP)=ISTP(LISTP)-1
             IF(ISTP(LISTP).EQ.0)  THEN
             LISTP=MAX(LISTP-1,0)
             IF(LISTP.EQ.0)  UNITARY=.FALSE.
C SEE IF THE NEXT OPERATION IS '**', IF YES DO NOTHING
                IF(I+2.LE.NLET) THEN
                 IF(EXPR(I+1:I+2) .EQ. '**')  THEN
                  IF(POWER)  THEN
        CALL ERRT(43,'POLISH - to many nested power operators',NE)
                  RETURN
                  ENDIF
                  POWER=.TRUE.
                  LPOW=0
                  GOTO 41
d176 3
a178 4
                ENDIF
             EXPR1(K:K) = ')'
             K          = K + 1
             ENDIF
d180 7
a186 7
           IF(POWER) THEN
            LPOW=LPOW-1
            IF(LPOW.EQ.0)  THEN
             POWER=.FALSE.
             EXPR1(K:K) = ')'
             K          = K + 1
            ENDIF
d191 1
a191 1
           IF(EXPR(I:I+1) .EQ. '**') THEN
d193 2
a194 2
           K = K+1
           I = I+1
d199 57
d257 1
a257 1
        IF (CTEMP .GE. 'A' .AND. CTEMP .NE. 'X') THEN
d259 9
a267 3
C       ADD MORE MATH FUNCTIONS FOR PARSING
C       MATH FUNCTIONS PARSING BEGINS HERE
C       SUBSTITUE LETTERS FOR MATH FUNCTIONS
d269 2
a270 11
C  FIRST LETTER X IS RESERVED FOR REGISTERS
C  NO FUNCTIONS BEGGINING WITH 'X'
	
          IF(I+2.LE.NLET)  THEN
            TCHR = EXPR(I:I+2)
            DO  L=1,NFUNC
            IF (TCHR .EQ. FUNT(L)) GOTO  51
            ENDDO
            GOTO  52
C  Code function by a small letter
51        EXPR1(K:K) = CHAR(L - 1 + ICHAR('a'))
d274 7
a280 32
          ENDIF
52        IF(I+1.LE.NLET)  THEN
           IF (EXPR(I:I+1) .EQ. 'P1') THEN
C Pixel operations for AR
              IF(J.GT.IPOLEN)  THEN
               CALL ERRT(43,'POLISH: expression too long',NE)
               RETURN
              ENDIF
              VAL(J)      = 0.0
              NPIX        = NPIX + 1
              INDPL(NPIX) = J
C  start from '1'
              EXPR1(K:K)=CHAR(J+48)
              K = K+1
              I = I+1
              J = J+1
            IF(UNITARY)  THEN
             IF(BGS)  THEN
             BGS=.FALSE.
C POP FROM THE STACK, IF END OF STACK UNITARY=.FALSE.
             LISTP=MAX(LISTP-1,0)
             IF(LISTP.EQ.0)  UNITARY=.FALSE.
C SEE IF THE NEXT OPERATION IS '**', IF YES DO NOTHING
                IF(I+2.LE.NLET) THEN
                 IF(EXPR(I+1:I+2) .EQ. '**')  THEN
                  IF(POWER)  THEN
        CALL ERRT(43,'POLISH - to many nested power operators',NE)
                  RETURN
                  ENDIF
                  POWER=.TRUE.
                  LPOW=0
                  GOTO 41
a281 13
                ENDIF
             EXPR1(K:K) = ')'
             K          = K + 1
             ENDIF
            ENDIF
            IF(POWER .AND. LPOW.EQ.0) THEN
             POWER=.FALSE.
             EXPR1(K:K) = ')'
             K          = K + 1
            ENDIF
            GOTO 41
           ENDIF
          ENDIF
d283 36
a318 7
        ELSEIF (CTEMP .EQ. 'X') THEN
C          EVALUATE REGISTER
         IF(I+1.LE.NLET)  THEN
              READ(EXPR(I+1:I+1),30,IOSTAT=IER) IVAL
	      IF(IER.NE.0)  THEN
              CALL ERRT(43,'POLISH: no register number',NE)
              RETURN
a319 14
         ELSE
              CALL ERRT(43,'POLISH: no register number',NE)
              RETURN
         ENDIF
     
         IF(I+2.LE.NLET)  THEN
         NEXT = EXPR(I+2:I+2)
           IF(NEXT.GE.'0'.AND.NEXT.LE.'9') THEN
C            HAVE 2ND DIGIT FOR REGISTER NUMBER
             READ(NEXT,30,IOSTAT=IER) IVAL1
             IF(IER.EQ.0)  THEN
             IVAL = 10 * IVAL + IVAL1
             I    = I+1
             ENDIF
a320 1
         ENDIF
a321 40
             IF(J.GT.IPOLEN)  THEN
               CALL ERRT(43,'POLISH: expression too long',NE)
               RETURN
             ENDIF
           VAL(J) = PARAM(IVAL+1)
C  start from '1'
           EXPR1(K:K)=CHAR(J+48)

           K = K+1
           I = I+1
           J = J+1

          IF(UNITARY)  THEN
            IF(BGS)  THEN
             BGS=.FALSE.
C POP FROM THE STACK, IF END OF STACK UNITARY=.FALSE.
             LISTP=MAX(LISTP-1,0)
             IF(LISTP.EQ.0)  UNITARY=.FALSE.
C SEE IF THE NEXT OPERATION IS '**', IF YES DO NOTHING
                IF(I+2.LE.NLET) THEN
                 IF(EXPR(I+1:I+2) .EQ. '**')  THEN
                  IF(POWER)  THEN
        CALL ERRT(43,'POLISH - to many nested power operators',NE)
                  RETURN
                  ENDIF
                  POWER=.TRUE.
                  LPOW=0
                  GOTO 41
                 ENDIF
                ENDIF
             EXPR1(K:K) = ')'
             K          = K + 1
            ENDIF
          ENDIF
          IF(POWER .AND. LPOW.EQ.0) THEN
           POWER=.FALSE.
           EXPR1(K:K) = ')'
           K          = K + 1
          ENDIF
            
a322 4
        ELSEIF(NRQ(CTEMP).EQ.-1)  THEN
C ARITHMETIC OPERATION +-*/
           EXPR1(K:K) = EXPR(I:I)
           K          = K + 1
d324 16
a339 9
        ELSEIF(CTEMP.EQ.'.' .OR. (CTEMP.GE.'0'.AND.CTEMP.LE.'9')) THEN
C a number
           IBEGIN=I
           IF(CTEMP.EQ.'.')  THEN
C  FP indicates floating point number
             FP=.TRUE.
             I=I+1
             IF(I.GT.NLET)  THEN
                CALL ERRT(43,'POLISH - SINGLE DOT',NE)
d342 7
a348 6
           ELSE
             FP=.FALSE.
           ENDIF
C Leading digits for FP, or digits after single dot for FP, or whole INT
           DO WHILE (I+1.LE.NLET .AND.
     &            (EXPR(I+1:I+1).GE.'0' .AND. EXPR(I+1:I+1).LE.'9') )
d350 5
a354 5
           ENDDO
           IF(I.EQ.NLET)  GOTO 28
           IF(EXPR(I+1:I+1).EQ.'.')  THEN
              IF(FP)  THEN
                CALL ERRT(43,'POLISH - SECOND DOT',NE)
d356 9
a364 9
              ELSE
               FP=.TRUE.
               I = I + 1
               IF(I.EQ.NLET)  GOTO 28
C Digits after single dot for FP
               DO WHILE (I+1.LE.NLET .AND.
     &            (EXPR(I+1:I+1).GE.'0' .AND. EXPR(I+1:I+1).LE.'9') )
                I = I + 1
               ENDDO
d366 1
a366 1
           ELSEIF(FP.AND.(EXPR(I+1:I+1).NE.'E'))  THEN
d369 1
a369 1
           IF(I.EQ.NLET)  GOTO 28
d371 17
a387 17
C  After dot, certainly FP
           IF(EXPR(I:I).EQ.'.')  THEN
               CALL ERRT(43,'POLISH - SECOND DOT',NE)
               RETURN
           ELSEIF(EXPR(I:I).EQ.'E')  THEN
             I = I + 1
             IF(EXPR(I:I).EQ.'+' .OR. EXPR(I:I).EQ.'-') I = I + 1
             IF (I.EQ.NLET .AND.
     &            (EXPR(I:I).LT.'0' .OR. EXPR(I:I).GT.'9') )  THEN
                CALL ERRT(43,'POLISH - WRONG CHARACTER AFTER E',NE)
                RETURN
             ENDIF
C  Digits after E
             DO WHILE (I+1.LE.NLET .AND.
     &            (EXPR(I+1:I+1).GE.'0' .AND. EXPR(I+1:I+1).LE.'9') )
             I = I + 1
             ENDDO
d389 1
a389 1
           I = I - 1
d392 20
a411 13
C       EVALUATE THE NUMBER
28           IF(J.GT.IPOLEN)  THEN
               CALL ERRT(43,'POLISH: expression too long',NE)
               RETURN
             ENDIF
          EXPR1(K:K) = CHAR(J+48)
	  IS = I - IBEGIN + 1
	  IF (IS .LT. 10) THEN
	   IF (FP) THEN
C  Floating point
	      FRMT = "(F .1)"
	      WRITE(FRMT(3:3),"(I1)") IS
	      READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) VAL(J)
d413 10
a422 5
C      Integer
	      FRMT = "(I )"
	      WRITE(FRMT(3:3),"(I1)") IS
	      READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) ITEMP1
	      VAL(J) = ITEMP1 
a423 12
	  ELSE
	    IF (FP) THEN
	      FRMT = "(I  )"
	      WRITE(FRMT(3:4),"(I2)") IS
	      READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) ITEMP1
	      VAL(J) = ITEMP1 
	    ELSE
	      FRMT = "(F  .1)"
	      WRITE(FRMT(3:4),"(I2)") IS
	      READ(EXPR(IBEGIN:I),FRMT,IOSTAT=IER) VAL(J)
	    ENDIF 
	  ENDIF
d425 4
a428 4
	  IF (IER .NE. 0)  THEN
           CALL ERRT(43,'POLISH - ERROR IN NUMBER READING',NE)
           RETURN
          ENDIF
d430 2
a431 2
	  J = J+1
	  K = K+1
d433 1
a433 1
 30	  FORMAT(I1)
d435 18
a452 16
          IF(UNITARY)  THEN
            IF(BGS)  THEN
             BGS=.FALSE.
C POP FROM STACK, IF END OF STACK UNITARY=.FALSE.
             LISTP=MAX(LISTP-1,0)
             IF(LISTP.EQ.0)  UNITARY=.FALSE.
C SEE IF THE NEXT OPERATION IS '**', IF YES DO NOTHING
                IF(I+2.LE.NLET) THEN
                 IF(EXPR(I+1:I+2) .EQ. '**')  THEN
                  IF(POWER)  THEN
        CALL ERRT(43,'POLISH - to many nested power operators',NE)
                  RETURN
                  ENDIF
                  POWER=.TRUE.
                  LPOW=0
                  GOTO 41
d454 9
a462 11
                ENDIF
             EXPR1(K:K) = ')'
             K          = K + 1
            ENDIF
          ENDIF
          IF(POWER .AND. LPOW.EQ.0) THEN
            POWER=.FALSE.
            EXPR1(K:K) = ')'
            K          = K + 1
          ENDIF

d464 3
a466 4
C  Unexpected character in the expression
        CALL ERRT(43,
     &  'POLISH - Unexpected character in the expression',NE)
        RETURN
d489 1
a489 1
	   IF (ITOP.NE.0) THEN
d493 1
a493 1
           J = 1
d495 6
a500 1
           NPOL  = I
d509 30
a538 2
7	IF (NFQ(NEXT) .LE. NGQ(STACK(ITOP:ITOP))) THEN
           IF (NFQ(NEXT).NE. NGQ(STACK(ITOP:ITOP))) THEN
d540 7
a546 2
              POLSH(I:I) = STACK(ITOP:ITOP)
              IRANK      = IRANK + NRQ(STACK(ITOP:ITOP))
@


1.13
log
@leading minus with power problem solved.
@
text
@d1 1
a1 1
C++*************************************************** 
d76 1
a76 1
	LOGICAL         FP,BGS,UNITARY
d106 2
a107 1

d140 1
a155 4
C SEE IF THE NEXT OPERATION IS '**' IN THIS CASE DO NOTHING
           IF(I+2.LE.NLET) THEN
           IF(EXPR(I+1:I+2) .EQ. '**') GOTO 41
           ENDIF
d162 12
d178 8
d234 2
a235 7
          IF(UNITARY)  THEN
C SEE IF THE NEXT OPERATION IS '**' IN THIS CASE DO NOTHING
           IF(I+2.LE.NLET) THEN
           IF(EXPR(I+1:I+2) .EQ. '**') GOTO 41
           ENDIF
           BGS=.FALSE.
            IF(BGS)  THEN
d240 18
d261 1
a261 2
          ENDIF
              GOTO 41
a302 4
C SEE IF THE NEXT OPERATION IS '**' IN THIS CASE DO NOTHING
           IF(I+2.LE.NLET) THEN
           IF(EXPR(I+1:I+2) .EQ. '**') GOTO 41
           ENDIF
d308 12
d324 5
a439 4
C SEE IF THE NEXT OPERATION IS '**' IN THIS CASE DO NOTHING
           IF(I+2.LE.NLET) THEN
           IF(EXPR(I+1:I+2) .EQ. '**') GOTO 41
           ENDIF
d445 12
d460 6
a465 1
           ENDIF
a478 5
C CLOSE REMAINIG UNITARY OPERATOR (LEADING -)
          IF(UNITARY)  THEN
             EXPR1(K:K) = ')'
             K          = K + 1
          ENDIF
@


1.12
log
@Ssingle digit register corrected
@
text
@d154 4
d217 5
d273 4
d397 4
d423 5
@


1.11
log
@NEW VERSION
@
text
@d38 1
a38 1
C       MOD -> g
d44 1
a44 1
C       LN ->  m
d80 1
a80 1
     &  'ABS','ATA','ASI','ACO','LOG','RAN'/
d240 2
d243 1
a243 1
             READ(EXPR(I+2:I+2),30,IOSTAT=IER) IVAL1
d248 1
@


1.10
log
@OK?
@
text
@d1 1
a1 1
C++*************************************************** 12/11/79 1/11/81 VAX
d3 1
a3 1
C POLISH.F                    ADAPTED FROM EVALN.FOR FOR CHAR AUG 89 AL
d14 1
a14 1
C  POLISH(EXPR,NLET,POLSH,VAL,NVAL,INDPL,NPIX,IRTLFG))
d19 1
a19 1
C	EXPR       CHARACTER STRING CONTAINING EXPRESSION        (SENT)
d46 1
d60 1
a60 1
	SUBROUTINE POLISH(EXPR,NLET,POLSH,VAL,NVAL,INDPL,NPIX,IRTLFG)
d66 1
d70 2
a71 1
	INTEGER         INDPL(IPOLEN)
d74 9
a82 10
        CHARACTER       CTEMP,NEXT,JCHAR,CTEMP1,CTEMM1

C       NXT NEEDS TO BE INTEGER*2 TO EXTRACT CORRECT PORTION OF TIME STRING 
C       FOR RANDOM GENERATOR:
	INTEGER   *2    NXT(4)
	CHARACTER *8    CNXT
	EQUIVALENCE     (NXT,CNXT)
	LOGICAL         ISDIGI,SIGN_TEST,LETTER_TEST

        DATA PI/3.141592654/
d91 1
a97 1
	IDOT_TEST = 0
d101 5
d112 3
a114 2
	IUMIN = 1
	CTEMP = EXPR(I:I)
d116 3
a118 2
C       REMOVE ALL SPACES
	IF (CTEMP .EQ. ' ' .OR. CTEMP .EQ. ',') THEN
d120 16
d138 14
a151 2
	IF (CTEMP.EQ.'(' .OR. CTEMP.EQ.')') THEN
           EXPR1(K:K) = EXPR(I:I)
d153 11
a164 1
        ENDIF
d166 2
a167 1
	IF (EXPR(I:I+1) .EQ. '**') THEN
d172 5
a176 1
        ENDIF
d181 3
d185 8
a192 4
        IF (CTEMP .GE. 'A') THEN

           IF (EXPR(I:I+2) .EQ. 'PAD') THEN
	      EXPR1(K:K) = 'a'
d196 13
a208 63

	   ELSEIF (EXPR(I:I+2) .EQ. 'SIN') THEN
              EXPR1(K:K) = 'b'
              K = K+1
              I = I+2
              GOTO 41

	   ELSEIF (EXPR(I:I+2) .EQ. 'EXP') THEN
              EXPR1(K:K) = 'c'
              K = K+1
              I = I+2
              GOTO 41

	   ELSEIF (EXPR(I:I+2) .EQ. 'LOG') THEN
              EXPR1(K:K) = 'd'
              K = K+1
              I = I+2
              GOTO 41

	   ELSEIF (EXPR(I:I+2) .EQ. 'COS') THEN
              EXPR1(K:K) = 'e'
              K = K+1
              I = I+2
              GOTO 41
	   
	   ELSEIF (EXPR(I:I+2) .EQ. 'SQR') THEN
              EXPR1(K:K) = 'f'
              K = K+1
              I = I+2
              GOTO 41

	   ELSEIF (EXPR(I:I+2) .EQ. 'MOD') THEN
              EXPR1(K:K) = 'g'
              K = K+1
              I = I+2
              GOTO 41
	   
	   ELSEIF (EXPR(I:I+2) .EQ. 'INT') THEN
              EXPR1(K:K) = 'h'
              K = K+1
              I = I+2
              GOTO 41

   	   ELSEIF (EXPR(I:I+2) .EQ. 'ABS') THEN
              EXPR1(K:K) = 'i'
              K = K+1
              I = I+2
              GOTO 41

	   ELSEIF (EXPR(I:I+2) .EQ. 'ATA') THEN
              EXPR1(K:K) = 'j'
              K = K+1
              I = I+2
              GOTO 41

	   ELSEIF (EXPR(I:I+2) .EQ. 'ASI') THEN
              EXPR1(K:K) = 'k'
              K = K+1
              I = I+2
              GOTO 41

	   ELSEIF (EXPR(I:I+2) .EQ. 'ACO') THEN
              EXPR1(K:K) = 'l'
a209 6
              I = I+2
              GOTO 41

	   ELSEIF (EXPR(I:I+1) .EQ. 'LN') THEN
              EXPR1(K:K) = 'm'
              K = K+1
d211 11
d223 1
a223 49
	   
	   ELSEIF (EXPR(I:I+2) .EQ. 'RAN') THEN
              EXPR1(K:K) = 'n'
              K = K+1
              I = I+2
              GOTO 41

	   ENDIF

	   IF (NRQ(CTEMP) .NE. -1 .AND. CTEMP .NE. '.'  .AND. 
     &        CTEMP      .NE. 'P'.AND. CTEMP .NE. ','  .AND.  
     &        CTEMP .NE. 'X' .AND. (.NOT. ISDIGI(CTEMP))) THEN
	      CALL ERRT(43,'POLISH',NE)
              RETURN
	   ENDIF
	ENDIF

C       CHECK FOR MINUS SIGN AT FIRST CHAR, OR A MINUS SIGN IN FIRST CHAR.
C       FOLLOWED BY A FUNCTION STRING, OR A OPERATION FOLLOWED BY A MINUS 
C       SIGN AND A "."
C       OR AN OPERATION FOLLOWED BY A MINUS SIGN, THEN AN X, THEN A DIGIT.

        IMINUS = 0
        IF (CTEMP .EQ. '-') THEN
C         A MINUS SIGN
          CTEMP1 = EXPR(I+1:I+1)
          CTEMM1 = EXPR(I-1:I-1)

          IF (
     &	      (I .EQ. 1) 
     &	         .OR. 
     &        (NRQ(CTEMM1) .EQ. -1 .AND. CTEMP1 .EQ. '.') 
     &            .OR. 
     &        (I .NE. 1 .AND. NRQ(CTEMM1) .EQ. -1 .AND.
     &           (ISDIGI(CTEMP1) .OR. CTEMP1 .EQ. 'P' .OR. 
     &            CTEMP1 .EQ. 'X'
     &            )
     &         )
     &        ) THEN

             IUMIN=-1
             I     = I + 1
	     IF (CTEMP1 .EQ.'.') THEN
		IMINUS = 2
	     ELSE	
		IMINUS = 1
	     ENDIF
	     IDOT_TEST = 1
             CTEMP = EXPR(I:I)
d226 6
a231 38
        ELSEIF (CTEMP .EQ. '+') THEN
C         A PLUS SIGN
          CTEMP1 = EXPR(I+1:I+1)
          CTEMM1 = EXPR(I-1:I-1)

          IF (
     &	      (I .EQ. 1) 
     &	         .OR. 
     &        (NRQ(CTEMM1) .EQ. -1 .AND. CTEMP1 .EQ. '.') 
     &            .OR. 
     &        (I .NE. 1 .AND. NRQ(CTEMM1) .EQ. -1 .AND.
     &           (ISDIGI(CTEMP1) .OR. CTEMP1 .EQ. 'P' .OR. 
     &            CTEMP1 .EQ. 'X'
     &            )
     &         )
     &        ) THEN

             I     = I + 1

	     IF (CTEMP1 .EQ. '.') THEN
		IMINUS = 2
	     ELSE	
		IMINUS = 1
	     ENDIF
	     IDOT_TEST = 1
             CTEMP = EXPR(I:I)
          ENDIF
        ENDIF
  
        IDOT = 0
        IF (CTEMP .EQ. '.') THEN
C          IS DECIMAL POINT 
           IDOT = 1
           I = I+1
 	   IDOT_TEST = 1
           IF (.NOT. ISDIGI(EXPR(I:I)) .AND. 
     &        EXPR(I:I) .NE. 'E') THEN
	      CALL ERRT(43,'POLISH',NE)
d233 3
a235 14
           ENDIF 

	ELSEIF (CTEMP.NE.'X'.AND. CTEMP.NE.'P'.AND. .NOT. ISDIGI(CTEMP)) THEN
C          IS NEITHER A DIGIT NOR AN X
           EXPR1(K:K) = EXPR(I:I)
           K          = K + 1
           GOTO 41

	ELSEIF (CTEMP .EQ. 'X') THEN
C          EVALUATE REGISTER
	   IF (ISDIGI(EXPR(I+1:I+1))) THEN
              READ(EXPR(I+1:I+1),30) IVAL
	   ELSE 
              CALL ERRT(43,'POLISH',NE)
d237 1
a237 1
           ENDIF
d239 1
a239 1
           IF (ISDIGI(EXPR(I+2:I+2))) THEN
d241 2
a242 1
             READ(EXPR(I+2:I+2),30) IVAL1
d245 2
a246 1
           ENDIF
d248 7
a254 2
           VAL(J) = PARAM(IVAL+1) * IUMIN
           WRITE(EXPR1(K:K),30) J
a258 13
           GOTO 41
 
        ELSEIF (CTEMP .EQ. 'P') THEN
C          PIXEL SUBSTITUTION PLACEHOLDER
           READ(EXPR(I+1:I+1),30) IVAL
	   IF (IVAL .NE. 1)  THEN
C             NEED BETTER ERROR HANDLING??
	      CALL ERRT(43,'POLISH',NE)
              RETURN
	   ENDIF
           VAL(J)      = 0.0
           NPIX        = NPIX + 1
           INDPL(NPIX) = J
d260 11
a270 6
           WRITE(EXPR1(K:K),30) J
           K = K+1
           I = I+1
           J = J+1
           GOTO 41
        ENDIF
d272 4
a275 2
C       MUST BE A DIGIT
        ITEMP3 = 0
d277 33
a309 49
C       PROCESSING A NUMBER IN A LOOP
	IF (IMINUS .EQ. 2) THEN
	    IBEGIN = I - 2
	    IE = 1
	ELSEIF (IMINUS .EQ. 1) THEN
	    IBEGIN = I - 1
	ELSEIF (IDOT .EQ. 1) THEN
	      IBEGIN = I - 1
	      IE = 1
      	ELSEIF ((IDOT .EQ. 0) .OR. (IMINUS .EQ. 0)) THEN
	      IBEGIN = I
	      IE = 0
	ENDIF

 23	IF ((I+1) .GT. NLET) GOTO 28

	IF (.NOT. ISDIGI(EXPR(I+1:I+1))) THEN
C          THIS DIGIT IS NOT FOLLOWED BY A ANOTHER DIGIT

           IF (EXPR(I+1:I+1) .EQ. 'E') THEN
	      IE = 1
	      IF (IDOT_TEST .EQ. 0) THEN
               CALL  ERRT(43,'POLISH',NE)
               RETURN
              ENDIF
C       REAL DATA IN SCIENTIFIC NOTATION
C             NUMBER CONTAINS EXPONTIAL NOTATION NOW
              IF((I+2) .LE. NLET .AND.(
     &           EXPR(I+2:I+2) .EQ. '-' .OR. 
     &           EXPR(I+2:I+2) .EQ. '+' .OR.
     &           ISDIGI(EXPR(I+2:I+2)))) THEN

	       IF ( (EXPR(I+2:I+2) .EQ. '-' .OR. 
     &              EXPR(I+2:I+2) .EQ. '+')
     &		    .AND. (.NOT. ISDIGI(EXPR(I+3:I+3)))) THEN
                    CALL   ERRT(43,'POLISH',NE)
		    ENDIF
C                HAS >= 1 DIGIT AFTER THE E
                 I       = I + 2
                 IEXPGO  = I 
                 DO WHILE (I+1 .LE. NLET .AND. ISDIGI(EXPR(I+1:I+1)))
                    I = I + 1
                 ENDDO
C                END OF DIGITS AFTER E, EVALUATE THE EXPONENT
               ELSE
		  CALL ERRT(43,'POLISH',NE)
                  RETURN
               ENDIF
	      GOTO 28
d311 2
a312 38
C       IF (EXPR(I+1:I+1) .EQ. 'E')
C          IF NOT A DECIMAL POINT THEN EVALUATE THE NUMBER NOW
           IF (EXPR(I+1:I+1) .NE. '.') GOTO 28
	       IE = 1
	       IDOT_TEST = 1
           IF (.NOT. ISDIGI(EXPR(I+2:I+2))) THEN

	      IF (EXPR(I+2:I+2) .EQ. 'E' ) THEN
C             CHAR. AFTER . IS NOT A DIGIT, EVALUATE THE NUMBER NOW

		 IF((I+3) .LE. NLET .AND.(
     &           EXPR(I+3:I+3) .EQ. '-' .OR. 
     &           EXPR(I+3:I+3) .EQ. '+' .OR.
     &           ISDIGI(EXPR(I+3:I+3)))) THEN

    		 IF ( (EXPR(I+3:I+3) .EQ. '-' .OR. 
     &              EXPR(I+3:I+3) .EQ. '+')
     &		    .AND. (.NOT. ISDIGI(EXPR(I+4:I+4)))) THEN
                    CALL   ERRT(43,'POLISH',NE)
                    RETURN
		 ENDIF

C                HAS >= 1 DIGIT AFTER THE E
                 I       = I + 2
                 IEXPGO  = I 
                 DO WHILE (I+1 .LE. NLET .AND. ISDIGI(EXPR(I+1:I+1)))
                    I = I + 1
                 ENDDO
C                END OF DIGITS AFTER E, EVALUATE THE EXPONENT
                 ELSE
                    I = I + 1
                 ENDIF

                ELSE
                   I = I + 1
                   GOTO 28
	      ENDIF

d314 1
a314 4
           I     = I + 2
           IF (.NOT. ISDIGI(EXPR(I:I))) GOTO 28
        ELSE
C          PROCESS NEXT DIGIT IN NUMBER
d316 20
a335 1
        ENDIF
a336 3
        GOTO 23

C       END OF NUMBER PROCESSING LOOP
d338 14
a351 7

 28	JCHAR = CHAR(J+48)
	EXPR1(K:K) = JCHAR
	IEND = I
	IS = IEND - IBEGIN + 1
	IF (IS .LE. 10) THEN
	   IF (IE .EQ. 0) THEN
d354 1
a354 1
	      READ(EXPR(IBEGIN:IEND),FRMT,IOSTAT=IER) ITEMP1
a355 4
	   ELSEIF (IE .EQ. 1) THEN
	      FRMT = "(F .1)"
	      WRITE(FRMT(3:3),"(I1)") IS
	      READ(EXPR(IBEGIN:IEND),FRMT,IOSTAT=IER) VAL(J)
d357 2
a358 2
	ELSE
	    IF (IE .EQ. 0) THEN
d361 1
a361 1
	      READ(EXPR(IBEGIN:IEND),FRMT,IOSTAT=IER) ITEMP1
d363 1
a363 1
	    ELSEIF (IE .EQ. 1) THEN
d366 8
a373 3
	      READ(EXPR(IBEGIN:IEND),FRMT,IOSTAT=IER) VAL(J)
	   ENDIF 
	ENDIF
d375 2
a376 2
	J = J+1
	K = K+1
d378 12
a389 1
 30	FORMAT(I1)
d391 5
a395 3
	IF (IER .NE. 0)  THEN
         CALL ERRT(43,'POLISH',NE)
         RETURN
d398 2
d403 1
d406 1
a406 1

d424 1
a424 1
           NVAL  = I
d446 1
a446 1
3        ELSE
@


1.9
log
@corrected for long numbers
@
text
@d14 1
a14 1
C  POLISH(EXPR,NLET,POLSH,NPOLISH,VAL,NVAL,INDPL,NPIX,IRTLFG))
a24 1
C       NPOLISH    NO. OF ELEMENTS IN POLISH                    (RETURNED)
d249 1
d258 1
a258 2
           ENDIF
        ENDIF
d260 1
a260 1
         IF (CTEMP .EQ. '+') THEN
d286 1
a286 1
           ENDIF
@


1.8
log
@New version, corrected
@
text
@d68 1
a68 1
        CHARACTER *6    FRMT
d516 1
a516 1
           NVAL   = I
@


1.7
log
@corrected
@
text
@d14 1
a14 1
C  POLISH(EXPR,NLET,POLSH,VAL,NVAL,INDPL,NPIX,IRTLFG))
d24 2
a25 1
C       NVAL       NO. OF ELEMENTS IN POLISH                 (RETURNED)
d68 1
d458 23
a480 6
	
	IF (IE .EQ. 0) THEN
	   READ(EXPR(IBEGIN:IEND),32,IOSTAT=IER) ITEMP1
	   VAL(J) = ITEMP1 
	ELSEIF (IE .EQ. 1) THEN
	   READ(EXPR(IBEGIN:IEND),33,IOSTAT=IER) VAL(J)
d485 1
a485 1
	
d487 1
a487 2
 32	FORMAT(I)
 33	FORMAT(F)
d545 1
@


1.6
log
@ipolen NOT polen for parameter
@
text
@d94 1
a96 2
	FRAC = 1.0
	NINT = 10
d100 1
d230 1
d232 9
a240 6
C          A MINUS SIGN
           CTEMP1 = EXPR(I+1:I+1)
           CTEMM1 = EXPR(I-1:I-1)
           IF ((I .EQ. 1) .OR. 
     &        (NM .NE. 0. AND. I .EQ. 5) .OR.
     &        (NRQ(CTEMM1) .EQ. -1 .AND. CTEMP1 .EQ. '.') .OR. 
d242 16
a257 2
     &        (ISDIGI(CTEMP1) .OR. CTEMP1 .EQ. 'P' .OR. 
     &        CTEMP1 .EQ. 'X'))) THEN
d259 26
a284 3
              I     = I + 1
              IUMIN = -1
              CTEMP = EXPR(I:I)
d287 2
a288 1

d291 5
a295 2
           I = I + 1
           IF (.NOT. ISDIGI(EXPR(I:I)) .AND. EXPR(I:I) .NE. 'E') THEN
d298 1
a298 3
	   ENDIF 
           FRAC  = 0.1
           NINT  = 1
d353 14
a366 4
 23     READ(EXPR(I:I),30) ITEMP
	VAL(J) = NINT * VAL(J) + ITEMP * FRAC
	IF (FRAC .NE. 1.) FRAC = FRAC / 10.
        IF ((I+1) .GT. NLET) GOTO 28
d372 6
d383 6
d396 5
a400 3
                 READ(EXPR(IEXPGO:I),*) ITEMP3    
              ELSE
                 I = I + 1
d402 1
a402 3
C             EVALUATE THE NUMBER NOW
              GOTO 28
           ENDIF
d405 3
d409 1
a409 1
           IF (.NOT. ISDIGI(EXPR(I+2:I+2))) THEN
d411 29
a439 2
              I = I + 1
              GOTO 28
a441 2
           FRAC  = 0.1
           NINT  = 1
d447 1
a448 2
C       END OF NUMBER PROCESSING LOOP -----------------------------

d450 1
a451 7
28	FRAC   = 1.
	NINT   = 10
	VAL(J) = VAL(J)*IUMIN
        IF (ITEMP3 .NE. 0) THEN
C          USE EXPONENTIAL VALUE HERE
           VAL(J) = VAL(J) * (10.0 ** ITEMP3)
        ENDIF
d453 10
a462 1
 	JCHAR = CHAR(J+48)
d464 3
d468 6
a473 3
	EXPR1(K:K) = JCHAR
	J          = J+1
	K          = K+1
a477 1

d479 1
d494 1
a526 2


@


1.5
log
@cleaned up logic & added comments
@
text
@d64 1
a64 1
        PARAMETER       (POLEN = 40)
d67 2
a68 2
	INTEGER         INDPL(POLEN)
	DIMENSION       VAL(POLEN)
@


1.4
log
@*** empty log message ***
@
text
@d3 1
a3 1
C EVALNQ.FOR                  ADAPTED FROM EVALN.FOR FOR CHAR AUG 89 AL
d6 6
a11 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
d13 16
a28 9
C       POLISH(EXPR,LEN,POLSH,VAL,COUNTER,INDPL,IL)
C       PURPOSE: PARSE INFIX EXPESSION INTO POSTFIX EXPESSION
C	EXPR:       A CHARACTER STRING CONTAINS A EXPRESSION
C	LEN:        LENGTH OF THE STRING
C	POLISH:     A CHARACTER STRING STORES POSTFIX EXPRESSION
C       VAL:        ARRAY STORES VALUES WHICH INDEX BY POLISH'S ELEMENTS
C       COUNTER:    HOW MANY ELEMENTS ON THE POLISH
C       INDPL:      INDEX FOR PIXEL VALUES
C       IL:         COUNTER FOR PIXEL VALUES
d31 16
a46 16
C FOR MATH FUNCTION
C             ARGUMENTS
C PAD -> a       
C SIN -> b
C EXP -> c
C LOG -> d
C COS -> e
C SQR -> f
C MOD -> g
C INT -> h
C ABS -> i
C ATA -> j
C ASI -> k
C ACO -> l 
C LN ->  m
C RAN -> n
d50 8
a57 5
C  12e+	
C       NOTE:         TO ADD A NEW MATH FUNCTION:
C                     1. LOOK FOR A COMMENT "ADD MORE MATH FUNCTIONS FOR PARSING"
C                     2. INSERT YOUR MATH FUNCTION FOR PARSING
C                     3. CHOOSE A SEQUENTIAL LETTER FOR SUBSTITUTING A MATH FUNCTION
d59 1
a59 1
	SUBROUTINE POLISH(EXPR,LEN,POLSH,VAL,COUNTER,INDPL,IL)
d62 9
a70 9
	COMMON /PARAM/  PARAM(103),NSEL(10)
        CHARACTER *80   FCHAR
	COMMON/FUNCTION/FCHAR
	INTEGER  INDPL(*)

	DIMENSION      VAL(40)
        CHARACTER *(*) EXPR
        CHARACTER *81  EXPR1,POLSH,STACK
        CHARACTER      CTEMP,NEXT,JCHAR,CTEMP1,CTEMM1
d74 6
a79 6
	INTEGER*2      NXT(4)
	CHARACTER*8    CNXT
	EQUIVALENCE    (NXT,CNXT)
	LOGICAL        GFLAG,ISDIGI,SIGN_TEST,LETTER_TEST
	INTEGER        COUNTER 
        DATA PI/3.141592654/,GFLAG/.FALSE./
d81 1
d83 4
a86 1
 	IL=0
d89 3
a91 3
          EXPR1(I:I)=' '
          STACK(I:I)=' '
          POLSH(I:I)=' '
d100 1
a100 1
C       -------------- loop ----------------------------------------
d102 1
a102 1
	IF (I .GT. LEN) GOTO 41
a111 1

d114 1
a114 1
           K = K + 1
a117 1
	
d135 1
a135 1
           GOTO 41
d141 1
a141 1
           GOTO 41
d147 1
a147 1
           GOTO 41
d153 1
a153 1
           GOTO 41
d159 1
a159 2
           GOTO 41

d165 1
a165 1
           GOTO 41
d171 1
a171 1
           GOTO 41
d177 1
a177 1
           GOTO 41
d183 1
a183 1
           GOTO 41
d189 1
a189 1
           GOTO 41
d195 1
a195 1
           GOTO 41
a196 1
	   
d201 1
a201 1
           GOTO 41
d207 1
a207 2
           GOTO 41

d213 1
a213 1
           GOTO 41
d215 1
a215 7
	ENDIF

	IF (NRQ(CTEMP) .NE. -1 .AND. CTEMP .NE. '.'  .AND. 
     &      CTEMP      .NE. 'P'.AND. CTEMP .NE. ','  .AND.  
     &      CTEMP .NE. 'X' .AND. (.NOT. ISDIGI(CTEMP))) THEN
	   CALL ERRT(43,'AR',NE)
	ENDIF
d217 6
d231 4
a234 4
C         A MINUS SIGN
          CTEMP1 = EXPR(I+1:I+1)
          CTEMM1 = EXPR(I-1:I-1)
          IF ((I .EQ. 1) .OR. 
d241 3
a243 3
             I     = I + 1
             IUMIN = -1
             CTEMP = EXPR(I:I)
d249 1
a249 1
           I = I+1
d251 3
a253 3
	      CALL ERRT(43,'AR',NE)
	      ENDIF 

d260 1
a260 1
           K = K + 1
d265 6
a270 5
	    IF (ISDIGI(EXPR(I+1:I+1))) THEN
	       READ(EXPR(I+1:I+1),30) IVAL
	    ELSE 
                CALL ERRT(43,'AR',NE)
            ENDIF
d275 1
a275 1
             IVAL = 10*IVAL+IVAL1
d279 1
a279 1
           VAL(J) = PARAM(IVAL+1)*IUMIN
d288 1
d290 8
a297 7
	IF(IVAL.NE.1)  THEN
C ERROR
	   CALL ERRT(43,'AR',NE)
	ENDIF
           VAL(J) = 0.0
		IL=IL+1
		INDPL(IL)=J
a299 1

d310 2
a311 2
 23      READ(EXPR(I:I),30) ITEMP
	VAL(J) = NINT*VAL(J)+ITEMP*FRAC
d313 1
a313 1
        IF ((I+1) .GT. LEN) GOTO 28
d320 1
a320 1
              IF((I+2) .LE. LEN .AND.(
d327 1
a327 1
                 DO WHILE (I+1 .LE. LEN .AND. ISDIGI(EXPR(I+1:I+1)))
d355 1
a355 1
C       END OF NUMBER PROCESSING LOOP
d367 1
a367 1
 	JCHAR = char(j+48)
d371 2
a372 2
	J = J+1
	K = K+1
d374 1
a374 2
41	IF (I .LT. LEN) GOTO 40
C       --------------------- end loop ------------------------
d376 2
d381 6
a386 6
	NCHAR2 = K+1
	IPNT  = 1
	ITOP  = 1
	STACK(1:1)='('
	IRANK = 0
	I     = 0
d391 3
a393 3
	    IF (ITOP.NE.0) THEN
	     CALL ERRT(43,'AR',NE)
	     ENDIF
d395 3
a397 1
           GOTO 13
a399 1

d401 3
a403 2
	   CALL ERRT(43,'AR',NE)
	     ENDIF
d406 15
a420 17

         IF (NFQ(NEXT).NE. NGQ(STACK(ITOP:ITOP))) THEN
             I = I + 1
             POLSH(I:I) = STACK(ITOP:ITOP)
             IRANK       = IRANK+NRQ(STACK(ITOP:ITOP))
             IF (IRANK .LE. 0)   THEN
		CALL ERRT(43,'AR',NE)	
	     ENDIF

             ITOP = ITOP - 1
             GOTO 7
          ENDIF
          ITOP = ITOP - 1

        ELSE
          ITOP = ITOP+1
          STACK(ITOP:ITOP) = NEXT
a421 1

a423 3

13	CONTINUE
	COUNTER = I
@


1.3
log
@*** empty log message ***
@
text
@d1 26
a26 4
C For val index
C ASCII(N) - ASCII(0) for N from 1 to Z on the ASCII table
C For math function
C             Arguments
d41 3
a43 4
C P1 -> p for pixel point
C The subroutine transform the expression from token to a single
C For example expression 43+COS(6) -> 1+e(2)
C convert from infix to postfix notation
a44 2
C computation

d46 3
a48 3
C                     1. look for a comment "ADD MORE MATH FUNCTIONS FOR PARSING"
C                     2. insert your math function for parsing
C                     3. choose a sequential letter for substituting a math function
a51 2
CNO_STATIC

d69 1
a69 1
	INTEGER COUNTER 
a113 9
C       IF CURRENT CHAR. IS NOT START OF OPERATOR STRING, AND IS NOT "X", AND 
C       IS NOT "," AND NOT "." AND IS NOT A DIGIT THEN RETURN

C		IF (NRQ(CTEMP) .NE. -1 .AND. CTEMP .NE. '.'  .AND. 
C     &      CTEMP      .NE. 'X'.AND. CTEMP .NE. ','  .AND.
C     &     (.NOT. ISDIGI(CTEMP))) RETURN
	


d118 1
a118 1
	IF (CTEMP .GE. 'A') THEN
d120 4
a123 4
      IF (EXPR(I:I+2) .EQ. 'PAD') THEN
           EXPR1(K:K) = 'a'
           K = K+1
           I = I+2
d126 4
a129 4
	ELSEIF (EXPR(I:I+2) .EQ. 'SIN') THEN
           EXPR1(K:K) = 'b'
           K = K+1
           I = I+2
d132 4
a135 4
	ELSEIF (EXPR(I:I+2) .EQ. 'EXP') THEN
           EXPR1(K:K) = 'c'
           K = K+1
           I = I+2
d138 4
a141 4
	ELSEIF (EXPR(I:I+2) .EQ. 'LOG') THEN
           EXPR1(K:K) = 'd'
           K = K+1
           I = I+2
d144 4
a147 4
	ELSEIF (EXPR(I:I+2) .EQ. 'COS') THEN
           EXPR1(K:K) = 'e'
           K = K+1
           I = I+2
d151 4
a154 4
	ELSEIF (EXPR(I:I+2) .EQ. 'SQR') THEN
           EXPR1(K:K) = 'f'
           K = K+1
           I = I+2
d157 4
a160 4
	ELSEIF (EXPR(I:I+2) .EQ. 'MOD') THEN
           EXPR1(K:K) = 'g'
           K = K+1
           I = I+2
d163 4
a166 4
	ELSEIF (EXPR(I:I+2) .EQ. 'INT') THEN
           EXPR1(K:K) = 'h'
           K = K+1
           I = I+2
d169 4
a172 4
   	ELSEIF (EXPR(I:I+2) .EQ. 'ABS') THEN
           EXPR1(K:K) = 'i'
           K = K+1
           I = I+2
d175 4
a178 4
	ELSEIF (EXPR(I:I+2) .EQ. 'ATA') THEN
           EXPR1(K:K) = 'j'
           K = K+1
           I = I+2
d181 4
a184 4
	ELSEIF (EXPR(I:I+2) .EQ. 'ASI') THEN
           EXPR1(K:K) = 'k'
           K = K+1
           I = I+2
d188 4
a191 4
	ELSEIF (EXPR(I:I+2) .EQ. 'ACO') THEN
           EXPR1(K:K) = 'l'
           K = K+1
           I = I+2
d194 4
a197 4
	ELSEIF (EXPR(I:I+1) .EQ. 'LN') THEN
           EXPR1(K:K) = 'm'
           K = K+1
           I = I+1
d201 4
a204 4
	ELSEIF (EXPR(I:I+2) .EQ. 'RAN') THEN
           EXPR1(K:K) = 'n'
           K = K+1
           I = I+2
d366 3
@


1.2
log
@*** empty log message ***
@
text
@a55 1
        IFLAG = -1
a259 2
	     ELSE 
              CALL ERRT(43,'AR',NE)
@


1.1
log
@Initial revision
@
text
@d205 1
a205 1
	   CALL ERRT(44,'VAR ERR',NE)
d236 1
a236 1
	      CALL ERRT(45,'DIG ERR',NE)
d253 1
a253 1
                CALL ERRT(46,'REG ERR',NE)
d262 1
a262 1
              CALL ERRT(46,'REG ERR',NE)
a263 4
C	   IF ((NRQ(EXPR(I+3:I+3)) .NE. -1) .OR. 
C     &      (EXPR(I+3:I+3) .NE. ' ')) THEN
C	       CALL ERRT(46,'REG ERR',NE)
C	       ENDIF
d277 1
a277 1
	   CALL ERRT(46,'PIX ERR',NE)
d373 1
a373 1
	     CALL ERRT(47,'MIS PAR',NE)
d381 1
a381 1
	   CALL ERRT(47,'MIS PAR',NE)
d391 1
a391 1
		CALL ERRT(48,'OP ERR',NE)	
@
