head	1.66;
access;
symbols
	healthdept_2018:1.66
	pre_getangas:1.56
	GPL2010:1.55
	pre_GPL2010:1.54
	pre_var_equation:1.53
	pre_fftwrings:1.53
	pre_opfiles:1.53
	src:1.53
	best-code:1.53
	named-reg:1.53
	x-named-regs:1.52
	x:1.52
	v13-00:1.51
	pre_GPL:1.49
	prec_CA:1.44
	noindx:1.43
	Bproc:1.30
	oct21:1.29
	last77:1.24;
locks; strict;
comment	@c @;


1.66
date	2018.10.03.14.34.05;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2015.12.11.16.34.56;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2015.12.11.16.32.18;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2012.09.20.13.16.20;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2012.01.19.20.21.10;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2012.01.19.16.45.34;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2012.01.18.15.05.18;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2011.12.06.14.20.22;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2011.12.06.14.00.01;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2011.06.22.15.49.11;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2011.01.03.14.07.59;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2010.06.24.13.25.36;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.26.13.59.29;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.12.15.27.24;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.15.21.50.53;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.17.20.36.53;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2005.10.17.18.27.20;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.07.14.55.49;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.15.14.13.16;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2004.04.06.15.56.07;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.05.14.27.20;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2003.11.24.17.25.14;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.04.13.08.22;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2002.09.30.15.35.48;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.07.17.17.04;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.06.12.40.45;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.04.18.51.30;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.14.15.15.51;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.09.14.25.02;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.28.16.54.32;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.22.14.28.22;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2001.01.23.15.09.58;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.08.20.29.49;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.08.18.14.15;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.27.16.05.41;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.08.14.47.50;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	99.11.16.15.59.00;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	99.10.19.18.35.27;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	99.09.15.15.07.03;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	99.09.13.16.12.09;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	99.09.13.14.52.08;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	99.08.03.13.43.38;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	99.02.17.19.39.00;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	99.02.16.13.41.15;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	99.02.11.16.07.05;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	98.02.12.18.11.11;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	98.02.12.17.41.32;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	98.02.06.15.10.24;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	97.11.19.16.14.02;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	97.10.06.20.43.36;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	97.07.24.16.22.12;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	97.07.10.15.53.58;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	97.07.07.19.08.22;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	97.06.27.17.48.32;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	97.06.26.15.44.22;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	97.05.14.16.08.55;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	97.01.27.18.55.39;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	97.01.06.18.37.36;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	96.09.19.18.27.40;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	96.07.12.19.29.48;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	95.03.06.15.42.06;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	95.01.05.14.02.03;	author mladjadj;	state Exp;
branches;
next	1.4;

1.4
date	94.10.31.12.14.38;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	94.05.17.13.00.17;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.05.06;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.48.47;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.66
log
@email_health_dept
@
text
@
C++*********************************************************************
C
C FILERD.F   ADAPTED FROM FILRD AND SPFILE         OCT 88 ARDEAN LEITH
C            REWRITTEN FOR NEW SUBSTITUTION        JUN 97 ARDEAN LEITH
C            ADDS EXTEN NOW IF SENT                FEB 99 ARDEAN LEITH
C            CAN USE PROMPT FOR INPUT --           AUG 99 ARDEAN LEITH
C            REMOVED AVGX11 & AVG0I RULES --       SEP 99 ARDEAN LEITH
C            TRAILING ~ ON PROMPT OMITS "FILE"     NOV 00 ARDEAN LEITH
C            $ EFFECTIVE NOW IF ONLY 1 CHAR.       JAN 01 ARDEAN LEITH
C            ALTERED COMMENT HANDLING              JAN 01 ARDEAN LEITH
C            ALTERED COMMENT HANDLING              MAR 02 ARDEAN LEITH
C            NLOG                                  NOV 03 ARDEAN LEITH
C            REMOVED IRTFLG INPUT                  APR 04 ARDEAN LEITH
C            TEMPLATTING CAPABILITY                DEC 04 ARDEAN LEITH
C            RDPR PARAMETERS                     04/14/05 ARDEAN LEITH
C            RDPR IRTFLG FOR LEGACY REGS         06/24/09 ARDEAN LEITH
C            PROMPT(LENP-2:LENP) .EQ. '~9~'      12/07/10 ARDEAN LEITH
C            ACCEPT EXTENSION BUG                  JUN 11 ARDEAN LEITH 
C            ! COMMENT DELIMITER                   DEC 11 ARDEAN LEITH
C            NECHO                                 SEP 12 ARDEAN LEITH
C            FILENAME ECHO FORMATTING 2 BLANKS     DEC 15 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  FILERD(FILN,NLET,EXTEN,PROMPT,IRTFLG)
C
C  PARAMETERS:  FILN    CHARACTER ARRAY FOR FILE NAME           (RET.)
C               NLET    NO. OF CHARACTERS IN FILE NAME          (RET.)
C               EXTENT  OPTIONAL FILE NAME EXTENSION            (SENT)
C                       AN INPUT EXTENSION SUPERCEDES THIS
C                       PARAMETER
C               PROMPT  FILE NAME SOLICITATION PROMPT           (SENT)
C                       A ~ (TILDE) IN FIRST CHAR. SAYS USE
C                       PROMPT INSTEAD OF INPUT
C                       A ~ (TILDE) IN LAST CHAR. SAYS SKIP
C                         "FILE" AT END OF PROMPT
C                       A ~9  IN NEXT TO LAST OR 
C                          NEXT-TO-NEXT-TO LAST
C                          ACCEPTS AN EXTENSION 
C                          (OTHERWISE DISCARDED!)
C               IRTFLG  ERROR FLAG, ZERO IS NORMAL          (SENT/RET.)
C
C  PURPOSE:     READS IN FILE NAME AND TITLE.  CAN
C               SUBSTITUTE REGISTERS AND DO LOOP INDICES INTO
C               CERTAIN FILENAME
C               
C  DESCRIPTION: PRINTS OUT <PROMPT> MESSAGE:,
C               READS IN FILE NAME FROM INPUT DEVICE. 
C               SUBSTITUTES FOR REGISTER AND LOOP INDEX. 
C               EXAMPLES IF (X0 = 1, X11=11, X21=1111, INDEX:A=44)
C
C                   avg{***A }  ---> avg044
C                   avg{**A }   ---> avg44
C                   avg{***x0}  ---> avg001
C                   avg{****x0} ---> avg0001
C                   avg{****}   ---> avg****
c                   avg{***x21} ---> ERROR (DAMAGES INVARIANT PART OF 
C                                    FILE NAME)
C
C               IF THE FIRST CHARACTER IS A '$', FILNAM FROM PREVIOUS 
C               CALL REMAINS UNCHANGED.  
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE FILERD(FILN,NLET,EXTENT,PROMPT,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        CHARACTER(LEN=*)      :: FILN,EXTENT,PROMPT
        INTEGER               :: NLET,IRTFLG

        CHARACTER(LEN=MAXNAM) :: EXTEN,COMMENT
        CHARACTER(LEN=160)    :: FILNAM,RESPONSE
        CHARACTER(LEN=100)    :: PROMPTP
        CHARACTER(LEN=1)      :: JCHAR
        LOGICAL               :: NOX,EXTENOK,GOTEX
        LOGICAL               :: ISDIGI,ISCHAR,GETANS,STRIP,LEGACYREGS
        LOGICAL               :: UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI
 
        CHARACTER(LEN=1)      :: NULL = CHAR(0)
        INTEGER               :: ICOMM,MYPID,MPIERR,LENP

        CALL SET_MPI(ICOMM,MYPID,MPIERR)

        LEGACYREGS = (IRTFLG == -999)  ! CONVERT x**
  
        LENP = LNBLNKN(PROMPT)

C       '~9' IN LAST 3 CHAR. OF PROMPT INDICATES THAT EXTENSION CAN 
C       BE READ IN ON NAME (USED TO BE IRTFLG == 9)
        EXTENOK = .FALSE.
        IF (PROMPT(LENP-1:LENP-1) == '~' .OR.
     &      PROMPT(LENP-2:LENP-2) == '~') THEN
           EXTENOK = .TRUE.
           LENP    = LENP - 2
        ENDIF
      
C       SET ERROR RETURN
        IRTFLG = 1

        IF (PROMPT(:1) == '~') THEN
C          DO NOT SOLICIT NAME, INSTEAD USE PROMPT FOR: FILN 
           FILNAM   = PROMPT(2:LENP)
           NLET     = LENP - 1
           IRTFLGT  = 0

        ELSE
C          READ THE FILE NAME FROM THE INPUT, DO NOT UPPERCASE IT!
C          THIS WILL FAIL IF PROMPT > 96 CHAR!!!        
           LENU = MIN(96,LENP)
           IF (PROMPT(LENU:LENU) == '~') THEN
C             DO NOT ADD "FILE" TO PROMPT
              LENU    = LENU - 1
              PROMPTP = PROMPT(1:LENU) 
           ELSE
              PROMPTP = PROMPT(1:LENU) // ' FILE' 
              LENU    = LENU + 5
           ENDIF

           GETANS    = .TRUE.
           UPPER     = .FALSE.
           WANTSUB   = .TRUE.
           SAYPRMT   = .NOT. SILENT
           SAYANS    = .FALSE.
           ENDATSEMI = .TRUE.
           STRIP     = .TRUE.
           IRTFLGT   = 0
           IF (.NOT. LEGACYREGS) IRTFLGT   = -999  ! DO NOT CONVERT x**
           CALL RDPR(PROMPTP(1:LENU),NLET,FILNAM,GETANS,
     &             UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI,STRIP,IRTFLGT)
        ENDIF

        IF (NLET <= 0 .OR. IRTFLGT .NE. 0) THEN
C          NO FILE NAME IN INPUT LINE
           IRTFLG = -1
           RETURN
        ENDIF

C       REPLACE ANY TAB CHARACTERS WITH BLANKS
        ITAB = INDEX(FILNAM,CHAR(9))
        DO WHILE (ITAB > 0)
           FILNAM(ITAB:ITAB) = ' '
           ITAB = INDEX(FILNAM,CHAR(9))
        ENDDO
   
C       REMOVE ANY INITIAL BLANKS
        FILNAM = ADJUSTL(FILNAM)

C       SAVE ANY TRAILING COMMENT FROM THE INPUT LINE
        ISEMI = SCAN(FILNAM,';!')

        IF (ISEMI > 1) THEN
            NLET    = LNBLNKN(FILNAM(1:ISEMI-1)) 
            FILNAM  = FILNAM(1:NLET)
            COMMENT = FILNAM(NLET+1:)
            NLETC   = LNBLNKN(COMMENT)
        ELSE
            NLETC   = 0
            NLET    = LNBLNKN(FILNAM)
        ENDIF

        IF (FILNAM(:1) == '?') THEN
C          ?PROMPT? [var] LINE RETURNED, READ RESPONSE FROM CALLER
C          SUBSTITUTE FOR SYMBOLS & REG. FROM CALLING PROCEDURE
           CALL FRSYMPAR(FILNAM(1:NLET),FILNAM,NLET,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ENDIF

        IF (FILNAM(1:NLET) == '$') THEN
C          DO NOT ALTER FILN  IF INPUT IS "$"
           CALL ECHONAME(FILNAM,NLET,COMMENT,NLETC,MYPID)
           IRTFLG = 0
           RETURN 
   
        ELSEIF (FILNAM(1:1) == '^' .OR. FILNAM(1:1) == '*') THEN
C          RETURN IF  INPUT IS "^" OR "*"
           FILN(1:) = FILNAM(1:1)
           CALL ECHONAME(FILN,NLET,COMMENT,NLETC,MYPID)
           IRTFLG = -1
           RETURN

        ENDIF

C       REMOVE ANY EXTENSION FROM THE FILENAME (UNLESS IT IS WANTED)
        J      = NLET
        GOTEX  = .FALSE.
        DO WHILE (J >= 1 )
           JCHAR = FILNAM(J:J)

           IF (JCHAR == ' ') THEN
C             DISCARD THIS TRAILING BLANK (or embedded blank!)
              NLET = J - 1

           ELSEIF (JCHAR == ']' .OR. 
     &             JCHAR == ':'  .OR. 
     &             JCHAR == '/' ) THEN
C             BEGINNING OF DEVICE OR DIRECTORY, HALT EXTENSION SEARCH
              EXIT

           ELSEIF (JCHAR == '.') THEN
              IF (EXTENOK) THEN
C                WANT TO USE INPUTTED FILE EXTENSION
                 IEXT  = J + 1    ! MAY HAVE > 1 EXTENSION
                 GOTEX = .TRUE.
              ENDIF
           ENDIF
           J = J - 1
        ENDDO

        IF (GOTEX) THEN
C           RECEIVED EXTENSION ON INPUT LINE
            EXTEN = FILNAM(IEXT:NLET) // NULL
            NLET  = IEXT - 2  
        ENDIF

        IF (NLET <= 0) THEN 
           CALL ERRT(101,'*** ABNORMAL FILENAME',NE)
           IRTFLG = 1
           RETURN
        ENDIF

        ILEN = LEN(FILN)
        IF (NLET >= ILEN) THEN
           WRITE(NOUT,*) 'FILENAME: ',FILNAM(1:NLET)
           CALL ERRT(102,'FILENAME TOO LONG, MUST BE < ',ILEN)
           IRTFLG = 1
           RETURN
        ENDIF
        FILN = FILNAM(1:NLET) // NULL

C       USE SENT EXTENSION IF NOT NULL AND NO EXTENSION INPUT AND OK
        LENET = LNBLNKN(EXTENT)
        IF (.NOT. GOTEX) EXTEN = NULL
        IF (LENET > 0 .AND. .NOT. GOTEX) EXTEN = EXTENT

        LENE = LNBLNKN(EXTEN)    ! LENGTH OF EXTENSION TO BE APPENDED 
        
        !WRITE(6,*) ' exten1:',lene,':',exten(1:4)

        IF (LENE <= 0) THEN
C          DO NOT PUT ANY EXTENSION AT END OF FILE NAME, ECHO NAME
           CALL ECHONAME(FILN,NLET,COMMENT,NLETC,MYPID)

        ELSE
C          PUT EXTENSION (SENT OR INPUT) AT END OF FILE NAME
           IF (LENE + NLET > LEN(FILN)) THEN
              NLET = NLET + LENE + 1
              CALL ERRT(102,'FILENAME TOO LONG',NLET)
              IRTFLG = 1
              RETURN
           ENDIF

           IF (EXTEN(1:LENE) == DATEXC(1:3)) THEN
C             USES STANDARD SPIDER EXTENSION, DO NOT ECHO IT
              CALL ECHONAME(FILN,NLET,COMMENT,NLETC,MYPID)
           ENDIF

           FILN = FILN(1:NLET) // '.' // EXTEN(1:LENE) // NULL
           NLET = NLET + LENE + 1
           IF (EXTEN(1:LENE) /= DATEXC(1:3)) THEN
C             USES NON-STANDARD SPIDER EXTENSION, ECHO IT
              CALL ECHONAME(FILN,NLET,COMMENT,NLETC,MYPID)
           ENDIF
        ENDIF

C       SET NORMAL ERROR RETURN
        IRTFLG = 0

        END



        SUBROUTINE ECHONAME(FILN,NLET,COMMENT,NLETC,MYPID)

        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC'

        CHARACTER(LEN=*)      :: FILN
        INTEGER               :: NLET
        CHARACTER(LEN=*)      :: COMMENT
        INTEGER               :: NLETC,MYPID
 
        IF (NLETC > 0 .AND. MYPID <= 0) THEN

           IF (.NOT. SILENT)
     &        WRITE(NOUT,93)FILN(1:NLET),COMMENT(1:NLETC)
           IF (NLOG .NE. 0) THEN
              WRITE(NLOG,93) FILN(1:NLET),COMMENT(1:NLETC)
              NECHO = NECHO + 1
          ENDIF

93        FORMAT('  ',A,' ',A)

       ELSEIF (MYPID <= 0) THEN
          IF (.NOT. SILENT) WRITE(NOUT,93) FILN(1:NLET)
          IF (NLOG .NE. 0) THEN
             WRITE(NLOG,93) FILN(1:NLET)
             NECHO = NECHO + 1
          ENDIF
       ENDIF

       END
@


1.65
log
@typo
@
text
@d30 1
a30 1
C=* Email: spider@@wadsworth.org                                        *
@


1.64
log
@FILENAME ECHO FORMATTING 2 BLANKS
@
text
@d309 2
a310 1
           IF (.NOT. SILENT) WRITE(NOUT,93) FILN(1:NLET),COMMENT(1:NLETC)
@


1.63
log
@necho
@
text
@d22 1
d28 1
a28 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d87 1
a87 1
	SUBROUTINE FILERD(FILN,NLET,EXTENT,PROMPT,IRTFLG)
d192 1
a192 1
	IF (FILNAM(1:NLET) == '$') THEN
d194 1
a194 1
	   CALL ECHONAME(FILNAM,NLET,COMMENT,NLETC,MYPID)
d201 1
a201 1
	   CALL ECHONAME(FILN,NLET,COMMENT,NLETC,MYPID)
d296 1
a296 1
	SUBROUTINE ECHONAME(FILN,NLET,COMMENT,NLETC,MYPID)
d309 5
a313 5
          IF (.NOT. SILENT) WRITE(NOUT,93) FILN(1:NLET),COMMENT(1:NLETC)
          IF (NLOG .NE. 0) THEN
             WRITE(NLOG,93) FILN(1:NLET),COMMENT(1:NLETC)
             NECHO = NECHO + 1
         ENDIF
d315 1
a315 1
93        FORMAT(' ',A,' ',A)
d317 1
a317 1
        ELSEIF (MYPID <= 0) THEN
d320 4
a323 4
            WRITE(NLOG,93) FILN(1:NLET)
            NECHO = NECHO + 1
         ENDIF
        ENDIF
d325 1
a325 1
        END
@


1.62
log
@ECHONAME for LOG file echo extension bug
@
text
@d21 1
d27 1
a27 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d308 6
a313 2
          IF (.NOT. SILENT)WRITE(NOUT,93) FILN(1:NLET),COMMENT(1:NLETC)
          IF (NLOG .NE. 0) WRITE(NLOG,93) FILN(1:NLET),COMMENT(1:NLETC)
d317 5
a321 2
          IF (.NOT. SILENT)WRITE(NOUT,93) FILN(1:NLET)
          IF (NLOG .NE. 0) WRITE(NLOG,93) FILN(1:NLET)
@


1.61
log
@ge >=
@
text
@d90 3
a92 1
        CHARACTER(LEN=*)      :: FILN,PROMPT,EXTENT
d102 1
a159 3
C       write(nout,*)' '
        !write(6,*)'input:      ',filnam(1:nlet)

d187 1
d191 2
a192 1
C          DO NOT ALTER FILNAM IF INPUT IS "$"
d194 1
a194 1
           GOTO 999 
d199 3
a201 2
           IRTFLG   = -1
           GOTO 999
d239 1
d247 1
d257 7
a263 1
        LENE = LNBLNKN(EXTEN)
d265 3
a267 9
        IF (LENE > 0) THEN
C          ADD EXTENSION (SENT OR INPUT) ON BACK OF FILE NAME

           IF (LENE + NLET <= LEN(FILN)) THEN
              FILN = FILN(1:NLET) // '.' // EXTEN(1:LENE) // NULL
              NLET = NLET + LENE + 1
              !write(6,*) 'nlet:',nlet,filn(1:nlet)

           ELSE
d270 1
d273 12
d290 16
a305 1
999     IF (NLETC > 0 .AND. MYPID <= 0) THEN
a315 1
        RETURN
a316 2


@


1.60
log
@no blank before NLOG output
@
text
@d65 1
a65 1
C
d94 1
a94 1
        CHARACTER(LEN=1)      :: NULL,JCHAR
d99 2
d103 1
a103 1
        LEGACYREGS = (IRTFLG .EQ. -999)  ! CONVERT x**
a104 2
        NULL = CHAR(0)

d110 2
a111 2
        IF (PROMPT(LENP-1:LENP-1) .EQ. '~' .OR.
     &      PROMPT(LENP-2:LENP-2) .EQ. '~') THEN
d119 1
a119 1
        IF (PROMPT(:1) .EQ. '~') THEN
d129 1
a129 1
           IF (PROMPT(LENU:LENU) .EQ. '~') THEN
d151 1
a151 1
        IF (NLET .LE. 0 .OR. IRTFLGT .NE. 0) THEN
d162 1
a162 1
        DO WHILE (ITAB .GT. 0)
d183 1
a183 1
        IF (FILNAM(:1) .EQ. '?') THEN
d189 1
a189 1
	IF (FILNAM(1:NLET) .EQ. '$') THEN
d194 1
a194 1
        ELSEIF (FILNAM(1:1) .EQ. '^' .OR. FILNAM(1:1) .EQ. '*') THEN
d205 1
a205 1
        DO WHILE (J .GE. 1 )
d208 1
a208 1
           IF (JCHAR .EQ. ' ') THEN
d212 3
a214 2
           ELSEIF (JCHAR .EQ. ']' .OR. 
     &             JCHAR .EQ. ':' .OR. JCHAR .EQ. '/' ) THEN
d218 1
a218 1
           ELSEIF (JCHAR .EQ. '.') THEN
d234 1
a234 1
        IF (NLET .LE. 0) THEN 
d240 1
a240 1
        IF (NLET .GE. ILEN) THEN
d250 1
a250 1
        IF (LENET .GT. 0 .AND. .NOT. GOTEX) EXTEN = EXTENT
d254 1
a254 1
        IF (LENE .GT. 0) THEN
d257 1
a257 1
           IF (LENE + NLET .LE. LEN(FILN)) THEN
d271 3
a273 1
999     IF (NLETC .GT. 0 .AND. MYPID .LE. 0) THEN
d278 1
a278 1
        ELSEIF (MYPID .LE. 0) THEN
@


1.59
log
@scan on isemi
@
text
@d273 1
a273 1
93        FORMAT('  ',A,' ',A)
@


1.58
log
@! COMMENT DELIMITER
@
text
@d171 1
a171 3
        ISEMI = INDEX(FILNAM,';')
        IEXCL = INDEX(FILNAM,'!')
        ISEMI = MIN(ISEMI,IEXCL)
@


1.57
log
@ADD EXTENSION (SENT OR INPUT) ON BACK OF FILE
@
text
@d4 17
a20 16
C FILERD.F   ADAPTED FROM FILRD AND SPFILE OCT 88      ARDEAN LEITH
C            REWRITTEN FOR NEW SUBSTITUTION JUNE 97    ARDEAN LEITH
C            ADDS EXTEN NOW IF SENT -- FEB 99          ARDEAN LEITH
C            CAN USE PROMPT FOR INPUT -- AUG 99        ARDEAN LEITH
C            REMOVED AVGX11 & AVG0I RULES -- SEPT 99   ARDEAN LEITH
C            TRAILING ~ ON PROMPT OMITS "FILE"  NOV 00 ARDEAN LEITH
C            $ EFFECTIVE NOW IF ONLY 1 CHAR.    JAN 01 ARDEAN LEITH
C            ALTERED COMMENT HANDLING           JAN 01 ARDEAN LEITH
C            ALTERED COMMENT HANDLING           MAR 02 ARDEAN LEITH
C            NLOG                               NOV 03 ARDEAN LEITH
C            REMOVED IRTFLG INPUT               APR 04 ARDEAN LEITH
C            TEMPLATTING CAPABILITY             DEC 04 ARDEAN LEITH
C            RDPR PARAMETERS                  04/14/05 ARDEAN LEITH
C            RDPR IRTFLG FOR LEGACY REGS      06/24/09 ARDEAN LEITH
C            PROMPT(LENP-2:LENP) .EQ. '~9~'   12/07/10 ARDEAN LEITH
C            ACCEPT EXTENSION BUG               JUN 11 ARDEAN LEITH *
d172 4
a175 1
        IF (ISEMI .GT. 1) THEN
@


1.56
log
@~9 logic changed
@
text
@d19 1
d25 1
a25 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d94 1
a94 1
        LOGICAL               :: NOX,EXTENOK,GOTEX,KEEPGO
d157 2
a158 1
C       write(nout,*)'input:      ',filnam(1:nlet)
a200 1
        KEEPGO = .TRUE.
d203 1
a203 1
        DO WHILE (J .GE. 1 .AND. KEEPGO)
d207 1
a207 1
C             DISCARD THIS TRAILING BLANK
d211 1
a211 1
     &            JCHAR .EQ. ':' .OR. JCHAR .EQ. '/' ) THEN
d213 1
a213 1
              KEEPGO = .FALSE.
d218 1
a218 1
                 EXTEN = FILNAM(J+1:NLET) // NULL
a220 1
              NLET  = J - 1
d225 6
a235 3

C       write(nout,*) 'final:      ',filnam(1:nlet),' : ',nlet

d250 1
d252 1
a252 1
C          ADD EXTENSION ON BACK OF FILE NAME
d257 2
d272 1
@


1.55
log
@GPL_2010
@
text
@d18 1
d44 2
a45 2
C  PARAMETERS:  FILN    CHARACTER ARRAY FOR FILE NAME       (RETURNED)
C               NLET    NO. OF CHARACTERS IN FILE NAME      (RETURNED)
d53 6
a58 4
C                       "FILE" AT END OF PROMPT
C                       A ~ (TILDE) IN NEXT TO LAST CHAR. SAYS 
C                       FILERD ACCEPTS AN EXTENSION OTHERWISE DISCARDED!
C               IRTFLG  ERROR FLAG, ZERO IS NORMAL     (SENT/RETURNED)
d105 1
a105 1
C       '~9' ON LAST 2 LETTERS OF PROMPT SAYS THAT EXTENSION CAN 
d108 2
a109 1
        IF (PROMPT(LENP-1:LENP) .EQ. '~9') THEN
d118 1
a118 1
C          USE PROMPT FOR INPUT LINE
@


1.54
log
@x11 in filenames by irtflg
@
text
@a19 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
d21 5
a25 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d27 1
a27 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d32 1
a32 1
C=* This program is distributed in the hope that it will be useful,    *
d34 1
a34 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a35 1
C=*                                                                    *
d37 1
a37 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.53
log
@native named registers
@
text
@d17 1
d21 1
a21 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d95 1
a95 1
        LOGICAL               :: ISDIGI,ISCHAR,GETANS,STRIP
d98 1
a98 7
#ifdef USE_MPI
        include 'mpif.h'
        icomm = mpi_comm_world
        call mpi_comm_rank(icomm, mypid,  ierr)
#else
        mypid = -1
#endif
d100 3
a102 1
        NULL   = CHAR(0)
d143 2
a144 1

@


1.52
log
@named register support.f
@
text
@d90 1
a90 1
        CHARACTER(LEN=160)    :: FILNAM
d94 1
a94 1
        LOGICAL               :: ISDIGI,ISCHAR,GETANS
d139 1
d141 1
d143 1
a143 2
           WANTSUB   = .TRUE.
           SAYANS    = (FCHAR(1:10) .EQ. '.OPERATION')
d145 1
a145 1
           GETANS    = .TRUE.
d148 1
a148 1
     &               UPPER,WANTSUB,SAYPRMT,SAYANS,ENDATSEMI, IRTFLGT)
d181 6
a231 56
C       CHECK FOR TEMPLATING SUBSTITUTION (ABC***x#)
        ILEFAST = INDEX(FILNAM(1:NLET),'*')
        ILEFMIN = INDEX(FILNAM(1:NLET),'-')
        IRITAST = 0

        IF (ILEFAST .GT. 0 .AND. ILEFAST .LT. (NLET -1)) THEN
C          FIND RIGHT AST
           J = ILEFAST  
           DO WHILE (J .LT. NLET .AND. FILNAM(J:J) .EQ. '*')
              IRITAST = J
              J       = J + 1 
           ENDDO
        ELSEIF (ILEFMIN .GT. 0 .AND. ILEFMIN .LT. (NLET -1)) THEN
C          FIND RIGHT -
           ILEFAST = ILEFMIN
           J       = ILEFMIN  
           DO WHILE (J .LT. NLET .AND. FILNAM(J:J) .EQ. '-')
              IRITAST = J
              J       = J + 1 
           ENDDO
        ENDIF

        IF (IRITAST .GT. 0) THEN
C           SUBSTITUTE X#... FOR ***X#...
            IF ((FILNAM(IRITAST+1:IRITAST+1) .EQ. 'x'  .OR.
     &           FILNAM(IRITAST+1:IRITAST+1) .EQ. 'X') .AND.
     &           ISDIGI(FILNAM(IRITAST+2:IRITAST+2))) THEN

C                SUBSTITUTE NOW
                 IRITNUM = IRITAST+2
                 J       = IRITNUM 
                 DO WHILE (J .LE. NLET .AND. ISDIGI(FILNAM(J:J)))
                    IRITNUM = J
                    J = J + 1
                 ENDDO
                 IF (ILEFAST .GT. 1) THEN
                    FILNAM = FILNAM(1:ILEFAST-1) // '{' //  
     &                       FILNAM(ILEFAST:IRITNUM) // '}' //
     &                       FILNAM(IRITNUM+1:NLET) // NULL
                 ELSE
                    FILNAM = '{' //  
     &                       FILNAM(ILEFAST+1:IRITNUM) // '}' //
     &                       FILNAM(IRITNUM+1:NLET) // NULL
                 ENDIF

                 NLET = LNBLNKN(FILNAM)
C                write(nout,*) 'templated: ',filnam(1:NLET)
            ENDIF
        ENDIF

C       write(nout,*) 'evaluating: ',filnam(1:nlet)

C       SUBSTITUTE FOR STRINGS WITHIN {...} PORTION(S) OF THE FILE NAME
C       ALREADY DONE IN RDPR BUT MAY HAVE ADDED NEW {} FROM TEMPLATE
        CALL FILNAMSUB(FILNAM,NLET,.FALSE.,0,IRTFLGT)
        IF (IRTFLGT .NE. 0) RETURN
d267 1
a267 1
93        FORMAT('  ',A,A)
@


1.51
log
@GPL License fixed
@
text
@d16 1
d42 1
a42 1
C ********************************************************************C
d44 1
a44 1
C    FILERD(FILN,NLET,EXTEN,PROMPT,IRTFLG)
d46 13
a58 13
C    PARAMETERS:  FILN    CHARACTER ARRAY FOR FILE NAME       (RETURNED)
C                 NLET    NO. OF CHARACTERS IN FILE NAME      (RETURNED)
C                 EXTENT  OPTIONAL FILE NAME EXTENSION            (SENT)
C                         AN INPUT EXTENSION SUPERCEDES THIS
C                         PARAMETER
C                 PROMPT  FILE NAME SOLICITATION PROMPT           (SENT)
C                         A ~ (TILDE) IN FIRST CHAR. SAYS USE
C                         PROMPT INSTEAD OF INPUT
C                         A ~ (TILDE) IN LAST CHAR. SAYS SKIP
C                         "FILE" AT END OF PROMPT
C                         A ~ (TILDE) IN NEXT TO LAST CHAR. SAYS 
C                         FILERD ACCEPTS AN EXTENSION OTHERWISE DISCARDED!
C                 IRTFLG  ERROR FLAG, ZERO IS NORMAL     (SENT/RETURNED)
d60 3
a62 3
C    PURPOSE:     READS IN FILE NAME AND TITLE.  CAN
C                 SUBSTITUTE REGISTERS AND DO LOOP INDICES INTO
C                 CERTAIN FILENAME
d64 4
a67 4
C    DESCRIPTION: PRINTS OUT <PROMPT> MESSAGE:,
C                 READS IN FILE NAME FROM INPUT DEVICE. 
C                 SUBSTITUTES FOR REGISTER AND LOOP INDEX. 
C                 EXAMPLES IF (X0 = 1, X11=11, X21=1111, INDEX:A=44)
d69 7
a75 7
C                     avg{***A }  ---> avg044
C                     avg{**A }   ---> avg44
C                     avg{***x0}  ---> avg001
C                     avg{****x0} ---> avg0001
C                     avg{****}   ---> avg****
c                     avg{***x21} ---> ERROR (DAMAGES INVARIANT PART OF 
C                                      FILE NAME)
d77 2
a78 2
C                 IF THE FIRST CHARACTER IS A '$', FILNAM FROM PREVIOUS 
C                 CALL REMAINS UNCHANGED.  
d88 1
a88 1
        CHARACTER *(*)           FILN,PROMPT,EXTENT
d90 7
a96 6
        CHARACTER(LEN=160) ::    FILNAM
        CHARACTER(LEN=100) ::    PROMPTP
        CHARACTER(LEN=1) ::      NULL,JCHAR
        LOGICAL ::               NOX,EXTENOK,GOTEX,SAYIT,KEEPGO
        LOGICAL ::               ISDIGI,ISCHAR

d99 2
a100 3
        integer mypid, comm, ierr
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid,  IERR)
d132 1
a132 1
              LENU = LENU - 1
d139 9
a147 3
           SAYIT   = .NOT. SILENT
	   CALL RDPR(PROMPTP(1:LENU),NLET,FILNAM,.FALSE.,
     &               SAYIT,IRTFLGT)
d316 1
a316 1
93        FORMAT(A,A)
@


1.50
log
@HRI GPL License used
@
text
@a17 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d21 1
a21 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a40 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.49
log
@file***x11 template
@
text
@d19 24
@


1.48
log
@.ext bug
@
text
@d15 1
d74 1
a74 1
        CHARACTER(LEN=1) ::      NULL,JCHAR,JM1CHAR,JM2CHAR
d76 1
a76 3
        LOGICAL ::               OLD1,OLD2,OLD3,ISDIGI,ISCHAR

        DATA OLD1,OLD2,OLD3/.TRUE.,.TRUE.,.TRUE./
d201 21
a221 16
C       CHECK FOR OLD-STYLE SUBSTITUTION SPECIAL CHARACTERS
        JCHAR   = FILNAM(NLET:NLET)
        JM1CHAR = CHAR(0)
        IF (NLET .GT. 1) JM1CHAR = FILNAM(NLET-1:NLET-1)
        JM2CHAR = CHAR(0)
        IF (NLET .GT. 2) JM2CHAR = FILNAM(NLET-2:NLET-2)

        IF (ISCHAR(JCHAR) .AND. ISDIGI(JM1CHAR)) THEN
C          POSSIBLE OLD-STYLE REGISTER (0I) SUBSTITUTION
           IF (OLD1) THEN
C             COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
              WRITE(NOUT,90) 
  90          FORMAT(/,' *** YOU MAY HAVE TO USE MODERN FILENAME ',
     &              'SUBSTITUTION SYNTAX (E.G. aaaa{***i})?',/)
              OLD1 = .FALSE.
           ENDIF
d223 27
a249 26
        ELSEIF (ISDIGI(JCHAR)) THEN
C          POSSIBLE OLD-STYLE REGISTER (X) SUBSTITUTION
           IF (JM1CHAR .EQ. 'X' .OR. JM1CHAR .EQ. 'x') THEN
C             FOUND "X0" TYPE  OLD-STYLE REGISTER (X) SUBSTITUTION
              IF (OLD2) THEN
C                COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
                 WRITE(NOUT,91) 
  91             FORMAT(/,' *** PLEASE USE MODERN FILENAME ',
     &                 'SUBSTITUTION SYNTAX (E.G. aaaa{***X0})',/)
                 OLD2 = .FALSE.
              ENDIF

           ELSEIF (ISDIGI(JM1CHAR) .AND.
     &             JM2CHAR .EQ. 'X' .OR. JM2CHAR .EQ. 'x') THEN
C             FOUND "X00" TYPE  OLD-STYLE REGISTER (X) SUBSTITUTION

              IF (OLD3) THEN
C                COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
                 WRITE(NOUT,92) 
 92              FORMAT(/,' *** PLEASE USE MODERN FILENAME ',
     &                  'SUBSTITUTION SYNTAX (E.G. aaaa{***X11})',/)
                 OLD3 = .FALSE.
              ENDIF
           ENDIF

         ENDIF
d254 1
a254 1
C       ALREADY DONE IN RDPR BUT MAY HAVE ADDED NEW {} FOR OBSOLETE!!
@


1.47
log
@lenp wrong on ~9 prompt
@
text
@d90 1
a90 1
        LENP = LEN(PROMPT)
d105 2
a106 2
           FILNAM   = PROMPT(2:)
           NLET     = LEN(PROMPT) - 1
@


1.46
log
@IRTFLG input removed
@
text
@d97 1
a97 1
           LENP    = LENP - 3
@


1.45
log
@NLOG
@
text
@d14 1
d37 2
a39 2
C                         IF IRTFLG = 9 FILERD ACCEPTS AN EXTENSION
C                         FROM THE INPUT OTHERWISE IT IS DISCARDED!
d90 1
a90 2
C       IRTFLG INPUT OF 9 SAYS THAT EXTENSION CAN BE READ IN ON NAME
        EXTENOK = (IRTFLG .EQ. 9) 
d92 8
d108 1
d111 3
a113 4
        
           LENF = LEN(PROMPT)
           LENU = MIN(96,LENF)
           IF (PROMPT(LENF:LENF) .EQ. '~') THEN
d115 1
@


1.44
log
@mpi
@
text
@d13 1
d77 1
d83 2
d86 1
d275 1
a275 14
#ifdef USE_MPI
999     IF (NLETC .GT. 0 .and. mypid .eq. 0) THEN
          IF (.NOT. SILENT)WRITE(NOUT,93) FILN(1:NLET),COMMENT(1:NLETC)
          IF (NPROC .NE. 0)WRITE(NPROC,93)FILN(1:NLET),COMMENT(1:NLETC)
93        FORMAT(A,A)
        ELSE
          if (mypid .eq. 0) then
          IF (.NOT. SILENT)WRITE(NOUT,94) FILN(1:NLET)
          IF (NPROC .NE. 0)WRITE(NPROC,94)FILN(1:NLET)
          endif
94        FORMAT(A)
        ENDIF
#else
999     IF (NLETC .GT. 0) THEN
d277 1
a277 1
          IF (NPROC .NE. 0)WRITE(NPROC,93)FILN(1:NLET),COMMENT(1:NLETC)
d279 3
a281 4
        ELSE
          IF (.NOT. SILENT)WRITE(NOUT,94) FILN(1:NLET)
          IF (NPROC .NE. 0)WRITE(NPROC,94)FILN(1:NLET)
94        FORMAT(A)
a282 1
#endif
@


1.43
log
@comment echoed
@
text
@d76 6
a81 1

d270 13
a282 1

d292 1
@


1.42
log
@do not print comment if none
@
text
@a128 1
            NLETC   = NLET - LNBLNKN(FILNAM(1:ISEMI-1))
d130 1
d132 1
a132 1
            FILNAM  = FILNAM(1:NLET)
@


1.41
log
@NECHO --> NOUT
@
text
@d12 1
d16 1
a16 1
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
d69 1
a69 1
        CHARACTER(LEN=160) ::    RESPONSE,FILNAM
a71 3
        CHARACTER(LEN=6) ::      FMT1
        CHARACTER(LEN=9) ::      DIGITS
        CHARACTER(LEN=26) ::     ALFABT
a74 3
        DATA DIGITS/'123456789'/
        DATA ALFABT/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
        DATA FMT1/'(I . )'/
d129 1
d134 2
a135 2
             COMMENT = ''
             NLET    = LNBLNKN(FILNAM)
d266 9
a274 4
999     IF (.NOT. SILENT) WRITE(NOUT,911)  FILN(1:NLET),COMMENT
        IF (NPROC .NE. 0) WRITE(NPROC,911) FILN(1:NLET),COMMENT
911     FORMAT(A,A)

@


1.40
log
@removed commented out code for setsympar
@
text
@d270 1
a270 1
999     IF (.NOT. SILENT) WRITE(NECHO,911) FILN(1:NLET),COMMENT
@


1.39
log
@longer comments in filname allowed
@
text
@a152 8
cc        ELSEIF (FILNAM(1:1) .EQ. '?') THEN
ccC         SET SYMBOLIC PARAMETER
cc          CALL CHARINSIDE(FILNAM(1:NLET),'?','?',.FALSE.,.FALSE., 
cc     &                   IGO,IEND,NCHARQ)
cc          IF (IGO .GT. 0) 
cc     &         CALL SETSYMPAR(FILNAM(1:NLET),RESPONSE,NLET,IRTFLG)
cc          IF (IRTFLG .NE. 0) RETURN
cc          FILNAM = RESPONSE
@


1.38
log
@rdpr simplification for symbolic parameters & variable subs.
@
text
@d67 2
a68 2
        CHARACTER(LEN=MAXNAM) :: FILNAM,EXTEN,COMMENT
        CHARACTER(LEN=160) ::    RESPONSE
d248 6
d269 2
a270 1
              CALL ERRT(100,'*** FILENAME TOO LONG',NE)
@


1.37
log
@comment on filename had last char from filename (bug)
@
text
@d4 8
a11 8
C FILERD.F   ADAPTED FROM FILRD AND SPFILE OCT 88     ARDEAN LEITH
C            REWRITTEN FOR NEW SUBSTITUTION JUNE 97   ARDEAN LEITH
C            ADDS EXTEN NOW IF SENT -- FEB 99         ARDEAN LEITH
C            CAN USE PROMPT FOR INPUT -- AUG 99       ARDEAN LEITH
C            REMOVED AVGX11 & AVG0I RULES -- SEPT 99  ARDEAN LEITH
C            TRAILING ~ ON PROMPT OMITS "FILE" NOV 00 ARDEAN LEITH
C            $ EFFECTIVE NOW IF ONLY 1 CHAR.   JAN 01 ARDEAN LEITH
C            ALTERED COMMENT HANDLING          JAN 01 ARDEAN LEITH
d153 8
a160 8
        ELSEIF (FILNAM(1:1) .EQ. '?') THEN
C         SET SYMBOLIC PARAMETER
          CALL CHARINSIDE(FILNAM(1:NLET),'?','?',.FALSE.,.FALSE., 
     &                   IGO,IEND,NCHARQ)
          IF (IGO .GT. 0) 
     &         CALL SETSYMPAR(FILNAM(1:NLET),RESPONSE,NLET,IRTFLG)
          IF (IRTFLG .NE. 0) RETURN
          FILNAM = RESPONSE
d242 1
@


1.36
log
@?xxxx?<1> anywhere now
@
text
@d134 2
a135 2
            NLET    = LNBLNKN(FILNAM(1:ISEMI-1))
            COMMENT = FILNAM(NLET:)
@


1.35
log
@removed null cahr on output
@
text
@d64 1
d66 10
a75 9
        CHARACTER *(*)  FILN,PROMPT,EXTENT
        CHARACTER  *80  FILNAM,EXTEN,COMMENT
        CHARACTER  *100 PROMPTP
	CHARACTER   *1  NULL,JCHAR,JM1CHAR,JM2CHAR
        CHARACTER  * 6  FMT1
        CHARACTER  * 9  DIGITS
        CHARACTER * 26  ALFABT
        LOGICAL         NOX,EXTENOK,GOTEX,SAYIT,KEEPGO,ISDIGI,ISCHAR
        LOGICAL         OLD1,OLD2,OLD3
d152 9
@


1.34
log
@comment handling changed, can handle long ones now
@
text
@d136 1
a136 1
             COMMENT = CHAR(0)
@


1.33
log
@$ if only one char now.
@
text
@d11 1
d66 1
a66 1
        CHARACTER  *80  FILNAM,EXTEN
d126 1
a126 1
C       REMOVE ANY INITIAL OR FINAL BLANKS
a127 1
        NLET   = LNBLNKN(FILNAM)
d129 11
a150 4
 
C       REMOVE ANY TRAILING COMMENT FROM THE INPUT LINE
        ISEMI = INDEX(FILNAM(1:NLET),';')
        IF (ISEMI .GT. 1) NLET = ISEMI - 1
d259 3
a261 3
999     IF (.NOT. SILENT) WRITE(NECHO,911) FILN(1:NLET)
        IF (NPROC .NE. 0) WRITE(NPROC,911) FILN(1:NLET)
911     FORMAT(A)
@


1.32
log
@added trailing ~ for no "FILE"
@
text
@d10 1
d13 7
a19 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
C **********************************************************************
d129 1
a129 1
	IF (FILNAM(1:1) .EQ. '$') THEN
@


1.31
log
@can remove tabs from name now
@
text
@d4 6
a9 5
C FILERD.F   ADAPTED FROM FILRD AND SPFILE OCT 88    ARDEAN LEITH
C            REWRITTEN FOR NEW SUBSTITUTION JUNE 97  ARDEAN LEITH
C            ADDS EXTEN NOW IF SENT -- FEB 99        ARDEAN LEITH
C            CAN USE PROMPT FOR INPUT -- AUG 99      ARDEAN LEITH
C            REMOVED AVGX11 & AVG0I RULES -- SEPT 99 ARDEAN LEITH
d28 1
a28 1
C                         A ~ (TILDE) IN FIST CAHR. SAYS USE
d30 2
d94 10
a103 3
           LENF    = LEN(PROMPT)
           LENF    = MIN(96,LENF)
           PROMPTP = PROMPT(1:LENF) // ' FILE' // NULL
d105 1
a105 1
	   CALL RDPR(PROMPTP(1:LENF+5),NLET,FILNAM,.FALSE.,
@


1.30
log
@modern message change
@
text
@d107 7
a113 1

@


1.29
log
@blanks at beginning code fixed
@
text
@d173 1
a173 1
     &              'SUBSTITUTION  SYNTAX  (E.G. aaaa{***i})?',/)
d185 1
a185 1
     &                 'SUBSTITUTION  SYNTAX  (E.G. aaaa{***X0})',/)
d196 2
a197 2
 92              FORMAT(/,' *** PLEASE USE  MODERN FILENAME ',
     &                  'SUBSTITUTION  SYNTAX  (E.G. aaaa{***X11})',/)
@


1.28
log
@removed blanks before filname echo
@
text
@d108 3
a110 14
C       REMOVE ANY INITIAL BLANKS
        I = 0
        DO WHILE (FILNAM(I+1:I+1) .EQ. ' ' .OR. 
     &           FILNAM(I+1:I+1) .EQ. CHAR(11))
C          INITIAL BLANK/TAB IN FILENAME
           I = I + 1
        ENDDO

        IF (I .GT. 1) THEN
C          REMOVE INITIAL BLANKS
           NLET2           = NLET - I 
           FILNAM(1:NLET2) = FILNAM(I+1:NLET)
           NLET            = NLET2
        ENDIF
@


1.27
log
@removed old style filname substituion code
@
text
@d248 1
a248 1
911     FORMAT(5X,A)
@


1.26
log
@altered avg0i rule
@
text
@d8 1
a8 1
C            CHANGED AVG0I  RULE -- SEPT 99          ARDEAN LEITH
a40 7
C                     avgx0       ---> avg001
C                     avg1x0      ---> avg001 (no error reported)
c                     avgx11      ---> avg011
c                     avgx21      ---> av1111 (no error reported)
c                     avg*x11     ---> avg0001
c                     avg***x11   ---> avg000001
c                     avg1x10     ---> avg1001
d42 2
a43 4
C                     avg0a       ---> avg044
C                     avg00a      ---> avg044
C                     avg**00a    ---> avg00044
C
d45 4
a48 4
C                     avg{****x0} ---> avg001
C                     avg{****}   ---> avg***
c                     avg{***x21} ---> ERROR DAMAGES INVARIANT PART OF 
C                                      FILE NAME
d171 1
a171 3
C       LOCATE OLD-STYLE SUBSTITUTION SPECIAL CHARACTERS
        IFILEND = NLET 

d178 2
a179 9
        IF (ISCHAR(JCHAR) .AND. 
     &      ISDIGI(JM1CHAR) .AND. ISDIGI(JM2CHAR)) THEN
C          FOUND OLD-STYLE INDEX SUBSTITUTION AT END OF FILE NAME *0I
           IFILEND = NLET - 3

C          GOT >= ONE ZERO BEFORE INDEX SO SUBSTITUTE LOOP COUNTER
           CALL SSUPCAS(JCHAR)
           IDX  = INDEX(ALFABT,JCHAR)
           IVAL = IALPHA(IDX)
d183 2
a184 3
 90           FORMAT(/,
     &           ' --- PLEASE CONVERT TO MODERN FILENAME SUBSTITUTION ',
     &           'SYNTAX  (E.G. aaaa{***i})',/)
d192 6
a197 7
              IFILEND = NLET - 3
              IREG    = INDEX(DIGITS,JCHAR) 
C             SPECIAL CODE FOR PICX0
              IF (NLET .EQ. 5) THEN
C                SPECIAL CODE FOR PICX0
                 IFILEND = NLET - 2
                 NLET    = 6
a198 7
               IF (OLD2) THEN
C                 COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
                  WRITE(NOUT,91) 
  91              FORMAT(/,' --- PLEASE CONVERT TO MODERN FILENAME ',
     &                  'SUBSTITUTION  SYNTAX  (E.G. aaaa{***X0})',/)
                  OLD2 = .FALSE.
               ENDIF
a202 2
              IFILEND = NLET - 3
              IREG    = INDEX(DIGITS,JM1CHAR) * 10 + INDEX(DIGITS,JCHAR) 
d207 1
a207 1
 92              FORMAT(/,' --- PLEASE CONVERT TO MODERN FILENAME ',
d213 1
a213 46
           IF (IFILEND .LT. NLET) THEN
C             REGISTER SUBSTITUTION NEEDED
              IF (IREG .LT. 0 .OR. IREG .GT. 100)  THEN
                 WRITE(NOUT,*) 
     &            '*** BAD REGISTER: ',IREG,' IN FILENAME SUBSTITUTION'
                 CALL ERRT(100,'FILERD',NE)
                 RETURN
              ENDIF

C             FIND REGISTER CONTENTS
              IVAL = PARAM(IREG+1) + 0.5
              IF (IVAL .LT. 0)  THEN
                 WRITE(NOUT,*) 
     &              '*** NEGATIVE REGISTER CONTENT: ',IVAL,
     &              ' NOT ALLOWED IN FILENAME SUBSTITUTION'
                 CALL ERRT(100,'FILERD',NE)
                 RETURN
              ENDIF
           ENDIF
        ENDIF


        IF (IFILEND .LT. NLET) THEN
C          SUBSTITUTE FOR A PORTION OF THE FILE NAME
C          FIND NUMBER OF DIGITS TO BE SUBSTITUTED (>=3) 

           NDIGITS = NUMDIG(IVAL,3)

C          FIND NUMBER OF IMMEDIATLY PRECEEDING ASTERICKS (IF ANY)
           DO WHILE (IFILEND .GE. 1 .AND. 
     &              (FILNAM(IFILEND:IFILEND) .EQ. '*'))
C             INCREMENT ASTERICKS NEEDED
              IF ((NLET - IFILEND) .GE. NDIGITS) NDIGITS = NDIGITS + 1
              IFILEND = IFILEND - 1
           ENDDO  

           IFILEND = NLET - NDIGITS 
           IF (IFILEND .LT. 0) THEN
              WRITE(NOUT,*) '*** FILENAME TOO SHORT FOR SUBSTITUTION'
              CALL ERRT(100,'FILERD',NE)
              GOTO 999
           ENDIF

C          PREPARE FORMAT FOR WRITING IVAL INTO FILENAME
           FMT1(3:3) = DIGITS(NDIGITS:NDIGITS)
           FMT1(5:5) = DIGITS(NDIGITS:NDIGITS)
a214 4
C          WRITE REGISTER CONTENTS INTO THE FILE NAME
           WRITE(FILNAM(IFILEND+1:IFILEND+NDIGITS),FMT1) IVAL
        ENDIF
        
@


1.25
log
@~prompt capability added for filelistb use
@
text
@d8 1
d189 2
a190 1
        IF (ISCHAR(JCHAR) .AND. ISDIGI(JM1CHAR)) THEN
d198 8
a205 8
cc           IF (OLD1) THEN
ccC             COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
cc              WRITE(NOUT,90) 
cc 90           FORMAT(/,' --- PLEASE USE MODERN FILENAME SUBSTITUTION ',
cc     &               'SYNTAX  (E.G. aaaa{***i})',/,
cc     &               ' --- THIS MESSAGE ONLY OCCURS ONCE.',/)
cc              OLD1 = .FALSE.
cc           ENDIF
d219 7
a225 8
cc              IF (OLD2) THEN
ccC                COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
cc                 WRITE(NOUT,91) 
cc 91              FORMAT(/,' --- PLEASE USE MODERN FILENAME ',
cc     &                  'SUBSTITUTION  SYNTAX  (E.G. aaaa{***X0})',/,
cc     &               ' ---THIS MESSAGE WILL NOT OCCUR AGAIN.',/)
cc                 OLD2 = .FALSE.
cc              ENDIF
d233 7
a239 8
cc              IF (OLD3) THEN
ccC                COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
cc                 WRITE(NOUT,92) 
cc 92              FORMAT(/,' --- PLEASE USE MODERN FILENAME ',
cc     &                  'SUBSTITUTION  SYNTAX  (E.G. aaaa{***X11})',/,
cc     &               ' ---THIS MESSAGE WILL NOT OCCUR AGAIN.',/)
cc                 OLD3 = .FALSE.
cc              ENDIF
@


1.24
log
@nulled end of string
@
text
@d4 4
a7 3
C    FILERD.F     ADAPTED OCT 88 FROM FILRD AND SPFILE al
C                 TOTALLY REWRITTEN JUNE 97 FOR NEW SUBSTITUTION al
C                 ADDS EXTEN NOW IF SENT -- FEB 99       ARDEAN LEITH
d26 2
a66 1
CNO_SAVE
d91 7
a97 1
C       READ THE FILE NAME FROM THE INPUT, DO NOT UPPERCASE IT!
d99 7
a105 5
        LENF    = LEN(PROMPT)
        LENF    = MIN(96,LENF)
        PROMPTP = PROMPT(1:LENF) // ' FILE' // NULL
        SAYIT   = .NOT. SILENT
	CALL RDPR(PROMPTP(1:LENF+5),NLET,FILNAM,.FALSE.,SAYIT,IRTFLGT)
d108 1
a108 1
C          NO FILE NAME IN INPUT
@


1.23
log
@lnblnkn outside parameters now
@
text
@d91 2
a92 2
        LENF    = LNBLNKN(PROMPT)
        LENF    = MAX(1,LENF)
d291 1
a291 1
        FILN(1:NLET+1) = FILNAM(1:NLET) // NULL
d295 1
a295 1
        IF (.NOT. GOTEX) EXTEN = CHAR(0)
@


1.22
log
@can concat exten from parameter now
@
text
@d90 3
a92 1
        LENF    = MAX(1,LNBLNKN(PROMPT))
d295 1
@


1.21
log
@removed complaint about old
@
text
@d2 1
a2 1
C++*************************************************************************
d6 1
d8 8
a15 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH                            *
C **************************************************************************
d21 3
a23 1
C                 EXTEN   OPTIONAL FILE NAME EXTENSION   (SENT/RETURNED)
d25 3
a27 1
C                 IRTFLG  ERROR FLAG, ZERO IS NORMAL          (RETURNED)
d29 1
a29 1
C    PURPOSE:     READS IN CHARACTER FILE NAME  AND TITLE.  CAN ALSO 
d31 1
a31 1
C                 CERTAIN POSITIONS OF FILENAME
a54 1
C
a56 10
C                 AFTER THE FILE NAME, A TITLE UP TO 160 
C                 CHARACTERS CAN BE ENTERED WHICH IS ATTACHED TO THE 
C                 IMAGE FILE IN THE HEADER WHEN OPEN IS 
C                 SUBSEQUENTLY CALLED.  NEW TITLE INFORMATION 
C                 SUPERSEDES THE TITLE ALREADY PRESENT IN THE HEADER.  
C                 TO ENTER A TITLE TYPE '|' AFTER THE FILE NAME.
C                 EXAMPLE: ABC001|THIS IS A TITLE
C
C  NOTE:          IF IRTFLG = 9 FILERD ACCEPTS AND RETURNS AN EXTENSION
C                 FROM THE INPUT
d59 1
a59 1
C--*******************************************************************
d61 1
a61 1
	SUBROUTINE FILERD(FILN,NLET,EXTEN,PROMPT,IRTFLG)
d66 3
a68 3
        CHARACTER *(*)  FILN,PROMPT,EXTEN
        CHARACTER  *80  FILNAM
        CHARACTER  *100 FMT
a75 1

d83 1
d86 3
d90 4
a93 4
        LENF  = MAX(1,lnblnk(PROMPT))
        FMT   = PROMPT(1:LENF) // ' FILE' // NULL
        SAYIT = .NOT. SILENT
	CALL RDPR(FMT(1:LENF+5),NLET,FILNAM,.FALSE.,SAYIT,IRTFLG)
d95 1
a95 1
        IF (NLET .LE. 0) THEN
a99 1
        IRTFLG = 1
d153 1
a153 1
C                WANT TO USE FILE EXTENSION
d163 1
a163 2
           WRITE(NOUT,*) '*** ABNORMAL FILENAME'
           CALL ERRT(100,'FILERD',NE)
d284 2
a285 2
        CALL FILNAMSUB(FILNAM,NLET,.FALSE.,0,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
a288 1
        FILN = NULL
d291 8
a298 7
        IF (EXTEN(1:1) .NE. NULL .AND. EXTENOK) THEN
C          EXTENSION RECEIVED FROM CALLER OR ON INPUT. 
C          ADD IT TO FILE NAME
           LENE = INDEX(EXTEN,NULL)
           IF (LENE .EQ. 0) LENE = LEN(EXTEN)
           LENB = INDEX(EXTEN,' ')
           IF (LENB .GT. 0) LENE = MIN(LENE,LENB)
d301 1
a301 1
              NLET = NLET + LENE
d303 1
a303 3
              WRITE(NOUT,*) '*** FILENAME TOO LONG'
               CALL ERRT(100,'FILERD',NE)
              IRTFLG = 1
@


1.20
log
@changed modern message
@
text
@d87 1
a87 1
        DATA OLD1,OLD2/.TRUE.,.TRUE./
d190 8
a197 8
           IF (OLD1) THEN
C             COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
              WRITE(NOUT,90) 
 90           FORMAT(/,' --- PLEASE USE MODERN FILENAME SUBSTITUTION ',
     &               'SYNTAX  (E.G. aaaa{***i})',/,
     &               ' --- THIS MESSAGE ONLY OCCURS ONCE.',/)
              OLD1 = .FALSE.
           ENDIF
d211 8
a218 8
              IF (OLD2) THEN
C                COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
                 WRITE(NOUT,91) 
 91              FORMAT(/,' --- PLEASE USE MODERN FILENAME ',
     &                  'SUBSTITUTION  SYNTAX  (E.G. aaaa{***X0})',/,
     &               ' ---THIS MESSAGE WILL NOT OCCUR AGAIN.',/)
                 OLD2 = .FALSE.
              ENDIF
d225 9
a233 8
              IF (OLD3) THEN
C                COMPLAIN ABOUT OLD-STYLE SUBSTITUTION
                 WRITE(NOUT,92) 
 92              FORMAT(/,' --- PLEASE USE MODERN FILENAME ',
     &                  'SUBSTITUTION  SYNTAX  (E.G. aaaa{***X11})',/,
     &               ' ---THIS MESSAGE WILL NOT OCCUR AGAIN.',/)
                 OLD3 = .FALSE.
              ENDIF
@


1.19
log
@added nag msg.
@
text
@d195 1
a195 1
     &               ' ---THIS MESSAGE WILL NOT OCCUR AGAIN.',/)
@


1.18
log
@new parameters on filnamsub call
@
text
@d81 1
d83 1
d87 1
d190 8
d211 8
d225 8
a232 1

@


1.17
log
@*** empty log message ***
@
text
@d263 1
a263 1
        CALL FILNAMSUB(FILNAM,NLET,IRTFLG)
@


1.16
log
@substituion for avg***** in procudures with x10 were wrong
@
text
@d80 1
a80 1
        LOGICAL         NOX,NEEDEX,GOTEX,SAYIT,KEEPGO,ISDIGI,ISCHAR
d88 1
a88 1
        NEEDEX = (IRTFLG .EQ. 9) 
d154 1
a154 1
              IF (NEEDEX) THEN
d271 3
a273 2
        IF (EXTEN(1:1) .NE. NULL .AND. .NOT. GOTEX) THEN
C          EXTENSION RECEIVED FROM CALLER. ADD IT TO FILE NAME
d278 1
a278 1
           IF (LENE + NLET .LT. LEN(FILN)) THEN
d280 1
a280 1
              NLET = NLET + LENE + 1
@


1.15
log
@removed filnamsub.f routine to own file
@
text
@d241 2
a242 2
              NDIGITS    = NDIGITS + 1
              IFILEND    = IFILEND - 1
@


1.14
log
@fixed old style filename sub. bug
@
text
@a299 119
C -------------------------------------------------------------------


      SUBROUTINE FILNAMSUB(FILNAM,NLET,IRTFLG)

      INCLUDE 'CMBLOCK.INC'
CNO_SAVE

      CHARACTER *(*)  FILNAM
      CHARACTER *1    JCHAR,JP1CHAR,JP2CHAR
      CHARACTER  * 6  FMT1
      CHARACTER  * 9  DIGITS
      CHARACTER * 26  ALFABT
      LOGICAL         ISDIGI,ISCHAR

      DATA DIGITS/'123456789'/
      DATA ALFABT/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      DATA FMT1/'(I . )'/

      IRTFLG = 1

10    CONTINUE

C     SEE IF "{...}" IS PRESENT      
      CALL CHARINSIDE(FILNAM(1:NLET),'{','}',.FALSE., IGO,IEND,NCHAR)

      IF (NCHAR .GT. 0) THEN
C        NEED TO SUBSTITUTE INTO FILNAM
         J    = IGO + 1
         NAST = 0
         DO WHILE (J .LT. IEND .AND. FILNAM(J:J) .EQ. '*')
            NAST = NAST + 1
            J    = J + 1
         ENDDO

         IF (NAST .LE. 0) THEN
C           NO ASTERICKS IS AN ERROR
            WRITE(NOUT,*) 
     &         '***NO ASTERICKS IN FILENAME SUBSTITUTION STRING'
            CALL ERRT(100,'FILNAMSUB',NE)
            RETURN
         ELSEIF ((NAST + 2) .EQ. NCHAR) THEN
C           SUBSTITUTION STRING HAS ONLY ASTERICKS, LEAVE IT ALONE
            IRTFLG = 0
            RETURN
         ENDIF

         JCHAR   = FILNAM(J:J)
         JP1CHAR = CHAR(0)
         IF ((J + 1) .LT. IEND) JP1CHAR = FILNAM(J+1:J+1)
         JP2CHAR = CHAR(0)
         IF ((J + 2) .LT. IEND) JP2CHAR = FILNAM(J+2:J+2)
         CALL SSUPCAS(JCHAR)

         IF (JCHAR .EQ. 'X' .AND. ISDIGI(JP1CHAR)) THEN
C           REGISTER SUBSTITUTION WANTED
            IREG = INDEX(DIGITS,JP1CHAR) 
            IF (ISDIGI(JP2CHAR)) IREG = IREG * 10 + 
     &          INDEX(DIGITS,JP2CHAR) 

            IF (IREG .LT. 0 .OR. IREG .GT. 100) THEN
               WRITE(NOUT,*) 
     &            '*** BAD REGISTER: ',IREG,' IN FILENAME SUBSTITUTION'
               CALL ERRT(100,'FILNAMSUB',NE)
               RETURN
            ENDIF

C           FIND REGISTER CONTENTS
            IVAL = PARAM(IREG+1) + 0.5

         ELSEIF (ISCHAR(JCHAR)) THEN
C           LOOP COUNTER SUBSTITUTION WANTED
            CALL SSUPCAS(JCHAR)
            IDX  = INDEX(ALFABT,JCHAR)
            IVAL = IALPHA(IDX)
         ENDIF

C        FIND DIGITS IN IVAL
         NDIGITS = NUMDIG(IVAL,0)
         IF (NDIGITS .GT. NAST) THEN
            
            WRITE(NOUT,90)IVAL,FILNAM(1:NLET)
90          FORMAT(' *** SUBSTITUTING: ',I, ' INTO:',A,/,
     &             '     DAMAGES INVARIANT PART OF FILE NAME')
            CALL ERRT(100,'FILNAMSUB',NE)
            RETURN
         ENDIF

C        PREPARE FORMAT FOR WRITE
         FMT1(3:3) = DIGITS(NAST:NAST)
         FMT1(5:5) = DIGITS(NAST:NAST)

         NLEN    = LEN(FILNAM)
         NLET = IGO + NAST + (NLET - IEND) - 1

         IF (NLET .GT. NLEN) THEN
            WRITE(NOUT,*) '*** SUBSTITUTED FILENAME TOO LONG: ',NLET
            CALL ERRT(100,'FILNAMSUB',NE)
            RETURN
         ENDIF
  
C        PRESERVE END OF FILENAME AFTER SUBSTITUTION AREA    
         FILNAM(IGO+NAST:) = FILNAM(IEND+1:)

C        WRITE SUBSTITUTION CONTENTS INTO THE FILE NAME
         WRITE(FILNAM(IGO:IGO+NAST-1),FMT1,IOSTAT=IERR) IVAL
         IF (IERR .NE. 0) THEN
            WRITE(NOUT,*) '*** ERROR SUBSTITUTING INTO FILENAME ',IVAL
            CALL ERRT(100,'FILNAMSUB',NE)
         ENDIF

C        SEE IF ANY MORE SUBSTITUTIONS ARE NEEDED
         GOTO 10
      ENDIF

      IRTFLG = 0

      RETURN
      END
@


1.13
log
@need iast for 00 preceeding x11
@
text
@d34 1
d36 1
a36 2
c                     avgx21      ---> ERROR DAMAGES INVARIANT PART OF 
C                                      FILE NAME
d38 1
a38 1
c                     avg***x11   ---> avg0001
a39 1
c                     avg0x0      ---> avg0001
d48 2
d76 5
a80 1
	CHARACTER   *1  NULL,JCHAR,JM1CHAR,JM2CHAR,JM3CHAR
d82 3
a84 1
        LOGICAL         NOX,NEEDEX,GOTEX,SAYIT,KEEPGO,ISDIGI,ISCHAR
d171 1
a171 3
        ISUBGO  = 0
        IFILEND = NLET - 2
        NAST    = 3
a177 2
        JM3CHAR = CHAR(0)
        IF (NLET .GT. 3) JM3CHAR = FILNAM(NLET-3:NLET-3)
a180 1
           ISUBGO  = NLET 
d182 5
a186 5
C          FOR PIC0I
           IF (JM2CHAR .NE. '0' .AND. JM2CHAR .NE. '*')IFILEND=ISUBGO-2
           IAST    = ISUBGO - 2
C          FOR PIC*00I
           IF (JM2CHAR .EQ. '0' .AND. JM3CHAR .EQ. '*')IAST=ISUBGO-3
d192 8
a199 3
              ISUBGO  = NLET - 1
              IFILEND = NLET - 2
              IAST    = ISUBGO - 1
a203 1
              ISUBGO  = NLET - 2
d205 22
a226 1
              IAST    = ISUBGO - 1
d231 13
a243 2
        IF (ISUBGO .GT. 0) THEN
C          SUBSTITUTION NEEDED
d245 1
d252 3
a254 20
C          SET NUMBER OF ASTERICKS BEFORE THE SUBSTITUTION STRING
C          THIS IS DONE FOR CONFORMITY WITH OLD METHOD!
           NAST = 3

C          FIND NUMBER OF IMMEDIATLY PRECEEDING ASTERICKS OR DIGITS
           DO WHILE (IAST .GE. 1 .AND. 
     &              (FILNAM(IAST:IAST) .EQ. '*' .OR. 
     &               ISDIGI(FILNAM(IAST:IAST))))
C             INCREMENT ASTERICKS NEEDED
              NAST    = NAST + 1
              IAST    = IAST - 1
              IFILEND = IAST 
           ENDDO  
             
           IF ((IFILEND + NAST + (NLET - ISUBGO) + 3) .GT. 80) THEN
              ITEMP = IFILEND + NAST + (NLET - ISUBGO) + 3
              WRITE(NOUT,*) '*** FILENAME TOO LONG: ',ITEMP
              CALL ERRT(100,'FILERD',NE)
              GOTO 999
           ENDIF
d256 2
a257 15
C          CREATE NEW-STYLE SUBSTITUTION STRING
           FMT(1:1) = '{'
           IAST = 2
           DO WHILE (IAST .LT. (NAST+2)) 
              FMT(IAST:IAST) = '*'
              IAST = IAST + 1
           ENDDO
             
C          PUT IN REGISTER OR INDEX
           FMT(NAST+2:) = FILNAM(ISUBGO:NLET)
           NC = 1 + NAST + (NLET - ISUBGO + 1) + 1
           FMT(NC:NC) = '}'
 
           FILNAM(IFILEND+1:) = FMT(:NC) 
           NLET = IFILEND + NC 
@


1.12
log
@new name substitutiion method used
@
text
@d217 5
a221 3
C          FIND NUMBER OF IMMEDIATLY PRECEEDING ASTERICKS
           DO WHILE (IAST .GE. 1 .AND. FILNAM(IAST:IAST) .EQ. '*')
C             INCREMENT  ASTERICKS NEEDED
@


1.11
log
@comments
@
text
@d4 3
a6 2
C    FILERD.FOR
C                       ADAPTED OCT 88 FROM FILRD AND SPFILE al
d19 31
a49 28
C    PARAMETERS:   FILN      CHARACTER ARRAY FOR RETURNED FILE NAME
C                  NLET      NUMBERS OF CHARACTERS IN FILE NAME
C                  PROMPT    ALPHANUMERIC STRING TO SOLICIT FILE NAME
C                  IRTFLG    ERROR FLAG
C
C    PURPOSE:      READS IN CHARACTER FILE NAME  AND TITLE.  CAN ALSO 
C                  CREATE FILE NAMES FROM PREFIX AND REGISTER, OR FROM 
C                  PREFIX AND DO-LOOP INDEX.
C
C    DESCRIPTION:  PRINTS OUT <PROMPT> MESSAGE:,
C                  READS IN FILE NAME FROM INPUT DEVICE. 
C                     FILE NAME SPECIFIER = <ABC><LMN>  (EXAMPLE PIC005)
C                               - OR -      <ABC>00<A>  (EXAMPLE PIC00J)
C                               - OR -      <ABC>X<MN>  (EXAMPLE PICX12)
C                               - OR -      <N><LMN>    (EXAMPLE <4>001)
C                               - OR -      <N>X<MN>    (EXAMPLE <4>X10)
C                               - OR -      <N>00<A>    (EXAMPLE <4>00I)
C                  (NOTE: SUBSTITUTION FOR <N> OCCURS IN DRIVER IN BATCH MODE)
C
C                  IF THE FIRST CHARACTER IS A '$', FILNAM FROM PREVIOUS 
C                  CALL REMAINS UNCHANGED.  
C                  AFTER THE FILE NAME, A TITLE UP TO 160 
C                  CHARACTERS CAN BE ENTERED WHICH IS ATTACHED TO THE 
C                  PICTURE FILE IN THE MASTER LABEL WHEN OPEN IS 
C                  SUBSEQUENTLY CALLED.  NEW TITLE INFORMATION 
C                  SUPERSEDES THE TITLE ALREADY PRESENT IN THE LABEL.  
C                  TO ENTER A TITLE TYPE '/' AFTER THE FILE NAME.
C                  EXAMPLE: ABC001/THIS IS A TITLE
d51 9
a59 2
C  NOTE:           IF IRTFLG = 9 FILERD ACCEPTS AND RETURNS AN EXTENSION
C                  FROM THE INPUT
d61 3
d70 1
a70 1
cNO_SAVE
a73 1
        CHARACTER * 26  ALFABT
d75 3
a77 11
        CHARACTER  * 9  DIGITS
        CHARACTER  * 6  FMT1
        CHARACTER  * 4  FMT2
	CHARACTER   *1  CHARI,NULL,JCHAR

        LOGICAL         NOX,NEEDEX,GOTEX,SAYIT

        DATA DIGITS/'123456789'/
        DATA ALFABT/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
        DATA FMT1/'(I . )'/
        DATA FMT2/'(I )'/
d81 1
a81 3
        NEEDEX = .FALSE.
        IF (IRTFLG .EQ. 9) NEEDEX = .TRUE.
        GOTEX = .FALSE.
a88 3
C       IFOUND IS FLAG FOR TITLE GIVEN IN INPUT & AFFECTS OPENF OUTPUT
	IFOUND = 0

a92 29

        ELSEIF (FILNAM(1:1) .EQ. '^' .OR. FILNAM(1:1) .EQ. '*') THEN
           FILN(1:) = FILNAM(1:1)
           WRITE(NECHO,911)  FILN(1:NLET)
           IF (NPROC .NE. 0) WRITE(NPROC,911) FILN(1:NLET)
           IRTFLG = -1
           RETURN
        ENDIF

#ifdef SP_VMS
        ISLASH = INDEX(FILNAM(1:NLET),'/')
        IF (ISLASH .LE. 0) ISLASH = INDEX(FILNAM(1:NLET),'|')
#else
C**     SLASH CHANGED TO | FOR UNIX 
        ISLASH = INDEX(FILNAM(1:NLET),'|')
#endif
	IF (ISLASH .GT. 0) THEN
C          TITLE GIVEN IN INPUT
           IFOUND = -1
           LENTIT = MIN0(160,NLET-ISLASH)
           CTIT(1:LENTIT) = FILNAM(ISLASH+1:)

           IF (LENTIT .LT. 160) THEN
             CTIT(LENTIT+1:LENTIT+1) = NULL
             DO I = LENTIT+2,160
               CTIT(I:I) = ' '
             ENDDO
           ENDIF
           NLET = ISLASH - 1
d94 1
d96 2
d99 5
a103 3
C       FIND PRECEEDING BLANKS
        I = 1
4       IF (FILNAM(I:I) .EQ. ' ') THEN
d105 1
a105 1
           GOTO 4
d107 5
a111 5
        ELSEIF (I .GT. 1) THEN
C          REMOVE PRECEEDING BLANKS
           NLET2 = NLET - I + 1
           FILNAM(1:NLET2) = FILNAM(I:NLET)
           NLET = NLET2
d114 13
a126 4
C       DO NOT ALTER CALLING NAME
	IF (FILNAM(:1) .EQ. '$') GOTO 10    

C       REMOVE ANY TRAILING COMMENT
d130 23
a152 27
C       GO BACKWARDS THRU FILENAME TO LOCATE SPECIAL CHARACTERS
        IXL = 0
        NOX = .TRUE.
        J   = NLET

C       IDENTIFY THIS CHARACTER     
5       JCHAR = FILNAM(J:J)
        IF (JCHAR .EQ. ' ') THEN
C          DISCARD THIS TRAILING BLANK
           NLET = J - 1

        ELSEIF (J .EQ. 1 .OR. JCHAR .EQ. ']' .OR. 
     &         JCHAR .EQ. ':' .OR. JCHAR .EQ. '/') THEN
C          FOUND BEGINNING OF DEVICE OR DIRECTORY, HALT BACK SEARCH
           IFIL = J + 1
           IF (J .EQ. 1) IFIL = 1
           GOTO 6

        ELSEIF (JCHAR .EQ. '.') THEN
           IF (NEEDEX) THEN
C            SAVE FILE EXTENSION
             EXTEN = FILNAM(J+1:NLET) // NULL
             GOTEX = .TRUE.

           ELSE
C            DISCARD FILE EXTENSION 
             NLET = J - 1              
d154 2
d157 4
a160 8
        ELSEIF ((JCHAR .EQ. 'X' .OR. JCHAR .EQ. 'x').AND. NOX) THEN
C          FOUND LAST X IN FILE NAME
           IXL = J
           NOX = .FALSE.

        ELSEIF (JCHAR .LT. '0' .OR. JCHAR .GT. '9') THEN
C          CAN NOT BE A INDEXING X ANY MORE (E.G.  BXA001)
           NOX = .FALSE.
d163 39
a201 2
        J = J - 1
        IF (J .GE .1) GOTO 5
d204 2
a205 2
6       CHARI = FILNAM(NLET:NLET)
        NDIGITS = NLET - IXL
d207 5
a211 29
        IF (IXL .GT. 0) THEN
C         POSSIBLE REGISTER SUBSTITUTED FILE NAME

          IF (NDIGITS .LT. 1 .OR. NDIGITS .GT. 9) THEN
             WRITE(NOUT,*) '*** BAD REGISTER NUMBER IN: ',FILNAM(1:NLET)
             CALL ERRT(100,'FILERD',NE)
          ENDIF

          FMT2(3:3) = DIGITS(NDIGITS:NDIGITS)
          READ(FILNAM(IXL+1:NLET),FMT2,ERR=10) IPARM

          IF (IPARM .LT. 0 .OR. IPARM .GT. 100) THEN
             WRITE(NOUT,*) '*** BAD REGISTER NUMBER: ',IPARM
             CALL ERRT(100,'FILERD',NE)
          ELSE
C            FIND REGISTER CONTENTS
             IVAL = PARAM(IPARM+1) + 0.5
          ENDIF

        ELSEIF (((CHARI .GE. 'A' .AND. CHARI .LE. 'Z') .OR.
     &          (CHARI .GE. 'a' .AND. CHARI .LE. 'z')) .AND.
     &           FILNAM(NLET-1:NLET-1) .EQ. '0') THEN

C         GOT >= ONE ZERO BEFORE INDEX SO SUBSTITUTE LOOP COUNTER
          CALL SSUPCAS(CHARI)
          IDX  = INDEX(ALFABT,CHARI)
          IVAL = IALPHA(IDX)
          IXL  = NLET - 2
        ENDIF
d213 18
a230 35
        NAST = 0
        IF (IXL .GT. 0) THEN
C         SET FLAG TO OVERWRITE ANY PRECEEDING ASTERICKS
          IAST = 0
          IF (IXL .GT. 1) IAST = INDEX(FILNAM(1:IXL-1),'*')
          IF (IXL .GT. 1 .AND. IAST .GT. 0) THEN
C            FIND NUMBER OF IMMEDIATLY PRECEEDING ASTERICKS
             DO IT = IXL-1,1,-1
                IF (FILNAM(IT:IT) .EQ. '*') THEN
                  NAST = NAST + 1
                ELSE
                  GOTO 7
                ENDIF
             ENDDO
          ENDIF
        ENDIF                


7       IF (IXL .GT. 0) THEN
C          SUBSTITUTE FOR A PORTION OF THE FILE NAME
C          FIND NUMBER OF DIGITS TO BE SUBSTITUTED (>=3) and >= NAST
           LENI = MAX(NUMDIG(IVAL,3),(NAST+3))
           IF (LENI .GT. 3) THEN
              IF ((IXL - IFIL) .LT. (LENI - 3)) THEN
C                FILE NAME NOT LONG ENOUGH FOR DIGITS
                 WRITE(NOUT,*) '*** FILENAME TOO SHORT FOR SUBSTITUTION'
                 IRTFLG = 1
                 RETURN
               ENDIF
               IXL = IXL - (LENI - 3)

           ELSEIF (IXL .EQ. (NLET-1) .AND. IAST .EQ. 0 .AND.
     &             IXL .NE. 4) THEN
C              SPECIAL KLUDGE FOR FILENAME WITH  X0 (E.G. JNK0X0)
               IXL = IXL - 1
d232 18
a249 1
           ENDIF
d251 3
a253 7
C          PREPARE FORMAT FOR WRITE
           FMT1(3:3) = DIGITS(LENI:LENI)
           FMT1(5:5) = DIGITS(LENI:LENI)

C          WRITE REGISTER CONTENTS INTO THE FILE NAME
           WRITE(FILNAM(IXL:IXL+LENI-1),FMT1) IVAL
           NLET = IXL + LENI - 1
d255 1
a255 1
        ENDIF
d271 1
d277 4
a280 1
10      IF (.NOT. SILENT) WRITE(NECHO,911) FILN(1:NLET)
d284 121
a404 2
C       SET NORMAL ERROR RETURN
        IRTFLG = 0
@


1.10
log
@accept comments ok now
@
text
@d32 4
a35 4
C                               - OR -       P<N><LMN>  (EXAMPLE P4001)
C                               - OR -       P<N>X<MN>  (EXAMPLE P4X10)
C                               - OR -       P<N>00<A>  (EXAMPLE P400I)
C                  (NOTE: SUBSTITUTION FOR P OCCURS IN DRIVER IN BATCH MODE)
@


1.9
log
@ used rdpr for ; handling
@
text
@d141 4
@


1.8
log
@silent added
@
text
@d56 1
d61 1
a61 1
        CHARACTER  *24  FMT
d67 1
a67 1
        LOGICAL         NOX,NEEDEX,GOTEX
a70 1
        DATA FMT /'($,1X,1H.,A  ,7H FILE: )'/
a79 8
C       SETUP PROMPT LINE
        NP = LEN(PROMPT)
        WRITE(FMT(12:13),8002) NP
8002    FORMAT(I2)

C       PRINT THE PROMPT
	IF (.NOT. SILENT) WRITE(NOUT,FMT) PROMPT(:NP)

d81 4
a84 1
	CALL READCH(PROMPT(:NP),NIN,NLET,FILNAM,.FALSE.,IRTFLG)
a85 3
C       INCREMENT BATCH COUNTER
        IBCNT = IBCNT + 1

a150 1

@


1.7
log
@altered so should handle fr with names like cen3**** and x10 substituition
with x10 contents 0 or 1000 without altering 3 of cen3.
@
text
@d86 1
a86 1
	WRITE(NOUT,FMT) PROMPT(:NP)
d293 1
a293 1
10      WRITE(NECHO,911)  FILN(1:NLET)
@


1.6
log
@fixed do loop pointer for lowercase
@
text
@a1 1

d13 1
a13 1
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
d29 6
a34 6
C		      FILE NAME SPECIFIER = <ABC><LMN>  (EXAMPLE PIC005)
C				- OR -	    <ABC>00<A>  (EXAMPLE PIC00J)
C				- OR -	    <ABC>X<MN>  (EXAMPLE PICX12)
C				- OR -       P<N><LMN>  (EXAMPLE P4001)
C				- OR -       P<N>X<MN>  (EXAMPLE P4X10)
C				- OR -       P<N>00<A>  (EXAMPLE P400I)
a52 3

#ifdef SP_VMS

d55 1
a55 1
        INCLUDE 'COMMON1:CMBLOCK.INC'
a88 2

C	CHANGEd 3/29/93 TO ADD ON-LINE HELP, MAHIEDDINE LADJADJ
d110 1
a110 1

a112 190
	IF (ISLASH .GT. 0) THEN
C          / OR | FOR TIME TITLE GIVEN IN INPUT
           IFOUND = -1
           LENTIT = MIN0(160,NLET-ISLASH)
           CTIT(1:LENTIT) = FILNAM(ISLASH+1:)

           IF (LENTIT .LT. 160) THEN
             CTIT(LENTIT+1:LENTIT+1) = NULL
             DO  I = LENTIT+2,160
              CTIT(I:I) = ' '
             ENDDO
           ENDIF
           NLET = ISLASH - 1
        ENDIF


C       FIND PRECEEDING BLANKS
        I = 1
4       IF (FILNAM(I:I) .EQ. ' ') THEN
           I = I + 1
           GOTO 4

        ELSEIF (I .GT. 1) THEN
C          REMOVE PRECEEDING BLANKS
           NLET2 = NLET - I + 1
           FILNAM(1:NLET2) = FILNAM(I:NLET)
           NLET = NLET2
        ENDIF

C       DO NOT ALTER CALLING NAME
	IF (FILNAM(:1) .EQ. '$') GOTO 10    

C       GO BACKWARDS THRU FILENAME TO LOCATE SPECIAL CHARACTERS
        IXL = 0
        NOX = .TRUE.
        J   = NLET

C       IDENTIFY THIS CHARACTER     
5       JCHAR = FILNAM(J:J)
        IF (JCHAR .EQ. ' ') THEN
C          DISCARD THIS TRAILING BLANK
           NLET = J - 1


        ELSEIF (J .EQ. 1 .OR. JCHAR .EQ. ']' .OR. JCHAR .EQ. ':') THEN
C          FOUND BEGINNING OF DEVICE OR DIRECTORY, HALT BACK SEARCH
           IFIL = J + 1
           GOTO 6


        ELSEIF (JCHAR .EQ. '.') THEN
           IF (NEEDEX) THEN
C            SAVE FILE EXTENSION
             EXTEN = FILNAM(J+1:NLET) // NULL
             GOTEX = .TRUE.

           ELSE
C            DISCARD FILE EXTENSION 
             NLET = J - 1              
           ENDIF

        ELSEIF ((JCHAR .EQ. 'X' .OR. JCHAR .EQ. 'x').AND. NOX) THEN
C          FOUND LAST X IN FILE NAME
           IXL = J
           NOX = .FALSE.

        ELSEIF (JCHAR .LT. '0' .OR. JCHAR .GT. '9') THEN
C          CAN NOT BE A INDEXING X ANY MORE (E.G.  BXA001)
           NOX = .FALSE.
        ENDIF

        J = J - 1
        IF (J .GE .1) GOTO 5


6       CHARI = FILNAM(NLET:NLET)
        NDIGITS = NLET - IXL

        IF (IXL .GT. 0) THEN
C         POSSIBLE REGISTER SUBSTITUTED FILE NAME
          FMT2(3:3) = DIGITS(NDIGITS:NDIGITS)
          READ(FILNAM(IXL+1:NLET),FMT2,ERR=10) IPARM

          IF (IPARM .LT. 0 .OR. IPARM .GT. 100) THEN
             WRITE(NOUT,*) '*** IMPOSSIBLE REGISTER NUMBER:',IPARM
          ELSE
C            FIND REGISTER CONTENTS
             IVAL = PARAM(IPARM+1) + 0.5
          ENDIF

        ELSEIF (((CHARI .GE. 'A' .AND. CHARI .LE. 'Z') .OR.
     &          (CHARI .GE. 'a' .AND. CHARI .LE. 'z')) .AND.
     &           FILNAM(NLET-1:NLET-1) .EQ. '0') THEN
C         GOT >= ONE ZERO BEFORE INDEX SO SUBSTITUTE LOOP COUNTER
          CALL SSUPCAS(CHARI)
          IDX  = INDEX(ALFABT,CHARI)
          IVAL = IALPHA(IDX)
          IXL  = NLET - 2
        ENDIF

        NAST = 0
        IF (IXL .GT. 0) THEN
C         SET FLAG TO OVERWRITE ANY PRECEEDING ASTERICKS
C
C	MAHIEDDINE LADJADJ 
C	3/29/93 CHANGE TO TAKE CARE OF IXL=1
C	REPLACE NEXT LINE BY THE NEXT TWO LINES.
C
C          IAST = INDEX (FILNAM(1:IXL-1),'*')
	  IAST=0
	  IF(IXL.GT.1) IAST = INDEX (FILNAM(1:IXL-1),'*')

          IF (IXL .GT. 1 .AND. IAST .GT. 0) THEN
C            FIND NUMBER OF IMMEDIATLY PRECEEDING ASTERICKS
             DO 17 IT= IXL-1,1,-1
                IF (FILNAM(IT:IT) .EQ. '*') THEN
                  NAST = NAST + 1
                ELSE
                  GOTO 7
                ENDIF
17           CONTINUE
          
          ENDIF
        ENDIF                


7       IF (IXL .GT. 0) THEN
C          SUBSTITUTE FOR A PORTION OF THE FILE NAME
C          FIND NUMBER OF DIGITS TO BE SUBSTITUTED (>=3)
           LENI = NUMDIG(IVAL,3) + NAST
           IF (LENI .GT. 3) THEN
              IF ((IXL - IFIL) .LT. (LENI - 3)) THEN
C                FILE NAME NOT LONG ENOUGH FOR DIGITS
                 WRITE(NOUT,*) '*** FILENAME TOO SHORT FOR SUBSTITUTION'
                 IRTFLG = 1
                 RETURN
               ENDIF
               IXL = IXL - (LENI - 3)

           ELSEIF (IXL .EQ. (NLET-1) .AND. IAST .EQ. 0 .AND.
     &             IXL .NE. 4) THEN
C              SPECIAL KLUDGE FOR FILENAME WITH  X0 (E.G. JNK0X0)
               IXL = IXL - 1

           ENDIF

C          PREPARE FORMAT FOR WRITE
           FMT1(3:3) = DIGITS(LENI:LENI)
           FMT1(5:5) = DIGITS(LENI:LENI)

C          WRITE REGISTER CONTENTS INTO THE FILE NAME
           WRITE(FILNAM(IXL:IXL+LENI-1),FMT1) IVAL
           NLET = IXL+LENI-1

        ENDIF

        FILN = NULL
        FILN(1:NLET+1) = FILNAM(1:NLET) // NULL

        IF (EXTEN(1:1) .NE. NULL .AND. .NOT. GOTEX) THEN
C          EXTENSION RECEIVED FROM CALLER. ADD IT TO FILE NAME
           LENE = INDEX(EXTEN,NULL)
           IF (LENE .EQ. 0) LENE = LEN(EXTEN)
           LENB = INDEX(EXTEN,' ')
           IF (LENB .GT. 0) LENE = MIN(LENE,LENB)
           IF (LENE + NLET .LT. LEN(FILN)) THEN
              FILN = FILN(1:NLET) // '.' // EXTEN(1:LENE) // NULL
              NLET = NLET + LENE + 1

           ELSE
              WRITE(NOUT,*) '*** FILENAME TOO LONG'
              IRTFLG = 1
              RETURN
           ENDIF
        ENDIF

10      WRITE(NECHO,911)  FILN(1:NLET)
        IF (NPROC .NE. 0) WRITE(NPROC,911) FILN(1:NLET)
911     FORMAT(5X,A)

C       SET NORMAL ERROR RETURN
        IRTFLG = 0

      RETURN
      END





d114 1
a114 59
	SUBROUTINE FILERD(FILN,NLET,EXTEN,PROMPT,IRTFLG)

        INCLUDE 'CMBLOCK.INC'

        CHARACTER *(*)  FILN,PROMPT,EXTEN
        CHARACTER  *80  FILNAM
        CHARACTER * 26  ALFABT
        CHARACTER  *24  FMT
        CHARACTER  * 9  DIGITS
        CHARACTER  * 6  FMT1
        CHARACTER  * 4  FMT2
	CHARACTER   *1  CHARI,NULL,JCHAR

        LOGICAL         NOX,NEEDEX,GOTEX

        DATA DIGITS/'123456789'/
        DATA ALFABT/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
        DATA FMT /'($,1X,1H.,A  ,7H FILE: )'/
        DATA FMT1/'(I . )'/
        DATA FMT2/'(I )'/

        NULL = CHAR(0)

        NEEDEX = .FALSE.
        IF (IRTFLG .EQ. 9) NEEDEX = .TRUE.
        GOTEX = .FALSE.

C       SETUP PROMPT LINE
        NP = LEN(PROMPT)
        WRITE(FMT(12:13),8002) NP
8002    FORMAT(I2)

C       PRINT THE PROMPT
	WRITE(NOUT,FMT) PROMPT(:NP)

C       READ THE FILE NAME FROM THE INPUT
	CALL READCH(PROMPT(:NP),NIN,NLET,FILNAM,.FALSE.,IRTFLG)

C       INCREMENT BATCH COUNTER
        IBCNT = IBCNT + 1

C       IFOUND IS FLAG FOR TITLE GIVEN IN INPUT & AFFECTS OPENF OUTPUT
	IFOUND = 0

        IF (NLET .LE. 0) THEN
C          NO FILE NAME IN INPUT
           IRTFLG = -1
           RETURN

        ELSEIF (FILNAM(1:1) .EQ. '^' .OR. FILNAM(1:1) .EQ. '*') THEN
           FILN(1:) = FILNAM(1:1)
           WRITE(NECHO,911)  FILN(1:NLET)
           IF (NPROC .NE. 0) WRITE(NPROC,911) FILN(1:NLET)
           IRTFLG = -1
           RETURN
        ENDIF


C**     slash changed to | for unix *****
d116 1
d118 1
a118 1
C          / FOR TITLE GIVEN IN INPUT
d165 1
a167 1

d198 6
d208 2
a209 1
             WRITE(NOUT,*) '*** IMPOSSIBLE REGISTER NUMBER:',IPARM
d230 1
a230 1
          IF(IXL .GT. 1) IAST = INDEX (FILNAM(1:IXL-1),'*')
d233 1
a233 1
             DO 17 IT= IXL-1,1,-1
d239 1
a239 2
17           CONTINUE
          
d246 2
a247 2
C          FIND NUMBER OF DIGITS TO BE SUBSTITUTED (>=3)
           LENI = NUMDIG(IVAL,3) + NAST
d270 1
a270 1
           NLET = IXL+LENI-1
d285 1
a285 1
              NLET = NLET + 1 + LENE
a301 1
#endif 
@


1.5
log
@just a test for yanhong
@
text
@d466 1
@


1.4
log
@allow | for title on vax , fix first letter of unix title.
@
text
@@


1.3
log
@fixed VMS
@
text
@d118 1
d120 1
a120 1
C          / FOR TIME TITLE GIVEN IN INPUT
d374 1
a374 1
           CTIT(I:LENTIT) = FILNAM(ISLASH+1:)
@


1.2
log
@cpp_lines_added
@
text
@a2 2
#ifdef VMS

d54 3
a58 3
#ifdef SP_UNIX
        INCLUDE 'CMBLOCK.INC'
#else
a59 1
#endif
d305 3
a310 1
#ifdef SP_UNIX
a311 3
#else
        INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
@


1.1
log
@Initial revision
@
text
@d2 3
d58 3
d62 1
d306 246
@
