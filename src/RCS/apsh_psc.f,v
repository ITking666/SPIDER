head	1.41;
access;
symbols
	pre_mrcs:1.41
	healthdept_2018:1.41
	pre_getangas:1.12;
locks; strict;
comment	@c @;


1.41
date	2018.10.03.14.33.55;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2016.11.18.16.30.35;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2016.11.16.18.55.49;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2015.04.28.15.32.55;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2015.04.24.14.04.17;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2012.10.26.15.00.32;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2012.09.10.13.58.31;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2012.09.07.11.42.44;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2012.04.11.14.56.23;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2012.04.02.14.35.48;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2012.03.07.16.36.32;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2012.03.05.20.38.53;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2012.03.03.23.00.41;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2012.02.29.13.47.01;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2012.02.24.15.42.45;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2012.02.24.15.32.36;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.18.13.38.43;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.11.14.38.21;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.23.16.15.10;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2011.12.02.13.54.47;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2011.12.01.17.46.03;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2011.11.04.18.42.50;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.04.18.00.34;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2011.08.29.18.47.54;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2011.04.14.15.59.30;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2011.02.28.15.04.40;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2011.02.17.14.25.28;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2011.02.16.20.21.17;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2011.02.16.18.51.58;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2011.02.08.17.02.40;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2011.02.03.15.48.49;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.25.13.33.09;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.28.15.52.52;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.21.17.25.25;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.13.14.56.44;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.12.18.43.22;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.14.14.18.53;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.13.19.34.44;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.13.18.48.10;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.30.18.05.24;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.24.15.02.10;	author leith;	state Exp;
branches;
next	;


desc
@for use with ap_sh, uses transformed rays & coeff
@


1.41
log
@email_health_dept
@
text
@C++*********************************************************************
C
C   APSH_PSC.F      RTSQ, RENAMED                 JAN 11 ARDEAN LEITH
C                   MAKE_CLOSE_LIST, GETANGAS     FEB 11 ARDEAN LEITH
C                   QU,QM ALLOCATED               FEB 11 ARDEAN LEITH
C                   IRAY1,IRAY2                   NOV 11 ARDEAN LEITH
C                   FBS_WANTED                    NOV 11 ARDEAN LEITH
C                   IRAY CALCULATION              FEB 12 ARDEAN LEITH
C                   AP_ENDS                       MAR 12 ARDEAN LEITH
C                   DENOISE                       SEP 12 ARDEAN LEITH
C                   FOURIER LOWPASS DENOISE       OCT 12 ARDEAN LEITH
C                   AP_STAT_SHC USED              APR 15 ARDEAN LEITH
C                   CAN DENOISE WITHOUT ROTFIRST  NOV 16 ARDEAN LEITH
C
C **********************************************************************
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.                          *
C=* Authors: J. Frank & A. Leith                                       *
C=* Copyright 1985-2016  Health Research Inc.                          *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *       
C=*                                                                    *
C **********************************************************************
C
C  APSH_PSC 
C  
C  PURPOSE: FIND ROTATIONAL AND SHIFT PARAMETERS TO ALIGN A SERIES OF
C           REFERENCE IMAGES WITH SAMPLE IMAGES.
C           USED IF:  CIRCREF_IN_CORE .AND. NUMEXP >= NUMTH. 
C           BY DEFAULT USES COEFFICIENTS, NON-TRANSPOSED RINGS AND
C           COMPLEX VARIABLES TO SPEED UP CALCULATIONS.
C
C SOME PARAMETERS:
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS      (SENT)
C       NUMREF              NO. OF IMAGES                        (SENT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS      (SENT)
C       NUMEXP              NO. OF IMAGES                        (SENT)
C       NX,NY               ACTUAL (NOT-WINDOWED) IMAGE SIZE     (SENT)
C       ISHRANGEX,ISHRANGEY ALLOWED SHIFT RANGE                  (SENT)
C       ISTEP               SHIFT STEP WITHIN RANGE              (SENT)
C       NRING               NUMBER OF CIRCULAR RINGS             (SENT)
C       LCIRC               LENGTH OF CIRCULAR RING ARRAY        (SENT)
C       NUMR                CIRCULAR RING ARRAY INDICES          (SENT)
C       CIRCREF             CIRCULAR RINGS ARRAY                 (SENT)
C       CIRCREF_IN_CORE     INCORE MEMORY USED                   (SENT)
C       MODE                                                     (SENT)
C       REFANGDOC           REF. ANGLES FILE NAME                (SENT)
C       EXPANGDOC           EXP. ANGLES FILE NAME                (SENT)
C       SCRFILE                                                  (SENT)
C       FFTW_PLANS          FFTW PLAN POINTERS                   (SENT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE      (SENT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE      (SENT)
C       RANGE                                                    (SENT)
C       ROTFIRST            ROTATE/SHIFT EXP INPUT IMAGES        (SENT)
C       DENOISE             DENOISE EXP INPUT IMAGES             (SENT)
C       CKMIRROR            LOGICAL FLAG TO CHECK MIRRORING      (SENT)
C       CTYPE               SUB-OPERATION                        (SENT)
C       LUNDOC              DOC FILE I/O UNIT                    (SENT)
C       RAY1,RAY2           RAY RANGE                            (SENT)
C       FBS_WANTED          WANT TO USE RTSF IF ROTFIRST         (SENT)
C
C NOTES:  NON-MPI CODE
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

cpgi$g opt=3

        SUBROUTINE APSH_PSC(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
     &               NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &               NRING,LCIRC,NUMR, CIRCREF,CIRCREF_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,DENOISE,
     &               CKMIRROR,CTYPE,LUNDOC,RAY1,RAY2,FBS_WANTED)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	INTEGER              :: IREFLIST(NUMREF) 
	INTEGER              :: NUMREF 
	INTEGER              :: IEXPLIST(NUMEXP)
	INTEGER              :: NUMEXP,NX,NY,ISHRANGEX,ISHRANGEY
        INTEGER              :: ISTEP,NRING,LCIRC 
        INTEGER              :: NUMR(3,NRING)
	REAL                 :: CIRCREF(LCIRC,NUMREF)
	LOGICAL              :: CIRCREF_IN_CORE
        CHARACTER (LEN=1)    :: MODE
        CHARACTER (LEN=*)    :: REFANGDOC,EXPANGDOC,SCRFILE
        INTEGER *8           :: FFTW_PLANS(*)   ! STRUCTURE POINTERS
        CHARACTER (LEN=*)    :: REFPAT,EXPPAT 
        REAL                 :: RANGE
        LOGICAL              :: ROTFIRST,DENOISE,CKMIRROR
        CHARACTER (LEN=*)    :: CTYPE
        INTEGER              :: LUNDOC
        REAL                 :: RAY1,RAY2 
        LOGICAL              :: FBS_WANTED,CHNG_ORDER,SAY_RAW
  

	LOGICAL              :: MIRRORNEW,GOTREFANG,LIMITRANGE
        LOGICAL              :: WEIGHT
        LOGICAL              :: TRANS        ! FLAG FOR REFORMED RINGS
        LOGICAL              :: CPLX         ! FLAG FOR COMPLEX CROSRNG
        LOGICAL              :: USECOEF      ! FOR TESTING
        LOGICAL              :: ANGINHEADER,GOTEXPANG,FIRST   
        INTEGER              :: NXT

C       AUTOMATIC ARRAYS
	REAL                 :: ANGOUT(3)

C       ALLOCATED ARRAYS
	REAL,    ALLOCATABLE :: EXPBUF(:,:,:)
	REAL,    ALLOCATABLE :: TMPBUF(:,:)
	INTEGER, ALLOCATABLE :: NPROJA(:)
	REAL,    ALLOCATABLE :: DLIST(:,:) 
	REAL,    ALLOCATABLE :: REFDIR(:,:), EXPDIR(:,:) 
	REAL,    ALLOCATABLE :: ANGREF(:,:), ANGEXP(:,:)
        REAL,    ALLOCATABLE :: COEFFS(:,:)
        INTEGER, ALLOCATABLE :: IXY(:,:)
        INTEGER, ALLOCATABLE :: NLOCS(:,:)

        INTEGER, PARAMETER   :: NLISTMAX = 15
        REAL                 :: PARLIST(NLISTMAX)

        REAL,    PARAMETER   :: QUADPI = 3.1415926535897932384626
        REAL,    PARAMETER   :: DGR_TO_RAD = (QUADPI/180)

        INTEGER, PARAMETER   :: LUNT    = 77
        INTEGER, PARAMETER   :: INANG   = 78
        INTEGER, PARAMETER   :: LUNRING = 50

        INTEGER              :: NBORDER = 0       ! # BORDER PIXELS
        INTEGER              :: NSUBPIX = 0       ! # SUBPIX PIXELS
        INTEGER              :: MYPID   = -1      ! NOT FOR MPI

        LOGICAL, PARAMETER   :: MPIBCAST = .TRUE.
 
        LOGICAL              :: erri2
 
C       SET TYPE OF OUTPUT DOC FILES WANTED
        NWANTOUT = 15

C       INITIALIZE CCROT STATISTICS COUNTERS
        ANGDIFTHR   = 0.0
        CALL AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
     &                   CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                   CCROTIMPROV,IWORSECCROT,CCROTWORSE)

        LIMITRANGE  = (RANGE > 0.0)
        RANGECOS    = COS(RANGE * DGR_TO_RAD)  
        !write(6,*) ' range,rangecos:',range,rangecos

C       FIND NUMBER OF OMP THREADS
        CALL GETTHREADS(NUMTH)
        
        NRAYSC = NUMR(3,NRING) / 2     ! # OF RAYS   (FOURIER)
        NRAYS  = NUMR(3,NRING) -2      ! # OF RAYS   (REAL)

        ! CONVERT 0...360 ANGLES TO 1...NRAYS  RAY POSITIONS
        IF (RAY1< 0 .OR. RAY1 >360) THEN
            WRITE(NOUT,*) ' Ray Range:',RAY1,RAY2
            CALL ERRT(101,'INTEGER RAY LIMITS = 0...360',NDUM)
            GOTO 9999
        ELSEIF (RAY2 < 0 .OR. RAY2 >360) THEN
            WRITE(NOUT,*) ' Ray Range:',RAY1,RAY2
            CALL ERRT(101,'INTEGER RAY RANGE = 0...360',NDUM)
            GOTO 9999
        ENDIF

        !IRAY1 = ((RAY1+1) / FLOAT(359)) * NRAYS 
        !IRAY2 = ((RAY2+1) / FLOAT(359)) * NRAYS 
        !IF (RAY1 == 0)    IRAY1 = 1  
        !IF (RAY2 <= 0)    IRAY2 = NRAYS  
        !IF (IRAY2  > 359) IRAY2 = NRAYS  

        IRAY1 = 1 + RAY1 * FLOAT(NRAYS - 1) / 360
        IRAY2 = 1 + RAY2 * FLOAT(NRAYS - 1) / 360
        !IF (RAY2 <= 0)    IRAY2 = NRAYS  
        !IF (IRAY2  > 359) IRAY2 = NRAYS  

        !rangnew1 = ang_n(float(iray1),mode,nrays)
        !rangnew2 = ang_n(float(iray2),mode,nrays)
        !write(6,*) ' Nrays:',nrays,nring,nraysc,ray1,ray2
        !write(6,*) ' Ray range:',ray1,ray2,'-->',iray1,iray2
        !write(6,*) ' raynum:  ',iray1,iray2,'-->',rangnew1,rangnew2

	ALLOCATE(EXPBUF(NX,NY,NUMTH), 
     &           DLIST(5,NUMTH), 
     &           NPROJA(NUMTH),    STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           MWANT = NX*NY*NUMTH + 6*NUMTH    
           CALL ERRT(46,'APSH_PSC; EXPBUF & DLIST...',MWANT)
           GOTO 9999
        ENDIF
 
        ANGINHEADER = .FALSE. ! unfinished !!!!!!!!!!!

        IF (DENOISE) THEN

           N2X   = NX * 2
           N2Y   = NY * 2
           N2XLD = N2X + 2 - MOD(N2X,2)
           NXLD  = NX + 2 - MOD(NX,2) ! FFT PAD
           NXT   = NX
           IF (FBS_WANTED) NXT = NXLD ! FOR BUFFER IN CALLEE

	   ALLOCATE(TMPBUF(N2XLD,N2Y), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_PSC; TMPBUF',N2XLD*N2Y)
              GOTO 9999
           ENDIF

        ELSEIF (ROTFIRST) THEN
	   ALLOCATE(TMPBUF(NX,NY), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_PSC; TMPBUF',NX*NY)
              GOTO 9999
           ENDIF

           anginheader = (expangdoc .eq. '*') ! unfinished !!!!!!!!!!!
        ENDIF

        DLIST = 0.0        ! ZEROS WHOLE DLIST

C       CHOICES: SHC, SHCT,SHCU, SHCUC, SHCTC

        ILENC      = LNBLNKN(CTYPE) 
        CHNG_ORDER = .TRUE.    ! ORDER OF SHIFT AND ROTATE
        SAY_RAW    = .FALSE.   ! REPORT SHIFT AFTER ROTATION COMPENSATION
        IF (ILENC > 3) SAY_RAW = (INDEX(CTYPE(:ILENC),'R') > 0)
        IF (SAY_RAW) THEN
            WRITE(NOUT,*)' REPORTING RAW SHIFT VALUES IN REG: 13 & 14'
        ENDIF

        USECOEF = .TRUE. 
        WEIGHT  = .TRUE.    ! REF. IMAGES HAVE WEIGHTED FFT'S
        TRANS   = .FALSE.   ! DO NOT USE REFORMED RINGS/RAYS
        CPLX    = .TRUE.    ! USE COMPLEX CROSRNG VARIABLES
        IF (ILENC > 3) TRANS   = (CTYPE(4:4) .EQ. 'T')
        IF (ILENC > 4) CPLX    = (CTYPE(5:5) .EQ. 'C')
        IF (ILENC > 5) USECOEF = .NOT. (CTYPE(5:5) .EQ. 'N')
 
        !write(6,*) 'trans:',trans,'  cplx:',cplx,'  usecoef:',usecoef

        IF (TRANS) THEN
C          SET # OF POINTS ON EACH RAY AND RAY STARTING INDEX IN CIRC
C          THIS IS ONLY USED FOR TRANSFORMED RING ORDERS
	   ALLOCATE( NLOCS(2,NRAYSC+1), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              MWANT = 2*NRAYSC+2  
              CALL ERRT(46,'APSH_PSC; NLOCS',MWANT)
              GOTO 9999
           ENDIF 
  
           CALL APRINGS_TRANS_LOCS(NUMR,NRING, NLOCS,NRAYSC)
        ELSE
	   ALLOCATE(NLOCS(1,1),  STAT=IRTFLG)
        ENDIF

        IF (USECOEF) THEN
	   ALLOCATE(COEFFS(6,LCIRC), IXY(2,LCIRC), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              MWANT = 6*LCIRCR +2*LCIRCR 
              CALL ERRT(46,'APSH_PSC; COEFFS...',MWANT)
              GOTO 9999
           ENDIF 
           IXY     = -100       ! FOR HANDLING CIRC PADS
           COEFFS  = 0.0

c                     write(6,*) ' aprings  coef Threads:',numth
c          if (trans) write(6,*) ' aprings  transformed rings' 
c          if (cplx)  write(6,*) ' aprings  complx crosrngs'

C          READ REFERENCE IMAGES INTO REFERENCE RINGS ARRAY (CIRCREF) 
C          OR CREATE REFERENCE RINGS FILE FOR LATER READING
C          SAVES COEFFS FOR LATER USE 
           CALL APRINGS_NEW_COEF(IREFLIST,NUMREF,  NX,NY,
     &                       NRING,LCIRC,NUMR, NLOCS,NRAYSC,
     &                       COEFFS,IXY,
     &                       MODE,FFTW_PLANS,
     &                       REFPAT,LUNT, CIRCREF,CIRCREF_IN_CORE,
     &                       LUNRING,SCRFILE, WEIGHT, TRANS,IRTFLG)
        ELSE
C          ONLY USED DURING TESTING!
C          READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
           CALL APRINGS_NEW(IREFLIST,NUMREF, NX,NY,
     &               NRING,LCIRC,NUMR, MODE,FFTW_PLANS,
     &               REFPAT,LUNT,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)
        ENDIF

       !call chkring(2,.false., circref,lcirc, numr,nring, ndum,ndum)
       !call chkray (2,.false., circref,lcirc, numr,nring, ndum,ndum)

	ALLOCATE(REFDIR(3,NUMREF),
     &           ANGREF(3,NUMREF), STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'APSH_PSC; REFDIR, ANGREF',6*NUMREF)
           GOTO 9999
        ENDIF 

C       READ REF. ANGLES INTO ANGREF FROM HEADER OR DOC FILE
C       CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
        CALL AP_GETANGAS(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                   LUNT,INANG,3,ANGREF,GOTREFANG,NGOTREF,
     &                   .TRUE.,REFDIR,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        NGOTPAR = 0
        IF (EXPANGDOC .NE. CHAR(0)) THEN
	   ALLOCATE(ANGEXP(8,NUMEXP), 
     &              EXPDIR(3,NUMEXP), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_PSC; ANGEXP....',11*NUMEXP)
              GOTO 9999
           ENDIF 

C          READ EXP. ANGLES INTO ANGEXP
C          CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS (EXPDIR).
	   CALL AP_GETANGAS(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                      LUNT,INANG,8,ANGEXP,GOTEXPANG,NGOTPAR,
     &                      .TRUE.,EXPDIR,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

        ELSE
C          DUMMY ALLOCATE TO AVOID BUS ERROR ON SOME SYSTEMS
	   ALLOCATE(ANGEXP(8,1), EXPDIR(3,1), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_PSC; ANGEXP....',11)
              GOTO 9999
           ENDIF 
        ENDIF

        !print *,'gotexpang:',gotexpang,ngotpar
        !print *,'angexp:',angexp(:,1)
        !print *,'expdir:',expdir(:,1)
        !write(6,*) ' Rotfirst,angin:',ROTFIRST,denoise,ANGINHEADER

C       LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES -------------


 	DO IEXPT=1,NUMEXP,NUMTH

C          LOAD EXP. IMAGE DATA FOR THIS MP SET OF IMAGES INTO EXPBUF
           IEND = MIN(NUMEXP,IEXPT+NUMTH-1)

           IF (DENOISE) THEN
C             DENOISE, ROTATE/SHIFT EXP IMAGES, NEEDS 2XFFT PAD
 
	      CALL AP_GETDATA_DEN(IEXPLIST,NUMEXP, 
     &                    NXT,NX,NY, N2XLD,N2X,N2Y, 0.0,
     &                    NUMTH,EXPPAT,LUNT, IEXPT,IEND,
     &                    ANGINHEADER, ANGEXP, 
     &                    MPIBCAST,TMPBUF,EXPBUF,
     &                    FBS_WANTED,ROTFIRST,IRTFLG)

           ELSEIF (ROTFIRST) THEN
C             ROTATE/SHIFT EXP IMAGES WHEN READING THEM, NO PADDING,

	      CALL AP_GETDATA_RTSQ(IEXPLIST,NUMEXP, 
     &                    NX,NY, NX,NY,0.0,
     &                    NUMTH,EXPPAT,LUNT, IEXPT,IEND,
     &                    ANGINHEADER, ANGEXP, 
     &                    MPIBCAST,TMPBUF,EXPBUF,
     &                    .FALSE., ADUM, ADUM, FBS_WANTED,IRTFLG)

           ELSE
C             NO ROTATE, NO PADDING, NO DENOISE
	      CALL AP_GETDATA(IEXPLIST,NUMEXP,
     &                    NX,NY, NX,NY,0.0,
     &                    NUMTH,EXPPAT,LUNT, IEXPT,IEND,
     &                    MPIBCAST,  EXPBUF,  
     &                    .FALSE., ADUM, ADUM, IRTFLG)
           ENDIF
           IF (IRTFLG .NE. 0) GOTO 9999

C          NUMTH EXP. IMAGES READY TO BE ALIGNED

c$omp      parallel do private(iexp,it)
	   DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
              IT = IEXP - IEXPT + 1

	      CALL APRQ2DC(EXPBUF(1,1,IT),CIRCREF,NUMR,
     &	            NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &	            IRAY1,IRAY2,LCIRC,NRING,NUMREF,MODE,
     &              REFDIR,EXPDIR(1,IEXP),RANGECOS,
     &              DLIST(1,IT),DLIST(2,IT),
     &              DLIST(3,IT),DLIST(4,IT),
     &              DLIST(5,IT),NPROJA(IT),
     &              CKMIRROR,LIMITRANGE,FFTW_PLANS,
     &              COEFFS,IXY,NLOCS,NRAYSC,TRANS,CPLX,USECOEF,
     &              NBORDER,NSUBPIX)
	   ENDDO
c$omp      end parallel do

C          OUTPUT FROM DLIST POSITION 
C          1 - NUMBER OF MOST SIMILAR REFERENCE PROJECTION.
C          2 - NOT-NORMALIZED CORRELATION COEFFICIENT.
C          3 - PSI ANGLE. (IN=PLANE ROTATION) RANGNEW
C          4 - SX SHIFT
C          5 - SY SHIFT
         
           DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
              IT     = IEXP - IEXPT + 1
              IMGEXP = IEXPLIST(IEXP)

C             DLIST(1,IT) IS LIST NUMBER OF MOST SIMILAR REF. IMAGE 
C                 (<0 IF MIRRORED, 0 IF NO SIMILAR IMAGE )

              IREF = INT(DLIST(1,IT))
              IF (IREF < 0) THEN
C                MIRRORED REFERENCE IMAGE
                 IMGREF = IREFLIST(-IREF)

C                IREFT IS FOR REFDIR INDEX
                 IREFT     = -IREF
                 MIRRORNEW = .TRUE.

              ELSEIF (IREF == 0) THEN
C                NO NEARBY REFERENCE IMAGE
                 IMGREF = 0

C                IREFT IS FOR REFDIR INDEX
                 IREFT     = 1
                 MIRRORNEW = .FALSE.

              ELSE
                 IMGREF = IREFLIST(IREF)
C                IREFT IS FOR REFDIR INDEX
                 IREFT     = IREF
                 MIRRORNEW = .FALSE.
              ENDIF
 
              CCROT    = DLIST(2,IT)
              RANGNEW  = DLIST(3,IT)
              XSHRAW   = DLIST(4,IT)
              YSHRAW   = DLIST(5,IT)
              NPROJ    = NPROJA(IT)
              PEAKV    = 1.0

C             WRITE DATA TO DOC FILE
              CALL AP_ENDS(IEXP,IMGEXP,IMGREF,
     &                ANGREF(1,IREFT),REFDIR(1,IREFT),
     &                ANGEXP(1,IEXP), EXPDIR(1,IEXP),ISHRANGEX,
     &                GOTREFANG, NGOTPAR, CCROT,PEAKV,
     &                RANGNEW,XSHRAW,YSHRAW, MIRRORNEW,REFPAT,
     &                NPROJ, CTYPE, LUNDOC,
     &                CHNG_ORDER,SAY_RAW,PARLIST)

C             WRITE DATA TO IMAGE HEADER
              CALL AP_END_HEAD(IMGEXP,EXPPAT,LUNT,PARLIST,8,IRTFLG)

C             UPDATE CCROT & ANGULAR DISPLACEMENT STATISTICS COUNTERS
              CALL AP_STAT_ADD(NGOTPAR,CCROT,PARLIST(10),
     &                       ANGDIFTHR,ANGEXP(8,IEXP),
     &                       CCROTAVG,IBIGANGDIF,ANGDIFAVG,IMPROVCCROT,
     &                       CCROTIMPROV,IWORSECCROT,CCROTWORSE)

	   ENDDO
	ENDDO

        IF (LUNDOC > 0) THEN
C         SAVE CCROT & ANGULAR DISPLACEMENT STATISTICS

          ! IF NO ALIGN DOC INPUT -->  NO CCROT DIFFERENCES
          FIRST   = NGOTPAR == 0        ! FIRST FILE, NO DIFFERENCES

          CALL AP_STAT_SHC(NUMEXP,ANGDIFTHR,IBIGANGDIF,
     &                 ANGDIFAVG, CCROTAVG,
     &                 IMPROVCCROT,CCROTIMPROV,
     &                 IWORSECCROT,CCROTWORSE,
     &                 NBORDER,NSUBPIX,LUNDOC,FIRST)
        ENDIF

9999    CONTINUE

C       DEALLOCATE  ARRAYS
        IF (ALLOCATED(DLIST))      DEALLOCATE(DLIST)
        IF (ALLOCATED(NPROJA))     DEALLOCATE(NPROJA)
	IF (ALLOCATED(EXPBUF))     DEALLOCATE(EXPBUF)
	IF (ALLOCATED(REFDIR))     DEALLOCATE(REFDIR)
	IF (ALLOCATED(EXPDIR))     DEALLOCATE(EXPDIR)
	IF (ALLOCATED(ANGEXP))     DEALLOCATE(ANGEXP)
	IF (ALLOCATED(ANGREF))     DEALLOCATE(ANGREF)

        IF (ALLOCATED(NLOCS))      DEALLOCATE(NLOCS)
        IF (ALLOCATED(COEFFS))     DEALLOCATE(COEFFS)
        IF (ALLOCATED(IXY))        DEALLOCATE(IXY)
        IF (ALLOCATED(TMPBUF))     DEALLOCATE(TMPBUF)

       
       END



C+**********************************************************************
C
C APRQ2DC.F
C 
C  PARAMETERS:
C                DIREF    NUMBER OF  MOST SIMILAR REF. PROJ.  (OUTPUT)
C                            (NEGATIVE IF MIRRORED)
C                CCROT    CORR COEFF.                         (OUTPUT)
C                RANGNEW  INPLANE ANGLE                       (OUTPUT)
C                XSHRAW   SHIFT                               (OUTPUT)
C                YSHRAW   SHIFT                               (OUTPUT)
C                NPROJ                                        (OUTPUT)
C
C-**********************************************************************

	SUBROUTINE APRQ2DC(EXPBUF,CIRCREF,NUMR,
     &	             NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &	             IRAY1,IRAY2,LCIRC,NRING,NUMREF,MODE,
     &               REFDIR,EXPDIR,RANGECOS,
     &               DIREF,CCROT,RANGNEW,XSHRAW,YSHRAW,NPROJ,
     &               CKMIRROR,LIMITRANGE,FFTW_PLANS,
     &               COEFFS,IXY,NLOCS,NRAYSC, TRANS,CPLX,USECOEF,
     &               NBORDER,NSUBPIX)

C       NOTE: RUNS WITHIN OMP PARALLEL SECTION OF CODE!
        INCLUDE 'MAKE_CLOSE_LIST.INC'  

	REAL                   :: EXPBUF(NX,NY)
        COMPLEX                :: CIRCREF(LCIRC/2,NUMREF)
        INTEGER                :: NUMR(3,NRING) 
        INTEGER                :: NX,NY,ISHRANGEX,ISHRANGEY,ISTEP 
        INTEGER                :: IRAY1,IRAY2,LCIRC,NRING,NUMREF 
        CHARACTER (LEN=1)      :: MODE
	REAL                   :: REFDIR(3,NUMREF), EXPDIR(3)
	REAL                   :: RANGECOS,DIREF,CCROT,RANGNEW
        REAL                   :: XSHRAW,YSHRAW
        INTEGER                :: NPROJ 
        LOGICAL                :: CKMIRROR,LIMITRANGE
        INTEGER *8             :: FFTW_PLANS(*)  ! STRUCTURE POINTERS
        REAL                   :: COEFFS(6,LCIRC)
        INTEGER                :: IXY(2,LCIRC)
        INTEGER                :: NLOCS(2,*)
        INTEGER                :: NRAYSC
        LOGICAL                :: TRANS          ! TRANSFORMED RAYS
        LOGICAL                :: CPLX           ! COMPLEX CROSRNG
        LOGICAL                :: USECOEF        ! FOR TESTING
        INTEGER                :: NBORDER,NSUBPIX

C       AUTOMATIC ARRAYS
	REAL                   :: CC(-ISTEP:ISTEP,-ISTEP:ISTEP)
	REAL                   :: CCP(-1:1,-1:1)

C       ALLOCATABLE ARRAYS
        REAL, ALLOCATABLE      :: CIRCT(:)
        COMPLEX, ALLOCATABLE   :: CIRCEXP(:)
        COMPLEX, ALLOCATABLE   :: QU(:),QM(:)
        INTEGER, POINTER       :: LCG(:)

	REAL                   :: PEAK
	REAL                   :: CCROT_INTERP,CCNOW
        LOGICAL                :: MIRRORED,ALLRAYS
        LOGICAL                :: ISMIRRORED,USE_UN,USE_MIR
        LOGICAL                :: ISMIRROREDT

        REAL                   :: WR(1)
 	REAL                   :: POS_MAX

        LOGICAL, PARAMETER     :: USE_OMP = .FALSE.

	REAL                   :: ang_n

        PEAK    = 0.0    ! UNUSED?
        WR(1)   = 0.0    ! DUMMY VALUE FLAG FOR APRINGS CALL

        MAXRIN  = NUMR(3,NRING) - 2 ! ACTUAL LENGTH OF LONGEST RING
        LCIRCD2 = LCIRC / 2
        NULLIFY(LCG)         ! INTEL COMPILER NEEDS THIS 2016

C       IF LIMITRANGE, MAKE LIST OF CLOSE REF. IMAGES, RETURNS: NPROJ
        CALL MAKE_CLOSE_LIST(NUMREF,LIMITRANGE,
     &                       REFDIR,EXPDIR,
     &                       RANGECOS, CKMIRROR, 
     &                       LCG, NPROJ, IRTFLG)

        ALLRAYS = (IRAY1 == 1 .AND. IRAY2 == MAXRIN) 

 	IF (NPROJ <= 0) THEN
C          THERE IS NO REFERENCE WITHIN SEARCH RANGE
           XSHRAW  = 0
	   YSHRAW  = 0
           DIREF   = 0     ! FEEDS INTO DLIST
           RANGNEW = 0
           CCROT   = -1.0 
           RETURN	
        ENDIF
	  
	ALLOCATE(CIRCEXP(LCIRCD2),
     &           CIRCT(LCIRC), 
     &           QU(LCIRCD2+1), 
     &           QM(LCIRCD2+1), 
     &           STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL ERRT(46,'APSH_PSC; CIRCEXP...',4*LCIRC+4)
           RETURN 
        ENDIF
 
	CCROT    = -HUGE(CCROT)    ! HIGHEST CC VALUE

C       SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
        USE_UN  = .TRUE.
        USE_MIR = CKMIRROR

c       GO THROUGH CENTERS FOR SHIFT ALIGNMENT ------------------------
	DO JT= -ISHRANGEY,ISHRANGEY,ISTEP
	   CNR2 = NY / 2 + 1 + JT

	   DO IT= -ISHRANGEX,ISHRANGEX,ISTEP
	      CNS2 = NX / 2 + 1 + IT

C             NORMALIZE EXP VALUES UNDER MASK OVER VARIANCE RANGE.
C             INTERPOLATE TO POLAR COORD. AROUND: CNS2,CNR2.
C             CREATE FOURIER OF RINGS, NO WEIGHTING OF RINGS        

              CALL APRINGS_SATU(EXPBUF,NX,NY,CNS2,CNR2, 
     &                          MODE,NUMR,NRING,LCIRC,USE_OMP,
     &                          WR,FFTW_PLANS, NLOCS,NRAYSC,
     &                          COEFFS,IXY, USECOEF,TRANS,CPLX,
     &                          CIRCT,  CIRCEXP, IRTFLG)
              IF (IRTFLG .NE. 0) RETURN

  
C             COMPARE EXP. RING WITH ALL REFERENCE RINGS ------------

	      DO IRR=1,NPROJ  ! LOOP OVER ALL REF. IMAGES
                 IR = IRR
                 IF (LIMITRANGE) THEN
C                    ONLY CHECKING NEARBY PROJECTIONS
                     IR = ABS(LCG(IRR))
                     IF (CKMIRROR ) THEN
C                       ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                        USE_UN  = (LCG(IRR) >= 0)
                        USE_MIR = (LCG(IRR) <  0)
                     ENDIF
                 ENDIF

C                CROSS CORRELATION PEAK DETERMINATION
#ifdef DEBUGT  
                 CALL CROSRNG_SATU(CIRCEXP,CIRCREF(1,IR),
     &                        NUMR,NRING,LCIRC,
     &                        FFTW_PLANS, NLOCS,NRAYSC,
     &                        TRANS,CPLX, USE_UN,USE_MIR,
     &                        ISMIRRORED,CCNOW,POS_MAX, IRTFLG)
#else     
                 IF (ALLRAYS) THEN
                    CALL CROSRNG_2CQR(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
     &                        NRING,MAXRIN,NUMR,
     &                        .FALSE., FFTW_PLANS, 
     &                        USE_UN,USE_MIR,
     &                        QU,QM,
     &                        ISMIRRORED,CCNOW,POS_MAX, MAXL)
                 ELSE
                    CALL CROSRNG_2CQRR(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
     &                        NRING,MAXRIN,NUMR,IRAY1,IRAY2,
     &                        .FALSE., FFTW_PLANS, 
     &                        USE_UN,USE_MIR,
     &                        QU,QM,
     &                        ISMIRRORED,CCNOW,POS_MAX, MAXL)
                 ENDIF
#endif

                 IF (CCNOW .GE. CCROT)  THEN
C                   THIS POSITION IS BEST SO FAR OVER ALL REFS & SHIFTS
	            RANGNEW  = ANG_N(POS_MAX,MODE,MAXRIN)! BEST ROTATION
C                   write(6,'(a,i5,3f9.2,3i4)')' rangnew0:',
C     &                      maxl,pos_max,rangnew,ccnow,it,jt
	            CCROT    = CCNOW  ! BEST CC VALUE
	            IBE      = IR     ! BEST REFERENCE IMAGE
	            ISX      = IT     ! BEST X SHIFT
	            ISY      = JT     ! BEST Y SHIFT
	            IDIS     = IR     ! BEST MIRROR FLAG & REF. #
                    IF (ISMIRRORED) IDIS = -IR
	         ENDIF

	      ENDDO ! END OF:  DO IRR=1,NPROJ --------------------- REFS.
           ENDDO    ! END OF:  DO IT=-ISHRANGEX,ISHRANGEX,ISTEP
	ENDDO       ! END OF:  DO JT=-ISHRANGEY,ISHRANGEY,ISTEP

        !write(6,'(a,2i4,3x,f8.2)') ' 0 X,Y:',isx,isy,ccrot 
        !write(6,*) ' '
        !write(6,'(a,2f9.2,i5)') ' rangnew1:',rangnew,CCROT

        ISTEPX = ISTEP
        IF (ISHRANGEX <= 0) ISTEPX = 0
        ISTEPY = ISTEP
        IF (ISHRANGEY <= 0) ISTEPY = 0

        IF (ISTEP > 1) THEN
C          CHECK NEIGHBORING LOCATIONS OF BEST REF's BEST CC'S

           IR   = IBE     ! BEST REF IMAGE
	   ISXT = ISX     ! BEST X SHIFT FOR THIS REF IMAGE
           ISYT = ISY     ! BEST Y SHIFT FOR THIS REF IMAGE

           !write(6,'a,3i4,3x,f8.2') ' Ref:',ir,isxt,isyt, ccrot 

C          WHAT IF X OR Y RANGE IS ZERO?
           JT1 = -ISTEP+1
           JT2 =  ISTEP-1
           IF (ISHRANGEY <= 0) THEN
               JT1 = 0
               JT2 = 0
           ENDIF
           IT1 = -ISTEP+1
           IT2 =  ISTEP-1
           IF (ISHRANGEX <= 0) THEN
               IT1 = 0
               IT2 = 0
           ENDIF

           DO JT= JT1,JT2                          ! OVER Y
	      CNR2 = NY / 2 + 1 + JT + ISYT         ! CENTER

	      DO IT= IT1,IT2                        ! OVER X
	         CNS2 = NX / 2 + 1 + IT + ISXT      ! CENTER

   	         IF (IT == 0 .AND. JT == 0) CYCLE     ! ALREADY HAVE 
                 IF (((ISXT + IT) < -ISHRANGEX) .OR.
     &               ((ISXT + IT) >  ISHRANGEX) .OR.
     &               ((ISYT + JT) < -ISHRANGEY) .OR.
     &               ((ISYT + JT) >  ISHRANGEY)) CYCLE ! OUT OF SHIFT 

                 !write(6,'a,2i5') ' Checking: ',isxt+it,isyt+jt

C                NORMALIZE EXP VALUES UNDER MASK OVER VARIANCE RANGE.
C                INTERPOLATE TO POLAR COORD. AROUND: CNS2,CNR2.
C                CREATE FOURIER OF RINGS, NO WEIGHTING OF RINGS        
                 CALL APRINGS_SATU(EXPBUF,NX,NY,CNS2,CNR2, 
     &                     MODE,NUMR,NRING,LCIRC,USE_OMP,
     &                     WR,FFTW_PLANS, NLOCS,NRAYSC,
     &                     COEFFS,IXY, USECOEF,TRANS,CPLX,
     &                     CIRCT,  CIRCEXP, IRTFLG)
                 IF (IRTFLG .NE. 0) RETURN
 
#ifdef DEBUGT  
C                CROSS CORRELATION PEAK DETERMINATION
                 CALL CROSRNG_SATU(CIRCEXP,CIRCREF(1,IR),
     &                             NUMR,NRING,LCIRC,
     &                             FFTW_PLANS, NLOCS,NRAYSC,
     &                             TRANS,CPLX, USE_UN,USE_MIR,
     &                             ISMIRROREDT,CC(IT,JT),POS_MAX,IRTFLG)
#else
                 IF (ALLRAYS) THEN
                    CALL CROSRNG_2CQR(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
     &                             NRING,MAXRIN,NUMR,
     &                             .FALSE., FFTW_PLANS, 
     &                             USE_UN,USE_MIR,
     &                             QU,QM,
     &                             ISMIRROREDT,CC(IT,JT),
     &                             POS_MAX, MAXL)
                 ELSE
                    CALL CROSRNG_2CQRR(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
     &                             NRING,MAXRIN,NUMR,IRAY1,IRAY2,
     &                             .FALSE., FFTW_PLANS, 
     &                             USE_UN,USE_MIR,
     &                             QU,QM,
     &                             ISMIRROREDT,CC(IT,JT),
     &                             POS_MAX, MAXL)
                 ENDIF
#endif
                 IF (IRTFLG .NE. 0) RETURN

	         IF (CC(IT,JT) > CCROT)  THEN
C                   CC VALUE HIGHER THAN CURRENT BEST
	            RANGNEW = ANG_N(POS_MAX ,MODE,MAXRIN)
	            CCROT   = CC(IT,JT) ! BEST CC VALUE
                    IBE     = IR        ! BEST REF. # 
	            ISX     = IT + ISXT ! BEST X SHIFT
	            ISY     = JT + ISYT ! BEST Y SHIFT
                    IBE     = IR        ! BEST REF. # 
 	            IDIS    = IR        ! BEST MIRROR FLAG & REF. #
                    IF (ISMIRROREDT) IDIS = -IR
	         ENDIF

	      ENDDO     ! END OF:  DO IT=-ISTEP,ISTEP
           ENDDO        ! END OF:  DO JT=-ISTEP,ISTEP
      
        ELSE
C          NO NEED TO CHECK STEPPED SHIFT LOCATIONS  
        ENDIF
        !write(6,'(a,2f8.2)') ' rangnew2:',rangnew,pos_max

        SX       = ISX              ! BEST X SHIFT
        SY       = ISY              ! BEST Y SHIFT
        DIREF    = IDIS             ! REAL AS FEEDS INTO DLIST
        MIRRORED = (IDIS .LT. 0 )   ! CHECK MIRRORED ONLY IF(IDIS.LT.0) 

        !write(6,'a,2i4,3x,f8.2') ' 1 X,Y:',isx,isy,ccrot 

        IF (ABS(ISX) == ISHRANGEX .OR. ABS(ISY) == ISHRANGEY) THEN

           NBORDER = NBORDER + 1    ! ON BORDER, SKIP SUB-PIXEL
        ELSE
C          NOTE: RECOVER ARRAY FOR SUBPIXEL CCROT AROUND BEST SHIFT
C          NOTE: NO EASY WAY TO RECOVER SUBPIXEL ARRAY EVEN IF ISTEP=1!!

C          LOAD CC VALUES FOR SHIFTS ADJACENT TO MAX CC SHIFT 
	   CCP(0,0) = CCROT

           DO JT= -1,1
	      CNR2 = NY / 2 + 1 + JT + ISY     ! CENTER
	      DO IT= -1,1
	         CNS2 = NX / 2 + 1 + IT + ISX  ! CENTER

   	         IF (IT == 0 .AND. JT == 0) CYCLE ! ALREADY HAVE THIS

C                NORMALIZE EXP VALUES UNDER MASK OVER VARIANCE RANGE.
C                INTERPOLATE TO POLAR COORD. AROUND: CNS2,CNR2.
C                CREATE FOURIER OF RINGS, NO WEIGHTING OF RINGS        
                 CALL APRINGS_SATU(EXPBUF,NX,NY,CNS2,CNR2, 
     &                        MODE,NUMR,NRING,LCIRC,USE_OMP,
     &                        WR,FFTW_PLANS, NLOCS,NRAYSC,
     &                        COEFFS,IXY, USECOEF,TRANS,CPLX,
     &                        CIRCT, CIRCEXP,   IRTFLG)
 
C                CROSS CORRELATION PEAK DETERMINATION
#ifdef DEBUG  
                 CALL CROSRNG_SATU(CIRCEXP,CIRCREF(1,IBE),
     &                        NUMR,NRING,LCIRC,
     &                        FFTW_PLANS, NLOCS,NRAYSC,
     &                        TRANS,CPLX, .NOT. MIRRORED,MIRRORED,
     &                        ISMIRRORED,CCP(IT,JT), POS_MAX,IRTFLG)
#else
                IF (ALLRAYS ) THEN
                    CALL CROSRNG_2CQR(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
     &                        NRING,MAXRIN,NUMR,
     &                        .FALSE., FFTW_PLANS, 
     &                        .NOT.MIRRORED,MIRRORED,
     &                        QU,QM,
     &                        ISMIRROREDT,CCP(IT,JT),
     &                        POS_MAX, MAXL)
                ELSE
                   CALL CROSRNG_2CQRR(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
     &                        NRING,MAXRIN,NUMR,IRAY1,IRAY2,
     &                        .FALSE., FFTW_PLANS, 
     &                        .NOT.MIRRORED,MIRRORED,
     &                        QU,QM,
     &                        ISMIRROREDT,CCP(IT,JT),
     &                        POS_MAX, MAXL)
                 ENDIF
#endif

	      ENDDO     ! END OF:  DO IT=-ISTEP,ISTEP
           ENDDO        ! END OF:  DO JT=-ISTEP,ISTEP

777        continue


C          SUB-PIXEL INTERPOLATION -----------------------------------

           !write(6,'(a,2f8.2)') ' rangnew3:',rangnew,pos_max 
           !write(6,*) 'cc' write(6,910) cc
910        format(3f14.4,/,3f14.4,/,3f14.4)

C          SUB-PIXEL INTERPOLATION 
           CALL PARABL(CCP,SSX,SSY,PEAK)  ! RETURNS: SSX,SSY,PEAK 

	   CNS2 = NX/2+1 + SX + SSX
	   CNR2 = NY/2+1 + SY + SSY

           !write(6,'a,2f8.2,3x,2f8.2')' 3 X,Y:',sx+ssx,sy+ssy,CNR2,CNS2 
           !write(6,'(a,f8.2)') ' rangnew4:',rangnew 

C          NORMALIZE EXP VALUES UNDER MASK OVER VARIANCE RANGE.
C          INTERPOLATE TO POLAR COORD. AROUND: CNS2,CNR2.
C          CREATE FOURIER OF RINGS, NO WEIGHTING OF RINGS        
C          CAN NOT USE: APRINGS_ONE_COEF AS NOT INTEGRAL SHIFT.

           CALL APRINGS_SATU(EXPBUF,NX,NY,CNS2,CNR2, 
     &                     MODE,NUMR,NRING,LCIRC,USE_OMP,
     &                     WR,FFTW_PLANS, NLOCS,NRAYSC,
     &                     COEFFS,IXY, .FALSE.,TRANS,CPLX,
     &                     CIRCT,CIRCEXP,   IRTFLG)

C          CROSS CORRELATION PEAK DETERMINATION
#ifdef DEBUGT  
           CALL CROSRNG_SATU(CIRCEXP,CIRCREF(1,IBE),
     &                       NUMR,NRING,LCIRC,
     &                       FFTW_PLANS, NLOCS,NRAYSC,
     &                       TRANS,CPLX, .NOT. MIRRORED,MIRRORED,
     &                       ISMIRRORED,CCROT_INTERP,POS_MAX_INTERP, 
     &                       IRTFLG)
#else
           IF ( ALLRAYS) THEN
               CALL CROSRNG_2CQR(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
     &                       NRING,MAXRIN,NUMR,
     &                       .FALSE., FFTW_PLANS, 
     &                       .NOT. MIRRORED,MIRRORED,
     &                       QU,QM,
     &                       ISMIRRORED,CCROT_INTERP,
     &                       POS_MAX_INTERP, MAXL)
           ELSE
              CALL CROSRNG_2CQRR(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
     &                       NRING,MAXRIN,NUMR,iray1,iray2,
     &                       .FALSE., FFTW_PLANS, 
     &                       .NOT. MIRRORED,MIRRORED,
     &                       QU,QM,
     &                       ISMIRRORED,CCROT_INTERP,
     &                       POS_MAX_INTERP, MAXL)
           ENDIF
#endif
 
           IF (CCROT_INTERP > CCROT) THEN
C                USE SUB-PIXEL LOCATION INSTEAD OF INTEGRAL LOCATION

              !write(6,961) ssx,ssy, ccrot_interp,ccrot 
961           format(' Subpixel:',2f8.2,'    ',f9.2,' >> ',f9.2)

	      RANGNEW = ANG_N(POS_MAX_INTERP,MODE,MAXRIN) ! BEST ROT.
              CCROT   = CCROT_INTERP   ! HIGHEST CC 
	      SX      = SX + SSX       ! BEST X SHIFT
              SY      = SY + SSY       ! BEST Y SHIFT
              NSUBPIX = NSUBPIX + 1    ! SUB-PIXEL COUNTER

           ENDIF  ! END OF: (CCROT_INTERP > CCROT)
        ENDIF     ! END OF: IF (ABS(ISX).NE. ISHRANGEX.......

        XSHRAW = SX
        YSHRAW = SY

C       CHANGE ORDER OF SHIFT & ROTATION IN: AP_ENDS
        !write(6,'(a,2i4,f8.2)') 'X,Y:',isx,isy,ccrot 

9999    IF (ASSOCIATED(LCG))    DEALLOCATE(LCG)
        IF (ALLOCATED(CIRCEXP)) DEALLOCATE(CIRCEXP)
        IF (ALLOCATED(QM))      DEALLOCATE(QM)
        IF (ALLOCATED(QU))      DEALLOCATE(QU)
        IF (ALLOCATED(CIRCT))   DEALLOCATE(CIRCT)
        NULLIFY(LCG)

	END


#ifdef NEVER
           IF (.FALSE.) THEN !!!!!!!!!!!!!!!!!!!!!!!!!!
C             DENOISE THE EXP IMAGES

c$omp         parallel do private(iexp,it)
	      DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
                 IT = IEXP - IEXPT + 1

C                MEDIAN FILTER OVER 3x3 SQUARE BOX
                 CALL MD2_NOLUN(EXPBUF(1,1,IT),TMPBUF(1,1,IT), IT!!!!
     &                          NX,NY, 3,9,'B')
                 EXPBUF(1:NX,1:NY,IT) = TMPBUF(1:NX,1:NY,IT)

              ENDDO
           ENDIF
#endif
@


1.40
log
@nullify lcg for ifort use
@
text
@d21 1
a21 1
C=* Email: spider@@wadsworth.org                                        *
@


1.39
log
@CAN DENOISE WITHOUT ROTFIRST
@
text
@d584 1
d878 1
a878 1
        !write(6,'(a,f8.2)') ' rangnew4:',rangnew 
@


1.38
log
@AP_STAT_SHC USED
@
text
@d13 1
d19 1
a19 1
C=* Copyright 1985-2015  Health Research Inc.                          *
d359 3
a361 4
           IF (ROTFIRST .AND. DENOISE) THEN
C             ROTATE/SHIFT EXP IMAGES WHEN READING THEM, NEEDS 2XFFT PAD
              !write(6,*) ' calling getdata_den'

d367 1
a367 1
     &                    FBS_WANTED,IRTFLG)
d369 1
a369 1
           ELSEIF (ROTFIRST .AND. .NOT. DENOISE) THEN
d379 2
a380 2
          ELSE
C             NO ROTATE, NO PADDING,
a387 3

C          NUMTH EXP. IMAGES READY TO BE ALIGNED

@


1.37
log
@undefined anginheader
@
text
@d12 1
d18 1
a18 1
C=* Copyright 1985-2012  Health Research Inc.                          *
d116 1
a116 1
        LOGICAL              :: ANGINHEADER,GOTEXPANG   
d479 5
a483 1
          CALL AP_STAT(NUMEXP,ANGDIFTHR,IBIGANGDIF,
d487 1
a487 1
     &                 NBORDER,NSUBPIX,LUNDOC)
@


1.36
log
@FOURIER LOWPASS DENOISE added
calls AP_GETDATA_DEN
@
text
@d206 2
@


1.35
log
@moved Aligning msg to apmaster instead
@
text
@d11 1
d116 1
d123 1
a123 1
	REAL,    ALLOCATABLE :: TMPBUF(:,:,:)
a164 1
        CALL FLUSHRESULTS()
d206 1
a206 3
        IF (ROTFIRST .OR. DENOISE) THEN
           IT = 1
           IF (DENOISE) IT = NUMTH
d208 15
a222 1
	   ALLOCATE(TMPBUF(NX,NY,IT), STAT=IRTFLG)
d224 1
a224 1
              CALL ERRT(46,'APSH_PSC; TMPBUF',NX*NY*IT)
a226 1
        ENDIF
a227 1
        IF (ROTFIRST) THEN
d229 1
a229 1
        ENDIF 
d345 1
a345 1
        !write(6,*) ' Rotfirst,angin:',ROTFIRST,ANGINHEADER
d347 1
a348 1
C       LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES -------------
d355 14
a368 3
           IF (ROTFIRST) THEN
C             WANT TO ROTATE/SHIFT EXP IMAGES WHEN READING THEM
C             NO PADDING
d375 3
a377 1
           ELSE
a387 14
           IF (DENOISE) THEN
C             DENOISE THE EXP IMAGES

c$omp         parallel do private(iexp,it)
	      DO IEXP=IEXPT,MIN(NUMEXP,IEXPT+NUMTH-1)
                 IT = IEXP - IEXPT + 1

C                MEDIAN FILTER OVER 3x3 SQUARE BOX
                 CALL MD2_NOLUN(EXPBUF(1,1,IT),TMPBUF(1,1,IT), 
     &                          NX,NY, 3,9,'B')
                 EXPBUF(1:NX,1:NY,IT) = TMPBUF(1:NX,1:NY,IT)

              ENDDO
           ENDIF
d944 17
@


1.34
log
@denoise parameter & ability
@
text
@a129 2
        CHARACTER (LEN=80)   :: MSG
 
a215 23
        MSG = ' Aligning'
        NA  = 9 
        IF (DENOISE) THEN
           MSG = MSG(1: NA) // ' denoised'
           NA = NA + 9
        ENDIF 
        IF (ROTFIRST) THEN
           IF (FBS_WANTED) THEN
              MSG = MSG(1: NA) //  ', FBS interpolated, rotated'
              NA = NA + 26
           ELSE
              MSG = MSG(1: NA) //  ', QUAD interpolated, rotated'
              NA = NA + 27
           ENDIF
        ELSE
           MSG = MSG(1: NA) //  ', unrotated'
           NA = NA + 11

        ENDIF
        MSG = MSG(1: NA) // ' exp images'
        NA = NA + 10
        WRITE(NOUT,*) MSG(1:NA)
  
d220 1
a220 1
        DLIST   = 0.0        ! ZEROS WHOLE DLIST
@


1.33
log
@intel compiler does not like: FLOAT(RAY2)
@
text
@d10 1
d51 4
a54 4
C       NRING                                                    (SENT)
C       LCIRC                                                    (SENT)
C       NUMR                                                     (SENT)
C       CIRCREF                                                  (SENT)
d64 2
a65 1
C       ROTFIRST            USE RTSQ ON EXP INPUT IMAGES         (SENT)
d67 1
a67 1
C       CTYPE                                                    (SENT)
d69 2
a70 2
C       RAY1,RAY2 
C       FBS_WANTED          WANT TO USE RTSF IF ROTFIRST         (SENT)                                                  (SENT)
d83 1
a83 1
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,
d102 1
a102 1
        LOGICAL              :: ROTFIRST,CKMIRROR
d121 1
a121 1
	REAL,    ALLOCATABLE :: TMPBUF(:,:)
d130 2
d159 1
a159 1
        LIMITRANGE  = (RANGE .GT. 0.0)
d205 7
a211 3
        ENDIF 
        IF (ROTFIRST) THEN
	   ALLOCATE(TMPBUF(NX,NY), STAT=IRTFLG)
d213 1
a213 1
              CALL ERRT(46,'APSH_PSC; TMPBUF',NX*NY)
d216 9
a224 1
           anginheader = (expangdoc .eq. '*') ! unfinished !!!!!!!!!!!
d226 2
a227 1
            WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH FBS INTERPOLATION'
d229 2
a230 1
           WRITE(NOUT,*)' ALIGNING INPUT IMAGES WITH QUAD INTERPOLATION'
d232 11
d362 1
a362 1
C       LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES -----------
d371 1
a371 1

d389 17
d438 1
a438 1
              IF (IREF .LT. 0) THEN
d446 1
a446 1
              ELSEIF (IREF .EQ. 0) THEN
d451 1
a451 1
                 IREFT  = 1
d489 1
a489 1
        IF (LUNDOC .GT. 0) THEN
@


1.32
log
@JT2 =  ISTEP-1, & DO JT= JT11,JT2  BUGS!
@
text
@d177 2
a178 2
        !IRAY1 = (FLOAT(RAY1+1) / FLOAT(359)) * NRAYS 
        !IRAY2 = (FLOAT(RAY2+1) / FLOAT(359)) * NRAYS 
d183 2
a184 2
        IRAY1 = 1 + FLOAT(RAY1) * FLOAT(NRAYS - 1) / 360
        IRAY2 = 1 + FLOAT(RAY2) * FLOAT(NRAYS - 1) / 360
@


1.31
log
@say shifts before rotation capability
moved shift then rot to ap_ends subroutine
@
text
@d679 1
a679 1
           JT2 =  ISTEP+1
d685 1
a685 1
           IT2 =  ISTEP+1
d691 1
a691 1
           DO JT= JT11,JT2                          ! OVER Y
d754 1
d825 2
@


1.30
log
@speed bug fix
@
text
@d9 1
d104 2
a105 1
        LOGICAL              :: FBS_WANTED   
d220 8
a231 1
        ILENC   = LNBLNKN(CTYPE) 
d332 1
d417 2
a418 2
              XSHNEW   = DLIST(4,IT)
              YSHNEW   = DLIST(5,IT)
d423 1
a423 1
              CALL AP_END(IEXP,IMGEXP,IMGREF,
d427 3
a429 2
     &                RANGNEW,XSHNEW,YSHNEW, MIRRORNEW,REFPAT,
     &                NPROJ, CTYPE, LUNDOC,PARLIST)
d482 2
a483 2
C                XSHSUM   SHIFT                               (OUTPUT)
C                YSHSUM   SHIFT                               (OUTPUT)
d492 1
a492 1
     &               DIREF,CCROT,RANGNEW,XSHSUM,YSHSUM,NPROJ,
d508 1
a508 1
        REAL                   :: XSHSUM,YSHSUM
d540 1
a540 4
        REAL, PARAMETER        :: QUADPI     = 3.1415926535
        REAL, PARAMETER        :: DGR_TO_RAD = (QUADPI/180)

        LOGICAL, PARAMETER     :: USE_OMP    = .FALSE.
d560 2
a561 2
           XSHSUM  = 0
	   YSHSUM  = 0
d895 2
a896 10
C       HAVE TO CHANGE ORDER OF SHIFT & ROTATION.
C       IN THIS PROGRAM IMAGE IS SHIFTED FIRST, ROTATED SECOND.
C       IN 'RT SQ' IT IS ROTATED FIRST, SHIFTED SECOND.
C       THIS CODE CORRESPONDS TO OPERATION: 'SA P'.
        SX     = -SX              ! BEST X SHIFT
        SY     = -SY              ! BEST Y SHIFT
	CO     =  COS(RANGNEW * DGR_TO_RAD)
	SO     = -SIN(RANGNEW * DGR_TO_RAD)
	XSHSUM = SX*CO - SY*SO
	YSHSUM = SX*SO + SY*CO
d898 1
@


1.29
log
@used both CROSRNG_2CQRR and CROSRNG_2CQR for overcoming low speed bug
@
text
@d1 1
a1 1
dC++*********************************************************************
d522 1
a522 1
        LOGICAL                :: MIRRORED
d548 2
d562 2
d617 2
a618 2
                 IF (Iray1 == 1 .and. iray2 == maxrin) then
                 CALL CROSRNG_2CQR(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
d622 1
d624 3
a626 3
                 ELSE                                         
                 CALL CROSRNG_2CQRR(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
     &                        NRING,MAXRIN,NUMR,iray1,iray2,
d631 1
a631 1
                 endif
d715 2
a716 2
                 IF (Iray1 == 1 .and. iray2 == maxrin) then
                 CALL CROSRNG_2CQR(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
d720 1
d723 3
a725 3
                 else
                 CALL CROSRNG_2CQRR(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
     &                             NRING,MAXRIN,NUMR,iray1,iray2,
d731 1
a731 1
                 endif
d795 2
a796 2
                IF (Iray1 == 1 .and. iray2 == maxrin) then
                 CALL CROSRNG_2CQR(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
d800 1
d804 2
a805 2
                CALL CROSRNG_2CQRR(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
     &                        NRING,MAXRIN,NUMR,iray1,iray2,
d811 1
a811 1
                 endif
d853 2
a854 2
           IF (Iray1 == 1 .and. iray2 == maxrin) then
           CALL CROSRNG_2CQR(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
d858 1
d862 1
a862 1
           CALL CROSRNG_2CQRR(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
d869 1
a869 1
           endif
@


1.28
log
@ray range calc. changed
@
text
@a559 2
     &           QU(LCIRCD2+1), 
     &           QM(LCIRCD2+1), 
d612 2
a613 1
#else
d615 7
a621 1
     &                        NRING,MAXRIN,NUMR,IRAY1,IRAY2,
d626 1
d710 1
d712 8
a719 1
     &                             NRING,MAXRIN,NUMR,IRAY1,IRAY2,
d725 1
d789 1
d791 8
a798 1
     &                        NRING,MAXRIN,NUMR,IRAY1,IRAY2,
d804 1
d846 1
d848 8
a855 1
     &                       NRING,MAXRIN,NUMR,IRAY1,IRAY2,
d861 1
@


1.27
log
@removed a debug output
@
text
@d3 1
a3 28
C   APSH_PSC.F      USED CMLIMIT                  AUG 00 ARDEAN LEITH
C                   ADDED REF_CIRC FILE           APR 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   OPFILEC                       FEB 03 ARDEAN LEITH
C                   APMASTER REWRITE              AUG 03 ARDEAN LEITH
C                   USED AP_OUT                   FEB 04 ARDEAN LEITH
C                   NORMASS USED FOR ALTIX        JUN 04 ARDEAN LEITH
C                   INTERPOLATION ON EDGE BUG     AUG 04 ARDEAN LEITH
C                   CROSRNG_E SPEEDS UP           AUG 04 ARDEAN LEITH
C                   AP_END CALL HAS PARLIST       OCT 04 ARDEAN LEITH
C                   PEAKV = 1                     JAN 05 ARDEAN LEITH
C                   RANGNEWT OPT 64 BUG FIXED     MAY 05 ARDEAN LEITH
C                   DISCARD MIRROR ...            JUN 06 ARDEAN LEITH
C                   AP_STAT CALL                  JAN 07 ARDEAN LEITH
C                   REF-RINGS FILE ADDED          MAR 08 ARDEAN LEITH
C                   CROSRNG_E REWRITE             MAR 08 ARDEAN LEITH
C                   IREFLIST VAR. NAME            MAR 08 ARDEAN LEITH
C                   APRINGS_ONE_NEW               MAR 08 ARDEAN LEITH
C                   AP_END CALL CHANGED           NOV 08 ARDEAN LEITH
C                   AP_STAT_ADD                   NOV 08 ARDEAN LEITH
C                   NPROJ BUG                     AUG 09 ARDEAN LEITH
C                   ISHRANGEX                     FEB 10 ARDEAN LEITH
C                   APRINGS_COEF                  MAY 10 ARDEAN LEITH
C                   AP_STAT NBORDER               OCT 10 ARDEAN LEITH
C                   DORINGS                       OCT 10 ARDEAN LEITH
C                   ADJACENT SEARCH               OCT 10 ARDEAN LEITH
C                   RTSQ, RENAMED                 JAN 11 ARDEAN LEITH
d8 1
a163 3
        !RAY1 = 0
        !RAY2 = 30

d175 10
a184 5
        IRAY1 = (FLOAT(RAY1+1) / FLOAT(359)) * NRAYS 
        IRAY2 = (FLOAT(RAY2+1) / FLOAT(359)) * NRAYS 
        IF (RAY1 == 0)    IRAY1 = 1  
        IF (RAY2 <= 0)    IRAY2 = NRAYS  
        IF (IRAY2  > 359) IRAY2 = NRAYS  
@


1.26
log
@C          WHAT IF X OR Y RANGE IS ZERO?
>            JT1 = -ISTEP
@
text
@d881 1
a881 1
        write(6,'(a,2i4,f8.2)') 'X,Y:',isx,isy,ccrot 
@


1.25
log
@added rtsq call msg.
@
text
@d572 1
a572 1
 	IF (NPROJ .LE. 0) THEN
d626 2
a627 2
                        USE_UN  = (LCG(IRR) .GE. 0)
                        USE_MIR = (LCG(IRR) .LT. 0)
d650 2
a651 2
      !write(6,'(a,i5,3f9.2,3i4)')' rangnew0:',
      !&                             maxl,pos_max,rangnew,ccnow,it,jt
d668 5
d682 15
a696 1
           DO JT= -ISTEP+1,ISTEP-1
d699 1
a699 1
	      DO IT= -ISTEP+1,ISTEP-1
d702 1
a702 1
   	         IF (IT.EQ.0 .AND. JT.EQ.0) CYCLE     ! ALREADY HAVE 
d738 1
a738 1
	         IF (CC(IT,JT) .GT. CCROT)  THEN
d764 1
a764 1
        IF (ABS(ISX).EQ. ISHRANGEX .OR. ABS(ISY).EQ. ISHRANGEY) THEN
d779 1
a779 1
   	         IF (IT.EQ.0 .AND. JT.EQ.0) CYCLE ! ALREADY HAVE THIS
d881 1
a881 1
        !write(6,'a,2i4,f8.2') 'X,Y:',isx,isy,ccrot 
@


1.24
log
@FBS_WANTED parameter passed in and out
@
text
@d231 5
@


1.23
log
@renamed nsam,nrow
@
text
@d34 1
d40 1
a40 1
C=* Copyright 1985-2011  Health Research Inc.                          *
d72 1
a72 1
C       NX,NY           ACTUAL (NOT-WINDOWED) IMAGE SIZE     (SENT)
d79 1
a79 1
C       CIRCREF_IN_CORE                                          (SENT)
d84 1
a84 1
C       FFTW_PLANS                                               (SENT)
d91 3
a93 1
C       LUNDOC                                                   (SENT)
d95 1
a95 1
C  NOTES:   NON-MPI CODE
d107 1
a107 1
     &               CKMIRROR,CTYPE,LUNDOC,RAY1,RAY2)
d129 1
d351 1
d357 1
a357 1
     &                    .FALSE., ADUM, ADUM, IRTFLG)
@


1.22
log
@mpibcast T on getdata
@
text
@d71 1
a71 1
C       NSAM,NROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE     (SENT)
d100 1
a100 1
     &               NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d112 1
a112 1
	INTEGER              :: NUMEXPNSAM,NROW,ISHRANGEX,ISHRANGEY
d212 1
a212 1
	ALLOCATE(EXPBUF(NSAM,NROW,NUMTH), 
d216 1
a216 1
           MWANT = NSAM*NROW*NUMTH + 6*NUMTH    
d221 1
a221 1
	   ALLOCATE(TMPBUF(NSAM,NROW), STAT=IRTFLG)
d223 1
a223 1
              CALL ERRT(46,'APSH_PSC; TMPBUF',NSAM*NROW)
d226 1
d276 1
a276 1
           CALL APRINGS_NEW_COEF(IREFLIST,NUMREF,  NSAM,NROW,
d285 1
a285 1
           CALL APRINGS_NEW(IREFLIST,NUMREF, NSAM,NROW,
a332 2
        anginheader = (rotfirst .and. expangdoc .eq. '*') ! unfinished !!!!!!!!!!!
         
d348 1
a348 1
     &                    NSAM,NROW, NSAM,NROW,0.0,
d355 1
a355 1
     &                    NSAM,NROW, NSAM,NROW,0.0,
a358 1
              IF (IRTFLG .NE. 0) GOTO 9999
d360 1
d369 1
a369 1
     &	            NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d492 1
a492 1
     &	             NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d503 1
a503 1
	REAL                   :: EXPBUF(NSAM,NROW)
d506 1
a506 1
        INTEGER                :: NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP 
d590 1
a590 1
	   CNR2 = NROW / 2 + 1 + JT
d593 1
a593 1
	      CNS2 = NSAM / 2 + 1 + IT
d599 1
a599 1
              CALL APRINGS_SATU(EXPBUF,NSAM,NROW,CNS2,CNR2, 
d668 1
a668 1
	      CNR2 = NROW / 2 + 1 + JT + ISYT         ! CENTER
d671 1
a671 1
	         CNS2 = NSAM / 2 + 1 + IT + ISXT      ! CENTER
d684 1
a684 1
                 CALL APRINGS_SATU(EXPBUF,NSAM,NROW,CNS2,CNR2, 
d746 1
a746 1
	      CNR2 = NROW / 2 + 1 + JT + ISY     ! CENTER
d748 1
a748 1
	         CNS2 = NSAM / 2 + 1 + IT + ISX  ! CENTER
d755 1
a755 1
                 CALL APRINGS_SATU(EXPBUF,NSAM,NROW,CNS2,CNR2, 
d791 2
a792 2
	   CNS2 = NSAM/2+1 + SX + SSX
	   CNR2 = NROW/2+1 + SY + SSY
d802 1
a802 1
           CALL APRINGS_SATU(EXPBUF,NSAM,NROW,CNS2,CNR2, 
@


1.21
log
@MPIBCAST for AP_GETDATA calls bug
@
text
@d162 1
a162 1
        LOGICAL, PARAMETER   :: MPIBCAST = .FALSE.
@


1.20
log
@IF (RAY1 == 0)    IRAY1 = 1
@
text
@a147 1
        DOUBLE PRECISION     :: DDUM
d162 2
d352 2
a353 2
     &                    TMPBUF,EXPBUF,
     &                    .FALSE., DDUM, DDUM, IRTFLG)
d358 2
a359 2
     &                    .FALSE.,  EXPBUF,  
     &                    .FALSE., DDUM, DDUM, IRTFLG)
@


1.19
log
@RANGNEW possible bug, ray1 ... ray2 support
@
text
@d201 1
d640 1
a640 1
      !write(6,'(a,i4,3f9.2,3i4)')' rangnew0:',
@


1.18
log
@AP_GETDATA parameters fixed
@
text
@d33 1
d103 2
a104 1
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,CKMIRROR,CTYPE,LUNDOC)
d125 1
d162 2
d183 26
d369 1
a369 1
     &	            LCIRC,NRING,NUMREF,MODE,
d492 1
a492 1
     &	             LCIRC,NRING,NUMREF,MODE,
a501 1

d505 9
d517 1
a517 4

        CHARACTER (LEN=1)      :: MODE
	REAL                   :: REFDIR(3,NUMREF), EXPDIR(3)
        INTEGER *8             :: FFTW_PLANS(*)  ! STRUCTURE POINTERS
d534 2
a535 2
	REAL                   :: CCROT,CCROT_INTERP,CCNOW
        LOGICAL                :: CKMIRROR,LIMITRANGE,MIRRORED
d540 1
a540 1
 	REAL                   :: ROTMP,ROTNOW
d547 2
d626 1
a626 1
     &                        ISMIRRORED,CCNOW,RANGNOW, IRTFLG)
d628 2
a629 2
                 CALL CROSRNG_2CQ(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
     &                        NRING,MAXRIN,NUMR,
d633 1
a633 1
     &                        ISMIRRORED,CCNOW,RANGNOW,POS_MAX, IRTFLG)
d638 3
a640 1
	            RANGNEW  = ANG_N(RANGNOW,MODE,MAXRIN)! BEST ROTATION
d653 3
a655 1
        !write(6,'a,2i4,3x,f8.2') ' 0 X,Y:',isx,isy,ccrot 
d696 1
a696 1
     &                             ISMIRROREDT,CC(IT,JT),ROTMP, IRTFLG)
d698 2
a699 2
                 CALL CROSRNG_2CQ(CIRCEXP,CIRCREF(1,IR),LCIRC/2,
     &                             NRING,MAXRIN,NUMR,
d703 2
a704 2
     &                             ISMIRROREDT,CC(IT,JT),ROTMP,
     &                             POS_MAX, IRTFLG)
d710 1
a710 1
	            RANGNEW = ANG_N(ROTMP ,MODE,MAXRIN)
d725 1
d766 1
a766 1
     &                        ISMIRRORED,CCP(IT,JT), ROTMP,IRTFLG)
d768 2
a769 2
                 CALL CROSRNG_2CQ(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
     &                        NRING,MAXRIN,NUMR,
d773 2
a774 2
     &                        ISMIRROREDT,CCP(IT,JT),ROTMP,
     &                        POS_MAX, IRTFLG)
d783 1
d794 1
d813 1
a813 1
     &                       ISMIRRORED,CCROT_INTERP,RANGNEW_INTERP, 
d816 2
a817 2
           CALL CROSRNG_2CQ(CIRCEXP,CIRCREF(1,IBE),LCIRC/2,
     &                       NRING,MAXRIN,NUMR,
d821 2
a822 2
     &                       ISMIRRORED,CCROT_INTERP,RANGNEW_INTERP,
     &                       POS_MAX, IRTFLG)
d831 1
a831 1
	      RANGNEW = ANG_N(RANGNEW_INTERP,MODE,MAXRIN) ! BEST ROT.
@


1.17
log
@, in format list bad on intel ifort
@
text
@d145 1
d315 2
a316 1
	      CALL AP_GETDAT_RTSQ(IEXPLIST,NUMEXP,NSAM,NROW,NSAM,NROW,
d318 3
a320 2
     &                    1,NROW,1,NSAM, ANGINHEADER, 
     &                    ANGEXP, TMPBUF,EXPBUF,IRTFLG)
d322 2
a323 1
	      CALL AP_GETDAT(IEXPLIST,NUMEXP,NSAM,NROW,NSAM,NROW,
d325 2
a326 1
     &                    1,NROW,1,NSAM,  EXPBUF,  IRTFLG)
@


1.16
log
@COMPLEX QU,QM ALLOCATED HERE
@
text
@d736 1
a736 1
910        format(3f14.4,/,3f14.4,/,3f14.4,)
@


1.15
log
@removed make_close_list.f
@
text
@d32 1
d468 1
a468 1
        REAL                   :: CIRCREF(LCIRC,NUMREF)
a484 1
        REAL, ALLOCATABLE      :: CIRCEXP(:),CIRCT(:)
d486 4
d506 2
a507 2
        PEAK   = 0.0    ! UNUSED?
        WR(1)  = 0.0    ! DUMMY VALUE FLAG FOR APRINGS CALL
d509 2
a510 1
        MAXRIN = NUMR(3,NRING) - 2 ! ACTUAL LENGTH OF LONGEST RING
d528 5
a532 1
	ALLOCATE(CIRCEXP(LCIRC),CIRCT(LCIRC), STAT=IRTFLG)
d534 1
a534 1
           CALL ERRT(46,'APSH_PSC; CIRCEXP...',2*LCIRC)
d576 1
a576 1
  
d578 1
d584 8
d643 1
d646 13
a658 4
     &                            NUMR,NRING,LCIRC,
     &                            FFTW_PLANS, NLOCS,NRAYSC,
     &                            TRANS,CPLX, USE_UN,USE_MIR,
     &                            ISMIRROREDT,CC(IT,JT),ROTMP, IRTFLG)
d713 1
d719 9
d758 1
d760 14
a773 5
     &                     NUMR,NRING,LCIRC,
     &                     FFTW_PLANS, NLOCS,NRAYSC,
     &                     TRANS,CPLX, .NOT. MIRRORED,MIRRORED,
     &                     ISMIRRORED,CCROT_INTERP,RANGNEW_INTERP, 
     &                     IRTFLG)
d805 2
@


1.14
log
@IRTFLG = 0 in makelist
@
text
@a761 72

C ****************** MAKE_CLOSE_LIST  *********************************
       

      SUBROUTINE MAKE_CLOSE_LIST(NUMREF,LIMITRANGE,
     &                           REFDIR,EXPDIR,
     &                           RANGECOS, CKMIRROR, 
     &                           LCGPOINTER, NPROJ, IRTFLG)

      IMPLICIT NONE

      INTEGER, INTENT(IN)  :: NUMREF 
      LOGICAL, INTENT(IN)  :: LIMITRANGE
      REAL,    INTENT(IN)  :: REFDIR(3,NUMREF), EXPDIR(3)
      REAL,    INTENT(IN)  :: RANGECOS
      LOGICAL, INTENT(IN)  :: CKMIRROR
      INTEGER, POINTER     :: LCGPOINTER(:)
      INTEGER, INTENT(OUT) :: NPROJ, IRTFLG

      REAL                 :: DT,DTABS
      INTEGER              :: IREF


      IF (.NOT. LIMITRANGE) THEN
         IF (.NOT. ASSOCIATED(LCGPOINTER)) THEN
C           DUMMY ALLOCATE TO AVOID BUS ERROR ON SOME SYSTEMS
            ALLOCATE(LCGPOINTER(1),STAT=IRTFLG)
         ENDIF
         NPROJ  = NUMREF
         lcgpointer(1) = -999
         RETURN
      ENDIF

C     RESTRICTED RANGE SEARCH ------------------------------------
      IF (.NOT. ASSOCIATED(LCGPOINTER)) THEN
         ALLOCATE(LCGPOINTER(NUMREF),STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'LCG',NUMREF)
            RETURN
         ENDIF
      ENDIF

C     MAKE LIST OF NEARBY REFERENCE IMAGES
      NPROJ = 0

      DO IREF=1,NUMREF 
C        DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED
         DT    = (EXPDIR(1) * REFDIR(1,IREF) + 
     &            EXPDIR(2) * REFDIR(2,IREF) +
     &            EXPDIR(3) * REFDIR(3,IREF))
	 DTABS = ABS(DT)

         IF (DTABS >= RANGECOS)  THEN
C           MIRRORED OR NON-MIRRORED IS WITHIN RANGE

            IF (CKMIRROR .OR. DT > 0) THEN
C              DO NOT DISCARD IF NOT MIRRORED OR WANT MIRRORED
	       NPROJ             = NPROJ + 1
	       LCGPOINTER(NPROJ) = IREF
               IF (DT .LT. 0) LCGPOINTER(NPROJ) = -IREF
            ENDIF
         ENDIF
      ENDDO
      IRTFLG = 0
      !print *,'makelist, ref:',refdir(:,1)
      !print *,'makelist, exp:',expdir


      END



@


1.13
log
@apsh in names, MAKE_CLOSE_LIST, '*' in refangdoc
@
text
@d825 1
@


1.12
log
@DEALLOCATE(TMPBUF), anginheader = (rotfirst unfinished
@
text
@d3 1
a3 1
C   AP_SH_PSC.F     USED CMLIMIT                  AUG 00 ARDEAN LEITH
d31 1
d56 1
a56 1
C  AP_SH_PSC 
d97 1
a97 1
        SUBROUTINE AP_SH_PSC(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d128 1
a128 1
        LOGICAL              :: ANGINHEADER   
d182 1
a182 1
           CALL ERRT(46,'AP_SH_PSC; EXPBUF & DLIST...',MWANT)
d188 1
a188 1
              CALL ERRT(46,'AP_SH_PSC; TMPBUF',NSAM*NROW)
a257 2
C       ALWAYS USES REFANGLES FILE
        GOTREFANG = .TRUE.
d265 5
a269 3
C       READ REF. ANGLES INTO ANGREF
        CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                  LUNT,INANG,3,ANGREF,NGOTREF,IRTFLG)
a271 3
C       CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)

a273 2
C          READ EXP. ANGLES INTO ANGEXP

d281 5
a285 2
	   CALL AP_GETANGA(IEXPLIST,NUMEXP,0,EXPANGDOC,EXPPAT,
     &                       LUNT,INANG,8,ANGEXP,NGOTPAR,IRTFLG)
a287 2
C          CONVERT EXP. ANGLES TO UNITARY DIRECTIONAL VECTORS(EXPDIR).
	   CALL AP_GETSATA(ANGEXP,EXPDIR,8,NUMEXP,IRTFLG)
a296 1

d299 3
a301 1

a436 42
C+**********************************************************************

       SUBROUTINE AP_END_HEAD(IMNUM,FILPAT,LUNIN,PARLIST,NVALS,IRTFLG)

C      PURPOSE:  PUT ANGLES, ETC AS HEADER VALUES IN IMAGE

       IMPLICIT NONE
       INCLUDE 'CMBLOCK.INC'
       INCLUDE 'CMLIMIT.INC'

       INTEGER               :: IMNUM
       CHARACTER(LEN=*)      :: FILPAT
       INTEGER               :: LUNIN
       REAL                  :: PARLIST(NVALS)
       INTEGER               :: NVALS
       INTEGER               :: IRTFLG

       CHARACTER(LEN=MAXNAM) :: FILNAM
       INTEGER               :: MAXIM,ITYPE,LSAM,LROW,LSLICE,NLET
       LOGICAL               :: FOUROK = .FALSE.

C      OPEN EXISTING IMAGE FILE FOR OUTPUT
       IF (IMNUM >= 0) THEN
C         CREATE IMAGE FILE NAME FIRST
          NLET = 0
          CALL FILGET(FILPAT,FILNAM,NLET,IMNUM,IRTFLG)
          IF (IRTFLG .NE. 0)  RETURN
       ELSE
          FILNAM = FILPAT
       ENDIF
 
       MAXIM = 0
       CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',ITYPE,
     &              LSAM,LROW,LSLICE,MAXIM,' ',FOUROK,IRTFLG)
       IF (IRTFLG .NE. 0)  RETURN

C      PUT ANGLES, ETC IN HEADER
       CALL LUNSETVALS(LUNIN,IAPLOC+1,NVALS,PARLIST,IRTFLG)

       CLOSE(LUNIN)

       END
d755 1
a755 1
9999    IF (ASSOCIATED(LCG)) DEALLOCATE(LCG)
d758 1
d763 1
a763 1
C ****************** LISTCLOSE ***************************************
d786 4
a789 2
C        DUMMY ALLOCATE TO AVOID BUS ERROR ON SOME SYSTEMS
         ALLOCATE(LCGPOINTER(1),STAT=IRTFLG)
d796 6
a801 4
      ALLOCATE(LCGPOINTER(NUMREF),STAT=IRTFLG)
      IF (IRTFLG .NE. 0) THEN
         CALL ERRT(46,'LCG',NUMREF)
         RETURN
d814 1
a814 1
         IF (DTABS .GE. RANGECOS)  THEN
d817 1
a817 1
            IF (CKMIRROR .OR. DT .GT. 0) THEN
d825 3
a829 3



@


1.11
log
@RTSQ, RENAMED
@
text
@d181 1
a181 1
           CALL ERRT(46,'APSH_PSC; EXPBUF & DLIST...',MWANT)
d184 8
a299 7
        IF (ROTFIRST) THEN
	   ALLOCATE(TMPBUF(NSAM,NROW), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL ERRT(46,'APSH_PSC; TMPBUF',NSAM*NROW)
              GOTO 9999
           ENDIF
        ENDIF 
d301 4
a304 2
        ANGINHEADER = (ROTFIRST .AND. EXPANGDOC .EQ. '*') ! UNFINISHED !!!!!!!!!!!
        !write(6,*) ' rotfirest,angin:',ROTFIRST,ANGINHEADER
a323 1
#
d433 2
@


1.10
log
@renamed from mrqli_psc.f
@
text
@d1 1
a1 1
C++*********************************************************************
d3 1
a3 1
C    AP_SH_PSC.F    USED CMLIMIT                  AUG 00 ARDEAN LEITH
d30 1
d36 1
a36 1
C=* Copyright 1985-2010  Health Research Inc.                          *
d59 1
a59 1
C           USED IF:  CIRCREF_IN_CORE .AND. NUMEXP .GE. NUMTH 
d64 24
a87 9
C       IREFLIST            LIST OF REF. IMAGE FILE NUMBERS   (INPUT)
C       NUMREF              NO. OF IMAGES                     (INPUT)
C       IEXPLIST            LIST OF EXP. IMAGE FILE NUMBERS   (INPUT)
C       NUMEXP              NO. OF IMAGES                     (INPUT)
C       NSAM,NROW           ACTUAL (NOT-WINDOWED) IMAGE SIZE  (INPUT)
C       REFANGDOC           REF. ANGLES FILE NAME             (INPUT)
C       EXPANGDOC           EXP. ANGLES FILE NAME             (INPUT)
C       REFPAT              REF. IMAGE SERIES FILE TEMPLATE   (INPUT)
C       EXPPAT              EXP. IMAGE SERIES FILE TEMPLATE   (INPUT)
d100 1
a100 1
     &               REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,LUNDOC)
d106 1
d108 2
d113 2
a114 4
        LOGICAL              :: CKMIRROR
	LOGICAL              :: MIRRORNEW
	LOGICAL              :: GOTREFANG,LIMITRANGE
        LOGICAL              :: WEIGHT
a115 4

        CHARACTER (LEN=1)    :: MODE
        CHARACTER (LEN=*)    :: REFANGDOC,EXPANGDOC
        CHARACTER (LEN=*)    :: SCRFILE
d117 2
d120 1
d122 2
a123 1
        INTEGER              :: LUNDOC
d127 1
d134 1
d137 2
a138 2
	REAL,    ALLOCATABLE :: REFDIR(:,:),EXPDIR(:,:) 
	REAL,    ALLOCATABLE :: ANGREF(:,:),ANGEXP(:,:)
d181 1
a181 1
           CALL  ERRT(46,'EXPBUF & DLIST...',MWANT)
d205 1
a205 1
              CALL ERRT(46,'NLOCS',MWANT)
d218 1
a218 1
              CALL ERRT(46,'COEFFS...',MWANT)
d254 1
a254 1
           CALL ERRT(46,'REFDIR, ANGREF',6*NUMREF)
d270 2
a271 1
	   ALLOCATE(ANGEXP(8,NUMEXP), EXPDIR(3,NUMEXP), STAT=IRTFLG)
d273 1
a273 1
              CALL ERRT(46,'ANGEXP....',11*NUMEXP)
d287 1
a287 1
              CALL ERRT(46,'ANGEXP....',11)
d292 11
d309 9
a317 1
	   CALL AP_GETDAT(IEXPLIST,NUMEXP,NSAM,NROW,NSAM,NROW,
d319 4
a322 2
     &                    1,NROW,1,NSAM, EXPBUF,  IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
d396 3
d404 1
a432 1
  
d435 42
d524 1
a524 1
        REAL                   :: CIRCEXP(LCIRC),CIRCT(LCIRC)
d562 7
a568 1
	   
d796 2
@


1.9
log
@no-coef supported
@
text
@d3 1
a3 1
C    MRQLI_PSC.F    USED CMLIMIT                  AUG 00 ARDEAN LEITH
d54 1
a54 1
C  MRQLI_PSC 
d80 1
a80 1
        SUBROUTINE MRQLI_PSC(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
@


1.8
log
@speedup & rewrite
@
text
@d109 1
a133 2
        LOGICAL, PARAMETER   :: USECOEF  = .TRUE. ! FOR TESTING

d169 8
a176 6
        WEIGHT = .TRUE.    ! REF. IMAGES HAVE WEIGHTED FFT'S
        TRANS  = .FALSE.   ! DO NOT USE REFORMED RINGS/RAYS
        CPLX   = .TRUE.    ! USE COMPLEX CROSRNG VARIABLES
        ILENC  = LNBLNKN(CTYPE) 
        IF (ILENC > 3) TRANS = (CTYPE(4:4) .EQ. 'T')
        IF (ILENC > 4) CPLX  = (CTYPE(5:5) .EQ. 'C')
d297 1
a297 1
     &              COEFFS,IXY,NLOCS,NRAYSC,TRANS,CPLX,
d413 1
a413 1
     &               COEFFS,IXY,NLOCS,NRAYSC, TRANS,CPLX,
d432 1
a454 1
        LOGICAL, PARAMETER     :: USECOEF    = .TRUE. ! FOR TESTING
d678 1
a678 1
              write(6,961) ssx,ssy, ccrot_interp,ccrot 
@


1.7
log
@used dorings.f, cosmetic rewrite, searches borders more
@
text
@d29 1
d82 1
a82 1
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
d114 1
a114 1
	REAL, ALLOCATABLE    :: ABUF(:,:,:)
d116 3
a118 3
	REAL, ALLOCATABLE    :: DLIST(:,:) 
	REAL, ALLOCATABLE    :: REFDIR(:,:),EXPDIR(:,:) 
	REAL, ALLOCATABLE    :: ANGREF(:,:),ANGEXP(:,:)
d126 2
a127 2
        REAL, PARAMETER      :: QUADPI = 3.1415926535897932384626
        REAL, PARAMETER      :: DGR_TO_RAD = (QUADPI/180)
d133 1
a133 1
        LOGICAL, PARAMETER   :: NOCOEF  = .FALSE. ! FOR TESTING
d144 1
a144 1
        CALL  AP_STAT_ADD(-1,CCROT,ANGDIF,ANGDIFTHR,CCROTLAS,
d158 1
a158 1
	ALLOCATE(ABUF(NSAM,NROW,NUMTH), 
d160 1
a160 5
     &           NPROJA(NUMTH), 
     &           COEFFS(6,LCIRC),
     &           IXY(2,LCIRC),      
     &           NLOCS(2,NRAYSC+1),
     &           STAT=IRTFLG)
d162 2
a163 3
           MWANT = NSAM*NROW*NUMTH + 6*NUMTH +6*LCIRCR +
     &             2*LCIRCR + 2*NRAYSC+2  
           CALL  ERRT(46,'A & DLIST...',MWANT)
a166 7
        IXY     = -100       ! FOR HANDLING CIRC PADS
        COEFFS  = 0.0

C       SET # OF POINTS ON EACH RAY AND RAY STARTING INDEX IN CIRC
        CALL APRINGS_TRANS_LOCS(NUMR,NRING, NLOCS,NRAYSC)

        WEIGHT = .TRUE.     ! REF. IMAGES HAVE WEIGHTED FFT'S
d170 1
d173 3
a175 2
        IF (LEN(CTYPE) > 3) TRANS = (CTYPE(4:4) .EQ. 'T')
        IF (LEN(CTYPE) > 4) CPLX  = (CTYPE(5:5) .EQ. 'C')
d177 13
a189 8
        IF (NOCOEF) THEN
C          ONLY OCCURS DURING TESTING
C          READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
                write(6,*) ' ERROR 0 !!!!!!!!'
           CALL APRINGS_NEW(IREFLIST,NUMREF, NSAM,NROW,
     &               NRING,LCIRC,NUMR, MODE,FFTW_PLANS,
     &               REFPAT,LUNT,CIRCREF,CIRCREF_IN_CORE,
     &               LUNRING,SCRFILE,IRTFLG)
d191 13
d217 7
a223 1

d234 2
a235 2
            CALL ERRT(46,'REFDIR, ANGREF',6*NUMREF)
            GOTO 9999
d275 1
a275 1
C          LOAD EXP. IMAGE DATA FOR THIS SET OF IMAGES
d279 1
a279 1
     &                    1,NROW,1,NSAM, ABUF,  IRTFLG)
d282 1
a282 1
C          NUMTH INPUT IMAGES READY TO BE ALIGNED
d288 1
a288 1
	      CALL APRQ2DC(ABUF(1,1,IT),CIRCREF,NUMR,
d339 6
a344 6
              CCROT     = DLIST(2,IT)
              RANGNEW   = DLIST(3,IT)
              XSHNEW    = DLIST(4,IT)
              YSHNEW    = DLIST(5,IT)
              NPROJ     = NPROJA(IT)
              PEAKV     = 1.0
d346 1
d354 1
d376 1
a376 1
	IF (ALLOCATED(ABUF))       DEALLOCATE(ABUF)
d385 3
a388 1
	END
d416 2
d434 2
a435 2
	DOUBLE PRECISION       :: CC(-ISTEP:ISTEP,-ISTEP:ISTEP)
	DOUBLE PRECISION       :: CCP(-1:1,-1:1)
d438 1
a438 1
        INTEGER, ALLOCATABLE   :: LCG(:)
d440 2
a441 3
        CHARACTER (LEN=9)      :: SETRINGS
	DOUBLE PRECISION       :: CCROTD,PEAK,CCROTD_INTERP
	DOUBLE PRECISION       :: CCOA,CCBEST
d444 1
d447 1
a447 1
 	REAL                   :: ROTMP
d453 1
a453 1
        LOGICAL, PARAMETER     :: NOCOEF     = .FALSE. ! FOR TESTING
d460 17
a476 50
        IEND  = NUMREF
        IF (.NOT. LIMITRANGE) THEN
C          DUMMY ALLOCATE TO AVOID BUS ERROR ON SOME SYSTEMS
	   ALLOCATE(LCG(1),STAT=IRTFLG)
           NPROJ = NUMREF
        ELSE
C          RESTRICTED RANGE SEARCH
	   ALLOCATE(LCG(NUMREF),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
              CALL  ERRT(46,'LCG',NUMREF)
              RETURN
           ENDIF

C          MAKE LIST OF NEARBY REFERENCE IMAGES
	   NPROJ = 0

	   DO IREF=1,NUMREF 
C             DT NEAR 1.0 = NOT-MIRRORED, DT NEAR -1.0 = MIRRORED
	      DT    = (EXPDIR(1) * REFDIR(1,IREF) + 
     &                 EXPDIR(2) * REFDIR(2,IREF) +
     &                 EXPDIR(3) * REFDIR(3,IREF))
	      DTABS = ABS(DT)

              IF (DTABS .GE. RANGECOS)  THEN
C                MIRRORED OR NON-MIRRORED IS WITHIN RANGE

                 IF (CKMIRROR .OR. DT .GT. 0) THEN
C                   DO NOT DISCARD IF NOT MIRRORED OR WANT MIRRORED
	            NPROJ      = NPROJ + 1
	            LCG(NPROJ) = IREF
                    IF (DT .LT. 0) LCG(NPROJ) = -IREF

c                   if (mod(iref,50) .le. 0) then
c                   write(110,*)'in  iref: ',iref,' dt: ',dt,lcg(nproj)
c                   endif
                 ENDIF
              ENDIF
	   ENDDO

	   IF (NPROJ .LE. 0) THEN
C             THERE IS NO REFERENCE WITHIN SEARCH RANGE
              XSHSUM  = 0
	      YSHSUM  = 0
              DIREF   = 0     ! FEEDS INTO DLIST
              RANGNEW = 0
              CCROT   = -1.0 
              RETURN	
           ENDIF
           IEND = NPROJ
        ENDIF     ! END OF RESTRICTED RANGE SEARCH
a477 4
	CCROTD   = -HUGE(CCROTD)
        SETRINGS = 'NONE'           ! NO RINGS CREATION 

        
d489 13
a501 16
C             NORMALIZE IMAGE VALUES UNDER THE MASK OVER VARIANCE RANGE
C             INTERPOLATE TO POLAR COORD., CREATE FOURIER OF RINGS.
C             NO WEIGHTING OF RINGS        

              IF (NOCOEF) THEN
	         CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, 
     &                             EXPBUF,.FALSE.,
     &                             MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                             CIRCEXP,IRTFLG)
              ELSE
                 CALL APRINGS_ONE_COEF(EXPBUF, NSAM,NROW, CNS2,CNR2, 
     &                             NUMR,NRING, NLOCS,NRAYSC,
     &                             COEFFS,IXY,
     &                             .FALSE., WR, FFTW_PLANS, TRANS,
     &                             CIRCT,LCIRC, CIRCEXP, IRTFLG)
              ENDIF
d503 1
a503 2
C             COMPARE EXP. IMAGE WITH ALL REFERENCE IMAGES ------------
	      DO IRR=1,IEND
d514 16
a529 16

                 CALL DORINGS(NSAM,NROW,CNS2,CNR2,EXPBUF,
     &                     MODE,NUMR,NRING,LCIRC,
     &                     WR,FFTW_PLANS(1),CIRCEXP,NLOCS,NRAYSC,
     &                     COEFFS,IXY, SETRINGS,TRANS,CPLX,
     &                     CIRCT,CIRCREF(1,IR),USE_UN,USE_MIR,
     &                     ISMIRRORED,CCOA, RANGO,IRTFLG)

                 IF (CCOA .GE. CCROTD)  THEN
C                   GOOD MATCH WITH NEW (MIRRORED OR NOT) POSITION 
	            CCROTD  = CCOA
	            IBE     = IR
	            ISX     = IT
	            ISY     = JT
	            RANGNEW = ANG_N(RANGO,MODE,MAXRIN)
	            IDIS    = IR
d532 2
a533 1
	      ENDDO ! END OF:  DO IRR=1,IEND --------------------- REFS.
d537 60
a596 4
        SX       = ISX              ! BEST SHIFTS
        SY       = ISY
        CCROT    = CCROTD           ! BEST ROTATION
        !write(6,'a,2i4,f8.2') 'X,Y:',isx,isy,ccrot 
d598 2
d603 8
a610 2
C       BEFORE 10/13/10 BORDER PIXELS WERE NOT SEARCHED!
        !IF (ABS(ISX).EQ.ISHRANGEX .OR. ABS(ISY).EQ.ISHRANGEY) GOTO 999
d612 2
a613 2
C       CHECK LOCATIONS WITHIN ISTEP AROUND MAX UP TO SHIFT RANGE 
C       NOTE: NO OTHER WAY TO RECOVER SUBPIXEL ARRAY EVEN IF ISTEP=1!!
d615 22
a636 56
	CC(0,0)  = CCROTD
	CCBEST   = CCROTD
	JTMA     = 0
	ITMA     = 0
        RANGBEST = RANGNEW

        SETRINGS = 'ONE_COEF'            ! COEF RINGS CREATION 
        IF (NOCOEF) SETRINGS = 'ONE_NEW' ! NON-COEF RINGS CREATION

        DO JT= -ISTEP,ISTEP
	   CNR2 = NROW / 2 + 1 + JT + ISY

	   DO IT= -ISTEP,ISTEP
	      CNS2 = NSAM / 2 + 1 + IT + ISX

   	      IF (IT.EQ.0 .AND. JT.EQ.0) CYCLE ! ALREADY HAVE THIS

              IF (((ISX + IT) < -ISHRANGEX) .OR.
     &            ((ISX + IT) >  ISHRANGEX) .OR.
     &            ((ISY + JT) < -ISHRANGEY) .OR.
     &            ((ISX + JT) >  ISHRANGEY)) THEN
C                 OVER BOUNDARY OF SHIFT RANGE 
                 CYCLE ! 
              ENDIF 

C             NORMALIZE IMAGE VALUES UNDER MASK OVER VARIANCE RANGE
C             INTERPOLATE INTO POLAR COORD, CREATE FFT OF: CIRCEXP
              CALL DORINGS(NSAM,NROW,CNS2,CNR2,EXPBUF, 
     &                     MODE,NUMR,NRING, LCIRC,
     &                     WR,FFTW_PLANS,CIRCEXP,NLOCS,NRAYSC,
     &                     COEFFS,IXY, SETRINGS,TRANS,CPLX, 
     &                     CIRCT,CIRCREF(1,IBE),
     &                    .NOT. MIRRORED,MIRRORED,
     &                     ISMIRRORED,CC(IT,JT),ROTMP,IRTFLG)

	      IF (CC(IT,JT) .GT. CCBEST)  THEN
C                CC VALUE HIGHER THAN CURRENT BEST
	         CCBEST   = CC(IT,JT)
	         RANGBEST = ANG_N(ROTMP ,MODE,MAXRIN)
	         ITMA     = IT
	         JTMA     = JT
	      ENDIF
	   ENDDO     ! END OF:  DO IT=-ISTEP,ISTEP
        ENDDO        ! END OF:  DO JT=-ISTEP,ISTEP

C       TEMP VARIABLE OVERCOMES COMPILER BUG ON OPT 64 PGI 6.0
        RANGNEW = RANGBEST

        IF (CCBEST > CCROTD) NBORDER = NBORDER + 1
        CCROTD = CCBEST

C       UPDATE INTEGRAL LOCATION OF PEAK
        ISX    = ISX + ITMA
        ISY    = ISY + JTMA
        SX     = ISX
        SY     = ISY
d638 2
a639 3
        IF (ABS(ITMA).NE. ISTEP .AND. ABS(JTMA).NE. ISTEP) THEN
C          NOT ON EDGE OF: ISTEPxISTEP INTERPOLATION AREA
C          SUB-PIXEL INTERPOLATION -----------------------------------
a640 3
C          NOTE: IN MAY 2010 TEST OF 25 EXP IMAGES WITH 17X17 SHIFTS
C                ONLY 2 CASES THE SUBPIXEL TEST GAVE AN IMPROVEMENT!
C                I WONDER IF IT IS WORTH THE EFFORT??
d642 1
a642 6
C          COPY CC VALUES AROUND THE PEAK CC VALUE
           DO JT= -1,1
              DO IT= -1,1
                 CCP(IT,JT) = CC(ITMA+IT,JTMA+JT)
              ENDDO
           ENDDO
d644 1
a644 1
           !write(6,*) 'cc' write(6,910)cc write(6,*)' ccp'write(6,910) ccp
d648 2
a649 2
           CALL PARABLD(CCP,SSX,SSY,PEAK)  ! RETURNS: SSX,SSY,PEAK 
  
d653 1
a653 14
C          NORMALIZE IMAGE VALUES UNDER MASK OVER VARIANCE RANGE
C          INTERPOLATE INTO POLAR COORD., CREATE FFT OF: CIRCEXP
C          CAN NOT USE: APRINGS_ONE_COEF AS NOT INTEGRAL SHIFT

           SETRINGS = 'ONE_NEW'              ! NON_TRANS RINGS CREATION 
           IF (TRANS) SETRINGS = 'TRANS_NEW' ! TRANS RINGS CREATION

           CALL DORINGS(NSAM,NROW,CNS2,CNR2, EXPBUF,
     &                  MODE,NUMR,NRING,LCIRC,
     &                  WR,FFTW_PLANS, CIRCEXP,NLOCS,NRAYSC,
     &                  COEFFS,IXY, SETRINGS,TRANS,CPLX,
     &                  CIRCT,CIRCREF(1,IBE),
     &                  .NOT. MIRRORED,MIRRORED,
     &                  ISMIRRORED,CCROTD_INTERP,RANGNEW_INTERP,IRTFLG)
d655 20
a674 1
           IF (CCROTD_INTERP > CCROTD) THEN
d677 2
d680 8
a687 2
              write(6,961) ssx,ssy, ccrotd_interp,ccrotd 
961           format(' Subpixel:',2f12.5,' ',f10.5,' >> ',f10.5)
a688 12
              NSUBPIX = NSUBPIX + 1
              CCROTD  = CCROTD_INTERP
	      RANGNEW = ANG_N(RANGNEW_INTERP,MODE,MAXRIN)
	      SX      = SX + SSX 
              SY      = SY + SSY 
           ENDIF  ! END OF: (CCROTD_INTERP > CCROTD)
        ENDIF     ! END OF: (IABS(ITMA).NE. ISTEP .......

999     CCROT = CCROTD
	SX    = -SX
	SY    = -SY
 
d693 2
d700 3
a702 1
9999    IF (ALLOCATED(LCG)) DEALLOCATE(LCG)
d707 62
a771 45
#ifdef NEVER
        write(6,921) idis,isx,isy,ccrotd,rangnew
921     format(' 1 ',i5,' (',i3,',',i3,'): ',f12.4,' ',2f8.2,f6.1)
#endif

#ifdef NEVER
                 if(it .eq. -10 .and. jt .eq. -1 .and. ir .eq. 47)then
                    rt1 = ang_n(tot,mode,maxrin)
                    write(6,821) it,jt, tota,rt1
821                 format(' tota(',i3,',',i3,'): ',f14.4,' ',2f8.2)
                    rt1 = ang_n(tmt,mode,maxrin)
                    write(6,826) it,jt, tmta,rt1
826                 format(' tmta(',i3,',',i3,'): ',f14.4,' ',2f8.2)
                 endif
#endif
 
#ifdef NEVER
          cc(it,jt) = cc(it,jt) 
          write(6,961) it,jt, cc(it,jt),cns2,cnr2, rotmp(it,jt)
961       format(' cc(',i2,',',i2,') : ',f12.4,' ',2f8.2,f6.1)
#endif

#ifdef NEVER
	      rt1 = ang_n(rangnew_interp,mode,maxrin)
              write(6,904) idis,isx,isy, ccrotd_interp,rt1,
     &                     cns2,cnr2, sx+ssx,sy+ssy
904           format(' 3 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)
#endif

#ifdef NEVER
	   cnr2 = nrow / 2 + 1 + isy
           cns2 = nsam / 2 + 1 + isx
           write(6,905) idis,isx,isy, ccrotd,rangnew, cns2,cnr2,sx,sy
905        format(' 2 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)
#endif
#ifdef NEVER
        cns2 = nsam / 2 + 1 - sx
        cnr2 = nrow / 2 + 1 - sy
        write(6,906) idis,isx,isy, ccrotd,rangnew,
     &               cns2,cnr2, xshsum,yshsum
906     format(' 4 ',i5,' (',i3,',',i3,'): ',f12.4,' ',5f8.2)

        write(6,*) ' ------------------------------------- '
        write(6,*) '  '
#endif
@


1.6
log
@NBORDER,NSUBPIX for ap_stat
@
text
@d28 1
d56 1
a56 1
C           REFERENCE IMAGES WITH SAMPLE IMAGES
d58 4
a61 4
C           USES COEFFICIENTS AND TRANSPOSED RINGS TO SPEED UP
C           CALCULATIONS.

C PARAMETERS:
d72 2
d77 1
a77 1
cpgi$g opt=O3
d79 1
a79 1
      SUBROUTINE MRQLI_PSC(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
d99 1
a99 1
        CHARACTER(LEN=1)     :: MODE
d128 1
a128 1
        INTEGER, PARAMETER   :: LUNT   = 77
d131 3
a133 1
 
a136 13

#ifndef SP_LIBFFTW3
        CALL ERRT(101,'USE "AP SH" INSTEAD',MWANT)
       
        END
#endif

#ifdef USE_MPI
        CALL ERRT(101,'THIS SUB-OPERATION NOT ON MPI, USE AP SH',MWANT)
        
        END
#else
C       ---------------  NON-MPI CODE --------------------------------
d179 4
a182 2
        TRANS  = .FALSE.    ! USE REFORMED RINGS/RAYS
        CPLX   = .FALSE.    ! USE COMPLEX CROSRNG
d186 5
a190 4
#ifdef NOCOEF
        write(6,*) ' aprings  no-coef, Threads:',numth
C       READ REFERENCE IMAGES INTO REFERENCE RINGS (CIRCREF) ARRAY 
        CALL APRINGS_NEW(IREFLIST,NUMREF, NSAM,NROW,
d194 9
a202 9
#else
c                  write(6,*) ' aprings  coef Threads:',numth
c       if (trans) write(6,*) ' aprings  transformed rings' 
c       if (cplx)  write(6,*) ' aprings  complx crosrngs'

C       READ REFERENCE IMAGES INTO REFERENCE RINGS ARRAY (CIRCREF) OR
C       CREATE REFERENCE RINGS FILE FOR LATER READING
C       SAVES COEFFS FOR LATER USE 
        CALL APRINGS_NEW_COEF(IREFLIST,NUMREF,  NSAM,NROW,
d209 2
a210 1
#endif
d281 2
a282 1
     &              COEFFS,IXY,NLOCS,NRAYSC,TRANS,CPLX)
a370 4
C ------------------------- END OF NON-MPI CODE ---------------------
#endif


d393 2
a394 1
     &               COEFFS,IXY,NLOCS,NRAYSC, TRANS,CPLX)
d402 1
a402 1
        INTEGER                :: IXY(2,CIRC)
d410 1
d419 1
d428 1
a428 1
        REAL, PARAMETER        :: QUADPI = 3.1415926535
d431 2
a432 1
        LOGICAL, PARAMETER     :: USE_OMP = .FALSE.
d490 7
a496 1
	CCROTD = -HUGE(CCROTD)
d509 3
a511 2
#ifdef NOCOEF
	      CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, EXPBUF,.FALSE.,
d514 7
a520 7
#else
              CALL APRINGS_ONE_COEF(EXPBUF, NSAM,NROW, CNS2,CNR2, 
     &                              NUMR,NRING, NLOCS,NRAYSC,
     &                              COEFFS,IXY,
     &                              .FALSE., WR, FFTW_PLANS, TRANS,
     &                              CIRCT,LCIRC, CIRCEXP, IRTFLG)
#endif
d525 8
a532 10
                 IF (LIMITRANGE) IR = ABS(LCG(IRR))
                
                 IF (CKMIRROR .AND. LIMITRANGE) THEN
C                   ONLY SEARCH EITHER MIRRORED OR NON-MIRRORED
                    USE_UN  = (LCG(IRR) .GE. 0)
                    USE_MIR = (LCG(IRR) .LT. 0)
                 ELSE
C                   SEARCH BOTH MIRRORED & NON-MIRRORED IF CHKMIR
                    USE_UN  = .TRUE.
                    USE_MIR = CKMIRROR
d535 6
a540 30
                 IF (TRANS) THEN
                    IF (CPLX) THEN
	               CALL CROSRNG_TRANS(CIRCREF(1,IR),CIRCEXP,LCIRC/2,
     &                           NLOCS,NRAYSC,
     &                           USE_OMP,FFTW_PLANS(1),
     &                           USE_UN,USE_MIR,
     &                           ISMIRRORED,CCOA,RANGO)
                    ELSE
	               CALL CROSRNG_TRANS_NOC(CIRCREF(1,IR),CIRCEXP,
     &                           LCIRC/2,
     &                           NLOCS,NRAYSC,
     &                           USE_OMP,FFTW_PLANS(1),
     &                           USE_UN,USE_MIR,
     &                           ISMIRRORED,CCOA,RANGO)
                    ENDIF
                 ELSE
                    IF (CPLX) THEN
	               CALL CROSRNG_2C(CIRCREF(1,IR),CIRCEXP,LCIRC/2,
     &                          NRING, MAXRIN,NUMR, 
     &                          USE_OMP,FFTW_PLANS(1),
     &                          USE_UN,USE_MIR,
     &                          ISMIRRORED,CCOA,RANGO)
                    ELSE
	               CALL CROSRNG_2(CIRCREF(1,IR),CIRCEXP,LCIRC,
     &                          NRING, MAXRIN,NUMR, 
     &                          USE_OMP,FFTW_PLANS(1),
     &                          USE_UN,USE_MIR,
     &                          ISMIRRORED,CCOA,RANGO)
                    ENDIF
                 ENDIF
d559 1
d564 75
a638 101
        IF (ABS(ISX).NE.ISHRANGEX .AND. ABS(ISY).NE.ISHRANGEY) THEN
C          CHECK LOCATIONS WITHIN ISTEP AROUND MAX  
C          DO NOT CHECK WHEN ON THE EDGE OF SHIFT RANGE
C          NOTE: NO WAY TO RECOVER THE SUBPIXEL ARRAY EVEN IF ISTEP=1!!

	   CC(0,0)    = CCROTD
	   CCBEST     = CCROTD
	   JTMA       = 0
	   ITMA       = 0
           RANGBEST   = RANGNEW

           DO JT= -ISTEP,ISTEP
	      CNR2 = NROW / 2 + 1 + JT + ISY

	      DO IT= -ISTEP,ISTEP
	         CNS2 = NSAM / 2 + 1 + IT + ISX

   	         IF (IT.NE.0 .OR. JT.NE.0) THEN
C                   NORMALIZE IMAGE VALUES UNDER MASK OVER VARIANCE RANGE
C                   INTERPOLATE INTO POLAR COORD, CREATE FFT OF: CIRCEXP
 
#ifdef NOCOEF
	            CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, 
     &                           EXPBUF,.FALSE.,
     &                           MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                           CIRCEXP,IRTFLG)
#else
                    CALL APRINGS_ONE_COEF(EXPBUF, NSAM,NROW, CNS2,CNR2, 
     &                           NUMR,NRING, NLOCS,NRAYSC,
     &                           COEFFS,IXY,
     &                           .FALSE., WR, FFTW_PLANS, TRANS,
     &                           CIRCT,LCIRC, CIRCEXP, IRTFLG)
#endif

                    IF (TRANS) THEN
                       IF (CPLX) THEN
	                  CALL CROSRNG_TRANS(CIRCREF(1,IBE),CIRCEXP,
     &                           LCIRC/2,
     &                           NLOCS,NRAYSC,
     &                           USE_OMP,FFTW_PLANS(1),
     &                           .NOT. MIRRORED,MIRRORED,
     &                           ISMIRRORED,CC(IT,JT),ROTMP)
                       ELSE
	                  CALL CROSRNG_TRANS_NOC(CIRCREF(1,IBE),CIRCEXP,
     &                           LCIRC/2,
     &                           NLOCS,NRAYSC,
     &                           USE_OMP,FFTW_PLANS(1),
     &                           .NOT. MIRRORED,MIRRORED,
     &                           ISMIRRORED,CC(IT,JT),ROTMP)
                       ENDIF
                    ELSE
                       IF (CPLX) THEN
	                 CALL CROSRNG_2C(CIRCREF(1,IBE),CIRCEXP,LCIRC/2,
     &                           NRING, MAXRIN,NUMR, 
     &                           USE_OMP,FFTW_PLANS(1),
     &                           .NOT. MIRRORED,MIRRORED,
     &                           ISMIRRORED,CC(IT,JT),ROTMP)
                       ELSE
	                  CALL CROSRNG_2(CIRCREF(1,IBE),CIRCEXP,LCIRC,
     &                           NRING, MAXRIN,NUMR, 
     &                           USE_OMP,FFTW_PLANS(1),
     &                           .NOT. MIRRORED,MIRRORED,
     &                           ISMIRRORED,CC(IT,JT),ROTMP)
                      ENDIF
                    ENDIF

	            IF (CC(IT,JT) .GT. CCBEST)  THEN
C                      CC VALUE HIGHER THAN CURRENT BEST
	               CCBEST   = CC(IT,JT)
	               RANGBEST = ANG_N(ROTMP ,MODE,MAXRIN)
	               ITMA     = IT
	               JTMA     = JT
	            ENDIF

                 ENDIF  ! END OF:  IF (IT.NE.0 .OR. JT.NE.0)
	      ENDDO     ! END OF:  DO IT=-ISTEP,ISTEP
           ENDDO        ! END OF:  DO JT=-ISTEP,ISTEP

C          TEMP VARIABLE OVERCOMES COMPILER BUG ON OPT 64 PGI 6.0
           RANGNEW = RANGBEST
           CCROTD  = CCBEST
        
C          UPDATE INTEGRAL LOCATION OF PEAK
	   ISX    = ISX + ITMA
	   ISY    = ISY + JTMA
           SX     = ISX
           SY     = ISY

           IF (ABS(ITMA).NE. ISTEP .AND. ABS(JTMA).NE. ISTEP) THEN
C             NOT ON EDGE OF: ISTEPxISTEP INTERPOLATION AREA
C             SUB-PIXEL INTERPOLATION -----------------------------------

C             NOTE: IN MAY 2010 TEST OF 25 EXP IMAGES WITH 17X17 SHIFTS
C                   ONLY 2 CASES THE SUBPIXEL TEST GAVE AN IMPROVEMENT!
C                   I WONDER IF IT IS WORTH THE EFFORT??

C             COPY CC VALUES AROUND THE PEAK CC VALUE
              DO JT= -1,1
                 DO IT= -1,1
                    CCP(IT,JT) = CC(ITMA+IT,JTMA+JT)
                 ENDDO
d640 1
d642 2
a643 2
              !write(6,*) 'cc' write(6,910)cc write(6,*)' ccp'write(6,910) ccp
910           format(3f14.4,/,3f14.4,/,3f14.4,)
d645 2
a646 2
C             SUB-PIXEL INTERPOLATION 
              CALL PARABLD(CCP,SSX,SSY,PEAK)  ! RETURNS: SSX,SSY,PEAK 
d648 2
a649 6
	      CNS2 = NSAM/2+1 + SX + SSX
	      CNR2 = NROW/2+1 + SY + SSY

C             NORMALIZE IMAGE VALUES UNDER MASK OVER VARIANCE RANGE
C             INTERPOLATE INTO POLAR COORD., CREATE FFT OF: CIRCEXP
C             CAN NOT USE: APRINGS_ONE_COEF AS NOT INTEGRAL SHIFT
d651 14
a664 40
              IF (TRANS) THEN
                 CALL APRINGS_TRANS_ONE(EXPBUF,NSAM,NROW,  CNS2,CNR2,
     &                          NUMR,NRING, NLOCS,NRAYSC,
     &                          MODE,USE_OMP, WR,FFTW_PLANS,
     &                          CIRCT,LCIRC, CIRCEXP,LCIRC/2)

                 IF (CPLX) THEN
	            CALL CROSRNG_TRANS(CIRCREF(1,IBE),CIRCEXP,LCIRC/2,
     &                          NLOCS,NRAYSC,
     &                          USE_OMP,FFTW_PLANS(1),
     &                          .NOT. MIRRORED,MIRRORED,
     &                          ISMIRRORED,CCROTD_INTERP,RANGNEW_INTERP)
                 ELSE
	            CALL CROSRNG_TRANS_NOC(CIRCREF(1,IBE),CIRCEXP,
     &                          LCIRC/2,
     &                          NLOCS,NRAYSC,
     &                          USE_OMP,FFTW_PLANS(1),
     &                          .NOT. MIRRORED,MIRRORED,
     &                          ISMIRRORED,CCROTD_INTERP,RANGNEW_INTERP)
                 ENDIF
              ELSE
	         CALL APRINGS_ONE_NEW(NSAM,NROW, CNS2,CNR2, 
     &                          EXPBUF,.FALSE.,
     &                          MODE,NUMR,NRING,LCIRC,WR,FFTW_PLANS,
     &                          CIRCEXP,IRTFLG)
                 IF (CPLX) THEN
	            CALL CROSRNG_2C(CIRCREF(1,IBE),CIRCEXP,LCIRC/2,
     &                         NRING, MAXRIN,NUMR, 
     &                         USE_OMP,FFTW_PLANS(1),
     &                         .NOT. MIRRORED,MIRRORED,
     &                         ISMIRRORED,CCROTD_INTERP,RANGNEW_INTERP)

                 ELSE
	            CALL CROSRNG_2(CIRCREF(1,IBE),CIRCEXP,LCIRC,
     &                          NRING, MAXRIN,NUMR, 
     &                          USE_OMP,FFTW_PLANS(1),
     &                          .NOT. MIRRORED,MIRRORED,
     &                          ISMIRRORED,CCROTD_INTERP,RANGNEW_INTERP)
                 ENDIF
              ENDIF
d666 1
a666 1
              IF (CCROTD_INTERP > CCROTD) THEN
a668 2
                 !write(6,961) ssx,ssy, ccrotd_interp,ccrotd 
961              format(' Subpixel:',2f12.5,' ',f10.5,' >> ',f10.5)
d670 10
a679 7
                 CCROTD  = CCROTD_INTERP
	         RANGNEW = ANG_N(RANGNEW_INTERP,MODE,MAXRIN)
	         SX      = SX + SSX 
	         SY      = SY + SSY 
              ENDIF  ! END OF: (CCROTD_INTERP > CCROTD)
           ENDIF     ! END OF: (IABS(ITMA).NE. ISTEP .......
        ENDIF        ! END OF: (IABS(ISX) .NE. ISHRANGEX .... 
d681 1
a681 1
        CCROT = CCROTD
d697 2
@


1.5
log
@opt level
@
text
@d27 1
d129 3
a131 1
        MYPID = -1
d353 2
a354 1
     &                 IWORSECCROT,CCROTWORSE,LUNDOC)
@


1.4
log
@removed debug output
@
text
@d30 1
a30 1
C=* SPIDER - Modular Image Processing System. 
d73 3
a75 1
       SUBROUTINE MRQLI_PSC(IREFLIST,NUMREF,IEXPLIST,NUMEXP, 
@


1.3
log
@TRANS, CPLX support
@
text
@d195 3
a197 3
                   write(6,*) ' aprings  coef Threads:',numth
        if (trans) write(6,*) ' aprings  transformed rings' 
        if (cplx)  write(6,*) ' aprings  complx crosrngs'
@


1.2
log
@angref undefined bug
@
text
@d91 1
d99 3
a101 1
        INTEGER *8           :: FFTW_PLANS(*)
d122 1
a122 1
        INTEGER, PARAMETER   :: INPIC   = 77
d157 1
a157 1

d171 1
a171 1
           RETURN
d180 18
a197 1
        WEIGHT  = .TRUE.     ! REF. IMAGES HAVE WEIGHTED FFT'S
d201 2
a202 2
C       SAVES COEFFS FOR LATER USE (SEE: APRINGS_FAST)
        CALL APRINGS_NEW_COEFT(IREFLIST,NUMREF,  NSAM,NROW,
d206 2
a207 2
     &                       REFPAT,INPIC, CIRCREF,CIRCREF_IN_CORE,
     &                       LUNRING,SCRFILE, WEIGHT, IRTFLG)
d209 3
a211 2
       !CALL CHKRING(2,.FALSE., CIRCREF,LCIRC, NUMR,NRING, NDUM,NDUM)
       !CALL CHKRAY (2,.FALSE., CIRCREF,LCIRC, NUMR,NRING, NDUM,NDUM)
d219 1
a219 1
            RETURN
d224 1
a224 1
     &                  INPIC,INANG,3,ANGREF,NGOTREF,IRTFLG)
d237 1
a237 1
              RETURN
d241 1
a241 1
     &                       INPIC,INANG,8,ANGEXP,NGOTPAR,IRTFLG)
d251 1
a251 1
              RETURN
d256 1
d262 1
a262 1
     &                    NUMTH,EXPPAT,INPIC, IEXPT,IEND,
d280 1
a280 1
     &              COEFFS,IXY,NLOCS,NRAYSC)
d394 1
a394 1
     &               COEFFS,IXY,NLOCS,NRAYSC)
d408 2
d500 11
a510 5
              CALL APRINGS_ONE_COEFT(EXPBUF, NSAM,NROW, CNS2,CNR2, 
     &                               NUMR,NRING, NLOCS,NRAYSC,
     &                               COEFFS,IXY,
     &                               .FALSE., WR, FFTW_PLANS, 
     &                               CIRCT,LCIRC, CIRCEXP, IRTFLG)
d527 3
a529 1
	         CALL CROSRNG_TRANS(CIRCREF(1,IR),CIRCEXP,LCIRC/2,
d534 23
d600 12
a611 5
                    CALL APRINGS_ONE_COEFT(EXPBUF, NSAM,NROW, CNS2,CNR2, 
     &                               NUMR,NRING, NLOCS,NRAYSC,
     &                               COEFFS,IXY,
     &                               .FALSE., WR, FFTW_PLANS, 
     &                               CIRCT,LCIRC, CIRCEXP, IRTFLG)
d613 31
a643 5
	            CALL CROSRNG_TRANS(CIRCREF(1,IBE),CIRCEXP,LCIRC/2,
     &                         NLOCS,NRAYSC,
     &                         USE_OMP,FFTW_PLANS(1),
     &                         .NOT. MIRRORED,MIRRORED,
     &                         ISMIRRORED,CC(IT,JT),ROTMP)
d695 5
a699 4
              CALL APRINGS_TRANS_ONE(EXPBUF,NSAM,NROW,  CNS2,CNR2,
     &                               NUMR,NRING, NLOCS,NRAYSC,
     &                               MODE,USE_OMP, WR,FFTW_PLANS,
     &                                CIRCT,LCIRC, CIRCEXP,LCIRC/2)
d701 22
a722 2
	      CALL CROSRNG_TRANS(CIRCREF(1,IBE),CIRCEXP,LCIRC/2,
     &                         NLOCS,NRAYSC,
d725 10
a734 1
     &                        ISMIRRORED,CCROTD_INTERP,RANGNEW_INTERP)
@


1.1
log
@Initial revision
@
text
@a170 1
        COEFFS  = 0.0
d192 13
a204 15
        GOTREFANG = .FALSE.
        IF (LIMITRANGE) THEN
C          REFANGLES FILE FOR RESTRICTED ANGULAR SEARCH  OR 'SH'
	   ALLOCATE(REFDIR(3,NUMREF),
     &              ANGREF(3,NUMREF), STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
               CALL ERRT(46,'REFDIR, ANGREF',6*NUMREF)
               RETURN
           ENDIF 
           GOTREFANG = .TRUE.

C          READ REF. ANGLES INTO ANGREF
	   CALL AP_GETANGA(IREFLIST,NUMREF,0,REFANGDOC,REFPAT,
     &                    INPIC,INANG,3,ANGREF,NGOTREF,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
d206 2
a207 3
C          CONVERT REF. ANGLES TO UNITARY DIRECTIONAL VECTORS (REFDIR).
	   CALL AP_GETSATA(ANGREF,REFDIR,3,NUMREF,IRTFLG)
        ENDIF
d225 1
a225 1
       ELSE
d249 1
d268 1
a268 1
    
d336 1
d395 1
a395 1
	DOUBLE PRECISION       :: CCOA,CCMA,CCBEST
d621 1
a621 1
                 write(6,961) ssx,ssy, ccrotd_interp,ccrotd 
@
