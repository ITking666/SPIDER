head	1.24;
access;
symbols
	pre_getangas:1.13
	GPL2010:1.6
	pre_GPL2010:1.5
	pre_var_equation:1.4
	pre_fftwrings:1.3
	pre_opfiles:1.1
	src:1.1;
locks; strict;
comment	@c @;


1.24
date	2014.10.02.13.29.54;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2014.09.15.15.36.42;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2014.06.02.11.59.23;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2013.05.22.14.18.29;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.18.13.43.32;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2012.11.05.16.22.23;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.01.18.55.16;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2012.04.11.18.17.27;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2012.03.29.11.45.55;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2012.01.18.17.50.11;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.29.15.21.56;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2011.02.10.15.39.27;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2011.02.08.17.03.39;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.12.18.34.42;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.03.19.26.45;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.03.18.24.01;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2011.01.03.17.03.17;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2011.01.03.16.21.22;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.24.13.26.25;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.01.11.15.31;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2009.05.22.10.57.10;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.06.21.27.49;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.12.13.45.19;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2007.01.11.17.53.19;	author leith;	state Exp;
branches;
next	;


desc
@@


1.24
log
@LOCAST, ASKLIST  RULES FOR USING SENT ILIST
@
text
@ 
C++*********************************************************************
C                                                                      *
C  OPFILES.F   NEW                            12/15/06  ARDEAN LEITH    
C              BAD NUMBRT() TRAP              05/21/09  ARDEAN LEITH  
C              ASKNAM, PROMPTEX               12/06/10  ARDEAN LEITH 
C              NX...                          03/26/12  ARDEAN LEITH 
C              COPY NON SPIDER INPUT          05/26/14  ARDEAN LEITH 
C              COPY NON SPIDER INPUT          05/26/14  ARDEAN LEITH 
C              LOCAST, ASKLIST FOR ILIST      10/02/14  ARDEAN LEITH
C
C ********************************************************************** 
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2014  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C ********************************************************************** 
C 
C  CONTAINS:  OPFILES, GETOLDIMG, GETNEWIMG, NEXTFILE, NEXTFILES 
C
C  OPFILES(LUNCP,LUNIMG,LUNDOC,LUNXM,  ASKNAM,FILPAT,NLET, DISP,
C          ITYPE,NX,NY,NZ,MAXIM, PROMPT,FOUROK,
C          ILIST,NIMAXT, NTOT,IMGNUM, IRTFLG)
C 
C  PURPOSE: SOLICITS FILE NAME(S) AND OPENS FILE(S)
C           SUPPORT ROUTINE FOR CONVERTING OPERATIONS TO 
C           WORK ON WHOLE STACK OR WITH SELECTION DOC FILE.
C
C  PARAMETERS:
C        LUNCP      UNIT TO COPY HEADER VALUES FROM               (SENT)
C        LUNIMG     UNIT TO OPEN FILE ON                          (SENT)
C        LUNDOC     UNIT TO OPEN LIST DOC FILES ON                (SENT)
C        LUNXM      UNIT TO OPEN XMIPP SELFILE ON                 (SENT)
C        ASKNAM     FLAG TO ASK FOR FILE NAME                     (SENT)
C        FILPAT     FILE NAME PATTERN                             (RET)
C        NLET       CHARS IN FILE NAME PATTERN                    (RET)
C        DISP       CHARACTER CONTAINING ONE OF THE               (SENT) 
C                   FOLLOWING DISPOSITION SPECIFICATIONS:
C                   'O'   -  FILE IS ASSUMED TO EXIST.  DIMENSIONS,
C                            ITYPE AND HEADER INFO (IN COMMON) ARE 
C                            RETURNED TO THE CALLING PROGRAM. 
C                   'B'   -  SAME AS OLD BUT NO LIMIT ON BUFFER LENGTH
C                            FOR OPENCHK. 
C                   'Z/E' -  THE FILE IS ASSUMED TO EXIST.
C                            IF FILE DOES NOT EXIST, THEN BATCH DOES
C                            NOT STOP. (ONLY DIFFERENCE FROM 'O'). 
C                   'N'  -   WANT NEW FILE. SEND NX, NY, NZ & ITYPE.
C                   'U'  -   IT IS NOT KNOWN IF THE FILE EXISTS.  
C                            SEND NX, NY, NZ & ITYPE. IF FILE 
C                            ALREADY EXISTS, IT WILL BE REPLACED.
C        ITYPE      IFORM FOR FILE                         (SENT OR RET) 
C        NX,NY,NZ   IMAGE SIZE                             (SENT OR RET)
C        MAXIM      STACK INDICATOR IF DISP == 'I'                (SENT)
C                   STACK INDICATOR                               (RET)
C        PROMPT     PROMPT FOR FILNAME                            (SENT)
C                     IF NOT (ASKNAM) THIS IS FILE NAME           (SENT)
C                     ~ (TILDE) IN LAST CHAR. SAYS SKIP
C                       "FILE" AT END OF PROMPT
C                     ~9 IN NEXT TO LAST OR
C                        NEXT-TO-NEXT-TO LAST
C                        ACCEPTS AN EXTENSION
C                        (OTHERWISE DISCARDED!)
C                     ~6 KEEPS OLD DATE/TIME
C        FOUROK     CAN USE EXISTING FOURIER FILES?               (SENT)
C        ILIST      IMAGE NUMBER LIST                             (RET)
C                     IF NIMAXT < 0 MUST BE SENT
C                     NOT USED IF SINGLE IMAGE/SELFILE 
C        NIMAXT     MAX LENGTH OF IMAGE NUMBER LIST               (SENT)
C                     <0 MEANS DO NOT ASK FOR LIST
C        UNUSED     UNUSED                                          (?)
C        NTOT       # OF IMAGES IN IMAGE NUMBER LIST              (RET)
C                     ZERO FOR SINGLE IMAGE AND NO * 
C        IMGNUM     IMAGE NUMBER THAT IS CURRENTLY OPEN       (SENT/RET)
C                   ON INPUT: IF (BARESTACK) IS # WANTED
C                   ON OUTPUT:   <0 IS SELFILE IN USE 
C        IRTFLG     ERROR FLAG (0 IS NORMAL)                      (RET)
C                      -1 GOTO PREVIOUS QUESTION
C 
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12 
C--********************************************************************* 

       SUBROUTINE OPFILES(LUNCP,LUNIMG,LUNDOC,LUNXM,
     &                    ASKNAM,FILPAT,NLET, DISP,
     &                    ITYPE,NX,NY,NZ,MAXIM,
     &                    PROMPT,
     &                    FOUROK,ILIST,NIMAXT, 
     &                    UNUSED,NTOT,IMGNUM, IRTFLG) 
 
       INCLUDE 'CMBLOCK.INC' 
       INCLUDE 'CMLIMIT.INC' 
 
       INTEGER                   :: LUNCP,LUNIMG,LUNDOC
       LOGICAL                   :: ASKNAM
       CHARACTER(LEN=*)          :: FILPAT 
       INTEGER                   :: NLET
       CHARACTER(LEN=1)          :: DISP 
       INTEGER                   :: ITYPE,NX,NY,NZ,MAXIM
       CHARACTER(LEN=*)          :: PROMPT 
       LOGICAL                   :: FOUROK
       INTEGER                   :: ILIST(*)
       INTEGER                   :: NIMAXT,NDUM,NTOT,IMGNUM, IRTFLG

       INTEGER                   :: NIMAXP
       LOGICAL                   :: SAYIT,ASKLIST
       CHARACTER (LEN=1)         :: CDUM 
       CHARACTER (LEN=MAXNAM)    :: FILNAM 
       CHARACTER (LEN=2*MAXNAM)  :: MESG 
       CHARACTER (LEN=100)       :: PROMPTEX
       CHARACTER (LEN=1)         :: DISPT 
       CHARACTER (LEN=1)         :: NULL = CHAR(0)

       INTEGER                   :: LUNOP,NLETT

       LOGICAL                   :: ISOPEN,GOTFILE
       CHARACTER (LEN=MAXNAM)    :: FILNAMT 

       LOCTILDE = INDEX(PROMPT,'~') ! unfinished

       IF (ASKNAM .AND. PROMPT == NULL) THEN
C         ASK FOR FILE NAME, CAN ACCEPT EXTENSION

          IF (DISP == 'N' .OR. 
     &        DISP == 'I' .OR.
     &        DISP == 'U') THEN
C            NEW FILE, USE DEFAULT PROMPT
             PROMPTEX = 
     &          'OUTPUT FILE NAME OR TEMPLATE (E.G. STK@@****)~~9'
          ELSE
C            OLD FILE, USE DEFAULT PROMPT
             PROMPTEX = 
     &          'INPUT FILE NAME OR TEMPLATE (E.G. STK@@****)~~9'
          ENDIF
       
          CALL FILERD(FILPAT,NLET,NULL,PROMPTEX,IRTFLG)
          IF (IRTFLG .NE. 0) RETURN 

       ELSEIF (ASKNAM) THEN
C         ASK FOR FILE NAME USING PROMPT
      
          CALL FILERD(FILPAT,NLET,NULL,PROMPT,IRTFLG)
          IF (IRTFLG .NE. 0) RETURN 

       ELSE
C         USE FILENAME SENT IN: PROMPT
          FILPAT = PROMPT
          NLET   = LNBLNKN(FILPAT)
       ENDIF
 
       IMGNUMIN = IMGNUM
       IMGNUM   = 0 
     
       LOCAT    = INDEX(FILPAT(1:NLET),'@@')   
       LOCAST   = INDEX(FILPAT(1:NLET),'*')
       
       !write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
       !write(6,*)' ILIST:',ILIST(1)
       !write(6,*)' locast,locat,nstack:',locast,locat,maxim

       ASKLIST = (NIMAXT >= 0)
       NIMAXP  = ABS(NIMAXT)
 
       !!IF (ASKNAM .AND. LOCAST > 0 .AND. ASKLIST) THEN
       IF (LOCAST > 0 .AND. ASKLIST) THEN
C         GET LIST OF IMAGES FROM DOC. FILE OR INPUT LINE
          NTOT   = 0 
          CALL FILELIST(.FALSE.,LUNDOC,CDUM,NDUM,ILIST,NIMAXP,
     &                  NTOT,' ',IRTFLG)
          IF (IRTFLG .NE. 0) RETURN
       ELSEIF (.NOT. ASKLIST) THEN
          NTOT = NIMAXP
       ENDIF

       IF (LOCAT > 0 .AND. LOCAST > LOCAT) THEN
C         TEMPLATED STACKED FILE: STK@@**** -------------- _9@@* or STK@@**

C         OPEN STACK HEADER
          FILNAM = FILPAT(1:LOCAT)
          MAXIM  = 1  
             
          IF (FILNAM(1:1) .NE. '_') THEN
             CALL FILNAMANDEXT(FILNAM(1:LOCAT-1),DATEXC,
     &                         FILNAMT,NLET,.TRUE.,IRTFLG)
             INQUIRE(FILE=FILNAMT,OPENED=ISOPEN,NUMBER=LUNOP)
             MESG = '  FILE: ' // FILNAMT(1:NLET) //
     &              '  ALREADY OPENED ON' // NULL
             LENE = LNBLNKN(MESG)
             IF (ISOPEN .AND. LUNOP .NE. LUNIMG) THEN
                WRITE(NOUT,'(A,I3)') MESG(1:LENE),LUNOP 
                !CALL ERRT(102,MESG(1:LENE),LUNOP) 
                IRTFLG = -2
                GOTO 9000
             ENDIF
          ENDIF

	  CALL OPFILEC(LUNCP,.FALSE.,FILNAM,LUNIMG,DISP,
     &                 ITYPE,NX,NY,NZ, 
     & 		       MAXIM,' ',FOUROK,IRTFLG) 
	  IF (IRTFLG .NE. 0) GOTO 9000 
          CALL LUNSETISBARE(LUNIMG,.FALSE.,IRTFLG)

C         OPEN FIRST FILE IN STACK SERIES
          IMGWANT  = ILIST(1)
          IF (IMGWANT < 0 .OR. IMGWANT > 10000000) THEN
              CALL ERRT(102,'INVALID IMAGE NUMBER',IMGWANT)
              IRTFLG = 1
              GOTO 9000
          ENDIF

          SAYIT    = .TRUE.
          IF (DISP == 'U' .OR. DISP == 'N') THEN
             CALL GETNEWIMG(LUNCP,LUNIMG,LUNDOC,FILPAT,IMGWANT,
     &                      SAYIT,IMGNUM,IRTFLG)
          ELSE
	     CALL GETOLDIMG(LUNIMG,LUNDOC,FILPAT, IMGWANT,SAYIT,
     &                      FOUROK,IMGNUM,IRTFLG)
          ENDIF
          IF (IRTFLG .NE. 0) GOTO 9000

C         RETRIEVE CURRENT MAXIMUM IMAGE NUMBER FROM OVERALL HEADER
          CALL LUNGETMAXIM(LUNIMG,MAXIM,IRTFLG)

          !write(6,'(A,A,A,i6,a,i6,a,i6)')' Opened templated stack: ',
!     &          FILPAT(1:nlet),' At image: ',IMGNUM, 
!     &          '  Maxim: ',maxim

       ELSEIF (LOCAT == NLET) THEN
C         WHOLE BARESTACK:  STK@@  --------------------------_9@@ or STK@@
          DISPT = DISP
          IF (DISP == 'I') THEN
C             OPEN NEW BARE INDEXED STACK 
              DISPT = 'N'
              MAXIM = -MAXIM  ! FLAG FOR INDEXED STACK
          ELSE
              MAXIM = 1
          ENDIF

          IF (FILNAM(1:1) .NE. '_') THEN
             CALL FILNAMANDEXT(FILPAT(1:LOCAT-1),DATEXC,
     &                         FILNAMT,NLET,.TRUE.,IRTFLG)
             INQUIRE(FILE=FILNAMT,OPENED=ISOPEN,NUMBER=LUNOP)
             MESG = '  FILE: ' // FILNAMT(1:NLET) //
     &              '  ALREADY OPENED ON' // NULL
             LENE = LNBLNKN(MESG)
             IF (ISOPEN .AND. LUNOP .NE. LUNIMG) THEN
                WRITE(NOUT,'(A,I3)') MESG(1:LENE),LUNOP 
                !CALL ERRT(102,MESG(1:LENE),LUNOP) 
                IRTFLG = -2
                GOTO 9000
             ENDIF
          ENDIF

          CALL OPFILEC(LUNCP,.FALSE.,FILPAT,LUNIMG,DISPT,
     &                 ITYPE,NX,NY,NZ, 
     & 		       MAXIM,'INPUT',FOUROK,IRTFLG) 
	  IF (IRTFLG .NE. 0) GOTO 9000

C         OPEN FIRST FILE IN STACK, UNLESS SPECIFIED FOR NEW BARE STACK
          IMGWANT = 1
          SAYIT   = .TRUE.

          IF (DISP == 'U' .OR. 
     &        DISP == 'I' .OR.
     &        DISP == 'N') THEN
C            NEW BARE STACK, OPEN REQUESTED FILE IN STACK

             IF (IMGNUMIN > 0) IMGWANT = IMGNUMIN
             CALL GETNEWIMG(LUNCP,LUNIMG,LUNDOC,FILPAT,IMGWANT,
     &                      SAYIT,IMGNUM,IRTFLG)
             IF (IRTFLG .NE. 0) GOTO 9000

          ELSE
C            EXISTING BARE STACK, OPEN FIRST FILE IN STACK
	     CALL GETOLDIMG(LUNIMG,LUNDOC,FILPAT, IMGWANT,
     &                      SAYIT,FOUROK,IMGNUM,IRTFLG)
             IF (IRTFLG .NE. 0) GOTO 9000

C            CREATE IMAGE NUMBER LIST IN: ILIST
             NTOT = 0
             DO I= 1,MAXIM
                NTOT = NTOT + 1
                IF (NTOT > NIMAXP) THEN
                   CALL ERRT(102,'IMAGE # LIST OVERFLOW AT IMAGE',NTOT)
                   GOTO 9000
                ENDIF
                ILIST(NTOT) = I
             ENDDO
          ENDIF

         !write(6,*)' Opened bare stack:',FILPAT(1:NLET),' Img:',IMGNUM
         
       ELSEIF (LOCAST > 0) THEN
C         A SIMPLE FILE TEMPLATE: IMG*** ----------------------- IMG***

C         OPEN FIRST FILE IN THE SERIES
          IMGNUM = ILIST(1)
          IF (IMGNUM < 0 .OR. IMGNUM > 10000000) THEN
              CALL ERRT(102,'INVALID IMAGE NUMBER',IMGNUM)
              IRTFLG = 1
              GOTO 9000
          ENDIF
          CALL  FILGET(FILPAT,FILNAM,NLET,IMGNUM,IRTFLG)
	  IF (IRTFLG .NE. 0) GOTO 9000 

          MAXIM = 0 
	  CALL OPFILEC(LUNCP,.FALSE.,FILNAM,LUNIMG,DISP,
     &                 ITYPE,NX,NY,NZ, 
     & 		       MAXIM,' ',FOUROK,IRTFLG) 
	  IF (IRTFLG .NE. 0) GOTO 9000 

          !write(6,*)' Opened templated file: ',FILPAT(1:NLET),
      !&              '  for:',NTOT,' images.'

       ELSE
C         SINGLE SIMPLE INPUT FILE: IMG001 --------------------- IMG001
C         OR XMIPP SELFILE LISTING FILE: SELX ----------------- SELFILE
C         OR TRYING TO COPY NON-SPIDER FILE   ----------------- NONSPIFILE
               
C         CHECK FOR XMIPP SELFILE LIST
          IF (LUNXM > 0) THEN
             !write(6,*)' Filpat for openxmsel: ',filpat(:nlet) 
             CALL OPENXMSELFILE(FILPAT,LUNXM,FILNAM,NLET,NTOT,IRTFLG)
             !write(6,*)' Filnam from openxmsel: ',ntot,':',filnam(:nlet) 

             INQUIRE(FILE=FILNAM(:NLET),EXIST=GOTFILE)
           
             IF (NTOT > 0 .AND. GOTFILE) THEN
C               OPEN FIRST FILE IN XMIPP SELFILE LIST
                MAXIM = 0  
	        CALL OPFILEC(LUNCP,.FALSE.,FILNAM(:NLET),LUNIMG,DISP,
     &                       ITYPE,NX,NY,NZ, 
     & 		             MAXIM,'dum~9',FOUROK,IRTFLG) 
	        IF (IRTFLG .NE. 0) GOTO 9000 

                IMGNUM     = -1
                !write(6,*)' Opened selfile image: ',filnam(1:nlet) 
                RETURN

             ENDIF
          ENDIF

C         SINGLE SIMPLE INPUT FILE: IMG001 ------------------ IMG001
          MAXIM = 0  
	  CALL OPFILEC(LUNCP,.FALSE.,FILPAT,LUNIMG,DISP,
     &                 ITYPE,NX,NY,NZ, 
     & 		       MAXIM,PROMPT,FOUROK,IRTFLG) 

C         RETURN FILENAME WITH ANY EXTENSION IF NOT SPIDER IMAGE
          IF (IRTFLG == 5) NLET = lnblnkn(FILPAT)
	  IF (IRTFLG .NE. 0) GOTO 9000 

          NTOT       = 0
          IMGNUM     = 1

          !write(6,*)' Opened simple file: ',FILPAT(1:nlet) 
       ENDIF

9000   RETURN

       END 
 

C++*********************************************************************
C
C GETOLDIMG.F   FROM GETNXTSTK                     JAN 02 ARDEAN LEITH
C
C **********************************************************************
C
C    GETOLDIMG(LUN,LUNXM,FILPAT,NWANT, SAYIT,FOUROK,NGOT,IRTFLG)
C
C    PURPOSE:       TO OPEN A SPECIFIED IMAGE WITHIN STACK FOR RANDOM 
C                   ACCESS READING/WRITING.
C
C    PARAMETERS:
C        LUN        LUN NUMBER FOR FILNAM                         (SENT)
C        LUNXM      LUN FOR XM SELFILE                            (SENT) 
C        FILPAT     FILENAME PATTERN                              (SENT)
C        NWANT      IMAGE NUMBER WANTED (<0 IS SELFILE)           (SENT) 
C        SAYIT      SAY FILE OPENING INFO.                        (SENT)
C        FOUROK     FOURIER INPUT OK FLAG                         (SENT) 
C        NGOT       IMAGE NUMBER FOUND                            (RET.) 
C        IRTFLG     ERROR RETURN FLAG.                            (RET.)
C                   IRTFLG = -1    END OF FILE BEFORE NWANT
C                   IRTFLG =  0    NORMAL RETURN, IMAGE IS STACK
C                   IRTFLG =  2    IMAGE NOT IN USE
C
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************
 
	SUBROUTINE GETOLDIMG(LUN,LUNXM,FILPAT,NWANT, SAYIT,
     &                       FOUROK,NGOT,IRTFLG)

        INCLUDE 'CMLIMIT.INC'

        INTEGER                :: LUN     
        INTEGER                :: LUNXM     
        CHARACTER(LEN=*)       :: FILPAT
        INTEGER                :: NWANT     
        LOGICAL                :: SAYIT
        LOGICAL                :: FOUROK
        INTEGER                :: NGOT     
        INTEGER                :: IRTFLG     

        CHARACTER(LEN=MAXNAM)  :: FILNAM
        CHARACTER(LEN=1)       :: NULL = CHAR(0)

        INTEGER                :: NLET,LOCAST,LOCAT

        NLET   = lnblnkn(FILPAT)

        LOCAST = INDEX(FILPAT(1:NLET),'*')
        LOCAT  = INDEX(FILPAT(1:NLET),'@@')

        !write(6,*)' locast,locat:',locast,locat,nlet,filpat(1:nlet)
        !write(6,*)' getoldimg, nwant,: ',nwant,':',filpat(1:nlet)
        
        IF (NWANT < 0) THEN
C          XMIPP SELFILE SIMPLE IMAGE ------------------------- SELAAA

C          RECOVER EXISTING IMAGE SIZE & TYPE
           CALL LUNGETSIZE(LUN,NX1,NY1,NZ1,IRTFLG)
           CALL LUNGETTYPE(LUN,ITYPE1,IRTFLG)
           CLOSE(LUN)    ! USUALLY STILL OPEN
 
C          LOAD FILNAM FROM SELFILE
           CALL GETNEXT_XMSEL(LUNXM,.TRUE.,FILNAM,NLET,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

C          OPEN EXISTING FILE: FILNAM  (HAS EXTENSION)
           MAXIM = 0  
	   CALL OPFILEC(0,.FALSE.,FILNAM(:NLET),LUN,'O',ITYPE,
     &                 NX,NY,NZ, 
     & 		       MAXIM,'~9',FOUROK,IRTFLG) 
	   IF (IRTFLG .NE. 0) RETURN 

C          NEW IMAGE SIZE SHOULD BE SAME AS PREVIOUS FILE
           CALL SIZCHK(NULL,NX1,NY1,NZ1,ITYPE1,
     &                      NX ,NY, NZ, ITYPE, IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 
 
           !write(6,*)' Opened old xmipp selfile file: ',filnam(1:nlet)

           NGOT   = NWANT   
           IRTFLG = 0
           RETURN

        ELSEIF (LOCAST > 0 .AND. LOCAT <= 0) THEN 
C          TEMPLATED SIMPLE IMAGE --------------------------- IMG***

           CALL LUNGETSIZE(LUN,NX1,NY1,NZ1,IRTFLG)
           CALL LUNGETTYPE(LUN,ITYPE1,IRTFLG)
           CLOSE(LUN)    ! USUALLY STILL OPEN
 
           CALL  FILGET(FILPAT,FILNAM,NLET,NWANT,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

           MAXIM = 0  
	   CALL OPFILEC(0,.FALSE.,FILNAM,LUN,'O',ITYPE,
     &                 NX,NY,NZ, 
     & 		       MAXIM,' ',FOUROK,IRTFLG) 
	   IF (IRTFLG .NE. 0) RETURN 

C          IMAGE SIZE SHOULD BE SAME
           CALL SIZCHK(NULL,NX1,NY1,NZ1,ITYPE1,
     &                      NX ,NY, NZ, ITYPE, IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

           !write(6,*)' Opened old templated file: ',filnam(1:nlet),maxim

           NGOT   = NWANT   
           IRTFLG = 0
           RETURN

        ELSEIF (LOCAT  > 0 .AND. LOCAST > LOCAT) THEN
C          TEMPLATED STACKED IMAGE ---------------------------- STK@@***

C          MUST LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
           CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLG)
           CALL LUNREDHED(LUN,NX,0,.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) THEN
              !write(6,*) ' lunredhed,lun,NX,irtflg:',lun,NX,irtflg
              CALL ERRT(102,'REDHED FAILED ON LUN',LUN) 
              IRTFLG = 2
              RETURN
           ENDIF

C          LOAD SPECIFIED IMAGE HEADER
           CALL LUNREDHED(LUN,NX,NWANT,.FALSE.,IRTFLG)
           IF (IRTFLG == 0) THEN
C             NEED IMUSED FROM THIS STACKED IMAGE
              CALL LUNGETINUSE(LUN,IMUSED,IRTFLG)
           ENDIF
           IF (IRTFLG .NE. 0 .OR. IMUSED == 0) THEN
              CALL ERRT(102,'IMAGE NOT IN STACK',NWANT) 
              IRTFLG = 2
              RETURN
           ENDIF
           NGOT = NWANT

           FILNAM = FILPAT
           CALL LUNSETIMNUM(LUN,FILNAM,NWANT,'O',IRTFLG)
           NLET = lnblnkn(FILNAM)

           !write(6,*)' Opened old templated stacked file: ',FILNAM(:NLET)

        ELSEIF (LOCAT == NLET) THEN
C          WHOLE IMAGE STACK ------------------------------ STK@@ or _1@@
C          GET SPECIFIED IMAGE HEADER FROM STACK FILE LOCATION
C          DO NOT CALL ERRT IF RUNS OFF END OF FILE

           CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLG)

           NGOT = NWANT
           DO
C             LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
              CALL LUNREDHED(LUN,NX,0,.FALSE.,IRTFLG)

C             LOAD SPECIFIED IMAGE HEADER
              CALL LUNREDHED(LUN,NX,NGOT,.FALSE.,IRTFLG)
              IF (IRTFLG > 0) THEN
C                PROBABLY RAN OFF END OF STACK FILE
                 IRTFLG = -1
                 NGOT   = 0
                 RETURN
              ENDIF

C             NEED IMUSED FROM THIS STACKED IMAGE
              CALL LUNGETINUSE(LUN,IMUSED,IRTFLG)
              IF (IMUSED > 0) EXIT     ! FOUND NEXT IMAGE

C             THIS IMAGE NOT AN EXISTING IMAGE WITHIN STACK!
C             INCREMENT NGOT AND TRY AGAIN
              NGOT  = NGOT + 1

           ENDDO

           FILNAM = FILPAT
           CALL LUNSETIMNUM(LUN,FILNAM,NGOT,'O',IRTFLG)

           NLET = lnblnkn(FILNAM)

           !write(6,*)' Opened old bare stacked file: ',FILNAM(1:NLET)
           !write(6,*)' ngot,NX:',ngot,NX,lun,imused,irtflg
        ENDIF

C       SET OFFSETS FOR REDLIN/WRTLIN ON THIS LUN
        CALL LUNSETIMGOFF(LUN,NGOT,NX,IRTFLG)

C       WRITE OUT FILE OPENING INFO 
        CALL LUNSAYINFO(LUN,IRTFLG)

C       SET COMMON BLOCK VARIABLES
        CALL LUNSETCOMMON(LUN,IRTFLG)


	END


C **********************************************************************
C
C    GETNEWIMG(LUNCP,LUN,LUNXM,FILPAT,NWANTT, SAYIT,NGOT,IRTFLG)
C
C    PURPOSE:       TO OPEN A SPECIFIED IMAGE WITHIN STACK FOR RANDOM 
C                   ACCESS READING/WRITING.
C
C    PARAMETERS:
C        LUNCP      UNIT NUMBER FOR HEADER TXT COPY               (SENT)
C        LUN        UNIT NUMBER FOR FILNAM.                       (SENT)
C        LUNXM      UNIT NUMBER FOR XM SELFILE                    (SENT)
C        FILPAT     FILENAME PATTERN                              (SENT)
C        NWANT      IMAGE NUMBER WANTED                           (SENT) 
C        SAYIT      SAY FILE OPENING INFO                         (SENT)
C        NGOT       IMAGE NUMBER FOUND                            (RET.) 
C        IRTFLG     ERROR RETURN FLAG.                            (RET.)
C                   IRTFLG = -1    END OF FILE BEFORE NWANT
C                   IRTFLG =  0    NORMAL RETURN, IMAGE IS STACK
C                   IRTFLG =  2    IMAGE NOT IN USE
C
C **********************************************************************

	SUBROUTINE GETNEWIMG(LUNCP,LUN,LUNXM,FILPAT,NWANTT, 
     &                       SAYIT,NGOT,IRTFLG)

        INCLUDE 'CMLIMIT.INC'

        INTEGER                :: LUNCP,LUN,LUNXM
        CHARACTER(LEN=*)       :: FILPAT
        INTEGER                :: NWANTT
        LOGICAL                :: SAYIT
        INTEGER                :: NGOT
        INTEGER                :: IRTFLG

        CHARACTER(LEN=MAXNAM)  :: FILNAM
        CHARACTER(LEN=1)       :: DSP
        LOGICAL                :: FOUROK,ISBARE

        NWANT  = NWANTT          ! NWANTT MAY NOT BE WRITABLE
        NLET   = lnblnkn(FILPAT)
        LOCAST = INDEX(FILPAT(1:NLET),'*')
        LOCAT  = INDEX(FILPAT(1:NLET),'@@')

        !write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)

        IF (NWANT < 0) THEN
C          XMIPP SELFILE SIMPLE IMAGE ----------------------- SELAAA

C          GET PREVIOUS FILE SIZE AND TYPE (SHOULD BE SAME)
           CALL LUNGETSIZE(LUN,NX1,NY1,NZ1,IRTFLG)
           CALL LUNGETTYPE(LUN,ITYPE1,IRTFLG)
           CLOSE(LUN)           ! USUALLY STILL OPEN
 
C          LOAD FILE NAME FROM SELFILE
           CALL GETNEXT_XMSEL(LUNXM,.TRUE.,FILNAM,NLET,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

C          OPEN FILNAM
           MAXIM = 0  
	   CALL OPFILEC(0,.FALSE.,FILNAM(1:NLET),LUN,'U',ITYPE1,
     &                 NX1,NY1,NZ1, 
     & 		       MAXIM,'~9',FOUROK,IRTFLG) 
	   IF (IRTFLG .NE. 0) RETURN 

           !write(6,*)' Opened new Xmipp selfile file: ',filnam(1:nlet)

           NGOT = NWANT   
           RETURN

        ELSEIF (LOCAT <= 0 .AND. LOCAST > 1) THEN
C          TEMPLATED SIMPLE IMAGE --------------------------- IMG***

C          NEW IMAGE, NEEDS TO KNOW: ITYPE,NX,NY,NZ!
C          GET IT FROM OPFILES OR PREVIOUS CALL
           CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLG)
           CALL LUNGETTYPE(LUN,ITYPE,IRTFLG)
           CLOSE(LUN)   ! GET RID OF ANY OPEN IMAGE
 
C          CREATE FILE NAME
           CALL FILGET(FILPAT,FILNAM,NLET,NWANT,IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN 

           MAXIM = 0
           CLOSE(LUN)    ! MAY BE STILL OPEN FROM FIRST CALL  
	   CALL OPFILEC(LUNCP,.FALSE.,FILNAM,LUN,'U',ITYPE,
     &                 NX,NY,NZ, 
     & 		       MAXIM,' ',FOUROK,IRTFLG) 
	   IF (IRTFLG .NE. 0) RETURN 

           !write(6,*)' Opened new templated file: ',FILNAM(1:NLET)

           NGOT   = NWANT   
           IRTFLG = 0
           RETURN

        ELSEIF (LOCAT > 0) THEN
C          STACKED IMAGE ------------------------------- STK@@*  or STK@@

           CALL LUNGETISBARE(LUN,ISBARE,IRTFLG)
!           IF (ISBARE) THEN
!C             WANT NEXT IMAGE IN STACK, GET CURRENT FILE NUMBER 
!              CALL LUNGETINUSE(LUN,NWANT,IRTFLG)
!              NWANT = NWANT + 1
!              IF (NWANT <= 0) NWANT = 1
!           ENDIF

C          LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
           CALL LUNGETSIZE(LUN,NX,NY,NZ,IRTFLG)
           CALL LUNREDHED(LUN,NX,0,.FALSE.,IRTFLG)
 
C          RETRIEVE CURRENT MAXIMUM IMAGE NUMBER FROM OVERALL HEADER
           CALL LUNGETMAXIM(LUN,MAXIM,IRTFLG)

           IF (NWANT > MAXIM) THEN
C             UPDATE OVERALL HEADER WITH MAXIMUM IMAGE NUMBER
              CALL LUNSETMAXIM(LUN,NWANT,IRTFLG)
              CALL LUNSETMAXALL(LUN,NWANT,IRTFLG)
           ENDIF

C          NEED ISTACK 
           CALL LUNCOPYSTK(LUN,ISTACK,IRTFLGT)

          IF (ISTACK < 0) THEN
C             MAKING A NEW INDEXED STACKED FILE, UPDATE INDX LOCATION
              CALL LUNWRTINDX(LUN,NWANT,NX,IRTFLGT)
              IF (IRTFLGT .NE. 0) RETURN
           ENDIF

           IF (NWANT > MAXIM .OR. ISTACK > 2) THEN
C             SAVE OVERALL HEADER NOW TO PRESERVE MAXIM & LASTINDX
              CALL LUNWRTHED(LUN,NX,0,IRTFLGT)
              CALL LUNGETMAXIM(LUN,MAXIM,IRTFLG)
           ENDIF

C          GET FILENAM FROM CURRENT HEADER OBJECT
           CALL LUNGETFILE(LUN,FILNAM,NLET,DSP,IRTFLG)

C          SET NEW FILENAME IN HEADER OBJECT AND GET FILENAME
           CALL LUNSETIMNUM(LUN,FILNAM,NWANT,'N',IRTFLG)
           NLET = lnblnkn(FILNAM)    ! MAY HAVE BEEN ALTERED

C          SET IMGNUM IN HEADER OBJECT
           CALL LUNSETINUSE(LUN,NWANT,IRTFLG)

C          PUT IMAGE ISTACK
           CALL LUNSETISTACK(LUN,0,IRTFLG)

C          PUT COMMON VALUES INTO COMMON AREA (NOT NEEDED IN FUTURE?)
           CALL LUNSETCOMMON(LUN,IRTFLG)

C          PUSH HEADER OBJECT INFO INTO NEW STACKED FILE
           CALL LUNWRTHED(LUN,NX,NWANT,IRTFLG)

C          SET OFFSETS FOR REDLIN/WRTLIN ON THIS LUN
           CALL LUNSETIMGOFF(LUN,NWANT,NX,IRTFLGT)

C          WRITE OUT FILE OPENING INFO TO SCREEN
           CALL LUNSAYINFO(LUN,IRTFLG)

           NGOT = NWANT

           !write(6,*)' Opened new stacked file: ',FILNAM(1:NLET)

        ENDIF

	END




C++*********************************************************************
C
C  NEXTFILES.F  NEW                              12/15/06 ARDEAN LEITH
C               OVERUN OUTPUT LIST = -99          1/15/12 ARDEAN LEITH
C **********************************************************************
C
C NEXTFILES(NINDX1, NINDX2, INUMBR1,INUMBR2, 
C           FOUROK,NGOT1,NGOT2,   
C           MAXIM1,MAXIM2,   
C           LUN1,LUNCP,LUN2, FILPAT1,FILPAT2,
C           IMGNUM1,IMGNUM2,IRTFLG) 
C
C PURPOSE:  GETS NEXT FILES FOR A STACK ORIENTED OPERATION
C           STACKS MUST BE OPENED WITH OPFILES!!!
C
C PARAMETERS: NINDX1,NINDX2    LIST INDICES                   (SENT/RET)
C             INUMBR1,INUMR2   IMAGE NUMBER LISTS                (SENT)
C             FOUROK           FOURIER INPUT IS OK               (SENT)
C             LUNXM1,LUNXM2    LUN FOR SELFILE INPUT             (SENT)
C             NGOT1,NGOT2      # OF IMAGES                       (SENT)
C             MAXIM1,MAXIM2    MAXIM VALUES                      (SENT)
C             LUN1             LUN FOR INPUT  (0 = NO FILE IN)   (SENT)
C             LUNCP            LUN FOR OUTPUT HEADER COPY        (SENT)
C             LUN2             LUN FOR OUTPUT (0 = NO FILE OUT)  (SENT)
C             FILPAT,FILPAT2   FILE NAME PATTERNS                (SENT)
C             IMGNUM1,IMGNUM2  IMAGE NUMBERS                  (SENT/RET)
C             IRTFLG           ERROR (0 IS OK, -1 IS END STACK)  (RET.)
C--*********************************************************************
 
      SUBROUTINE NEXTFILES(NINDX1, NINDX2, INUMBR1,INUMBR2, 
     &                     FOUROK,LUNXM1,LUNXM2,
     &                     NGOT1,NGOT2,     MAXIM1,MAXIM2,   
     &                     LUN1,LUNCP,LUN2, FILPAT1,FILPAT2,
     &                     IMGNUM1,IMGNUM2,IRTFLG) 
 
      IMPLICIT NONE

      INTEGER           :: NINDX1,NINDX2
      INTEGER           :: INUMBR1(NGOT1),INUMBR2(NGOT2)
      LOGICAL           :: FOUROK
      INTEGER           :: LUNXM1,LUNXM2
      INTEGER           :: NGOT1,NGOT2
      INTEGER           :: MAXIM1,MAXIM2,LUN1,LUNCP,LUN2
      CHARACTER(LEN=*)  :: FILPAT1,FILPAT2
      INTEGER           :: IMGNUM1,IMGNUM2,IRTFLG

      INTEGER           :: NWANT1,NWANT2, it
      LOGICAL           :: SAYIT = .TRUE.
      LOGICAL           :: GOTAST1,GOTAST2
      

      NINDX1 = NINDX2 + 1
      NINDX2 = NINDX2 + 1

      !write(6,*) 'nextfiles0  : l1,l2:',lun1,lun2
      IF (LUN1 > 0) THEN  
C        OPEN NEXT INPUT FILE 
         GOTAST1 = (INDEX(FILPAT1,'*') > 0)

         !write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
!     &                              nindx1,ngot1,maxim1,imgnum1

         IF (IMGNUM1 == -1 .AND. LUNXM1 > 0 ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT1 = -1

         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST1 ) THEN
C           BARE STACK INPUT (NO LIST)
             IF (NINDX1 > NGOT1) THEN
C              FINISHED THE WHOLE STACK
               IRTFLG = -1
               RETURN
            ENDIF
            NWANT1 = NINDX1

         ELSEIF (MAXIM1 == -2  .OR.
     &           MAXIM1 == -1  .OR.
     &           MAXIM1  >    0 ) THEN
C           NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C              OVERUN INPUT LIST
               IRTFLG = -1
               RETURN
            ENDIF

C           OPEN NEXT INPUT FILE 
            NWANT1 = INUMBR1(NINDX1)

         ENDIF

         CALL GETOLDIMG(LUN1,LUNXM1,FILPAT1,NWANT1,SAYIT, 
     &                  FOUROK,IMGNUM1,IRTFLG)

         !write(6,'(a,8i5)')' Gotoldimg, lun1,nwant1,imgnum1: ',
!     &                                   lun1,nwant1,imgnum1

         IF (IRTFLG .LT. 0) RETURN    ! END OF WHOLE-STACK
         IF (IRTFLG .NE. 0) RETURN    ! ERROR

         IF (MAXIM1 > 0 .AND. .NOT. GOTAST1) THEN
C           INPUT FROM A BARE STACK 
            NINDX1 = IMGNUM1
            NINDX2 = IMGNUM1
         ENDIF
      ENDIF
           ! write(6,*) 'nextfiles1: l1,l2,irtflg:',lun1,lun2,irtflg

      IF (LUN2 > 0) THEN  
C        OPEN NEXT OUTPUT FILE 
         GOTAST2 = (INDEX(FILPAT2,'*') > 0)

         !write(6,'(a,8i5)')'  out: nindx2,ngot2,maxim2,imgnum2: ',
!     &                             nindx2,ngot2,maxim2,imgnum2

!            write(6,*) 'nextfiles2: l2,imgnum2,gotast2:',
!     &                              lun2,imgnum2,gotast2
         IF (IMGNUM2 == -1 .AND. LUNXM2 > 0  ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT2 = -1

         ELSEIF (MAXIM2 >= 0 .AND. .NOT. GOTAST2 ) THEN
C           BARE STACK OUTPUT (NO LIST)
            NWANT2 = NINDX2

            IF (LUN1 > 0) THEN
C              BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
               NWANT2 = IMGNUM1
            ENDIF

         ELSEIF (MAXIM2 == -2  .OR.
     &           MAXIM2 == -1  .OR.
     &           MAXIM2  >  0 ) THEN

C           NON-STACK IMAGE WITH/WITHOUT TEMPLATE LIST 
            IF (NINDX2 > NGOT2) THEN
C               OVERUN OUTPUT LIST
                !write(6,*) 'NINDX2 > NGOT2',NINDX2,NGOT2
                IRTFLG = -99
                RETURN
            ENDIF
C           OPEN NEXT OUTPUT FILE 
            NWANT2 = INUMBR2(NINDX2)
         ENDIF

         !write(6,*) ' nextfiles, nwant2,nindx2:',nwant2,nindx2
         !write(6,'(a,8i5)') 
!     &   ' Calling getnew,nwant2,imgnum2,maxim2:',nwant2,imgnum2,maxim2

         CALL GETNEWIMG(LUNCP,LUN2,LUNXM2,FILPAT2,NWANT2,
     &                  SAYIT,IMGNUM2,IRTFLG)

          !write(6,'(a,8i5)') ' Getnew,nwant2,imgnum2,maxim2,irtflg:',
!     &                                nwant2,imgnum2,maxim2,irtflg
         IF (IRTFLG .NE. 0) RETURN     ! ERROR

      ENDIF

      END


C++*********************************************************************
C
C NEXTFILE.F    NEW                              12/15/06 ARDEAN LEITH
C               OVERUN OUTPUT LIST = -99          1/15/12 ARDEAN LEITH
C
C **********************************************************************
C
C NEXTFILE  
C
C PURPOSE:  GETS NEXT FILE FOR A STACK ORIENTED OPERATION
C           STACKS MUST BE OPENED WITH OPFILES!!!
C
C PARAMETERS: NINDX1           LIST INDICES                   (SENT/RET)
C             INUMBR1          IMAGE NUMBER LISTS                (SENT)
C             FOUROK           FOURIER INPUT IS OK               (SENT)
C             LUNXM1           LUN FOR SELFILE INPUT             (SENT)
C             NGOT1            # OF IMAGES                       (SENT)
C             MAXIM1           MAXIM VALUES                      (SENT)
C             LUN1             LUN FOR I/0                       (SENT)
C             LUNCP            LUN FOR OUTPUT HEADER COPY        (SENT)
C             FILPAT1          FILE NAME PATTERN                 (SENT)
C             DISP             IMAGE EXISTANCE                   (SENT)
C             IMGNUM1          IMAGE NUMBER                   (SENT/RET)
C             IRTFLG           ERROR (0 IS OK, -1 IS END STACK)  (RET.)
C--*********************************************************************
 
      SUBROUTINE NEXTFILE(NINDX1,   INUMBR1, 
     &                    FOUROK,   LUNXM1,
     &                    NGOT1,    MAXIM1,   
     &                    LUN1,     LUNCP, 
     &                    FILPAT1,  DISP,
     &                    IMGNUM1,  IRTFLG) 
 
      IMPLICIT NONE

      LOGICAL           :: ISIN
      INTEGER           :: NINDX1 
      INTEGER           :: INUMBR1(NGOT1) 
      LOGICAL           :: FOUROK
      INTEGER           :: LUNXM1 
      INTEGER           :: NGOT1 
      INTEGER           :: MAXIM1, LUN1,LUNCP 
      CHARACTER(LEN=*)  :: FILPAT1
      INTEGER           :: IMGNUM1
      CHARACTER(LEN=1)  :: DISP
      INTEGER           :: IRTFLG

      INTEGER           :: NWANT1, it
      LOGICAL           :: SAYIT = .TRUE.
      LOGICAL           :: GOTAST
      

      NINDX1 = NINDX1 + 1
      GOTAST = (INDEX(FILPAT1,'*') > 0)

      IF (DISP == 'O' .OR. DISP == 'B' .OR. 
     &    DISP == 'Z' .OR. DISP == 'E') THEN 
 
C        OPEN INPUT FILE 
         !write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
c     &                              nindx1,ngot1,maxim1,imgnum1

         IF (IMGNUM1 == -1  .AND. LUNXM1 > 0 ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT1 = -1

         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
C           BARE STACK INPUT (NO LIST)
             IF (NINDX1 > NGOT1) THEN
C              FINISHED THE WHOLE STACK
               IRTFLG = -1
               RETURN
            ENDIF
            NWANT1 = NINDX1

         ELSEIF (MAXIM1 == -2  .OR.
     &           MAXIM1 == -1  .OR.
     &           MAXIM1  >    0 ) THEN
C           NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C              OVERUN INPUT LIST
               IRTFLG = -1
               RETURN
            ENDIF

C           OPEN NEXT INPUT FILE 
            NWANT1 = INUMBR1(NINDX1)

         ENDIF
         !write(6,*) ' call gotoldimg, nwant1:',nwant1,nindx1
 
         CALL GETOLDIMG(LUN1,LUNXM1,FILPAT1,NWANT1,SAYIT, 
     &                  FOUROK,IMGNUM1,IRTFLG)

         !write(6,'(a,8i5)')' Gotoldimg, ngot1,nwant1,imgnum1: ',
c     &                           ngot1,nwant1,imgnum1,irtflg,maxim1

         IF (IRTFLG .LT. 0) RETURN    ! END OF WHOLE-STACK
         IF (IRTFLG .NE. 0) RETURN    ! ERROR

         IF (MAXIM1 > 0 .AND. .NOT. GOTAST) THEN
C           BARE STACK 
            NINDX1 = IMGNUM1
         ENDIF

      ELSE   
C        OPEN NEXT OUTPUT FILE 
         !write(6,'(a,8i5)')'  out: nindx1,ngot1,maxim1,imgnum1: ',
c     &                            nindx1,ngot1,maxim1,imgnum1

         IF (IMGNUM1 == -1  .AND. LUNXM1 > 0 ) THEN
C           XMIPP SELFILE LISTED IMAGE
            NWANT1 = -1

         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
C           BARE STACK OUTPUT (NO LIST)
            NWANT1 = NINDX1

         ELSEIF (MAXIM1 == -2  .OR.
     &           MAXIM1 == -1  .OR.
     &           MAXIM1  >  0 ) THEN
C           NON STACKED IMAGE WITH/WITHOUT TEMPLATED LIST
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C               OVERUN OUTPUT LIST
                !write(6,*) 'NINDX1 > NGOT1',NINDX1,NGOT1
                IRTFLG = -99
                RETURN
            ENDIF
C           OPEN NEXT OUTPUT FILE 
            NWANT1 = INUMBR1(NINDX1)
         ENDIF

         !write(6,*) ' Nextfiles, nwant1,nindx1:',nwant1,nindx1
         !write(6,'(a,8i5)') 
c     &   ' calling Getnew,nwant1,imgnum1,maxim1:',nwant1,imgnum1,maxim1

         CALL GETNEWIMG(LUNCP,LUN1,LUNXM1,FILPAT1,NWANT1,
     &                  SAYIT,IMGNUM1,IRTFLG)

         !write(6,'(a,8i5)') ' Getnew,nwant1,imgnum1,maxim1,irtflg:',
!     &                              nwant1,imgnum1,maxim1,irtflg
         IF (IRTFLG .NE. 0) RETURN     ! ERROR

         IF (MAXIM1 > 0 .AND. .NOT. GOTAST) THEN
C           BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
            NINDX1 = IMGNUM1
         ENDIF
      ENDIF

      END


@


1.23
log
@comments
@
text
@d4 8
a11 5
C  OPFILES.F        NEW                         12/15/06  ARDEAN LEITH *   
C                   BAD NUMBRT() TRAP           05/21/09  ARDEAN LEITH * 
C                   ASKNAM, PROMPTEX            12/06/10  ARDEAN LEITH *
C                   NX...                       03/26/12  ARDEAN LEITH *
C                   COPY NON SPIDER INPUT       05/26/14  ARDEAN LEITH *
a71 2
C                     ~ (TILDE) IN FIRST CHAR. SAYS USE
C                       PROMPT INSTEAD OF INPUT
d177 2
a178 1
       IF (ASKNAM .AND. LOCAST > 0 .AND. ASKLIST) THEN
@


1.22
log
@==, RETURN FILENAME WITH ANY EXTENSION IF NOT SPIDER, use input prompt
@
text
@d47 16
a62 3
C        FILPAT     FILE NAME PATTERN                              (RET)
C        NLET       CHARS IN FILE NAME PATTERN                     (RET)
C        DISP       CHAR. FLAG FOR FILE EXISTENCE                 (SENT)
d66 1
a66 1
C                   STACK INDICATOR                                (RET)
d79 2
a80 1
C        ILIST      IMAGE NUMBER LIST                              (RET)
d84 2
a85 2
C        UNUSED     UNUSED                                           (?)
C        NTOT       # OF IMAGES IN IMAGE NUMBER LIST               (RET)
d90 2
a91 2
C        IRTFLG     ERROR FLAG (0 IS NORMAL)                       (RET)
C                     -1 GOTO PREVIOUS QUESTION
@


1.21
log
@comments
@
text
@d8 1
d13 1
a13 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d56 9
d105 1
a105 1
       CHARACTER (LEN=1)         :: CDUM,NULL 
d110 1
d112 1
a112 1
       integer                   :: lunop
d114 2
a115 4
       LOGICAL                   :: isopen
       CHARACTER (LEN=MAXNAM)    :: filnamt 

       NULL = CHAR(0)
d119 1
a119 1
       IF (ASKNAM .AND. PROMPT .EQ. NULL) THEN
d122 3
a124 3
          IF (DISP .EQ. 'N' .OR. 
     &        DISP .EQ. 'I' .OR.
     &        DISP .EQ. 'U') THEN
d137 3
a139 2
        ELSEIF (ASKNAM) THEN
C         ASK FOR FILE NAME       
d142 1
d148 1
a148 1

d202 1
a202 1
          IF (IMGWANT < 0 .OR. IMGWANT .GT. 10000000) THEN
d209 1
a209 1
          IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d225 1
a225 1
       ELSEIF (LOCAT .EQ. NLET) THEN
d228 1
a228 1
          IF (DISP .EQ. 'I') THEN
d260 3
a262 3
          IF (DISP .EQ. 'U' .OR. 
     &        DISP .EQ. 'I' .OR.
     &        DISP .EQ. 'N') THEN
d280 1
a280 1
                IF (NTOT .GT. NIMAXP) THEN
d295 1
a295 1
          IF (IMGNUM < 0 .OR. IMGNUM .GT. 10000000) THEN
d315 2
a316 1

d323 3
a325 2
             IF (NTOT > 0) THEN
                !write(6,*)' From openxmsel: ',ntot,':',filnam(:nlet) 
d336 1
d344 4
a347 1
     & 		       MAXIM,'INPUT',FOUROK,IRTFLG) 
d446 1
a446 1
        ELSEIF (LOCAST > 0 .AND. LOCAT .LE. 0) THEN 
d488 1
a488 1
           IF (IRTFLG .EQ. 0) THEN
d492 1
a492 1
           IF (IRTFLG .NE. 0 .OR. IMUSED .EQ. 0) THEN
d505 1
a505 1
        ELSEIF (LOCAT .EQ. NLET) THEN
d519 1
a519 1
              IF (IRTFLG .GT. 0) THEN
d528 1
a528 1
              IF (IMUSED .GT. 0) EXIT     ! FOUND NEXT IMAGE
d627 1
a627 1
        ELSEIF (LOCAT .LE. 0 .AND. LOCAST > 1) THEN
d661 1
a661 1
!              IF (NWANT .LE. 0) NWANT = 1
d671 1
a671 1
           IF (NWANT .GT. MAXIM) THEN
d686 1
a686 1
           IF (NWANT .GT. MAXIM .OR. ISTACK .GT. 2) THEN
d803 2
a804 2
         ELSEIF (MAXIM1 .EQ. -2  .OR.
     &           MAXIM1 .EQ. -1  .OR.
d858 3
a860 3
         ELSEIF (MAXIM2 .EQ. -2  .OR.
     &           MAXIM2 .EQ. -1  .OR.
     &           MAXIM2  >    0 ) THEN
d944 2
a945 2
      IF (DISP .EQ. 'O' .OR. DISP .EQ. 'B' .OR. 
     &    DISP .EQ. 'Z' .OR. DISP .EQ. 'E') THEN 
d964 2
a965 2
         ELSEIF (MAXIM1 .EQ. -2  .OR.
     &           MAXIM1 .EQ. -1  .OR.
d1008 3
a1010 3
         ELSEIF (MAXIM1 .EQ. -2  .OR.
     &           MAXIM1 .EQ. -1  .OR.
     &           MAXIM1  >    0 ) THEN
@


1.20
log
@IMGNUM1,IMGNUM2  IMAGE NUMBERS                  (SENT/RET)
IF (IMGNUM1 == -1 .AND. LUNXM1 > 0
@
text
@d12 1
a12 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d30 2
d36 3
a38 3
C PURPOSE: SOLICITS FILE NAME(S) AND OPENS FILE(S)
C          SUPPORT ROUTINE FOR CONVERTING OPERATIONS TO 
C          WORK ON WHOLE STACK OR WITH SELECTION DOC FILE.
d881 1
a881 1
C PURPOSE:  GETS NEXT FILES FOR A STACK ORIENTED OPERATION
@


1.19
log
@if already opened msg and irtflg changed
@
text
@d734 1
a734 1
C             IMGNUM1,IMGNUM2  IMAGE NUMBERS                     (RET.)
d771 1
a771 1
         IF (IMGNUM1 .EQ. -1  ) THEN
d826 1
a826 1
         IF (IMGNUM2 .EQ. -1  ) THEN
d892 1
a892 1
C             IMGNUM1          IMAGE NUMBER                      (RET.)
d932 1
a932 1
         IF (IMGNUM1 .EQ. -1  ) THEN
d981 1
a981 1
         IF (IMGNUM1 .EQ. -1  ) THEN
@


1.18
log
@INQUIRE(FILE=FILNAMT,OPENED=ISOPEN,NUMBER=LUNOP)
for doubly opened files trap
@
text
@d170 1
a170 1
             MESG = 'FILE: ' // FILNAMT(1:NLET) //
d174 3
a176 2
                CALL ERRT(102,MESG(1:LENE),LUNOP) 
                IRTFLG = -1
d227 1
a227 1
             MESG = 'FILE: ' // FILNAMT(1:NLET) //
d231 3
a233 2
                CALL ERRT(102,MESG(1:LENE),LUNOP) 
                IRTFLG = -1
d846 1
d996 1
@


1.17
log
@NTOT       = 1 for single images[D[D[
@
text
@d99 5
d164 16
a179 1
          MAXIM  = 1               
d222 14
d305 1
a305 1
             !write(6,*)' Filnam from openxmsel: ',filnam(:nlet) 
d308 1
d761 1
d813 1
d822 2
@


1.16
log
@NX...
@
text
@d32 1
a32 1
C          INUMBRT,NIMAXT, NTOT,IMGNUM, IRTFLG)
d54 1
a54 1
C        INUMBRT    IMAGE NUMBER LIST                              (RET)
d60 1
d74 1
a74 1
     &                    FOUROK,INUMBRT,NIMAXT, 
d88 1
a88 1
       INTEGER                   :: INUMBRT(*)
d138 1
a138 1
       !write(6,*)' inumbrt:',inumbrt(1)
d147 1
a147 1
          CALL FILELIST(.FALSE.,LUNDOC,CDUM,NDUM,INUMBRT,NIMAXP,
d167 1
a167 1
          IMGWANT  = INUMBRT(1)
d227 1
a227 1
C            CREATE IMAGE NUMBER LIST IN: INUMBRT
d235 1
a235 1
                INUMBRT(NTOT) = I
d245 1
a245 1
          IMGNUM = INUMBRT(1)
d261 1
a261 1
!     &              '  for:',NTOT,' images.'
d294 1
a294 1
          NTOT       = 1
@


1.15
log
@IRTFLG = -99 if no nextfile for output
@
text
@d7 1
d12 1
a12 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d31 1
a31 1
C          ITYPE,NSAM,NROW,NSLICE,MAXIM, PROMPT,FOUROK,
d34 3
a36 3
C PURPOSE:  SOLICITS FILE NAME(S) AND OPENS FILE(S)
C           SUPPORT ROUTINE FOR CONVERTING OPERATIONS TO 
C           WORK ON WHOLE STACK OR WITH SELECTION DOC FILE.
d48 1
a48 2
C        NSAM,NROW  IMAGE SIZE                             (SENT OR RET)
C        NSLICE     IMAGE Z SIZE                           (SENT OR RET)
d71 1
a71 1
     &                    ITYPE,NSAM,NROW,NSLICE,MAXIM,
d84 1
a84 1
       INTEGER                   :: ITYPE,NSAM,NROW,NSLICE,MAXIM
d160 1
a160 1
     &                 ITYPE,NSAM,NROW,NSLICE, 
d202 1
a202 1
     &                 ITYPE,NSAM,NROW,NSLICE, 
d255 1
a255 1
     &                 ITYPE,NSAM,NROW,NSLICE, 
d276 1
a276 1
     &                       ITYPE,NSAM,NROW,NSLICE, 
d289 1
a289 1
     &                 ITYPE,NSAM,NROW,NSLICE, 
d363 1
a363 1
           CALL LUNGETSIZE(LUN,NSAM1,NROW1,NSLICE1,IRTFLG)
d374 1
a374 1
     &                 NSAM,NROW,NSLICE, 
d379 2
a380 2
           CALL SIZCHK(NULL,NSAM1,NROW1,NSLICE1,ITYPE1,
     &                      NSAM ,NROW, NSLICE, ITYPE, IRTFLG)
d392 1
a392 1
           CALL LUNGETSIZE(LUN,NSAM1,NROW1,NSLICE1,IRTFLG)
d401 1
a401 1
     &                 NSAM,NROW,NSLICE, 
d406 2
a407 2
           CALL SIZCHK(NULL,NSAM1,NROW1,NSLICE1,ITYPE1,
     &                      NSAM ,NROW, NSLICE, ITYPE, IRTFLG)
d420 2
a421 2
           CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLG)
           CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)
d423 1
a423 1
              !write(6,*) ' lunredhed,lun,nsam,irtflg:',lun,nsam,irtflg
d430 1
a430 1
           CALL LUNREDHED(LUN,NSAM,NWANT,.FALSE.,IRTFLG)
d453 1
a453 1
           CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLG)
d458 1
a458 1
              CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)
d461 1
a461 1
              CALL LUNREDHED(LUN,NSAM,NGOT,.FALSE.,IRTFLG)
d485 1
a485 1
           !write(6,*)' ngot,nsam:',ngot,nsam,lun,imused,irtflg
d489 1
a489 1
        CALL LUNSETIMGOFF(LUN,NGOT,NSAM,IRTFLG)
d550 1
a550 1
           CALL LUNGETSIZE(LUN,NSAM1,NROW1,NSLICE1,IRTFLG)
d561 1
a561 1
     &                 NSAM1,NROW1,NSLICE1, 
d573 1
a573 1
C          NEW IMAGE, NEEDS TO KNOW: ITYPE,NSAM,NROW,NSLICE!
d575 1
a575 1
           CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLG)
d586 1
a586 1
     &                 NSAM,NROW,NSLICE, 
d608 2
a609 2
           CALL LUNGETSIZE(LUN,NSAM,NROW,NSLICE,IRTFLG)
           CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)
d625 1
a625 1
              CALL LUNWRTINDX(LUN,NWANT,NSAM,IRTFLGT)
d631 1
a631 1
              CALL LUNWRTHED(LUN,NSAM,0,IRTFLGT)
d652 1
a652 1
           CALL LUNWRTHED(LUN,NSAM,NWANT,IRTFLG)
d655 1
a655 1
           CALL LUNSETIMGOFF(LUN,NWANT,NSAM,IRTFLGT)
@


1.14
log
@DO I= 1,MAXIM for bare stack list bug fix
@
text
@d673 2
a674 1
C  NEXTFILES.F            NEW                     12/15/06 ARDEAN LEITH
d761 1
a761 1
          CALL GETOLDIMG(LUN1,LUNXM1,FILPAT1,NWANT1,SAYIT, 
d764 1
a764 1
          !write(6,'(a,8i5)')' Gotoldimg, lun1,nwant1,imgnum1: ',
d804 1
a804 1
                IRTFLG = -1
d829 3
a831 1
C  NEXTFILE.F            NEW                     12/15/06 ARDEAN LEITH
d953 1
a953 1
                IRTFLG = -1
@


1.13
log
@ASKLIST
@
text
@d228 1
a228 1
             DO I= IMGNUM,MAXIM
@


1.12
log
@OPEN NEW BARE INDEXED STACK bug
@
text
@d11 1
a11 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d57 1
d90 2
a91 1
       LOGICAL                   :: SAYIT
d135 1
d137 1
d140 4
a143 1
       IF (ASKNAM .AND. LOCAST .GT. 0) THEN
d146 1
a146 1
          CALL FILELIST(.FALSE.,LUNDOC,CDUM,NDUM,INUMBRT,NIMAXT,
d149 2
d154 1
a154 1
C         STACKED FILE TEMPLATE: STK@@**** -------------- _9@@* or STK@@**
d230 1
a230 1
                IF (NTOT .GT. NIMAXT) THEN
d238 1
a238 2
         !write(6,*)' Opened bare stack: ',FILPAT(1:NLET),
c    &              ' at image: ',IMGNUM
d260 1
a260 1
c    &              '  for: ',NTOT,'  images.'
a356 1

a357 1

d760 1
a760 3
         !write(6,*) ' call gotoldimg, nwant1:',nwant1
 
         CALL GETOLDIMG(LUN1,LUNXM1,FILPAT1,NWANT1,SAYIT, 
d763 2
a764 2
         !write(6,'(a,8i5)') ' Gotoldimg, lun1,nwant1,imgnum1: ',
c     &                                   lun1,nwant1,imgnum1
d781 1
a781 1
c     &                             nindx2,ngot2,maxim2,imgnum2
a807 1

d812 1
a812 1
c     &   ' calling Getnew,nwant2,imgnum2,maxim2:',nwant2,imgnum2,maxim2
d818 1
a818 1
c     &                              nwant2,imgnum2,maxim2,irtflg
d914 1
a914 1
        !write(6,*) ' call gotoldimg, nwant1:',nwant1,nindx1
d957 1
a957 1
         !write(6,*) ' nextfiles, nwant1,nindx1:',nwant1,nindx1
d965 1
a965 1
c     &                              nwant1,imgnum1,maxim1,irtflg
@


1.11
log
@NWANT2 = IMGNUM1, IMGNUMIN
@
text
@d49 2
a50 1
C        MAXIM      STACK INDICATOR                                (RET)
d82 1
a82 1
       CHARACTER(LEN=*)          :: DISP 
d94 1
d103 3
a105 1
          IF (DISP .EQ. 'N' .OR. DISP .EQ. 'U') THEN
d134 1
d145 1
a145 1
C         STACKED FILE TEMPLATE: STK@@**** ---------------------- STK@@**
d149 1
a149 1
          MAXIM  = 1  
d182 11
a192 3
C         WHOLE BARESTACK:  STK@@  ------------------------------- STK@@
          MAXIM = 1
          CALL OPFILEC(LUNCP,.FALSE.,FILPAT,LUNIMG,DISP,
d201 3
a203 1
          IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d229 1
a229 1
c         write(6,*)' Opened bare stack: ',FILPAT(1:NLET),
d251 1
a251 1
c         write(6,*)' Opened templated file: ',FILPAT(1:NLET),
d273 1
a273 1
c               write(6,*)' Opened selfile image: ',filnam(1:nlet) 
d288 1
a288 1
c         write(6,*)' Opened simple file: ',FILPAT(1:nlet) 
d341 1
a341 1
        INTEGER                :: NLET
d348 2
a349 1
        !write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d352 1
d377 1
a377 1
c          write(6,*)' Opened old xmipp selfile file: ',filnam(1:nlet)
d383 1
a383 1
        ELSEIF (LOCAST > 0 .AND. LOCAT .LE. 0) THEN
d404 1
a404 1
c          write(6,*)' Opened old templated file: ',filnam(1:nlet),maxim
d411 1
a411 1
C          TEMPLATED STACKED IMAGE ----------------------------- STK@@***
d417 1
a417 1
              write(6,*) ' lunredhed,lun,nsam,irtflg:',lun,nsam,irtflg
d440 1
a440 1
c          write(6,*)' Opened old templated stacked file: ',FILNAM(:NLET)
d443 1
a443 1
C          WHOLE IMAGE STACK -------------------------------- STK@@
a446 1
C          LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
a447 1
           CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)
d451 3
a470 3
C             MUST LOAD OVERALL HEADER FIRST FOR LUNREDHED (MAY BE MT NOW!)
              CALL LUNREDHED(LUN,NSAM,0,.FALSE.,IRTFLG)

a473 1
           !8dec CALL LUNSETIMNUM(LUN,FILNAM,NWANT,'O',IRTFLG)
d478 2
a479 1
c          write(6,*)' Opened old bare stacked file: ',FILNAM(1:NLET)
d538 1
a538 1
c       write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d559 1
a559 1
c           write(6,*)' Opened new Xmipp selfile file: ',filnam(1:nlet)
d584 1
a584 1
c          write(6,*)' Opened new templated file: ',FILNAM(1:NLET)
d656 1
a656 1
c          write(6,*)' Opened new stacked file: ',FILNAM(1:NLET)
d722 1
a722 1
!         write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
d759 1
a759 1
c         write(6,'(a,8i5)') ' Gotoldimg, lun1,nwant1,imgnum1: ',
d776 1
a776 1
c        write(6,'(a,8i5)')'  out: nindx2,ngot2,maxim2,imgnum2: ',
d807 2
a808 2
C        write(6,*) ' nextfiles, nwant2,nindx2:',nwant2,nindx2
c        write(6,'(a,8i5)') 
d814 1
a814 1
c         write(6,'(a,8i5)') ' Getnew,nwant2,imgnum2,maxim2,irtflg:',
d880 1
a880 1
c        write(6,'(a,8i5)') '  in:  nindx1,ngot1,maxim1,imgnum1: ',
d911 1
a911 1
c        write(6,*) ' call gotoldimg, nwant1:',nwant1,nindx1
d916 1
a916 1
c        write(6,'(a,8i5)')' Gotoldimg, ngot1,nwant1,imgnum1: ',
d929 1
a929 1
c        write(6,'(a,8i5)')'  out: nindx1,ngot1,maxim1,imgnum1: ',
d954 2
a955 2
C        write(6,*) ' nextfiles, nwant1,nindx1:',nwant1,nindx1
c        write(6,'(a,8i5)') 
d961 1
a961 1
c        write(6,'(a,8i5)') ' Getnew,nwant1,imgnum1,maxim1,irtflg:',
d972 1
@


1.10
log
@removed debug messages
@
text
@d58 3
a60 2
C        IMGNUM     IMAGE NUMBER THAT IS CURRENTLY OPEN            (RET)
C                     <0 IS SELFILE IN USE 
d124 2
a125 1
       IMGNUM = 0 
d127 2
a128 2
       LOCAT  = INDEX(FILPAT(1:NLET),'@@')   
       LOCAST = INDEX(FILPAT(1:NLET),'*')
d180 2
a181 2
     &                     ITYPE,NSAM,NROW,NSLICE, 
     & 		           MAXIM,'INPUT',FOUROK,IRTFLG) 
d184 2
a185 2
C         OPEN FIRST FILE IN STACK 
          IMGNUMT = 1
d187 1
d189 4
a192 2
C            NEW BARE STACK
             CALL GETNEWIMG(LUNCP,LUNIMG,LUNDOC,FILPAT,IMGNUMT,
d195 1
d197 3
a199 3
C            EXISTING BARE STACK
	     CALL GETOLDIMG(LUNIMG,LUNDOC,FILPAT, IMGNUMT,SAYIT,
     &                      FOUROK,IMGNUM,IRTFLG)
d207 1
a207 1
                   CALL ERRT(102,'INUMBRT LIST OVERFLOW AT IMAGE',NTOT)
d697 1
a697 1
      LOGICAL           :: GOTAST
d705 1
a705 1
         GOTAST = (INDEX(FILPAT1,'*') > 0)
d714 1
a714 1
         ELSEIF (MAXIM1 >= 0 .AND. .NOT. GOTAST ) THEN
d750 2
a751 2
         IF (MAXIM1 > 0 .AND. .NOT. GOTAST) THEN
C           BARE STACK 
d759 1
a759 1
         GOTAST = (INDEX(FILPAT2,'*') > 0)
d768 1
a768 1
         ELSEIF (MAXIM2 >= 0 .AND. .NOT. GOTAST ) THEN
d772 5
d799 1
a799 1
c        write(6,'(a,8i5)') ' Getnew,nwant2,imgnum2,maxim2,irtflg:',
a802 4
         IF (MAXIM2 > 0 .AND. .NOT. GOTAST) THEN
C           BARE STACK, OUTPUT IMAGE HAS SAME # AS INPUT ALWAYS
            NINDX2 = IMGNUM2
         ENDIF
@


1.9
log
@MAXIM2 .EQ. -1 bug in nextfiles, nextfile
@
text
@d354 1
a354 1
         write(6,*)' Opened old xmipp selfile file: ',filnam(1:nlet)
d381 1
a381 1
         write(6,*)' Opened old templated file: ',filnam(1:nlet),maxim
d417 1
a417 1
         write(6,*)' Opened old templated stacked file: ',FILNAM(:NLET)
d458 1
a458 1
          write(6,*)' Opened old bare stacked file: ',FILNAM(1:NLET)
d538 1
a538 1
           write(6,*)' Opened new Xmipp selfile file: ',filnam(1:nlet)
d563 1
a563 1
           write(6,*)' Opened new templated file: ',FILNAM(1:NLET)
d635 1
a635 1
          write(6,*)' Opened new stacked file: ',FILNAM(1:NLET)
d894 2
a895 2
        write(6,'(a,8i5)')' Gotoldimg, ngot1,nwant1,imgnum1: ',
     &                           ngot1,nwant1,imgnum1,irtflg,maxim1
@


1.8
log
@typo
@
text
@d717 3
a719 1
         ELSEIF (MAXIM1 .EQ. -2 ) THEN
d721 1
a730 9
         ELSEIF (MAXIM1 > 0) THEN
C           STACKED IMAGE WITH/WITHOUT LIST
            IF (NINDX1 > NGOT1) THEN
C               OVERUN INPUT LIST
                IRTFLG = -1
                RETURN
            ENDIF
C           OPEN NEXT INPUT FILE 
            NWANT1 = INUMBR1(NINDX1)
d766 4
a769 1
         ELSEIF (MAXIM2 .EQ. -2 ) THEN
a778 11
         ELSEIF (MAXIM2 > 0) THEN
C           STACKED IMAGE WITH/WITHOUT TEMPLATE LIST 

            IF (NINDX2 > NGOT2) THEN
C               OVERUN OUTPUT LIST
                IRTFLG = -1
                RETURN
            ENDIF

C           OPEN NEXT OUTPUT FILE 
            NWANT2 = INUMBR2(NINDX2)
d875 1
d887 1
d894 2
a895 2
c        write(6,'(a,8i5)')' Gotoldimg, lun1,nwant1,imgnum1: ',
c     &                                   lun1,nwant1,imgnum1,irtflg
d918 3
a920 2
         ELSEIF (MAXIM1 .EQ. -2   .OR.
     &           MAXIM1   >   0 ) THEN
@


1.7
log
@refactored
@
text
@d907 1
a907 1
 c     &                                   lun1,nwant1,imgnum1,irtflg
@


1.6
log
@GPL_2010
@
text
@d3 4
a6 4
C 
C  OPFILES.F        NEW                    ARDEAN LEITH        12/15/06 
C                   BAD NUMBRT() TRAP      ARDEAN LEITH        05/21/09
C
d29 1
a29 1
C  OPFILES(LUNCP,LUNIMG,LUNDOC, FILPAT,NLET, DISP,
d40 6
a45 4
C        LUNDOC     UNIT TO OPEN LIST DOC FILE ON                 (SENT)
C        FILPAT     FILE NAME PATTERN                             (SENT)
C        NLET       CHARS IN FILE NAME PATTERN                    (SENT)
C        DISP       CHARACTER CONTAINING  DISPOSITION             (SENT)
d49 1
a49 1
C        MAXIM      STACK INDICATOR                           (SENT/RET)
d51 1
d53 9
a61 7
C        INUMBRT    IMAGE NUMBER LIST                             (RET)
C                     NOT USED IF SINGLE IMAGE ONLY
C        NIMAXT     MAX LENGTH OF IMAGE NUMBER LIST              (SENT)
C        NTOT       NUMBER OF IMAGES IN IMAGE NUMBER LIST         (RET)
C        IMGNUM     IMAGE CURRENTLY OPENED                        (RET)
C        IRTFLG     ERROR FLAG (0 IS NORMAL)                      (RET)
C                        -1 GOTO PREVIOUS QUESTION
d65 3
a67 2
 
       SUBROUTINE OPFILES(LUNCP,LUNIMG,LUNDOC, FILPAT,NLET, DISP,
d70 2
a71 1
     &                    FOUROK,INUMBRT,NIMAXT, NTOT,IMGNUM, IRTFLG) 
d76 4
a79 2
       INTEGER                   :: INUMBRT(*)
       CHARACTER(LEN=*)          :: FILPAT,PROMPT 
d81 2
d84 3
d91 1
d97 26
a122 4
       CALL FILERD(FILPAT,NLET,NULL,PROMPT,IRTFLG)
       IF (IRTFLG .NE. 0) RETURN 
   
       NTOT   = 0 
d127 1
a127 1
C      write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d129 1
a129 1
       IF (LOCAST .GT. 0) THEN
d131 1
d137 1
a137 1
       IF (LOCAT .GT. 0 .AND. LOCAST .GT. LOCAT) THEN
d142 1
a142 1
          MAXIM = 1  
d151 1
a151 1
          IF (IMGWANT .LE. 0 .OR. IMGWANT .GT. 10000000) THEN
d153 1
d159 1
a159 1
             CALL GETNEWIMG(LUNCP,LUNIMG,FILPAT,IMGWANT,
d162 2
a163 2
	     CALL GETOLDIMG(LUNIMG,FILPAT, IMGWANT,
     &                      SAYIT,IMGNUM,IRTFLG)
d165 1
d167 2
a168 1
          IF (IRTFLG .NE. 0) GOTO 9000
d170 3
a172 2
c          write(6,*)'Opened templated stack: ',FILPAT(1:nlet),
c     &           ' at image: ',IMGNUM, '  for: ',NTOT,'  images.'
d186 2
a187 2
C            NEW STACKED FILE
             CALL GETNEWIMG(LUNCP,LUNIMG,FILPAT,IMGNUMT,
d191 3
a193 2
	     CALL GETOLDIMG(LUNIMG,FILPAT, IMGNUMT,
     &                      SAYIT,IMGNUM,IRTFLG)
d208 1
a208 1
c         write(6,*)'Opened bare stack: ',FILPAT(1:NLET),
d211 1
a211 1
       ELSEIF (LOCAST .GT. 0) THEN
d216 1
a216 1
          IF (IMGNUM .LE. 0 .OR. IMGNUM .GT. 10000000) THEN
d218 1
d230 1
a230 1
c         write(6,*)'Opened templated file: ',FILPAT(1:NLET),
d235 1
d237 21
a257 1
C         OPEN THE FILE
d267 1
a267 1
c         write(6,*)'Opened simple file: ',FILPAT(1:nlet) 
d281 1
a281 1
C    GETOLDIMG(LUN,FILPAT,NWANT, SAYIT,NGOT,IRTFLG)
d287 2
a288 1
C        LUN        LOGICAL UNIT NUMBER FOR FILNAM.               (SENT)
d290 3
a292 2
C        NWANT      IMAGE NUMBER WANTED                           (SENT) 
C        SAYIT      SAY FILE OPENIN INFO.                         (SENT)
d303 2
a304 1
	SUBROUTINE GETOLDIMG(LUN,FILPAT,NWANT, SAYIT,NGOT,IRTFLG)
d308 2
d311 1
d313 3
d318 1
a318 2
        CHARACTER(LEN=1)       :: DSP
        LOGICAL                :: FOUROK
d320 1
a320 1
        FOUROK = .TRUE.
d323 1
a325 1
c       write(6,*)' locast,locat,nlet:',locast,locat,nlet,filpat(1:nlet)
d327 34
a360 1
        IF (LOCAST .GT. 0 .AND. LOCAT .LE. 0) THEN
d363 2
d376 6
a381 1
c          write(6,*)'Opened old templated file: ',FILNAM(1:NLET)
a385 1
        ENDIF
d387 1
a387 1
        IF (LOCAT .GT. 0 .AND. LOCAST .GT. 0 .AND.LOCAT .LT. LOCAST)THEN
d393 6
d417 1
a417 1
c          write(6,*)'Opened old templated stacked file: ',FILNAM(:NLET)
a420 1

d441 1
a441 1
              IF (IMUSED .GT. 0) EXIT
d446 4
d453 3
a455 1
           CALL LUNSETIMNUM(LUN,FILNAM,NWANT,'O',IRTFLG)
d458 1
a458 1
c          write(6,*)'Opened old bare stacked file: ',FILNAM(1:NLET)
d470 1
d476 1
a476 1
C    GETNEWIMG(LUNCP,LUN,FILPAT,NWANTT, SAYIT,NGOT,IRTFLG)
d482 3
a484 2
C        LUNCP      LOGICAL UNIT NUMBER FOR HEADER TXT COPY       (SENT)
C        LUN        LOGICAL UNIT NUMBER FOR FILNAM.               (SENT)
d487 1
a487 1
C        SAYIT      SAY FILE OPENIN INFO.                         (SENT)
d496 1
a496 1
	SUBROUTINE GETNEWIMG(LUNCP,LUN,FILPAT,NWANTT, 
d501 1
d503 1
d505 2
d519 25
a543 1
        IF (LOCAT .LE. 0 .AND. LOCAST .GT. 0) THEN
d563 1
a563 1
c          write(6,*)'Opened new templated file: ',FILNAM(1:NLET)
d569 1
a569 1
        ELSEIF (LOCAT .GT. 0) THEN
d573 6
a578 6
           IF (ISBARE) THEN
C             WANT NEXT IMAGE IN STACK, GET CURRENT FILE NUMBER 
              CALL LUNGETINUSE(LUN,NWANT,IRTFLG)
              NWANT = NWANT + 1
              IF (NWANT .LE. 0) NWANT = 1
           ENDIF
d583 1
a583 1

d596 1
a596 1
          IF (ISTACK .LT. 0) THEN
d605 1
d634 2
a635 1
c          write(6,*)'Opened new stacked file: ',FILNAM(1:NLET)
d649 5
a653 2
C NEXTFILES(NWANT,INUMBR,INUMBROUT, LUNIN,LUNCP,LUNOUT,
C           FILPATIN,FILPATOUT,IMGNUM,IMGNUMOUT,IRTFLG)
d658 12
a669 11
C PARAMETERS: NWANT        LIST INDEX                         (SENT)
C             INUMBR       INPUT IMAGE NUMBER LIST            (SENT)
C             INUMBROUT    OUTPUT IMAGE NUMBER LIST           (SENT)
C             LUNIN        LUN FOR OUTPUT (0 IS NO FILE IN)   (SENT)
C             LUNCP        LUN FOR OUTPUT HEADER COPY         (SENT)
C             LUNOUT       LUN FOR OUTPUT (0 IS NO FILE OUT)  (SENT)
C             FILPATIN     INPUT FILE PATTERN                 (SENT)
C             FILPATOUT    OUTPUT  FILE PATTERN               (SENT)
C             IMGNUM       INPUT IMAGE                        (SENT/RET.)
C             IMGNUMOUT    LUN FOR OUTPUT (0 IS NO FILE OUT)  (SENT/RET.)
C             IRTFLG       ERROR (0 IS OK, -1 IS END STACK)   (RET.)
d672 5
a676 4
      SUBROUTINE NEXTFILES(NWANT, INUMBRT,INUMBROUT,   
     &                     LUNIN,LUNCP,LUNOUT,
     &                     FILPATIN,FILPATOUT,
     &                     IMGNUM,IMGNUMOUT,IRTFLG) 
d678 1
a678 3
      INTEGER           :: INUMBRT(*),INUMBROUT(*)
      CHARACTER(LEN=*)  :: FILPATIN,FILPATOUT
      LOGICAL           :: SAYIT
d680 13
a692 1
      SAYIT = .TRUE.
d694 2
a695 1
      NWANT   = NWANT + 1
d697 1
a697 1
      IF (LUNIN .GT. 0) THEN  
d699 48
a746 3
         IMGNUMT = INUMBRT(NWANT)
         CALL GETOLDIMG(LUNIN,FILPATIN, IMGNUMT, 
     &                  SAYIT,IMGNUM,IRTFLG)
d749 6
d757 1
a757 1
      IF (LUNOUT .GT. 0) THEN  
d759 1
a759 1
         IMGNUMOUTT = INUMBROUT(NWANT) ! NONSENSE IF WHOLE STACK
d761 49
a809 3
         CALL GETNEWIMG(LUNCP,LUNOUT,FILPATOUT,IMGNUMOUTT,
     &                  SAYIT,IMGNUMOUT,IRTFLG)
         IF (IRTFLG .NE. 0) RETURN    ! ERROR
d815 146
@


1.5
log
@closed lun in getnewimg bug
@
text
@d8 4
a11 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.,                         *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 1
C=* along with this program. If not, see <http://www.gnu.org/licenses> *                                                                    *
@


1.4
log
@ bad data trps
@
text
@d6 1
d8 5
a12 5
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d14 1
a14 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d19 1
a19 1
C=* This program is distributed in the hope that it will be useful,    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d257 1
a257 1
           CLOSE(LUN)
d403 2
a404 1
           MAXIM = 0  
@


1.3
log
@lunsetisbare false
@
text
@d5 1
d8 1
a8 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
a101 1

d112 1
d115 7
a121 2
          IMGNUM  = INUMBRT(1)
          SAYIT   = .TRUE.
d123 1
a123 1
             CALL GETNEWIMG(LUNCP,LUNIMG,FILPAT,IMGNUM,
d126 1
a126 1
	     CALL GETOLDIMG(LUNIMG,FILPAT, IMGNUM,
d129 1
a130 1
          CALL LUNSETISBARE(LUNIMG,.FALSE.,IRTFLG)
d132 2
a133 2
c         write(6,*)'Opened templated stack: ',FILPAT(1:nlet),
c    &           ' at image: ',IMGNUM, '  for: ',NTOT,'  images.'
d176 4
d361 1
a361 1
C        LUNCP      LOGICAL UNIT NUMBER FOR HEADER TXT COPY      (SENT)
@


1.2
log
@put in getnextfiles
@
text
@d124 1
@


1.1
log
@for stacked series
@
text
@d480 58
@

