head	1.36;
access;
symbols
	pre_mrcs:1.36
	healthdept_2018:1.36
	pre_getangas:1.26
	GPL2010:1.26
	pre_GPL2010:1.25
	pre_var_equation:1.25
	pre_fftwrings:1.25
	pre_opfiles:1.23
	src:1.23
	best-code:1.23
	named-reg:1.23
	x-named-regs:1.22
	x:1.22
	v13-00:1.21
	pre_GPL:1.20
	prec_CA:1.18
	noindx:1.18
	Bproc:1.11
	oct21:1.7
	last77:1.6;
locks; strict;
comment	@c @;


1.36
date	2018.10.03.14.34.06;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2015.07.27.14.32.30;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2014.07.28.16.03.34;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.14.18.57.01;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.08.16.47.56;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.28.18.26.40;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.17.12.40.33;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.15.17.42.54;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.03.18.27.16;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2012.05.23.14.39.55;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.24.13.25.37;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.30.16.20.44;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.22.20.25.53;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.12.15.27.32;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.15.21.50.55;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.17.21.00.07;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.06.14.28.33;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.02.20.22.38;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.12.13.42.42;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.12.13.30.28;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.13.20.28.03;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.19.15.55.54;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.26.21.16.30;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.08.20.21.21;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.05.20.48.48;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.08.18.16.10;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	99.12.28.17.24.18;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	99.12.27.19.03.56;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	99.12.27.18.39.06;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	99.09.15.14.55.32;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	98.03.05.16.33.42;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	97.12.04.15.46.16;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	97.11.19.16.47.01;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	97.10.15.17.51.36;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	97.10.14.15.24.59;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	97.10.06.20.43.36;	author pawel;	state Exp;
branches;
next	;


desc
@@


1.36
log
@email_health_dept
@
text
@
C++*********************************************************************
C
C    FILNAMSUB.F                             NEW  JUL 1997 ArDean Leith
C                  CHARINSIDE PARAMETERS CHANGED  JAN 2001 ArDean Leith
C                  SGI LEAK ON INTERNAL FMT       AUG 2002 ArDean Leith
C                  BETTER ERROR MSG               SEP 2002 ArDean Leith
C                  ADDED {%f3.4%x11} SUPPORT      JAN 2004 ArDean Leith
C                  ***[] SUPPORT FROM SUBSYM      DEC 2005 ArDean Leith
C                  ***/xxx***{v1][v2] SUPPORT     JAN 2007 ArDean Leith
C                  TOLERATES abc{***} TEMPLATE    MAY 2007 ArDean Leith
C                  %f% val < 0 bug                MAY 2012 ArDean Leith
C                  %I% SUPPORTED                  MAY 2012 ArDean Leith
C                  %I% BUG (not %i%               APR 2013 ArDean Leith
C                  aa**bb**[v1][v2] BUG           OCT 2013 ArDean Leith
C                  ff***[r1]  [ss] BUG            OCT 2013 ArDean Leith
C                  1-[r1]  [ss] BUG               NOV 2013 ArDean Leith
C                  igo blank format BUG           JUL 2015 ArDean Leith
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2015  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    FILNAMSUB(FILNAM,NLET,IBANK,IRTFLG)
C
C    PARAMETERS: 
C           FILNAM     CHARACTER STRING FOR SUBSTITUION  (SENT/RETURNED)
C           NLET       NO. OF CHARACTERS IN STRING       (SENT/RETURNED)
C           IBANK      SET OF REG. VALUES TO BE USED     (SENT)
C           IRTFLG     ERROR FLAG, ZERO IS NORMAL        (RETURNED)
C
C    PURPOSE:    SUBSTITUTE REGISTERS AND DO LOOP INDICES INTO
C                CERTAIN POSITIONS OF A STRING (NOT NECESSARILY A
C                FILENAME, IT CAN BE ANY STRING). ALSO SUBSTITUTES FOR
C                ENVIRONMENTAL VARIABLES ${...}.
C
C    DESCRIPTION: SUBSTITUTES FOR REGISTER AND LOOP INDEX. 
C                 EXAMPLES IF ([v1]=1, [v11]=11, [v1111]=1111, INDEX:A=44)
C
C                 avg***[v1]           ---> avg001
C                 dir*/avg***[v1][v11] ---> dir1/avg011
C
C                 avg000{---[v1]}      ---> avg001
C                 avg000{----[iv1]}    ---> av0001 (no error reported)
C                 avg000{---[v1111]}   ---> av1111 (no error reported)
C                 avg000{---a}         ---> avg044 
C
C                 avg{***[v1]}         ---> avg001
C                 avg{****[v1]}        ---> avg0001
C                 avg{**a}             ---> avg44 
C                 avg{****}            ---> avg***  (no error reported)
C                 avg{***[v1111]}      ---> ERROR DAMAGES INVARIANT PART 
C                                           OF FILE NAME
C                 EXAMPLES IF ([v2]=-1
C                 avg{***[v2]}         ---> avg0-1
C                 {%i3%[v2]}           --->  -1
C                 {%f3%[v2]}           ---> -1.0000000
C                 {%f4.2%[v2]}         ---> -1.0
C                 {%g14.1%[v2]}        ---> -1.
C
C  NOTE:         CALLS ERRT IF ERROR OCCURS
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

      SUBROUTINE FILNAMSUB(FILNAM,NLET,IBANK,IRTFLG)

      INCLUDE 'CMBLOCK.INC'
      INCLUDE 'CMLIMIT.INC'

      CHARACTER(LEN=*)      :: FILNAM
      INTEGER               :: NLET,IBANK,IRTFLG

      CHARACTER(LEN=1)      :: NULL = CHAR(0)
      CHARACTER(LEN=1)      :: JCHAR,CTEMP
      CHARACTER(LEN=4)      :: NAME
      CHARACTER(LEN=12)     :: SUBPAT
      LOGICAL               :: ISCHAR,CHKMULTIPLE
C     CHARACTER(LEN=80)     :: SUBENV,CVAL,FMT,CSUB JULY 2014 al
      CHARACTER(LEN=MAXNAM) :: SUBENV,CVAL,FMT,CSUB

      DATA SUBPAT/'{***********'/

      IRTFLG      = 1
      CHKMULTIPLE = .TRUE.

      IGOM   = 1    ! THIS ENSURES MULTIPLE TERMINAL [] ONLY SEARCHED 1X

C     SUBSTITUTION LOOP STARTS HERE
10    CONTINUE

C     SEE IF "$(...)" IS PRESENT FOR ENVIRONMENTAL VARIABLES ---------
      CALL CHARINSIDE(FILNAM(1:NLET),'${','}',.FALSE.,.FALSE.,
     &                IGOP,IENDP,NCHARP)

      IF (NCHARP > 0) THEN   
C        ENVIRONMENTAL VARIABLE SUBSTITUTION NEEDED 
         CALL MYGETENV(FILNAM(IGOP+2:IENDP-1),SUBENV,NCHARS,NULL,IER)
         CALL SUBCHAR(SUBENV(1:NCHARS),FILNAM,IGOP,IENDP,NLET,IRTFLG)

C        SEE IF ANY MORE ENV. VARIABLE SUBSTITUTIONS ARE NEEDED
         GOTO 10
      ENDIF

C     HANDLE A FILENAME TERMINATING WITH REG. OR LOOP ---------------
C     I.E.: ABC***[reg]  OR   ABC000[reg]  OR   ABC***i (at very end)

      NVAR = 0
      DO I= 1,NLET
         IF (FILNAM(I:I) == '[') NVAR = NVAR + 1
      ENDDO

      IF (NVAR == 1 .AND. 
     &    NLET > 3  .AND. 
     &    FILNAM(NLET:NLET) == ']' .AND.
     &    FILNAM(1:1) .NE. '?') THEN    ! ? NEEDED FOR 'FR' USE

C        PROBABLE TERMINAL REGISTER (STRING VARIABLES ALREADY REPLACED)

         IGOVAR = SCAN(FILNAM, '[', .TRUE.) 
         IENDA  = IGOVAR - 1                 ! POSSIBLE END OF ***'s

         IF (IENDA > 0) THEN
C           DEFINATE TERMINAL REGISTER: ....[REG]

C           FIND LAST NON-ASTERICK 
            INOTA  = VERIFY(FILNAM(1:IENDA), '*', BACK=.TRUE.)
            IASTGO = INDEX(FILNAM(1:IENDA),'*')

            !write (6,*)'inota,ienda,iastgo:',inota,ienda,iastgo

            IF (INOTA == IENDA .AND. IASTGO == 0) THEN
C              NO *(s) ANYWHERE, USE TERMINAL DIGITS OR OVERWRITE

               INOTDIG =VERIFY(FILNAM(1:IENDA),'0123456789',BACK=.TRUE.)
               !write(6,*)' inota,ienda:inotdig' ,inota,ienda,inotdig ! 4,4,4 
                  
               IF (INOTDIG .NE. IENDA) THEN
C                 HAS TERMINAL DIGITS, REPLACE THEM WITH *(s) 
                  IGOA = INOTDIG + 1
                  NAST = IGOVAR - IGOA
                  !write (6,*)'set0 =',igoa
                  !write(6,*)' csub:',CSUB(1:NCHARSUB),':',FILNAM(1:20)

                  CSUB = SUBPAT(1:NAST+1)//
     &                          FILNAM(IGOVAR:NLET)// '}'//NULL 
                  NCHARSUB = NAST+1+NLET-IGOVAR+1+1

                  CALL SUBCHAR(CSUB(1:NCHARSUB),FILNAM,
     &                         IGOA,NLET,NLET,IRTFLG)
              ENDIF
            ENDIF
        ENDIF

      ELSEIF (NLET > 1 .AND. ISCHAR(FILNAM(NLET:NLET)) ) THEN
C        POSSIBLE TERMINAL LOOP INDEX: ..**I
         IGOVAR = NLET 
         IENDA  = IGOVAR - 1 
       
         IF (IENDA > 0) THEN
C           ASSUME TERMINAL LOOP INDEX: ....[REG]
            INOTA = VERIFY(FILNAM(1:IENDA), '*', BACK=.TRUE.)

            IF (INOTA .NE. IENDA) THEN
C              HAS  *(s), SUBSTITUTE FOR *(s)
               IGOA = INOTA + 1
               NAST = IGOVAR - IGOA 
               CALL SSUPCAS(FILNAM(NLET:NLET))
               CSUB = SUBPAT(1:NAST+1) // '[_' // FILNAM(NLET:NLET) //
     &                       ']}' // NULL 

               NCHARSUB = NAST+1+2+1+2
               CALL SUBCHAR(CSUB(1:NCHARSUB),FILNAM,
     &                      IGOA,NLET,NLET,IRTFLG)
            ENDIF
         ENDIF
      ENDIF
      !write(6,*)' filnam:',FILNAM(1:20),IGOA,NLET


C     HANDLE FILNAM WITH MULTIPLE *** SUBSTITUTIONS  ----Jan07-----
C     E.G.  ABC***/DEF***[reg1][reg2]  
C     THIS WOULD BE MUCH SIMPLER IF FORTRAN HAD REGULAR EXPRESSIONS!

      !write(6,*) ' after filnam:', filnam(1:nlet),' igom:',igom, '  nlet:',nlet

      DO WHILE (CHKMULTIPLE .AND. IGOM <= (NLET - 2))
         CHKMULTIPLE = .FALSE.

         !write(6,*) ' Remaining filnam: ', filnam(igom:nlet)

C        FIND FIRST '*' IN REMAINING PART OF FILENAME
         IGOAST = INDEX(FILNAM(IGOM:NLET),'*')
         IF (IGOAST <= 0) EXIT

C        FOR THIS SUBSTITUTION WE CAN NOT HAVE A '{' JUST BEFORE FIRST '*'
         IF (IGOAST > 1 .AND.
     &       FILNAM(IGOM+IGOAST-2:IGOM+IGOAST-2) == '{')EXIT

C        FIND NUMBER OF '*' IN THIS ***
         NAST = VERIFY(FILNAM(IGOM+IGOAST-1:NLET),'*') - 1

C        NEED SOMETHING AFTER LAST '*' IN THIS ***
         IF (NAST <= 0) EXIT

         IGOVAR = INDEX(FILNAM(IGOM:NLET), '[') + IGOM -1 
         !write(6,*)' FILNAM(IGOM:NLET): ', FILNAM(IGOM:NLET)

C        NEED [.] REG. VARIABLE SOMEWHERE AFTER *** SEQUENCE
         IF (IGOVAR <= 0) EXIT

C        FIND NUMBER OF CHAR. IN THIS [] REG. VARIABLE
         NVAR = INDEX(FILNAM(IGOVAR:NLET),']')

C        NEED VALID [.] REG. VARIABLE AFTER *** SEQUENCE
         IF (NVAR <= 2) EXIT

         !write(6,*)' igom,igoast,nast,igovar,nvar: ', igom,igoast,nast,igovar,nvar
          
C        OK GO AHEAD AND SUBSTITUTE
         LOC1 = IGOM + IGOAST - 1
         LOC2 = LOC1 + NAST   - 1
         LOC3 = IGOVAR 
         LOC4 = LOC3 + NVAR   - 1
         NSUB = 1 + (LOC2- LOC1 + 1) + (LOC4 - LOC3 + 1) + 1 

          
         CSUB = '{'//FILNAM(LOC1:LOC2) // 
     &               FILNAM(LOC3:LOC4) // '}' // NULL
         !write(6,*)' nsub,loc1,loc2,loc3,loc4:',nsub,loc1,loc2,loc3,loc4
         !write(6,*)' csub: ', csub(1:nsub)

C        BLANK THE MATCHED VARIABLE [..] OUT                     
         FILNAM(LOC3:) = FILNAM(LOC4+1:) // NULL

C        SUBSTITUTE *** WITH {***[reg]}
         CALL SUBCHAR(CSUB(1:NSUB),FILNAM, LOC1,LOC2,NLET,IRTFLG)
         IF (IRTFLG .NE. 0) EXIT

C        CONTINUE LOOP TO FIND FURTHER *** STRINGS TO BE SUBSTITUTED
         IGOM        = LOC1 + NSUB
         CHKMULTIPLE = .TRUE.
       
         !write(6,*)' subed: ', filnam(1:nlet)
         !write(6,*)' igom,loc1,nsub: ', igom,loc1,nsub
 
      ENDDO
         

C     SEE IF "{...}" IS PRESENT  -------------------------------------    
      CALL CHARINSIDE(FILNAM(1:NLET),'{','}',.FALSE.,.FALSE.,
     &                IGO,IEND,NCHAR)

      IF (NCHAR > 0) THEN
C        HAVE {...}  NEED TO SUBSTITUTE INTO FILNAM

C        HUNT FOR ASTERICKS,- or %'s INSIDE {}
         NMINUS = 0
         NAST   = 0
         NPER   = 0

         J      = IGO + 1
         DO WHILE (J  <  IEND .AND. FILNAM(J:J) == '*')
            NAST = NAST + 1
            J    = J + 1
         ENDDO

         IF (NAST <= 0) THEN
C           HUNT FOR MINUS SIGNS INSIDE {}
            J    = IGO + 1
            DO WHILE (J  <  IEND .AND. FILNAM(J:J) == '-')
               NMINUS = NMINUS + 1
               J      = J + 1
            ENDDO
         ENDIF

         IF (NAST <= 0 .AND. NMINUS <= 0) THEN
C           SEE IF "(%...%)" IS PRESENT 
            CALL CHARINSIDE(FILNAM(J:NLET),'%','%',.FALSE.,.FALSE.,
     &                IGOPER,IENDPER,NPER)
            J = J + IENDPER
         ENDIF

         IF (NAST <= 0 .AND. NMINUS <= 0 .AND. NPER <= 0) THEN
C           NO ASTERICKS, MINUS, OR,PERCENT SIGNS IS AN ERROR
            WRITE(NOUT,*)'*** NO *,- OR, % IN SUBSTITUTION STRING: ',
     &                   FILNAM
            CALL ERRT(100,'FILNAMSUB',NE)
            RETURN

         ELSEIF ((NAST + 2) == NCHAR .OR. 
     &           (NMINUS > 0 .AND. (NMINUS +2) == NCHAR)) THEN
C           SUBSTITUTION STRING HAS {***..} OR {---} ONLY, REMOVE {}

            IF (IEND < NLET) THEN
               FILNAM = FILNAM(1:IGO-1) // 
     &                  FILNAM(IGO+1:IEND-1) // 
     &                  FILNAM(IEND+1:NLET)  // ' '
            ELSE
               FILNAM = FILNAM(1:IGO-1) // 
     &                  FILNAM(IGO+1:IEND-1) // ' '
            ENDIF

            NLET   = NLET - 2
            IRTFLG = 0
            RETURN
         ENDIF

         JCHAR   = FILNAM(J:J)

         IF (JCHAR == '[') THEN
C           REGISTER SUBSTITUTION WANTED

            CALL CHARINSIDE(FILNAM(J:),'[',']',.FALSE.,.FALSE.,
     &                       IGOBRAK,IENDBRAK,NCHARBRAK)

            CALL REG_GET_VAR(IBANK,FILNAM(J+IGOBRAK-1:J+NCHARBRAK-1),
     &                       .FALSE.,RVALT,IREG,IENDVAR,IRTFLG)
            IF (IRTFLG .NE. 0) RETURN

            IF (NPER <= 0) THEN
C              MAKE REG. CONTENTS INTO INTEGER FOR FILE NUMBER
               IF (RVALT >= 0 ) THEN
                  IVALT = RVALT + 0.5
               ELSE
                  IVALT = RVALT - 0.5
               ENDIF
            ENDIF
            !write(6,*) ' fil:',filnam(J+IGOBRAK-1:J+NCHARBRAK-1) 
            !write(6,*) ' ivalt:',ibank,ireg,iendvar,irtflg,rvalt,ivalt

         ELSEIF (ISCHAR(JCHAR)) THEN
C           OLD STYLE LOOP COUNTER SUBSTITUTION WANTED
            CALL SSUPCAS(JCHAR)
            NAME = '[_' // JCHAR // ']'

            CALL REG_GET_VAR(0,NAME,.FALSE.,RVALT,IREG,IENDVAR,IRTFLG)
            IF (IRTFLG .NE. 0) RETURN
            IF (RVALT >= 0 ) THEN
               IVALT = RVALT + 0.5
            ELSE
               IVALT = RVALT - 0.5
            ENDIF

         ELSE
            CALL ERRT(101,'UNDECIPHERABLE SUBSTITUTION REQUEST',NE)
            RETURN
         ENDIF

C        FIND DIGITS IN IVALT
         NDIGITS = NUMDIG(IVALT,0)
         IF (NAST >  0 .AND. NDIGITS > NAST) THEN
            
            WRITE(NOUT,90) IVALT, FILNAM(1:NLET)
90          FORMAT(' *** SUBSTITUTING: ',I7, ' INTO: ',A,/,
     &             '     DAMAGES INVARIANT PART OF STRING')
            CALL ERRT(100,'FILNAMSUB',NE)
            RETURN
         ENDIF

C        FIND LOCATION FOR SUBSTITUTION WITHIN FILENAME
         NSUB      = NAST
         IF (NMINUS > 0) THEN
C           USING {---x?} SUBSTITUTION
            NSUB = MAX(NMINUS,NDIGITS)
C           EAT AWAY SUPPLIED FILENAME WHEN USING - TYPE SUBSTITUTION
            IGO = IGO - NSUB

C           EAT AWAY ANY PRECEEDING ASTERICKS IN FILENAME ALSO
            DO WHILE (IGO >= 2 .AND. FILNAM(IGO-1:IGO-1) == '*')
               IGO  = IGO - 1
               NSUB = NSUB + 1
            ENDDO
 
            IF (IGO <= 0) THEN
               WRITE(NOUT,*) '*** SUBSTITUTION NUMBER: ',IVALT,
     &                       ' WILL NOT FIT IN STRING'
               CALL ERRT(100,'FILNAMSUB',NE)
               RETURN
            ENDIF

         ELSEIF (NPER > 0) THEN
C           USING {%...%x?} SUBSTITUTION
            CALL CHARINSIDE(FILNAM(IGO:IGO+NCHAR-1),'%','%',
     &                      .TRUE.,.FALSE.,IGOPER,IENDPER,NPER)
            FMT = '(' // FILNAM(IGO+IGOPER-1:IGO+IENDPER-1) // 
     &                 ')' //CHAR(0)

            !write(6,*) 'Fmt:',fmt(1:15),':'

            IF (FMT(2:2) == 'i' .OR. FMT(2:2) == 'I') THEN
C              WRITE REG. CONTENT AS INTEGER
               IF (RVALT >= 0 ) THEN
                  IVALT = RVALT + 0.5
               ELSE
                  IVALT = RVALT - 0.5
               ENDIF
               WRITE(CVAL,FMT) IVALT

            ELSE
C              WRITE REG. CONTENT AS REAL
               WRITE(CVAL,FMT) RVALT
            ENDIF

            CVAL = adjustl(CVAL)
            NSUB = lnblnkn(CVAL) 
         ENDIF

         NLET  = IGO + NSUB + (NLET - IEND) - 1
         NLEN  = LEN(FILNAM)

         IF (NLET > NLEN) THEN
            CALL ERRT(102,'SUBSTITUTION IS TOO LONG',NLET)
            RETURN
         ENDIF

C        PRESERVE END OF FILENAME AFTER SUBSTITUTION AREA    
         FILNAM(IGO+NSUB:) = FILNAM(IEND+1:)

C        WRITE SUBSTITUTION CONTENTS INTO THE  STRING
         IF (NPER > 0) THEN
            FILNAM(IGO:IGO+NSUB-1) = CVAL(1:NSUB)


         ELSE

            CALL INTTOCHAR(IVALT,FILNAM(IGO:IGO+NSUB-1),NNN,NSUB)

            IF (NNN < 0) THEN
               CALL ERRT(102,'SUBSTITUTING NUMBER INTO STRING',
     &                  IVALT)
               RETURN
            ENDIF
         ENDIF

        !write(6,*) ' final: ',nper,':',filnam(1:25)

C        SEE IF ANY MORE SUBSTITUTIONS ARE NEEDED
         GOTO 10
      ENDIF

30    IF (INDEX(FILNAM(1:NLET), '$') > 0) THEN
C       CHECK FOR PRESENCE OF $DATEXT IN FILNAM -----------------
        IDATEXT = INDEX(FILNAM(1:NLET),'$DATEXT')
        IF (IDATEXT <= 0) IDATEXT = INDEX(FILNAM(1:NLET),'$datext')

        DO WHILE (IDATEXT > 0) 
C          SUBSTITUTE CURRENT DATEXC FOR $DATEXT
           FILNAM = FILNAM(1:IDATEXT-1) // DATEXC(1:3) // 
     &              FILNAM(IDATEXT+7:NLET)
           NLET      = NLET - 4 
           IDATEXT = INDEX(FILNAM(1:NLET),'$DATEXT')
           IF (IDATEXT <= 0)IDATEXT = INDEX(FILNAM(1:NLET),'$datext')
        END DO

C       CHECK FOR PRESENCE OF $PRJEXT IN FILNAM -----------------
C       DO NOT CHANGE CASE OF PRJEXT HERE!!!!

        IPRJEXT = INDEX(FILNAM(1:NLET),'$PRJEXT')
        IF (IPRJEXT <= 0) IPRJEXT = INDEX(FILNAM(1:NLET),'$prjext')

        DO WHILE (IPRJEXT > 0) 
C          SUBSTITUTE CURRENT PRJEXC FOR $PRJEXT
           FILNAM = FILNAM(1:IPRJEXT-1) // PRJEXC(1:3) // 
     &              FILNAM(IPRJEXT+7:NLET)
           NLET      = NLET - 4 
           IPRJEXT = INDEX(FILNAM(1:NLET),'$PRJEXT')
           IF (IPRJEXT <= 0) IPRJEXT = INDEX(FILNAM(1:NLET),'$prjext')
        END DO
 
C        SEE IF ANY MORE SUBSTITUTIONS ARE NEEDED
         GOTO 30
      ENDIF
      !    write(6,*) ' Return: ',filnam(1:25)

      IRTFLG = 0

      END
@


1.35
log
@CVAL = adjustl(CVAL) for removing extra blank in %% output line
@
text
@d26 1
a26 1
C=* Email: spider@@wadsworth.org                                        *
@


1.34
log
@(LEN=MAXNAM) :: SUBENV,CVAL,FMT,CSUB
@
text
@d18 1
d24 1
a24 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d90 1
d92 2
a93 1
      CHARACTER(LEN=1)      :: JCHAR,NULL,CTEMP
a101 1
      NULL        = CHAR(0)
d388 1
a388 1
            DO WHILE (IGO .GE. 2 .AND. FILNAM(IGO-1:IGO-1) == '*')
d407 2
d417 1
d422 2
d426 1
a426 1
           
d441 2
d454 1
a454 1
         !write(6,*) ' final: ',nper,':',filnam(1:25)
d492 1
a492 1
      !    write(6,*) ' return: ',filnam(1:25)
@


1.33
log
@aa**bb**[n] bug
@
text
@d23 1
a23 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
d86 1
d88 1
a88 1
      CHARACTER(LEN=*)  :: FILNAM
d90 6
a95 5
      CHARACTER(LEN=1)  :: JCHAR,NULL,CTEMP
      CHARACTER(LEN=4)  :: NAME
      CHARACTER(LEN=12) :: SUBPAT
      CHARACTER(LEN=80) :: SUBENV,CVAL,FMT,CSUB
      LOGICAL           :: ISCHAR,CHKMULTIPLE
@


1.32
log
@1-[r1]  [ss] BUG
@
text
@d133 1
d144 2
d156 2
a157 1
                  !write (6,*)'nast0 =',igovar,igoa,nast
d159 7
a165 13
               ELSE
C                 MAY BE 1-[n] ETC. LINE, DO NOT SUBSTITUTE
                  IGOA   = 0
                  NAST   = 0
                  !write (6,*)' nast1 =',igovar,igoa,nast

               ENDIF

            ELSEIF (INOTA < IENDA) THEN
C              HAS  TERMINAL *(s), SUBSTITUTE FOR *(s)
               IGOA = INOTA + 1
               NAST = IGOVAR - IGOA 
               !write (6,*)' nast2 =',igovar,igoa,nast
d167 1
a167 17

            !write(6,*) ' goa,nota,govar,enda,nast:',
            !       igoa,inota,igovar,ienda,nast

            IF (IGOA > 0 .AND. IGOA  <= IGOVAR) THEN
C              SUBSTITUTE FOR TERMINAL DIGITS OR ***'s
               !NAST = IGOVAR - IGOA 
               CSUB = SUBPAT(1:NAST+1)//FILNAM(IGOVAR:NLET)// '}'//NULL 
               NCHARSUB = NAST+1+NLET-IGOVAR+1+1

               !write(6,*) ' csub:',CSUB(1:NCHARSUB),'  ',FILNAM(1:20),IGOA,NLET

               CALL SUBCHAR(CSUB(1:NCHARSUB),FILNAM,
     &                      IGOA,NLET,NLET,IRTFLG)

             ENDIF
         ENDIF
d192 1
d481 2
a482 1
 
@


1.31
log
@ff***[r1]  [ss] BUG.
@
text
@d17 1
d131 1
a147 8

!               IF (INOTDIG ==  IENDA) THEN
!C                 NO DIGITS, ADD 3 TERMINAL DIGITS 
!                  NAST   = 3
!                  IGOA   = IGOVAR 
!                  IGOVAR = IGOVAR 
!               ELSE
!                  !write(6,*) ' goa,govar,nast:',goa,igovar,nast
d149 1
a149 1
               IF (INOTDIG .NE.  IENDA) THEN
d153 8
d167 1
@


1.30
log
@removed aaabbb[regvar] support
@
text
@d16 1
d225 2
a226 1
         IF (IGOAST > 1 .AND.FILNAM(IGOAST-1:IGOAST-1) == '{')EXIT
@


1.29
log
@aa**bb**[v1][v2] BUG
@
text
@d146 7
a152 6
               IF (INOTDIG ==  IENDA) THEN
C                 NO DIGITS, ADD 3 TERMINAL DIGITS 
                  NAST   = 3
                  IGOA   = IGOVAR 
                  IGOVAR = IGOVAR 
                  !write(6,*) ' goa,govar,nast:',goa,igovar,nast
d154 1
a154 1
               ELSE
@


1.28
log
@%I% BUG (not %i%)
@
text
@d15 1
d120 10
a129 2
      IF (NLET > 3 .AND. FILNAM(NLET:NLET) == ']') THEN
C        PROBABLE TERMINAL REGISTER (SYMBOLS ARE ALREADY GONE)
d131 1
a131 1
         IENDA  = IGOVAR - 1
d135 8
a142 4
            INOTA = VERIFY(FILNAM(1:IENDA), '*', BACK=.TRUE.)
  
            IF (INOTA == IENDA) THEN
C              NO *(s), USE TERMINAL DIGITS INSTEAD
d144 9
a152 4
               IF (INOTDIG == IENDA) THEN
C                 NO DIGITS, ADD 3 DIGITS TO END ANYWAY 
                  NAST = 3
                  IGOA = IGOVAR
d154 1
a154 1
C                 REPLACE ALL DIGITS WITH *(s) 
d158 3
a160 2
            ELSE
C              HAS  *(s), SUBSTITUTE FOR *(s)
d165 4
a168 1
            IF (IGOA > 0 .AND. IGOA .LT. IGOVAR) THEN
d170 1
a170 1
               NAST = IGOVAR - IGOA 
d173 3
d178 1
d211 1
a211 1
      !write(6,*) ' filnam: ', filnam(1:nlet)
d216 1
a216 1
         !write(6,*) ' remaining filnam: ', filnam(igom:nlet)
d226 1
a226 1
         NAST = VERIFY(FILNAM(IGOAST:NLET),'*') - 1
d231 3
a233 1
         IGOVAR = INDEX(FILNAM(IGOM:NLET), '[') 
d243 1
a243 2
c        !write(6,*)' igom,igoast,nast,igovar,nvar: ',
c     &               igom,igoast,nast,igovar,nvar
d248 1
a248 1
         LOC3 = IGOM + IGOVAR - 1
d250 1
a250 1
         NSUB = 1 + (LOC2- LOC1 + 1) + (LOC4- LOC3 + 1) + 1 
a251 1
c        !write(6,*)' nsub,loc1,loc2,loc3,loc4:',nsub,loc1,loc2,loc3,loc4
d255 2
a256 1
c        !write(6,*)' csub: ', csub(1:nsub)
a259 1
c        !write(6,*) ' blanked: ', FILNAM(1:NLET)
a263 1
         !write(6,*)' subed: ', filnam(1:nlet)
d266 1
a266 1
         IGOM        = LOC1 + NSUB + 1
d268 4
d273 1
a273 1
       
d288 1
a288 1
         DO WHILE (J .LT. IEND .AND. FILNAM(J:J) == '*')
d296 1
a296 1
            DO WHILE (J .LT. IEND .AND. FILNAM(J:J) == '-')
d354 2
d377 1
a377 1
         IF (NAST > 0 .AND. NDIGITS > NAST) THEN
@


1.27
log
@%I% SUPPORTED , %f% val < 0 bug
@
text
@d14 1
d20 1
a20 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d383 1
a383 1
            IF (FMT(2:2) == 'i' .OR. FMT(2:2) == 'i') THEN
@


1.26
log
@GPL_2010
@
text
@d12 2
d19 1
a19 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d67 6
d106 1
a106 1
      IF (NCHARP .GT. 0) THEN   
d118 1
a118 1
      IF (NLET .GT. 3 .AND. FILNAM(NLET:NLET) .EQ. ']') THEN
d123 1
a123 1
         IF (IENDA .GT. 0) THEN
d127 1
a127 1
            IF (INOTA .EQ. IENDA) THEN
d130 1
a130 1
               IF (INOTDIG .EQ. IENDA) THEN
d145 1
a145 1
            IF (IGOA .GT. 0 .AND. IGOA .LT. IGOVAR) THEN
d155 1
a155 1
      ELSEIF (NLET .GT. 1 .AND. ISCHAR(FILNAM(NLET:NLET)) ) THEN
d160 1
a160 1
         IF (IENDA .GT. 0) THEN
d184 1
a184 1
c      write(6,*) ' filnam: ', filnam(1:nlet)
d186 1
a186 1
      DO WHILE (CHKMULTIPLE .AND. IGOM .LE. (NLET - 2))
d189 1
a189 1
c        write(6,*) ' remaining filnam: ', filnam(igom:nlet)
d193 1
a193 1
         IF (IGOAST .LE. 0) EXIT
d196 1
a196 1
         IF (IGOAST .GT. 1 .AND.FILNAM(IGOAST-1:IGOAST-1) .EQ. '{')EXIT
d202 1
a202 1
         IF (NAST .LE. 0) EXIT
d206 1
a206 1
         IF (IGOVAR .LE. 0) EXIT
d212 1
a212 1
         IF (NVAR .LE. 2) EXIT
d214 1
a214 1
c         write(6,*)' igom,igoast,nast,igovar,nvar: ',
d224 1
a224 1
c        write(6,*)' nsub,loc1,loc2,loc3,loc4:',nsub,loc1,loc2,loc3,loc4
d228 1
a228 1
c         write(6,*)' csub: ', csub(1:nsub)
d232 1
a232 1
c         write(6,*) ' blanked: ', FILNAM(1:NLET)
d237 1
a237 1
c         write(6,*)' subed: ', filnam(1:nlet)
d249 1
a249 1
      IF (NCHAR .GT. 0) THEN
d258 1
a258 1
         DO WHILE (J .LT. IEND .AND. FILNAM(J:J) .EQ. '*')
d263 1
a263 1
         IF (NAST .LE. 0) THEN
d266 1
a266 1
            DO WHILE (J .LT. IEND .AND. FILNAM(J:J) .EQ. '-')
d272 1
a272 1
         IF (NAST .LE. 0 .AND. NMINUS .LE. 0) THEN
d279 1
a279 1
         IF (NAST .LE. 0 .AND. NMINUS .LE. 0 .AND. NPER .LE. 0) THEN
d286 2
a287 2
         ELSEIF ((NAST + 2) .EQ. NCHAR .OR. (NMINUS .GT. 0 .AND.
     &           (NMINUS +2) .EQ. NCHAR)) THEN
d290 1
a290 1
            IF (IEND .LT. NLET) THEN
d299 1
a299 2
            NLET = NLET - 2
c           write(6,*) ' substituted: ',FILNAM(1:nlet), ' nlet:',nlet
d306 1
a306 1
         IF (JCHAR .EQ. '[') THEN
d308 1
d316 1
a316 1
            IF (NPER .LE. 0) THEN
d318 5
a322 1
               IVALT = RVALT + 0.5
d332 5
a336 1
            IVALT = RVALT + 0.5
d345 1
a345 1
         IF (NAST .GT. 0 .AND. NDIGITS .GT. NAST) THEN
d356 1
a356 1
         IF (NMINUS .GT. 0) THEN
d363 1
a363 1
            DO WHILE (IGO .GE. 2 .AND. FILNAM(IGO-1:IGO-1) .EQ. '*')
d368 1
a368 1
            IF (IGO .LE. 0) THEN
d375 1
a375 1
         ELSEIF (NPER .GT. 0) THEN
d381 13
a393 1
            WRITE(CVAL,FMT) RVALT
d397 2
a398 2
         NLET      = IGO + NSUB + (NLET - IEND) - 1
         NLEN      = LEN(FILNAM)
d400 2
a401 3
         IF (NLET .GT. NLEN) THEN
            WRITE(NOUT,*) '*** SUBSTITUTION IS TOO LONG: ',NLET
            CALL ERRT(100,'FILNAMSUB',NE)
d404 1
a404 1
  
d409 1
a409 1
         IF (NPER .GT. 0) THEN
d412 1
d415 2
a416 2
            IF (NNN .LT. 0) THEN
               CALL ERRT(102,'SUBSTITUTING THIS NUMBER INTO STRING',
d422 2
d428 1
a428 1
30    IF (INDEX(FILNAM(1:NLET), '$') .GT. 0) THEN
d431 1
a431 1
        IF (IDATEXT .LE. 0) IDATEXT = INDEX(FILNAM(1:NLET),'$datext')
d433 1
a433 1
        DO WHILE (IDATEXT .GT. 0) 
d439 1
a439 1
           IF (IDATEXT .LE. 0)IDATEXT = INDEX(FILNAM(1:NLET),'$datext')
d446 1
a446 1
        IF (IPRJEXT .LE. 0) IPRJEXT = INDEX(FILNAM(1:NLET),'$prjext')
d448 1
a448 1
        DO WHILE (IPRJEXT .GT. 0) 
d454 1
a454 1
           IF (IPRJEXT .LE. 0) IPRJEXT = INDEX(FILNAM(1:NLET),'$prjext')
@


1.25
log
@TOLERATES abc{***} TEMPLATE
@
text
@a13 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d15 5
a19 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d21 1
a21 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d26 1
a26 1
C=* This program is distributed in the hope that it will be useful,    *
d28 1
a28 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a29 1
C=*                                                                    *
d31 1
a31 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.24
log
@***/xxx***{v1][v2] SUPPORT
@
text
@d11 1
d284 13
a296 1
C           SUBSTITUTION STRING HAS ONLY * or -, LEAVE IT ALONE
@


1.23
log
@native named registers
@
text
@d4 7
a10 6
C    FILNAMSUB.F                             NEW JULY 1997 AL
C                  CHARINSIDE PARAMETERS CHANGED  JAN 2001 AL
C                   SGI LEAK ON INTERNAL FMT      AUG 2002 ArDean Leith
C                   BETTER ERROR MSG              SEP 2002 ArDean Leith
C                   ADDED {%f3.4%x11} SUPPORT     JAN 2004 ArDean Leith
C                   ***[] SUPPORT FROM SUBSYM     DEC 2005 ArDean Leith
d14 1
a14 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d52 9
a60 6
C                 EXAMPLES IF ([v1] = 1, [v11]=11, [v1111]=1111, INDEX:A=44)

C                     avg000{---[v1]}  ---> avg001
C                     avg000{----[iv1]} ---> av0001 (no error reported)
C                     avg000{---[v1111]} ---> av1111 (no error reported)
C                     avg000{---a}   ---> avg044 
d62 6
a67 5
C                     avg{***[v1]}  ---> avg001
C                     avg{****[v1]} ---> avg0001
C                     avg{****}   ---> avg***
c                     avg{***[v1111]} ---> ERROR DAMAGES INVARIANT PART OF 
C                                      FILE NAME
d84 1
a84 1
      LOGICAL           :: ISCHAR
d88 5
a92 2
      NULL   = CHAR(0)
      IRTFLG = 1
a109 1

d111 1
a111 1
C     I.E.: ABC***[reg]  OR   ABC000[reg]  OR   ABC***i 
d174 66
d241 1
a241 1
20    CALL CHARINSIDE(FILNAM(1:NLET),'{','}',.FALSE.,.FALSE.,
d245 1
a245 1
C        NEED TO SUBSTITUTE INTO FILNAM
@


1.22
log
@named register support
@
text
@d9 1
d37 1
a37 1
C    FILNAMSUB(FILNAM,NLET,USEVAL,PARAM,IRTFLG)
a41 1
C           USEVAL     FLAG TO USE SENT REG. VALUES      (SENT)
d51 1
a51 1
C                 EXAMPLES IF (X0 = 1, X11=11, X21=1111, INDEX:A=44)
d53 3
a55 3
C                     avg000{---x0}  ---> avg001
C                     avg000{----x0} ---> av0001 (no error reported)
C                     avg000{---x21} ---> av1111 (no error reported)
d58 2
a59 2
C                     avg{***x0}  ---> avg001
C                     avg{****x0} ---> avg0001
d61 1
a61 1
c                     avg{***x21} ---> ERROR DAMAGES INVARIANT PART OF 
d69 1
a69 1
      SUBROUTINE FILNAMSUB(FILNAM,NLET,USEVAL,IBANK,IRTFLG)
d73 1
a73 1
      CHARACTER *(*)   FILNAM
d75 7
a81 3
      CHARACTER *1     JCHAR,JP1CHAR,NULL
      CHARACTER  * 80  SUBENV,CVAL,FMT
      LOGICAL          ISDIGI,ISCHAR,USEVAL
d89 1
a89 1
C     SEE IF "$(...)" IS PRESENT FOR ENVIRONMENTAL VARIABLES 
d102 67
a168 2
C     SEE IF "{...}" IS PRESENT      
      CALL CHARINSIDE(FILNAM(1:NLET),'{','}',.FALSE.,.FALSE.,
a215 2
         JP1CHAR = CHAR(0)
         IF ((J + 1) .LT. IEND) JP1CHAR = FILNAM(J+1:J+1)
d217 1
a217 2
         IF (((JCHAR .EQ. 'X') .OR. (JCHAR .EQ. 'x')) .AND. 
     &      ISDIGI(JP1CHAR)) THEN
d219 6
a224 4
            IBANKT = 0
            IF (USEVAL) IBANKT = IBANK 
            CALL REG_STR_TO_VAL(FILNAM(J:IEND),IBANKT,RVALT,IRTFLG)
            IF (IRTFLG .NE. 0)  RETURN
d231 1
a231 1
         ELSEIF (ISCHAR(JCHAR) .AND. .NOT. USEVAL) THEN
d234 5
a238 1
            CALL INDEXTOREG(JCHAR,.TRUE.,IDUM,IVALT)
d249 2
a250 2
            WRITE(NOUT,90)IVALT,FILNAM(1:NLET)
90          FORMAT(' *** SUBSTITUTING: ',I6, ' INTO:',A,/,
d316 33
a350 1
      RETURN
@


1.21
log
@GPL License fixed
@
text
@a148 1
         CALL SSUPCAS(JCHAR)
d150 2
a151 1
         IF ((JCHAR .EQ. 'X') .AND. ISDIGI(JP1CHAR)) THEN
d153 4
a156 14
            CALL REGPARSE(FILNAM(J:IEND),IREG,IGOR,IENDR,.TRUE.,IRTFLG)
            CALL REG_CHK(IREG,.FALSE.,IRTFLG)
            
            IF (IRTFLG .NE. 0) THEN
               CALL ERRT(102,'SUBSTITUTING INVALID REGISTER',IREG)
               RETURN
            ENDIF

C           FIND REGISTER CONTENTS
            IF (USEVAL) THEN
               CALL REG_GET_BANKED(IBANK,IREG,RVALT,IRTFLG)
            ELSE
               CALL REG_GET(IREG,RVALT,.FALSE.,IRTFLG)
            ENDIF
d165 1
@


1.20
log
@*** empty log message ***
@
text
@d2 1
a2 1
C++*************************************************************************
d10 25
a34 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH                            *
C **************************************************************************
@


1.19
log
@ADDED {%f3.4%x11} SUPPORT
@
text
@d202 1
a202 1
            FMT(2:)  = '(' // FILNAM(IGO+IGOPER-1:IGO+IENDPER-1) // 
@


1.18
log
@error msg bug
@
text
@d8 1
d60 1
a60 1
      CHARACTER  * 80  SUBENV
d89 1
a89 1
C        HUNT FOR ASTERICKS INSIDE {}
d92 2
d110 10
a119 2
C           NO ASTERICKS OR MINUS SIGNS IS AN ERROR
            WRITE(NOUT,*)'*** NO * OR - IN SUBSTITUTION STRING: ',FILNAM
d125 1
a125 1
C           SUBSTITUTION STRING HAS ONLY ASTERICKS, LEAVE IT ALONE
d135 1
a135 2
         IF ((JCHAR .EQ. 'X' .OR. JCHAR .EQ. 'x') .AND.
     &        ISDIGI(JP1CHAR)) THEN
d141 1
a141 3
               WRITE(NOUT,*) 
     &            '*** BAD REGISTER: ',IREG,' IN SUBSTITUTION'
               CALL ERRT(100,'FILNAMSUB',NE)
a150 2
C           MAKE REG. CONTENTS INTO INTEGER FOR FILE NUMBER
            IVALT = RVALT + 0.5
d152 5
d162 1
a162 3
            WRITE(NOUT,*) 
     &         '*** UNDECIPHERABLE SUBSTITUTION REQUEST'
            CALL ERRT(100,'FILNAMSUB',NE)
d177 1
a177 1
C        FIND LOCATION FOR SUBSTITUION WITHIN FILENAME
d180 1
d189 1
a189 1
            END DO
d197 9
d220 5
a224 2
C        WRITE SUBSTITUTION CONTENTS INTO THE FILE NAME
         CALL INTTOCHAR(IVALT,FILNAM(IGO:IGO+NSUB-1),NNN,NSUB)
d226 5
a230 4
         IF (NNN .LT. 0) THEN
            WRITE(NOUT,*) '*** ERROR SUBSTITUTING INTO STRING ',IVALT
            CALL ERRT(100,'FILNAMSUB',NE)
            RETURN
@


1.17
log
@better error msg
@
text
@d108 1
a108 2
            WRITE(NOUT,*)FILNAM 
     &         '*** NO ASTERICK OR MINUS IN SUBSTITUTION STRING:'
@


1.16
log
@inttochar used
@
text
@d7 1
d108 2
a109 2
            WRITE(NOUT,*) 
     &        '*** NO ASTERICK OR MINUS IN SUBSTITUTION STRING'
@


1.15
log
@INDEXTOREG changed to subroutine as it returns parameters (bug)
@
text
@d4 3
a6 2
C    FILNAMSUB.F                                       NEW JULY 97 AL
C                  CHARINSIDE PARAMETERS CHANGED JAN 2001          AL
a57 2
      CHARACTER  * 6   FMT1
      CHARACTER  * 9   DIGITS
a60 3
      DATA DIGITS/'123456789'/
      DATA FMT1/'(I . )'/

a188 3
C        PREPARE FORMAT FOR WRITE
         FMT1(3:3) = DIGITS(NSUB:NSUB)
         FMT1(5:5) = DIGITS(NSUB:NSUB)
d202 3
a204 2
         WRITE(FILNAM(IGO:IGO+NSUB-1),FMT1,IOSTAT=IERR) IVALT
         IF (IERR .NE. 0) THEN
@


1.14
log
@indextoreg parameters
@
text
@d152 1
a152 1
            IVALT = INDEXTOREG(JCHAR,.TRUE.,IDUM)
@


1.13
log
@can do env var. ${..} sub. now
@
text
@d152 1
a152 1
            IVALT = INDEXTOREG(JCHAR,IDUM)
@


1.12
log
@charinside parameter added
@
text
@d28 2
a29 1
C                FILENAME IT CAN BE ANY STRING)
d56 1
a56 1
      CHARACTER *1     JCHAR,JP1CHAR
d59 1
d65 1
d70 13
@


1.11
log
@changes for reg_set
@
text
@d4 2
a5 1
C    FILNAMSUB.F  NEW JULY 97 al
d69 2
a70 1
      CALL CHARINSIDE(FILNAM(1:NLET),'{','}',.FALSE., IGO,IEND,NCHAR)
@


1.10
log
@comment added
@
text
@d22 1
a22 1
C           CURPARAM   SET OF REG. VALUES TO BE USED     (SENT)
d48 1
a48 1
      SUBROUTINE FILNAMSUB(FILNAM,NLET,USEVAL,CURPARAM,IRTFLG)
a52 1
      DIMENSION        CURPARAM(103)
d54 1
a54 1
      CHARACTER *1     JCHAR,JP1CHAR,JP2CHAR
a107 2
         JP2CHAR = CHAR(0)
         IF ((J + 2) .LT. IEND) JP2CHAR = FILNAM(J+2:J+2)
d110 2
a111 1
         IF (JCHAR .EQ. 'X' .AND. ISDIGI(JP1CHAR)) THEN
d113 4
a116 5
            IREG = INDEX(DIGITS,JP1CHAR) 
            IF (ISDIGI(JP2CHAR)) IREG = IREG * 10 + 
     &          INDEX(DIGITS,JP2CHAR) 

            IF (IREG .LT. 0 .OR. IREG .GT. 100) THEN
d125 1
a125 1
               IVALT = CURPARAM(IREG+1) + 0.5
d127 1
a127 1
               IVALT = PARAM(IREG+1) + 0.5
d129 2
a140 1

@


1.9
log
@missing '
@
text
@d43 2
@


1.8
log
@not just for filenames now
@
text
@d169 1
a169 1
     &                       ' WILL NOT FIT IN STRING
@


1.7
log
@loop index converted to register
@
text
@d26 1
a26 1
C                CERTAIN POSITIONS OF FILENAM (NOT NECESSARILY A
d93 1
a93 1
     &        '*** NO ASTERICK OR MINUS IN FILENAME SUBSTITUTION STRING'
d119 1
a119 1
     &            '*** BAD REGISTER: ',IREG,' IN FILENAME SUBSTITUTION'
d137 1
a137 1
     &         '*** UNDECIPHERABLE FILENAME SUBSTITUTION REQUEST'
d149 1
a149 1
     &             '     DAMAGES INVARIANT PART OF FILE NAME')
d169 1
a169 1
     &                       ' WILL NOT FIT IN FILENAME'
d182 1
a182 1
            WRITE(NOUT,*) '*** SUBSTITUTED FILENAME TOO LONG: ',NLET
d193 1
a193 1
            WRITE(NOUT,*) '*** ERROR SUBSTITUTING INTO FILENAME ',IVALT
@


1.6
log
@added new {---} convention
@
text
@d31 1
a31 12
C                     avgx0       ---> avg001
C                     avg1x0      ---> avg001 (no error reported)
c                     avgx11      ---> avg011
c                     avgx21      ---> av1111 (no error reported)
c                     avg*x11     ---> avg0001
c                     avg***x11   ---> avg000001
c                     avg1x10     ---> avg1001
C
C                     avg0a       ---> avg044
C                     avg00a      ---> avg044
C                     avg**00a    ---> avg00044
C
a48 1
CNO_SAVE
a55 1
      CHARACTER * 26   ALFABT
a58 1
      DATA ALFABT/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
d132 3
a134 4
C           LOOP COUNTER SUBSTITUTION WANTED
            CALL SSUPCAS(JCHAR)
            IDX   = INDEX(ALFABT,JCHAR)
            IVALT = IALPHA(IDX)
@


1.5
log
@added curparam  to call
@
text
@d43 5
d49 1
a49 1
C                     avg{****x0} ---> avg001
a75 2
C     USE IVALT IN CASE IVAL IS A CONSTANT 
      IVALT  = IVAL
d77 1
d85 5
a89 2
         J    = IGO + 1
         NAST = 0
d96 10
a105 1
C           NO ASTERICKS IS AN ERROR
d107 1
a107 1
     &         '***NO ASTERICKS IN FILENAME SUBSTITUTION STRING'
d110 3
a112 1
         ELSEIF ((NAST + 2) .EQ. NCHAR) THEN
d150 6
d160 1
a160 1
         IF (NDIGITS .GT. NAST) THEN
d169 21
d191 4
a194 5
         FMT1(3:3) = DIGITS(NAST:NAST)
         FMT1(5:5) = DIGITS(NAST:NAST)

         NLEN    = LEN(FILNAM)
         NLET = IGO + NAST + (NLET - IEND) - 1
d203 1
a203 1
         FILNAM(IGO+NAST:) = FILNAM(IEND+1:)
d206 1
a206 1
         WRITE(FILNAM(IGO:IGO+NAST-1),FMT1,IOSTAT=IERR) IVALT
@


1.4
log
@added new parameters to pass in reg. value
@
text
@d16 1
a16 1
C    FILNAMSUB(FILNAM,NLET,USEVAL,IVAL,IRTFLG)
d18 6
a23 5
C    PARAMETERS: FILNAM  CHARACTER STRING FOR SUBSTITUION  (SENT/RETURNED)
C                NLET    NO. OF CHARACTERS IN STRING       (SENT/RETURNED)
C                USEVAL  FLAG TO USE SENT REG. VALUE       (SENT)
C                IVAL    REG. VALUE SENT TO BE SUBSTITUTED (SENT)
C                IRTFLG  ERROR FLAG, ZERO IS NORMAL        (RETURNED)
d52 1
a52 1
      SUBROUTINE FILNAMSUB(FILNAM,NLET,USEVAL,IVAL,IRTFLG)
d58 2
d121 3
a123 1
            IF (.NOT. USEVAL) THEN
d127 1
a127 1
         ELSEIF (ISCHAR(JCHAR)) THEN
@


1.3
log
@logical isdigi for f90
@
text
@d16 1
a16 1
C    FILNAMSUB(FILNAM,NLET,IRTFLG)
d18 9
a26 7
C    PARAMETERS:  FILNAM  CHARACTER STRING FOR SUBSTITUION (SENT/RETURNED)
C                 NLET    NO. OF CHARACTERS IN STRING      (SENT/RETURNED)
C                 IRTFLG  ERROR FLAG, ZERO IS NORMAL          (RETURNED)
C
C    PURPOSE:     SUBSTITUTE REGISTERS AND DO LOOP INDICES INTO
C                 CERTAIN POSITIONS OF FILENAM (NOT NECESSARILY A
C                 FILENAME IT CAN BE ANY STRING)
d51 1
a51 1
      SUBROUTINE FILNAMSUB(FILNAM,NLET,IRTFLG)
d61 1
a61 1
      LOGICAL          ISDIGI,ISCHAR
d68 2
d118 3
a120 1
            IVAL = PARAM(IREG+1) + 0.5
d125 2
a126 2
            IDX  = INDEX(ALFABT,JCHAR)
            IVAL = IALPHA(IDX)
d129 2
a130 2
C        FIND DIGITS IN IVAL
         NDIGITS = NUMDIG(IVAL,0)
d133 1
a133 1
            WRITE(NOUT,90)IVAL,FILNAM(1:NLET)
d157 1
a157 1
         WRITE(FILNAM(IGO:IGO+NAST-1),FMT1,IOSTAT=IERR) IVAL
d159 1
a159 1
            WRITE(NOUT,*) '*** ERROR SUBSTITUTING INTO FILENAME ',IVAL
d161 1
@


1.2
log
@f90
@
text
@d59 1
a59 1
      LOGICAL FUNCTION ISDIGI,ISCHAR
@


1.1
log
@Initial revision
@
text
@d54 6
a59 6
      CHARACTER *(*)  FILNAM
      CHARACTER *1    JCHAR,JP1CHAR,JP2CHAR
      CHARACTER  * 6  FMT1
      CHARACTER  * 9  DIGITS
      CHARACTER * 26  ALFABT
      LOGICAL         ISDIGI,ISCHAR
d128 1
a128 1
90          FORMAT(' *** SUBSTITUTING: ',I, ' INTO:',A,/,
@
