head	1.20;
access;
symbols
	pre_getangas:1.12
	GPL2010:1.12
	pre_GPL2010:1.11
	pre_var_equation:1.10
	pre_fftwrings:1.10
	pre_opfiles:1.10
	src:1.10
	best-code:1.10
	x-named-regs:1.10
	x:1.10
	v13-00:1.10
	pre_GPL:1.8
	prec_CA:1.8
	noindx:1.6;
locks; strict;
comment	@c @;


1.20
date	2018.01.26.17.08.33;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2016.06.13.15.36.30;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2016.05.23.15.34.48;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2015.10.28.16.08.30;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2015.09.14.18.22.33;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2015.07.15.14.05.36;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2015.01.20.19.26.52;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2014.09.15.15.36.55;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.24.13.25.50;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2009.07.30.11.41.46;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.17.20.32.53;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.17.18.23.41;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.11.16.15.21;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.28.19.09.53;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.18.13.49.20;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.15.20.32.54;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.28.18.01.46;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.25.13.47.00;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.22.19.25.53;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.22.18.06.34;	author leith;	state Exp;
branches;
next	;


desc
@@


1.20
log
@convert=little-ended rewrite
@
text
@
C **********************************************************************
C 
C  GETHEDCCP4                                                  
C             INTEL BYTE_ORDER                  JUL 09 ARDEAN LEITH
C             FORMATTING                        SEP 14 ARDEAN LEITH
C             FORMATTING                        JAN 15 ARDEAN LEITH
C             ISPG PASSED                       JUL 15 ARDEAN LEITH
C             ISPG=0, NX>1  FOR STACK NOW       SEP 14 ARDEAN LEITH
C             DATA TYPE REPORTED                OCT 15 ARDEAN LEITH
C                                                                      
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2018  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C                                                                      
C  GETHEDCCP4(HEADBUF,NX,NY,NZ,IMODE,DMIN,DMAX,
C             DMEAN,RMS,NSYMBT,FLIP,MACHST,ISPG,MZ,IRTFLG)
C                                                                      
C  PURPOSE:     DECODE CCP4 (MRC IMAGE 2000) HEADER      
C                                            
C  PARAMETERS: 
C  
C  MAP/IMAGE HEADER FORMAT
C 
C  LENGTH = 1024 BYTES, ORGANIZED AS 56 LONG WORDS FOLLOWED
C           BY SPACE FOR 10 80 BYTE TEXT LABELS.
C 
C  1    NX              # OF COLUMNS    (FASTEST CHANGING IN MAP)
C  2    NY              # OF ROWS
C  3    NZ              # OF SECTIONS   (SLOWEST CHANGING IN MAP)
C  4    MODE            DATA TYPE
C                       0   IMAGE:  8-BIT BYTES RANGE -128 -->127 (SIGNED)                         
C                       1   IMAGE: 16-BIT HALFWORDS                
C                       2   IMAGE: 32-BIT REALS                    
C                       3   TRANSFORM: COMPLEX 16-BIT INTEGERS     
C                       4   TRANSFORM: COMPLEX 32-BIT REALS        
C                       6   IMAGE : UNSIGNED 8-BIT BYTES RANGE 0 -->255        
C  5    NXSTART         NUMBER OF FIRST COLUMN  IN MAP 
C  6    NYSTART         NUMBER OF FIRST ROW     IN MAP       
C  7    NZSTART         NUMBER OF FIRST SECTION IN MAP       
C  8    MX              NUMBER OF INTERVALS ALONG X
C  9    MY              NUMBER OF INTERVALS ALONG Y
C 10    MZ              NUMBER OF INTERVALS ALONG Z    (>1 FOR STACK)
C 11-13 CELLA           CELL DIMENSIONS IN ANGSTROMS
C 14-16 CELLB           CELL ANGLES IN DEGREES                          
C 17    MAPC            AXIS CORRESPONDING TO COLUMNS  (1,2,3 FOR X,Y,Z)
C 18    MAPR            AXIS CORRESPONDING TO ROWS     (1,2,3 FOR X,Y,Z)
C 19    MAPS            AXIS CORRESPONDING TO SECTIONS (1,2,3 FOR X,Y,Z)
C 20    DMIN            MINIMUM DENSITY VALUE
C 21    DMAX            MAXIMUM DENSITY VALUE  
C 22    DMEAN           MEAN    DENSITY VALUE  
C 23    ISPG            SPACE GROUP NUMBER  (IMAGES == 0, VOL. == 1 )
C 24    NSYMBT          NUMBER OF BYTES USED FOR SYMMETRY DATA (0 OR 80)
C                       PLUS ANY EXTRA HEADER BYTES
C 25-26 EXTRA           EXTRA, USER DEFINED STORAGE SPACE. 29 WORDS MAX.
C 27    ?               CURRENTLY: 'MRCO'
C 28    IVERSION        VERSION NUMBER (CURRENTLY: 20140)
C 29-49 EXTRA           EXTRA, USER DEFINED STORAGE SPACE. 29 WORDS MAX.
C 50-52 ORIGIN          ORIGIN IN X,Y,Z USED FOR TRANSFORMS             
C 53    MAP             CHARACTER STRING 'MAP ' TO IDENTIFY FILE TYPE   
C 54    MACHST          MACHINE STAMP                                   
C 55    RMS             RMS DEVIATION OF MAP FROM MEAN DENSITY          
C 56    NLABL           NUMBER OF LABELS BEING USED                     
C 57-256                LABEL(20,10) 10 80-CHARACTER TEXT LABELS
C 
C SYMMETRY RECORDS FOLLOW - IF ANY - STORED AS TEXT AS IN INTERNATIONAL
C TABLES, OPERATORS SEPARATED BY * AND GROUPED INTO 'LINES' OF 80
C CHARACTERS (IE. SYMMETRY OPERATORS DO NOT CROSS THE ENDS OF THE
C 80-CHARACTER 'LINES' AND THE 'LINES' DO NOT TERMINATE IN A *).
C 
C DATA RECORDS FOLLOW.
C
C NOTES IN VERSION 20140++ :
C        DMAX  < DMIN                        MAX & MIN UNDETERMINED
C        DMEAN < (SMALLER OF DMIN and DMAX)  DMEAN     UNDETERMINED
C        RMS   < 0.0                         RMS       UNDETERMINED
C
C     Bytes 213 and 214 contain 4 `nibbles' (half-bytes) indicating 
C     the representation of float, complex, integer and character 
C     datatypes. Bytes 215 and 216 are unused. The CCP4 library contains 
C     a general representation of datatypes, but in practice it is 
C     safe to use 0x44 0x44 0x00 0x00 for little endian machines, and 
C     0x11 0x11 0x00 0x00 for big endian machines. The CCP4 library 
C     uses this information to automatically byte-swap data if 
C     appropriate, when tranferring data files between machines.  
C
C23456789012345678901234567890123456789012345678901234567890123456789012
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

        SUBROUTINE GETHEDCCP4(HEADBUF,NX,NY,NZ,IMODE,DMIN,DMAX,
     &             DMEAN,RMS,NSYMBT,FLIP,MACHST,
     &             ISPG,MZ,IRTFLG)

        IMPLICIT NONE
        INCLUDE 'CMBLOCK.INC'

        REAL                  :: HEADBUF(*)
        INTEGER               :: NX,NY,NZ,IMODE
        REAL                  :: DMIN,DMAX,DMEAN,RMS
        INTEGER               :: NSYMBT
        LOGICAL               :: FLIP
        INTEGER               :: MACHST,ISPG,MZ,IRTFLG

        CHARACTER(LEN=800)    :: CLABLS
        CHARACTER(LEN=4)      :: MAP,CVAL
        LOGICAL               :: ISSWABT,BIGENDARCH,BIGENDED
        LOGICAL               :: BIGENDFILE,SAMEENDFILE

        INTEGER               :: MAPC,MAPR,MAPS,LNBLNKN,NXSTART
        INTEGER               :: NYSTART,NZSTART,MX,MY
        REAL                  :: CELLAX,CELLAY,CELLAZ
        REAL                  :: CELLBX,CELLBY,CELLBZ
        REAL                  :: ORX,ORY,ORZ
        INTEGER               :: NLABL,INOW,I,IEND,IVERSION

        INTEGER               :: LENMAP
        CHARACTER(LEN=1)      :: LXYZ(3)

        LOGICAL               :: isswab

        DATA LXYZ/'X','Y','Z'/

C       GET CURRENT ARCHITECTURE ENDED-NESS
        BIGENDARCH = BIGENDED(0)

C       FIND IF CURRENTLY SWAPPING BYTES DURING FILE OUTPUT
C       THIS MAY BE DONE BY COMPILER, SO HAVE TO ACTUALLY TEST OUTPUT

        ISSWABT = ISSWAB(99)


C       DETERMINE CURRENT FILE ENDED-NESS AS READ IN

        CALL MVNFLIP(HEADBUF(17), MAPC, .FALSE.)
        CALL MVNFLIP(HEADBUF(18), MAPR, .FALSE.)
        CALL MVNFLIP(HEADBUF(19), MAPS, .FALSE.)

C       write(6,*) ' mapc,mapr,maps: ',mapc,mapr,maps

        SAMEENDFILE = ((MAPC == 1) .OR. (MAPR == 1) .OR. (MAPS == 1))

        BIGENDFILE = ((      SAMEENDFILE .AND.       BIGENDARCH) .OR.
     &                (.NOT. SAMEENDFILE .AND. .NOT. BIGENDARCH))

C       IF FILE ENDEDNESS (AS READ IN!) DIFFERS FROM THIS MACHINES 
C       MUST FLIP BYTES
        FLIP = .NOT. SAMEENDFILE

C       write(6,*) '  FLIP: ',flip,'  SAMEENDFILE ',sameendfile 

C       WRITE OUT CONVERSION INFORMATION
        IF (VERBOSE) THEN       
           IF (BIGENDARCH) THEN
              WRITE(NOUT,*)' On big ended architecture'
           ELSE
              WRITE(NOUT,*)' On little ended architecture'
           ENDIF

           IF (BIGENDFILE) THEN
              WRITE(NOUT,*)' Reading big ended file'
           ELSE
              WRITE(NOUT,*)' Reading little ended file'
           ENDIF

           IF (ISSWABT) THEN
               WRITE(NOUT,*)' SPIDER I/O Non-native byte order'
           ELSE
               WRITE(NOUT,*)' SPIDER I/O Native byte order'
           ENDIF

           IF (FLIP) THEN
              WRITE(NOUT,*)' Flipping byte order'
           ENDIF
        ENDIF

C       GET MAP TYPE FROM INPUT FILE
        CALL MVNREV(HEADBUF(53),MAP,FLIP)
          
        LENMAP = lnblnkn(MAP)
        IF (LENMAP <= 0) THEN
C           OLD STYLE, MRC MAP OR UNKNOWN FILE TYPE
            WRITE(NOUT,*) ' *** BLANK MAP STRING IN MRC FILE'

        ELSEIF (MAP .NE. 'MAP ') THEN
C           OLD STYLE, MRC MAP OR UNKNOWN FILE TYPE
            WRITE(NOUT,*) ' *** BAD MAP STRING IN MRC FILE: ',MAP
        ENDIF

        CALL MVNFLIP(HEADBUF( 1), NX,     FLIP) 
        CALL MVNFLIP(HEADBUF( 2), NY,     FLIP)
        CALL MVNFLIP(HEADBUF( 3), NZ,     FLIP)
        CALL MVNFLIP(HEADBUF( 4), IMODE,  FLIP)

        CALL MVNFLIP(HEADBUF( 5), NXSTART,FLIP)
        CALL MVNFLIP(HEADBUF( 6), NYSTART,FLIP)
        CALL MVNFLIP(HEADBUF( 7), NZSTART,FLIP)
        CALL MVNFLIP(HEADBUF( 8), MX,     FLIP)
        CALL MVNFLIP(HEADBUF( 9), MY,     FLIP)
        CALL MVNFLIP(HEADBUF(10), MZ,     FLIP)

        IF (FLIP) CALL FLIPBYTESI(HEADBUF(11),6,IRTFLG)
        CELLAX  = HEADBUF(11)
        CELLAY  = HEADBUF(12)
        CELLAZ  = HEADBUF(13)
        CELLBX  = HEADBUF(14)
        CELLBY  = HEADBUF(15)
        CELLBZ  = HEADBUF(16)

        CALL MVNFLIP(HEADBUF(17), MAPC,  FLIP)
        CALL MVNFLIP(HEADBUF(18), MAPR,  FLIP)
        CALL MVNFLIP(HEADBUF(19), MAPS,  FLIP)

        IF (FLIP) CALL FLIPBYTESI(HEADBUF(20),3,IRTFLG)
        DMIN    = HEADBUF(20)
        DMAX    = HEADBUF(21)
        DMEAN   = HEADBUF(22)

C       GET EXTTYP (NOW 'MRCO')
        CALL MVNREV(HEADBUF(27),CVAL,FLIP)

C       GET VERSION NUMBER 
        CALL MVNFLIP(HEADBUF(28),IVERSION,     FLIP)

        CALL MVNFLIP(HEADBUF(23), ISPG,  FLIP)
        CALL MVNFLIP(HEADBUF(24), NSYMBT,FLIP)

        IF (FLIP) CALL FLIPBYTESI(HEADBUF(50),3,IRTFLG)
        ORX     = HEADBUF(50)
        ORY     = HEADBUF(51)
        ORZ     = HEADBUF(52)

        CALL MVNFLIP(HEADBUF(54), MACHST, FLIP)
        IF (FLIP) CALL FLIPBYTESI(HEADBUF(55),1,IRTFLG)
        RMS     = HEADBUF(55)
        CALL MVNFLIP(HEADBUF(56), NLABL, FLIP)

        IF (NLABL > 0) THEN
C          GET LABELS
           INOW = 1
           DO I = 57,56 + NLABL * 20
              CALL MVNREV(HEADBUF(I),CLABLS(INOW:INOW+3),FLIP)
              INOW = INOW + 4
           ENDDO
        ENDIF

        IF (VERBOSE) THEN 
           WRITE(NOUT,*) ' '

           IF     (IMODE == 0) THEN
              WRITE(NOUT,*) ' Input data: ' //
     &                      ' 8-bit signed integers, Range -128 --> 127'
           ELSEIF (IMODE == 1) THEN
              WRITE(NOUT,*) ' Input data: ' //
     &                      ' 16-bit signed integers'
           ELSEIF (IMODE == 2) THEN
              WRITE(NOUT,*) ' Input data: ' //
     &                      ' 32-bit reals '
           ELSEIF (IMODE == 3) THEN
              WRITE(NOUT,*) ' Input data: ' //
     &                      ' Complex 16-bit integers'
           ELSEIF (IMODE == 4) THEN
              WRITE(NOUT,*) ' Input data: ' //
     &                      ' Complex 16-bit reals'
           ELSEIF (IMODE == 6) THEN
              WRITE(NOUT,*) ' Input data: ' //
     &                      ' 8-bit unsigned integers, Range 0 --> 255'
           ENDIF

           IEND = lnblnkn(CLABLS)
           IF (IEND <= 0) NLABL = 0
      
C          WRITE OUT HEADER INFORMATION
           WRITE(NOUT,1000) NX,NY,NZ,IMODE,
     &       NXSTART,NYSTART,NZSTART, MX,MY,MZ,
     &       CELLAX,CELLAY,CELLAZ, CELLBX,CELLBY,CELLBZ,
     &       DMIN,DMAX,DMEAN,RMS,ORX,ORY,ORZ,ISPG,NSYMBT,
     &       MACHST,MAP,IVERSION, CVAL,NLABL

1000       FORMAT(
     &     2X,'Columns, rows, sections .................. ',3(I7,1X)/
     &     2X,'Mode ..................................... ',I6/
     &     2X,'Start points on columns, rows, sections .. ',3I7/
     &     2X,'Grid sampling on x, y, z ................. ',3I7/
     &     2X,'Cell axes ................................ ',3F10.2/
     &     2X,'Cell angles .............................. ',3F10.2/
     &     2X,'Minimum density .......................... ',F25.12/
     &     2X,'Maximum density .......................... ',F25.12/
     &     2X,'Mean density ............................. ',F25.12/
     &     2X,'RMS deviation ............................ ',F25.12/
     &     2X,'Origins .................................. ',3F10.2/
     &     2X,'Space group, # bytes symmetry ............ ',2I7/
     &     2X,'Machine stamp ............................ ',I12/
     &     2X,'Map ......................................      ',A/
     &     2X,'Version ..................................    ',I7/
     &     2X,'ExtType .....................................   ',A/

     &     2X,'Number of labels ......................... ',I7)

           IF (NLABL > 0) THEN
              WRITE(NOUT,1001)
1001          FORMAT('  Labels:')
              WRITE(NOUT,1002) CLABLS(1:IEND)
1002          FORMAT(3X,100(A80))
           ENDIF
           WRITE(NOUT,*) ' '

        ENDIF

      END

C --------------------------- MVNREV -------------------------------

C     PURPOSE: COPY AN ARRAY OF INTEGER * 1 INTO A CHAR. STRING 
C
C     PARAMETERS:
C     IA        ARRAY HOLDING 4 INTEGER * 1 or 1 FLOAT          SENT
C     COUT      CHAR STRING                                     RET.
C     REVERSE   LOGICAL FLAG TO FLIP ORDER OF ELEMENTS          SENT

      SUBROUTINE MVNREV(I1IN,COUT,REVERSE)
      
      CHARACTER(LEN=4) :: COUT
      INTEGER * 1      :: I1IN(4)
      LOGICAL          :: REVERSE

      IF (REVERSE) THEN
         DO I = 1,4
           COUT(I:I) = CHAR(I1IN(5-I))
         ENDDO
      ELSE
         DO I = 1,4
           COUT(I:I) = CHAR(I1IN(I))
         ENDDO
      ENDIF

      END


C ------------------------ MVNFLIP -------------------------------

      SUBROUTINE MVNFLIP(I1IN,I1OUT,FLIP)

C     ASSIGNS I1IN TO I1OUT AND FLIPS BYTES WITHIN WORDS IF REQUESTED

      LOGICAL     :: FLIP
      INTEGER * 1 :: I1IN(4),I1OUT(4)

      IF (FLIP) THEN
         I1OUT(1) = I1IN(4)
         I1OUT(2) = I1IN(3)
         I1OUT(3) = I1IN(2)
         I1OUT(4) = I1IN(1)
      ELSE
         I1OUT(1) = I1IN(1)
         I1OUT(2) = I1IN(2)
         I1OUT(3) = I1IN(3)
         I1OUT(4) = I1IN(4)
      ENDIF

      END

C ------------------------ CCPMVI -------------------------------

      SUBROUTINE CCPMVI (ARR1,ARR2,NUM)

C     PURPOSE:  ASSIGNS THE FIRST NUM WORDS OF ARR2 TO ARR1

      INTEGER  :: NUM
      REAL     :: ARR1(*),ARR2(*)
      INTEGER  :: J

      DO J=1,NUM
         ARR1(J) = ARR2(J)
      ENDDO

      END
 
@


1.19
log
@version and exttyp reported now
@
text
@d16 1
a16 1
C=* Copyright 1985-2016  Health Research Inc.,                         *
d35 1
a35 1
C             DMEAN,RMS,NSYMBT,ISSWABT,FLIP,MACHST,ISPG,MZ,IRTFLG)
d96 9
d109 1
a109 1
     &             DMEAN,RMS,NSYMBT,ISSWABT,FLIP,MACHST,
d119 1
a119 1
        LOGICAL               :: ISSWABT,FLIP
d124 1
a124 1
        LOGICAL               :: BIGENDARCH,BIGENDED
d137 2
d144 7
a150 1
C       DETERMINE CURRENT FILE ENDED-NESS
d156 1
a156 1
        !write(6,*) ' mapc,mapr,maps: ',mapc,mapr,maps
d163 2
a164 1
C       IF FILE ENDEDNESS DIFFERS FROM THIS MACHINES MUST FLIP BYTES
d167 2
d183 2
a184 2
           IF (.NOT. ISSWABT) THEN
              WRITE(NOUT,*)' SPIDER I/O Native byte order'
d186 1
a186 1
              WRITE(NOUT,*)' SPIDER I/O Non-native byte order'
d195 1
a195 1
        CALL MVNREV(HEADBUF(53),MAP,ISSWABT)
d237 1
a237 1
        CALL MVNREV(HEADBUF(27),CVAL,ISSWABT)
d259 1
a259 1
              CALL MVNREV(HEADBUF(I),CLABLS(INOW:INOW+3),ISSWABT)
@


1.18
log
@error msg,  ==
@
text
@d73 4
a76 1
C 25-49 EXTRA           EXTRA, USER DEFINED STORAGE SPACE. 29 WORDS MAX.
d91 2
a92 2
C NOTES:
C        DMAX   < DMIN                       MAX & MIN UNDETERMINED
d114 1
a114 1
        CHARACTER(LEN=4)      :: MAP
d123 1
a123 1
        INTEGER               :: NLABL,INOW,I,IEND
d216 6
a273 1
     &       LXYZ(MAPC),LXYZ(MAPR),LXYZ(MAPS),
d275 1
a275 1
     &       MACHST,MAP,NLABL
a283 1
     &     2X,'Fast, medium, slow axes .................. ',3(4X,A)/
d292 2
@


1.17
log
@added data type output
@
text
@d16 1
a16 1
C=* Copyright 1985-2015  Health Research Inc.,                         *
d138 1
a138 1
        SAMEENDFILE = ((MAPC.EQ.1) .OR. (MAPR.EQ.1) .OR. (MAPS.EQ.1))
d177 1
a177 1
            WRITE(NOUT,*) ' *** BLANK MAP STRING IN CCP4 FILE'
d181 1
a181 1
            WRITE(NOUT,*) ' *** BAD MAP STRING IN CCP4 FILE: ',MAP
@


1.16
log
@put ccpmvi inside here
@
text
@d10 1
d235 26
a260 1
        IF (VERBOSE) THEN       
d269 1
a269 1
1000       FORMAT(/
d285 1
a290 1
              IEND = lnblnkn(CLABLS)
@


1.15
log
@mainly cosmetic
@
text
@d5 5
a9 4
C                INTEL BYTE_ORDER                  JUL 09 ARDEAN LEITH
C                FORMATTING                        SEP 14 ARDEAN LEITH
C                FORMATTING                        JAN 15 ARDEAN LEITH
C                ISPG PASSED                       JUL 15 ARDEAN LEITH
d49 1
a49 1
C                       0   IMAGE: SIGNED 8-BIT BYTES RANGE -128 -->127                          
d88 1
a88 1
C        DMAX < DMIN                         MAX & MIN UNDETERMINED
d90 1
a90 1
C        RMS < 0.0                           RMS       UNDETERMINED
d272 1
a272 1
         END
d325 15
@


1.14
log
@output formatting merged big numbers on line
@
text
@d3 2
a4 2
C                                                                      
C  GETHEDCCP4                                                                      *
d8 1
d33 1
a33 1
C             DMEAN,RMS,NSYMBT,ISSWABT,FLIP,MACHST,IRTFLG)
d35 1
a35 1
C  PURPOSE:     DECODE CCP4 (MRC IMAGE 2000) HEADER                                        *
d41 2
a42 2
C 	LENGTH = 1024 BYTES, ORGANIZED AS 56 LONG WORDS FOLLOWED
C                BY SPACE FOR 10 80 BYTE TEXT LABELS.
d44 27
a70 26
C  1	NX		# OF COLUMNS	(FASTEST CHANGING IN MAP)
C  2	NY		# OF ROWS
C  3	NZ		# OF SECTIONS 	(SLOWEST CHANGING IN MAP)
C  4	MODE		DATA TYPE
C			0	IMAGE : SIGNED 8-BIT BYTES RANGE -128 	
C					TO 127				
C			1	IMAGE : 16-BIT HALFWORDS		
C			2	IMAGE : 32-BIT REALS			
C			3	TRANSFORM : COMPLEX 16-BIT INTEGERS	
C			4	TRANSFORM : COMPLEX 32-BIT REALS	
C  5	NXSTART		NUMBER OF FIRST COLUMN  IN MAP 
C  6	NYSTART		NUMBER OF FIRST ROW     IN MAP       
C  7	NZSTART		NUMBER OF FIRST SECTION IN MAP       
C  8	MX		NUMBER OF INTERVALS ALONG X
C  9	MY		NUMBER OF INTERVALS ALONG Y
C 10	MZ		NUMBER OF INTERVALS ALONG Z
C 11-13	CELLA           CELL DIMENSIONS IN ANGSTROMS
C 14-16	CELLB           CELL ANGLES IN DEGREES				
C 17	MAPC		AXIS CORRESPONDING TO COLUMNS  (1,2,3 FOR X,Y,Z)
C 18	MAPR		AXIS CORRESPONDING TO ROWS     (1,2,3 FOR X,Y,Z)
C 19	MAPS		AXIS CORRESPONDING TO SECTIONS (1,2,3 FOR X,Y,Z)
C 20	DMIN		MINIMUM DENSITY VALUE
C 21	DMAX		MAXIMUM DENSITY VALUE
C 22	DMEAN		MEAN    DENSITY VALUE    
C 23	ISPG		SPACE GROUP NUMBER 0 OR 1 (DEFAULT=0)
C 24	NSYMBT		NUMBER OF BYTES USED FOR SYMMETRY DATA (0 OR 80)
d72 6
a77 6
C 50-52	ORIGIN          ORIGIN IN X,Y,Z USED FOR TRANSFORMS		
C 53	MAP	        CHARACTER STRING 'MAP ' TO IDENTIFY FILE TYPE	
C 54	MACHST          MACHINE STAMP					
C 55	RMS	        RMS DEVIATION OF MAP FROM MEAN DENSITY		
C 56	NLABL	        NUMBER OF LABELS BEING USED			
C 57-256	        LABEL(20,10) 10 80-CHARACTER TEXT LABELS
d86 5
d94 3
a96 2
	SUBROUTINE GETHEDCCP4(HEADBUF,NX,NY,NZ,IMODE,DMIN,DMAX,
     &            DMEAN,RMS,NSYMBT,ISSWABT,FLIP,MACHST,IRTFLG)
d98 1
d102 5
d108 1
a108 1
	CHARACTER(LEN=800)    :: CLABLS
d112 7
a118 1
        LOGICAL               :: FLIP,ISSWABT
d121 1
a121 1
	CHARACTER(LEN=1)      :: LXYZ(3)
d123 1
a123 1
	DATA LXYZ/'X','Y','Z'/
d136 1
a136 1
	SAMEENDFILE = ((MAPC.EQ.1) .OR. (MAPR.EQ.1) .OR. (MAPS.EQ.1))
d145 1
a145 1
        IF (VERBOSE) THEN    	
d147 1
a147 1
	      WRITE(NOUT,*)' On big ended architecture'
d149 1
a149 1
	      WRITE(NOUT,*)' On little ended architecture'
d153 1
a153 1
	      WRITE(NOUT,*)' Reading big ended file'
d155 1
a155 1
	      WRITE(NOUT,*)' Reading little ended file'
d159 1
a159 1
	      WRITE(NOUT,*)' SPIDER I/O Native byte order'
d161 1
a161 1
	      WRITE(NOUT,*)' SPIDER I/O Non-native byte order'
d165 1
a165 1
	      WRITE(NOUT,*)' Flipping byte order!'
d182 4
a185 4
	CALL MVNFLIP(HEADBUF( 1), NX,   FLIP) 
	CALL MVNFLIP(HEADBUF( 2), NY,   FLIP)
	CALL MVNFLIP(HEADBUF( 3), NZ, FLIP)
	CALL MVNFLIP(HEADBUF( 4), IMODE,  FLIP)
d230 1
a230 1
	   ENDDO
d233 1
a233 1
        IF (VERBOSE) THEN    	
d235 3
a237 3
	   WRITE(NOUT,1000) NX,NY,NZ,IMODE,
     &       NXSTART,NYSTART,NZSTART,MX,MY,MZ,
     &	     CELLAX,CELLAY,CELLAZ,CELLBX,CELLBY,CELLBZ,
d239 2
a240 2
     &	     DMIN,DMAX,DMEAN,RMS,ORX,ORY,ORZ,ISPG,NSYMBT,
     &       MACHST,NLABL,MAP
d242 3
a244 3
1000	   FORMAT(/
     &     2X,'Number of columns, rows, sections ........ ',3(I7,1X)/
     &     2X,'Pixel mode ............................... ',I6/
d255 4
a258 4
     &	   2X,'Space group, # bytes symmetry ............ ',2I7/
     &	   2X,'Machine stamp ............................ ',I12/
     &     2X,'Number of labels ......................... ',I7/
     &     2X,'Map ......................................    ',A,//)
d260 1
a260 1
	   IF (NLABL > 0) THEN
d262 4
a265 3
1001          FORMAT(' Labels:')
              WRITE(NOUT,1002) CLABLS(1:NLABL * 80)
1002          FORMAT(5X,100(A80))
d271 1
a271 1
        END
@


1.13
log
@formatting, labels
@
text
@d7 1
d13 1
a13 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d223 1
a223 1
     &     2X,'Number of columns, rows, sections ........ ',3I6/
d225 2
a226 2
     &     2X,'Start points on columns, rows, sections .. ',3I6/
     &     2X,'Grid sampling on x, y, z ................. ',3I6/
d235 1
a235 1
     &	   2X,'Space group, # bytes symmetry ............ ',2I6/
d237 1
a237 1
     &     2X,'Number of labels ......................... ',I6/
@


1.12
log
@GPL_2010
@
text
@d3 5
a7 4
C                                                                      *
C  GETHEDCCP4                                                          *            *
C                INTEL BYTE_ORDER                   JUL 09 ARDEAN LEITH
C                                                                      *
d12 1
a12 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d29 2
a30 2
C                                                                      *
C  GETHEDCCP4(HEADBUF,NSAM,NROW,NSLICE,IMODE,DMIN,DMAX,
d32 5
a36 5
C                                                                      *
C  PURPOSE:     DECODE CCP4 (MRC IMAGE 2000) HEADER                      *                                          *
C                                                                      *
C  PARAMETERS:                                                         *
C                                                                      *
d46 6
a51 6
C			0	IMAGE : SIGNED 8-BIT BYTES RANGE -128 	*
C					TO 127				*
C			1	IMAGE : 16-BIT HALFWORDS		*
C			2	IMAGE : 32-BIT REALS			*
C			3	TRANSFORM : COMPLEX 16-BIT INTEGERS	*
C			4	TRANSFORM : COMPLEX 32-BIT REALS	*
d59 4
a62 4
C 14-16	CELLB           CELL ANGLES IN DEGREES				*
C 17	MAPC		WHICH AXIS CORRESPONDS TO COLUMNS  (1,2,3 FOR X,Y,Z)
C 18	MAPR		WHICH AXIS CORRESPONDS TO ROWS     (1,2,3 FOR X,Y,Z)
C 19	MAPS		WHICH AXIS CORRESPONDS TO SECTIONS (1,2,3 FOR X,Y,Z)
d65 1
a65 1
C 22	DMEAN		MEAN    DENSITY VALUE    (AVERAGE)
d69 6
a74 6
C 50-52	ORIGIN          ORIGIN IN X,Y,Z USED FOR TRANSFORMS		*
C 53	MAP	        CHARACTER STRING 'MAP ' TO IDENTIFY FILE TYPE	*
C 54	MACHST          MACHINE STAMP					*
C 55	RMS	        RMS DEVIATION OF MAP FROM MEAN DENSITY		*
C 56	NLABL	        NUMBER OF LABELS BEING USED			*
C 57-256	        LABEL(20,10) 10 80-CHARACTER TEXT LABELS		*
d81 1
a81 1
C 		DATA RECORDS FOLLOW.
d84 1
a84 1
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
d86 1
a86 1
	SUBROUTINE GETHEDCCP4(HEADBUF,NSAM,NROW,NSLICE,IMODE,DMIN,DMAX,
d91 1
a91 1
        REAL                           :: HEADBUF(*)
d93 8
a100 6
	CHARACTER(LEN=800)             :: CLABLS
        CHARACTER(LEN=4)               :: MAP
        LOGICAL                        :: BIGENDARCH,BIGENDED
        LOGICAL                        :: BIGENDFILE,SAMEENDFILE
        LOGICAL                        :: FLIP,ISSWABT
	CHARACTER(LEN=1), DIMENSION(3) :: LXYZ
a122 6
        !write(6,*) ' gethedccp4.f bigendarch:  ', bigendarch 
        !write(6,*) ' gethedccp4.f sameendfile: ', sameendfile
        !write(6,*) ' gethedccp4.f bigendfile:  ', bigendfile 
        !write(6,*) ' gethedccp4.f isswabt:     ', isswabt 
	!write(6,*) ' gethedccp4.f flip:        ', flip

d126 1
a126 1
	      WRITE(NOUT,*)'      Big ended architecture'
d128 1
a128 1
	      WRITE(NOUT,*)'      Little ended architecture'
d132 1
a132 1
	      WRITE(NOUT,*)'      Big ended file'
d134 1
a134 1
	      WRITE(NOUT,*)'      Little ended file'
d138 1
a138 1
	      WRITE(NOUT,*)'      SPIDER I/O Native byte order'
d140 1
a140 1
	      WRITE(NOUT,*)'      SPIDER I/O Non-native byte order'
d144 1
a144 1
	      WRITE(NOUT,*)'      Flipping byte order!'
d151 2
a152 1
        IF (MAP .NE. 'MAP ') THEN
d154 5
a158 1
            WRITE(NOUT,*) '*** BAD MAP STRING IN CCP4 FILE: ',MAP
d161 3
a163 3
	CALL MVNFLIP(HEADBUF( 1), NSAM,   FLIP) 
	CALL MVNFLIP(HEADBUF( 2), NROW,   FLIP)
	CALL MVNFLIP(HEADBUF( 3), NSLICE, FLIP)
d203 1
a203 1
        IF (NLABL .GT. 0) THEN
d214 1
a214 1
	   WRITE(NOUT,1000) NSAM,NROW,NSLICE,IMODE,
d222 16
a237 16
     &     7X,'Number of columns, rows, sections ........ ',3I6/
     &     7X,'Map mode ................................. ',I6/
     &     7X,'Start points on columns, rows, sections .. ',3I6/
     &     7X,'Grid sampling on x, y, z ................. ',3I6/
     &     7X,'Cell axes ................................ ',3F10.2/
     &     7X,'Cell angles .............................. ',3F10.2/
     &     7X,'Fast, medium, slow axes .................. ',3(5X,A)/
     &     7X,'Minimum density .......................... ',F25.12/
     &     7X,'Maximum density .......................... ',F25.12/
     &     7X,'Mean density ............................. ',F25.12/
     &     7X,'RMS deviation ............................ ',F25.12/
     &     7X,'Origin ................................... ',3F10.2/
     &	   7X,'Space group, # bytes symmetry ............ ',2I6/
     &	   7X,'Machine stamp ............................ ',I12/
     &     7X,'Number of titles ......................... ',I6/
     &     7X,'Map ......................................    ',A,//)
d239 1
a239 1
	   IF (NLABL .GT. 0) THEN
d241 1
a241 1
1001          FORMAT(7x,'Titles :')
d243 1
a243 1
1002          FORMAT(1X,A80)
d245 1
d248 1
a248 1
	RETURN
d262 3
a264 3
      CHARACTER(LEN=4) ::    COUT
      INTEGER * 1            I1IN(4)
      LOGICAL ::             REVERSE
a299 1
      RETURN
@


1.11
log
@for big-endian default
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2009  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.10
log
@GPL License fixed
@
text
@d5 1
d9 1
a9 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d94 1
a94 2
	CHARACTER(LEN=200)  ::    CLABLS
        COMMON /COMMUN/ CLABLS
d96 6
a101 6
        DIMENSION                 HEADBUF(*)

        CHARACTER(LEN=4) ::       MAP
        LOGICAL ::                BIGENDARCH,BIGENDED,BIGENDFILE
        LOGICAL ::                FLIP,ISSWABT
	CHARACTER(LEN=1), DIMENSION(3)::   LXYZ
d108 2
a109 1
C       GET CURRENT FILE ENDED-NESS FLAG
d113 7
a119 1
	BIGENDFILE = ((MAPC.EQ.1).OR.(MAPR.EQ.1).OR.(MAPS.EQ.1))
d122 1
a122 2
        FLIP       = (( .NOT. BIGENDFILE .AND.  BIGENDARCH) .OR.
     &                ( .NOT. BIGENDARCH .AND.  BIGENDFILE))
d124 5
a128 2
C       IF -byteswapio FLIP BYTES IS OPPOSITE
        IF (ISSWABT) FLIP = .NOT. FLIP 
d166 2
a167 1
	CALL MVNFLIP(HEADBUF( 4), IMODE,  FLIP)     
d176 7
a182 6
        CELLAX  =            HEADBUF(11)
        CELLAY  =            HEADBUF(12)
        CELLAZ  =            HEADBUF(13)
        CELLBX  =            HEADBUF(14)
        CELLBY  =            HEADBUF(15)
        CELLBZ  =            HEADBUF(16)
d186 1
d188 4
a191 3
        DMIN    =            HEADBUF(20)
        DMAX    =            HEADBUF(21)
        DMEAN   =            HEADBUF(22)
d196 3
a198 3
        ORX     =            HEADBUF(50)
        ORY     =            HEADBUF(51)
        ORZ     =            HEADBUF(52)
d202 1
a202 1
        RMS     =            HEADBUF(55)
a215 1

d242 4
a245 4
             WRITE(NOUT,1001)
1001         FORMAT(7x,'Titles :')
             WRITE(NOUT,1002) CLABLS(1:NLABL * 80)
1002         FORMAT(1X,A80)
a251 3


 
a279 26

C ------------------------ MVNFLIPO -------------------------------

      SUBROUTINE MVNFLIPO(I1IN,I1OUT,FLIP)

C     ASSIGNS 11IN TO i1OUT AND FLIPS BYTES WITHIN WORDS IF REQUESTED

      LOGICAL     :: FLIP

      INTEGER * 1    I1IN(4),I1OUT(4)

      IF (FLIP) THEN
         I1OUT(3) = I1IN(1)
         I1OUT(4) = I1IN(2)
         I1OUT(1) = I1IN(3)
         I1OUT(2) = I1IN(4)
      ELSE
         I1OUT(1) = I1IN(1)
         I1OUT(2) = I1IN(2)
         I1OUT(3) = I1IN(3)
         I1OUT(4) = I1IN(4)
      ENDIF

      RETURN
      END

d284 1
a284 2
C     ASSIGNS 11IN TO i1OUT 
C     FLIPS WORDS & BYTES WITHIN WORDS IF REQUESTED
d287 1
a287 2

      INTEGER * 1    I1IN(4),I1OUT(4)
@


1.9
log
@HRI GPL License used
@
text
@a6 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d10 1
a10 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a29 6

C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.8
log
@fixed flip
@
text
@d8 24
@


1.7
log
@continue if bad map string
@
text
@a92 1
c          write(nout,*) 'mapc:',mapc
d119 1
a119 1
	      WRITE(NOUT,*)'      Native byte order'
d121 1
a121 1
	      WRITE(NOUT,*)'      Non-native byte order'
d147 2
d158 1
d165 1
d171 1
d255 1
a255 1
C ------------------------ MVNFLIP  -------------------------------
d257 1
a257 1
      SUBROUTINE MVNFLIP(I1IN,I1OUT,FLIP)
d270 26
@


1.6
log
@*** empty log message ***
@
text
@d135 1
a135 3
            WRITE(NOUT,*) '*** MAP: ',MAP
            IRTFLG = 2
            RETURN
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
C ++********************************************************************
d22 1
a22 1
C MAP/IMAGE HEADER FORMAT
d72 1
a72 1
     &            DMEAN,RMS,NSYMBT,ISSWABT,FLIP,MACHSTT,IRTFLG)
d76 2
a77 2
	CHARACTER(LEN=4)      ::      CLABLS
        COMMON /COMMUN/ CLABLS(20,10)
d80 2
a81 1
        CHARACTER(LEN=3)      ::  MAP
d83 1
a83 1
        LOGICAL ::                FLIP,ISSWABT,FLIPH
a84 3
        INTEGER ::                MACHST
        REAL    ::                FMACHST
        EQUIVALENCE               (FMACHST,MACHST)
d92 4
a95 3
        CALL MVNFLIP(HEADBUF(17), MAPC,    .FALSE.)
        CALL MVNFLIP(HEADBUF(18), MAPR,    .FALSE.)
        CALL MVNFLIP(HEADBUF(19), MAPS,    .FALSE.)
d97 2
d101 28
a128 2
        FLIPH      = FLIP
        IF (ISSWABT) FLIPH = .NOT. FLIPH 
d131 3
a133 3
        CALL I1TOC(MAP,HEADBUF(53),3,FLIPH)

        IF (MAP .NE. 'MAP') THEN
d135 1
d140 10
a149 10
	CALL MVNFLIP(HEADBUF( 1), NSAM,   FLIPH) 
	CALL MVNFLIP(HEADBUF( 2), NROW,   FLIPH)
	CALL MVNFLIP(HEADBUF( 3), NSLICE, FLIPH)
	CALL MVNFLIP(HEADBUF( 4), IMODE,  FLIPH)     
        CALL MVNFLIP(HEADBUF( 5), NXSTART,FLIPH)
        CALL MVNFLIP(HEADBUF( 6), NYSTART,FLIPH)
        CALL MVNFLIP(HEADBUF( 7), NZSTART,FLIPH)
        CALL MVNFLIP(HEADBUF( 8), MX,     FLIPH)
        CALL MVNFLIP(HEADBUF( 9), MY,     FLIPH)
        CALL MVNFLIP(HEADBUF(10), MZ,     FLIPH)
d156 3
a158 3
        CALL MVNFLIP(HEADBUF(17), MAPC,  FLIPH)
        CALL MVNFLIP(HEADBUF(18), MAPR,  FLIPH)
        CALL MVNFLIP(HEADBUF(19), MAPS,  FLIPH)
d162 2
a163 2
        CALL MVNFLIP(HEADBUF(23), ISPG,  FLIPH)
        CALL MVNFLIP(HEADBUF(24), NSYMBT,FLIPH)
d169 1
a169 1
        FMACHST =            HEADBUF(54)
d171 1
a171 1
        CALL MVNFLIP(HEADBUF(56), NLABL, FLIPH)
d173 9
a181 4
C       GET LABELS
        CALL I1TOC(CLABLS,HEADBUF(57),800,FLIPH)
	 
C       WRITE OUT HEADER INFORMATION
d183 1
a183 11
           IF (BIGENDARCH) THEN
	      WRITE(NOUT,*)'      Big ended architecture'
           ELSE
	      WRITE(NOUT,*)'      Little ended architecture'
           ENDIF

           IF (BIGENDFILE) THEN
	      WRITE(NOUT,*)'      Big ended file'
           ELSE
	      WRITE(NOUT,*)'      Little ended file'
           ENDIF
a184 13
           IF (.NOT. ISSWABT) THEN
	      WRITE(NOUT,*)'      Native byte order'
           ELSE
	      WRITE(NOUT,*)'      Non-native byte order'
           ENDIF

          IF (FLIP) THEN
	      WRITE(NOUT,*)'      Flipping file data byte order!'
           ELSE
	      WRITE(NOUT,*)'      Not flipping file data byte order'
           ENDIF


d190 1
a190 1
     &       MACHST,NLABL
d207 2
a208 1
     &     7X,'Number of titles ......................... ',I6//)
d210 6
a215 4

	   IF (NLABL .GT. 0)
     &        WRITE(NOUT,1001)((CLABLS(I,K),I=1,20),K=1,NLABL)
1001       FORMAT('Titles :'/10(1X,20A4/))
a217 1
        MACHSTT = MACHST
d224 1
a224 1
C --------------------------- I1TOC -------------------------------
d226 1
a226 3
C I1TOC(COUT,I1IN,NB,FLIP) 
 
C PURPOSE: COPY AN ARRAY OF INTEGER * 1 INTO A CHAR. STRING 
d228 4
a231 5
C PARAMETERS:
C      COUT      CHAR STRING
C      IA        ARRAY HOLDING INTEGER * 1 VALUES
C      NB        NUMBER OF ELEMENTS  TO BE COPIED TO STRING
C      FlIP      LOGICAL FLAG TO FLIP ORDER OF ELEMENTS
d233 1
a233 1
      SUBROUTINE I1TOC(COUT,I1IN,NB,FLIP)
d235 7
a241 7
      CHARACTER(LEN=NB)   :: COUT
      INTEGER * 1            I1IN(NB)
      LOGICAL             :: FLIP

      IF (FLIP) THEN
         DO I = NB,1,-1
           COUT(I:I) = CHAR(I1IN(I))
d244 1
a244 1
         DO I = 1,NB
@


1.4
log
@split out bigended
@
text
@d16 1
a16 1
C             DMEAN,RMS,NSYMBT,FLIP,MACHST,IRTFLG)
d72 1
a72 1
     &                        DMEAN,RMS,NSYMBT,FLIP,MACHSTT,IRTFLG)
d81 2
a82 1
        LOGICAL ::                BIGENDARCH,BIGENDED,FLIP,BIGENDFILE
d92 1
a92 1
 
d100 2
d104 1
a104 1
        CALL I1TOC(MAP,HEADBUF(53),3,FLIP)
d112 10
a121 10
	CALL MVNFLIP(HEADBUF( 1), NSAM,   FLIP) 
	CALL MVNFLIP(HEADBUF( 2), NROW,   FLIP)
	CALL MVNFLIP(HEADBUF( 3), NSLICE, FLIP)
	CALL MVNFLIP(HEADBUF( 4), IMODE,  FLIP)     
        CALL MVNFLIP(HEADBUF( 5), NXSTART,FLIP)
        CALL MVNFLIP(HEADBUF( 6), NYSTART,FLIP)
        CALL MVNFLIP(HEADBUF( 7), NZSTART,FLIP)
        CALL MVNFLIP(HEADBUF( 8), MX,     FLIP)
        CALL MVNFLIP(HEADBUF( 9), MY,     FLIP)
        CALL MVNFLIP(HEADBUF(10), MZ,     FLIP)
d128 3
a130 3
        CALL MVNFLIP(HEADBUF(17), MAPC,  FLIP)
        CALL MVNFLIP(HEADBUF(18), MAPR,  FLIP)
        CALL MVNFLIP(HEADBUF(19), MAPS,  FLIP)
d134 2
a135 2
        CALL MVNFLIP(HEADBUF(23), ISPG,  FLIP)
        CALL MVNFLIP(HEADBUF(24), NSYMBT,FLIP)
d143 1
a143 1
        CALL MVNFLIP(HEADBUF(56), NLABL, FLIP)
d146 1
a146 1
        CALL I1TOC(CLABLS,HEADBUF(57),800,FLIP)
d150 25
d198 1
@


1.3
log
@*** empty log message ***
@
text
@a213 21
C ------------------------ BIGENDED ---------------------------------

	
         LOGICAL FUNCTION BIGENDED(IDUM)

C        PURPOSE:  CHECK ENDEDNESS OF CURRENT ARCHITECTURE. 
C                  RETURNS TRUE  IF BIG ENDIAN (IBM, SUN, SGI)
C                  RETURNS FALSE IF LITTLE ENDIAN (VAX, COMPAQ, INTEL)   

        INTEGER * 2    ITWO
        INTEGER * 1    I1ARRAY(2)
        EQUIVALENCE (ITWO,I1ARRAY(1))

C       GET CURRENT ARCHITECTURE ENDED-NESS
        I1ARRAY(1) = 0
        I1ARRAY(3) = 0

        ITWO       = 1

        BIGENDED   = (I1ARRAY(1) .EQ. 0) 
        END
@


1.2
log
@*** empty log message ***
@
text
@d56 1
a56 1
C 54	MACHST	        MACHINE STAMP					*
d72 1
a72 1
     &                        DMEAN,RMS,NSYMBT,FLIP,MACHST,IRTFLG)
d83 3
d138 1
a138 1
        CALL MVNFLIP(HEADBUF(54), MACHST,FLIP)
d176 1
@


1.1
log
@Initial revision
@
text
@d15 2
a16 2
C  GETHEDCCP4(BUF,NSAM,NROW,NSLICE,MODE,DMIN,DMAX,DMEAN,RMS,
C             NSYM,IRTFLG)           *                                                              *
d149 1
a149 1
     &       NLABL
d165 1
d232 1
a232 1
C -----------------------------------------------------------
@
