head	1.36;
access;
symbols
	healthdept_2018:1.36
	pre_getangas:1.32
	GPL2010:1.32
	pre_GPL2010:1.31
	pre_var_equation:1.31
	pre_fftwrings:1.31
	pre_opfiles:1.31
	src:1.31
	best-code:1.31
	x-named-regs:1.31
	x:1.31
	v13-00:1.31
	pre_GPL:1.29
	prec_CA:1.29
	noindx:1.28
	Bproc:1.26
	oct21:1.21
	last77:1.19;
locks; strict;
comment	@c @;


1.36
date	2018.10.03.14.34.05;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2013.06.14.13.40.13;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.10.15.33.41;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.21.16.29.31;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.24.13.25.34;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2005.10.17.20.01.41;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.17.17.57.22;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.20.19.40.10;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.11.14.07.50;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.22.20.56.34;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2000.08.04.21.20.47;	author bimal;	state Exp;
branches;
next	1.25;

1.25
date	2000.08.04.20.58.04;	author bimal;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.12.19.24.52;	author bimal;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.06.18.28.12;	author bimal;	state Exp;
branches;
next	1.22;

1.22
date	99.12.03.20.33.34;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	99.04.16.19.23.49;	author pawel;	state Exp;
branches;
next	1.20;

1.20
date	99.04.16.14.12.01;	author pawel;	state Exp;
branches;
next	1.19;

1.19
date	99.03.01.18.47.08;	author pawel;	state Exp;
branches;
next	1.18;

1.18
date	99.03.01.14.39.11;	author pawel;	state Exp;
branches;
next	1.17;

1.17
date	98.04.06.19.56.50;	author pawel;	state Exp;
branches;
next	1.16;

1.16
date	98.04.06.18.54.47;	author pawel;	state Exp;
branches;
next	1.15;

1.15
date	97.10.17.15.18.45;	author pawel;	state Exp;
branches;
next	1.14;

1.14
date	97.10.06.20.43.27;	author pawel;	state Exp;
branches;
next	1.13;

1.13
date	97.08.15.15.00.37;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	97.08.15.13.38.30;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	96.12.03.15.28.59;	author mladjadj;	state Exp;
branches;
next	1.10;

1.10
date	96.11.27.20.47.17;	author mladjadj;	state Exp;
branches;
next	1.9;

1.9
date	95.08.09.13.39.13;	author mladjadj;	state Exp;
branches;
next	1.8;

1.8
date	95.08.08.17.30.51;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	95.07.28.15.17.42;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	95.04.05.15.25.14;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	95.03.17.18.07.28;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	94.09.28.19.48.52;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	94.09.28.19.18.34;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.04.52;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.48.36;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.36
log
@email_health_dept
@
text
@C++*********************************************************************
C
C FALB
C              B-SPLINE INTERPOLATION INTRODUCED              09/21/89
C              RESTRICTION OF THE INTERPOLATION FIELD         10/13/89
C              SUBTRACTION OF ONE IMAGE                       03/27/91 
C              QUADRATIC INTERPOLATION USED AS AN OPTION      06/24/91
C              SCRATCH FILE ON THE DISK                       08/01/91
C              PROMPTS                             JAN 02 ARDEAN LEITH
C              OPFILEC                             FEB 03 ARDEAN LEITH
C              FALB_P INSERTED                     MAR 12 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2012  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C         FALB
C         FALB_P(BUF,ILIST,NX,NY,LSAM,LROW,NIMA,
C         ANG(RKK,MODE)
C         ENER(CIRC,LCIRC,NRING,NUMR,MODE)
C         ALPRBS(NUMR,NRING,LCIRC,MODE)
C         ALRQ
C         UPDTC(CIRC1,CIRC2,LCIRC,NRING,NUMR,TOT,MAXRIN,IS)
C         OUTRNG
C         CROSRNG
C         FOURING(CIRC,LCIRC,NUMR,NRING,E,MODE)
C         LOG2(N)
C         PRB1D(B,NPOINT,POS)
C         FFTR_D(X,NV)   
C         FFTC_D(BR,BI,LN,KS)
C
C         USES NON-FFTW FOURIER
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

        SUBROUTINE FALB

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'   

        INTEGER, ALLOCATABLE  :: NUMR(:,:)

        CHARACTER(LEN=MAXNAM) :: FINPAT,FINPIC

        INTEGER               :: MAXRIN
        CHARACTER(LEN=1)      :: MODE,ASK
        CHARACTER(LEN=1)      :: NULL = CHAR(0) 
        LOGICAL               :: FOUROK = .FALSE.

        INTEGER, PARAMETER    :: INPIC = 77
        INTEGER,PARAMETER     :: LUNXM = 0  ! SELFILE NOT ALLOWED

C       OPEN INPUT IMAGE(S)
        MAXIM  = 0
        NILMAX = NIMAX
        CALL OPFILES(0,INPIC,LUNDOC,LUNXM, 
     &             .TRUE.,FINPAT,NLET, 'O',
     &             IFORM,NX,NY,NZ,MAXIM,
     &             'INPUT FILE TEMPLATE (E.G. PIC****)~',
     &             FOUROK,INUMBR,NILMAX, 
     &             NDUM,NIMA,IMGNUM, IRTFLG) 
        IF (IRTFLG .NE. 0) RETURN
        CLOSE(INPIC)

C       NIMA - TOTAL NUMBER OF IMAGES
        IF (NIMA > 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT('  Number of images: ',I5)
        ELSE
           CALL ERRT(100,'NO IMAGES',NDUM)
           RETURN
        ENDIF
	 
        MR    = 5
        NRAD  = MIN(NX/2-1, NY/2-1)
        NR    = NRAD
        ISKIP = -1    ! TRAP FOR OLD STYLE INPUT

        CALL RDPRI3S(MR,NR,ISKIP,NOT_USED,
     &       'FIRST, LAST RING, & RING SKIP,',IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999

        IF (ISKIP < 0) THEN
            CALL RDPRI1S(ISKIP,NOT_USED,'RING SKIP',IRTFLG)
            IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF
        ISKIP = MAX(1,ISKIP)

	IF (MR <= 0) THEN
	   CALL ERRT(101,'FIRST RING MUST BE > 0',NE)
	   GOTO 9999

	ELSEIF (NR < MR)  THEN 
	   CALL ERRT(102,'LAST RING MUST BE > ',MR)
	   GOTO 9999

	ELSEIF (NR >= NRAD)  THEN 
	   CALL ERRT(102,'LAST RING MUST BE < ',NRAD)
	   GOTO 9999
        ENDIF

        CALL  RDPRMC(ASK,NA,.TRUE.,
     &               'ANALYZE FULL OR HALF RING? (F/H)',
     &                NULL,IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999

        IF (ASK == 'F')  THEN
           MODE = 'F'
        ELSEIF (ASK == 'H')  THEN
           MODE = 'H'
        ELSE
	   CALL ERRT(101,'INVALID RESPONSE',NRAD)
	   GOTO 9999
        ENDIF

C       CALL  RDPRMI(JACUP,NDUMP,NOT_USED,
C     &         'Precision of peak location (0..100)')
C       JACUP=MAX0(0,MIN0(100,JACUP))
        JACUP=0

C       FIND TOTAL NUMBER OF RINGS
        NRING = 0
        DO I=MR,NR,ISKIP
           NRING = NRING + 1
        ENDDO

        ALLOCATE (NUMR(3,NRING), STAT=IRTFLG)
        IF (IRTFLG .NE. 0) THEN 
           CALL ERRT(46,'FALB; NUMR',3*NRING)
           GOTO 9999
        ENDIF

C       FILL RINGS POINTER
        NRING = 0
        DO I=MR,NR,ISKIP
           NRING         = NRING + 1
           NUMR(1,NRING) = I
        ENDDO
 
C       CALCULATION OF ACTUAL DIMENSION OF AN IMAGE TO BE INTERPOLATED
C       2*(NO. OF RINGS)+(0'TH ELEMENT)+2*(MARGIN OF 1)

        NRA  = MIN(((NX-1)/2)*2+1, ((NY-1)/2)*2+1, 2*NR+3)
        LSAM = NX
        LROW = NY
        NX   = NRA
        NY   = NRA

C       FILL NUMR
        CALL ALPRBS(NUMR,NRING,LCIRC,MODE)

        MAXRIN = NUMR(3,NRING)  ! CORRECT AS NOT FFTW al
 
        CALL  FALB_P(INUMBR,NX,NY,LSAM,LROW,NIMA,
     &               NRING,LCIRC,MAXRIN,JACUP,NUMR,MODE, FINPAT,NLET)

9999    IF (ALLOCATED(NUMR)) DEALLOCATE(NUMR)

        END


C++*********************************************************************
C
C FALB_P.F                ROT FIXED & RANDOMIZED JULY 2000 ARDEAN LEITH
C
C **********************************************************************
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

	SUBROUTINE  FALB_P(ILIST,NX,NY,LSAM,LROW,NIMA,
     &          NRING,LCIRC,MAXRIN,JACUP,NUMR,MODE, FINPAT,NLET)

C       BUFIN,ROT,CIROLD,CIRNEW,CIRTMP,TEMP,EC ARE AUTOMATIC ARRAYS
	
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'   

        REAL, ALLOCATABLE  :: X(:,:),CIRC(:,:) 

        INTEGER            :: MAXRIN,MAXRI,NUMR(3,NRING)
        REAL               :: BUFIN(LSAM),DIST(NIMA)
        REAL               :: CIROLD(LCIRC),CIRNEW(LCIRC),CIRTMP(LCIRC)
        DOUBLE PRECISION   :: TEMP(MAXRIN,2)
        DOUBLE PRECISION   :: ENER,TOTMIN,SOLD,SNEW,EAV,EC(NIMA)
        INTEGER            :: ILIST(NIMA)
        REAL               :: DLIST(5),ROT(NIMA)
        LOGICAL            :: NEWFILE

        INTEGER            :: NLET
        LOGICAL*1          :: CH_ANG
        CHARACTER(LEN=1)   :: MODE

        CHARACTER(LEN=MAXNAM) :: FINPIC,FINPAT,OUTDOC
        CHARACTER(LEN=MAXNAM) :: MSG

        COMMON  /MXR/ MAXRI
C       MXR in: ang.f,gali.f,hali_p.f

        INTEGER,PARAMETER    :: INPIC  = 77
        INTEGER,PARAMETER    :: LUNDOC = 80   

        MAXRI = MAXRIN

        LQ  = LROW/2+1
        LR1 = (NY-1)/2
        LR2 = LQ+LR1
        LR1 = LQ-LR1
        LQ  = LSAM/2+1
        LS1 = (NX-1)/2
        LS2 = LQ+LS1
        LS1 = LQ-LS1

        ALLOCATE (X(NX,NY), CIRC(LCIRC,NIMA), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           MWANT = NX*NY + LCIRC*NIMA 
           CALL ERRT(46,'FALB_P; X',MWANT)
           RETURN
        ENDIF

        DO K1=1,NIMA

           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(101,'FILE DOES NOT EXIST',NE)
              GOTO 9999
           ENDIF

           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &           NXT,NYT,NSL,MAXIM,'DUMMY',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999

           DO K2=LR1,LR2
              CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
              DO K3=LS1,LS2
                 X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
              ENDDO
           ENDDO
       
           CLOSE(INPIC)

           CALL ALRQ(X,NX,NY,NUMR,CIRC(1,K1),LCIRC,NRING,MODE,K1)
           CALL FOURING(CIRC(1,K1),LCIRC,NUMR,NRING,EC(K1),MODE)

        ENDDO

C       BUILD FIRST AVERAGE

C       TWO ESTIMATION OF INITIAL AVERAGE ARE USED
C       ONLY ONE !!!  11/06/91

C          DIST IS USED HERE FOR THE RANDOM CHOOSING OF IMAGES

           DO IMI=1,NIMA
              DIST(IMI) = 0.0
           ENDDO

           CALL RANDOM_NUMBER(CIID)
           IMI = MIN(NIMA,MAX0(1, INT(CIID*NIMA+0.5)))

           DO I=1,LCIRC
              CIROLD(I) = CIRC(I,IMI)
           ENDDO

           ROT(IMI)  = 1.0
           DIST(IMI) = 1.0

C          write(nout,*) 'rot(',imi,'):',rot(imi),ciid,nima,dist(imi)
           DO KTN=2,NIMA

804           CALL RANDOM_NUMBER(CIID) 
              M = MIN(NIMA, MAX(1, INT(CIID*(NIMA-KTN+1)+0.5)))

              IMI = 0
              DO I=1,NIMA
                 IF (DIST(I) .NE. 1.0)  THEN
                    IMI = IMI + 1
                    IF (IMI == M)  GOTO 810
                 ENDIF
809           CONTINUE
              ENDDO
              GOTO  804

810           IMI       = I
              DIST(IMI) = 1.0

              CALL CROSRNG(CIROLD,CIRC(1,IMI),LCIRC,NRING,TEMP,
     &             TEMP(1,2),MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)

              ROT(IMI) = TOT

C             write(nout,*) 'rot(',imi,'):',rot(imi),ciid,m,dist(imi),i
              CALL UPDTC(CIROLD,CIRC(1,IMI),LCIRC,NRING,NUMR,
     &                   TOT,MAXRIN,KTN)
           ENDDO

           SOLD = ENER(CIROLD,LCIRC,NRING,NUMR,MODE)
           WRITE(NOUT,2037)  SOLD
2037      FORMAT('  Random approximation: 1,  Squared sum:    ',1PE12.5)

           DO I=1,LCIRC
              CIRNEW(I) = CIROLD(I)
           ENDDO
                 
C       PRINT  *,SOLD*FLOAT(NIMA)/(NIMA-1)
C       PRINT  2001,(ANG(ROT(J),MODE),J=1,NIMA)
2001    FORMAT(8(1X,F8.3))

C       ITERATIONS TO GET BETTER APPROXIMATION

        ITER = 0
901     CONTINUE

        ITER   = ITER+1
        CH_ANG = .FALSE.

        DO IMI=1,NIMA
           CALL OUTRNG(CIROLD,CIRC(1,IMI),CIRTMP,LCIRC,NRING,
     &                 NUMR,ROT(IMI),MAXRIN,NIMA)

           CALL CROSRNG(CIRTMP,CIRC(1,IMI),LCIRC,NRING,TEMP,
     &               TEMP(1,2),MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)

           IF (ROT(IMI) .NE. TOT)  THEN
              CH_ANG   = .TRUE.
              ROT(IMI) = TOT
           ENDIF

          CALL UPDTC(CIRNEW,CIRC(1,IMI),LCIRC,NRING,NUMR,TOT,MAXRIN,IMI)

        ENDDO

        SNEW = ENER(CIRNEW,LCIRC,NRING,NUMR,MODE)

        WRITE(NOUT,2030)  ITER,SNEW
2030    FORMAT('  Iteration:         ',I4,',  New squared sum:',1PE12.5)

        IF (SNEW .GE. SOLD .AND. CH_ANG)  THEN
           DO  I=1,LCIRC 
              CIROLD(I) = CIRNEW(I)
           ENDDO
           SOLD = SNEW
           GOTO  901
        ENDIF

        !IF (VERBOSE) WRITE(NOUT,*1) ' ANGLES:'
        !IF (VERBOSE) WRITE(NOUT,2001) (ANG(ROT(J),MODE),J=1,NIMA)

C       OPEN ALIGNMENT OUTPUT DOC FILE 
        CALL OPENDOC(OUTDOC,.TRUE.,NLET,LUNDOC,LUNDOCO,.TRUE.,
     &                   'CLASSIFICATION & ALIGNMENT DOC FILE',
     &              .FALSE.,.FALSE.,.TRUE.,NEWFILE,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999

C            123456789 123456789 123456789 123456789 123456789
        MSG='         FILE#         ANGLE      DIST/MIR         GROUP'
        CALL LUNDOCPUTCOM(LUNDOCO,MSG,IRTFLG)

        DLIST(4) = 1.0   ! FOR CONSISTENCY WITH 'AP C'

        DO   IMI=1,NIMA
C          CALCULATE DISTANCES
           CALL  OUTRNG(CIROLD,CIRC(1,IMI),CIRTMP,LCIRC,NRING,
     &           NUMR,ROT(IMI),MAXRIN,NIMA)

           CALL CROSRNG (CIRTMP,CIRC(1,IMI),LCIRC,NRING,TEMP,
     &          TEMP(1,2), MAXRIN,JACUP,NUMR,TOTMIN,TOT,MODE)

           EAV      = ENER(CIRTMP,LCIRC,NRING,NUMR,MODE)

           DLIST(1) = ILIST(IMI)
           DLIST(2) = ANG(ROT(IMI),MODE)  ! FUNCTION CALL
           DLIST(3) = EAV + EC(IMI) - 2.0 * TOTMIN

           CALL LUNDOCWRTDAT(LUNDOC,IMI,DLIST,4,IRTFLG)

           !!CALL SAVD(NDOC,DLIST,5,IRTFLG)
        ENDDO

        CLOSE(LUNDOC)

9999    IF (ALLOCATED(X))    DEALLOCATE(X)
        IF (ALLOCATED(CIRC)) DEALLOCATE(CIRC)

        END
@


1.35
log
@comment
@
text
@d19 1
a19 1
C=* Email: spider@@wadsworth.org                                        *
@


1.34
log
@MAXRIN CORRECT AS NOT FFTW al msg added
@
text
@d218 1
a218 1
C       MXR in: ang.f,angmor.f,gali.f,hali_p.f,oracfmsk.f,oracfmskm.f
@


1.33
log
@combined falb & falb_p  ,  falb rewrite
@
text
@d50 2
d171 1
a171 1
        MAXRIN = NUMR(3,NRING)
d310 1
d312 1
@


1.32
log
@GPL_2010
@
text
@d4 8
a11 2
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   OPFILEC                       FEB 03 ARDEAN LEITH
d17 1
a17 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d35 14
a48 22
C  B-spline interpolation introduced 09/21/89
C  Restriction of the interpolation field 10/13/89
C  Subtraction of one image 03/27/91   -  FALB
C  Quadratic interpolation used as an option. 06/24/91
C  Scratch file on the disk   08/01/91
c
c         FALB
c         FALB_P(BUF,ILIST,NSAM,NROW,LSAM,LROW,NIMA,
c         ANG(RKK,MODE)
c         ENER(CIRC,LCIRC,NRING,NUMR,MODE)
c         ALPRBS(NUMR,NRING,LCIRC,MODE)
c         ALRQ
c         UPDTC(CIRC1,CIRC2,LCIRC,NRING,NUMR,TOT,MAXRIN,IS)
c         OUTRNG
c         CROSRNG
c         FOURING(CIRC,LCIRC,NUMR,NRING,E,MODE)
c         LOG2(N)
c         PRB1D(B,NPOINT,POS)
c         FFTR_D(X,NV)   
c         FFTC_D(BR,BI,LN,KS)
C
C IMAGE_PROCESSING_ROUTINE
d58 1
a58 2
        INTEGER, ALLOCATABLE, DIMENSION(:) :: ILIST
        INTEGER, ALLOCATABLE, DIMENSION(:,:) :: NUMR
d60 1
a60 2
        COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
        CHARACTER*80  FINPIC, FINPAT
d62 4
a65 2
        INTEGER      MAXRIN
        CHARACTER*1  MODE,NULL,ASK
d67 2
a68 1
        DATA  INPIC/77/
d70 2
d73 6
a78 11
        NULL=CHAR(0)

        ALLOCATE (ILIST(NILMAX), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'AP RA, ILIST',IER)
           RETURN
        ENDIF

C       ASK FOR DATA FILE
        CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NIMA,
     &      'ENTER TEMPLATE FOR 2-D IMAGE SERIES',IRTFLG)
d80 1
d83 1
a83 1
        IF (NIMA .GT. 0)  THEN
d85 1
a85 1
2001       FORMAT(' Number of images: ',I5)
a87 1
           DEALLOCATE(ILIST)
d90 13
a102 11
	
C       GET IMAGE SIZE
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
     &              MAXIM,' ',.FALSE.,IRTFLG)
        CLOSE(INPIC)
        IF (IRTFLG .NE. 0)  THEN
           DEALLOCATE(ILIST)
           RETURN
d104 1
a104 2
 
        CALL  RDPRMI(MR,NR,NOT_USED,'FIRST AND LAST RING')
d106 11
a116 4
        IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
           CALL ERRT(31,'OR 2',NE)
           DEALLOCATE(ILIST)
           RETURN
d119 9
a127 9
        CALL  RDPRMI(ISKIP,NDUMP,NOT_USED,'SKIP')
        ISKIP=MAX0(1,ISKIP)
7981    NA=1
        CALL  RDPRMC(ASK,NA,.TRUE.,'(F)ULL OR (H)ALF CIRCLE',NULL,IRT)

        IF (ASK.EQ.'F')  THEN
           MODE='F'
        ELSEIF (ASK.EQ.'H')  THEN
           MODE='H'
d129 2
a130 2
           DEALLOCATE(ILIST)
           RETURN
d139 3
a141 3
        NRING=0
        DO    I=MR,NR,ISKIP
           NRING=NRING+1
d145 3
a147 4
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'AP RA, NUMR',IER)
           DEALLOCATE (ILIST)
           RETURN
d150 5
a154 5

        NRING=0
        DO    I=MR,NR,ISKIP
           NRING=NRING+1
           NUMR(1,NRING)=I
d160 8
a167 6
        NRA=MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1,2*NR+3)
        LSAM=NSAM
        LROW=NROW
        NSAM=NRA
        NROW=NRA
        CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
d169 1
a169 1
        MAXRIN=NUMR(3,NRING)
d171 2
a172 2
        CALL  FALB_P(ILIST,NSAM,NROW,LSAM,LROW,NIMA,
     &               NRING,LCIRC,MAXRIN,JACUP,NUMR,MODE,NOUT)
d174 1
a174 6
         WRITE (NOUT,2600)
2600     FORMAT (/ ' ',72('-')//,
     &             ' ','ROTATIONAL ALIGNMENT -- END OF COMPUTATION',//,
     &             ' ',72('-')/)

        DEALLOCATE (ILIST, NUMR)
a183 1
C **********************************************************************
a184 1
C IMAGE_PROCESSING_ROUTINE
a185 1
C        1         2         3         4         5         6         7
d189 2
a190 2
	SUBROUTINE  FALB_P(ILIST,NSAM,NROW,LSAM,LROW,NIMA,
     &          NRING,LCIRC,MAXRIN,JACUP,NUMR,MODE,NOUT)
d192 1
a192 1
C       BUFIN,ROT,CIROLD,CIRNEW,CIRTMP,TEMP,EC AND DIST ARE AUTOMATIC ARRAYS
d194 2
a195 1
        REAL, ALLOCATABLE, DIMENSION(:,:) :: X,CIRC 
d197 1
a197 1
        PARAMETER  (NLIST=5)
d199 12
a210 6
        INTEGER  MAXRIN,MAXRI,NUMR(3,NRING)
        DIMENSION  BUFIN(LSAM),DIST(NIMA)
        DIMENSION  CIROLD(LCIRC),CIRNEW(LCIRC),CIRTMP(LCIRC)
        DOUBLE PRECISION TEMP(MAXRIN,2)
        DOUBLE PRECISION ENER,TOTMIN,SOLD,SNEW,EAV,EC(NIMA)
        DIMENSION  ILIST(NIMA),DLIST(NLIST),ROT(NIMA)
d212 2
a213 1
        CHARACTER*80  FINPIC,FINPAT
d215 2
a216 2
        COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
        COMMON  /MXR/  MAXRI
d218 2
a219 4
        LOGICAL*1    CH_ANG
        CHARACTER*1  MODE
 
        DATA  INPIC/77/,NDOC/55/
d224 1
a224 1
        LR1 = (NROW-1)/2
d228 1
a228 1
        LS1 = (NSAM-1)/2
d232 1
a232 7
        ALLOCATE (X(NSAM,NROW), STAT=IRTFLG)
        IF (IRTFLG.NE.0) THEN 
           CALL ERRT(46,'AP RA, X',IER)
           RETURN
        ENDIF

        ALLOCATE (CIRC(LCIRC,NIMA), STAT=IRTFLG)
d234 2
a235 2
           CALL ERRT(46,'AP RA, CIRC',IER)
           DEALLOCATE (X)
d241 1
a241 1
           CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
d243 2
a244 3
              CALL ERRT(18,'AP RA ',NE)
              DEALLOCATE (X,CIRC)     
              RETURN
d249 2
a250 7
     &           NSAMT,NROWT,NSL,MAXIM,'DUMMY',.FALSE.,IRTFLG)
          
           IF (IRTFLG .NE. 0)  THEN
              CALL ERRT(4,'AP RA ',NE)
              DEALLOCATE (X,CIRC)
              RETURN
           ENDIF
d255 1
a255 1
                 X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
d261 1
a261 1
           CALL ALRQ(X,NSAM,NROW,NUMR,CIRC(1,K1),LCIRC,NRING,MODE,K1)
d278 1
a278 1
           IMI = MIN0(NIMA,MAX0(1,INT(CIID*NIMA+0.5)))
d283 1
d291 1
a291 1
              M = MIN0(NIMA,MAX0(1,INT(CIID*(NIMA-KTN+1)+0.5)))
d297 1
a297 1
                    IF (IMI. EQ. M)  GOTO 810
d316 1
a316 1
2037       FORMAT(' Random approximation #1,  Squared sum =',1PE12.5)
d328 1
a328 1
        ITER=0
d338 1
a338 1
           CALL  CROSRNG(CIRTMP,CIRC(1,IMI),LCIRC,NRING,TEMP,
d345 1
d350 2
a351 1
        SNEW=ENER(CIRNEW,LCIRC,NRING,NUMR,MODE)
d353 3
a355 2
2030    FORMAT('  Iteration #',I4,'  New squared sum =',1PE12.5)
        IF (SNEW.GE.SOLD .AND. CH_ANG)  THEN
d357 1
a357 1
              CIROLD(I)=CIRNEW(I)
d363 15
a377 2
        WRITE(NOUT,2001)  (ANG(ROT(J),MODE),J=1,NIMA)
        DLIST(5) = 1.0
d387 8
a394 5
           DLIST(1) = IMI
           DLIST(2) = ILIST(IMI)
           DLIST(3) = ANG(ROT(IMI),MODE)
           DLIST(4) = EAV+EC(IMI)-2.0*TOTMIN
           CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
a395 2
        CALL  SAVDC
        CLOSE(NDOC)
d397 5
a401 1
        DEALLOCATE (X,CIRC)
@


1.31
log
@GPL License fixed
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
a183 23
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
C=*                                                                    *
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* This program is distributed in the hope that it will be useful,    *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
C=*                                                                    *
@


1.30
log
@HRI GPL License used
@
text
@a1 1
C++************************************************************************
a7 3
C **************************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
d11 1
a11 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a30 7

C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
a31 1
C **************************************************************************
a57 1
C--************************************************************************
a183 1
C++************************************************************************
a187 3
C **************************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK         *
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
d191 1
a191 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a210 7

C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH                              *
a211 1
C **************************************************************************
a217 1
C--************************************************************************
@


1.29
log
@opfilec
@
text
@d1 1
d8 1
d10 1
d12 24
d42 1
d69 1
d196 1
d201 1
d203 1
d205 24
d235 1
d242 1
@


1.28
log
@nloop,iloop_removed
@
text
@d5 1
d53 2
a54 1
        INTEGER  MAXRIN
d56 1
d87 1
a87 1
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d247 2
a248 2
           CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',NSAMT,NROWT,NSL,
     &                   MAXIM,'DUMMY',.FALSE.,IRTFLG)
@


1.27
log
@prompts
@
text
@d92 1
a92 1
        CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
d100 1
a100 1
        CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
d114 1
a114 1
C       CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
@


1.26
log
@*** empty log message ***
@
text
@d3 2
a4 1
C 
d22 14
a35 14
c       SUBROUTINE FALB
c       SUBROUTINE  FALB_P(BUF,ILIST,NSAM,NROW,LSAM,LROW,NIMA,
c       FUNCTION  ANG(RKK,MODE)
c       DOUBLE PRECISION FUNCTION  ENER(CIRC,LCIRC,NRING,NUMR,MODE)
c       SUBROUTINE  ALPRBS(NUMR,NRING,LCIRC,MODE)
c       SUBROUTINE  ALRQ
c       SUBROUTINE  UPDTC(CIRC1,CIRC2,LCIRC,NRING,NUMR,TOT,MAXRIN,IS)
c       SUBROUTINE  OUTRNG
c       SUBROUTINE  CROSRNG
c       SUBROUTINE  FOURING(CIRC,LCIRC,NUMR,NRING,E,MODE)
c       FUNCTION  LOG2(N)
c       SUBROUTINE PRB1D(B,NPOINT,POS)
c       SUBROUTINE  FFTR_D(X,NV)   
c       SUBROUTINE  FFTC_D(BR,BI,LN,KS)
a38 1
C        1         2         3         4         5         6         7
a43 1

a65 1

d67 1
a67 1
     &    'ENTER TEMPLATE FOR 2-D IMAGE NAME',IRTFLG)
d70 1
a70 1
C       NIMA - total number of images
d73 1
a73 1
2001       FORMAT('  Number of images =',I5)
d75 1
a75 2
           WRITE(NOUT,*)  '*** NO IMAGES!'
           CALL ERRT(100,'AP CA ',NDUM)
d80 1
d86 1
a87 1
           CALL ERRT(4,'AP RA ',NE)
a90 1
        CLOSE(INPIC)
a99 2


d105 1
a105 1
        IF(ASK.EQ.'F')  THEN
d107 1
a107 1
        ELSEIF(ASK.EQ.'H')  THEN
d154 4
a157 3
        WRITE (NOUT,2600)        
 2600   FORMAT (/ ' ',80('-')//' ',' Rotational alignment,  ',
     &      'end of computation',//' ',80('-')/)
d161 220
@


1.25
log
@*** empty log message ***
@
text
@d31 1
a31 1
c       FUNCTION  LOG(N)
@


1.24
log
@no message for small 1st ring
@
text
@d31 1
a31 1
c       FUNCTION  LOG2_P(N)
@


1.23
log
@adapted for dynamical memory allocation
@
text
@d103 1
a103 4
        IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021    FORMAT(' SMALL VALUE OF THE FIRST RING GIVEN (',I1,') MAY'
     &  ' RESULT IN NUMERICAL ERRORS',/,
     & ' PLEASE VERIFY THE RESULTS OR INCREASE FIRST RING VALUE TO 5')
@


1.22
log
@ # continue char fails on NT f90
@
text
@a0 1

d12 1
a12 1
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
d21 45
a65 39
c	SUBROUTINE FALB(MAXMEM)
c   	SUBROUTINE  FALB_P(BUF,ILIST,NSAM,NROW,LSAM,LROW,NIMA,
c	FUNCTION  ANG(RKK,MODE)
c	DOUBLE PRECISION FUNCTION  ENER(CIRC,LCIRC,NRING,NUMR,MODE)
c	SUBROUTINE  ALPRBS(NUMR,NRING,LCIRC,MODE)
c 	SUBROUTINE  ALRQ
c	SUBROUTINE  UPDTC(CIRC1,CIRC2,LCIRC,NRING,NUMR,TOT,MAXRIN,IS)
c	SUBROUTINE  OUTRNG
c	SUBROUTINE  CROSRNG
c	SUBROUTINE  FOURING(CIRC,LCIRC,NUMR,NRING,E,MODE)
c	FUNCTION  LOG2_P(N)
c	SUBROUTINE PRB1D(B,NPOINT,POS)
c 	SUBROUTINE  FFTR_D(X,NV)   
c	SUBROUTINE  FFTC_D(BR,BI,LN,KS)


	SUBROUTINE FALB(MAXMEM)

	PARAMETER  (NILMAX=10000) 
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
        INCLUDE 'CMBLOCK.INC'   
        COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),BAF(1)
        EQUIVALENCE  (BAF,NUMR) 
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: Q
#else
        DIMENSION Q(1)
        POINTER   (IPQ,Q) 
#endif
        LOGICAL   RUNTIME
	COMMON  /F_SPEC/  FINPAT,NLET,FINPIC
	CHARACTER*80  FINPIC
	CHARACTER*80  FINPAT
	INTEGER  MAXRIN
	CHARACTER*1  MODE,NULL,ASK
	DATA  INPIC/77/
d67 5
a71 5
        NULL=CHAR(0)
	NMAX=NILMAX
 	CALL  FILSEQP(FINPAT,NLET,ILIST,NMAX,NIMA,
     &	  'Enter template for 2-D image name',IRTFLG)
     
d73 16
a88 3
 	CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
 	CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
 	IF(NF.NE.2)  THEN
d90 4
a93 3
	   RETURN
	ENDIF
	CLOSE(INPIC)
d95 16
a110 14
	CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
C
	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	CALL ERRT(31,'OR 2',NE)
	RETURN
	ENDIF
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
	ISKIP=MAX0(1,ISKIP)
7981	NA=1
d112 13
a124 10
	IF(ASK.EQ.'F')  THEN
	MODE='F'
	ELSEIF(ASK.EQ.'H')  THEN
	MODE='H'
	ELSE
	RETURN
	ENDIF
C	CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
C     &		'Precision of peak location (0..100)')
C	JACUP=MAX0(0,MIN0(100,JACUP))
d126 20
a145 6
C
	NRING=0
	DO    I=MR,NR,ISKIP
	NRING=NRING+1
	NUMR(1,NRING)=I           
	ENDDO
d147 11
a157 66
C       Calculation of actual dimension of an image to be interpolated
C       2*(No. of rings)+(0'th element)+2*(margin of 1)
	NRA=MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1,2*NR+3)
	LSAM=NSAM
	LROW=NROW
	NSAM=NRA
	NROW=NRA
	CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
C
C   memory division
C	NUMR	       1
C	CIRC	       2
C       EC             7  ! Double precision !
C A: X     B: ROT      3
C    BUFIN    CIROLD   4
C    WORK     CIRNEW   5
C             CIRTMP   0
C             TEMP     6
C             DIST     7
C
	MAXRIN=NUMR(3,NRING)
        K1=-1
        K2=1
	K7=IPALIGN64(K2+LCIRC*NIMA)
	K3A=IPALIGN64(K7+NIMA*2)
	K41A=IPALIGN64(K3A+NSAM*NROW)
	K4A=IPALIGN64(K41A+LSAM)
	K5A=K4A
	K3B=K3A
	K4B=IPALIGN64(K3B+NIMA)
	K5B=IPALIGN64(K4B+LCIRC)
	K0B=IPALIGN64(K5B+LCIRC)
	K6B=IPALIGN64(K0B+LCIRC)
	K7B=IPALIGN64(K6B+MAXRIN*4)
	K8B=IPALIGN64(K7B+NIMA)
	MEMTOT=MAX0(K5A,K8B)
	
        CALL CHKMEM(MEMTOT, BAF, MAXMEM-(NILMAX+1200), 
     &	            RUNTIME,IPQ,IRTFLG)
	IF(IRTFLG.EQ.0) THEN
           IF (.NOT.RUNTIME)  THEN  
	   
c	      not enougth memory can be allocated, check common block
              K1=1
              K2=IPALIGN64(K1+3*NRING)
	      K7=IPALIGN64(K2+LCIRC*NIMA)
	      K3A=IPALIGN64(K7+NIMA*2)
	      K41A=IPALIGN64(K3A+NSAM*NROW)
	      K4A=IPALIGN64(K41A+LSAM)
	      K5A=K4A
	      K3B=K3A
	      K4B=IPALIGN64(K3B+NIMA)
	      K5B=IPALIGN64(K4B+LCIRC)
	      K0B=IPALIGN64(K5B+LCIRC)
	      K6B=IPALIGN64(K0B+LCIRC)
	      K7B=IPALIGN64(K6B+MAXRIN*4)
	      K8B=IPALIGN64(K7B+NIMA)
	      MEMTOT=MAX0(K5A,K8B)
              CALL CHKMEM(MEMTOT, BAF, MAXMEM-(NILMAX+1200), 
     &	            RUNTIME,IPQ,IRTFLG)
	      IF(IRTFLG.NE.0) THEN
	         WRITE(NOUT,*)  '  Sorry, not enough memory !'
	      ENDIF
	   ELSE
	      WRITE(NOUT,*)  '  Sorry, not enough memory !'
	   ENDIF
d159 4
a162 18
           WRITE (NOUT,2500)  MAXMEM , MEMTOT
#ifdef SP_F90
         Q = >IPQ
#endif
    	   CALL  FALB_P(BUF,ILIST,NSAM,NROW,LSAM,LROW,NIMA,
     &	                NRING,LCIRC,MAXRIN,JACUP,NUMR,
     &	                Q(K2),Q(K3A),Q(K4A),Q(K41A),Q(K3B),
     &	                Q(K4B),Q(K5B),Q(K0B),
     &	                Q(K6B),Q(K7),Q(K7B),MODE,NOUT)
           WRITE (NOUT,2600)
	
           IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'FALB',IRTFLG)
	ELSE
	    WRITE(NOUT,*)  '  Sorry, not enough memory !'
	ENDIF
	
 2500   FORMAT (/,'  MEMORY RESERVATION: YOU HAVE',              
     &       ' RESERVED ',I8,',  YOU NEED  ',I8 / )
d165 3
@


1.21
log
@,
@
text
@d1 15
d36 2
a37 1
c
d39 1
d110 1
a110 1
C       2*(# of rings)+(0'th element)+2*(margin of 1)
d193 1
a193 1
     #       ' RESERVED ',I8,',  YOU NEED  ',I8 / )
d195 1
a195 1
     #      'end of computation',//' ',80('-')/)
@


1.20
log
@*** empty log message ***
@
text
@a32 1

a68 3
C
	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
	ISKIP=MAX0(1,ISKIP)
@


1.19
log
@*** empty log message ***
@
text
@d61 13
a166 1

@


1.18
log
@ff
@
text
@d24 2
a38 2
 
	 
a42 1
	INTEGER  NUMR(3,480)
@


1.17
log
@*** empty log message ***
@
text
@d42 2
a43 2
	INTEGER*2  MAXRIN
	INTEGER*2  NUMR(3,480)
a45 3
CNO_SAVE

 
d128 1
a128 1
              K2=IPALIGN64(K1+(3*NRING+3)/2)
@


1.16
log
@f90 alloc
@
text
@d25 2
a26 2
        COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),KAF(1)
        EQUIVALENCE  (KAF,NUMR) 
d124 1
a124 1
        CALL CHKMEM(MEMTOT, KAF, MAXMEM-(NILMAX+1200), 
d145 1
a145 1
              CALL CHKMEM(MEMTOT, KAF, MAXMEM-(NILMAX+1200), 
@


1.15
log
@R
@
text
@d27 6
d35 1
d155 4
@


1.14
log
@*** empty log message ***
@
text
@d50 1
a50 1
 	CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'R',NF,NSL)
@


1.13
log
@*** empty log message ***
@
text
@d75 1
a75 1
	DO  1  I=MR,NR,ISKIP
d77 2
a78 1
1	NUMR(1,NRING)=I           
@


1.12
log
@ipalign64
@
text
@d23 1
a23 1
	PARAMETER  (NILMAX=5000) 
d36 1
a36 1
	INTEGER*2  NUMR(3,1000)
@


1.11
log
@change NOT. to .NOT.
@
text
@d102 4
a105 12
	K7=K2+LCIRC*NIMA
	K7=K7/2
        K7=K7*2+1
	K3A=K7+NIMA*2
	K3A=K3A/2
        K3A=K3A*2+1
	K41A=K3A+NSAM*NROW
	K41A=K41A/2
        K41A=K41A*2+1
	K4A=K41A+LSAM
	K4A=K4A/2
        K4A=K4A*2+1
a106 2
	K5A=K5A/2
        K5A=K5A*2+1
d108 6
a113 20
	K3B=K3B/2
        K3B=K3B*2+1
	K4B=K3B+NIMA
	K4B=K4B/2
        K4B=K4B*2+1
	K5B=K4B+LCIRC
	K5B=K5B/2
        K5B=K5B*2+1
	K0B=K5B+LCIRC
	K0B=K0B/2
        K0B=K0B*2+1
	K6B=K0B+LCIRC
	K6B=K6B/2
        K6B=K6B*2+1
	K7B=K6B+MAXRIN*4
	K7B=K7B/2
        K7B=K7B*2+1
	K8B=K7B+NIMA
	K8B=K8B/2
        K8B=K8B*2+1
d123 5
a127 15
              K2=K1+(3*NRING+3)/2
	      K2=K2/2
              K2=K2*2+1 
	      K7=K2+LCIRC*NIMA
	      K7=K7/2
              K7=K7*2+1
	      K3A=K7+NIMA*2
	      K3A=K3A/2
              K3A=K3A*2+1
	      K41A=K3A+NSAM*NROW
	      K41A=K41A/2
              K41A=K41A*2+1
	      K4A=K41A+LSAM
	      K4A=K4A/2
              K4A=K4A*2+1
a128 2
	      K5A=K5A/2
              K5A=K5A*2+1
d130 6
a135 21
	      K3B=K3B/2
              K3B=K3B*2+1
	      K4B=K3B+NIMA
	      K4B=K4B/2
              K4B=K4B*2+1
	      K5B=K4B+LCIRC
	      K5B=K5B/2
              K5B=K5B*2+1
	      K0B=K5B+LCIRC
	      K0B=K0B/2
              K0B=K0B*2+1
	      K6B=K0B+LCIRC
	      K6B=K6B/2
              K6B=K6B*2+1
	      K7B=K6B+MAXRIN*4
	      K7B=K7B/2
              K7B=K7B*2+1
	      K8B=K7B+NIMA
	      K8B=K8B/2
              K8B=K8B*2+1
	
a162 3
     
     
        RETURN
@


1.10
log
@use of chkmem instead of allocit
@
text
@d143 1
a143 1
           IF (NOT.RUNTIME)  THEN  
@


1.9
log
@add SP_ALLOC for allocit call
@
text
@d23 9
a31 15
	PARAMETER  (NILMAX=5000)
#ifdef SP_UNIX
        INCLUDE 'CMBLOCK.INC' 
#else
        INCLUDE 'COMMON1:CMBLOCK.INC' 
#endif
#ifdef SP_ALLOC
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),NUMR
         DIMENSION Q(1)
         POINTER   (IPQ,Q) 
         LOGICAL         RUNTIME
#else 
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),Q(1)
         EQUIVALENCE  (Q,NUMR)
#endif
d40 3
a42 3
C
C  ASK FOR DATA FILE
C
d47 2
a48 2
C  NIMA - total number of images
C
d52 2
a53 2
         CALL ERRT(4,'AP RA ',NE)
	RETURN
d56 1
a56 1
C
d70 1
a70 1
C     &	'Precision of peak location (0..100)')
d78 3
a80 4
C 
C Calculation of actual dimension of an image to be interpolated
C 2*(# of rings)+(0'th element)+2*(margin of 1)
C
a99 2
#ifdef SP_ALLOC
C K1 not used
a101 6
#else
         K1=1
         K2=K1+(3*NRING+3)/2
	K2=K2/2
        K2=K2*2+1
#endif
a137 1
#ifdef SP_ALLOC
d139 67
a205 18
         CALL ALLOCIT(MEMTOT,RUNTIME,IPQ,'FALB',IRTFLG)
	IF(RUNTIME)  THEN
#else
	MEMTOT=NILMAX+1200+MAX0(K5A,K8B)
C
        IF (MEMTOT .LE. MAXMEM)  THEN
#endif
C
C
      WRITE (NOUT,2500)  MAXMEM , MEMTOT
    	CALL  FALB_P(BUF,ILIST,NSAM,NROW,LSAM,LROW,NIMA,
     &	  NRING,LCIRC,MAXRIN,JACUP,NUMR,
     &	Q(K2),Q(K3A),Q(K4A),Q(K41A),Q(K3B),Q(K4B),Q(K5B),Q(K0B),
     &	      Q(K6B),Q(K7),Q(K7B),MODE,NOUT)
	WRITE (NOUT,2600)
#ifdef SP_ALLOC
      CALL ALLOCIT(0,RUNTIME,IPQ,'FALB',IRTFLG)
#endif
d207 1
a207 1
	WRITE(NOUT,*)  '  Sorry, not enough memory !'
d209 7
a216 4
 2500 FORMAT (/,'  MEMORY RESERVATION: YOU HAVE',              
     #    ' RESERVED ',I8,',  YOU NEED  ',I8 / )
 2600 FORMAT (/ ' ',80('-')//' ',' Rotational alignment,  ',
     #      'end of computation',//' ',80('-')/)
@


1.8
log
@dealloc corrected
@
text
@d26 4
d34 1
a34 2
#else
        INCLUDE 'COMMON1:CMBLOCK.INC' 
d107 1
a107 1
#ifdef SP_UNIX
d153 1
a153 1
#ifdef SP_UNIX
d170 1
a170 1
#ifdef SP_UNIX
@


1.7
log
@malloc
@
text
@d167 3
a172 3
#ifdef SP_UNIX
      CALL ALLOCIT(0,RUNTIME,IPQ,'FALB',IRTFLG)
#endif
@


1.6
log
@nilmax increased to 5000
@
text
@d26 4
d32 2
a34 1
	COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),Q(1)
a40 1
	EQUIVALENCE  (Q,NUMR)
d42 1
d55 1
a55 1
	WRITE(NOUT,*)  ' File not found'
d104 7
a110 2
	K1=1
	K2=K1+(3*NRING+1)/2
d113 1
d150 5
d157 2
a161 1
        IF (MEMTOT .LE. MAXMEM)  THEN
d170 3
@


1.5
log
@common aligned
@
text
@d23 1
a23 1
	PARAMETER  (NILMAX=4000)
@


1.4
log
@buffer on the disk removed
@
text
@d101 2
d104 2
d107 2
d110 2
d113 2
d116 2
d119 2
d122 2
d125 2
d128 2
d131 2
d134 2
d137 2
@


1.3
log
@imls removed
@
text
@d7 1
a7 1
c	SUBROUTINE FALB(MAXMEM,IB_D)
d22 1
a22 1
	SUBROUTINE FALB(MAXMEM,IB_D)
a30 1
	DIMENSION  IRETRANGE(2)
a98 1
	IF(IB_D.EQ.0)  THEN
a125 36
	ENDIF
	ELSE
	K1=1
	K7=K1+(3*NRING+1)/2
	K3A=K7+NIMA*2
	K41A=K3A+NSAM*NROW
	K4A=K41A+LSAM
	K5A=K4A
	K3B=K3A
	K4B=K3B+NIMA
	K5B=K4B+LCIRC
	K0B=K5B+LCIRC
	K6B=K0B+LCIRC
	K7B=K6B+MAXRIN*4
	K8B=K7B+NIMA
	MEMTOT=NILMAX+1200+MAX0(K5A,K8B)
C
C
C
      WRITE (NOUT,2500)  MAXMEM , MEMTOT
        IF (MEMTOT .LE. MAXMEM)  THEN
	NULL=CHAR(0)
	CALL  FILERD(FINPIC,NLET1,NULL,'Scratch',IRTFLG)
	FINPIC=FINPIC(1:NLET1)//'.'//DATEXC(1:3)
	MSPACE=LCIRC*NIMA
	CALL  PRIV(MSPACE,FINPIC,IRETRANGE)
C
    	CALL  FALB_P(BUF,ILIST,NSAM,NROW,LSAM,LROW,NIMA,
     &	  NRING,LCIRC,MAXRIN,JACUP,NUMR,
     &		%VAL(IRETRANGE(1)),
     &	Q(K3A),Q(K4A),Q(K41A),Q(K3B),Q(K4B),Q(K5B),Q(K0B),
     &	      Q(K6B),Q(K7),Q(K7B),MODE,NOUT)
	WRITE (NOUT,2600)
	ELSE
	WRITE(NOUT,*)  '  Sorry, not enough memory !'
	ENDIF
@


1.2
log
@cpp_lines_added
@
text
@a11 3
c 	SUBROUTINE  ALRBS
c	SUBROUTINE  POLCBS(BSCOEF,XKNOT,YKNOT,
c	SUBROUTINE  INT2BSF(X,BSCOEF,XD,XKNOT,YD,YKNOT,
d56 2
a57 2
	CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING$')
	CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP$')
d60 1
a60 1
        CALL  RDPRMC(ASK,NA,.TRUE.,'(F)ULL OR (H)ALF CIRCLE$',NULL,IRT)
d69 1
a69 1
C     &	'Precision of peak location (0..100)$')
a71 5
	CALL  RDPRMI(KXORD,KYORD,NLOOP,ILOOP,'X,Y order of splines$')
	IF(KXORD.EQ.0)  WRITE(NOUT,*)
     &	 '  Warning, quadratic interpolation will be used !'
c	KXORD=MAX0(2,KXORD)
c	KYORD=MAX0(2,KYORD)
a98 18
	NXKNOT=NSAM+KXORD
	NYKNOT=NROW+KYORD
C
C  MEMORY for IMSL
C
	J2=1+NSAM*NROW
	J3=J2+NSAM
	J4=J3+NXKNOT
	J5=J4+NROW
	J6=J5+NYKNOT
	N1=MAX0(2*NSAM,2*NROW)
	N2=NSAM*NROW+MAX0((2*KXORD-1)*NSAM,(2*KYORD-1)*NROW)+
     &	   MAX0((3*KXORD-2)*NSAM,(3*KYORD-2)*NROW)+ 
     &   2*MAX0(NSAM,NROW)      
	N3=3*MAX(KXORD,KYORD)+KYORD
	MEMIMSL=MAX0(N1,N2+MAX0(NSAM,NROW),N3)+J6
	IF(KXORD.EQ.0)  MEMIMSL=0
C
d107 1
a107 1
	K5A=K4A+MEMIMSL
d124 1
a124 1
     &	      Q(K6B),Q(K7),Q(K7B),MODE,KXORD,KYORD,NOUT)
d135 1
a135 1
	K5A=K4A+MEMIMSL
d159 1
a159 1
     &	      Q(K6B),Q(K7),Q(K7B),MODE,KXORD,KYORD,NOUT)
@


1.1
log
@Initial revision
@
text
@d27 3
d31 1
@
