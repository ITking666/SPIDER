head	1.157;
access;
symbols
	pre_mrcs:1.157
	healthdept_2018:1.157
	pre_getangas:1.105
	GPL2010:1.93
	pre_GPL2010:1.92
	pre_var_equation:1.88
	pre_fftwrings:1.80
	pre_opfiles:1.77
	src:1.77
	best-code:1.77
	x-named-regs:1.77
	x:1.77
	v13-00:1.76
	pre_GPL:1.75
	prec_CA:1.52
	noindx:1.40
	Bproc:1.22
	oct21:1.12
	last77:1.8;
locks; strict;
comment	@c @;


1.157
date	2018.10.03.14.33.55;	author leith;	state Exp;
branches;
next	1.156;

1.156
date	2018.08.30.18.05.02;	author leith;	state Exp;
branches;
next	1.155;

1.155
date	2018.08.30.18.03.17;	author leith;	state Exp;
branches;
next	1.154;

1.154
date	2016.01.28.16.22.18;	author leith;	state Exp;
branches;
next	1.153;

1.153
date	2016.01.28.16.19.15;	author leith;	state Exp;
branches;
next	1.152;

1.152
date	2015.04.27.18.01.20;	author leith;	state Exp;
branches;
next	1.151;

1.151
date	2013.02.13.15.29.10;	author leith;	state Exp;
branches;
next	1.150;

1.150
date	2013.01.10.14.11.36;	author leith;	state Exp;
branches;
next	1.149;

1.149
date	2012.10.26.14.58.06;	author leith;	state Exp;
branches;
next	1.148;

1.148
date	2012.10.01.13.47.11;	author leith;	state Exp;
branches;
next	1.147;

1.147
date	2012.09.25.18.56.08;	author leith;	state Exp;
branches;
next	1.146;

1.146
date	2012.09.25.14.09.47;	author leith;	state Exp;
branches;
next	1.145;

1.145
date	2012.09.10.15.36.17;	author leith;	state Exp;
branches;
next	1.144;

1.144
date	2012.09.10.13.56.55;	author leith;	state Exp;
branches;
next	1.143;

1.143
date	2012.09.07.11.41.57;	author leith;	state Exp;
branches;
next	1.142;

1.142
date	2012.09.05.13.19.23;	author leith;	state Exp;
branches;
next	1.141;

1.141
date	2012.08.29.18.07.56;	author leith;	state Exp;
branches;
next	1.140;

1.140
date	2012.07.27.14.42.32;	author leith;	state Exp;
branches;
next	1.139;

1.139
date	2012.07.27.14.41.11;	author leith;	state Exp;
branches;
next	1.138;

1.138
date	2012.06.12.17.02.24;	author leith;	state Exp;
branches;
next	1.137;

1.137
date	2012.06.11.13.01.58;	author leith;	state Exp;
branches;
next	1.136;

1.136
date	2012.04.16.19.08.02;	author leith;	state Exp;
branches;
next	1.135;

1.135
date	2012.04.02.16.15.02;	author leith;	state Exp;
branches;
next	1.134;

1.134
date	2012.04.02.16.09.24;	author leith;	state Exp;
branches;
next	1.133;

1.133
date	2012.04.02.13.06.44;	author leith;	state Exp;
branches;
next	1.132;

1.132
date	2012.03.21.14.25.46;	author leith;	state Exp;
branches;
next	1.131;

1.131
date	2012.02.29.13.46.14;	author leith;	state Exp;
branches;
next	1.130;

1.130
date	2012.02.24.15.30.41;	author leith;	state Exp;
branches;
next	1.129;

1.129
date	2012.01.18.13.34.29;	author leith;	state Exp;
branches;
next	1.128;

1.128
date	2012.01.11.16.05.42;	author leith;	state Exp;
branches;
next	1.127;

1.127
date	2012.01.11.15.46.28;	author leith;	state Exp;
branches;
next	1.126;

1.126
date	2012.01.11.15.35.21;	author leith;	state Exp;
branches;
next	1.125;

1.125
date	2012.01.11.14.36.14;	author leith;	state Exp;
branches;
next	1.124;

1.124
date	2011.12.23.16.08.13;	author leith;	state Exp;
branches;
next	1.123;

1.123
date	2011.12.01.17.19.50;	author leith;	state Exp;
branches;
next	1.122;

1.122
date	2011.11.04.17.55.36;	author leith;	state Exp;
branches;
next	1.121;

1.121
date	2011.11.01.11.51.48;	author leith;	state Exp;
branches;
next	1.120;

1.120
date	2011.09.08.14.52.01;	author leith;	state Exp;
branches;
next	1.119;

1.119
date	2011.08.29.17.50.05;	author leith;	state Exp;
branches;
next	1.118;

1.118
date	2011.08.29.17.47.44;	author leith;	state Exp;
branches;
next	1.117;

1.117
date	2011.08.22.15.39.57;	author leith;	state Exp;
branches;
next	1.116;

1.116
date	2011.06.16.16.36.55;	author leith;	state Exp;
branches;
next	1.115;

1.115
date	2011.05.16.15.20.35;	author leith;	state Exp;
branches;
next	1.114;

1.114
date	2011.05.16.14.54.02;	author leith;	state Exp;
branches;
next	1.113;

1.113
date	2011.05.16.14.02.06;	author leith;	state Exp;
branches;
next	1.112;

1.112
date	2011.05.09.17.19.19;	author leith;	state Exp;
branches;
next	1.111;

1.111
date	2011.04.26.12.13.39;	author leith;	state Exp;
branches;
next	1.110;

1.110
date	2011.04.25.20.06.45;	author leith;	state Exp;
branches;
next	1.109;

1.109
date	2011.04.23.18.28.29;	author leith;	state Exp;
branches;
next	1.108;

1.108
date	2011.04.01.15.38.09;	author leith;	state Exp;
branches;
next	1.107;

1.107
date	2011.02.16.20.19.16;	author leith;	state Exp;
branches;
next	1.106;

1.106
date	2011.02.16.18.48.37;	author leith;	state Exp;
branches;
next	1.105;

1.105
date	2011.02.08.16.59.18;	author leith;	state Exp;
branches;
next	1.104;

1.104
date	2011.02.03.15.48.16;	author leith;	state Exp;
branches;
next	1.103;

1.103
date	2011.01.25.13.35.24;	author leith;	state Exp;
branches;
next	1.102;

1.102
date	2010.10.13.14.50.31;	author leith;	state Exp;
branches;
next	1.101;

1.101
date	2010.10.13.14.24.18;	author leith;	state Exp;
branches;
next	1.100;

1.100
date	2010.10.07.16.21.58;	author leith;	state Exp;
branches;
next	1.99;

1.99
date	2010.08.26.13.43.44;	author leith;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.16.19.22.44;	author leith;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.13.18.15.45;	author leith;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.29.17.47.01;	author leith;	state Exp;
branches;
next	1.95;

1.95
date	2010.06.24.14.06.56;	author leith;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.24.14.05.30;	author leith;	state Exp;
branches;
next	1.93;

1.93
date	2010.06.24.13.25.04;	author leith;	state Exp;
branches;
next	1.92;

1.92
date	2010.03.02.13.04.02;	author leith;	state Exp;
branches;
next	1.91;

1.91
date	2009.08.28.14.36.50;	author leith;	state Exp;
branches;
next	1.90;

1.90
date	2009.08.19.14.42.20;	author leith;	state Exp;
branches;
next	1.89;

1.89
date	2009.08.11.13.33.19;	author leith;	state Exp;
branches;
next	1.88;

1.88
date	2009.01.05.16.21.30;	author leith;	state Exp;
branches;
next	1.87;

1.87
date	2008.11.25.15.47.22;	author leith;	state Exp;
branches;
next	1.86;

1.86
date	2008.10.31.15.18.41;	author leith;	state Exp;
branches;
next	1.85;

1.85
date	2008.06.19.12.53.05;	author leith;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.18.15.24.15;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.06.17.47.07;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	2008.05.22.12.25.39;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	2008.05.19.12.02.32;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2008.04.08.13.40.37;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2008.03.19.12.07.38;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2008.03.13.18.58.27;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.08.15.48.12;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2005.10.17.20.55.37;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2005.08.01.15.12.53;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	2005.03.09.16.43.54;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	2005.02.21.17.46.26;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	2005.02.16.18.49.04;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.15.20.36.16;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	2005.01.21.19.16.12;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	2005.01.20.15.58.56;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	2005.01.18.20.26.12;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	2005.01.05.15.46.54;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	2004.09.23.12.52.42;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	2004.08.17.18.13.12;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	2004.06.29.14.28.34;	author leith;	state Exp;
branches;
next	1.63;

1.63
date	2004.06.08.18.14.21;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	2004.06.08.12.26.36;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.15.18.41.17;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	2004.04.15.18.37.46;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.05.14.37.07;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.22.21.25.29;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.18.14.47.44;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.10.20.00.30;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.28.19.28.16;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.28.15.24.31;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	2003.10.15.12.45.23;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.08.18.13.55;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.05.18.14.38;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.05.14.22.27;	author leith;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.02.17.41.48;	author leith;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.02.15.42.32;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.02.14.54.59;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	2003.08.27.14.32.47;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	2003.08.26.16.44.09;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.19.18.16.27;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.07.18.50.45;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.23.20.52.27;	author leith;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.19.21.31.50;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.20.20.38.37;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	2002.10.17.20.35.06;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.11.14.08.05;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.22.20.56.46;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.14.21.28.30;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	2001.10.19.18.43.10;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.09.16.57.27;	author leith;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.17.13.25.56;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	2001.07.12.19.53.55;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.11.12.42.40;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.05.16.31.42;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.24.18.18.04;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.06.14.53.50;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.26.19.04.11;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.17.20.00.18;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.17.19.36.43;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.31.17.34.33;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2000.09.28.13.53.17;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.11.19.24.58;	author pawel;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.04.20.57.28;	author bimal;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.12.19.23.00;	author bimal;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.28.16.34.58;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.01.16.03.05;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.01.15.54.01;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.24.19.23.38;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.27.15.56.47;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	99.12.03.20.33.22;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	99.10.25.18.22.33;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	99.10.20.21.31.17;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	99.08.06.19.32.56;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	99.08.05.21.04.50;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	99.04.16.14.11.56;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	99.03.25.20.09.03;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	99.03.19.14.58.15;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	99.03.01.18.48.14;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	99.03.01.14.33.11;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	98.12.03.16.56.35;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	98.11.30.19.20.12;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	98.11.02.20.39.57;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.10.31.19.45.49;	author pawel;	state Exp;
branches;
next	;


desc
@AP RN - calling program
@


1.157
log
@email_health_dept
@
text
@
C++*********************************************************************
C
C APMASTER.F        CAN OUTPUT TO REGISTERS NOW   MAY 01 ARDEAN LEITH
C                   CAN GET ANGLES FROM HEADER    JUN 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C                   SAVDN1 + SAVD BUG             JAN 02 ARDEAN LEITH
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   UNSAV LOOP IMPROVED           SEP 02 ARDEAN LEITH
C                   ADDED ANG. DIFFERENCE         OCT 02 ARDEAN LEITH
C                   OPFILEC                       FEB 03 ARDEAN LEITH
C                   MERGED WITH DSFR & DSGRS      AUG 03 ARDEAN LEITH
C                   MERGED WITH DSFS              AUG 03 ARDEAN LEITH
C                   MERGED WITH AP_SH1            SEP 03 ARDEAN LEITH
C                   HEADER OUTPUT CHANGED         OCT 03 ARDEAN LEITH
C                   MPI OUTPUT CHANGED            FEB 04 Chao Yang
C                   'AP SH'                       FEB 04 ARDEAN LEITH
C                   'DOC FILE HEADERS'            APR 04 ARDEAN LEITH
C                   OR REF FILE                   JUN 04 ARDEAN LEITH
C                   PSI,THE,PHI                   JUN 04 ARDEAN LEITH
C                   REF_RINGS AUTO CREATION       JAN 05 ARDEAN LEITH
C                   ANG DIFF. THRESHOLD           FEB 05 ARDEAN LEITH
C                   'OR' HAD OUTPUT FILE BUG      AUG 05 ARDEAN LEITH
C                   'AP RQN' MIRRORED BUG         DEC 05 ARDEAN LEITH
C                   'AP SCC' INCORPORATED         FEB 08 ARDEAN LEITH
C                   APRINGS_INIT_PLANS            APR 08 ARDEAN LEITH
C                   OBSOLETE OPERATION MSG.       MAY 08 ARDEAN LEITH
C                   'OR NQ, OR MQ --> OR SH'      JUN 08 ARDEAN LEITH
C                   APRINGS RAYS                  JUN 08 ARDEAN LEITH
C                   FFTW3_KILLPLANS               JAN 09 ARDEAN LEITH
C                   'AP SH' CIRCREF ALLOC MSG.    AUG 09 ARDEAN LEITH
C                   MOVED 'AP SCC' OUT            AUG 09 ARDEAN LEITH
C                   ISHRANGEX                     FEB 10 ARDEAN LEITH
C                   CUDA, APSH_SS PARAMETERS      APR 10 ARDEAN LEITH
C                   REMOVED OBSOLETE OPERATIONS   JUN 10 ARDEAN LEITH
C                   'AP REF' REGISTER ONLY BUG    AUG 10 ARDEAN LEITH
C                   'AP OR' NO CALLING MSG        OCT 10 ARDEAN LEITH
C                   MRQLI & DSGR RENAME           JAN 11 ARDEAN LEITH
C                   AP_ RENAME                    FEB 11 ARDEAN LEITH
C                   WEIGHT = (YN == 'Y' ..        APR 11 ARDEAN LEITH
C                   ALLOCATABLE NPLANS            APR 11 ARDEAN LEITH
C                   APRINGS_INIT_PLANS PARAMS     JUN 11 ARDEAN LEITH
C                   AP FOU                        AUG 11 ARDEAN LEITH
C                   CKMIRROR PARSING              AUG 11 ARDEAN LEITH
C                   RAY1,RAY2                     NOV 11 ARDEAN LEITH
C                   ROTFIRST                      DEC 11 ARDEAN LEITH
C                   FBS_WANTED                    JAN 12 ARDEAN LEITH
C                   AP SHC PARAM. SUMMARY         FEB 12 ARDEAN LEITH
C                   AP FOU PATM                   JUN 12 ARDEAN LEITH
C                   DENOISE, ROTFIRST=FBS         SEP 12 ARDEAN LEITH
C                   RING LIMIT TRAP               FEB 13 ARDEAN LEITH
C                   REMOVED CUDA SUPPORT          APR 15 ARDEAN LEITH
C                   REMOVED 'FOU' PATM SUPPORT    APR 15 ARDEAN LEITH
C                   APRINGS_FILL_NEW CALL  BUG    AUG 18 ARDEAN LEITH
C 
C **********************************************************************
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* Authors: J. Frank & A. Leith                                       *
C=* Copyright 1985-2018  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C    APMASTER(MODE,CTYPE)                                  
C
C    MASTER IO AND INITIALIZATION ROUTINE FOR MOST 'AP ..' OPERATIONS
C  
C    'AP AL'   -- ??
C    'OR SH'
C    'AP I'    -- CREATE RINGS FILE ONLY
C    'AP MI'   -- 
C    'AP REF'  -- APRE_P or APRE_PM
C    'AP REFT' -- FORCES: APREF_PM
C    'AP REFF' -- FORCES: NON-INCORE EVEN IF SIZE IS OK
C    'AP REFB' -- FORCES: DOC FILE OUTPUT EVEN IF HAS OPERATION REGISTERS
C    'AP SH'   -- APSH_SS or APSH_PS
C    'AP SHC'  -- APSH_PSC; COEFF, NON-TRANSFORMED RINGS, CPLX VAR.
C    'AP SHF'  -- NON-INCORE EVEN IF SIZE IS OK
C    'AP SHT'  -- FORCES: APSH_SS
C    'AP I'    -- CREATE RINGS FILE ONLY
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE APMASTER(MODE,CTYPE)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	CHARACTER(LEN=1)       :: MODE
	CHARACTER(LEN=*)       :: CTYPE

        INTEGER, ALLOCATABLE   :: IMGLST(:)
        INTEGER, ALLOCATABLE   :: NUMR(:,:)
        REAL,    ALLOCATABLE   :: CIRCREF(:,:)

#ifndef SP_32
        INTEGER *8             :: IASK8,IOK
        INTEGER *8,ALLOCATABLE :: FFTW_PLANS(:)
#else
        INTEGER                :: IASK8,IOK
        INTEGER,   ALLOCATABLE :: FFTW_PLANS(:)
#endif

        CHARACTER (LEN=MAXNAM) :: ASK,SCRFILE,FILNAM,REFANGDOC
        CHARACTER (LEN=MAXNAM) :: REFPAT,EXPPAT,EXPANGDOC,OUTANG

	CHARACTER(LEN=1)       :: NULL,ANS,YN,CTEMP
	CHARACTER(LEN=80)      :: PROMPT,MSG
	CHARACTER(LEN=220)     :: COMMEN
        LOGICAL                :: CIRCREF_IN_CORE,CKMIRROR
        LOGICAL                :: WINDOW,NEWFILE,WEIGHT,WANTDOC
        LOGICAL                :: ROTFIRST,GOTMIR,FBS_WANTED 
        LOGICAL                :: DENOISE,GOTRTSH 
        REAL                   :: VALUES(6)

        INTEGER, PARAMETER     :: LUNREF  = 50
        INTEGER, PARAMETER     :: LUNEXP  = 51
        INTEGER, PARAMETER     :: LUNRING = 52
	!USED IN CALLED ROUTINE
        INTEGER, PARAMETER     :: INPIC   = 77 
        INTEGER, PARAMETER     :: INANG   = 78 
        INTEGER, PARAMETER     :: NDOC    = 55 
        INTEGER, PARAMETER     :: NSCF    = 50 

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID 

        NULL   = CHAR(0)
        NILMAX = NIMAX

#ifdef USE_MPI
        IF (CTYPE(1:3) == 'SHC') THEN
           CALL ERRT(101,"SUB-OPERATION NOT ON MPI, USE 'AP SH'",NDUM)
           RETURN
        ENDIF
#endif

        IF (CTYPE(1:2) == 'OR') THEN
           MAXIM = 0
           CALL OPFILEC(0,.TRUE.,REFPAT,LUNREF,'O',ITYPE,NX,NY,
     &               NZ,MAXIM,'REFERENCE',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           NUMREF    = 1
           INUMBR(1) = 0
        ELSE
           NUMREF = 0
C          ASK FOR TEMPLATE AND NUMBERS FOR REFERENCE IMAGES
	   CALL FILELIST(.TRUE.,LUNREF,REFPAT,NLET,INUMBR,NILMAX,NUMREF,
     &           'TEMPLATE FOR REFERENCE IMAGES',IRTFLG)
	   IF (IRTFLG .NE. 0) RETURN

           IF (MYPID <= 0) WRITE(NOUT,2001) NUMREF
2001       FORMAT('  Number of reference images: ',I7)
        ENDIF

C       NUMREF - TOTAL NUMBER OF REF. IMAGES
        IF (NUMREF <= 0)  THEN
           WRITE(NOUT,*)
     &     ' *** ERROR: Operation requires file template and number(s)'
           WRITE(6,*)
     &     '*** ERROR: Operation requires file template and number(s)'
           CALL ERRT(101,'No reference images',IDUM)
           GOTO 9999
        ENDIF

C       GET FIRST REFERENCE IMAGE TO DETERMINE DIMENSIONS
        IF (CTYPE(1:2) == 'OR') THEN
           FILNAM = REFPAT
        ELSE
           NLET = 0
           CALL FILGET(REFPAT,FILNAM,NLET,INUMBR(1),INTFLG)
        ENDIF

        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FILNAM,LUNREF,'O',IFORM,NX,NY,NZ,
     &               MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999
        CLOSE(LUNREF)

        ISHRANGE = 1
        IVAL2    = 999999
        IVAL3    = 999999
        IF (CTYPE(1:2) == 'SH'  .OR.
     &      CTYPE(1:2) == 'OR') THEN
	   CALL RDPRI3S(ISHRANGE,IVAL2,IVAL3,NOT_USED,
     &     'TRANSLATION SEARCH RANGE IN X, IN Y (OPTIONAL), STEP SIZE',
     &      IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
	   ISHRANGE   = MAX(ISHRANGE,0)       
	   ISHRANGEX  = ISHRANGE           ! _ & 5
           IF (IVAL2 == 999999) THEN       ! 5
              ISHRANGEY = ISHRANGEX
              ISTEP     = 1
           ELSEIF (IVAL3 == 999999) THEN   ! 5,6
              ISHRANGEY = ISHRANGEX
              ISTEP     = IVAL2
           ELSE                            ! 5,3,1
              ISHRANGEY = MAX(0,IVAL2)
              ISTEP     = IVAL3
           ENDIF
	   ISTEP = MAX(ISTEP,1)

C          CHECK SEARCH RANGE AND STEP SIZE.
	   IF (ISHRANGEX  > NX/2-2)  THEN
	      CALL ERRT(102,'X SEARCH MUST BE LESS THAN',NX/2-2)
              GOTO 9999
	   ELSEIF (ISHRANGEY  > NX/2-2)  THEN
	      CALL ERRT(102,'Y SEARCH MUST BE LESS THAN',NX/2-2)
              GOTO 9999
	   ELSEIF (ISHRANGEX > 0 .AND.
     &             MOD(ISHRANGEX,ISTEP) .NE. 0) THEN
	      CALL ERRT(102,'X SEARCH RANGE MUST BE DIVISIBLE BY',ISTEP)
              GOTO 9999
	   ELSEIF (ISHRANGEY > 0 .AND.
     &        MOD(ISHRANGEY,ISTEP) .NE. 0) THEN
	      CALL ERRT(102,'Y SEARCH RANGE MUST BE DIVISIBLE BY',ISTEP)
              GOTO 9999
	   ENDIF

        ELSEIF ( CTYPE(1:3) == 'REF' ) THEN
           CALL RDPRI1S(ISHRANGE,NOT_USED,
     &         'TRANSLATION SEARCH RANGE (ZERO FOR NONE)' ,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
        ENDIF

        IRAY   = 1
        RAY1   = 0               ! FIRST RAY ANGLE
        RAY2   = 360             ! LAST  RAY ANGLE

        MR     = 5
        MAXRAD = MIN( (NX - (NX/2+1)),(NY - (NY/2+1)) ) 
        NR     = MAXRAD - 2      ! DEFAULT VALUE

        !write(6,*) 'center:' , (NX/2+1),(NY/2+1)
        !write(6,*) 'nx,ny,maxrad:' ,nx,ny,maxrad 

	IF (CTYPE(1:2) == 'OR' ) THEN
           ISKIP = 1
           CALL RDPRIS(MR,NR,NOT_USED,'FIRST & LAST RING',IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
 
        ELSE
           ISKIP     = 0
           ISKIP     = 0
           ISKIP     = 0

           VALUES(1) = MR
           VALUES(2) = NR
           VALUES(3) = ISKIP
           VALUES(4) = IRAY
           VALUES(5) = RAY1
           VALUES(6) = RAY2

           CALL RDPRA('FIRST, LAST RING, RING STEP & RAY STEP',
     &                6,0,.TRUE.,VALUES,NGOT,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           IF (NGOT  > 0) THEN
C             COPY THE RETURNED VALUES 
              IF (NGOT >= 1) MR    = VALUES(1)
              IF (NGOT >= 2) NR    = VALUES(2)
              IF (NGOT >= 3) ISKIP = VALUES(3)
              IF (NGOT >= 4) IRAY  = VALUES(4)
              IF (NGOT >= 5) RAY1  = VALUES(5)
              IF (NGOT >= 6) RAY2  = VALUES(6)
           ENDIF
  
           IF ( CTYPE(1:2) .NE. 'SH' .AND. ISKIP <= 0) THEN
              ISKIP = 1
              CALL RDPRI1S(ISKIP,NOT_USED,'RING STEP',IRTFLG)
           ENDIF
        ENDIF
        IF (IRTFLG .NE. 0) GOTO 9999
        ISKIP = MAX(1,ISKIP)
        IF (IRAY .NE. 1 .AND. IRAY .NE. 2 .AND. 
     &      IRAY .NE. 4 .AND. IRAY .NE. 8) THEN
	   CALL ERRT(101,'RAY STEP MUST BE 1,2,4, OR 8',NE)
           GOTO 9999
        ENDIF

	IF (MR <= 0) THEN
	   CALL ERRT(101,'FIRST RING MUST BE > 0',NE)
	   GOTO 9999

	ELSEIF (NR < MR)  THEN 
	   CALL ERRT(102,'LAST RING MUST BE > ',MR)
	   GOTO 9999

	ELSEIF (CTYPE(1:2) == 'SH') THEN
C          CHECK SEARCH RANGE AND STEP SIZE TOGETHER
	   IF ((ISHRANGEX+NR)  >= MAXRAD)  THEN
	      CALL ERRT(102,
     &          'LAST RING + X TRANSLATION MUST BE LESS THAN',MAXRAD)
              GOTO 9999
	   ELSEIF ((ISHRANGEY+NR)  >= MAXRAD)  THEN
	      CALL ERRT(102,
     &          'LAST RING + Y TRANSLATION MUST BE LESS THAN',MAXRAD)
              GOTO 9999
	   ENDIF
	ELSEIF (NR >= MAXRAD)  THEN 
	   CALL ERRT(102,'LAST RING MUST BE LESS THAN',MAXRAD)
	   GOTO 9999
        ENDIF        

        REFANGDOC = NULL
        IF (CTYPE(1:3) == 'REF' .OR. 
     &      CTYPE(1:2) == 'SH') THEN
C          GET NAME OF REFERENCE IMAGES ANGLES DOCUMENT FILE
           CALL FILERD(REFANGDOC,NREFA,NULL,
     &		'REFERENCE IMAGES ANGLES DOCUMENT',IRTFLG)
C          FILERD WILL RETURN IRTFLG=-1 IF "*" !!!!
           IF (NREFA <= 0) REFANGDOC = NULL
         ENDIF

C        FIND NUMBER OF REFERENCE-RINGS IN USE
         NRING=0
         DO I=MR,NR,ISKIP
            NRING = NRING + 1
	 ENDDO

         ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'APMASTER; NUMR',3*NRING)
            GOTO 9999
         ENDIF

C        INITIALIZE NUMR ARRAY WITH RING RADII
         NRING = 0
         DO I=MR,NR,ISKIP
            NRING         = NRING + 1
            NUMR(1,NRING) = I
	 ENDDO

C        CALCULATES NUMR & LCIRC, EACH RING HAS FFT PAD OF 2 FLOATS
         CALL ALPRBS_Q_NEW(NUMR,NRING,LCIRC,MODE,IRAY)

C        FIND NUMBER OF OMP THREADS
         CALL GETTHREADS(NUMTH)

         NPLANS = 42 + 2   ! I THOUGHT 14 WAS ENUFF!!
         ALLOCATE(FFTW_PLANS(NPLANS),STAT=IRTFLG)
         IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'APMASTER; FFTW_PLANS',NPLANS)
            GOTO 9999
         ENDIF

         IASK8 = (LCIRC * NUMREF)*4
         CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

         IF (CTYPE(1:4) == 'REFF' .OR. 
     &           CTYPE(1:3) == 'SHF'  .OR. 
     &           CTYPE(1:1) == 'I' ) THEN
C           INITIATE NON-INCORE EVEN IF SIZE IS OK

            ALLOCATE(CIRCREF(LCIRC,NUMTH),STAT=IRTFLG)
            IF (IRTFLG .NE. 0) THEN
               IF (MYPID <= 0) WRITE(NOUT,92) LCIRC,NUMTH
92             FORMAT ('  CAN NOT ALLOCATE: CIRCREF(',I8,' X ',I8,')') 
	       CALL ERRT(46,'APMASTER; CIRCREF',LCIRC*NUMTH)
	       GOTO 9999
            ENDIF
            IF (MYPID <= 0) WRITE(NOUT,93) LCIRC,NUMTH
93          FORMAT ('  DISK BASED RINGS FILE, ALLOCATED: CIRCREF(',I8,
     &                 ' X ',I8,')') 

            CIRCREF_IN_CORE = .FALSE.
         ELSE

            ALLOCATE(CIRCREF(LCIRC,NUMREF),STAT=IRTFLG)

            NTOT = LCIRC * NUMREF
            IF (IRTFLG == 0) THEN 
C              CIRCREF ALLOCATION SUCCEEDED 
               CIRCREF_IN_CORE = .TRUE.
               IF (MYPID <= 0) WRITE(NOUT,91) LCIRC,NUMREF,NTOT
91             FORMAT('  ALLOCATED: CIRCREF(',I8,' X ',I8,'): ',I10) 

	    ELSE
               CIRCREF_IN_CORE = .FALSE.
               IF (MYPID <= 0) WRITE(NOUT,90) LCIRC,NUMREF,NTOT
90             FORMAT('  CAN NOT ALLOCATE: CIRCREF(',I8,' X ',I8,'): ',
     &            I10,'  WILL USE REFERENCE-RINGS FILE.',/,
     &                '  MAY BE VERY SLOW! ',  
     &                'ADVISE YOU USE FEWER REFERENCES, INSTEAD.',/) 
 
C              GWP - HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
               IF (ALLOCATED(CIRCREF)) DEALLOCATE(CIRCREF)
	       ALLOCATE(CIRCREF(LCIRC,NUMTH),STAT=IRTFLG)
	       IF (IRTFLG .NE. 0) THEN
	          CALL  ERRT(46,'APMASTER; CIRCREF',LCIRC*NUMTH)
	          GOTO 9999
	       ENDIF
            ENDIF
         ENDIF

         IF ((CTYPE(1:2) .EQ. 'AL') .OR. 
     &       (CTYPE(1:2) .NE. 'SH'  .AND.
     &        CTYPE(1:2) .NE. 'OR') .OR.
     &       (CTYPE(1:2) .EQ. 'SH'  .AND. .NOT. CIRCREF_IN_CORE)) THEN
C
C           ~9 IS TO ACCEPT EXTENSION IF FILE IS NAMED
            CALL FILERD(ASK,NA,NULL,'REFERENCE-RINGS~9',IRTFLG)
            IF (IRTFLG .NE. 0)  GOTO 9999

            SCRFILE = ASK
            IF (ASK(1:NA) == 'W') THEN
               CALL ERRT(101,
     &         'OBSOLETE, USE: <AP I> TO CREATE REFERENCE-RINGS FILE',N)
               GOTO 9999
            ELSEIF (NA <= 3 .AND. ASK(1:1) == 'N' .AND. 
     &              .NOT. CIRCREF_IN_CORE) THEN
               CALL ERRT(101,
     &         'OBSOLETE, USE: <AP I> TO CREATE REFERENCE-RINGS FILE',N)
               GOTO 9999
            ELSEIF (NA <= 3 .AND. ASK(1:1) == 'Y') THEN
               SCRFILE = 'SCRATCH.file'
               IF (MYPID <= 0) WRITE(NOUT,*) 
     &               'OBSOLETE, GIVE NAME FOR REFERENCE-RINGS FILE'
            ENDIF 
         ELSE
            SCRFILE = CHAR(0) 
         ENDIF


         IF (CTYPE(1:1) == 'I' .OR. 
     &       CTYPE(1:2) == 'MI') THEN
C           ----------------- 'I' ------------------------ APRINGS_FILL
C          CREATE REFERENCE RINGS FILE FOR OUTPUT
           NSL = 1
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'B',IFORM,
     &               LCIRC,NUMREF,NSL,MAXIM,' ', .FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9990

           CALL RDPRMC(YN,NLET,.TRUE.,'WEIGHT THE RINGS? (Y/N)',
     &                 NULL,IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9990
           WEIGHT = (YN == 'Y' .OR. YN == 'y')

C          INITIALIZE FFTW3 PLANS FOR USE WITHIN OMP || SECTIONS
           CALL APRINGS_INIT_PLANS(NUMR,NRING,
     &                          FFTW_PLANS,NPLANS,NX,NY,IRTFLG)

           CALL APRINGS_FILL_NEW(INUMBR,NUMREF,
     &                  NX,NY,NUMTH,
     &                  NRING,LCIRC,NUMR,MODE,FFTW_PLANS, 
     &                  REFPAT,LUNREF,
     &                  CIRCREF,NUMTH,LUNRING,WEIGHT,IRTFLG)

           CLOSE(LUNRING)
           GOTO 9989
        ENDIF

399     IF (CTYPE(1:2) == 'OR') THEN
C           GET NAME OF SINGLE IMAGE TO BE ALIGNED
            MAXIM = 0
            CALL OPFILEC(0,.TRUE.,EXPPAT,LUNEXP,'O',IFORM,
     &                  NX,NY,NZ,MAXIM,'EXPERIMENTAL IMAGE',
     &                  .FALSE.,IRTFLG)
	    IF (IRTFLG .NE. 0) GOTO 9999

	    ALLOCATE(IMGLST(1),STAT=IRTFLG)
	    IF (IRTFLG .NE. 0) THEN
                CALL ERRT(46,'APMASTER; IMGLST',1)
                GOTO 9999
            ENDIF

            IMGLST(1) = 0
            NUMEXP    = 1
        ELSE
C           GET LIST OF EXPERIMENTAL IMAGES TO BE ALIGNED
	    ALLOCATE(IMGLST(NILMAX),STAT=IRTFLG)
	    IF (IRTFLG .NE. 0) THEN
               CALL ERRT(46,'APMASTER; IMGLST',NILMAX)
               GOTO 9999
            ENDIF

	    CALL FILELIST(.TRUE.,LUNEXP,EXPPAT,NLEP,
     &         IMGLST,NILMAX,NUMEXP,
     &         'TEMPLATE FOR IMAGE SERIES TO BE ALIGNED',IRTFLG)
	    IF (IRTFLG .NE. 0) GOTO 9999

            IF (MYPID <= 0) WRITE(NOUT,2002) NUMEXP
2002        FORMAT('  Number of experimental images: ',I6)
        ENDIF   


        EXPANGDOC = NULL
        IF (CTYPE(1:2) == 'SH'  .OR. 
     &      CTYPE(1:3) == 'REF') THEN

C          GET NAME OF DOC FILE HOLDING EXPERIMENTAL IMAGES ANGLES
           CALL FILERD(EXPANGDOC,NEXPA,NULL,
     &                 'EXPERIMENTAL IMAGES ALIGNMENT DOCUMENT',IRTFLG)
           IF (NEXPA == 0) EXPANGDOC = NULL
        ENDIF

        RANGE     = 0.0
        ANGDIFTHR = 0.0
        IF (CTYPE(1:3) == 'REF' .OR.
     &      CTYPE(1:2) == 'SH') THEN

           CALL RDPRM2S(RANGE,ANGDIFTHR,NOT_USED,
     &      'RANGE OF PROJECTION ANGLE SEARCH & ANGLE CHANGE THRESHOLD',
     &       IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           IF (RANGE  > 0.0 .AND. EXPANGDOC == NULL) THEN
             CALL ERRT(101,
     &       'MUST SPECIFY EXPERIMENTAL IMAGES ALIGNMENT DOCUMENT FILE',
     &       IDUM)
             RANGE = 0.0
           ENDIF
           RANGE = MIN(RANGE,180.0)  ! 3D MAX. DIFFERENCE POSSIBLE
       ENDIF

       DENOISE    = .FALSE.
       ROTFIRST   = .FALSE.
       CKMIRROR   = .TRUE.
       FBS_WANTED = .FALSE.

       IF ( CTYPE(1:3) == 'REF'  .OR.
     &      CTYPE(1:3) == 'ORS'  .OR.
     &      CTYPE(1:2) == 'SH' ) THEN

          IF (CTYPE(1:3) == 'SHC') THEN
C                      123456789 123456789 1234567890
             PROMPT = 'CHECK MIRRORED POSITIONS?, ' //
     &                'SHIFT/ROTATE INPUT?, '       //
     &                'DENOISE? (Y/N)' 
             CALL RDPRMC(ASK,NA,.TRUE.,PROMPT(1:62),NULL,IRTFLG)
             IF (IRTFLG .NE. 0) GOTO 9999

             GOTMIR     = .FALSE.
             GOTRTSH    = .FALSE.
             CKMIRROR   = .FALSE.
             ROTFIRST   = .FALSE.
             FBS_WANTED = .FALSE.
             DENOISE    = .FALSE.

             DO I = 1,NA
                CTEMP = ASK(I:I)
                IF (CTEMP == '1' .OR. 
     &              CTEMP == 'Y' .OR. 
     &              CTEMP == 'Q'.OR.
     &              CTEMP == 'F') THEN
                   IF (.NOT. GOTMIR) THEN
                      CKMIRROR   = .TRUE.
                      GOTMIR     = .TRUE.
        !write(6,*) '1',ctemp,CKMIRROR,gotrtsh,fbs_wanted,denoise

                   ELSEIF (.NOT. GOTRTSH) THEN 
                      GOTRTSH    = .TRUE.
                      ROTFIRST   = .TRUE.
                      IF (CTEMP == 'F' ) FBS_WANTED = .TRUE. 
        !write(6,*) '2',ctemp,CKMIRROR,gotrtsh,fbs_wanted,denoise

                    ELSE  
                      IF (CTEMP == 'Y') DENOISE = .TRUE. 
        !write(6,*) '3',ctemp,CKMIRROR,gotrtsh,fbs_wanted,denoise
                      EXIT
                   ENDIF

                ELSEIF (CTEMP == '0' .OR. 
     &                  CTEMP == 'N') THEN
                   IF (.NOT. GOTMIR) THEN
                      CKMIRROR = .FALSE.
                      GOTMIR   = .TRUE.
                   ELSEIF (.NOT. GOTRTSH) THEN 
                      ROTFIRST = .FALSE.
                      GOTRTSH  = .TRUE.
                   ELSE  
                      DENOISE  = .FALSE.
                      EXIT
                   ENDIF
                ENDIF
             ENDDO
 
          ELSEIF ((CTYPE(1:3) == 'REF') .OR.
     &             CTYPE(1:2) == 'SH') THEN
C                      123456789 123456789 1234567890
             PROMPT = 'CHECK MIRRORED POSITIONS?, ' //
     &                'SHIFT/ROTATE INPUT? (Y/N)' 
             CALL RDPRMC(ASK,NA,.TRUE.,PROMPT(1:52),NULL,IRTFLG)
             IF (IRTFLG .NE. 0) GOTO 9999

             CKMIRROR = .FALSE.
             GOTMIR   = .FALSE.
             GOTRTSH  = .FALSE.
             DO I = 1,NA
                CTEMP = ASK(I:I)
                IF (CTEMP == '1' .OR. 
     &              CTEMP == 'Y' .OR. 
     &              CTEMP == 'Q'.OR.
     &              CTEMP == 'F') THEN
                   IF (.NOT. GOTMIR) THEN
                      CKMIRROR   = .TRUE.
                      GOTMIR     = .TRUE.
                   ELSEIF (.NOT. GOTRTSH) THEN 
                      GOTRTSH    = .TRUE.
                      ROTFIRST   = .TRUE.
                      IF (CTEMP == 'Q') FBS_WANTED = .FALSE. 
                   ENDIF

                ELSEIF (CTEMP == '0' .OR. 
     &                  CTEMP == 'N') THEN
                   IF (.NOT. GOTMIR) THEN
                      CKMIRROR = .FALSE.
                      GOTMIR   = .TRUE.
                   ELSEIF (.NOT. GOTRTSH) THEN 
                      ROTFIRST = .FALSE.
                      GOTRTSH  = .TRUE.
                   ENDIF
                ENDIF
             ENDDO
 
          ELSE

             CALL RDPRMC(ASK,NA,.TRUE.,
     &          'CHECK MIRRORED POSITIONS? (Y/N)', NULL,IRTFLG)
             IF (IRTFLG .NE. 0) GOTO 9999

             DO I = 1,NA
                CTEMP = ASK(I:I)
                IF (CTEMP == '1' .OR. CTEMP == 'Y') THEN
                   CKMIRROR = .TRUE.
                   EXIT
                ELSEIF (CTEMP == '0' .OR. CTEMP == 'N') THEN
                   CKMIRROR = .FALSE.
                   EXIT
                ENDIF
             ENDDO
          ENDIF

       ENDIF

C      GET NAME FOR OUTPUT DOC FILE
       CALL REG_GET_USED(NSEL_USED)
       LENC = lnblnkn(CTYPE)

       WANTDOC = .TRUE.
       IF  (FCHAR(1:2) == 'OR') WANTDOC = .FALSE.
       IF  (NSEL_USED  > 0)       WANTDOC = .FALSE.
       IF ((NSEL_USED  > 0) .AND.
     &     (LENC >= 4 .AND. CTYPE(4:4) == 'D') .OR.
     &     (LENC >= 5 .AND. CTYPE(5:5) == 'D')) WANTDOC = .TRUE.
       !write(6,*) 'wantdoc: ',wantdoc,lenc,ctype

        IF (.NOT. WANTDOC) THEN
C        NO OUTPUT FILE WANTED
         OUTANG  = NULL
         NOUTANG = 0
       ELSE
C        OPEN OUTPUT DOC FILE (FOR APPENDING)
         NOUTANG = NDOC
         CALL OPENDOC(OUTANG,.TRUE.,NLET,NDOC,NOUTANG,.TRUE.,
     &           'OUTPUT ALIGNMENT DOCUMENT',.FALSE.,.TRUE.,.TRUE.,
     &            NEWFILE,IRTFLG)
         IF (IRTFLG == -1) THEN
C           DO NOT WANT OUTPUT DOC FILE
            NOUTANG = 0
         ELSEIF (IRTFLG .NE. 0) THEN
            RETURN
         ELSE
C           WANT OUTPUT DOC FILE
            IF (CTYPE(1:2) == 'SH'  .OR. 
     &          CTYPE(1:3) == 'REF' ) THEN
               IF (USE_LONGCOL) THEN    ! FROM CMBLOCK.INC
               COMMEN ='                 '                           //
     &         ' PSI,          THE,          PHI,         REF#,     '//
     &         '   EXP#,    CUM. {INPLANE,      SX,          SY},  ' //
     &         '        NPROJ,         DIFF,        CCROT,  '        //
     &         '     INPLANE,          SX,            SY,       MIR-CC'


               ELSE
               COMMEN =' KEY       '              //
     &         'PSI,    THE,    PHI,   REF#,    ' //
     &         'EXP#,  CUM.{ROT,   SX,    SY},  ' //
     &         'NPROJ,   DIFF,      CCROT,    '   //
     &         'ROT,     SX,     SY,   MIR-CC'
               ENDIF

            ELSE
               COMMEN = '      ' //
     &         'MIR-REF#,     CCROT,     INPLANE <,      SX,         '//
     &         'SY,           IMG#,       < DIFF'
            ENDIF
            CALL LUNDOCPUTCOM(NOUTANG,COMMEN,IRTFLG)
         ENDIF
       ENDIF


C        -------PARAMETER INPUT FINISHED, CALCULATE NOW ---------


C       INITIALIZE FFTW3 PLANS FOR USE WITHIN OMP || SECTIONS
        CALL APRINGS_INIT_PLANS(NUMR,NRING,
     &                          FFTW_PLANS,NPLANS,NX,NY,IRTFLG)

        IF (CTYPE(1:3) == 'REF') THEN
C           --------------------'REF'   ----------------------- 'AP REF'
 
            IF ((CIRCREF_IN_CORE .AND. 
     &           NUMTH > 1 .AND. NUMEXP > NUMTH) .OR. 
     &           CTYPE(3:3) == 'T' .OR. CTYPE(4:4) == 'T') THEN

               IF (MYPID <= 0) WRITE(NOUT,*) 
     &           ' Calling: APREF_PM FOR: ',CTYPE(1:3),' -----------'
               CALL FLUSHFILE(6)

               CALL APREF_PM(INUMBR,NUMREF,IMGLST,NUMEXP,
     &                NX,NY, ANGDIFTHR,RANGE,
     &                NRING,LCIRC,NUMR,CIRCREF,
     &                MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &                REFPAT,EXPPAT,
     &                CKMIRROR,CTYPE,ROTFIRST,ISHRANGE,
     &                NOUTANG,FBS_WANTED)
            ELSE 
               IF (MYPID <= 0) WRITE(NOUT,*) 
     &            ' Calling: APREF_P FOR: ',CTYPE(1:3),' -----------'
               CALL FLUSHFILE(6)


               CALL APREF_P(INUMBR,NUMREF,IMGLST,NUMEXP,
     &               NX,NY,RANGE,ANGDIFTHR,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &               REFPAT,EXPPAT,
     &               CKMIRROR,CTYPE,ROTFIRST,ISHRANGE,
     &               NOUTANG,FBS_WANTED)
           ENDIF 

        ELSEIF (CTYPE(1:2) == 'SH' .OR.
     &          CTYPE(1:2) == 'AL' .OR.
     &          CTYPE(1:2) == 'OR') THEN
C        ---- ' SH', 'ORS',  ---------------------------------- 'AP_SH'

#ifdef MPI_DEBUG 
              T0 = MPI_WTIME()
#endif

	   IF (CIRCREF_IN_CORE .AND. (CTYPE(3:3) == 'C')) THEN
C             FOR MP, LARGE NUMBER OF IMAGES TO BE ALIGNED, OR SP.
C             USES COEF. TO SPEED UP APRINGS          
              IF (MYPID <= 0) WRITE(NOUT,*)
     &           ' Calling: APSH_PSC FOR: ',CTYPE(1:5),' ----------'

C             ECHO SEARCH PARAMETERS
              NSHIFTSX = (2*ISHRANGEX + 1) 
              NSHIFTSY = (2*ISHRANGEY + 1)
              NSHIFTS  = NSHIFTSX *  NSHIFTSY 

              MSG = ' Aligning'
              NA  = 9 
              IF (ROTFIRST) THEN
                 IF (FBS_WANTED) THEN
                    MSG = MSG(1: NA) //  ' FBS interpolated, rotated'
                    NA = NA + 26
                 ELSE
                    MSG = MSG(1: NA) //  ' QUAD interpolated, rotated'
                    NA = NA + 27
                 ENDIF
              ELSE
                 MSG = MSG(1: NA)    //  ' unrotated'
                 NA = NA + 10

              ENDIF
              IF (DENOISE) THEN
                 MSG = MSG(1: NA)    // ', denoised'
                 NA = NA + 10
              ENDIF 
              MSG = MSG(1: NA)       // ' exp images'
              NA = NA + 11
              IF (MYPID <= 0) WRITE(NOUT,*) MSG(1:NA)

              IF (MYPID <= 0) WRITE(NOUT,981)-ISHRANGEX,ISHRANGEX,
     &                                       -ISHRANGEY,ISHRANGEY,
     &                                        ISTEP    !,NSHIFTS
981           FORMAT('  Shift search X range:      ',I3,' ...',I3,
     &               '     Y range:',I3,'...',I3, 
     &               '    Step size:',I3)
              IF (MYPID <= 0) WRITE(NOUT,982)MR,NR,ISKIP
982           FORMAT('  Ring search radius range:  ',I3,' ...',I4,
     &               '    Skip increment:',I3)
              IF (MYPID <= 0) WRITE(NOUT,983)RAY1,RAY2
983           FORMAT('  Rotational search range:',F6.1,' ...',F6.1,/)
              CALL FLUSHRESULTS_Q(.FALSE.)

              CALL APSH_PSC(INUMBR,NUMREF,IMGLST,NUMEXP, 
     &               NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,DENOISE,
     &               CKMIRROR,CTYPE,NOUTANG,RAY1,RAY2,FBS_WANTED)

	   ELSEIF (CIRCREF_IN_CORE      .AND. 
     &             NUMEXP >= NUMTH      .AND. 
     &             CTYPE(3:3) .NE. 'T'  .AND. 
     &             CTYPE(4:4) .NE. 'T'  .AND.
     &             CTYPE(1:2) .NE. 'OR') THEN
C             FOR MP, LARGE NUMBER OF IMAGES TO BE ALIGNED, OR SP.

              IF (MYPID <= 0) WRITE(NOUT,*)
     &           ' Calling: APSH_PS FOR: ',CTYPE(1:3),' ----------'
              CALL FLUSHRESULTS_Q(.FALSE.)

C             ECHO SEARCH PARAMETERS
              NSHIFTSX = (2*ISHRANGEX + 1) 
              NSHIFTSY = (2*ISHRANGEY + 1)
              NSHIFTS  = NSHIFTSX *  NSHIFTSY 
              IF (MYPID <= 0) WRITE(NOUT,*)
              IF (MYPID <= 0) WRITE(NOUT,981)-ISHRANGEX,ISHRANGEX,
     &                                       -ISHRANGEY,ISHRANGEY,
     &                                       ISTEP    
              IF (MYPID <= 0) WRITE(NOUT,982)MR,NR,ISKIP
              IF (MYPID <= 0) WRITE(NOUT,983)RAY1,RAY2

              CALL APSH_PS(INUMBR,NUMREF,IMGLST,NUMEXP, 
     &               NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,
     &               CKMIRROR,CTYPE,NOUTANG,FBS_WANTED)

	   ELSE
C             USE DIFFERENT STRATEGY FOR SMALL NUMBER OF SAMPLE IMAGES  
C             OR FOR CIRCREF FROM RINGS FILE  
C             TO MAKE MP EFFICIENT. ALSO FOR 'OR' OPERATIONS
              IF (CTYPE(1:2) .NE. 'OR' .AND. MYPID <= 0) WRITE(NOUT,*) 
     &           ' Calling: APSH_SS FOR: ',CTYPE(1:3),' ----------'
              CALL FLUSHFILE(6)

              CALL APSH_SS(INUMBR,NUMREF,IMGLST,NUMEXP, 
     &               NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS, 
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,
     &               CKMIRROR,CTYPE,NOUTANG,FBS_WANTED)
 	   ENDIF

#ifdef MPI_DEBUG
           T1 = MPI_WTIME()
           T1 = T1 - T0
           IF (MYPID == 0)  WRITE(6, 222) T1
 222       FORMAT('  AP TIME: ', 1PE11.3)
#endif
         ENDIF

C        UNALLOCATE FFTW3 PLANS (TO REMOVE MEMORY LEAK)
9989     CALL FFTW3_KILLPLANS(FFTW_PLANS,NPLANS,IRTFLG)

9990     IF (MYPID <= 0 .AND. VERBOSE) WRITE (NOUT,2600)
2600     FORMAT (/' ',12('-'),' END OF COMPUTATION ',12('-')/)

9999     IF (ALLOCATED(IMGLST))     DEALLOCATE(IMGLST)
         IF (ALLOCATED(NUMR))       DEALLOCATE(NUMR)
         IF (ALLOCATED(CIRCREF))    DEALLOCATE(CIRCREF)
         IF (ALLOCATED(FFTW_PLANS)) DEALLOCATE(FFTW_PLANS)

         CLOSE(NDOC)

#ifdef USE_MPI_NEVER
         write(0,*) ' apmaster; at final barrier: ',mypid
         CALL MPI_BARRIER(ICOMM,MPIERR)
         write(0,*) ' apmaster; after final barrier: ',mypid
#endif

         END

@


1.156
log
@comment
@
text
@d61 1
a61 1
C=* Email: spider@@wadsworth.org                                        *
@


1.155
log
@APRINGS_FILL_NEW call had extra parameter bug
@
text
@d54 1
d59 1
a59 1
C=* Copyright 1985-2016  Health Research Inc.,                         *
@


1.154
log
@flushresults_q
@
text
@d460 1
a460 1
     &                  CIRCREF,NUMTH,LUNRING,WEIGHT,.FALSE.,IRTFLG)
@


1.153
log
@flusresults()
@
text
@d800 1
a800 1
              CALL FLUSHRESULTS(.FALSE.)
d818 1
a818 1
              CALL FLUSHRESULTS(.FALSE.)
@


1.152
log
@removed cuda + patm  support 'AP SHG' & 'AP FOU'
@
text
@d58 1
a58 1
C=* Copyright 1985-2015  Health Research Inc.,                         *
d800 1
a800 1
              CALL FLUSHRESULTS
d818 1
a818 1
              CALL FLUSHRESULTS
@


1.151
log
@RING LIMIT TRAP fixed to fill image
@
text
@d52 3
a54 1
C
d58 1
a58 1
C=* Copyright 1985-2013  Health Research Inc.,                         *
a91 1
C    'AP SHG'  -- GPU (MAY NOT BE LINKED)
a92 1
C    'AP FOU'  -- NEW ALGORITHM
d124 1
a124 1
        LOGICAL                :: WINDOW,NEWFILE,WEIGHT,GPU,WANTDOC
a232 22
        ELSEIF ( CTYPE(1:3) == 'FOU' ) THEN
	   CALL RDPRIS(ISHRANGE,IVAL2,NOT_USED,
     &     'TRANSLATION SEARCH RANGE IN X AND IN Y (OPTIONAL)',IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
	   ISHRANGE   = MAX(ISHRANGE,1)       
	   ISHRANGEX  = ISHRANGE            ! _ & 5
           IF (IVAL2 == 999999) THEN        ! 5
              ISHRANGEY = ISHRANGEX
           ELSE                             ! 5,3,1
              ISHRANGEY = MAX(1,IVAL2)
           ENDIF
	   ISTEP = 1

C          CHECK SEARCH RANGE.
	   IF (ISHRANGEX  > NX/2-2)  THEN
	      CALL ERRT(102,'X SEARCH MUST BE LESS THAN',NX/2-2)
              GOTO 9999
	   ELSEIF (ISHRANGEY  > NX/2-2)  THEN
	      CALL ERRT(102,'Y SEARCH MUST BE LESS THAN',NX/2-2)
              GOTO 9999
	   ENDIF

d250 1
a250 2
	IF (CTYPE(1:2) == 'OR' .OR. 
     &      CTYPE(1:3) == 'FOU' ) THEN
a319 1
     &      CTYPE(1:3) == 'FOU' .OR.
d363 1
a363 6
         GPU = (CTYPE(1:4) == 'SH G')
         IF (GPU) THEN
C           GPU MUST USE IN_CORE
            CIRCREF_IN_CORE = .TRUE.
            
         ELSEIF (CTYPE(1:4) == 'REFF' .OR. 
a410 1
     &        CTYPE(1:3) .NE. 'FOU' .AND.
d412 1
a412 2
     &       (CTYPE(1:2) .EQ. 'SH'  .AND. .NOT. CIRCREF_IN_CORE) .OR.
     &       (CTYPE(1:3) .EQ. 'FOU' .AND. .NOT. CIRCREF_IN_CORE)) THEN
d502 1
a502 2
     &      CTYPE(1:3) == 'REF' .OR.
     &      CTYPE(1:3) == 'FOU') THEN
d513 1
a513 2
     &      CTYPE(1:3) == 'FOU' .OR.
     &     (CTYPE(1:2) == 'SH'  .AND. .NOT. GPU) ) THEN
d534 1
a534 2
       IF ((CTYPE(1:3) == 'REF') .OR.
     &      CTYPE(1:3) == 'FOU'  .OR.
d536 1
a536 1
     &     (CTYPE(1:2) == 'SH'   .AND. .NOT. GPU)) THEN
a591 1
     &             CTYPE(1:3) == 'FOU'  .OR.
a646 3
       ELSEIF (GPU) THEN
C          MIRRORING TOO COMPLEX LOGIC FOR GPU
           CKMIRROR = .FALSE.
d679 1
a679 2
     &          CTYPE(1:3) == 'REF' .OR.
     &          CTYPE(1:3) == 'FOU' ) THEN
d713 1
a713 16
        IF (CTYPE(1:3) == 'FOU') THEN
C          --------------------'FOU'   ------------------------ 'AP FOU'
 
          IF (MYPID <= 0) WRITE(NOUT,*) 
     &           ' Calling: APFOU_PATM FOR: ',CTYPE(1:4),' -----------'
          CALL FLUSHFILE(6)

          CALL APFOU_PATM(INUMBR,NUMREF, IMGLST,NUMEXP, 
     &                NX,NY, RANGE,ANGDIFTHR,
     &                NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &                REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &                REFPAT,EXPPAT, CKMIRROR,CTYPE,
     &                ROTFIRST,ISHRANGEX,ISHRANGEY,
     &                NOUTANG,FBS_WANTED)

         ELSEIF (CTYPE(1:3) == 'REF') THEN
d755 1
a755 16
	   IF (GPU) THEN
C             FOR GPU ACCELERATED, USES COEF. TO SPEED UP APRINGS
 
              IF (MYPID <= 0) WRITE(NOUT,*)
     &             ' Calling: APSH_CUDA FOR: ',CTYPE(1:3),' ----------'
              IF (MYPID <= 0) WRITE(6,*)
     &             ' Calling: APSH_CUDA FOR: ',CTYPE(1:3),' ----------'
              CALL FLUSHFILE(6)

              CALL APSH_CUDA(INUMBR,NUMREF, IMGLST,NUMEXP, 
     &               NX,NY,ISHRANGEX,ISHRANGEY,ISTEP,
     &               NUMR,NRING,
     &               MODE, REFANGDOC,EXPANGDOC,FFTW_PLANS,
     &               REFPAT,EXPPAT,NOUTANG)

           ELSEIF (CIRCREF_IN_CORE .AND. (CTYPE(3:3) == 'C')) THEN
@


1.150
log
@prompts
@
text
@d51 1
d56 1
a56 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d214 1
a214 1
	   ISTEP      = MAX(ISTEP,1)
d261 7
a267 3
        IRAY = 1
        RAY1 = 0               ! FIRST RAY ANGLE
        RAY2 = 360             ! LAST  RAY ANGLE
d269 2
a270 2
        MR   = 5
        NR   = MIN(NX/2-1, NY/2-1)
d272 2
a273 1
	IF (CTYPE(1:2) == 'OR' .OR. CTYPE(1:3) == 'FOU' ) THEN
a316 2
        NRAD = MIN(NX/2-1, NY/2-1)

a324 4
	ELSEIF (NR >= NRAD)  THEN 
	   CALL ERRT(102,'LAST RING MUST BE < ',NRAD)
	   GOTO 9999

d327 3
a329 2
	   IF ((ISHRANGEX+NR)  > (NRAD-1))  THEN
	      CALL ERRT(102,'LAST RING + X TRANSLATION MUST BE <',NRAD)
d331 3
a333 2
	   ELSEIF ((ISHRANGEY+NR)  > (NRAD-1))  THEN
	      CALL ERRT(102,'LAST RING + Y TRANSLATION MUST BE <',NRAD)
d336 4
a339 8
        ENDIF
         IF (CTYPE(1:3) == 'FOU') THEN
C           PADDED TO DOUBLE SIZE 
            MR   = 2 * MR
            NR   = 2 * NR
            NRAD = 2 * NRAD
         ENDIF
        
@


1.149
log
@DENOISE selection added, FBS rot defaults
@
text
@d161 1
a161 1
     &           'ENTER TEMPLATE FOR REFERENCE IMAGES',IRTFLG)
d525 1
a525 1
     &        'ENTER TEMPLATE FOR IMAGE SERIES TO BE ALIGNED',IRTFLG)
@


1.148
log
@doc file header realigned
@
text
@a581 3
             DENOISE    = .FALSE.
             FBS_WANTED = .FALSE.
             CKMIRROR   = .FALSE.
d584 4
d598 2
d603 3
a605 3
                      FBS_WANTED = .TRUE.
                      IF (CTEMP == 'Q') FBS_WANTED = .FALSE.
                      IF (FBS_WANTED) DENOISE = .TRUE. 
d607 2
a608 1
                      IF (CTEMP == 'N') DENOISE = .FALSE. 
@


1.147
log
@DENOISE    = .FALSE. default
@
text
@d729 1
a729 1
     &         'NPROJ,   DIFF,    CCROT,    '     //
@


1.146
log
@CHECK MIRRORED POSITIONS?, SHIFT/ROTATE INPUT? (Y/N)
default is rt sf for rotate
@
text
@d582 2
a583 2
             DENOISE    = .TRUE.
             FBS_WANTED = .TRUE.
d600 3
a602 1
                      IF (CTEMP == 'Q') FBS_WANTED = .FALSE. 
@


1.145
log
@trap for undefined numth with no valid template
@
text
@d50 1
a50 1
C                   DENOISE                       SEP 12 ARDEAN LEITH
d574 2
a575 4
          IF ((CTYPE(1:3) == 'REF') .OR.
     &         CTYPE(1:3) == 'FOU'  .OR.
     &         CTYPE(1:2) == 'SH') THEN
C                      123456789012345678901234567890
d582 6
a587 3
             CKMIRROR = .FALSE.
             GOTMIR   = .FALSE.
             GOTRTSH  = .FALSE.
d598 1
d600 1
a600 2
                      FBS_WANTED = (CTEMP == 'F')
                      GOTRTSH    = .TRUE.
d602 1
a602 1
                      DENOISE    = .TRUE.
d621 39
d691 2
a692 2
     &     (LENC .GE. 4 .AND. CTYPE(4:4) == 'D') .OR.
     &     (LENC .GE. 5 .AND. CTYPE(5:5) == 'D')) WANTDOC = .TRUE.
@


1.144
log
@denoise in 'AP SHC', Aligning comment, trap for no ref. template
@
text
@d171 3
a173 1
     &     ' *** ERROR: Operation requires file template and numbers'
d727 1
a727 1
     &           NUMTH >1 .AND. NUMEXP >NUMTH) .OR. 
@


1.143
log
@denoise parameter for apsh shc
@
text
@d120 1
a120 1
	CHARACTER(LEN=80)      :: PROMPT
d158 1
a158 1

d170 2
d367 1
a367 1
            NRING = NRING + 1
a782 2
              CALL FLUSHFILE(6)

d788 24
d823 1
d841 1
a841 2
              CALL FLUSHFILE(6)

@


1.142
log
@flushfile 6 after calling output
@
text
@d50 1
d120 1
d125 1
d560 1
d570 8
a577 6
          IF (CTYPE(1:2) == 'SH'  .OR.
     &        CTYPE(1:3) == 'REF' .OR.
     &        CTYPE(1:3) == 'FOU') THEN
             CALL RDPRMC(ASK,NA,.TRUE.,
     &          'CHECK MIRRORED POSITIONS?, SHIFT/ROTATE INPUT? (Y/N)',
     &           NULL,IRTFLG)
d582 1
d586 2
a587 1
     &              CTEMP == 'Y' .OR. CTEMP == 'Q'.OR.
d592 1
a592 1
                   ELSE  
d595 3
d600 3
a602 1
                ELSEIF (CTEMP == '0' .OR. CTEMP == 'N') THEN
d606 3
d610 1
a610 1
                      ROTFIRST = .FALSE.
d720 1
a720 1
C           --------------------'REF'   ------------------------ 'AP REF'
a780 2
              IF (MYPID <= 0) WRITE(6,*)
     &           ' Calling: APSH_PSC FOR: ',CTYPE(1:5),' ----------'
d804 1
a804 1
     &               REFPAT,EXPPAT,RANGE,ROTFIRST,
a815 2
              IF (MYPID <= 0) WRITE(6,*) 
     &           ' Calling: APSH_PS FOR: ',CTYPE(1:3),' ----------'
a842 2
              IF (CTYPE(1:2) .NE. 'OR' .AND.  MYPID <= 0) WRITE(6,*) 
     &           ' Calling: APSH_SS FOR: ',CTYPE(1:3),' ----------'
a843 1

@


1.141
log
@CTEMP == 'Y' .OR. CTEMP == 'Q'.OR.
@
text
@d693 1
d712 1
d724 2
d752 1
d767 2
d804 2
d833 2
@


1.140
log
@*** empty log message ***
@
text
@d579 1
a579 1
     &              CTEMP == 'Y' .OR.
@


1.139
log
@NPLANS = 42 + 2   ! I THOUGHT 14 WAS ENUFF!!
@
text
@a0 1
myr
@


1.138
log
@fouless 2x
@
text
@d1 1
d373 1
a373 1
         NPLANS = 32 + 2   ! I THOUGHT 14 WAS ENUFF
d397 1
a397 1
	       CALL  ERRT(46,'APMASTER; CIRCREF',LCIRC*NUMTH)
@


1.137
log
@calling APFOU_PATM now
@
text
@d49 1
d328 6
d464 2
a465 1
         IF (CTYPE(1:1) == 'I' .OR. CTYPE(1:2) == 'MI') THEN
d655 1
a655 1
               IF (USE_LONGCOL) THEN
@


1.136
log
@removed APFOU_P call
@
text
@d40 1
a40 1
C                   WEIGHT = (YN == 'Y' ..      APR 11 ARDEAN LEITH
d263 1
a263 1
  
d282 6
a287 6
              IF (NGOT .GE. 1) MR    = VALUES(1)
              IF (NGOT .GE. 2) NR    = VALUES(2)
              IF (NGOT .GE. 3) ISKIP = VALUES(3)
              IF (NGOT .GE. 4) IRAY  = VALUES(4)
              IF (NGOT .GE. 5) RAY1  = VALUES(5)
              IF (NGOT .GE. 6) RAY2  = VALUES(6)
d309 1
a309 1
	ELSEIF (NR .LT. MR)  THEN 
d313 1
a313 1
	ELSEIF (NR .GE. NRAD)  THEN 
d327 1
a327 1
        RADI_MASK = NRAD -1   ! MASKING RADIUS
d337 1
a337 1
           IF (NREFA<=0) REFANGDOC = NULL
d340 1
a340 1
C        FIND NUMBER OF REFERENCE-RINGS
d426 1
a426 1
         IF ((CTYPE(1:2) == 'AL') .OR. 
d430 2
a431 2
     &       (CTYPE(1:2) == 'SH'  .AND. .NOT. CIRCREF_IN_CORE) .OR.
     &       (CTYPE(1:3) == 'FOU' .AND. .NOT. CIRCREF_IN_CORE)) THEN
d684 1
a684 1
     &           ' Calling: APFOU_P FOR: ',CTYPE(1:4),' -----------'
d686 2
a687 2
          CALL APFOU_PTRS(INUMBR,NUMREF, IMGLST,NUMEXP, 
     &                NX,NY, RANGE,ANGDIFTHR,RADI_MASK,
@


1.135
log
@USE_LONGCOL header values added
@
text
@d684 1
a684 1
     &           ' Calling: APFOU_P FOR: ',CTYPE(1:3),' -----------'
a692 10

#ifdef NEVER
          CALL APFOU_P(INUMBR,NUMREF, IMGLST,NUMEXP, 
     &                NX,NY, RANGE,ANGDIFTHR,RADI_MASK,
     &                NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &                REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &                REFPAT,EXPPAT, CKMIRROR,CTYPE,
     &                ROTFIRST,ISHRANGEX,ISHRANGEY,
     &                NOUTANG,FBS_WANTED)
#endif
@


1.134
log
@align doc file output col headers
@
text
@d647 10
a656 1
               COMMEN =' KEY       ' //
d658 2
a659 2
     &         'EXP#,  CUM.{ROT,   SX,    SY},  '//
     &         'NPROJ,   DIFF,    CCROT,    '      //
d661 2
@


1.133
log
@activated: APFOU_PTRS
@
text
@d40 1
a40 1
C                   WEIGHT = (YN == 'Y' ..        APR 11 ARDEAN LEITH
d647 5
a651 5
               COMMEN ='                 ' //
     &         ' PSI,          THE,          PHI,         REF#,     '//
     &         '   EXP#,    CUM. {INPLANE,      SX,          SY},  '//
     &         '        NPROJ,         DIFF,        CCROT,  '//
     &         '     INPLANE,          SX,            SY,       MIR-CC'
@


1.132
log
@blank output line removed
@
text
@d40 1
a40 1
C                   WEIGHT = (YN == 'Y' ..      APR 11 ARDEAN LEITH
d675 9
d691 1
@


1.131
log
@added search parameter echos
@
text
@a747 1
              IF (MYPID <= 0) WRITE(NOUT,*)
@


1.130
log
@ISHRANGEX > 0 for different ranges and steps bug
@
text
@d48 1
d664 1
d744 17
d779 11
@


1.129
log
@added FBS_WANTED param. to apfou call
@
text
@d192 2
a193 2
	   ISHRANGE   = MAX(ISHRANGE,1)       
	   ISHRANGEX  = ISHRANGE            ! _ & 5
d200 2
a201 2
           ELSE                              ! 5,3,1
              ISHRANGEY = MAX(1,IVAL2)
d213 3
a215 2
	   ELSEIF (MOD(ISHRANGEX,ISTEP) .NE. 0) THEN
	      CALL ERRT(101,'X SEARCH RANGE MUST BE DIVISIBLE BY',ISTEP)
d217 3
a219 2
	   ELSEIF (MOD(ISHRANGEY,ISTEP) .NE. 0) THEN
	      CALL ERRT(101,'Y SEARCH RANGE MUST BE DIVISIBLE BY',ISTEP)
d229 1
a229 1
           IF (IVAL2 == 999999) THEN       ! 5
d231 1
a231 1
           ELSE                              ! 5,3,1
@


1.128
log
@FBS_WANTED = (CTEMP == 'F') on rotfirst query
@
text
@d676 2
a677 1
     &                ROTFIRST,ISHRANGEX,ISHRANGEY,NOUTANG)
@


1.127
log
@FBS_WANTED set for various ap ops
@
text
@d546 4
a549 2
       ROTFIRST = .FALSE.
       CKMIRROR = .TRUE.
d553 1
a553 1
     &     (CTYPE(1:2) == 'SH'  .AND. .NOT. GPU)) THEN
d567 3
a569 1
                IF (CTEMP == '1' .OR. CTEMP == 'Y') THEN
d571 2
a572 2
                      CKMIRROR = .TRUE.
                      GOTMIR   = .TRUE.
d574 2
a575 1
                      ROTFIRST = .TRUE.
a667 2
          FBS_WANTED = ROTFIRST .AND. ( CTYPE(4:4) == 'F' )

a680 2
            FBS_WANTED = ROTFIRST .AND. ( CTYPE(4:4) == 'F' )

a738 2
              FBS_WANTED = ROTFIRST .AND. ( CTYPE(4:4) == 'F' )

a757 2
              FBS_WANTED = ROTFIRST .AND. ( CTYPE(4:4) == 'F' )

a772 2

              FBS_WANTED = ROTFIRST .AND. ( CTYPE(4:4) == 'F' ) !???
@


1.126
log
@,FBS_WANTED on some ap... calls[D[D[
@
text
@d663 2
d678 2
d738 2
a739 1
              FBS_WANTED = ( CTYPE(4:4) == 'F' )
d759 2
d776 2
@


1.125
log
@fbs support in ap shcf
@
text
@d688 2
a689 1
     &                CKMIRROR,CTYPE,ROTFIRST,ISHRANGE,NOUTANG)
d699 2
a700 1
     &               CKMIRROR,CTYPE,ROTFIRST,ISHRANGE,NOUTANG)
d759 1
a759 1
     &               CKMIRROR,CTYPE,NOUTANG)
d775 1
a775 1
     &               CKMIRROR,CTYPE,NOUTANG)
@


1.124
log
@added ROTFIRST to apsh_* calls
@
text
@d40 1
a40 1
C                   WEIGHT = (YN .EQ. 'Y' ..      APR 11 ARDEAN LEITH
d47 1
d52 1
a52 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d120 1
a120 1
        LOGICAL                :: ROTFIRST,GOTMIR 
d138 1
a138 1
        IF (CTYPE(1:3) .EQ. 'SHC') THEN
d144 1
a144 1
        IF (CTYPE(1:2) .EQ. 'OR') THEN
d146 2
a147 2
           CALL OPFILEC(0,.TRUE.,REFPAT,LUNREF,'O',ITYPE,NSAM,NROW,
     &               NSLICE,MAXIM,'REFERENCE',.FALSE.,IRTFLG)
d159 1
a159 1
           IF (MYPID .LE. 0) WRITE(NOUT,2001) NUMREF
d164 1
a164 1
        IF (NUMREF .LE. 0)  THEN
d170 1
a170 1
        IF (CTYPE(1:2) .EQ. 'OR') THEN
d178 1
a178 1
        CALL OPFILEC(0,.FALSE.,FILNAM,LUNREF,'O',IFORM,NSAM,NROW,NSLICE,
d186 2
a187 2
        IF (CTYPE(1:2) .EQ. 'SH'  .OR.
     &      CTYPE(1:2) .EQ. 'OR') THEN
d194 1
a194 1
           IF (IVAL2 .EQ. 999999) THEN       ! 5
d197 1
a197 1
           ELSEIF (IVAL3 .EQ. 999999) THEN   ! 5,6
d207 2
a208 2
	   IF (ISHRANGEX .GT. NSAM/2-2)  THEN
	      CALL ERRT(102,'X SEARCH MUST BE LESS THAN',NSAM/2-2)
d210 2
a211 2
	   ELSEIF (ISHRANGEY .GT. NSAM/2-2)  THEN
	      CALL ERRT(102,'Y SEARCH MUST BE LESS THAN',NSAM/2-2)
d221 1
a221 1
        ELSEIF ( CTYPE(1:3) .EQ. 'FOU' ) THEN
d227 1
a227 1
           IF (IVAL2 .EQ. 999999) THEN       ! 5
d235 2
a236 2
	   IF (ISHRANGEX .GT. NSAM/2-2)  THEN
	      CALL ERRT(102,'X SEARCH MUST BE LESS THAN',NSAM/2-2)
d238 2
a239 2
	   ELSEIF (ISHRANGEY .GT. NSAM/2-2)  THEN
	      CALL ERRT(102,'Y SEARCH MUST BE LESS THAN',NSAM/2-2)
d243 1
a243 1
        ELSEIF ( CTYPE(1:3) .EQ. 'REF' ) THEN
d254 1
a254 1
        NR   = MIN(NSAM/2-1, NROW/2-1)
d256 1
a256 1
	IF (CTYPE(1:2) .EQ. 'OR' .OR. CTYPE(1:3) .EQ. 'FOU' ) THEN
d277 1
a277 1
           IF (NGOT .GT. 0) THEN
d287 1
a287 1
           IF ( CTYPE(1:2) .NE. 'SH' .AND. ISKIP .LE. 0) THEN
d300 1
a300 1
        NRAD = MIN(NSAM/2-1, NROW/2-1)
d302 1
a302 1
	IF (MR .LE. 0) THEN
d314 1
a314 1
	ELSEIF (CTYPE(1:2) .EQ. 'SH') THEN
d316 1
a316 1
	   IF ((ISHRANGEX+NR) .GT. (NRAD-1))  THEN
d319 1
a319 1
	   ELSEIF ((ISHRANGEY+NR) .GT. (NRAD-1))  THEN
d327 3
a329 3
        IF (CTYPE(1:3) .EQ. 'REF' .OR. 
     &      CTYPE(1:3) .EQ. 'FOU' .OR.
     &      CTYPE(1:2) .EQ. 'SH') THEN
d334 1
a334 1
           IF (NREFA.LE.0) REFANGDOC = NULL
d372 1
a372 1
         GPU = (CTYPE(1:4) .EQ. 'SH G')
d377 3
a379 3
         ELSEIF (CTYPE(1:4) .EQ. 'REFF' .OR. 
     &           CTYPE(1:3) .EQ. 'SHF'  .OR. 
     &           CTYPE(1:1) .EQ. 'I' ) THEN
d384 1
a384 1
               IF (MYPID .LE. 0) WRITE(NOUT,92) LCIRC,NUMTH
d389 1
a389 1
            IF (MYPID .LE. 0) WRITE(NOUT,93) LCIRC,NUMTH
d399 1
a399 1
            IF (IRTFLG .EQ. 0) THEN 
d402 1
a402 1
               IF (MYPID .LE. 0) WRITE(NOUT,91) LCIRC,NUMREF,NTOT
d407 1
a407 1
               IF (MYPID .LE. 0) WRITE(NOUT,90) LCIRC,NUMREF,NTOT
d423 1
a423 1
         IF ((CTYPE(1:2) .EQ. 'AL') .OR. 
d427 2
a428 2
     &       (CTYPE(1:2) .EQ. 'SH'  .AND. .NOT. CIRCREF_IN_CORE) .OR.
     &       (CTYPE(1:3) .EQ. 'FOU' .AND. .NOT. CIRCREF_IN_CORE)) THEN
d435 1
a435 1
            IF (ASK(1:NA) .EQ. 'W') THEN
d439 1
a439 1
            ELSEIF (NA .LE. 3 .AND. ASK(1:1) .EQ. 'N' .AND. 
d444 1
a444 1
            ELSEIF (NA .LE. 3 .AND. ASK(1:1) .EQ. 'Y') THEN
d446 1
a446 1
               IF (MYPID .LE. 0) WRITE(NOUT,*) 
d454 1
a454 1
         IF (CTYPE(1:1) .EQ. 'I' .OR. CTYPE(1:2) .EQ. 'MI') THEN
d465 1
a465 1
           WEIGHT = (YN .EQ. 'Y' .OR. YN .EQ. 'y')
d469 1
a469 1
     &                          FFTW_PLANS,NPLANS,NSAM,NROW,IRTFLG)
d472 1
a472 1
     &                  NSAM,NROW,NUMTH,
d481 1
a481 1
399     IF (CTYPE(1:2) .EQ. 'OR') THEN
d485 1
a485 1
     &                  NSAM,NROW,NSLICE,MAXIM,'EXPERIMENTAL IMAGE',
d510 1
a510 1
            IF (MYPID .LE. 0) WRITE(NOUT,2002) NUMEXP
d516 3
a518 3
        IF (CTYPE(1:2) .EQ. 'SH'  .OR. 
     &      CTYPE(1:3) .EQ. 'REF' .OR.
     &      CTYPE(1:3) .EQ. 'FOU') THEN
d523 1
a523 1
           IF (NEXPA .EQ. 0) EXPANGDOC = NULL
d528 3
a530 3
        IF (CTYPE(1:3) .EQ. 'REF' .OR.
     &      CTYPE(1:3) .EQ. 'FOU' .OR.
     &     (CTYPE(1:2) .EQ. 'SH'  .AND. .NOT. GPU) ) THEN
d537 1
a537 1
           IF (RANGE .GT. 0.0 .AND. EXPANGDOC .EQ. NULL) THEN
d548 8
a555 8
       IF ((CTYPE(1:3) .EQ. 'REF') .OR.
     &      CTYPE(1:3) .EQ. 'FOU'  .OR.
     &      CTYPE(1:3) .EQ. 'ORS'  .OR.
     &     (CTYPE(1:2) .EQ. 'SH'  .AND. .NOT. GPU)) THEN

          IF (CTYPE(1:2) .EQ. 'SH'  .OR.
     &        CTYPE(1:3) .EQ. 'REF' .OR.
     &        CTYPE(1:3) .EQ. 'FOU') THEN
d565 1
a565 1
                IF (CTEMP .EQ. '1' .OR. CTEMP .EQ. 'Y') THEN
d573 1
a573 1
                ELSEIF (CTEMP .EQ. '0' .OR. CTEMP .EQ. 'N') THEN
d592 1
a592 1
                IF (CTEMP .EQ. '1' .OR. CTEMP .EQ. 'Y') THEN
d595 1
a595 1
                ELSEIF (CTEMP .EQ. '0' .OR. CTEMP .EQ. 'N') THEN
d612 1
a612 1
       IF  (FCHAR(1:2) .EQ. 'OR') WANTDOC = .FALSE.
d615 2
a616 2
     &     (LENC .GE. 4 .AND. CTYPE(4:4) .EQ. 'D') .OR.
     &     (LENC .GE. 5 .AND. CTYPE(5:5) .EQ. 'D')) WANTDOC = .TRUE.
d629 1
a629 1
         IF (IRTFLG .EQ. -1) THEN
d636 3
a638 3
            IF (CTYPE(1:2) .EQ. 'SH'  .OR. 
     &          CTYPE(1:3) .EQ. 'REF' .OR.
     &          CTYPE(1:3) .EQ. 'FOU' ) THEN
d658 1
a658 1
     &                          FFTW_PLANS,NPLANS,NSAM,NROW,IRTFLG)
d660 1
a660 1
        IF (CTYPE(1:3) .EQ. 'FOU') THEN
d663 1
a663 1
          IF (MYPID .LE. 0) WRITE(NOUT,*) 
d667 1
a667 1
     &                NSAM,NROW, RANGE,ANGDIFTHR,RADI_MASK,
d673 1
a673 1
         ELSEIF (CTYPE(1:3) .EQ. 'REF') THEN
d677 2
a678 2
     &           NUMTH.GT.1 .AND. NUMEXP.GT.NUMTH) .OR. 
     &           CTYPE(3:3) .EQ. 'T' .OR. CTYPE(4:4) .EQ. 'T') THEN
d680 1
a680 1
               IF (MYPID .LE. 0) WRITE(NOUT,*) 
d684 1
a684 1
     &                NSAM,NROW, ANGDIFTHR,RANGE,
d690 1
a690 1
               IF (MYPID .LE. 0) WRITE(NOUT,*) 
d694 1
a694 1
     &               NSAM,NROW,RANGE,ANGDIFTHR,
d701 3
a703 3
        ELSEIF (CTYPE(1:2) .EQ. 'SH' .OR.
     &          CTYPE(1:2) .EQ. 'AL' .OR.
     &          CTYPE(1:2) .EQ. 'OR') THEN
d713 1
a713 1
              IF (MYPID .LE. 0) WRITE(NOUT,*)
d715 1
a715 1
              IF (MYPID .LE. 0) WRITE(6,*)
d719 1
a719 1
     &               NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d724 1
a724 1
           ELSEIF (CIRCREF_IN_CORE .AND. (CTYPE(3:3) .EQ. 'C')) THEN
d727 1
a727 1
              IF (MYPID .LE. 0) WRITE(NOUT,*)
d729 1
a729 1
              IF (MYPID .LE. 0) WRITE(6,*)
d732 1
d734 1
a734 1
     &               NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d738 1
a738 1
     &               CKMIRROR,CTYPE,NOUTANG,RAY1,RAY2)
d741 1
a741 1
     &             NUMEXP .GE. NUMTH    .AND. 
d747 1
a747 1
              IF (MYPID .LE. 0) WRITE(NOUT,*)
d749 1
a749 1
              IF (MYPID .LE. 0) WRITE(6,*) 
d753 1
a753 1
     &               NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d763 1
a763 1
              IF (CTYPE(1:2) .NE. 'OR' .AND. MYPID .LE. 0) WRITE(NOUT,*) 
d765 1
a765 1
              IF (CTYPE(1:2) .NE. 'OR' .AND.  MYPID .LE. 0) WRITE(6,*) 
d769 1
a769 1
     &               NSAM,NROW,ISHRANGEX,ISHRANGEY,ISTEP,
d779 1
a779 1
           IF (MYPID .EQ. 0)  WRITE(6, 222) T1
d787 1
a787 1
9990     IF (MYPID .LE. 0 .AND. VERBOSE) WRITE (NOUT,2600)
@


1.123
log
@RADI_MASK added for AP_FOU
@
text
@d46 1
d552 1
a552 1
          IF (CTYPE(1:3) .EQ. 'SHC' .OR.
d754 2
a755 1
     &               REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,NOUTANG)
d770 1
a770 1
     &               REFPAT,EXPPAT,RANGE,
@


1.122
log
@RAY1,RAY2 for apsh_psc call
@
text
@d322 1
d665 1
a665 1
     &                NSAM,NROW, RANGE,ANGDIFTHR,
@


1.121
log
@apsh_psc parameters wrong --> filename bug
@
text
@d45 1
d247 3
a249 3
        IRAY  = 1
        IRAY1 = 1               ! FIRST RAY ANGLE
        IRAY2 = 360             ! LAST  RAY ANGLE
d268 2
a269 2
           VALUES(5) = IRAY1
           VALUES(6) = IRAY2
d281 2
a282 2
              IF (NGOT .GE. 5) IRAY1 = VALUES(5)
              IF (NGOT .GE. 6) IRAY2 = VALUES(6)
d734 1
a734 1
     &               CKMIRROR,CTYPE,NOUTANG) !! unfinished ,IRAY1,IRAY2)
@


1.120
log
@APFOU_P changes
@
text
@d733 1
a733 1
     &               CKMIRROR,CTYPE,NOUTANG,IRAY1,IRAY2)
@


1.119
log
@typo
@
text
@d118 1
a118 1
        REAL                   :: VALUES(4)
d246 4
a249 1
        IRAY = 1
d260 2
d267 2
d271 1
a271 1
     &                4,0,.TRUE.,VALUES,NGOT,IRTFLG)
d280 2
d659 2
a660 2
           IF (MYPID .LE. 0) WRITE(NOUT,*) 
     &           ' Removed: APFOU_P FOR: ',CTYPE(1:3),' -----------'
d662 6
a667 6
c          CALL APFOU_P(INUMBR,NUMREF, IMGLST,NUMEXP, !!!!!!!!
c     &                NSAM,NROW, RANGE,ANGDIFTHR,
c     &                NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
c     &                REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
c     &                REFPAT,EXPPAT, CKMIRROR,CTYPE,
c     &                ROTFIRST,ISHRANGEX,ISHRANGEY,NOUTANG)
d733 1
a733 1
     &               CKMIRROR,CTYPE,NOUTANG)
@


1.118
log
@APSH_FOU support, chkmirror parsing ok,
@
text
@d250 1
a250 1
	IF (CTYPE(1:2) .EQ. 'OR' .OR. CTYPE(1:3) .EQ. 'FOU')) THEN
@


1.117
log
@CKMIRROR PARSING
@
text
@d7 1
a7 1
C                   SAVDN1 + SAVD BUG             JAN 02 ArDean Leith
d43 1
d85 1
d117 1
a117 1
        LOGICAL                :: ROTFIRST,GOTMIR
a133 6
#ifndef SP_LIBFFTW3
        IF (CTYPE(1:3) .EQ. 'SHC') THEN
           CALL ERRT(101,"USE 'AP SH' INSTEAD",NDUM)
           RETURN
        ENDIF
#endif
d171 1
a171 1
           CALL  FILGET(REFPAT,FILNAM,NLET,INUMBR(1),INTFLG)
d183 1
a183 1
        IF (CTYPE(1:2) .EQ. 'SH' .OR.
d218 22
d249 2
a250 1
	IF (CTYPE(1:2) .EQ. 'OR') THEN
d253 2
d315 2
a316 1
     &       CTYPE(1:2) .EQ. 'SH') THEN
d412 1
d414 2
a415 1
     &       (CTYPE(1:2) .EQ. 'SH' .AND. .NOT. CIRCREF_IN_CORE)) THEN
d440 1
d462 1
a462 1
     &                  CIRCREF,NUMTH,LUNRING,WEIGHT,IRTFLG)
d503 3
a505 1
        IF (CTYPE(1:2) .EQ. 'SH' .OR. CTYPE(1:3) .EQ. 'REF') THEN
d516 1
d536 1
d541 2
a542 1
     &        CTYPE(1:3) .EQ. 'REF') THEN
d572 1
d588 1
a588 1
           
d590 2
a591 2
C         MIRRORING TOO COMPLEX LOGIC FOR GPU
          CKMIRROR = .FALSE.
d623 3
a625 1
            IF (CTYPE(1:2) .EQ. 'SH' .OR. CTYPE(1:3) .EQ. 'REF' ) THEN
d647 14
a660 1
        IF (CTYPE(1:3) .EQ. 'REF') THEN
d671 1
a671 1
     &                NSAM,NROW,ANGDIFTHR,RANGE,
@


1.116
log
@for fbp in aprings_init
@
text
@d43 1
d111 1
a111 1
	CHARACTER(LEN=1)       :: NULL,ANS,YN
d115 1
a115 1
        LOGICAL                :: ROTFIRST
d517 24
a540 2
             CKMIRROR = (ASK(1:1) .NE. '0' .AND. ASK(1:1) .NE. 'N')
             ROTFIRST  = (NA > 1 .AND.  (INDEX(ASK(2:),'Y') > 0))
d544 12
a555 2
                IF (IRTFLG .NE. 0) GOTO 9999
                CKMIRROR = (ASK(1:1) .NE. '0' .AND. ASK(1:1) .NE. 'N')
d557 5
a561 4
        ELSEIF (GPU) THEN
C          MIRRORING TOO COMPLEX LOGIC FOR GPU
           CKMIRROR = .FALSE.
        ENDIF
@


1.115
log
@doc file header line formatting
/
@
text
@d42 1
d430 1
a430 1
     &                          FFTW_PLANS,NPLANS,IRTFLG)
d578 1
a578 1
     &                          FFTW_PLANS,NPLANS,IRTFLG)
@


1.114
log
@cosmetic
@
text
@d110 1
a110 1
	CHARACTER(LEN=210)     :: COMMEN
d559 4
a562 4
     &         'PSI,           THE,          PHI,         REF#,     '//
     &         '   EXP#,     CUM. {INPLANE,    SX,         SY},  '//
     &         '        NPROJ,           DIFF,        CCROT,   '//
     &         '    INPLANE,         SX,          SY,         MIR-CC'
@


1.113
log
@doc file output comment header formatting
@
text
@d562 1
a562 1
     &         '    INPLANE,         SX,                                   SY,         MIR-CC'
@


1.112
log
@CHKMIRROR typo
@
text
@d559 4
a562 4
     &         'PSI,        THE,         PHI,         REF#,     '//
     &         '  EXP#,     CUM. {INPLANE,    SX,         SY},  '//
     &         '      NPROJ,        DIFF,       CCROT,   '//
     &         '   INPLANE,        SX,         SY,         MIR-CC'
@


1.111
log
@NPLANS = 32 + 2   ! I THOUGHT 14 WAS ENUFF
@
text
@d515 1
a515 1
             CHKMIRROR = (ASK(1:1) .NE. '0' .AND. ASK(1:1) .NE. 'N')
d521 1
a521 1
                CHKMIRROR = (ASK(1:1) .NE. '0' .AND. ASK(1:1) .NE. 'N')
d615 1
@


1.110
log
@NPLANS allocation changed
@
text
@d315 1
a315 1
            NRING = NRING+1
d325 1
a325 1
         NPLANS = 2*NUMTH+2
a331 1

d349 1
a349 1
	       CALL  ERRT(46,'CIRCREF',LCIRC*NUMTH)
d380 1
a380 1
	          CALL  ERRT(46,'CIRCREF',LCIRC*NUMTH)
d451 1
a451 1
                CALL ERRT(46,'IMGLST',1)
d461 1
a461 1
               CALL ERRT(46,'IMGLST',NILMAX)
@


1.109
log
@nplans = 64
@
text
@d41 1
d98 8
a115 9
        INTEGER, PARAMETER     :: NPLANS = 64 
#ifndef SP_32
        INTEGER *8             :: IASK8,IOK
        INTEGER *8             :: FFTW_PLANS(NPLANS)
#else
        INTEGER *4             :: IASK8,IOK
        INTEGER *4             :: FFTW_PLANS(NPLANS)
#endif

d308 1
a308 1
            CALL ERRT(46,'NUMR',3*NRING)
d325 8
d694 5
a698 3
9999     IF (ALLOCATED(IMGLST))  DEALLOCATE(IMGLST)
	 IF (ALLOCATED(NUMR))    DEALLOCATE(NUMR)
         IF (ALLOCATED(CIRCREF)) DEALLOCATE(CIRCREF)
@


1.108
log
@WEIGHT = mispelled WEIGTH bug
@
text
@d107 1
a107 1
        INTEGER, PARAMETER     :: NPLANS = 14
@


1.107
log
@AP_REF --> APREF_P , NEXPA .EQ. 0) EXPANGDOC = NULL
@
text
@d40 1
d418 1
a418 1
           WEIGTH = (YN .EQ. 'Y' .OR. YN .EQ. 'y')
@


1.106
log
@ap_sh --> apsh in names
@
text
@d39 1
d70 2
a71 2
C    'AP REF'  -- AP_REF_P or AP_REF_PM
C    'AP REFT' -- FORCES: AP_REF_PM
d295 2
a296 2
C          FILERD WILL RETURN IRTFLG=1 IF "*" !!!!
           IF (REFANGDOC(:1) .EQ. '*' .OR.NREFA.LE.0) REFANGDOC = NULL
d473 1
a473 1
           IF (NEXPA .EQ. 0 .OR.EXPANGDOC(:1) .EQ. '*')EXPANGDOC = NULL
d572 1
a572 1
C           --------------------'REF'   ------------------------ AP_REF
d579 1
a579 1
     &           ' Calling: AP_REF_PM FOR: ',CTYPE(1:3),' -----------'
d581 1
a581 1
               CALL AP_REF_PM(INUMBR,NUMREF,IMGLST,NUMEXP,
d589 1
a589 1
     &            ' Calling: AP_REF_P FOR: ',CTYPE(1:3),' -----------'
d591 1
a591 1
               CALL AP_REF_P(INUMBR,NUMREF,IMGLST,NUMEXP,
d602 1
a602 1
C        ---- ' SH', 'ORS',  ----------------------------------- AP_SH
@


1.105
log
@ROTFIRST on _REF calls
@
text
@d34 1
a34 1
C                   CUDA, AP_SH_SS PARAMETERS     APR 10 ARDEAN LEITH
d73 2
a74 2
C    'AP SH'   -- AP_SH_SS or AP_SH_PS
C    'AP SHC'  -- AP_SH_PSC; COEFF, NON-TRANSFORMED RINGS, CPLX VAR.
d76 1
a76 1
C    'AP SHT'  -- FORCES: AP_SH_SS
d610 1
a610 1
     &             ' Calling: AP_SH_CUDA FOR: ',CTYPE(1:3),' ----------'
d612 1
a612 1
     &             ' Calling: AP_SH_CUDA FOR: ',CTYPE(1:3),' ----------'
d614 1
a614 1
              CALL AP_SH_CUDA(INUMBR,NUMREF, IMGLST,NUMEXP, 
d624 1
a624 1
     &           ' Calling: AP_SH_PSC FOR: ',CTYPE(1:5),' ----------'
d626 1
a626 1
     &           ' Calling: AP_SH_PSC FOR: ',CTYPE(1:5),' ----------'
d628 1
a628 1
              CALL AP_SH_PSC(INUMBR,NUMREF,IMGLST,NUMEXP, 
d643 1
a643 1
     &           ' Calling: AP_SH_PS FOR: ',CTYPE(1:3),' ----------'
d645 1
a645 1
     &           ' Calling: AP_SH_PS FOR: ',CTYPE(1:3),' ----------'
d647 1
a647 1
              CALL AP_SH_PS(INUMBR,NUMREF,IMGLST,NUMEXP, 
d658 1
a658 1
     &           ' Calling: AP_SH_SS FOR: ',CTYPE(1:3),' ----------'
d660 1
a660 1
     &           ' Calling: AP_SH_SS FOR: ',CTYPE(1:3),' ----------'
d662 1
a662 1
              CALL AP_SH_SS(INUMBR,NUMREF,IMGLST,NUMEXP, 
@


1.104
log
@SHIFT/ROTATE INPUT? (Y/N), rotfirst in ap_sh_psc
@
text
@d88 3
d98 1
a98 1
	CHARACTER(LEN=1)       :: MODE,NULL,ANS,YN
a99 1
	CHARACTER(LEN=*)       :: CTYPE
d114 9
a124 3
	DATA  LUNREF,LUNEXP,LUNRING/50,51,52/
	DATA  INPIC,INANG,NDOC,NSCF/77,78,55,50/ !USED IN CALLED ROUTINE

a125 1

d130 1
a130 1
           CALL ERRT(101,"USE 'AP SH' INSTEAD",MWANT)
d492 1
a492 1
        ENDIF
d500 2
a501 1
          IF (CTYPE(1:3) .EQ. 'SHC') THEN
d510 1
a510 2
     &          'CHECK MIRRORED POSITIONS? (Y/N)',
     &           NULL,IRTFLG)
d584 2
a585 1
     &                REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,NOUTANG)
d594 2
a595 1
     &               REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,NOUTANG)
d666 2
a667 1
     &               REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,NOUTANG)
@


1.103
log
@renamed mrqli & dsgr...
@
text
@d100 1
d123 1
a123 1
           CALL ERRT(101,'USE "AP SH" INSTEAD',MWANT)
d129 1
a129 1
           CALL ERRT(101,'SUB-OPERATION NOT ON MPI, USE AP SH',NDUM)
d487 20
a506 10
        CKMIRROR = .TRUE.
        IF ((CTYPE(1:3) .EQ. 'REF') .OR.
     &       CTYPE(1:3) .EQ. 'ORS' .OR.
     &      (CTYPE(1:2) .EQ. 'SH' .AND. .NOT. GPU)) THEN
           CALL RDPRI1S(IMIRROR,NOT_USED,
     &         'CHECK MIRRORED POSITIONS (0=NOCHECK / 1=CHECK)?',
     &          IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999
           CKMIRROR = (IMIRROR .NE. 0)

d508 1
d615 1
a615 1
     &           'Calling: AP_SH_PSC FOR: ',CTYPE(1:5),' ----------'
d617 1
a617 1
     &           'Calling: AP_SH_PSC FOR: ',CTYPE(1:5),' ----------'
d623 2
a624 1
     &               REFPAT,EXPPAT,RANGE,CKMIRROR,CTYPE,NOUTANG)
@


1.102
log
@CTYPE(4:4) .NE. 'T') .AND. bug
@
text
@d14 1
a14 1
C                   MERGED WITH MRQLI1            SEP 03 ARDEAN LEITH
d34 1
a34 1
C                   CUDA, MRQLI_SS PARAMETERS     APR 10 ARDEAN LEITH
d38 1
d43 1
a43 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d69 2
a70 2
C    'AP REF'  -- DSGR_P or DSGR_PM
C    'AP REFT' -- FORCES: DSGR_PM
d73 2
a74 2
C    'AP SH'   -- MRQLI_SS or MRQLI_PS
C    'AP SHC'  -- MRQLI_PSC; COEFF, NON-TRANSFORMED RINGS, CPLX VAR.
d76 1
a76 1
C    'AP SHT'  -- FORCES: MRQLI_SS
d491 2
a492 1
     &         'CHECK MIRRORED POSITIONS (0=NOCHECK / 1=CHECK)?',IRTFLG)
d552 1
a552 1
C           --------------------'REF'   -------------------------- DSGR
d559 1
a559 1
     &           ' Calling: DSGR_PM FOR: ',CTYPE(1:3),' -----------'
d561 1
a561 1
               CALL DSGR_PM(INUMBR,NUMREF,IMGLST,NUMEXP,
d568 1
a568 1
     &            ' Calling: DSGR_P FOR: ',CTYPE(1:3),' -----------'
d570 1
a570 1
               CALL DSGR_P(INUMBR,NUMREF,IMGLST,NUMEXP,
d580 1
a580 1
C        ---- ' SH', 'ORS',  ----------------------------------- MRQLI
d589 1
a589 1
     &             ' Calling: MRQLI_CUDA FOR: ',CTYPE(1:3),' ----------'
d591 1
a591 1
     &             ' Calling: MRQLI_CUDA FOR: ',CTYPE(1:3),' ----------'
d593 1
a593 1
              CALL MRQLI_CUDA(INUMBR,NUMREF, IMGLST,NUMEXP, 
d603 1
a603 1
     &           'Calling: MRQLI_PSC FOR: ',CTYPE(1:5),' ----------'
d605 1
a605 1
     &           'Calling: MRQLI_PSC FOR: ',CTYPE(1:5),' ----------'
d607 1
a607 1
              CALL MRQLI_PSC(INUMBR,NUMREF,IMGLST,NUMEXP, 
d621 1
a621 1
     &           ' Calling: MRQLI_PS FOR: ',CTYPE(1:3),' ----------'
d623 1
a623 1
     &           ' Calling: MRQLI_PS FOR: ',CTYPE(1:3),' ----------'
d625 1
a625 1
              CALL MRQLI_PS(INUMBR,NUMREF,IMGLST,NUMEXP, 
d636 1
a636 1
     &           ' Calling: MRQLI_SS FOR: ',CTYPE(1:3),' ----------'
d638 1
a638 1
     &           ' Calling: MRQLI_SS FOR: ',CTYPE(1:3),' ----------'
d640 1
a640 1
              CALL MRQLI_SS(INUMBR,NUMREF,IMGLST,NUMEXP, 
@


1.101
log
@CTYPE(1:2) .EQ. 'MQ' removed, mrqli_psc type
@
text
@d611 5
a615 5
	   ELSEIF (CIRCREF_IN_CORE  .AND. 
     &         NUMEXP .GE. NUMTH    .AND. 
     &         CTYPE(3:3) .NE. 'T'  .AND. 
     &         CTYPE(4:4) .NE. 'T') .AND.
     &         CTYPE(1:2) .NE. 'OR') THEN
@


1.100
log
@no 'or' calling msg, AP SHC msg longer
@
text
@d73 1
a73 1
C    'AP SHC'  -- MRQLI_PSC; COEFF, TRANSFORMED RINGS, INCORE RINGS
d119 10
a128 15
        IF (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &      CTYPE(1:2) .EQ. 'NQ' .OR. 
     &      CTYPE(1:2) .EQ. 'RQ') THEN

            CALL ERRT(101,'OBSOLETE OPERATION, USE <AP SH>',NDUM)
            RETURN
        ELSEIF (CTYPE(1:2) .EQ. 'MD' .OR.
     &          CTYPE(1:2) .EQ. 'RD' .OR. 
     &          CTYPE(1:2) .EQ. 'RN') THEN
            CALL ERRT(101,'OBSOLETE OPERATION, USE <AP REF>',NDUM)
            RETURN
        ELSEIF (CTYPE(1:3) .EQ. 'ORN' .OR.
     &          CTYPE(1:2) .EQ. 'ORM') THEN
            CALL ERRT(101,'OBSOLETE OPERATION, USE <OR SH>',NDUM)
            RETURN
d130 1
d601 1
a601 1
     &           ' Calling: MRQLI_PSC FOR: ',CTYPE(1:5),' ----------'
d603 1
a603 1
     &           ' Calling: MRQLI_PSC FOR: ',CTYPE(1:5),' ----------'
d613 3
a615 2
     &        (CTYPE(3:3) .NE. 'T'  .AND. CTYPE(4:4) .NE. 'T') .AND.
     &        (CTYPE(1:2) .NE. 'OR')) THEN
@


1.99
log
@no calling msg for: OR
@
text
@d36 2
a37 1
C                   AP REF REGISTER ONLY BUG      AUG 10 ARDEAN LEITH
d590 1
a590 2
              IF (CTYPE(1:2) .NE. 'OR') THEN         
                 IF (MYPID .LE. 0) WRITE(NOUT,*)
d592 1
a592 1
                 IF (MYPID .LE. 0) WRITE(6,*)
d594 1
a594 1
              ENDIF      
d605 3
a607 2
     &           ' Calling: MRQLI_PSC FOR: ',CTYPE(1:3),' ----------'
              WRITE(6,*)' Calling: MRQLI_PSC FOR: ',CTYPE(1:4),'-------'
d620 1
d636 1
a636 1
              IF (MYPID .LE. 0) WRITE(NOUT,*) 
d638 1
a638 1
              IF (MYPID .LE. 0) WRITE(6,*) 
@


1.98
log
@WANTDOC bug for AP REF fixed
@
text
@d588 7
a594 6
          
              IF (MYPID .LE. 0) WRITE(NOUT,*)
     &           ' Calling: MRQLI_CUDA FOR: ',CTYPE(1:3),' ----------'
              IF (MYPID .LE. 0) WRITE(6,*)
     &           ' Calling: MRQLI_CUDA FOR: ',CTYPE(1:3),' ----------'
     &           
@


1.97
log
@NSAM,NROW,NR,ISHRANGEX -> NSAM,NROW,ISHRANGEX
@
text
@d36 1
d70 1
d97 1
a97 1
        LOGICAL                :: WINDOW,NEWFILE,WEIGHT,GPU
d503 1
d505 9
a513 1
       IF (FCHAR(1:2) .EQ. 'OR') THEN
d530 1
a530 1
            IF (CTYPE(1:3) .EQ. 'REF' .OR. CTYPE(1:2) .EQ. 'SH') THEN
@


1.96
log
@LENTT removed
@
text
@d62 1
a62 1
C    'AP AL'
d68 1
a68 1
C    'AP REFF' -- NON-INCORE EVEN IF SIZE IS OK
d73 1
a73 1
C    'AP SHG'  -- GPU
d576 1
a576 2
C             FOR GPU ACCELERATED
C             USES COEF. TO SPEED UP APRINGS
a577 1
#ifdef SP_CUDA
d584 1
a584 1
     &               NSAM,NROW,NR,ISHRANGEX,ISHRANGEY,ISTEP,
a587 4
#else
	      CALL  ERRT(101,'NOT COMPILED FOR CUDA',NDUM)
              RETURN
#endif
@


1.95
log
@mrqli_psc changes & removed old 'AP MQ' etc operations
@
text
@a311 3
C        FIND SPACE NEEDED FOR TT ON SGI FFT
         LENTT = 1   ! DUMMY VALUE NO LONGER USED ANYWHERE

d552 1
a552 1
     &                NSAM,NROW,ANGDIFTHR,LENTT,RANGE,
d561 1
a561 1
     &               NSAM,NROW,LENTT,RANGE,ANGDIFTHR,
d591 2
a592 2
	   CALL  ERRT(101,'NOT COMPILED FOR CUDA',NDUM)
           RETURN
d610 1
a610 2
     &        (CTYPE(3:3) .NE. 'T'  .AND. 
     &         CTYPE(4:4) .NE. 'T') .AND.
@


1.94
log
@cuda & mrqli_psc
@
text
@d35 1
d62 1
a62 1
C    'AP MQ', 'AP NQ', 'AP RQ', 'AP NQ', AP RN', 
d64 12
a75 2
C    'AP REF'
C    'AP SH'
d120 2
a121 3
            IF (MYPID .LE. 0) WRITE(NOUT,901) 
901         FORMAT(
     &         ' OBSOLETE OPERATION, NEXT TIME PLEASE USE: <AP SH>',/)
d125 2
a126 4
            IF (MYPID .LE. 0) WRITE(NOUT,902) 
902         FORMAT(
     &         ' OBSOLETE OPERATION, NEXT TIME PLEASE USE: <AP REF>',/)

d129 2
a130 3
            IF (MYPID .LE. 0) WRITE(NOUT,903) 
903         FORMAT(
     &         ' OBSOLETE OPERATION, NEXT TIME PLEASE USE: <OR SH>',/)
a158 1

d175 1
a175 4
        IF (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &      CTYPE(1:2) .EQ. 'NQ' .OR. 
     &      CTYPE(1:2) .EQ. 'RQ' .OR.
     &      CTYPE(1:2) .EQ. 'SH' .OR.
d219 1
a219 4
	IF (CTYPE(1:2) .EQ. 'MQ' .OR.
     &      CTYPE(1:2) .EQ. 'NQ' .OR.
     &      CTYPE(1:2) .EQ. 'RQ' .OR.
     &      CTYPE(1:2) .EQ. 'OR') THEN
d223 1
a223 1
           ISKIP = 0
d269 1
a269 4
	ELSEIF (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &          CTYPE(1:2) .EQ. 'RQ' .OR.
     &          CTYPE(1:2) .EQ. 'RN' .OR. 
     &          CTYPE(1:2) .EQ. 'SH') THEN
d281 2
a282 5
        IF ((CTYPE(1:2) .EQ. 'RN' .AND. CTYPE(3:3) .NE. 'S') .OR. 
     &       CTYPE(1:2) .EQ. 'RD'  .OR. 
     &       CTYPE(1:3) .EQ. 'REF' .OR. 
     &       CTYPE(1:2) .EQ. 'SH'  .OR. 
     &       CTYPE(1:2) .EQ. 'RQ') THEN
d327 2
a328 2
     &       CTYPE(1:3) .EQ. 'SHF'  .OR. 
     &       CTYPE(1:1) .EQ. 'I' ) THEN
a354 11
               IF (CTYPE(1:2) .EQ. 'MQ' .OR. CTYPE(1:2) .EQ. 'NQ') THEN
                  IF (MYPID .LE. 0) THEN
                      WRITE(NOUT,92) LCIRC,NUMREF
                      WRITE(NOUT,*) 
     &                   ' "AP NQ & AP MQ" MUST ALLOCATE CIRCREF. '
                      WRITE(NOUT,*)
     7                   ' USE "AP SH" AND USE FEWER  REFERENCES.' 
                  ENDIF
	          GOTO 9999
	       ENDIF
 
d372 4
a375 8
         IF ((CTYPE(1:4) .EQ. 'MQ R') .OR.
     &       (CTYPE(1:2) .EQ. 'AL') .OR.
     &       (CTYPE(1:2) .NE. 'MQ'  .AND. 
     &        CTYPE(1:2) .NE. 'NQ'  .AND.
     &        CTYPE(1:2) .NE. 'SH'  .AND.
     &        CTYPE(1:2) .NE. 'OR'  .AND.
     &        CTYPE(1:2) .NE. 'RQ') .OR.
     7      (CTYPE(1:2) .EQ. 'SH' .AND. .NOT. CIRCREF_IN_CORE)) THEN
d408 1
a408 1
          CALL RDPRMC(YN,NLET,.TRUE.,'WEIGHT THE RINGS? (Y/N)',
d427 1
a427 2
399     IF (CTYPE(1:3) .EQ. 'RNS' .OR.
     &      CTYPE(1:2) .EQ. 'OR') THEN
d462 1
a462 5
        IF ((CTYPE(1:2) .EQ. 'RN' .AND. CTYPE(3:3) .NE. 'S') .OR.
     &       CTYPE(1:2) .EQ. 'RD' .OR.
     &       CTYPE(1:2) .EQ. 'RQ' .OR.
     &       CTYPE(1:2) .EQ. 'SH' .OR.
     &       CTYPE(1:3) .EQ. 'REF') THEN
d472 2
a473 5
        IF ((CTYPE(1:2) .EQ. 'RN' .AND. CTYPE(3:3) .NE. 'S') .OR.
     &       CTYPE(1:2) .EQ. 'RD'  .OR.
     &       CTYPE(1:2) .EQ. 'RQ'  .OR.
     &       CTYPE(1:3) .EQ. 'REF' .OR.
     &      (CTYPE(1:2) .EQ. 'SH' .AND. .NOT. GPU) ) THEN
d492 1
a492 1
     &       (CTYPE(1:2) .EQ. 'SH' .AND. .NOT. GPU)) THEN
d498 1
a498 5
        ELSEIF (CTYPE(1:2) .EQ. 'NQ'  .OR.
     &          CTYPE(1:3) .EQ. 'RQN' .OR.
     &          CTYPE(1:2) .EQ. 'RN'  .OR.
     &          CTYPE(1:3) .EQ. 'ORN' .OR.
     &          GPU) THEN
d544 2
a545 41
        IF (CTYPE(1:3) .EQ. 'RNS') THEN
C           ----------------------- 'RNS'------------------------ DSGRS

            IF (MYPID .LE. 0)WRITE(NOUT,*)
     &         ' Calling: DSGRS FOR: ',CTYPE(1:3),' --------------'

            CALL DSGRS(INUMBR,NUMREF,IMGLST,1,
     &                 NSAM,NROW,NR,LENTT,
     &                 NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &                 MODE,SCRFILE,FFTW_PLANS,
     &                 REFPAT,EXPPAT) 

        ELSEIF (CTYPE(1:2) .EQ. 'MD') THEN
C           ------------------------- 'MD' ----------------------- DSFS

            IF (CIRCREF_IN_CORE .AND. NUMTH.GT.1 .AND. 
     &          NUMEXP .GT. NUMTH .OR. 
     &          CTYPE(3:3) .EQ. 'T') THEN
               IF (MYPID .LE. 0) WRITE(NOUT,*) 
     &          ' Calling: DSGR_PM FOR: ',CTYPE(1:3),' ------------'

               CALL DSGR_PM(INUMBR,NUMREF,IMGLST,NUMEXP,
     &                NSAM,NROW,ANGDIFTHR,LENTT,RANGE,
     &                NRING,LCIRC,NUMR,CIRCREF,
     &                MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW_PLANS,
     &                REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,NOUTANG)

	    ELSE
               IF (MYPID .LE. 0) WRITE(NOUT,*)
     &            ' Calling: DSFS_P FOR: ',CTYPE(1:2),' -----------'

               CALL DSFS_P(INUMBR,NUMREF,IMGLST,NUMEXP,
     &              NSAM,NROW,NR,LENTT,
     &              NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &              MODE,SCRFILE,REFPAT,EXPPAT,FFTW_PLANS(1))
            ENDIF

        ELSEIF (CTYPE(1:3) .EQ. 'REF' .OR.
     &          CTYPE(1:2) .EQ. 'RN'  .OR. 
     &          CTYPE(1:2) .EQ. 'RD') THEN
C           --------------------'REF' or 'RN' or 'RD' ------------ DSGR
d570 1
a570 4
        ELSEIF (CTYPE(1:2) .EQ. 'MQ' .OR.  
     &          CTYPE(1:2) .EQ. 'NQ' .OR.
     &          CTYPE(1:2) .EQ. 'RQ' .OR.
     &          CTYPE(1:2) .EQ. 'SH' .OR.
d573 1
a573 1
C        ---- ' SH', 'MQ', 'RQ', 'NQ', 'ORS', 'ORM', & 'ORN' ---- MRQLI
a597 1

a609 1

@


1.93
log
@GPL_2010
@
text
@d34 1
a36 1
C=*                                                                    *
d38 1
a38 1
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
d50 1
a50 1
C=* merchantability or fitness for a particular purpose.  See the GNU  *
d60 5
a64 1
C
d73 3
a75 3
        INTEGER, ALLOCATABLE, DIMENSION(:)     :: IMGLST
        INTEGER, ALLOCATABLE, DIMENSION(:,:)   :: NUMR
        REAL,    ALLOCATABLE, DIMENSION(:,:)   :: CIRCREF
d84 1
a84 1
        LOGICAL                :: WINDOW,NEWFILE
d315 1
a315 1
C        CALCULATES NUMR & LCIRC 
d319 1
a319 4
         LENTT = 1
#ifdef SP_LIBFFT
         LENTT =  NUMR(3,NRING) + 15
#endif
d327 6
a332 1
         IF (CTYPE(1:4) .EQ. 'REFF' .OR. 
d389 7
a395 7
        IF ((CTYPE(1:4) .EQ. 'MQ R') .OR.
     &      (CTYPE(1:2) .EQ. 'AL') .OR.
     &      (CTYPE(1:2) .NE. 'MQ'  .AND. 
     &       CTYPE(1:2) .NE. 'NQ'  .AND.
     &       CTYPE(1:2) .NE. 'SH'  .AND.
     &       CTYPE(1:2) .NE. 'OR'  .AND.
     &       CTYPE(1:2) .NE. 'RQ') .OR.
d429 5
d442 1
a442 1
     &                  CIRCREF,NUMTH,LUNRING,IRTFLG)
d499 2
a500 2
     &       CTYPE(1:2) .EQ. 'RD' .OR.
     &       CTYPE(1:2) .EQ. 'RQ' .OR.
d502 1
a502 1
     &       CTYPE(1:2) .EQ. 'SH') THEN
d521 1
a521 1
     &       CTYPE(1:2) .EQ. 'SH' ) THEN
d527 1
a527 1
        ELSEIF (CTYPE(1:2) .EQ. 'NQ' .OR.
d529 3
a531 2
     &          CTYPE(1:2) .EQ. 'RN' .OR.
     &          CTYPE(1:3) .EQ. 'ORN' ) THEN
d650 39
a688 1
	   IF (CIRCREF_IN_CORE      .AND. 
d696 2
a697 4

#if defined ( USE_MPI) && defined (MPI_DEBUG) 
              T0 = MPI_WTIME()
#endif
d700 1
a700 1
     &               NSAM,NROW,NR,LENTT,ISHRANGEX,ISHRANGEY,ISTEP,
a704 7
#if defined ( USE_MPI) && defined (MPI_DEBUG) 
              T1 = MPI_WTIME()
              T1 = T1 - T0
              IF (MYPID .EQ. 0)  WRITE(6, 222) T1
 222          FORMAT('  AP TIME: ', 1PE11.3)
#endif

d711 2
d715 1
a715 1
     &               NSAM,NROW,NR,LENTT,ISHRANGEX,ISHRANGEY,ISTEP,
d720 7
@


1.92
log
@x & y shift allowed
@
text
@d36 4
a39 3
C=* This file is part of:                                              * 
C=* SPIDER - Modular Image Processing System.   Author: J. FRANK       *
C=* Copyright 1985-2009  Health Research Inc.                          *
d50 1
a50 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a51 1
C=*                                                                    *
d53 1
a53 1
C=* along with this program. If not, see <http://www.gnu.org/licenses> *                      *
@


1.91
log
@RANGE = MIN(RANGE,
@
text
@d33 1
d162 3
a164 2
        ISHRANGE = 0
        ISTEP    = 1
d170 3
a172 2
	   CALL RDPRIS(ISHRANGE,ISTEP,NOT_USED,
     &                'TRANSLATION SEARCH RANGE, STEP SIZE',IRTFLG)
d174 12
a185 1
	   ISHRANGE   = MAX(ISHRANGE,1)
d189 5
a193 2
	   IF (ISHRANGE .GT. NSAM/2-2)  THEN
	      CALL ERRT(102,'SEARCH MUST BE LESS THAN',NSAM/2-2)
d195 2
a196 2
	   ELSEIF (MOD(ISHRANGE,ISTEP) .NE. 0) THEN
	       CALL ERRT(101,'SEARCH RANGE MUST BE DIVISIBLE BY',ISTEP)
d198 3
d270 5
a274 2
	   IF ((ISHRANGE+NR) .GT. (NRAD-1))  THEN
	      CALL ERRT(102,'LAST RING + TRANSLATION MUST BE <',NRAD)
d652 1
a652 1
     &               NSAM,NROW,NR,LENTT,ISHRANGE,ISTEP,
d672 1
a672 1
     &               NSAM,NROW,NR,LENTT,ISHRANGE,ISTEP,
@


1.90
log
@output doc file header alignment
@
text
@d481 1
a481 1

@


1.89
log
@removed ap scc, ap sh can do incore now
@
text
@d521 5
a525 5
               COMMEN ='                  ' //
     &         'PSI,       THE,        PHI,         REF#,      '//
     &         '  EXP# ,    CUM. {INPLANE,    SX,         SY),  '//
     &         '      NPROJ,        DIFF,       CCROT    '//
     &         '   INPLANE,        SX,        SY,         MIR-CC'
@


1.88
log
@FFTW3_KILLPLANS called
@
text
@d31 2
d35 5
a39 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d41 1
a41 6
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C=*                                                                    *
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d46 1
a46 1
C=* This program is distributed in the hope that it will be useful,    *
d52 1
a52 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
d79 1
a79 1
        LOGICAL                :: WINDOW,NEWFILE,NORMIT
d91 1
a91 8
#ifdef USE_MPI
        include 'mpif.h'

        ICOMM = MPI_COMM_WORLD
        CALL MPI_COMM_RANK(ICOMM, MYPID, MPIERR)
#else
        MYPID = -1
#endif
a182 16
        ELSEIF ( CTYPE(1:3) .EQ. 'SCC' ) THEN
C          MULTI-SHIFT CROSS-CORRELATION
           NSIX = 0
           NSIY = 0
           NSIZ = 0 
           CALL RDPRI3S(NSIX,NSIY,NSIZ,NOT_USED,
     &     'TRANSLATION SEARCH RANGE IN X,Y,&Z (ZERO FOR ALL)' ,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999

           CALL RDPRMC(YN,NLET,.TRUE.,'NORMALIZE PEAK HEIGHT (Y/N)',
     &                  NULL,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
           NORMIT = (YN .EQ. 'Y')

           GOTO 399            ! SKIP NEXT INPUT

d304 1
d325 2
a326 1
            IF (IRTFLG .EQ. 0) THEN  
d332 8
a339 5
               CIRCREF_IN_CORE = .FALSE.
               IF (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &             CTYPE(1:2) .EQ. 'NQ' .OR.
     &             CTYPE(1:2) .EQ. 'SH' ) THEN
                  IF (MYPID .LE. 0) WRITE(NOUT,92) LCIRC,NUMREF
d343 1
d346 4
a349 2
     &                 I10,'  WILL USE REFERENCE-RINGS FILE INSTEAD') 

d361 1
a361 1
     &      (CTYPE(1:4) .EQ. 'AL') .OR.
d366 2
a367 1
     &       CTYPE(1:2) .NE. 'RQ')) THEN
d523 3
a525 7
     &         '  EXP# ,    CUM. {INPLANE,    SX,       SY,  '//
     &         '       NPROJ},        DIFF,     CCROT    '//
     &         '    INPLANE,        SX,       SY,         MIR-CC'
            ELSE IF (CTYPE(1:3) .EQ. 'SCC') THEN
               COMMEN = '       ' //
     &         'EXP#,         REF#,         SX,           SY,       '//
     &         'SZ,           PEAK'
a537 12

        IF (CTYPE(1:3) .EQ. 'SCC') THEN
C           ------------------------- 'CC' ---------------------- APSCC
            IF (MYPID .LE. 0) WRITE(NOUT,*) 
     &          ' Calling: APSCC FOR: ',CTYPE(1:2),' ------------'
            NORMIT = .TRUE.
            CALL APSCC(INUMBR,NUMREF ,IMGLST,NUMEXP,
     &              NSAM,NROW,NSLICE, NSIX,NSIY,NSIZ, NORMIT,
     &              REFPAT,EXPPAT,LUNREF,LUNEXP,NOUTANG)
            GOTO 9990
        ENDIF

d615 4
a618 2
	   IF (NUMEXP .GE. NUMTH .AND. 
     &        (CTYPE(3:3) .NE. 'T' .AND. CTYPE(4:4) .NE. 'T') .AND.
d638 1
a638 1
 222          FORMAT('  APMQ TIME: ', 1PE11.3)
d643 1
@


1.87
log
@mr trap
@
text
@d30 1
a61 1
C
d427 1
a427 1
           GOTO 9990
d685 3
@


1.86
log
@mpi changes
@
text
@d262 4
@


1.85
log
@ring ray support, fast quadri
@
text
@d96 2
a97 2
        icomm = MPI_COMM_WORLD
        call MPI_COMM_RANK(icomm, mypid, ierr)
d99 1
a99 1
        mypid = -1
d113 1
a113 1
            IF (mypid .LE. 0) WRITE(NOUT,901) 
d119 1
a119 1
            IF (mypid .LE. 0) WRITE(NOUT,902) 
d125 1
a125 1
            IF (mypid .LE. 0) WRITE(NOUT,903) 
d145 1
a145 1
           IF (mypid .LE. 0) WRITE(NOUT,2001) NUMREF
d330 1
a330 1
               IF (mypid .LE. 0) WRITE(NOUT,92) LCIRC,NUMTH
d335 1
a335 1
            IF (mypid .LE. 0) WRITE(NOUT,93) LCIRC,NUMTH
d347 1
a347 1
               IF (mypid .LE. 0) WRITE(NOUT,91) LCIRC,NUMREF,NTOT
d355 1
a355 1
                  IF (mypid .LE. 0) WRITE(NOUT,92) LCIRC,NUMREF
d359 1
a359 1
               IF (mypid .LE. 0) WRITE(NOUT,90) LCIRC,NUMREF,NTOT
d397 1
a397 1
               IF (mypid .LE. 0) WRITE(NOUT,*) 
d456 1
a456 1
            IF (mypid .LE. 0) WRITE(NOUT,2002) NUMEXP
d557 1
a557 1
            IF (mypid .LE. 0) WRITE(NOUT,*) 
d573 1
a573 1
            IF (mypid .LE. 0)WRITE(NOUT,*)
d588 1
a588 1
               IF (mypid .LE. 0) WRITE(NOUT,*) 
d598 1
a598 1
               IF (mypid .LE. 0) WRITE(NOUT,*)
d616 1
a616 1
               IF (mypid .LE. 0) WRITE(NOUT,*) 
d625 1
a625 1
               IF (mypid .LE. 0) WRITE(NOUT,*) 
d647 1
a647 1
              IF (mypid .LE. 0) WRITE(NOUT,*)
d670 1
a670 1
              IF (mypid .LE. 0) WRITE(NOUT,*) 
d681 1
a681 1
9990     IF (mypid .LE. 0 .AND. VERBOSE) WRITE (NOUT,2600)
a686 1
     
d688 7
a694 1
  
@


1.84
log
@ERRT(102
@
text
@d29 1
d82 1
d84 1
a86 1
        INTEGER, PARAMETER     :: NPLANS = 14
a89 1
        INTEGER, PARAMETER     :: NPLANS = 14
d188 1
a188 1
	       CALL ERRT(102,'SEARCH RANGE MUST BE DIVISIBLE BY',ISTEP)
d214 3
a216 2
        MR    = 5
        NR    = MIN(NSAM/2-1, NROW/2-1)
d225 18
a242 2
           CALL RDPRI3S(MR,NR,ISKIP,NOT_USED,
     &              'FIRST, LAST RING, & RING STEP',IRTFLG)
d250 5
d310 1
a310 1
         CALL ALPRBS_Q(NUMR,NRING,LCIRC,MODE)
@


1.83
log
@ormq & ornq --> orsh
@
text
@d187 1
a187 1
	       CALL ERRT(101,'SEARCH RANGE MUST BE DIVISIBLE BY',ISTEP)
@


1.82
log
@OBSOLETE OPERATION, NEXT TIME
@
text
@d28 1
d121 6
d475 1
d618 1
a618 1
C              ----- ' SH', 'MQ', 'RQ', 'NQ', 'ORM', & 'ORN' ---- MRQLI
d646 1
a646 1
C             TO MAKE MP EFFICIENT.
@


1.81
log
@FFTW3 plan changes, FFTW aprings
@
text
@d27 1
d107 15
d632 2
a633 4
              IF (MYPID .EQ. 0) THEN
                 WRITE(6, 222) T1
 222             FORMAT('  APMQ TIME: ', 1PE11.3)
              ENDIF 
@


1.80
log
@reverted to pre aprings change
@
text
@d25 2
a26 1
C                   'AP CC' INCORPORATED          FEB 08 ARDEAN LEITH
a57 66
C    APMASTER ----  
C    ALPRBS
C    BIGALLOC
C    APRINGS   --> INITAP_NEW ---> AP_GETDAT
C                                  NORMAS
C                                  ALRQS
C                                  FRNGS
C                                  APPLYWS
C   DSGRS    --> APRINGS
C                AP_GETDAT
C                NORMAS
C                ALRQ 
C                FRNG 
C                CROSRNG_DS
C                APPLYWS
C
C   DSGR_PM  --> APMASTER_1
C                AP_GETANG
C                APRINGS
C                AP_GETDAT
C                DSGR_2     ---> NORMAS
C                                ALRQS
C                                FRNGS
C                                CROSRNG_MS
C                                CROSRNG_DS
c
c   DSFS_P   --> APMASTER_1
C                APRINGS
C                AP_GETDAT
C                NORMAS
C                ALRQ 
C                FRNG 
C                CROSRNG_MS
C
C   DSGR_P  -->  APMASTER_1
C                AP_GETANG
C                APRINGS
C                AP_GETDAT
C                NORMAS
C                ALRQ 
C                FRNG 
C                CROSRNG_MS
C                CROSRNG_DS
C
C   MRQLI_PS --> APMASTER_1
C                AP_GETANG
C                APRINGS
C                AP_GETDAT
C                APRQ2D    ---> NORMAS
C                                ALRQ_MS
C                                FRNGS
C                                CROSRNG_MS
C                                CROSRNG_DS
c
C
C   MRQLI_SS --> APMASTER_1
C                AP_GETANG
C                APRINGS
C                AP_GETDAT
C                NORMASC
C                ALRQMS 
C                FRNGS
C                CROSRNG_MS
C                CROSRNG_DS
C                PARABLD
C                NORMAS
d81 3
a83 1
        INTEGER *8       IASK8,IOK
d85 3
a87 1
        INTEGER *4       IASK8,IOK
a194 1
     &      CTYPE(1:2) .EQ. 'SH' .OR.
d202 1
a202 1
           IF (ISKIP .LE. 0) THEN
d204 1
a204 1
              CALL RDPRI1S(ISKIP,NOT_USED,'SKIP',IRTFLG)
d247 1
a247 1
            NRING = NRING+1
d256 1
a256 1
C        INITIALIZE NUMR ARRAY WITH RING COORDINATES
d263 2
a264 2
C        CALCULATES NUMR & LCIRC
         CALL ALPRBS(NUMR,NRING,LCIRC,MODE)
d366 5
a370 1
           CALL APRINGS_FILL(INUMBR,NUMREF,
d372 1
a372 1
     &                  NRING,LCIRC,NUMR,MODE, 
d504 1
d507 16
d524 1
a524 1
C           ----------------------- 'RNS'----------------------- DSGRS
d532 1
a532 1
     &                 MODE,SCRFILE,
d537 1
d539 2
a540 1
     &          NUMEXP .GT. NUMTH .OR. CTYPE(3:3) .EQ. 'T') THEN
d547 1
a547 1
     &                MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d557 1
a557 1
     &              MODE,SCRFILE,REFPAT,EXPPAT)
a559 9
        ELSEIF (CTYPE(1:3) .EQ. 'SCC') THEN
C           ------------------------- 'CC' ---------------------- APSCC
            IF (mypid .LE. 0) WRITE(NOUT,*) 
     &          ' Calling: APSCC FOR: ',CTYPE(1:2),' ------------'
            NORMIT = .TRUE.
            CALL APSCC(INUMBR,NUMREF ,IMGLST,NUMEXP,
     &              NSAM,NROW,NSLICE, NSIX,NSIY,NSIZ, NORMIT,
     &              REFPAT,EXPPAT,LUNREF,LUNEXP,NOUTANG)

d567 1
a567 2
     &           CTYPE(3:3) .EQ. 'T' .OR.
     &           CTYPE(4:4) .EQ. 'T') THEN
d575 1
a575 1
     &                MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d584 1
a584 1
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d603 1
a603 2
#ifdef USE_MPI
#ifdef MPI_DEBUG
d606 1
a606 1
#endif
d610 1
a610 1
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,
d612 2
a613 2
#ifdef USE_MPI
#ifdef MPI_DEBUG
d621 1
a621 1
#endif
d623 3
a625 3
C             USE DIFFERENT STRATEGY FOR SMALL NUMBER OF IMAGES TO 
C             BE ALIGNED  TO MAKE MP EFFICIENT.
              IF (mypid .LE. 0)WRITE(NOUT,*) 
d631 1
a631 1
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE, 
@


1.79
log
@ crosrng calls
@
text
@d146 1
a146 1
        INTEGER *8       IASK8,IOK,FFTW3PLAN
d148 1
a148 1
        INTEGER *4       IASK8,IOK,FFTW3PLAN
d256 1
d264 1
a264 1
           IF ( CTYPE(1:2) .NE. 'SH' .AND. ISKIP .LE. 0) THEN
d266 1
a266 1
              CALL RDPRI1S(ISKIP,NOT_USED,'RING STEP',IRTFLG)
a592 3
C              INITIALIZE REV. FFTW3 PLAN FOR USE WITHIN OMP ||
               CALL FMRS_PLAN(NUMR(3,NRING),1,1, 1, -1,FFTW3PLAN,IRTFLG)

a629 3
C              INITIALIZE REV. FFTW3 PLAN FOR USE WITHIN OMP ||
               CALL FMRS_PLAN(NUMR(3,NRING),1,1, 1, -1,FFTW3PLAN,IRTFLG)

d633 1
a633 1
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN,
a644 3
C          INITIALIZE REV. FFTW3 PLAN FOR USE WITHIN OMP ||
           CALL FMRS_PLAN(NUMR(3,NRING),1,1, 1, -1,FFTW3PLAN,IRTFLG)

d660 1
a660 1
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN,
d681 1
a681 1
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,FFTW3PLAN, 
@


1.78
log
@added 'AP SCC'
@
text
@d146 1
a146 1
        INTEGER *8       IASK8,IOK
d148 1
a148 1
        INTEGER *4       IASK8,IOK
a255 1
     &      CTYPE(1:2) .EQ. 'SH' .OR.
d263 1
a263 1
           IF (ISKIP .LE. 0) THEN
d265 1
a265 1
              CALL RDPRI1S(ISKIP,NOT_USED,'SKIP',IRTFLG)
d592 3
d632 3
d638 1
a638 1
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,
d650 3
d668 1
a668 1
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE,
d689 1
a689 1
     &               MODE, REFANGDOC,EXPANGDOC,SCRFILE, 
@


1.77
log
@'AP RQN' MIRRORED BUG
@
text
@d25 2
d29 1
a29 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d132 1
a132 1
        INTEGER, ALLOCATABLE, DIMENSION(:)     :: ILIP
d139 2
a140 2
	CHARACTER(LEN=1)       :: MODE,NULL,ANS
	CHARACTER(LEN=180)     :: COMMEN
d143 1
a143 1
        LOGICAL                :: WINDOW,NEWFILE
d228 17
d248 1
d252 1
a252 1
        NR    = MIN0(NSAM/2-1, NROW/2-1)
d263 1
a263 1
     &              'FIRST, LAST RING, & RING SKIP',IRTFLG)
d270 3
a272 1
        ISKIP = MAX0(1,ISKIP)
a273 1
        NRAD = MIN0(NSAM/2-1, NROW/2-1)
d282 4
a285 2
	ELSEIF (CTYPE(1:2) .EQ. 'MQ' .OR. CTYPE(1:2) .EQ. 'RQ' .OR.
     &          CTYPE(1:2) .EQ. 'RN' .OR. CTYPE(1:2) .EQ. 'SH') THEN
d294 1
a294 1
        IF ((CTYPE(1:2) .EQ. 'RN' .AND.CTYPE(3:3) .NE. 'S') .OR. 
d318 1
d328 1
a328 1
C        FIND SPACE NEEDED FOR TT 
d390 5
a394 4
     &      (CTYPE(1:2) .NE. 'MQ' .AND. 
     &       CTYPE(1:2) .NE. 'NQ' .AND.
     &       CTYPE(1:2) .NE. 'SH' .AND.
     &       CTYPE(1:2) .NE. 'OR' .AND.
d421 1
a421 1
C           ----------------- 'I' --------------------- APRINGS_FILL
d424 1
a424 1
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'U',IFORM,
d438 1
a438 1
        IF (CTYPE(1:3) .EQ. 'RNS' .OR.
d447 1
a447 1
	    ALLOCATE(ILIP(1),STAT=IRTFLG)
d449 1
a449 1
                CALL ERRT(46,'ILIP',1)
d453 2
a454 2
            ILIP(1) = 0
            NIDI    = 1
d457 1
a457 1
	    ALLOCATE(ILIP(NILMAX),STAT=IRTFLG)
d459 1
a459 1
               CALL ERRT(46,'ILIP',NILMAX)
d463 2
a464 1
	    CALL FILELIST(.TRUE.,LUNEXP,EXPPAT,NLEP,ILIP,NILMAX,NIDI,
d468 1
a468 1
            IF (mypid .LE. 0) WRITE(NOUT,2002) NIDI
d545 8
a552 4
     &              'PSI,       THE,        PHI,         REF#,      '//
     &              '  EXP# ,    CUM. {INPLANE,    SX,       SY,  '//
     &              '       NPROJ},        DIFF,     CCROT    '//
     &              '    INPLANE,      SX,      SY,        MIR-CC'
d565 1
a565 1
C           ----------------------- 'RNS'---------------------- DSGRS
d570 1
a570 1
            CALL DSGRS(INUMBR,NUMREF,ILIP,1,
d577 1
a577 1
C           ------------------------- 'MD' ---------------------- DSFS
d579 1
a579 1
     &          NIDI .GT. NUMTH .OR. CTYPE(3:3) .EQ. 'T') THEN
d583 1
a583 1
               CALL DSGR_PM(INUMBR,NUMREF,ILIP,NIDI,
d593 1
a593 1
               CALL DSFS_P(INUMBR,NUMREF,ILIP,NIDI,
d599 13
a611 3

        ELSEIF (CTYPE(1:3) .EQ. 'REF') THEN
C           -----------------------'REF' ------------------------- DSGR
d614 2
a615 1
     &           NUMTH.GT.1 .AND.NIDI.GT.NUMTH ) .OR. 
d621 1
a621 26
               CALL DSGR_PM(INUMBR,NUMREF,ILIP,NIDI,
     &                NSAM,NROW,ANGDIFTHR,LENTT,RANGE,
     &                NRING,LCIRC,NUMR,CIRCREF,
     &                MODE,REFANGDOC,EXPANGDOC,SCRFILE,
     &                REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,NOUTANG)
            ELSE 
               IF (mypid .LE. 0) WRITE(NOUT,*) 
     &            ' Calling: DSGR_P FOR: ',CTYPE(1:3),' -----------'

               CALL DSGR_P(INUMBR,NUMREF,ILIP,NIDI,
     &               NSAM,NROW,LENTT,RANGE,ANGDIFTHR,
     &               NRING,LCIRC,NUMR,CIRCREF,CIRCREF_IN_CORE,
     &               MODE,REFANGDOC,EXPANGDOC,SCRFILE,
     &               REFPAT,EXPPAT,CKMIRROR,CTYPE,ISHRANGE,NOUTANG)
           ENDIF 

        ELSEIF (CTYPE(1:2) .EQ. 'RN' .OR. CTYPE(1:2) .EQ. 'RD') THEN
C           -----------------------'RN' or 'RD' ------------------ DSGR
 
            IF (CIRCREF_IN_CORE .AND. NUMTH.GT.1 .AND. 
     &          NIDI.GT.NUMTH .OR. CTYPE(3:3) .EQ. 'T') THEN

               IF (mypid .LE. 0) WRITE(NOUT,*) 
     &           ' Calling: DSGR_PM FOR: ',CTYPE(1:3),' -----------'

               CALL DSGR_PM(INUMBR,NUMREF,ILIP,NIDI,
d630 1
a630 1
               CALL DSGR_P(INUMBR,NUMREF,ILIP,NIDI,
a636 1

d641 1
d643 1
a643 1
C              -------- 'MQ', 'RQ', 'NQ', 'ORM', & 'ORN' -------- MRQLI
d645 1
a645 1
	   IF (NIDI .GE. NUMTH .AND. 
d657 1
a657 1
              CALL MRQLI_PS(INUMBR,NUMREF,ILIP,NIDI, 
d678 1
a678 1
              CALL MRQLI_SS(INUMBR,NUMREF,ILIP,NIDI, 
d689 1
a689 1
9999     IF (ALLOCATED(ILIP))    DEALLOCATE(ILIP)
@


1.76
log
@GPL License fixed
@
text
@d4 1
a4 2
C APMASTER.F        'AP RN'
C                   CAN OUTPUT TO REGISTERS NOW   MAY 01 ARDEAN LEITH
d24 1
d491 1
@


1.75
log
@'OR' HAD OUTPUT FILE BUG
@
text
@d2 1
a2 1
C++************************************************************************
d26 23
a48 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2005. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.74
log
@for use with aprieng_fill
@
text
@d24 1
d27 1
a27 1
C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
d479 2
a480 2
C        GET NAME FOR OUTPUT DOC FILE
         CALL REG_GET_USED(NSEL_USED)
d482 5
d512 1
@


1.73
log
@ RDPRM2S(RANGE,ANGDIFTHR,NOT_USED
@
text
@d301 1
a301 1
        numth = 8
d310 1
a310 1
93          FORMAT ('  DISK BASE RINGS FILE, ALLOCATED: CIRCREF(',I8,
d378 13
a390 8
C           ----------------- 'I' --------------------- APRINGS_WRITE
C          CREATE REFERENCE-RINGS FILE AND QUIT
           WINDOW = (CTYPE(1:1) .EQ. 'I') 
           CALL APRINGS_WRITE(INUMBR,NUMREF, 
     &                       NSAM,NROW,NUMTH,
     &                       NRING,LCIRC,NUMR,MODE, 
     &                       REFPAT,LUNREF,CIRCREF,NUMTH,
     &                       LUNRING,SCRFILE,WINDOW,IRTFLG)
d480 4
a483 5
         NOUTANG = 0
         IF (NSEL_USED .LE. 0) THEN
C           OPEN OUTPUT DOC FILE (FOR APPENDING)
            NOUTANG = NDOC
            CALL OPENDOC(OUTANG,.TRUE.,NLET,NDOC,NOUTANG,.TRUE.,
d486 7
a492 2
            IF (IRTFLG .NE. 0) RETURN

d494 1
a494 1
            COMMEN ='                  ' //
d529 1
a529 1
     &                NSAM,NROW,NR,LENTT,RANGE,
d531 1
a531 1
     &                MODE,REFANGDOC,EXPANGDOC,
d556 1
a556 1
     &                NSAM,NROW,NR,LENTT,RANGE,
d558 1
a558 1
     &                MODE,REFANGDOC,EXPANGDOC,
d581 1
a581 1
     &                NSAM,NROW,NR,LENTT,RANGE,
d583 1
a583 1
     &                MODE,REFANGDOC,EXPANGDOC,
@


1.72
log
@ang diff threshold input
@
text
@d301 1
d309 3
a311 3

            IF (mypid .LE. 0)  WRITE(NOUT,901) 
901         FORMAT('  USING DISK_BASED REFERENCE-RINGS FILE')
d445 1
a445 1
           CALL RDPRM2S(RANGE,ANGDIFTHR,
d448 2
@


1.71
log
@BFC_IN_CORE is now: CIRCREF_IN_CORE etc
@
text
@d23 1
d119 1
a119 1
	CHARACTER(LEN=1)       :: MODE,NULL,ANS,LF
a132 1
        integer comm
d134 2
a135 2
        comm = MPI_COMM_WORLD
        call MPI_COMM_RANK(comm, mypid, ierr)
d141 1
a141 1
	DATA  INPIC,INANG,NDOC,NSCF/77,78,55,50/
a143 1
        LF     = CHAR(12)
d214 1
a214 1
        NR    = MIN(NSAM,NROW)
d436 2
a437 1
        RANGE    = 0.0
d444 3
a446 1
           CALL RDPRM(RANGE,NOT_USED,'RANGE OF PROJECTION ANGLE SEARCH')
d553 1
a553 1
     &               NSAM,NROW,NR,LENTT,RANGE,
d578 1
a578 1
     &               NSAM,NROW,NR,LENTT,RANGE,
d615 1
a615 1
 222             FORMAT(1X, 'APMQ TIME: ', 1PE11.3)
@


1.70
log
@bfc alloc bug
@
text
@a102 2
C
C
d113 1
a113 1
        REAL,    ALLOCATABLE, DIMENSION(:,:)   :: BFC
d121 1
a121 1
        LOGICAL                :: BFC_IN_CORE,CKMIRROR
d302 1
a302 1
            ALLOCATE(BFC(LCIRC,NUMTH),STAT=IRTFLG)
d305 2
a306 2
92             FORMAT ('  CAN NOT ALLOCATE: BFC(',I8,' X ',I8,')') 
	       CALL  ERRT(46,'BFC',LCIRC*NUMTH)
d313 1
a313 1
            BFC_IN_CORE = .FALSE.
d316 1
a316 1
            ALLOCATE(BFC(LCIRC,NUMREF),STAT=IRTFLG)
d320 1
a320 1
               BFC_IN_CORE = .TRUE.
d322 1
a322 1
91             FORMAT('  ALLOCATED: BFC(',I8,' X ',I8,'): ',I10) 
d325 1
a325 1
               BFC_IN_CORE = .FALSE.
d334 2
a335 2
90             FORMAT('  CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'): ',I10,
     &                '  WILL USE REFERENCE-RINGS FILE INSTEAD') 
d338 2
a339 2
               IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	       ALLOCATE(BFC(LCIRC,NUMTH),STAT=IRTFLG)
d341 1
a341 1
	          CALL  ERRT(46,'BFC',LCIRC*NUMTH)
d364 1
a364 1
     &              .NOT. BFC_IN_CORE) THEN
d382 1
a382 1
     &                       NSAM,NROW,NR,
d384 1
a384 1
     &                       REFPAT,LUNREF,BFC,NUMTH,
d503 1
a503 1
     &                 NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
d509 1
a509 1
            IF (BFC_IN_CORE .AND. NUMTH.GT.1 .AND. 
d516 1
a516 1
     &                NRING,LCIRC,NUMR,BFC,
d526 1
a526 1
     &              NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
d534 2
a535 1
            IF ((BFC_IN_CORE .AND. NUMTH.GT.1 .AND.NIDI.GT.NUMTH ) .OR. 
d543 1
a543 1
     &                NRING,LCIRC,NUMR,BFC,
d552 1
a552 1
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
d560 1
a560 1
            IF (BFC_IN_CORE .AND. NUMTH.GT.1 .AND. 
d568 1
a568 1
     &                NRING,LCIRC,NUMR,BFC,
d577 1
a577 1
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
d604 1
a604 1
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
d625 1
a625 1
     &               NRING,LCIRC,NUMR,BFC,BFC_IN_CORE,
d634 3
a636 3
9999     IF (ALLOCATED(ILIP)) DEALLOCATE(ILIP)
	 IF (ALLOCATED(NUMR)) DEALLOCATE(NUMR)
         IF (ALLOCATED(BFC))  DEALLOCATE(BFC)
@


1.69
log
@BFC_IN_CORE = .FALSE.
@
text
@d311 1
d314 1
d325 1
d338 8
a346 8

C           GWP - HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
            IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	    ALLOCATE(BFC(LCIRC,NUMTH),STAT=IRTFLG)
	    IF (IRTFLG .NE. 0) THEN
	       CALL  ERRT(46,'BFC',LCIRC*NUMTH)
	       GOTO 9999
	    ENDIF
@


1.68
log
@can force non-incore ref. rings with REFF
@
text
@d22 1
d301 6
a306 19
         NUMREFT = NUMREF
         IF (CTYPE(1:1) .EQ. 'I') NUMREFT = NUMTH 
         IF (CTYPE(1:4) .EQ. 'REFF') THEN
C           FORCE IT TO INITIATE NON-INCORE EVEN IF SIZE IS OK
            IRTFLG = 1  
         ELSE 
            ALLOCATE(BFC(LCIRC,NUMREFT),STAT=IRTFLG)
         ENDIF

         IF (IRTFLG .EQ. 0) THEN  
            BFC_IN_CORE = .TRUE.
            IF (mypid .LE. 0) WRITE(NOUT,91) LCIRC,NUMREFT
91          FORMAT ('  ALLOCATED: BFC(',I8,' X ',I8,')') 
	 ELSE
            BFC_IN_CORE = .FALSE.
            IF (CTYPE(1:2) .EQ. 'MQ' .OR. 
     &          CTYPE(1:2) .EQ. 'NQ' .OR.
     &          CTYPE(1:2) .EQ. 'SH' ) THEN
               IF (mypid .LE. 0) WRITE(NOUT,92) LCIRC,NUMREFT
d308 1
d310 21
a330 1
	    ENDIF
d332 4
a335 3
            IF (mypid .LE. 0) WRITE(NOUT,90) LCIRC,NUMREFT
90          FORMAT ('  CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &              '  WILL USE REFERENCE-RINGS FILE INSTEAD') 
d337 1
a337 1
C           GWP - I HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
d339 1
a339 1
	    ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
d341 1
a341 1
	       CALL  ERRT(46,'BFC',LCIRC)
@


1.67
log
@APRINGS_WRITE no close CLOSE(LUNRING)
@
text
@d301 8
a308 2
         IF (CTYPE(1:1) .EQ. 'I') NUMREFT = NUMTH  
	 ALLOCATE(BFC(LCIRC,NUMREFT),STAT=IRTFLG) 
d470 1
a470 1
     &              'PSI,       THE,        PHI,     MIR-REF#,      '//
d473 1
a473 1
     &              '    INPLANE,      SX,      SY,        MIR'
@


1.66
log
@noutang defaults to zero (no output)
@
text
@d361 1
a361 1
C           ----------------- 'I' --------------------------- APRINGS
d369 1
@


1.65
log
@EXPERIMENTAL IMAGES ALIGNMENT DOCUMENT prompt
@
text
@d452 1
@


1.64
log
@PSI,THE,PHI labels
@
text
@d415 1
a415 1
     &                 'EXPERIMENTAL IMAGES ALIGN. DOCUMENT',IRTFLG)
d427 7
@


1.63
log
@or ref file bad msg removed.
@
text
@d21 1
d455 1
a455 1
     &              'PHI,       THE,        PSI,     MIR-REF#,      '//
@


1.62
log
@ouput file formatting
@
text
@d20 1
d174 8
a181 2
        NLET = 0
        CALL  FILGET(REFPAT,FILNAM,NLET,INUMBR(1),INTFLG)
@


1.61
log
@appends to output doc file now
@
text
@d447 4
a450 4
     &              '<,           <,          <,     MIR-REF#,      '//
     &              '  EXP# ,    CUM. {INPLANE<,   SX,       SY,  '//
     &              '       NPROJ},      < DIFF,     CCROT    '//
     &              '    INPLANE<,     SX,      SY,        MIR'
d596 1
a596 1
9990     IF (mypid .LE. 0) WRITE (NOUT,2600)
@


1.60
log
@doc file headers changed
@
text
@d438 1
a438 1
C           OPEN OUTPUT DOC FILE
d441 1
a441 1
     &           'OUTPUT ALIGNMENT DOCUMENT',.FALSE.,.FALSE.,.TRUE.,
@


1.59
log
@~9
@
text
@d19 1
d447 1
a447 1
     &              '<,           <,          <,         REF#,      '//
@


1.58
log
@doc file header
@
text
@d328 2
a329 3
C           IRTFLG = 9 IS TO ACCEPT EXTENSION IF FILE IS NAMED
            IRTFLG = 9
            CALL FILERD(ASK,NA,NULL,'REFERENCE-RINGS',IRTFLG)
@


1.57
log
@AP SH, AP REF major changes
@
text
@d448 2
a449 2
     &              '  CCROT,    CUM. {INPLANE<,   SX,       SY,  '//
     &              '        MIR},      < DIFF,      '//
@


1.56
log
@'OR' input order changed
@
text
@d17 2
a18 1
C                   'OR' INPUT ORDER              DEC 03 ARDEAN LEITH
d101 2
a102 1
C--************************************************************************
d113 2
a114 2
        CHARACTER (LEN=MAXNAM) :: ASK,SCRFILE,FILNAM,REFANG
        CHARACTER (LEN=MAXNAM) :: REFPAT,EXPPAT,EXPANG,OUTANG
d116 2
a117 1
	CHARACTER(LEN=1)       :: MODE,NULL
d119 2
a120 2
        LOGICAL                :: BFC_IN_CORE,MIRROR
        LOGICAL                :: WINDOW
d130 2
a131 2
        integer mypid, comm, ierr
C
d142 2
d146 3
a148 19
        IF ( CTYPE(1:2) .EQ. 'OR') THEN
C           GET NAME OF SINGLE IMAGE TO BE ALIGNED
            MAXIM = 0
            CALL OPFILEC(0,.TRUE.,EXPPAT,LUNEXP,'O',IFORM,
     &                  NSAM,NROW,NSLICE,MAXIM,'EXPERIMENTAL IMAGE',
     &                  .FALSE.,IRTFLG)
	    IF (IRTFLG .NE. 0) GOTO 9999

	    ALLOCATE(ILIP(1),STAT=IRTFLG)
	    IF (IRTFLG .NE. 0) THEN
                CALL ERRT(46,'ILIP',1)
                GOTO 9999
            ENDIF

            ILIP(1) = 0
            NIDI    = 1

            MAXIM = 0
            CALL OPFILEC(0,.TRUE.,REFPAT,LUNREF,'O',ITYPE,NSAM,NROW,
d150 1
a150 4
            IF (IRTFLG .NE. 0) RETURN

            NUMREF    = 1
            INUMBR(1) = 0
d152 2
d163 1
d165 5
a169 5
C          NUMREF - TOTAL NUMBER OF REF. IMAGES
           IF (NUMREF .LE. 0)  THEN
              CALL ERRT(101,'No reference images',IDUM)
              GOTO 9999
           ENDIF
d171 8
a178 9
C          GET FIRST REFERENCE IMAGE TO DETERMINE DIMENSIONS
           NLET = 0
           CALL  FILGET(REFPAT,FILNAM,NLET,INUMBR(1),INTFLG)
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FILNAM,LUNREF,'O',IFORM,
     &              NSAM,NROW,NSLICE, MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  GOTO 9999
           CLOSE(LUNREF)
        ENDIF
d180 2
d185 1
d187 1
a187 1
	   CALL RDPRIS(NSI,ISTEP,NOT_USED,
d190 2
a191 2
	   NSI   = MAX0(NSI,1)
	   ISTEP = MAX0(ISTEP,1)
d194 1
a194 1
	   IF (NSI .GT. NSAM/2-2)  THEN
d197 1
a197 1
	   ELSEIF (MOD(NSI,ISTEP) .NE. 0) THEN
d201 3
a203 3
        ELSE
           ISTEP = 1
           NSI   = 0
d211 1
d232 2
a233 2
	ELSEIF (NR .GE. NRAD) THEN
	   CALL ERRT(31,'LAST RING MUST BE < ',NRAD)
d236 2
a237 1
	ELSE
d239 1
a239 1
	   IF (NSI+NR .GT. NRAD-1)  THEN
d245 1
a245 1

d247 4
a250 2
     &      CTYPE(1:2) .EQ. 'RD' .OR. 
     &      CTYPE(1:2) .EQ. 'RQ') THEN
d252 1
a252 1
           CALL FILERD(REFANG,NREFA,NULL,
d255 2
a256 4
        ELSE
           REFANG = CHAR(0)
        ENDIF

d300 3
a302 1
            IF (CTYPE(1:2) .EQ. 'MQ' .OR. CTYPE(1:2) .EQ. 'NQ') THEN
d324 1
d364 2
a365 2

        IF (CTYPE(1:3) .EQ. 'RNS') THEN
d381 1
a381 3

        ELSEIF ( CTYPE(1:2) .NE. 'OR') THEN

d398 15
a412 1
        IF ((CTYPE(1:2) .EQ. 'RN' .AND.CTYPE(3:3) .NE. 'S') .OR.
d414 12
a425 4
     &       CTYPE(1:2) .EQ. 'RQ') THEN
C          GET NAME OF DOC FILE  FOR EXPERIMENTAL IMAGES ANGLES
           CALL FILERD(EXPANG,NEXPA,NULL,
     &                 'EXPERIMENTAL IMAGES ANGLES DOCUMENT',IRTFLG)
d427 1
d429 5
a433 5
           CALL RDPRM(RANGE,NOT_USED,'RANGE OF ANGULAR SEARCH')
         ELSE
           EXPANG = CHAR(0)
           RANGE  = 0.0
         ENDIF
d437 1
a437 1
         IF (NSEL_USED .LE. 0 .AND. REFANG .NE. '*') THEN
d439 18
a456 5
            CALL  FILERD(OUTANG,NOUTANG,NULL,
     &                  'OUTPUT ANGLES DOCUMENT',IRTFLG)
             NRUN = 0
             CALL SAVDN1(NDOC,OUTANG,ADUM,0,NRUN,1)
	    IF (IRTFLG .NE. 0) GOTO 9999
a476 1
               MIRROR = .TRUE.
d478 1
a478 1
     &           ' Calling: DSGR_PM FOR: ',CTYPE(1:3),' --------------'
d483 2
a484 2
     &                MODE,REFANG,EXPANG,
     &                REFPAT,EXPPAT,MIRROR,CTYPE)
d488 1
a488 1
     &            ' Calling: DSFS_P FOR: ',CTYPE(1:2),' --------------'
d493 1
a493 2
     &              MODE,
     &              SCRFILE,REFPAT,EXPPAT)
d497 25
a524 2
            MIRROR = (CTYPE(1:2) .EQ. 'RD')

d529 1
a529 1
     &           ' Calling: DSGR_PM FOR: ',CTYPE(1:3),' --------------'
d534 2
a535 2
     &                MODE,REFANG,EXPANG,
     &                REFPAT,EXPPAT,MIRROR,CTYPE)
d538 1
a538 1
     &            ' Calling: DSGR_P FOR: ',CTYPE(1:3),' --------------'
d543 2
a544 2
     &               MODE,REFANG,EXPANG,SCRFILE,
     &               REFPAT,EXPPAT,MIRROR,CTYPE)
d547 1
d551 1
d553 1
a553 1
C              -------- 'MQ', 'RQ', 'NQ', 'ORM', & 'ORN' --------- MRQLI
d560 1
a560 1
     &           ' Calling: MRQLI_PS FOR: ',CTYPE(1:3),' --------------'
d562 5
d568 1
a568 1
     &               NSAM,NROW,NR,LENTT,NSI,ISTEP,
d570 12
a581 2
     &               MODE, REFANG,EXPANG,SCRFILE,
     &               REFPAT,EXPPAT,RANGE,CTYPE)
d585 2
a586 2
              IF (mypid .LE. 0) WRITE(NOUT,*) 
     &           ' Calling: MRQLI_SS FOR: ',CTYPE(1:3),' --------------'
d589 1
a589 1
     &               NSAM,NROW,NR,LENTT,NSI,ISTEP,
d591 2
a592 2
     &               MODE, REFANG,EXPANG,SCRFILE, 
     &               REFPAT,EXPPAT,RANGE,CTYPE)
a595 2


d602 3
a604 6
       
#ifdef SP_MP
C        RESET NUMTH TO PREVIOUS VALUE
         WRITE(NOUT,*) '  SETTING OMP THREADS: ',NUMTH
         CALL SETTHREADS(NUMTH)
#endif
@


1.55
log
@header output shortened -------------
@
text
@d17 1
d141 19
a159 3
        IF (CTYPE(1:2) .EQ. 'OR') THEN
           MAXIM = 0
           CALL OPFILEC(0,.TRUE.,REFPAT,LUNREF,'O',ITYPE,NSAM,NROW,
d161 1
a161 1
           IF (IRTFLG .NE. 0) RETURN
d163 3
a165 2
           NUMREF    = 1
           INUMBR(1) = 0
d175 6
a180 1
        ENDIF
d182 8
a189 4
C       NUMREF - TOTAL NUMBER OF REF. IMAGES
        IF (NUMREF .LE. 0)  THEN
           CALL ERRT(101,'No reference images',IDUM)
           GOTO 9999
a191 9
C       GET FIRST REFERENCE IMAGE TO DETERMINE DIMENSIONS
        NLET = 0
        CALL  FILGET(REFPAT,FILNAM,NLET,INUMBR(1),INTFLG)
        MAXIM = 0
        CALL OPFILEC(0,.FALSE.,FILNAM,LUNREF,'O',IFORM,NSAM,NROW,NSLICE,
     &               MAXIM,' ',.FALSE.,IRTFLG)
        IF (IRTFLG .NE. 0)  GOTO 9999
        CLOSE(LUNREF)

d368 2
a369 2
        IF (CTYPE(1:3) .EQ. 'RNS' .OR.
     &      CTYPE(1:2) .EQ. 'OR') THEN
d385 3
a387 1
        ELSE
d517 1
a517 1
              IF (mypid .LE. 0)WRITE(NOUT,*) 
@


1.54
log
@ ---- msg shortened
@
text
@d16 1
a410 3
         WRITE (NOUT,95)
95       FORMAT (' ',52('-'))

d414 2
a415 2
            IF (mypid .LE. 0)
     &         WRITE(NOUT,*)' Calling: DSGRS FOR: ',CTYPE(1:3)
d429 1
a429 2
     &             ' Calling: DSGR_PM FOR: ',CTYPE(1:3)
               WRITE (NOUT,95)
d439 1
a439 2
     &                   ' CALLING DSFS_P FOR: ',CTYPE(1:2)
               WRITE (NOUT,95)
d456 1
d458 1
a458 2
     &                ' Calling: DSGR_PM FOR: ',CTYPE(1:3)
               WRITE (NOUT,95)
d467 1
a467 2
     &                 ' Calling: DSGR_P FOR: ',CTYPE(1:3)
               WRITE (NOUT,95)
d486 2
a487 2
              IF (mypid .LE. 0) 
     &               WRITE(NOUT,*)' Calling: MRQLI_PS FOR: ',CTYPE(1:3)
d497 2
a498 2
              IF (mypid .LE. 0) 
     &              WRITE(NOUT,*) ' Calling: MRQLI_SS FOR: ',CTYPE(1:3)
@


1.53
log
@append on  savdn1 bug
@
text
@d416 2
a417 1
            IF (mypid .LE. 0)WRITE(NOUT,*)' Calling: DSGRS FOR: ',CTYPE
d431 1
a431 1
     &             ' Calling: DSGR_PM FOR: ',CTYPE
d442 1
a442 1
     &                   ' CALLING DSFS_P FOR: ',CTYPE
d461 1
a461 1
     &                ' Calling: DSGR_PM FOR: ',CTYPE
d471 1
a471 1
     &                 ' Calling: DSGR_P FOR: ',CTYPE
d492 1
a492 1
     &               WRITE(NOUT,*) ' Calling: MRQLI_PS FOR: ',CTYPE
d503 1
a503 1
     &              WRITE(NOUT,*) ' Calling: MRQLI_SS FOR: ',CTYPE
d516 1
a516 3
2600     FORMAT (/ ' ',52('-')/,
     &             ' ','END OF COMPUTATION',/,
     &             ' ',52('-')/)
@


1.52
log
@mpi
@
text
@d404 1
a404 1
             CALL SAVDN1(NDOC,OUTANG,ADUM,0,NRUN,0)
@


1.51
log
@or bug
@
text
@d123 10
d154 1
a154 1
           WRITE(NOUT,2001) NUMREF
d284 1
a284 1
            WRITE(NOUT,91) LCIRC,NUMREFT
d289 1
a289 1
               WRITE(NOUT,92) LCIRC,NUMREFT
d294 1
a294 1
            WRITE(NOUT,90) LCIRC,NUMREFT
d330 1
a330 1
               WRITE(NOUT,*) 
d378 1
a378 1
            WRITE(NOUT,2002) NIDI
d416 1
a416 2
            WRITE(NOUT,*) ' Calling: DSGRS FOR: ',CTYPE
            WRITE (NOUT,95)
d429 2
a430 1
               WRITE(NOUT,*) ' Calling: DSGR_PM FOR: ',CTYPE
d440 2
a441 1
               WRITE(NOUT,*) ' CALLING DSFS_P FOR: ',CTYPE
d459 2
a460 1
               WRITE(NOUT,*) ' Calling: DSGR_PM FOR: ',CTYPE
d469 2
a470 1
               WRITE(NOUT,*) ' Calling: DSGR_P FOR: ',CTYPE
d490 2
a491 2
              WRITE(NOUT,*) ' Calling: MRQLI_PS FOR: ',CTYPE
              WRITE (NOUT,95)
d501 2
a502 2
              WRITE(NOUT,*) ' Calling: MRQLI_SS FOR: ',CTYPE
              WRITE (NOUT,95)
d514 1
a514 1
9990     WRITE (NOUT,2600)
@


1.50
log
@'OR MQ' support
@
text
@d143 3
a153 3
        WRITE(NOUT,2001) NUMREF
2001    FORMAT('  Number of reference images: ',I7)

d347 7
@


1.49
log
@comments
@
text
@d15 1
d129 5
a133 4
C       ASK FOR TEMPLATE AND NUMBERS FOR REFERENCE IMAGES
	CALL FILELIST(.TRUE.,LUNREF,REFPAT,NLET,INUMBR,NILMAX,NUMREF,
     &     'ENTER TEMPLATE FOR REFERENCE IMAGES',IRTFLG)
	IF (IRTFLG .NE. 0) GOTO 9999
d135 10
d165 2
a166 1
     &      CTYPE(1:2) .EQ. 'RQ') THEN
d182 2
a183 1
           NSI = 0
d190 2
a191 1
     &      CTYPE(1:2) .EQ. 'RQ') THEN
d300 1
d339 2
a340 1
        IF (CTYPE(1:3) .EQ. 'RNS') THEN
d343 1
a343 1
            CALL OPFILEC(0,.TRUE.,FILNAM,LUNEXP,'O',IFORM,
d347 2
d367 2
a368 2
     &      CTYPE(1:2) .EQ. 'RD' .OR.
     &      CTYPE(1:2) .EQ. 'RQ') THEN
d402 1
a402 1
            CALL DSGRS(INUMBR,NUMREF,
d406 1
a406 1
     &                 REFPAT,FILNAM) 
d462 3
a464 2
     &          CTYPE(1:2) .EQ. 'RQ') THEN
C              -------------- 'MQ', 'RQ' or 'NQ' ---------------- MRQLI
d467 2
a468 1
     &        (CTYPE(3:3) .NE. 'T' .AND. CTYPE(4:4) .NE. 'T')) THEN
@


1.48
log
@bad scrfile for 'y'
@
text
@d28 69
@


1.47
log
@AP rewrite
@
text
@d234 1
a234 1
               SCRFILE = SCRATCH.file 
@


1.46
log
@new 'AP' op
@
text
@d45 1
d152 1
a152 1
C        FIND NUMBER OF REFERENCE RINGS
d202 1
a202 1
     &              '  WILL USE REFERENCE RINGS FILE INSTEAD') 
d213 4
a216 3
        IF (CTYPE(1:2) .NE. 'MQ' .AND. 
     &      CTYPE(1:2) .NE. 'NQ' .AND.
     &      CTYPE(1:2) .NE. 'RQ') THEN
d220 1
a220 1
            CALL FILERD(ASK,NA,NULL,'REFERENCE RINGS (SCRATCH)',IRTFLG)
d222 2
d226 1
a226 7
     &        'OBSOLETE, USE : <AP I> TO CREATE REFERENCE RINGS FILE',N)
               GOTO 9999

            ELSEIF (NA .LE. 3 .AND. ASK(1:1) .EQ. 'Y') THEN
               CALL ERRT(101,
     &           'OBSOLETE, GIVE NAME OF EXISTING REFERENCE RINGS FILE',
     &         NDUM)
a227 1

d231 1
a231 2
     &          'OBSOLETE, MUST GIVE A NAME FOR REFERENCE RINGS FILE',
     &         NDUM)
d233 4
a237 1
            SCRFILE = ASK
d242 1
a242 1
         IF (CTYPE(1:1) .EQ. 'I') THEN
d244 2
a245 1
C          CREATE REFERENCE RINGS FILE AND QUIT
d250 1
a250 1
     &                       LUNRING,SCRFILE,IRTFLG)
d289 1
d305 3
d312 2
d324 1
d326 2
d332 1
a332 1
     &                REFPAT,EXPPAT,.FALSE.,CTYPE)
d336 2
d354 2
d363 2
d381 2
d392 2
d405 3
a407 3
2600     FORMAT (/ ' ',72('-')//,
     &             ' ','END OF COMPUTATION',//,
     &             ' ',72('-')/)
@


1.45
log
@ask to dsgrs
@
text
@d24 1
a24 1
C    APMASTER(MODE,CTYPE)                                 10/21/99
d26 1
a26 6
C    DISTANCES BETWEEN PROJECTIONS.
C    BUFFER ON THE DISK IN THE 'SCRATCH.FILE'
C    SWITCHES BETWEEN "IN CORE" AND "ON DISK" VERSION,
C    SCRATCH.FILE PRODUCED IN EITHER CASE ...
C    RESTRICTED ANGULAR SEARCH RANGE.
C    DO NOT CHECK MIRRORED ORIENTATIONS..
d35 16
a50 5
        INTEGER, ALLOCATABLE, DIMENSION(:)   :: ILIP
        INTEGER, ALLOCATABLE, DIMENSION(:,:) :: NUMR

        CHARACTER (LEN=MAXNAM) ::  ASK,SCRFILE,FILNAM,REFANG
        CHARACTER (LEN=MAXNAM) ::  REFPAT,EXPPAT,EXPANG,OUTANG
d52 2
a53 3
	CHARACTER(LEN=1) ::        MODE,NULL
	CHARACTER(LEN=*) ::        CTYPE
        LOGICAL          ::        SUCCESS
a54 2
	DATA  LUNR,LUNI/50,51/

d59 1
a59 1
	CALL FILELIST(.TRUE.,LUNR,REFPAT,NLET,INUMBR,NILMAX,NUMREF,
d72 1
a72 1
C       GET FIRST REFERENCE IMAGE TO DETERMINE DIMS
d76 1
a76 1
        CALL OPFILEC(0,.FALSE.,FILNAM,LUNR,'O',IFORM,NSAM,NROW,NSLICE,
d79 41
a119 1
        CLOSE(LUNR)
d121 4
a124 1
        CALL RDPRMI(MR,NR,NOT_USED,'FIRST AND LAST RING')
d126 2
a127 2
	IF(MR.LE.0.OR.NR.GE.MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1))THEN
	   CALL ERRT(31,'AP',NE)
a128 1
	ENDIF
d130 7
a136 3
        ISKIP = 1
        CALL  RDPRI1S(ISKIP,NOT_USED,'SKIP',IRTFLG)
        IF (IRTFLG .NE. 0) GOTO 9999
a137 1
        ISKIP = MAX0(1,ISKIP)
d139 4
a142 1
        IF (CTYPE .EQ. 'RN' .OR. CTYPE .EQ. 'RD') THEN
d146 2
a147 9
        ENDIF

C       ACCEPT EXTENSION IF FILE IS NAMED
        IRTFLG = 9
        CALL FILERD(ASK,NA,NULL,
     &        'SCRATCH FILE EXISTS (Y/N/W/NAME)?~',IRTFLG)
        IF (IRTFLG .NE. 0)  THEN
            CALL ERRT(101,'FILE NAME NOT ENTERED',NE)
            GOTO 9999
a149 6
         SCRFILE = 'scratch.file'
         IF (NA .GT. 1) THEN
            SCRFILE = ASK
            ASK     = 'N'
         ENDIF
         CALL SSUPCAS(ASK)
d151 1
a151 1
C        FIND NUMBER OF RINGS
d169 2
a170 2
C        CALCULATION OF ACTUAL DIMENSION OF AN IMAGE TO BE INTERPOLATED
C        2*(NO.OF RINGS)+(0'TH ELEMENT)+2*(MARGIN OF 1)
d172 5
a176 6
         NRA  = MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1,2*NR+3)
         LSAM = NSAM
         LROW = NROW
         NSAM = NRA
         NROW = NRA
         CALL ALPRBS(NUMR,NRING,LCIRC,MODE)
d181 82
a262 3
         IF (CTYPE .EQ. 'RN' .OR. CTYPE .EQ. 'RD' .OR. 
     &       CTYPE .EQ. 'MD' .OR. CTYPE .EQ. 'MH') THEN
C           -----------------------------------------DSFS, DSGR, & DSFR
d269 1
a269 2
C           IMAGES TO BE ALIGNED
	    CALL FILELIST(.TRUE.,LUNI,EXPPAT,NLEP,ILIP,NILMAX,NIDI,
d275 1
a275 1
         ENDIF
a276 20
         IF (CTYPE .EQ. 'MD') THEN
C           ------------------------- 'MD' ----------------------- DSFS
	    SUCCESS = .FALSE.
 	    IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
              WRITE(NOUT,*) '  CALLING DSFS_PM'

              CALL  DSFS_PM(INUMBR,NUMREF,ILIP,NIDI,
     &             NSAM,NROW,LSAM,LROW,
     &             NRING,LCIRC,NUMR,MODE,NUMTH,SUCCESS,
     &             REFPAT,EXPPAT)
 	    ENDIF

	    IF (.NOT.SUCCESS) THEN
                WRITE(NOUT,*) '  CALLING DSFS_P NOW'

                CALL DSFS_P(INUMBR,NUMREF,ILIP,NIDI,
     &             NSAM,NROW,LSAM,LROW,
     &             NRING,LCIRC,NUMR,
     &             MODE,ASK,SCRFILE,REFPAT,EXPPAT)
             ENDIF
d278 12
a289 2
         ELSEIF (CTYPE .EQ. 'RN' .OR. CTYPE .EQ. 'RD') THEN
C           --------------'RN' .OR. 'RD'------------------- DSGR & DSFR
d291 8
a298 2
            CALL FILERD(EXPANG,NEXPA,NULL,
     &		   'EXPERIMENTAL IMAGES ANGLES DOCUMENT',IRTFLG)
d300 1
d302 1
a302 1
	    CALL RDPRM(RANGE,NOT_USED,'RANGE OF ANGULAR SEARCH')
d304 28
a331 58
            IF (CTYPE .EQ. 'RN') THEN
C              -------------------------------'RN'--------------- DSGR
               CALL REG_GET_USED(NSEL_USED)
               IF (NSEL_USED .LE. 0) THEN
                  CALL  FILERD(OUTANG,NOUTANG,NULL,
     &		              'OUTPUT ANGLES DOCUMENT',IRTFLG)
               ENDIF

               IF (REFANG(1:1) .EQ. '*') THEN
C                 'SMALLANGLE' MODIFICATIONS WITH INLINE ANGLES

                  CALL DSGR_SA(INUMBR,NUMREF,ILIP,NIDI,
     &                NSAM,NROW,LSAM,LROW,RANGE,
     &                NRING,LCIRC,NUMR,
     &                MODE,ASK,OUTANG,SCRFILE,
     &                REFPAT,EXPPAT) 
               ELSE

                  SUCCESS = .FALSE.
	          IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. 
     &                ASK.EQ.'N') THEN
                      WRITE(NOUT,*) '  Trying: DSGR_PM'
                      CALL DSGR_PM(INUMBR,NUMREF,ILIP,NIDI,
     &                   NSAM,NROW,LSAM,LROW,RANGE,
     &                   NRING,LCIRC,NUMR,
     &                   MODE,NUMTH,REFANG,EXPANG,OUTANG,SUCCESS,
     &                   REFPAT,EXPPAT) 
	          ENDIF

	          IF (.NOT.SUCCESS) THEN 
                     WRITE(NOUT,*) '  Calling: DSGR_P'
                     CALL DSGR_P(INUMBR,NUMREF,ILIP,NIDI,
     &               NSAM,NROW,LSAM,LROW,RANGE,
     &               NRING,LCIRC,NUMR,
     &               MODE,ASK,REFANG,EXPANG,OUTANG,SCRFILE,
     &               REFPAT,EXPPAT) 
                  ENDIF
               ENDIF
            ELSE
C              ----------------------------------'RD'------------ DSFR
	       SUCCESS = .FALSE.
 	       IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')THEN
                  WRITE(NOUT,*) '  Trying: DSFR_PM'
                  CALL DSFR_PM(INUMBR,NUMREF,ILIP,NIDI,
     &               NSAM,NROW,LSAM,LROW,RANGE,
     &               NRING,LCIRC,NUMR,
     &               MODE,NUMTH,REFANG,EXPANG,SUCCESS,
     &               REFPAT,EXPPAT) 
 	       ENDIF

	       IF (.NOT.SUCCESS) THEN
                  WRITE(NOUT,*) '  Calling: DSFR_P'
                  CALL DSFR_P(INUMBR,NUMREF,ILIP,NIDI,
     &               NSAM,NROW,LSAM,LROW,RANGE,
     &               NRING,LCIRC,NUMR,
     &               MODE,ASK,REFANG,EXPANG,SCRFILE,
     &               REFPAT,EXPPAT) 
               ENDIF
d334 48
a381 1
         ELSEIF (CTYPE .EQ. 'RNS') THEN
a382 7
C           ----------------------- 'RNS'---------------------- DSGRS
C           GET IMAGE TO BE ALIGNED
            MAXIM = 0
            CALL OPFILEC(0,.TRUE.,FILNAM,LUNI,'O',IFORM,
     &                  LSAM,LROW,NSLICE,MAXIM,'EXPERIMENTAL IMAGE',
     &                  .FALSE.,IRTFLG)
	    IF (IRTFLG .NE. 0) GOTO 9999
a383 5
            CALL DSGRS(INUMBR,NUMREF,
     &               NSAM,NROW,LSAM,LROW,RANGE,
     &               NRING,LCIRC,NUMR,MODE,
     &               SUCCESS,REFPAT,ASK) 
         ENDIF
d385 1
a385 1
         WRITE (NOUT,2600)
d390 4
a393 3
9999     IF (ALLOCATED(ILIP))  DEALLOCATE(ILIP)
	 IF (ALLOCATED(NUMR))  DEALLOCATE(NUMR)

d400 1
@


1.44
log
@cosmetic
@
text
@d265 1
a265 1
     &               SUCCESS,REFPAT) 
@


1.43
log
@for AP MD operations (combined)
@
text
@d165 1
a165 1
c	    IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
d172 1
a172 1
c	    ENDIF
@


1.42
log
@error msg for unfound angles wrong
@
text
@d4 1
a4 1
C DSGR.F            'AP RN'
d12 3
a14 2
C                   OPFILEC                       FEB  03 ARDEAN LEITH
C
d24 1
a24 1
C    DSGR(MODE)                                 10/21/99
d35 1
a35 1
         SUBROUTINE DSGR(MODE)
d37 2
a38 1
	 PARAMETER  (NILMAX=99998)
d40 2
a41 2
         INCLUDE 'CMLIMIT.INC'
         INCLUDE 'CMBLOCK.INC'
d43 2
a44 2
         CHARACTER*80      FIPROJ,FINPAT,FINPIC,REFANG,EXPANG
         COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
d46 3
a48 5
	 INTEGER, ALLOCATABLE, DIMENSION(:,:) ::  NUMR
	 INTEGER, ALLOCATABLE, DIMENSION(:)   ::  ILIST,ILIP
         CHARACTER (LEN=MAXNAM) ::  ASK,SCRFILE,OUTANG
         CHARACTER(LEN=1)    ::     MODE,NULL
	 LOGICAL      ::            SUCCESS
d50 1
a50 1
         DATA  INPIC/77/
d52 2
a53 1
         NULL = CHAR(0)
d55 3
a57 9
	 ALLOCATE(ILIST(NILMAX),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, ILIST',IER)
            RETURN
         ENDIF 

C       ASK FOR DATA FILE
	CALL FILELIST(.TRUE.,INPIC,FINPAT,NLET,ILIST,NILMAX,NIMA,
     &     'ENTER TEMPLATE FOR 2-D REFERENCE IMAGES',IRTFLG)
d60 3
a62 6
C       NIMA - TOTAL NUMBER OF IMAGES
        IF (NIMA .GT. 0)  THEN
           WRITE(NOUT,2001) NIMA
2001       FORMAT('  Number of reference images: ',I7)
        ELSE
           CALL ERRT(101,'No reference images!',IDUM)
d66 3
d70 2
a71 1
        CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
d73 1
a73 1
        CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d76 1
a76 1
        CLOSE(INPIC)
d81 1
a81 1
	   CALL ERRT(31,'AP RN',NE)
d85 4
a88 1
        CALL  RDPRMI(ISKIP,NDUMP,NOT_USED,'SKIP')
d90 3
a92 1
        CALL  FILERD(REFANG,NREFA,NULL,
d94 2
a95 1
C        FILERD WILL RETURN IRTFLG=1 IF "*"
d97 8
a104 8
C        ACCEPT EXTENSION IF FILE IS NAMED
         IRTFLG = 9
         CALL FILERD(ASK,NA,NULL,
     &         'SCRATCH FILE EXISTS (Y/N/W/NAME)?~',IRTFLG)
         IF (IRTFLG .NE. 0)  THEN
             CALL ERRT(101,'FILE NAME NOT ENTERED',NE)
             GOTO 9999
         ENDIF
d111 1
d113 1
d119 3
a121 3
	 ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, NUMR',IER)
a139 12
         MAXRIN = NUMR(3,NRING)

	 ALLOCATE(ILIP(NILMAX),STAT=IRTFLG)
	 IF (IRTFLG .NE. 0) THEN
            CALL ERRT(46,'AP RN, ILIP',IER)
            GOTO 9999
         ENDIF

C        IMAGES TO BE ALIGNED
	 CALL FILELIST(.TRUE.,INPIC,FIPROJ,NLEP,ILIP,NILMAX,NIDI,
     &     'ENTER TEMPLATE FOR IMAGE SERIES TO BE ALIGNED',IRTFLG)
	 IF (IRTFLG .NE. 0) GOTO 9999
a140 9
         WRITE(NOUT,2002) NIDI
2002     FORMAT('  Number of experimental images: ',I6)

         CALL  FILERD(EXPANG,NEXPA,NULL,
     &		'EXPERIMENTAL IMAGES ANGLES DOCUMENT',IRTFLG)

	 CALL  RDPRM(RANGE,NOT_USED,'RANGE OF ANGULAR SEARCH')
C        NIDI - NUMBER OF EXPERIMENTAL IMAGES 

d144 13
a156 1
         CALL REG_GET_USED(NSEL_USED)
d158 2
a159 3
         IF (NSEL_USED .LE. 0) THEN
            CALL  FILERD(OUTANG,NOUTANG,NULL,
     &		        'OUTPUT ANGLES DOCUMENT',IRTFLG)
d162 23
a184 2
         IF (REFANG(1:1) .EQ. '*') THEN
C           'SMALLANGLE' MODIFICATIONS WITH INLINE ANGLES
d186 80
a265 18
            CALL DSGR_SA(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,OUTANG,SCRFILE)
         ELSE

            SUCCESS = .FALSE.
	    IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
               CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &            NSAM,NROW,LSAM,LROW,RANGE,
     &            NRING,LCIRC,MAXRIN,NUMR,
     &            MODE,NUMTH,REFANG,EXPANG,OUTANG,SUCCESS)
	    ENDIF

	    IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &         NSAM,NROW,LSAM,LROW,RANGE,
     &         NRING,LCIRC,MAXRIN,NUMR,
     &         MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)
a267 4
9999     IF (ALLOCATED(ILIP))  DEALLOCATE(ILIP)
	 IF (ALLOCATED(NUMR))  DEALLOCATE(NUMR)
	 IF (ALLOCATED(ILIST)) DEALLOCATE(ILIST)

a271 1
         END
d273 2
a274 379
C++************************************************************************
C
C    DSGR_PM.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_DS. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
C
C--************************************************************************

        SUBROUTINE  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,MODE,NUMTH,
     &          REFANG,EXPANG,OUTANG,SUCCESS)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        PARAMETER (NLIST=8)
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        INTEGER           NUMR(3,NRING)
	DIMENSION         ILIST(NIMA),ILIP(NIDI)
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
        CHARACTER (LEN=MAXNAM) ::  OUTANG
        CHARACTER*1       MODE

C       AUTOMATIC ARRAYS
        DIMENSION  BUFIN(LSAM)
	DIMENSION  WR(NRING)

	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  X
	REAL, ALLOCATABLE, DIMENSION(:,:) ::   BFC,DLIST,SA,TA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT

	LOGICAL  SUCCESS
	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

	RANGE = COS(RANGE*DGR_TO_RAD)
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE.EQ.'H')  WR=WR*0.5

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
#endif
	ALLOCATE(DLIST(NLIST,NUMTH),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, DLIST',IER)

C       ZERO DLIST ARRAY
	DLIST = 0.0
C       FLAG TO OPEN OUTPUT DOC FILE
        NRUN  = 0

	ALLOCATE(X(NSAM,NROW,NUMTH),SA(3,NIMA),TA(3,NIDI),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP MD, X',IER)

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          ALLOCATION FAILED, RETURN & USE SLOW METHOD
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   SUCCESS = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT ('--- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &               ' WILL TRY DSGR_P NOW ') 
           GOTO 9999
        ENDIF

        IASK8 = (LCIRC * NIMA + NIMA * 3 + NIDI * 3 + NSAM * NROW)*4
        CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

        SUCCESS = .TRUE.
        WRITE(NOUT,92) LCIRC,NIMA
92      FORMAT ('--- ALLOCATED: BFC(',I8,' X ',I8,'),  IN DSGR_PM') 

        CALL REG_GET_USED(NSEL_USED)

        LQ   = LROW/2+1
        LR1  = (NROW-1)/2
        LR2  = LQ+LR1
        LR1  = LQ-LR1
        LQ   = LSAM/2+1
        LS1  = (NSAM-1)/2
        LS2  = LQ+LS1
        LS1  = LQ-LS1

C       READ THE ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
        DO  IMI=1,NIMA
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING REFERENCE PROJECTION ANGLE',IMI)
              RETURN
           ENDIF
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
        ENDDO
        CLOSE(INANG)

C       READ THE ANGLES FOR ITI EXPERIMENTAL (SAMPLE) IMAGES
	DO  ITI=1,NIDI
	   CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',ITI)
              RETURN
           ENDIF
           TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
	ENDDO
	CLOSE(INANG)

	DO ITIT=1,NIMA,NUMTH
	   DO K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)

              CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	      MAXIM = 0
	      CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN

	      DO K2=LR1,LR2
                 CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	         DO K3=LS1,LS2
                    X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
	         ENDDO
	      ENDDO
	      CLOSE(INPIC)
	  ENDDO

C         NORMALIZE UNDER THE MASK
c$omp     parallel do private(K1)
	  DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
	    CALL NORMAS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                 NUMR,NUMR(1,NRING))

	    CALL ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
     &		       BFC(1,K1),LCIRC,NRING,MODE)
	    CALL FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	    CALL APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
	  ENDDO
       ENDDO

       DO ITIT=1,NIDI,NUMTH
C         LOOP OVER ALL SETS OF EXPERIMENTAL (SAMPLE) IMAGES
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	     MAXIM = 0
	     CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
             IF (IRTFLG .NE. 0)  RETURN

             DO K2=LR1,LR2
                CALL REDLIN(INPIC,BUFIN,LSAM,K2)
                   DO K3=LS1,LS2
                      X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1) = BUFIN(K3)
	           ENDDO
    	     ENDDO
	     CLOSE(INPIC)
	  ENDDO

C         NORMALIZE UNDER THE MASK
c$omp     parallel do private(ITI)
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
	     CALL DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,
     &             MODE,MAXRIN,BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	           DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),
     &             DLIST(4,ITI-ITIT+1))
	  ENDDO

C         DLIST(2) = IDI
C         DLIST(3) = EAV
C         DLIST(4) = ANGMOR(RANG,MODE)
C         DLIST 5&6  PERMANENTLY SET TO ZERO (KEEP SAME FORMAT AS
C         AP MQ COMMAND)
          DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             DLIST(1,ITI-ITIT+1) = ITI
             IF (DLIST(2,ITI-ITIT+1) .GT. 0.0)  THEN
                 IDIT                = ILIST(INT(DLIST(2,ITI-ITIT+1)))
                 DLIST(2,ITI-ITIT+1) = IDIT
                 ANGT                = ABS(TA(1,ITI)*SA(1,IDIT)+
     &                                     TA(2,ITI)*SA(2,IDIT) +
     &                                     TA(3,ITI)*SA(3,IDIT))
                 ANGT                = MIN(1.0,ANGT)
                 DLIST(8,ITI-ITIT+1) = ACOS(ANGT) / DGR_TO_RAD
             ELSE
                 DLIST(8,ITI-ITIT+1) = -1.0
             ENDIF
             DLIST(7,ITI-ITIT+1) = ILIP(ITI)

             IF (NSEL_USED .GT. 0) THEN
C               OUTPUT TO REGISTERS NOT TO DOC FILE
                IT = ITI-ITIT+1
                CALL REG_SET_NSEL(1,5,DLIST(2,IT),DLIST(3,IT),
     &              DLIST(4,IT),DLIST(5,IT),DLIST(6,IT),IRTFLG)
                CALL REG_SET_NSEL(6,2,DLIST(7,IT),
     &              DLIST(8,IT),0.0 ,0.0, 0.0,IRTFLG)
             ELSE
C               OUTPUT TO TO DOC FILE
                CALL SAVDN1(NDOC,OUTANG,DLIST(1,ITI-ITIT+1),NLIST,
     &                      NRUN,0)
                NRUN = 1
             ENDIF
          ENDDO
       ENDDO

       CALL  SAVDC
       CLOSE(NDOC)
       DEALLOCATE(BFC)

9999   DEALLOCATE(TA)
       DEALLOCATE(SA)
       DEALLOCATE(X)
       DEALLOCATE(DLIST)
       DEALLOCATE(TT)

       END


C++************************************************************************
C
C    DSGR_P.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_DS. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
C
C--************************************************************************

         SUBROUTINE DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NLIST=8)
        INTEGER           NUMR(3,NRING)
	DOUBLE PRECISION  EAV
	DIMENSION         ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG,SCRFILE
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
        CHARACTER (LEN=MAXNAM) ::  OUTANG

C       AUTOMATIC ARRAYS
        DIMENSION         BUFIN(LSAM)
	DIMENSION         WR(NRING)

	REAL, ALLOCATABLE, DIMENSION(:,:)  ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:)    ::  TOT,CIRC,CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TT,TOTMIN
#ifndef SP_32
        INTEGER *8       IASK8,IOK
#else
        INTEGER *4       IASK8,IOK
#endif

	CHARACTER(LEN=1) ::   MODE,ASK,NULL
	LOGICAL          ::   IN_CORE

	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

        NULL  = CHAR(0)

C       ZERO DLIST ARRAY
	DLIST = 0.0

C       FLAG TO OPEN OUTPUT DOC FILE
        NRUN  = 0

	RANGE = COS(RANGE*DGR_TO_RAD)

	CALL RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H')  THEN
           WR    = WR*0.5
           DIVAS = 180.0
        ELSE
           DIVAS = 360.0
        ENDIF
#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'AP RN, TT',IER)
           RETURN
        ENDIF
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'AP RN, TT',IER)
           RETURN
        ENDIF
#endif
	ALLOCATE(TOT(NIMA),TOTMIN(NIMA),X(NSAM,NROW),CIRC(LCIRC),
     &           CIROLD(LCIRC),SA(3,NIMA),LCG(NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'AP RN, TOT,....',IER)
           RETURN
        ENDIF

	IN_CORE = .TRUE.

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          GWP - I HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
	      CALL  ERRT(46,'AP RN, BFC',IER)
	      RETURN
	   ENDIF
           IN_CORE = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT (' --- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &               ' USING TEMPORARY FILE INSTEAD') 
        ELSE

           IASK8 = (LCIRC * NIMA + NIMA * 6 + LCIRC * 2 + NSAM * NROW)*4
           CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

           WRITE(NOUT,91) LCIRC,NIMA
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), IN DSGR_P ') 
  	ENDIF

        CALL REG_GET_USED(NSEL_USED)

        LQ  = LROW/2+1
        LR1 = (NROW-1)/2
        LR2 = LQ+LR1
        LR1 = LQ-LR1
        LQ  = LSAM/2+1
        LS1 = (NSAM-1)/2
        LS2 = LQ+LS1
        LS1 = LQ-LS1
d277 3
a279 1
        IF (.NOT.IN_CORE) CALL SETTHREADS(2)
d281 1
a281 630
C       READ  ANGLES AND CONVERT THEM TO UNITARY DIRECTIONAL VECTORS.
	DO  IMI=1,NIMA
	   CALL UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING REFERENCE PROJECTION ANGLE',IMI)
              RETURN
           ENDIF
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
	ENDDO
	CLOSE(INANG)

	IF (ASK .EQ. 'Y')  GOTO  7751

	IF (ASK.EQ.'W' .OR. .NOT.IN_CORE) THEN
C          OPEN(NSCF,FILE=SCRFILE,STATUS='UNKNOWN',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'U',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  RETURN
        ENDIF

	DO   K1=1,NIMA
C          OPEN REFERENCE PROJECTIONS
           CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	   MAXIM = 0
	   CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

	   DO K2=LR1,LR2
              CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	      DO K3=LS1,LS2
                 X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	      ENDDO
	   ENDDO
	   CLOSE(INPIC)

C          NORMALIZE UNDER THE MASK
           CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))

	   CALL ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)

	   IF (ASK.EQ.'W'.OR..NOT.IN_CORE)  WRITE(NSCF)  CIRC
           IF (IN_CORE) THEN
c$omp         parallel do private(i)
              DO I=1,LCIRC
                 BFC(I,K1) = CIRC(I)
              ENDDO
           ENDIF
	ENDDO

	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)
7751    CONTINUE
        IF (.NOT. IN_CORE .OR. ASK.EQ.'Y') THEN
C          OPEN(NSCF,FILE='scratch.file',STATUS='OLD',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'O',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0)  RETURN
        ENDIF

        IF (ASK .EQ. 'Y')  THEN
            DO  J=1,NIMA
               READ(NSCF) (BFC(I,J),I=1,LCIRC)
            ENDDO
            CLOSE(NSCF)
        ENDIF

        DO ITI=1,NIDI
C         OPEN EXPERIMENTAL (SAMPLE) IMAGES
          CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
          IF (IRTFLG .NE. 0)  RETURN

          DO K2=LR1,LR2
             CALL REDLIN(INPIC,BUFIN,LSAM,K2)
             DO K3=LS1,LS2
                X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	     ENDDO
    	  ENDDO
	  CLOSE(INPIC)

C         READ THE ANGLES FOR THIS EXPERIMENTAL (SAMPLE) IMAGE
	  CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,IRTFLG,2)
	   IF (IRTFLG .NE. 0) THEN
              CLOSE(INANG)
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',ITI)
              RETURN
           ENDIF
          TA(1) = COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2) = SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3) = COS(BUFIN(2)*DGR_TO_RAD)

C         NORMALIZE UNDER THE MASK
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))
	  CALL ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
	  CALL FRNG(CIROLD,LCIRC,NUMR,NRING)

C         DETERMINE WHICH ONES ARE TO BE COMPARED
	  NIMALCG = 0
          DO   IMI=1,NIMA
C             ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                   (- DO NOT CHECK MIRRORED)
              DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	      IF (DT .GE. RANGE)  THEN
	         NIMALCG      = NIMALCG+1
	         LCG(NIMALCG) = IMI
	      ELSE
	         TOTMIN(IMI)  = -1.0D20
	      ENDIF
	  ENDDO
          EAV = -1.0D20
	  IF (NIMALCG.GT.0) THEN
             IF (IN_CORE) THEN
c$omp           parallel do private(imil,imi)
                DO IMIL=1,NIMALCG
	           IMI = LCG(IMIL)
	           CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ENDDO
             ELSE
             REWIND  NSCF
             DO IMI=1,NIMA
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT
C                    (- DO NOT CHECK MIRRORED)
                DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	        IF (DT .GE. RANGE)  THEN
                   READ(NSCF)  CIRC
                   CALL CROSRNG_DS(CIRC,CIROLD,LCIRC,NRING,
     &	                     MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ELSE
                   READ(NSCF)
	           TOTMIN(IMI) = -1.0D20
	        ENDIF
	     ENDDO
          ENDIF

          DO IMI=1,NIMA
             IF (TOTMIN(IMI) .GE. EAV)  THEN
                EAV  = TOTMIN(IMI)
                IDI  = ILIST(IMI)
                RANG = TOT(IMI)
	     ENDIF
	  ENDDO

          DLIST(2) = IDI
          DLIST(3) = EAV
          RANG     = (RANG-1) / MAXRIN * DIVAS
          DLIST(4) = RANG
C         DLIST 5&6  SET TO ZERO (KEEPS SAME FORMAT AS 'AP MQ')
          IDIT     = ABS(IDI)
          ANGT     = ABS(TA(1)*SA(1,IDIT)+TA(2)*SA(2,IDIT) +
     &                   TA(3)*SA(3,IDIT))
          ANGT     = MIN(1.0,ANGT)
          DLIST(8) = ACOS(ANGT) / DGR_TO_RAD
	 ELSE
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REF. PROJECTIONS	
            DLIST(2) = 0.0
            DLIST(3) = -1.0
            DLIST(4) = 0.0
            DLIST(8) = -1.0
	 ENDIF

         DLIST(1) = ITI
         DLIST(7) = ILIP(ITI)

         IF (NSEL_USED .GT. 0) THEN
C           OUTPUT TO REGISTER NOT TO DOC FILE
            CALL REG_SET_NSEL(1,5,DLIST(2),DLIST(3),DLIST(4),
     &                  DLIST(5),DLIST(6),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(7),DLIST(8),0.0,0.0,0.0,IRTFLG)
         ELSE
C           OUTPUT TO TO DOC FILE
            CALL SAVDN1(NDOC,OUTANG,DLIST,NLIST, NRUN,0)
            NRUN = 1
         ENDIF
      ENDDO

      CALL  SAVDC
      CLOSE(NDOC)
      CLOSE(INANG)

#ifdef SP_MP
      IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
#endif

      IF (.NOT.IN_CORE)  CLOSE(NSCF)
      DEALLOCATE(BFC)
      DEALLOCATE(LCG)
      DEALLOCATE(SA)
      DEALLOCATE(CIROLD)
      DEALLOCATE(CIRC)
      DEALLOCATE(X)
      DEALLOCATE(TOTMIN)
      DEALLOCATE(TOT)
      DEALLOCATE(TT)

      END


C++************************************************************************
C
C    DSGR_SA.F
C
C **********************************************************************
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
C *********************************************************************C **************************************************************************
C
C  ORDER OF PROCESSING:
C 1 - CALCULATE WEIGHTS FOR RINGS IN RINGWE, STORE IN WR
C 2 - CONVERT EACH REFERENCE IMAGE TO RINGS, DO THE FFTS
C     FOR ALL THE RINGS, APPLY WEIGHTS TO THE RINGS, STORE IT IN BFC.
C     IN ADDITION, HIGHEST FREQUENCY FOR ALL THE RINGS EXCEPT
C     MAXRING ARE DIVIDED BY 2.
C 3 - CONVERT EACH INPUT IMAGE TO RINGS, DO THE FFTS,
C     COMPARE EACH INPUT IMAGE WITH ALL THE REFERENCE IMAGES
C     USING CROSRNG_DS. 
C     SINCE Y WERE PRE-WEIGHTED THE RESULTS IS ALREADY CORRECT.
C
C--************************************************************************

         SUBROUTINE DSGR_SA(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,ASK,NUMTH,OUTANG,SCRFILE)

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        PARAMETER (NLIST=8)

        INTEGER           NUMR(3,NRING)
	DOUBLE PRECISION  EAV
	DIMENSION         ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,SCRFILE
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
        CHARACTER (LEN=MAXNAM) ::  OUTANG

C       AUTOMATIC ARRAYS
        DIMENSION         BUFIN(LSAM)
	DIMENSION         WR(NRING)

	REAL, ALLOCATABLE, DIMENSION(:,:)  ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:)    ::  TOT,CIRC,CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) :: TT,TOTMIN
#ifndef SP_32
        INTEGER *8       IASK8,IOK
#else
        INTEGER *4       IASK8,IOK
#endif

	CHARACTER(LEN=1) ::   MODE,ASK,NULL
	LOGICAL          ::   IN_CORE

	DATA  INPIC/77/,NDOC/55/,NSCF/50/

        NULL  = CHAR(0)

C       ZERO DLIST ARRAY
	DLIST = 0.0

C       FLAG TO OPEN OUTPUT DOC FILE ON FIRST CALL
        NRUN  = 0

	RANGE = COS(RANGE*DGR_TO_RAD)

	CALL RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE .EQ. 'H')  THEN
           WR    = WR*0.5
           DIVAS = 180.0
        ELSE
           DIVAS = 360.0
        ENDIF

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'AP RN, TT',IER)
           RETURN
        ENDIF
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'AP RN, TT',IER)
           RETURN
        ENDIF
#endif
	ALLOCATE(TOT(NIMA),TOTMIN(NIMA),X(NSAM,NROW),CIRC(LCIRC),
     &           CIROLD(LCIRC),SA(3,NIMA),LCG(NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
           CALL  ERRT(46,'AP RN, TOT,....',IER)
           RETURN
        ENDIF

	IN_CORE = .TRUE.

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) THEN
C          GWP - I HAVE TO FIX THE ALLOCATION HERE FOR DEC UNIX
           IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	   ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	   IF (IRTFLG .NE. 0) THEN
	      CALL  ERRT(46,'AP RN, BFC',IER)
	      RETURN
	   ENDIF
           IN_CORE = .FALSE.
           WRITE(NOUT,90) LCIRC,NIMA
90         FORMAT (' --- CAN NOT ALLOCATE: BFC(',I8,' X ',I8,'), ',
     &               ' USING TEMPORARY FILE INSTEAD') 
        ELSE

           IASK8 = (LCIRC * NIMA + NIMA * 6 + LCIRC * 2 + NSAM * NROW)*4
           CALL BIGALLOC(IASK8,IOK,.FALSE.,.FALSE.,IRTFLG)

           WRITE(NOUT,91) LCIRC,NIMA
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), IN DSGR_P ') 
  	ENDIF

        CALL REG_GET_USED(NSEL_USED)

        LQ  = LROW/2+1
        LR1 = (NROW-1)/2
        LR2 = LQ+LR1
        LR1 = LQ-LR1
        LQ  = LSAM/2+1
        LS1 = (NSAM-1)/2
        LS2 = LQ+LS1
        LS1 = LQ-LS1

#ifdef SP_MP
        IF (.NOT.IN_CORE) WRITE(NOUT,*) ' SETTING OMP THREADS: 2'
        IF (.NOT.IN_CORE) CALL SETTHREADS(2)
#endif

	IF (ASK .EQ. 'Y')  GOTO  7751

	IF (ASK.EQ.'W' .OR. .NOT.IN_CORE) THEN
C          OPEN(NSCF,FILE=SCRFILE,STATUS='UNKNOWN',FORM='UNFORMATTED')
           CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'U',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ENDIF

	DO   K1=1,NIMA
C          READ REFERENCE IMAGES
           CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	   MAXIM = 0
	   CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &                 LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

	   DO K2=LR1,LR2
              CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	      DO K3=LS1,LS2
                 X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	      ENDDO
	   ENDDO

C          READ ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
           ITLOC = IAPLOC + 1
           CALL LUNGETVALS(INPIC,ITLOC,4,BUFIN,IRTFLG)
           IF (IRTFLG .NE. 0)  RETURN

           IF (BUFIN(4) .LE. 0) THEN
	      CALL ERRT(102,'NO ANGLES IN REF. PROJECTION',K1)
	      RETURN
           ENDIF
           SA(1,K1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(2,K1)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           SA(3,K1)=COS(BUFIN(2)*DGR_TO_RAD)	

	   CLOSE(INPIC)

C          NORMALIZE UNDER THE MASK
           CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))

	   CALL ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)

	   IF (ASK.EQ.'W'.OR..NOT.IN_CORE) WRITE(NSCF) CIRC
           IF (IN_CORE)  THEN
c$omp         parallel do private(i)
              DO I=1,LCIRC
                 BFC(I,K1) = CIRC(I)
              ENDDO
           ENDIF
	ENDDO

	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)

7751    CONTINUE
        IF (.NOT. IN_CORE .OR. ASK.EQ.'Y') THEN
          CALL OPAUXFILE(.FALSE.,SCRFILE,NULL,-NSCF,0,
     &                     'O',' ',.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ENDIF

        IF (ASK .EQ. 'Y') THEN
            DO J=1,NIMA
               READ(NSCF) (BFC(I,J),I=1,LCIRC)
            ENDDO
            CLOSE(NSCF)
        ENDIF

        DO ITI=1,NIDI
C         READ EXPERIMENTAL IMAGES
          CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
          IF (IRTFLG .NE. 0)  RETURN

          DO K2=LR1,LR2
             CALL REDLIN(INPIC,BUFIN,LSAM,K2)
             DO K3=LS1,LS2
                X(K3-LS1+1,K2-LR1+1) = BUFIN(K3)
	     ENDDO
    	  ENDDO

C         READ THE ANGLES FOR ITI EXPERIMENTAL IMAGES
          CALL LUNGETVALS(INPIC,IAPLOC+1,4,BUFIN,IRTFLG)
          IF (IRTFLG .NE. 0)  RETURN
	  CLOSE(INPIC)

          IF (BUFIN(4) .LE. 0) THEN
	     CALL ERRT(102,'NO ANGLES IN EXP. IMAGE',ITI)
	     RETURN
          ENDIF

C         CONVERT TO UNITARY DIRECTIONAL VECTORS.
          TA(1) = COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2) = SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3) = COS(BUFIN(2)*DGR_TO_RAD)

C         NORMALIZE UNDER THE MASK
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                NUMR,NUMR(1,NRING))
	  CALL ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
	  CALL FRNG(CIROLD,LCIRC,NUMR,NRING)

C         DETERMINE WHICH ONES ARE TO BE COMPARED
	  NIMALCG = 0
          DO IMI=1,NIMA
C             ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                   (- DO NOT CHECK MIRRORED)
              DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	      IF (DT.GE.RANGE)  THEN
	         NIMALCG      = NIMALCG+1
	         LCG(NIMALCG) = IMI
	      ELSE
	         TOTMIN(IMI)  = -1.0D20
	      ENDIF
	  ENDDO
          EAV = -1.0D20
	  IF (NIMALCG.GT.0)  THEN
             IF (IN_CORE)  THEN
c$omp           parallel do private(imil,imi)
                DO IMIL=1,NIMALCG
	           IMI=LCG(IMIL)
	           CALL CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ENDDO
             ELSE
             REWIND  NSCF
             DO IMI=1,NIMA
C               ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT
C                    (- DO NOT CHECK MIRRORED)
                DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	        IF (DT.GE.RANGE)  THEN
                   READ(NSCF)  CIRC
                   CALL CROSRNG_DS(CIRC,CIROLD,LCIRC,NRING,
     &	                  MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	        ELSE
                   READ(NSCF)
	           TOTMIN(IMI) = -1.0D20
	        ENDIF
	     ENDDO
          ENDIF

          DO IMI=1,NIMA
             IF (TOTMIN(IMI) .GE. EAV)  THEN
                EAV  = TOTMIN(IMI)
                IDI  = ILIST(IMI)
                RANG = TOT(IMI)
	     ENDIF
	  ENDDO

          DLIST(2) = IDI
          DLIST(3) = EAV
          RANG     = (RANG-1)/MAXRIN*DIVAS
          DLIST(4) = RANG
C         DLIST 5&6 ARE PERMANENTLY SET TO ZERO (THIS KEEPS THE
C         SAME FORMAT AS 'AP MQ' OPERATION)
	 ELSE
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REFERENCE PROJECTIONS	
            DLIST(2) = 0.0
            DLIST(3) = -1.0
            DLIST(4) = 0.0
	 ENDIF

         DLIST(1) = ITI
         DLIST(7) = ILIP(ITI)

         IF (NSEL_USED .GT. 0) THEN
C           OUTPUT TO REGISTER NOT TO DOC FILE
            CALL REG_SET_NSEL(1,5,DLIST(2),DLIST(3),DLIST(4),
     &                       DLIST(5),DLIST(6),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(7),DLIST(8),0.0,0.0,0.0,IRTFLG)

          ELSE
C           OUTPUT TO DOC FILE
            CALL SAVDN1(NDOC,OUTANG,DLIST,NLIST, NRUN,0)
            NRUN = 1
         ENDIF
      ENDDO
      CALL SAVDC
      CLOSE(NDOC)

#ifdef SP_MP
      IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
#endif

      IF (.NOT.IN_CORE) CLOSE(NSCF)
      DEALLOCATE(BFC)
      DEALLOCATE(LCG)
      DEALLOCATE(SA)
      DEALLOCATE(CIROLD)
      DEALLOCATE(CIRC)
      DEALLOCATE(X)
      DEALLOCATE(TOTMIN)
      DEALLOCATE(TOT)
      DEALLOCATE(TT)

      END


C++************************************************************************
C
C    DSGR2D.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C--************************************************************************

	SUBROUTINE  DSGR2D(X,NSAM,NROW,NUMR,NRING,MODE,MAXRIN,
     &		BFC,LCIRC,NIMA,TT,SA,TA,RANGE,
     &		DLIST2,DLIST3,RANG)

	CHARACTER*1      MODE
	DOUBLE PRECISION EAV,TOTMIN
        INTEGER          NUMR(3,NRING)
	DIMENSION X(NSAM,NROW),BFC(LCIRC,NIMA),SA(3,NIMA),TA(3)
	REAL, ALLOCATABLE, DIMENSION(:)    ::  CIROLD
	INTEGER, ALLOCATABLE, DIMENSION(:) ::  LCG

	ALLOCATE(CIROLD(LCIRC),LCG(NIMA),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, CIRCOLD,LCG',IER)

C       DETERMINE WHICH ONES ARE TO BE COMPARED
	NIMALCG = 0
        DO IMI=1,NIMA
C          ABS - DIRECTIONS AT 180 DEGREES ARE DIFFERENT 
C                (- DO NOT CHECK MIRRORED)
           DT = TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	   IF (DT .GE. RANGE)  THEN
	      NIMALCG      = NIMALCG+1
	      LCG(NIMALCG) = IMI
	   ENDIF
	ENDDO

	IF (NIMALCG.GT.0) THEN
	   CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                  NUMR,NUMR(1,NRING))
	   CALL ALRQS(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE)
	   CALL FRNGS(CIROLD,LCIRC,NUMR,NRING)
           EAV = -1.0D20
           DO IMIL=1,NIMALCG
	      IMI = LCG(IMIL)
	      CALL  CROSRNG_DS(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	                       MAXRIN,NUMR,TOTMIN,TOT,TT)
              IF (TOTMIN .GE. EAV)  THEN
                 EAV  = TOTMIN
                 IDI  = IMI
                 RANG = TOT
	      ENDIF
	   ENDDO

	   IF (MODE.EQ.'F')  THEN
              RANG = (RANG-1.0)/MAXRIN*360.0
           ELSE
              RANG = (RANG-1.0)/MAXRIN*180.0
	   ENDIF
	   DLIST2 = IDI
	   DLIST3 = EAV
	ELSE
           RANG   = 0.0
	   DLIST2 = 0.0
	   DLIST3 = -1.0
	ENDIF

	DEALLOCATE(LCG)
	DEALLOCATE(CIROLD)

	END
@


1.41
log
@opfilec
@
text
@d149 2
a150 2
        WRITE(NOUT,2002) NIDI
2002    FORMAT('  Number of experimental images: ',I6)
d308 1
d317 1
a317 1
          SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
d323 1
a323 1
C       READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
d328 1
a328 1
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',IMI)
d369 1
d471 1
a471 1
         SUBROUTINE  DSGR_P(ILIST,NIMA,ILIP,NIDI,
d608 1
d657 1
d672 1
a672 1
C         READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
d676 1
a676 1
	      CALL ERRT(102,'MISSING EXP. PROJECTION ANGLE',IMI)
@


1.40
log
@register returns changed
@
text
@d12 1
d77 1
a77 1
        CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d341 1
a341 1
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d371 1
a371 1
	     CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d608 1
a608 1
	   CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d656 1
a656 1
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d943 1
a943 1
	   CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d1006 1
a1006 1
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
@


1.39
log
@added angular change to output file
@
text
@d415 4
a418 4
                CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2,IT),
     &              DLIST(3,IT),DLIST(4,IT),DLIST(5,IT),IRTFLG)
                CALL REG_SET_NSEL(6,3,DLIST(6,IT),
     &              DLIST(7,IT),DLIST(8,IT),0.0,0.0,IRTFLG)
d733 1
a733 1
          RANG     = (RANG-1)/MAXRIN*DIVAS
d754 3
a756 4
            CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2),
     &                  DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,3,DLIST(6),DLIST(7),DLIST(8),
     &                  0.0,0.0,IRTFLG)
d763 1
d1102 3
a1104 4
            CALL REG_SET_NSEL(1,5,FLOAT(ILIP(ITI)),DLIST(2),
     &          DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,3,DLIST(6),DLIST(7),DLIST(8),
     &          0.0,0.0,IRTFLG)
@


1.38
log
@nloop,iloop_removed
@
text
@d4 1
a4 1
C DSGR.F
d10 2
d15 1
a15 1
C * COPYRIGHT (C)1985, 2001. HEALTH RESEARCH INCORPORATED (HRI),       *
d67 1
a67 1
2001       FORMAT(' Number of reference images: ',I6)
d149 1
a149 1
2002    FORMAT(' Number of experimental images: ',I6)
d235 1
a235 1
        PARAMETER (NLIST=7)
a307 2
        K2A  = 1
        LERR = -1
d309 5
a313 13
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
           IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,
     &                      3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL ERRT(102,'REF. PROJECTION ANGLE NOT FOUND',
     &                      ILIST(IMI))
                 RETURN
              ENDIF
              K2A=1
d315 1
a315 1
           SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
a321 3
        K2A  = 1
        LERR = -1

d323 5
a327 12
	   CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	   IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL  ERRT(102,
     &                'EXPER. PROJECTION ANGLE NOT FOUND',ILIP(ITI))
                 RETURN
              ENDIF
              K2A=1
d398 12
a409 3
             DLIST(1,ITI-ITIT+1)=ITI
             IF (DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &           ILIST(INT(DLIST(2,ITI-ITIT+1)))
d411 1
d417 2
a418 2
                CALL REG_SET_NSEL(6,2,DLIST(6,IT),
     &              DLIST(7,IT),0.0,0.0,0.0,IRTFLG)
d478 1
a478 1
        PARAMETER  (NLIST=7)
d509 1
a581 2
	K2A=1
        LERR = -1
d583 6
a588 14
	   CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
           IF (LERR .NE. 0) THEN
                LERR = -1
		K2A  = 0
                CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,
     &                      LERR,K2A)
                IF (LERR .NE. 0) THEN
		   CLOSE(INANG)
	           CALL  ERRT(100,
     &             'ANGLE FOR REFERENCE PROJECTION NOT FOUND',NE)
		   RETURN
		ENDIF
		K2A = 1
            ENDIF
d628 1
a628 1
           IF (IN_CORE)  THEN
d647 1
a647 1
               READ(NSCF)  (BFC(I,J),I=1,LCIRC)
d668 6
a673 13
	  CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
          IF (LERR .NE. 0) THEN
             LERR = -1
             K2A  = 0
             CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
             IF (LERR .NE. 0) THEN
		CLOSE(INANG)
	        CALL  ERRT(100,
     &               'ANGLE FOR EXPERIMENTAL PROJECTION NOT FOUND',NE)
		RETURN
	     ENDIF
             K2A = 1
          ENDIF
d690 1
a690 1
	      IF (DT.GE.RANGE)  THEN
d697 4
a700 4
          EAV=-1.0D20
	  IF (NIMALCG.GT.0)  THEN
             IF (IN_CORE)  THEN
c$omp parallel do private(imil,imi)
d702 1
a702 1
	           IMI=LCG(IMIL)
d712 1
a712 1
	        IF (DT.GE.RANGE)  THEN
d715 1
a715 1
     &	                  MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
d735 6
a740 2
C         DLIST 5&6 ARE PERMANENTLY SET TO ZERO (THIS IS TO KEEP 
C         SAME FORMAT AS 'AP MQ' COMMAND)
d742 1
a742 1
C           PROJECTION IS OUTSIDE OF RANGE OF ALL THE REFERENCE PROJECTIONS	
d746 1
d755 3
a757 2
     &          DLIST(3),DLIST(4),DLIST(5),IRTFLG)
            CALL REG_SET_NSEL(6,2,DLIST(6),DLIST(7),0.0,0.0,0.0,IRTFLG)
d822 1
a822 1
        PARAMETER (NLIST=7)
d1104 2
a1105 1
            CALL REG_SET_NSEL(6,2,DLIST(6),DLIST(7),0.0,0.0,0.0,IRTFLG)
d1182 1
a1182 1
           DO   IMIL=1,NIMALCG
@


1.37
log
@prompts
@
text
@d79 1
a79 1
        CALL RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
d86 1
a86 1
        CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
d152 1
a152 1
	 CALL  RDPRM(RANGE,NLOOP,ILOOP,'RANGE OF ANGULAR SEARCH')
@


1.36
log
@outang savd & savdn1 both used bug fixed
@
text
@d9 1
d89 1
a89 1
     &		'REFERENCE PROJECTIONS ANGLES DOCUMENT',IRTFLG)
d143 1
a143 1
     &      'ENTER TEMPLATE FOR 2-D EXPERIMENTAL PROJECTIONS',IRTFLG)
d147 1
a147 1
2002    FORMAT(' Number of experimental projections: ',I6)
d150 1
a150 1
     &		'EXPERIMENTAL PROJECTIONS ANGLES DOCUMENT',IRTFLG)
@


1.35
log
@bad refang on 2nd expang unsav fixed
@
text
@d8 1
a776 1
            CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
a1124 1
            CALL SAVD(NDOC,DLIST,NLIST,IRTFLG)
@


1.34
log
@normass --> normas
@
text
@d687 1
a687 1
             CALL  UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
@


1.33
log
@iaploc  usage changed
@
text
@d7 1
d57 1
a57 1
     &     'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS',IRTFLG)
d61 6
a66 3
        IF (NIMA .LE. 0)  THEN
            CALL ERRT(101,'NO IMAGES!',IDUM)
            GOTO 9999
d69 1
a69 3
        WRITE(NOUT,2001) NIMA
2001    FORMAT(' NUMBER OF IMAGES =',I6)

a74 1

d90 9
a98 2
       	 CALL RDPRMC(ASK,NA,.TRUE.,
     &               'SCRATCH FILE EXISTS (Y/N/W/NAME)?',NULL,IRT)
d141 1
a141 1
     &   'ENTER TEMPLATE FOR 2-D EXPERIMENTAL PROJECTIONS NAME',IRTFLG)
d144 3
d191 3
a193 1
2600     FORMAT (/,' ',27('-'),'END OF COMPUTATION',25('-')/)
d372 1
a372 1
	    CALL NORMASS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
d1194 1
a1194 1
	   CALL NORMASS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
@


1.32
log
@activated dsgr_sa inline header angle code
@
text
@d929 1
d958 2
a959 1
           CALL LUNGETVALS(INPIC,IAPLOC+1,3,BUFIN,IRTFLG)
@


1.31
log
@typo
@
text
@d87 1
d147 7
a153 6
         IF (NSEL_USED .GT. 0) THEN
C           'SMALLANGLE' MODIFICATIONS
	    CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &         NSAM,NROW,LSAM,LROW,RANGE,
     &         NRING,LCIRC,MAXRIN,NUMR,
     &         MODE,ASK,NUMTH,REFANG,EXPANG,OUTANG,SCRFILE)
d155 4
a159 3

            CALL  FILERD(OUTANG,NOUTANG,NULL,
     &		'OUTPUT ANGLES DOCUMENT',IRTFLG)
@


1.30
log
@angles in header in dsgr_sa routine added
@
text
@d15 1
a15 1
C *********************************************************************C **************************************************************************
@


1.29
log
@added register output (usefull for AP RN with smallangles)
@
text
@d6 1
d8 8
a15 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
d40 1
a40 1
         CHARACTER (LEN=MAXNAM) ::  ASK,SCRFILE
d137 1
d139 1
a139 1
C        NIDI - NUMBER OF IMAGES TO CHECK DISTANCES
d143 22
a164 9
 
	 IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
            CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,
     &          MODE,NUMTH,NOUT,REFANG,EXPANG,SUCCESS)
	 ELSE
	    SUCCESS = .FALSE.
	 ENDIF
d166 1
a166 1
	 IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
d169 2
a170 1
     &         MODE,ASK,NUMTH,NOUT,REFANG,EXPANG,SCRFILE)
d210 1
a210 1
     &          NOUT,REFANG,EXPANG,SUCCESS)
d212 3
d222 1
d227 2
a231 1
	DIMENSION  WR(NRING)
d253 2
d411 3
a413 1
                CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
d461 4
a464 1
     &          MODE,ASK,NUMTH,NOUT,REFANG,EXPANG,SCRFILE)
d474 1
d496 2
d499 3
d553 1
a553 1
91         FORMAT (' --- ALLOCATED: BFC(',I8,' X ',I8,'), ') 
d761 2
d786 345
@


1.28
log
@SP_32 for NT
@
text
@d5 1
d162 1
a162 3
2600     FORMAT (/ ' ',72('-'),//,
     &             ' ', 'END OF COMPUTATION',//,
     &             ' ',72('-')/)
d255 2
d380 11
a390 1
             CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
d523 2
d719 10
a728 1
         CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
@


1.27
log
@allocation checks added
@
text
@d445 5
a449 1
	INTEGER * 8      :: IASK8,IOK
@


1.26
log
@typo '
@
text
@a4 1
C  needs improved error handling especially for deallocation on error!!
d31 1
d39 3
a41 3
         CHARACTER*80      ASK,SCRFILE
         CHARACTER*1       MODE,NULL
	 LOGICAL           SUCCESS
d129 2
a130 2
C       IMAGES TO BE ALIGNED
	CALL FILELIST(.TRUE.,INPIC,FIPROJ,NLEP,ILIP,NILMAX,NIDI,
d132 1
a132 1
	IF (IRTFLG .NE. 0) GOTO 9999
d141 3
a143 3

	IF (NUMTH.GT.1 .AND. NIDI.GT.NUMTH .AND. ASK.EQ.'N')  THEN
           CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d147 3
a149 3
	ELSE
	   SUCCESS = .FALSE.
	ENDIF
d151 1
a151 1
	IF (.NOT.SUCCESS) CALL DSGR_P(ILIST,NIMA,ILIP,NIDI,
d249 3
d253 2
d297 1
a297 1
              CALL UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
d445 1
d447 2
a448 2
	CHARACTER*1  MODE,ASK,NULL
	LOGICAL      IN_CORE
d485 1
d500 4
@


1.25
log
@cosmetic & better msgs. about alloc progress
@
text
@d271 1
a271 1
                 CALL ERRT(102,REF. PROJECTION ANGLE NOT FOUND',
@


1.24
log
@named scratch file, and used opauxfile & cosmetic
@
text
@d60 1
a60 1
            CALL ERRT(101,'NO IMAGES !',IDUM)
d142 1
a142 1
	IF (NUMTH.GT.1.AND.NIDI.GT.NUMTH.AND.ASK.EQ.'N')  THEN
d151 1
a151 1
	IF (.NOT.SUCCESS) CALL  DSGR_P(ILIST,NIMA,ILIP,NIDI,
d161 1
a161 1
2600     FORMAT (/ ' ',80('-'),//,
d163 1
a163 1
     &             ' ',80('-')/)
d166 223
d390 1
d405 10
a414 10
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
d426 1
a426 1
        INTEGER  NUMR(3,NRING)
d428 1
a428 1
	DIMENSION  ILIST(NIMA),ILIP(NIDI),DLIST(NLIST),TA(3)
d433 2
a434 2
        DIMENSION  BUFIN(LSAM)
	DIMENSION  WR(NRING)
d450 1
a450 1
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
d481 1
a481 1
C          GWP - I HAVE TO FIX THE ALLOCATION HERE
d489 7
a495 1
	ENDIF
d516 1
a516 1
		K2A=0
d525 1
a525 1
		K2A=1
d561 3
a563 3
	   CALL  ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	   CALL  FRNG(CIRC,LCIRC,NUMR,NRING)
	   CALL  APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
d567 1
a567 1
c$omp parallel do private(i)
d569 1
a569 1
                 BFC(I,K1)=CIRC(I)
d619 3
a621 3
          TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
          TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
d626 2
a627 2
	  CALL  ALRQ(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE,ITI)
	  CALL  FRNG(CIROLD,LCIRC,NUMR,NRING)
d630 1
a630 1
	  NIMALCG=0
d634 1
a634 1
              DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
d636 2
a637 2
	         NIMALCG=NIMALCG+1
	         LCG(NIMALCG)=IMI
d639 1
a639 1
	         TOTMIN(IMI)=-1.0D20
d646 1
a646 1
                DO   IMIL=1,NIMALCG
d653 1
a653 1
             DO    IMI=1,NIMA
d668 1
a668 1
          DO   IMI=1,NIMA
d689 2
a690 2
         DLIST(1)=ITI
         DLIST(7)=ILIP(ITI)
a714 214
C++************************************************************************
C
C    DSGR_PM.F
C
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
C
C--************************************************************************

        SUBROUTINE  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
     &          NSAM,NROW,LSAM,LROW,RANGE,
     &          NRING,LCIRC,MAXRIN,NUMR,MODE,NUMTH,
     &          NOUT,REFANG,EXPANG,SUCCESS)

C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C

        PARAMETER  (NLIST=7)
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
        INTEGER  NUMR(3,NRING)
	DIMENSION  ILIST(NIMA),ILIP(NIDI)
	COMMON  /F_SPEC/  FINPAT,FIPROJ,FINPIC,NLET,NLEP
	CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
        CHARACTER*1  MODE
C       AUTOMATIC ARRAYS
        DIMENSION  BUFIN(LSAM)
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  X
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  BFC,DLIST,SA,TA
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT
	DIMENSION  WR(NRING)

	LOGICAL  SUCCESS
	DATA  INPIC/77/,INANG/78/,NDOC/55/,NSCF/50/

	RANGE=COS(RANGE*DGR_TO_RAD)
	CALL  RINGWE(WR,NUMR,NRING,MAXRIN)
        IF (MODE.EQ.'H')  WR=WR*0.5

#ifdef SP_LIBFFT
	ALLOCATE(TT(MAXRIN+15),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
	CALL  DZFFT1DUI(MAXRIN,TT)
#else
	ALLOCATE(TT(1),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, TT',IER)
#endif
	ALLOCATE(DLIST(NLIST,NUMTH),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP RN, DLIST',IER)

C       ZERO DLIST ARRAY
	DLIST = 0.0

	ALLOCATE(X(NSAM,NROW,NUMTH),SA(3,NIMA),TA(3,NIDI),STAT=IRTFLG)
	IF (IRTFLG .NE. 0) CALL ERRT(46,'AP MD, X',IER)

	ALLOCATE(BFC(LCIRC,NIMA),STAT=IRTFLG)
	IF (IRTFLG.EQ.0) THEN
	   SUCCESS = .TRUE.

           LQ=LROW/2+1
           LR1=(NROW-1)/2
           LR2=LQ+LR1
           LR1=LQ-LR1
           LQ=LSAM/2+1
           LS1=(NSAM-1)/2
           LS2=LQ+LS1
           LS1=LQ-LS1
C          READ THE ANGLES AND CONVERT TO UNITARY DIRECTIONAL VECTORS.
	   K2A=1
           LERR = -1
	   DO  IMI=1,NIMA
	     CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	     IF (LERR .NE. 0) THEN
                LERR = -1
		K2A  = 0
                CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,
     &                      3,LERR,K2A)
                IF (LERR .NE. 0) THEN
		   CLOSE(INANG)
	           CALL ERRT(100,
     &                'ANGLE FOR REFERENCE PROJECTION NOT FOUND',NE)
		   RETURN
                ENDIF
                K2A=1
            ENDIF
            SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
            SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
            SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
	ENDDO
	CLOSE(INANG)

C       READ THE ANGLES FOR ITI EXPERIMENTAL PROJECTION
	K2A  = 1
        LERR = -1
	DO  ITI=1,NIDI
	   CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	   IF (LERR .NE. 0) THEN
              LERR = -1
              K2A  = 0
              CALL UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
              IF (LERR .NE. 0) THEN
                 CLOSE(INANG)
                 CALL  ERRT(100,
     &                'ANGLE FOR EXPERIMENTAL PROJECTION NOT FOUND',NE)
                 RETURN
              ENDIF
              K2A=1
           ENDIF
           TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
           TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
	ENDDO
	CLOSE(INANG)

	DO ITIT=1,NIMA,NUMTH
	   DO K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)

              CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	      MAXIM = 0
	      CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN

	      DO K2=LR1,LR2
                 CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	         DO K3=LS1,LS2
                    X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
	         ENDDO
	      ENDDO
	      CLOSE(INPIC)
	  ENDDO

C         NORMALIZE UNDER THE MASK
c$omp parallel do private(K1)
	  DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
	  CALL NORMASS(X(1,1,K1-ITIT+1),-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &                 NUMR,NUMR(1,NRING))

	  CALL ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
     &		BFC(1,K1),LCIRC,NRING,MODE)
	  CALL FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	  CALL APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
	  ENDDO
       ENDDO

       DO ITIT=1,NIDI,NUMTH
	  DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
             CALL FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	     MAXIM = 0
	     CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
     &               LSAM,LROW,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
             IF (IRTFLG .NE. 0)  RETURN

             DO K2=LR1,LR2
                CALL REDLIN(INPIC,BUFIN,LSAM,K2)
                   DO K3=LS1,LS2
                     X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1) = BUFIN(K3)
	           ENDDO
    	        ENDDO
	        CLOSE(INPIC)
	     ENDDO

C            NORMALIZE UNDER THE MASK
c$omp parallel do private(ITI)
	     DO ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
	        CALL DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,
     &             MODE,MAXRIN,BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	           DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),
     &             DLIST(4,ITI-ITIT+1))
	     ENDDO

C            DLIST(2) = IDI
C            DLIST(3) = EAV
C            DLIST(4) = ANGMOR(RANG,MODE)
C            DLIST 5&6  PERMANENTLY SET TO ZERO (KEEP SAME FORMAT AS
C            AP MQ COMMAND)
             DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
                DLIST(1,ITI-ITIT+1)=ITI
                IF (DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &             ILIST(INT(DLIST(2,ITI-ITIT+1)))
                DLIST(7,ITI-ITIT+1) = ILIP(ITI)
                CALL SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
	     ENDDO
	  ENDDO
          CALL  SAVDC
          CLOSE(NDOC)
	  DEALLOCATE(BFC)
       ELSE
          SUCCESS=.FALSE.
       ENDIF

       DEALLOCATE(TA)
       DEALLOCATE(SA)
       DEALLOCATE(X)
       DEALLOCATE(DLIST)
       DEALLOCATE(TT)
       END
@


1.23
log
@error trapping on alloc & much cosmetic
@
text
@d38 4
a41 3
	 INTEGER, ALLOCATABLE, DIMENSION(:) ::  ILIST,ILIP
         CHARACTER*1  MODE,ASK,NULL
	 LOGICAL      SUCCESS
d55 1
a55 1
     &     'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS NAME',IRTFLG)
d87 7
a93 2
      	CALL RDPRMC(ASK,NA,.TRUE.,
     &	   'SCRATCH FILE EXISTS (Y/N/W)?',NULL,IRT)
d97 1
a97 1
            NRING=NRING+1
d106 1
a106 1
         NRING=0
d108 2
a109 2
            NRING=NRING+1
            NUMR(1,NRING)=I
d115 5
a119 5
         NRA=MIN0(((NSAM-1)/2)*2+1,((NROW-1)/2)*2+1,2*NR+3)
         LSAM=NSAM
         LROW=NROW
         NSAM=NRA
         NROW=NRA
d154 1
a154 1
     &         MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
d191 1
a191 1

d197 1
a197 1
     &          MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
d205 1
a205 1
	CHARACTER*80      FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
d217 1
a217 1
	CHARACTER*1  MODE,ASK
d222 1
d228 2
a229 2
           WR=WR*0.5
           DIVAS=180.0
d231 1
a231 1
           DIVAS=360.0
d235 4
a238 1
	IF (IRTFLG .NE. 0) CALL  ERRT(46,'AP RN, TT',IER)
d242 4
a245 1
	IF (IRTFLG .NE. 0) CALL  ERRT(46,'AP RN, TT',IER)
d267 8
a274 8
        LQ=LROW/2+1
        LR1=(NROW-1)/2
        LR2=LQ+LR1
        LR1=LQ-LR1
        LQ=LSAM/2+1
        LS1=(NSAM-1)/2
        LS2=LQ+LS1
        LS1=LQ-LS1
d305 6
a310 2
	IF (ASK.EQ.'W'.OR..NOT.IN_CORE) OPEN(NSCF,FILE='scratch.file',
     &     STATUS='UNKNOWN',FORM='UNFORMATTED')
d317 1
a317 1
           IF (IRTFLG .NE. 0)  RETURN
d346 7
a352 3
        IF (.NOT.IN_CORE .OR. ASK.EQ.'Y')
     &         OPEN(NSCF,FILE='scratch.file',
     &             STATUS='OLD',FORM='UNFORMATTED')
d375 1
a375 1
C         Read the angles for ITI experimental projection
d424 2
a425 2
C               ABS - directions at 180 degrees are different
C                    (- do not check mirrored)
d429 1
a429 1
                   CALL CROSRNG_DS (CIRC,CIROLD,LCIRC,NRING,
d453 1
a453 1
C           Projection is outside of RANGE of all the reference projections	
d470 1
a470 1
C     CLOSE(NSCF,DISPOSE='DELETE')
@


1.22
log
@H
@
text
@d5 1
d17 2
a18 1
C    DSGR                                 10/21/99
d22 3
a24 15
C     SCRATCH.FILE PRODUCED IN EITHER CASE ...
C     RESTRICTED ANGULAR SEARCH RANGE.
C     DO NOT CHECK MIRRORED ORIENTATIONS..
C
C     SUBROUTINE DSGR(MAXMEM)
C     SUBROUTINE  DSGR_P(BUF,ILIST,NILMAX,ILIP,NIDI,NIDI,
C     SUBROUTINE  NORMAS(X,NS1,NS2,NR1,NR2,IR1,IR2)
C     SUBROUTINE  ALPRBS
C     SUBROUTINE  ALRQ
C     SUBROUTINE  CROSRNG_DS
C     SUBROUTINE  FRNG(CIRC,LCIRC,NUMR,NRING)
C     SUBROUTINE PRB1D(B,NPOINT,POS)
C     SUBROUTINE  FFTR_D(X,NV)
C     SUBROUTINE  FFTC_D(BR,BI,LN,KS)
C     FUNCTION  LOG2(N)
d31 1
d33 2
d36 1
a36 3
         CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
         INTEGER  MAXRIN
         CHARACTER*1  MODE,ASK,NULL
d39 3
a41 1
	 LOGICAL  SUCCESS
d43 2
a44 1
         NULL=CHAR(0)
d46 5
a50 1
	ALLOCATE(ILIST(NILMAX))
a52 1

d55 1
a55 1
	IF (IRTFLG .NE. 0) RETURN
d58 7
a64 7
         IF(NIMA.GT.0)  THEN
            WRITE(NOUT,2001) NIMA
2001        FORMAT('  NUMBER OF IMAGES =',I5)
         ELSE
            WRITE(NOUT,*)  '  NO IMAGES !'
            RETURN
         ENDIF
d66 3
a68 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,NSAM,NROW,NSLICE,
d70 1
a70 1
         IF(IRTFLG.NE.0)  RETURN
d72 1
a72 1
         CLOSE(INPIC)
d74 1
a74 1
         CALL  RDPRMI(MR,NR,NLOOP,ILOOP,'FIRST AND LAST RING')
d78 1
a78 1
	   RETURN
d81 4
a84 18

         CALL  RDPRMI(ISKIP,NDUMP,NLOOP,ILOOP,'SKIP')
         ISKIP=MAX0(1,ISKIP)
         CALL  FILERD(REFANG,NREFA,NULL,
     &		'Reference projections angles document',IRTFLG)
C
C     NA=1
C     CALL  RDPRMC(ASK,NA,.TRUE.,'(F)ULL OR (H)ALF CIRCLE',NULL,IRT)
C     IF(ASK.EQ.'F')  THEN
C         MODE='F'
C     ELSEIF(ASK.EQ.'H')  THEN
C        MODE='H'
C     ELSE
C        RETURN
C     ENDIF
C     CALL  RDPRMI(JACUP,NDUMP,NLOOP,ILOOP,
C     & 'Precision of peak location (0..100)$')
C     JACUP=MAX0(0,MIN0(100,JACUP))
d86 1
a86 1
      	CALL  RDPRMC(ASK,NA,.TRUE.,
d90 1
a90 1
         DO    I=MR,NR,ISKIP
d93 1
d95 5
a99 1
	 IF(IRTFLG.NE.0) CALL ERRT(46,'AP RN, NUMR',IER)
d101 3
a103 3
         DO    I=MR,NR,ISKIP
          NRING=NRING+1
          NUMR(1,NRING)=I
d105 4
a108 4
C
C Calculation of actual dimension of an image to be interpolated
C 2*(No.of rings)+(0'th element)+2*(margin of 1)
C
d114 2
a115 2
         CALL  ALPRBS(NUMR,NRING,LCIRC,MODE)
         MAXRIN=NUMR(3,NRING)
d117 5
a121 1
	 ALLOCATE(ILIP(NILMAX))
d126 1
a126 1
	IF (IRTFLG.NE.0) RETURN
d142 1
a142 1
	   SUCCESS=.FALSE.
d145 9
a153 9
	IF (.NOT.SUCCESS) 
     &   CALL  DSGR_P(ILIST,NIMA,ILIP,NIDI,
     &      NSAM,NROW,LSAM,LROW,RANGE,
     &      NRING,LCIRC,MAXRIN,NUMR,
     &      MODE,ASK,NUMTH,NOUT,REFANG,EXPANG)
C
	 DEALLOCATE(ILIP)
	 DEALLOCATE(NUMR)
	 DEALLOCATE(ILIST)
d175 11
d195 2
a196 3
         PARAMETER  (NLIST=7)
         INTEGER  MAXRIN
         INTEGER  NUMR(3,NRING)
d199 1
d201 2
a202 2
	CHARACTER*80  FINPIC,FIPROJ,FINPAT,REFANG,EXPANG
C Automatic arrays
d204 4
a207 2
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  X,BFC,SA
	REAL, ALLOCATABLE, DIMENSION(:) ::  TOT,CIRC,CIROLD
d209 1
a209 2
	DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:) ::  TT,TOTMIN
	DIMENSION  WR(NRING)
d212 2
a213 1
	LOGICAL  IN_CORE
d216 3
a218 14
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C
	DLIST=0.0
	RANGE=COS(RANGE*DGR_TO_RAD)
C
d220 1
a220 1
        IF(MODE.EQ.'H')  THEN
d228 1
a228 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d232 1
a232 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d234 8
a241 14
	ALLOCATE(TOT(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TOT',IER)
	ALLOCATE(TOTMIN(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TOTMIN',IER)
	ALLOCATE(X(NSAM,NROW),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, X',IER)
	ALLOCATE(CIRC(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRC',IER)
	ALLOCATE(CIROLD(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRCOLD',IER)
	ALLOCATE(SA(3,NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, SA',IER)
	ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, LCG',IER)
d243 9
a251 12
	IF (IRTFLG.NE.0) THEN
C         GWP - I HAVE TO FIX THE ALLOCATION HERE
          IF (ALLOCATED(BFC)) DEALLOCATE(BFC)
	  ALLOCATE(BFC(LCIRC,1),STAT=IRTFLG)
	  IF (IRTFLG.NE.0) THEN
	     CALL  ERRT(46,'AP RN, BFC',IER)
	     RETURN
	  ELSE
	     IN_CORE=.FALSE.
	  ENDIF
	ELSE
	  IN_CORE=.TRUE.
d254 8
a261 8
         LQ=LROW/2+1
         LR1=(NROW-1)/2
         LR2=LQ+LR1
         LR1=LQ-LR1
         LQ=LSAM/2+1
         LS1=(NSAM-1)/2
         LS2=LQ+LS1
         LS1=LQ-LS1
d266 1
a266 1
C  Read the angles and convert them to unitary directional vectors.
d270 2
a271 2
	CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
d274 7
a280 5
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for reference projection not found',NE)
		RETURN
d284 3
a286 3
        SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
d289 4
a292 4
C
	IF(ASK.EQ.'Y')  GOTO  7751
C
	IF(ASK.EQ.'W'.OR..NOT.IN_CORE) OPEN(NSCF,FILE='scratch.file',
d294 1
a294 1
C
d296 3
a298 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d300 20
a319 24
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
2032       FORMAT(' File not found ',A80,/,' Operation abandoned')
           RETURN
          ENDIF
	 DO    K2=LR1,LR2
          CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	  DO    K3=LS1,LS2
            X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
	  ENDDO
	 ENDDO
	 CLOSE(INPIC)
C
C  Normalize under the mask
C
	  CALL NORMAS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &       NUMR,NUMR(1,NRING))
C
	  CALL  ALRQ(X,NSAM,NROW,NUMR,CIRC,LCIRC,NRING,MODE,K1)
	  CALL  FRNG(CIRC,LCIRC,NUMR,NRING)
	  CALL  APPLYW(CIRC,LCIRC,NUMR,WR,NRING,MAXRIN)
C
	  IF(ASK.EQ.'W'.OR..NOT.IN_CORE)  WRITE(NSCF)  CIRC
          IF(IN_CORE)  THEN
d321 4
a324 4
           DO I=1,LCIRC
            BFC(I,K1)=CIRC(I)
           ENDDO
          ENDIF
d326 4
a329 3
	IF(ASK.EQ.'W'.OR..NOT.IN_CORE) CLOSE(NSCF)
7751     CONTINUE
         IF(.NOT.IN_CORE.OR.ASK.EQ.'Y')
d331 2
a332 2
     &        STATUS='OLD',FORM='UNFORMATTED')
         IF(ASK.EQ.'Y')  THEN
d334 1
a334 1
             READ(NSCF)  (BFC(I,J),I=1,LCIRC)
d336 5
a340 5
           CLOSE(NSCF)
         ENDIF
C
         DO  ITI=1,NIDI
          CALL  FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
d344 7
a350 9
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FIPROJ
           RETURN
          ENDIF
          DO    K2=LR1,LR2
           CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
            DO    K3=LS1,LS2
             X(K3-LS1+1,K2-LR1+1)=BUFIN(K3)
	    ENDDO
d353 6
a358 6
C
C  Read the angles for ITI experimental projection
	 CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
                LERR = -1
		K2A=0
d360 1
a360 1
                IF (LERR.NE.0) THEN
d362 2
a363 2
	 CALL  ERRT(100,
     &         'Angle for experimental projection not found',NE)
d365 8
a372 7
		ENDIF
		K2A=1
            ENDIF
         TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
         TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
         TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
C  Normalize under the mask
d374 1
a374 1
     &      NUMR,NUMR(1,NRING))
d377 14
a390 12
C Determine which ones are to be compared
	   NIMALCG=0
           DO   IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
         DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	    IF(DT.GE.RANGE)  THEN
	     NIMALCG=NIMALCG+1
	     LCG(NIMALCG)=IMI
	    ELSE
	     TOTMIN(IMI)=-1.0D20
	    ENDIF
	   ENDDO
d392 2
a393 2
	 IF(NIMALCG.GT.0)  THEN
          IF(IN_CORE)  THEN
d395 20
a414 21
            DO   IMIL=1,NIMALCG
	     IMI=LCG(IMIL)
	     CALL  CROSRNG_DS
     &		(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	 MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	    ENDDO
          ELSE
           REWIND  NSCF
           DO    IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	    IF(DT.GE.RANGE)  THEN
             READ(NSCF)  CIRC
             CALL  CROSRNG_DS
     &        (CIRC,CIROLD,LCIRC,NRING,
     &	MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
	    ELSE
             READ(NSCF)
	     TOTMIN(IMI)=-1.0D20
	    ENDIF
	   ENDDO
d416 1
a416 1
C
d418 4
a421 4
             IF(TOTMIN(IMI).GE.EAV)  THEN
                EAV=TOTMIN(IMI)
                IDI=ILIST(IMI)
                RANG=TOT(IMI)
d424 7
a430 7
C .....................................................................
          DLIST(2)=IDI
          DLIST(3)=EAV
          RANG=(RANG-1)/MAXRIN*DIVAS
          DLIST(4)=RANG
C DLIST 5&6 are permanently set to zero (this is to keep same format as
C  AP MQ command)
d432 4
a435 4
C Projection is outside of RANGE of all the reference projections	
          DLIST(2)=0.0
          DLIST(3)=-1.0
          DLIST(4)=0.0
d437 8
a444 7
          DLIST(1)=ITI
          DLIST(7)=ILIP(ITI)
          CALL  SAVD(NDOC,DLIST,NLIST,IRTFLG)
	 ENDDO
         CALL  SAVDC
         CLOSE(NDOC)
	 CLOSE(INANG)
d447 1
a447 1
	 IF (.NOT.IN_CORE) CALL SETTHREADS(NUMTH)
d449 30
a478 12
C        close(nscf,dispose='delete')
         IF(.NOT.IN_CORE)  CLOSE(NSCF)
	 DEALLOCATE(BFC)
	 DEALLOCATE(LCG)
	 DEALLOCATE(SA)
	 DEALLOCATE(CIROLD)
	 DEALLOCATE(CIRC)
	 DEALLOCATE(X)
	 DEALLOCATE(TOTMIN)
	 DEALLOCATE(TOT)
	 DEALLOCATE(TT)
         END
d484 13
d505 1
a505 1
C Automatic arrays
d514 1
a514 12
C
C  order of processing:
C 1 - calculate weights for rings in RINGWE, store in WR
C 2 - convert each reference image to rings, do the FFTs
C     for all the rings, apply weights to the rings, store it in BFC.
C     In addition, highest frequency for all the rings except
C     maxring are divided by 2.
C 3 - convert each input image to rings, do the FFTs,
C     compare each input image with all the reference images
C     using CROSRNG_DS. 
C     Since Y were pre-weighted the results is already correct.
C
d517 2
a518 1
        IF(MODE.EQ.'H')  WR=WR*0.5
d521 1
a521 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d525 1
a525 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TT',IER)
d528 8
a535 9
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, DLIST',IER)
	DLIST=0.0
C
	ALLOCATE(X(NSAM,NROW,NUMTH),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP MD, X',IER)
	ALLOCATE(SA(3,NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, SA',IER)
	ALLOCATE(TA(3,NIDI),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, TA',IER)
d537 17
a553 17
	IF(IRTFLG.EQ.0) THEN
	   SUCCESS=.TRUE.
C
         LQ=LROW/2+1
         LR1=(NROW-1)/2
         LR2=LQ+LR1
         LR1=LQ-LR1
         LQ=LSAM/2+1
         LS1=(NSAM-1)/2
         LS2=LQ+LS1
         LS1=LQ-LS1
C  Read the angles and convert them to unitary directional vectors.
	K2A=1
        LERR = -1
	DO  IMI=1,NIMA
	CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
d555 10
a564 8
		K2A=0
           CALL  UNSAV(REFANG,IMI-1,INANG,ILIST(IMI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for reference projection not found',NE)
		RETURN
		ENDIF
		K2A=1
d566 3
a568 3
        SA(1,IMI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(2,IMI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        SA(3,IMI)=COS(BUFIN(2)*DGR_TO_RAD)	
d571 3
a573 3
C
C  Read the angles for ITI experimental projection
	K2A=1
d576 16
a591 15
	CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
	    IF (LERR .NE. 0) THEN
                LERR = -1
		K2A=0
             CALL  UNSAV(REFANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
                IF (LERR.NE.0) THEN
		CLOSE(INANG)
	CALL  ERRT(100,'Angle for experimental projection not found',NE)
		RETURN
		ENDIF
		K2A=1
            ENDIF
        TA(1,ITI)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(2,ITI)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(3,ITI)=COS(BUFIN(2)*DGR_TO_RAD)
d594 3
a596 3
C
	DO   ITIT=1,NIMA,NUMTH
	 DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
d598 3
a600 3
         CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K1),INTFLAG)
	 MAXIM = 0
	 CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d602 9
a610 9
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
2032       FORMAT(' File not found ',A80,/,' Operation abandoned')
           RETURN
          ENDIF
	 DO    K2=LR1,LR2
          CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
	  DO    K3=LS1,LS2
            X(K3-LS1+1,K2-LR1+1,K1-ITIT+1)=BUFIN(K3)
a611 5
	 ENDDO
	 CLOSE(INPIC)
	ENDDO

C  Normalize under the mask
d613 1
d615 1
a615 1
	 DO  K1=ITIT,MIN(NIMA,ITIT+NUMTH-1)
d617 3
a619 3
     &       NUMR,NUMR(1,NRING))
C
	  CALL  ALRQS(X(1,1,K1-ITIT+1),NSAM,NROW,NUMR,
d621 10
a630 11
	  CALL  FRNGS(BFC(1,K1),LCIRC,NUMR,NRING)
	  CALL  APPLYWS(BFC(1,K1),LCIRC,NUMR,WR,NRING,MAXRIN)
C
	ENDDO
	 ENDDO
C
         DO  ITIT=1,NIDI,NUMTH
	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
          CALL  FILGET(FIPROJ,FINPIC,NLEP,ILIP(ITI),INTFLAG)
	  MAXIM = 0
	  CALL OPFILE(.FALSE.,FINPIC,INPIC,'O',IFORM,
d632 12
a643 14
          IF(IRTFLG.NE.0)  THEN
           WRITE(NOUT,2032)  FINPIC
           RETURN
          ENDIF
          DO    K2=LR1,LR2
           CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
            DO    K3=LS1,LS2
             X(K3-LS1+1,K2-LR1+1,ITI-ITIT+1)=BUFIN(K3)
	    ENDDO
    	  ENDDO
	  CLOSE(INPIC)
	 ENDDO
C
C  Normalize under the mask
d645 19
a663 4
	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
	CALL  DSGR2D(X(1,1,ITI-ITIT+1),NSAM,NROW,NUMR,NRING,MODE,MAXRIN,
     &    BFC,LCIRC,NIMA,TT,SA,TA(1,ITI),RANGE,
     &	  DLIST(2,ITI-ITIT+1),DLIST(3,ITI-ITIT+1),DLIST(4,ITI-ITIT+1))
d665 27
a691 26
C .....................................................................
C          DLIST(2)=IDI
C          DLIST(3)=EAV
C          DLIST(4)=ANGMOR(RANG,MODE)
C DLIST 5&6 are permanently set to zero (this is to keep same format as
C  AP MQ command)
 	  DO  ITI=ITIT,MIN(NIDI,ITIT+NUMTH-1)
           DLIST(1,ITI-ITIT+1)=ITI
	   IF(DLIST(2,ITI-ITIT+1).GT.0.0)  DLIST(2,ITI-ITIT+1)=
     &		ILIST(INT(DLIST(2,ITI-ITIT+1)))
           DLIST(7,ITI-ITIT+1)=ILIP(ITI)
           CALL  SAVD(NDOC,DLIST(1,ITI-ITIT+1),NLIST,IRTFLG)
	  ENDDO
	 ENDDO
         CALL  SAVDC
         CLOSE(NDOC)
	 DEALLOCATE(BFC)
	ELSE
	   SUCCESS=.FALSE.
	ENDIF
	 DEALLOCATE(TA)
	 DEALLOCATE(SA)
	 DEALLOCATE(X)
	 DEALLOCATE(DLIST)
	 DEALLOCATE(TT)
         END
d693 2
d698 2
a699 1
	CHARACTER*1  MODE
d701 1
a701 1
         INTEGER  NUMR(3,NRING)
d703 1
a703 1
	REAL, ALLOCATABLE, DIMENSION(:) ::  CIROLD
d705 14
a718 14
	ALLOCATE(CIROLD(LCIRC),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, CIRCOLD',IER)
	ALLOCATE(LCG(NIMA),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'AP RN, LCG',IER)
C
C Determine which ones are to be compared
	NIMALCG=0
        DO   IMI=1,NIMA
C ABS - directions at 180 degrees are different (- do not check mirrored)
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
	 IF(DT.GE.RANGE)  THEN
	  NIMALCG=NIMALCG+1
	  LCG(NIMALCG)=IMI
	 ENDIF
d720 25
a744 25
	IF(NIMALCG.GT.0) THEN
	CALL NORMASS(X,-NSAM/2,NSAM/2,-NROW/2,NROW/2,
     &      NUMR,NUMR(1,NRING))
	CALL  ALRQS(X,NSAM,NROW,NUMR,CIROLD,LCIRC,NRING,MODE)
	CALL  FRNGS(CIROLD,LCIRC,NUMR,NRING)
        EAV=-1.0D20
        DO   IMIL=1,NIMALCG
	 IMI=LCG(IMIL)
	  CALL  CROSRNG_DS
     &		(BFC(1,IMI),CIROLD,LCIRC,NRING,
     &	   MAXRIN,NUMR,TOTMIN,TOT,TT)
          IF(TOTMIN.GE.EAV)  THEN
           EAV=TOTMIN
           IDI=IMI
           RANG=TOT
	  ENDIF
	ENDDO
C
	 IF(MODE.EQ.'F')  THEN
          RANG=(RANG-1.0)/MAXRIN*360.0
         ELSE
          RANG=(RANG-1.0)/MAXRIN*180.0
	 ENDIF
	 DLIST2=IDI
	 DLIST3=EAV
d746 3
a748 3
         RANG=0.0
	 DLIST2=0.0
	 DLIST3=-1.0
d750 1
d753 1
@


1.21
log
@*** empty log message ***
@
text
@d38 1
a38 1
         SUBROUTINE DSGR
d93 1
a93 1
         MODE='F'
d226 6
d443 1
a443 1
          RANG=(RANG-1)/MAXRIN*360.0
d512 1
d718 5
a722 1
         RANG=(RANG-1)/MAXRIN*360.0
@


1.20
log
@no message for small 1st ring
@
text
@d34 1
a34 1
C     FUNCTION  LOG2_P(N)
@


1.19
log
@used setthreads
@
text
@d84 1
a84 5
	IF(MR.LT.5)  WRITE(NOUT,7021)  MR
7021	FORMAT(' Small value of the first ring given (',I1,') may'
     &	' result in numerical errors',/,
     & ' Please verify the results or increase FIRST RING value to 5')
C
@


1.18
log
@associated --> allocated
@
text
@d275 1
a275 1
C
d277 1
a277 1
	IF(.NOT.IN_CORE) call  omp_set_num_threads(2)
d432 5
a436 5
           IF(TOTMIN(IMI).GE.EAV)  THEN
            EAV=TOTMIN(IMI)
            IDI=ILIST(IMI)
            RANG=TOT(IMI)
	   ENDIF
d458 1
d460 1
a460 1
	IF(.NOT.IN_CORE) call  omp_set_num_threads(NUMTH)
d462 1
a462 1
C     close(nscf,dispose='delete')
@


1.17
log
@added assciated to gwp changes
@
text
@d255 1
a255 1
          IF (ASSOCIATED(BFC)) DEALLOCATE(BFC)
@


1.16
log
@DEALLOCATE ADDED BY GWP
@
text
@d253 3
a255 3
	IF(IRTFLG.NE.0) THEN
C         GWP - I have to fix the allocation here
          DEALLOCATE(BFC)
d257 3
a259 3
	  IF(IRTFLG.NE.0) THEN
	   CALL  ERRT(46,'AP RN, BFC',IER)
	   RETURN
d261 1
a261 1
	   IN_CORE=.FALSE.
d264 1
a264 1
	 IN_CORE=.TRUE.
d266 1
a266 1
C
@


1.15
log
@Used getthreads & cosmetic
@
text
@d254 2
@


1.14
log
@ # continue char fails on NT f90
@
text
@d1 1
d16 1
a16 1
C   DSGR                                 10/21/99
d21 2
a22 2
C  Restricted angular search range.
C  Do not check mirrored orientations..
d51 1
a51 1
C
d53 3
a55 3
C
C  ASK FOR DATA FILE
C
d57 1
a57 1
     &   'ENTER TEMPLATE FOR 2-D REFERENCE PROJECTIONS NAME',IRTFLG)
d59 2
a60 1
C  NIMA - total number of images
d62 2
a63 2
          WRITE(NOUT,2001) NIMA
2001      FORMAT('  Number of images =',I5)
d65 2
a66 2
          WRITE(NOUT,*)  '  No images !'
          RETURN
d68 1
a68 1
C
d73 2
a74 4
         IF(IRTFLG.NE.0)  THEN
          CALL ERRT(4,'AP RN ',NE)
          RETURN
         ENDIF
d76 1
a76 1
C
d78 1
a78 1
C
d80 2
a81 2
	 CALL ERRT(31,'AP RN',NE)
	 RETURN
d83 1
d108 2
a109 2
     &	'SCRATCH FILE EXISTS (Y/N/W)?',NULL,IRT)
C
d112 1
a112 1
          NRING=NRING+1
d114 2
a115 2
	ALLOCATE(NUMR(3,NRING),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL ERRT(46,'AP RN, NUMR',IER)
d132 1
a132 1
C
d134 2
a135 2
C
C  images to be aligned
d138 2
a139 1
	IF(IRTFLG.NE.0) RETURN
d141 9
a149 16
     &		'Experimental projections angles document',IRTFLG)
	 CALL  RDPRM(RANGE,NLOOP,ILOOP,'Range of angular search')
C  NIDI - number of images to check distances
C
#ifdef SP_MP
c$omp parallel private(np)
	np = OMP_GET_NUM_THREADS()
c$omp single
	NUMTH=np
c$omp end single
c$omp end parallel
#else
	NUMTH=1
#endif
	IF(NUMTH.GT.1.AND.NIDI.GT.NUMTH.AND.ASK.EQ.'N')  THEN
         CALL  DSGR_PM(ILIST,NIMA,ILIP,NIDI,
d154 1
a154 1
	 SUCCESS=.FALSE.
d156 2
a157 1
	IF(.NOT.SUCCESS) 
d167 3
a169 2
2600     FORMAT (/ ' ',80('-')//' ',
     &          'END OF COMPUTATION',//' ',80('-')/)
d171 2
d175 1
a175 1
C $$ DSGR_P.FOR
a186 3
C
C
C23456789012345678901234567890123456789012345678901234567890123456789012
d193 1
d210 1
a210 1
C
a211 1
	INTEGER  OMP_GET_NUM_THREADS
d214 1
a214 1
C
d490 1
a490 2
C
	INTEGER  OMP_GET_NUM_THREADS
d601 1
a601 1
C
d603 1
a603 1
C
@


1.13
log
@negative mirror
@
text
@d3 1
a3 1
C $$ DSGR.FOR
a14 5
C23456789012345678901234567890123456789012345678901234567890123456789012
C--************************************************************************

         SUBROUTINE DSGR

a22 1
C
d35 5
a39 1
	PARAMETER  (NILMAX=99998)
d122 1
a122 1
C 2*(# of rings)+(0'th element)+2*(margin of 1)
d172 1
a172 1
     #          'END OF COMPUTATION',//' ',80('-')/)
@


1.12
log
@*** empty log message ***
@
text
@d20 1
a20 1
C   DSGR                                 10/30/98
a27 7
C    WHEN IN THE OUTPUT DOCUMENT FILE N POINTS TO I+NIMA,
C    WHERE NIMA IS NUMBER OF REFERENCE PROJECTIONS,
C    THEN THE REFERENCE PROJECTION HAS TO BE MIRRORED
C    AND ITS EULERIAN ANGLES MODIFIED AS FOLLOWS:
C    I      :      THETA       PHI
C    I+NIMA :     180-THETA  180+PHI
C    AND PSI FROM THE OUTPUT DOCUMENT FILE  ->  180+PSI.
a282 2
c find max element on  ILIST
	MAXIMA=MAXVAL(ILIST)
d451 1
a451 1
          DLIST(2)=-1.0
a543 3

c find max element on  ILIST
	MAXIMA=MAXVAL(ILIST)
d647 1
a647 1
     &    BFC,LCIRC,NIMA,MAXIMA,TT,SA,TA(1,ITI),RANGE,
d676 1
a676 3



d678 1
a678 1
     &		BFC,LCIRC,NIMA,MAXIMA,TT,SA,TA,RANGE,
d724 1
a724 1
	 DLIST2=-1.0
@


1.11
log
@psi changed
@
text
@d353 1
a353 1
	 ENDDO
d384 1
a384 1
	CALL  UNSAV(EXPANG,ITI-1,INANG,ILIP(ITI),BUFIN,3,LERR,K2A)
d391 2
a392 1
	CALL  ERRT(100,'Angle for experimental projection not found',NE)
d397 3
a399 3
        TA(1)=COS(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(2)=SIN(BUFIN(3)*DGR_TO_RAD)*SIN(BUFIN(2)*DGR_TO_RAD)
        TA(3)=COS(BUFIN(2)*DGR_TO_RAD)
d409 1
a409 1
        DT=TA(1)*SA(1,IMI)+TA(2)*SA(2,IMI)+TA(3)*SA(3,IMI)
d425 1
a425 1
     &	MAXRIN,NUMR,TOTMIN(IMI),TOT(IMI),TT)
d447 1
a447 1
            IDI=IMI
d670 2
d733 3
a735 3
        RANG=(RANG-1)/MAXRIN*360.0
	DLIST2=IDI
	DLIST3=EAV
d737 3
a739 3
        RANG=0.0
	DLIST2=-1.0
	DLIST3=-1.0
@


1.10
log
@F90 version
@
text
@a453 1
          IF(RANG.GT.0.0)  RANG=360.0-RANG
a730 1
        IF(RANG.GT.0.0)  RANG=360.0-RANG
@


1.9
log
@*** empty log message ***
@
text
@d18 1
a18 1
         SUBROUTINE DSGR(MAXMEM)
d20 1
a20 1
C   DSFR                                 10/31/98
d25 1
a25 1
C  Restricted angular search range
d37 1
a37 1
C     SUBROUTINE  DSGR_S(BUF,ILIST,NILMAX,ILIP,NIPMAX,NIDI,
d41 1
a41 2
C     SUBROUTINE  CROSRNG
C     SUBROUTINE  CROSRMG
a45 1
C     FUNCTION  ANGMR(RKK,MODE)
d47 3
a49 16

	PARAMETER  (NILMAX=21000,NIPMAX=99998)
	PARAMETER  (MNUMR=480)
        INTEGER    NUMR(3,MNUMR)
	INCLUDE 'CMBLOCK.INC'
#ifdef SP_F90
        INCLUDE 'F90ALLOC.INC'
        REAL, DIMENSION(:), POINTER :: IPQ
        REAL, DIMENSION(:), POINTER :: BFC

#else
         DIMENSION BFC(1)
         POINTER   (IPQ,BFC) 
#endif
         LOGICAL         RUNTIME
         COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),ILIP(NIPMAX),Q(1)
d54 3
a56 2
         LOGICAL  IN_CORE
         EQUIVALENCE  (Q,NUMR)
d59 3
a61 1

d64 1
a64 2
         NMAX=NILMAX
         CALL  FILSEQP(FINPAT,NLET,ILIST,NMAX,NIMA,
d66 1
d68 8
a75 1

d77 6
a82 4
         CALL  OPENFB(BUF,FINPIC,INPIC,NSAM,NROW,'O',NF,NSL)
         IF (NF.NE.2)  THEN
            WRITE(NOUT,*)  ' FILE NOT FOUND'
            RETURN
d85 1
d89 2
a90 2
	CALL ERRT(31,'OR 2',NE)
	RETURN
d101 1
a114 1
         JACUP=0
d120 8
a127 2
         NRING=NRING+1
         NUMR(1,NRING)=I
d129 1
a129 1

d139 6
a144 2
         NMAX=NIPMAX
         CALL  FILSEQP(FIPROJ,NLEP,ILIP,NMAX,NIDI,
d146 1
a151 29
C
C   memory division
C     NUMR        1
C     CIRC        2
C A: X                 3
C    BUFIN             4
C    WORK              5
C          B:
C             CIROLD   4
C             TEMP     6
C             TOTMIN   61
C             TOT      63
C             TT       65
C             WR       66
C             K_SA
C             BFC      7
C
         MAXRIN=NUMR(3,NRING)
         K1=1
         K2=IPALIGN64(K1+3*NRING)
         K7=IPALIGN64(K2+LCIRC)
         K3A=K7
         K41A=IPALIGN64(K3A+NSAM*NROW)
         K4A=IPALIGN64(K41A+LSAM)
         K5A=K4A
         K3B=K5A
         K4B=K3B
         K5B=IPALIGN64(K4B+LCIRC)
         K6B=K5B
d153 6
a158 1
        K61=K6B
d160 1
a160 3
C  have to add 2 due to libfft
C  have to add 2 due to libfft
        K61=IPALIGN64(K6B+(MAXRIN+2)*4)
d162 39
d202 41
a242 4
         K62=IPALIGN64(K61+2*NIMA)
         K63=IPALIGN64(K62)
         K64=IPALIGN64(K63+NIMA)
         K65=IPALIGN64(K64)
d244 3
a246 1
         K66=IPALIGN64(K65+(LCIRC+15)*2)
d248 41
a288 1
         K66=K65
d290 183
a472 9
	K_SA=IPALIGN64(K66+NRING)
         K_LCG=IPALIGN64(K_SA+3*NIMA)
         K7B=IPALIGN64(K_LCG+NIMA)
        MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K7B)
	MEMBUF=LCIRC*NIMA
        CALL ALLOCIT(MEMBUF,RUNTIME,IPQ,'DSFS',IRTFLG)
	IF(MEMTOT.LE.MAXMEM.AND.RUNTIME)  THEN
#ifdef SP_F90
         BFC = >IPQ
d474 46
d521 9
a529 8
            WRITE (NOUT,2500)  MAXMEM , MEMTOT
2500        FORMAT (/,'  Alignment of projections, in-core version.',
     #              /,'  Memory: available ',I8,',  required ',I8,/)
            IN_CORE=.TRUE.
        ELSE
            IF(MEMTOT .LE. MAXMEM)  THEN
#ifdef SP_F90
            BFC = >IPQ
d531 40
a570 9
               WRITE (NOUT,2501)  MAXMEM , MEMTOT
2501           FORMAT (/,
     #'  Alignment of projections, on-disk version (scratch.file used).'
     #   ,/,'  Memory: available ',I8,',  required ',I8,/)
              IN_CORE=.FALSE.
            ELSE
               IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'AP RN',IRTFLG)
               CALL  ERRT(45,'AP RN',NE)
               RETURN
d572 30
a601 1
        ENDIF
d603 82
a684 11
         CALL  DSGR_S(BUF,ILIST,NILMAX,ILIP,NIPMAX,NIDI,
     &      NSAM,NROW,LSAM,LROW,NIMA,
     &      NRING,LCIRC,MAXRIN,JACUP,NUMR,RANGE,
     &      Q(K2),Q(K3A),Q(K41A),Q(K4B),Q(K_SA),Q(K_LCG),
     &      Q(K6B),Q(K61),Q(K63),Q(K65),Q(K66),
     &          BFC(1),
     &   MODE,ASK,IN_CORE,NOUT,REFANG,EXPANG)
        IF(RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'AP RN',IRTFLG)
         WRITE (NOUT,2600)
2600     FORMAT (/ ' ',80('-')//' ',
     #          'END OF COMPUTATION',//' ',80('-')/)
d686 57
@


1.8
log
@*** empty log message ***
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=99998)
d53 1
a53 1
         INCLUDE 'CMBLOCK.INC'
d89 10
@


1.7
log
@*** empty log message ***
@
text
@d216 1
a216 1
     &          BFC,
@


1.6
log
@*** empty log message ***
@
text
@a53 1
#ifdef SP_ALLOC
a63 1
#endif
a71 1
CNO_SAVE
a181 1
#ifdef SP_ALLOC
a188 5
#else
        K8B=IPALIGN64(K7B+LCIRC*NIMA)
        MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K8B)
        IF (MEMTOT.LE.MAXMEM)  THEN
#endif
d194 2
a195 7
         ELSE
#ifdef SP_ALLOC
            K8B=K8B-LCIRC*NIMA
            MEMTOT=NILMAX+1200+80+NIPMAX+MAX0(K5A,K8B)
#endif
            IF (MEMTOT .LE. MAXMEM)  THEN
#ifdef SP_ALLOC
a198 1
#endif
d205 2
a206 4
#ifdef SP_ALLOC
               IF (RUNTIME) CALL ALLOCIT(0,RUNTIME,IPQ,'DSFS',IRTFLG)
#endif
               WRITE(NOUT,*)  '  Sorry, not enough memory !'
d208 2
a209 2
           ENDIF
         ENDIF
a215 1
#ifdef SP_ALLOC
a216 3
#else
     &          Q(K7B),
#endif
a217 1
#ifdef SP_ALLOC
a218 1
#endif
@


1.5
log
@ff
@
text
@d51 2
a69 1
         INTEGER  NUMR(3,480)
@


1.4
log
@99998
@
text
@d67 2
a68 2
         INTEGER*2  MAXRIN
         INTEGER*2  NUMR(3,480)
d154 1
a154 1
         K2=IPALIGN64(K1+(3*NRING+1)/2)
@


1.3
log
@buffer 99999
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=99999)
d185 1
a185 1
        MEMTOT=NILMAX+1200+MAX0(K5A,K7B)
d194 1
a194 1
        MEMTOT=NILMAX+1200+MAX0(K5A,K8B)
d205 1
a205 1
            MEMTOT=NILMAX+1200+MAX0(K5A,K8B)
@


1.2
log
@TEMP fixed
@
text
@d50 1
a50 1
         PARAMETER  (NILMAX=21000,NIPMAX=20000)
@


1.1
log
@Initial revision
@
text
@d167 3
a169 1
        K61=IPALIGN64(K6B+MAXRIN*4)
@
