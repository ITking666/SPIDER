head	1.97;
access;
symbols
	pre_mrcs:1.97
	healthdept_2018:1.97
	pre_getangas:1.88
	GPL2010:1.87
	pre_GPL2010:1.86
	pre_var_equation:1.86
	pre_fftwrings:1.86
	pre_opfiles:1.86
	src:1.86
	best-code:1.86
	x-named-regs:1.86
	x:1.86
	v13-00:1.86
	pre_GPL:1.84
	prec_CA:1.81
	noindx:1.76
	Bproc:1.73
	oct21:1.72
	last77:1.69;
locks; strict;
comment	@c @;


1.97
date	2018.10.03.14.34.11;	author leith;	state Exp;
branches;
next	1.96;

1.96
date	2016.09.14.18.06.36;	author leith;	state Exp;
branches;
next	1.95;

1.95
date	2016.09.13.18.31.18;	author leith;	state Exp;
branches;
next	1.94;

1.94
date	2014.08.25.12.30.04;	author leith;	state Exp;
branches;
next	1.93;

1.93
date	2014.08.21.15.18.05;	author leith;	state Exp;
branches;
next	1.92;

1.92
date	2013.06.07.18.42.47;	author leith;	state Exp;
branches;
next	1.91;

1.91
date	2012.02.16.16.14.08;	author leith;	state Exp;
branches;
next	1.90;

1.90
date	2012.02.10.19.32.55;	author leith;	state Exp;
branches;
next	1.89;

1.89
date	2011.03.14.14.27.53;	author leith;	state Exp;
branches;
next	1.88;

1.88
date	2011.01.03.14.11.23;	author leith;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.24.13.26.25;	author leith;	state Exp;
branches;
next	1.86;

1.86
date	2005.10.17.20.32.18;	author leith;	state Exp;
branches;
next	1.85;

1.85
date	2005.10.17.18.23.10;	author leith;	state Exp;
branches;
next	1.84;

1.84
date	2004.09.30.16.42.29;	author leith;	state Exp;
branches;
next	1.83;

1.83
date	2004.08.30.17.40.39;	author leith;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.05.14.27.50;	author leith;	state Exp;
branches;
next	1.81;

1.81
date	2003.02.28.19.23.12;	author leith;	state Exp;
branches;
next	1.80;

1.80
date	2003.02.21.20.34.35;	author leith;	state Exp;
branches;
next	1.79;

1.79
date	2003.02.18.16.04.12;	author leith;	state Exp;
branches;
next	1.78;

1.78
date	2003.01.27.20.12.12;	author leith;	state Exp;
branches;
next	1.77;

1.77
date	2003.01.23.15.51.24;	author leith;	state Exp;
branches;
next	1.76;

1.76
date	2002.10.10.17.18.56;	author leith;	state Exp;
branches;
next	1.75;

1.75
date	2002.08.13.20.30.03;	author leith;	state Exp;
branches;
next	1.74;

1.74
date	2001.01.16.19.40.05;	author leith;	state Exp;
branches;
next	1.73;

1.73
date	99.12.03.15.28.30;	author leith;	state Exp;
branches;
next	1.72;

1.72
date	99.09.08.16.59.26;	author leith;	state Exp;
branches;
next	1.71;

1.71
date	99.04.14.17.55.39;	author leith;	state Exp;
branches;
next	1.70;

1.70
date	99.04.09.17.06.33;	author leith;	state Exp;
branches;
next	1.69;

1.69
date	99.03.16.19.29.26;	author leith;	state Exp;
branches;
next	1.68;

1.68
date	99.03.01.19.18.16;	author leith;	state Exp;
branches;
next	1.67;

1.67
date	99.03.01.16.02.40;	author leith;	state Exp;
branches;
next	1.66;

1.66
date	99.02.19.17.00.13;	author leith;	state Exp;
branches;
next	1.65;

1.65
date	99.01.08.16.42.11;	author leith;	state Exp;
branches;
next	1.64;

1.64
date	98.02.24.16.47.13;	author liy;	state Exp;
branches;
next	1.63;

1.63
date	98.01.21.20.43.07;	author leith;	state Exp;
branches;
next	1.62;

1.62
date	98.01.20.19.46.54;	author leith;	state Exp;
branches;
next	1.61;

1.61
date	98.01.12.20.29.42;	author leith;	state Exp;
branches;
next	1.60;

1.60
date	97.12.22.14.47.28;	author leith;	state Exp;
branches;
next	1.59;

1.59
date	97.12.19.19.31.34;	author leith;	state Exp;
branches;
next	1.58;

1.58
date	97.12.12.19.09.14;	author leith;	state Exp;
branches;
next	1.57;

1.57
date	97.12.12.18.01.49;	author leith;	state Exp;
branches;
next	1.56;

1.56
date	97.12.12.17.40.30;	author leith;	state Exp;
branches;
next	1.55;

1.55
date	97.12.12.17.01.46;	author leith;	state Exp;
branches;
next	1.54;

1.54
date	97.12.11.21.18.07;	author leith;	state Exp;
branches;
next	1.53;

1.53
date	97.12.10.21.18.55;	author leith;	state Exp;
branches;
next	1.52;

1.52
date	97.12.09.17.41.07;	author leith;	state Exp;
branches;
next	1.51;

1.51
date	97.12.08.16.59.30;	author leith;	state Exp;
branches;
next	1.50;

1.50
date	97.12.01.22.08.42;	author liy;	state Exp;
branches;
next	1.49;

1.49
date	97.12.01.21.42.20;	author liy;	state Exp;
branches;
next	1.48;

1.48
date	97.10.16.19.59.01;	author leith;	state Exp;
branches;
next	1.47;

1.47
date	97.10.16.19.49.14;	author leith;	state Exp;
branches;
next	1.46;

1.46
date	97.10.15.18.08.17;	author leith;	state Exp;
branches;
next	1.45;

1.45
date	97.10.14.13.52.33;	author leith;	state Exp;
branches;
next	1.44;

1.44
date	97.10.03.18.47.12;	author leith;	state Exp;
branches;
next	1.43;

1.43
date	97.05.16.18.17.16;	author leith;	state Exp;
branches;
next	1.42;

1.42
date	97.01.22.17.34.27;	author mladjadj;	state Exp;
branches;
next	1.41;

1.41
date	96.11.22.21.04.54;	author leith;	state Exp;
branches;
next	1.40;

1.40
date	96.11.22.18.03.01;	author leith;	state Exp;
branches;
next	1.39;

1.39
date	96.10.18.17.28.44;	author leith;	state Exp;
branches;
next	1.38;

1.38
date	96.10.18.17.09.23;	author leith;	state Exp;
branches;
next	1.37;

1.37
date	96.09.26.16.14.50;	author leith;	state Exp;
branches;
next	1.36;

1.36
date	96.08.29.15.25.52;	author leith;	state Exp;
branches;
next	1.35;

1.35
date	96.08.22.15.33.30;	author leith;	state Exp;
branches;
next	1.34;

1.34
date	96.08.21.17.49.11;	author pawel;	state Exp;
branches;
next	1.33;

1.33
date	96.08.21.14.09.48;	author leith;	state Exp;
branches;
next	1.32;

1.32
date	96.08.21.14.05.21;	author leith;	state Exp;
branches;
next	1.31;

1.31
date	96.08.16.15.17.17;	author leith;	state Exp;
branches;
next	1.30;

1.30
date	96.08.13.18.55.56;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	96.08.12.18.10.57;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	96.08.12.17.34.28;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	96.07.30.13.16.12;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	95.10.19.16.24.53;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	95.10.04.18.16.19;	author mladjadj;	state Exp;
branches;
next	1.24;

1.24
date	95.10.04.16.13.30;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	95.09.15.15.23.47;	author mladjadj;	state Exp;
branches;
next	1.22;

1.22
date	95.09.07.13.41.06;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	95.09.05.18.21.23;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	95.08.28.15.00.08;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	95.08.21.14.41.35;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	95.08.18.13.07.33;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	95.08.17.18.26.32;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	95.08.16.16.43.50;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	95.08.11.20.09.21;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	95.08.11.17.40.53;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	95.06.22.18.37.37;	author mladjadj;	state Exp;
branches;
next	1.12;

1.12
date	95.05.23.20.04.25;	author mladjadj;	state Exp;
branches;
next	1.11;

1.11
date	95.05.04.18.03.38;	author mladjadj;	state Exp;
branches;
next	1.10;

1.10
date	95.04.19.21.31.10;	author mladjadj;	state Exp;
branches;
next	1.9;

1.9
date	95.04.17.18.54.34;	author mladjadj;	state Exp;
branches;
next	1.8;

1.8
date	95.04.17.13.31.26;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	95.01.10.16.05.55;	author liy;	state Exp;
branches;
next	1.6;

1.6
date	94.11.17.17.22.26;	author mladjadj;	state Exp;
branches;
next	1.5;

1.5
date	94.11.17.15.33.41;	author mladjadj;	state Exp;
branches;
next	1.4;

1.4
date	94.11.09.20.08.06;	author mladjadj;	state Exp;
branches;
next	1.3;

1.3
date	94.05.17.12.53.34;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	94.05.13.14.08.17;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	94.05.13.12.50.53;	author leith;	state Exp;
branches;
next	;


desc
@unix specific source code with preprocessor lines
@


1.97
log
@email_health_dept
@
text
@
C++*********************************************************************
C
C OPENSTK.F -- CREATED                         DEC 96 -- ArDean Leith
C              USED LUNHDR                     FEB 99 -- ArDean Leith
C              INDEXED STACKS                  JAN 03 -- ArDean Leith
C              HEADER COPY                     FEB 03 -- ArDean Leith
C              OPENFIL PARAMETERS              APR 04 -- ArDean Leith
C              BAD IRTFLG RETURN               AUG 04 -- ArDean Leith
C              ERROR MSG                       DEC 10 -- ArDean Leith
C              MPI ERROR MSG                   MAR 11 -- ArDean Leith
C              MSG                             FEB 12 -- ArDean Leith
C              'ST' MISSING STACKED IMAGE      AUG 14 -- ArDean Leith
C              'FS' ON MISSING STACKED IMAGE   SEP 16 -- ArDean Leith
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2016  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  OPENSTK(LUNT,FILNAM,LUN,NX,NY,NZ,NSTACK,ITYPE,DISP,IRTFLG)
C
C  PURPOSE:       TO OPEN A NEW OR EXISTING STACK FILE.  NOT FOR INLINE
C                 STACKS
C
C  PARAMETERS:
C        LUNT       UNIT TO COPY HEADER VALUES FROM               (SENT)
C        FILNAM     CHARACTER ARRAY, CONTAINING FILE NAME         (SENT)
C        LUN        LOGICAL UNIT NUMBER FOR FILNAM.               (SENT)
C        NX,NY      DIMENSIONS OF FILE                       (SENT/RET.)
C        NZ         NUMBER OF PLANES                         (SENT/RET.)
C        ITYPE      IFORM                                    (SENT/RET.)    
C        NSTACK     STACK INDICATOR                          (SENT/RET.)
C                   ON INPUT:
C                      >0 : REGULAR STACK FILE (IF NEW)
C                      <0 : INDEXED STACK FILE (IF NEW)
C                   ON OUTPUT:                               
C                      -2 : NOT STACK = ERROR
C                      -1 : STACKED IMAGE
C                       0 : REGULAR BARE STACK, CONTAINS NO IMAGE(S)
C                      >0 : INDEXED BARE STACK, VALUE IS MAX. IMAGE
C                       5 : NOT SPIDER FILE?
C
C        DISP       FILE DISPOSITION, SEE OPFIL FOR VALUES        (SENT)
C        IRTFLG     ERROR RETURN FLAG.                            (RET.)
C                   IRTFLG = 0    NORMAL RETURN
C
C  CALL TREE:  SEE OPFILC
C
C23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C--*********************************************************************

        SUBROUTINE OPENSTK(LUNT,FILNAM,LUN,NX,NY,NZ,
     &                     NSTACK,ITYPE,DISP,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        INTEGER                  :: LUNT
        CHARACTER (LEN=*)        :: FILNAM
        INTEGER                  :: LUN,NX,NY,NZ,ITYPE,IRTFLG
        CHARACTER (LEN=*)        :: DISP

        CHARACTER (LEN=MAXNAM)   :: FILNOAT,FILNPE
        CHARACTER (LEN=2*MAXNAM) :: MSG
	LOGICAL                  :: EX,ISDIGI,CALLERRTRED,INDXD

#ifdef USE_MPI
        include 'mpif.h'
#endif

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

C       SHOULD NOT STOP IF DISP == 'Z' AND REDHED FAILS
        CALLERRTRED = (DISP(1:1) .NE. 'Z')

C       SET ERROR RETURN
        IRTFLG   = 1
        NSTACKIN = NSTACK

        ILOCAT = INDEX(FILNAM,'@@')      

        IF (ISDIGI(FILNAM(ILOCAT + 1:ILOCAT + 1))) THEN
C          FIND IMAGE NUMBER WITHIN STACK FILE 
           CALL GETFILENUM(FILNAM(ILOCAT:),IMGNUM,NDIGITS,.TRUE.,IER)
           IF (IER .NE. 0) RETURN

           IF (IMGNUM <= 0) THEN
              NLEN = lnblnkn(FILNAM)
              WRITE(NOUT,*) 'STACK NAME:',FILNAM(1:NLEN)
              CALL ERRT(102,'STACKS START WITH IMAGE: 1 NOT',IMGNUM)
              RETURN
           ENDIF
        ELSE
C          SET IMGNUM FOR BARESTACK
           IMGNUM = 0
        ENDIF

C       GET FILENAME WITHOUT @@ AND DATEXC
        FILNOAT = FILNAM(1:ILOCAT-1) // CHAR(0) 

C       CREATE STACK FILE NAME WITHOUT '@@' BUT WITH EXTENSION
        CALL FILNAMANDEXT(FILNOAT,DATEXC,FILNPE,NLET,.TRUE.,IRTFLGT)
	IF (IRTFLGT .NE.0) RETURN

C       SEE IF STACK FILE ALREADY EXISTS NOW
#ifdef USE_MPI
        INQUIRE(FILE=FILNPE,IOSTAT=IER,EXIST=EX)
        CALL MPI_BCAST(IER,1,MPI_INTEGER,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) ' OPENSTK: FAILED TO BCAST IER'
           STOP
        ENDIF

        CALL MPI_BCAST(EX,1,MPI_LOGICAL,0,ICOMM,MPIERR)
        IF (MPIERR .NE. 0) THEN
           WRITE(0,*) ' OPENSTK: FAILED TO BCAST EX'
           STOP
        ENDIF
#else
        INQUIRE(FILE=FILNPE,IOSTAT=IER,EXIST=EX)
#endif
        IF (IER .NE. 0) THEN
           WRITE(NOUT,*) '*** FILE INQUIRY ERROR: ',FILNPE(1:NLET)
           CALL ERRT(100,'OPENSTK',NE)
           RETURN
        ENDIF
 
	IF (DISP(1:1) == 'U' .OR. DISP(1:1) == 'N') THEN
C          WANT TO MAKE A NEW STACK OR NEW IMAGE WITHIN EXISTING STACK
C -------------------------------- NEW --------------------------------

           IF (.NOT. EX .OR. IMGNUM  ==  0) THEN
C             STACK FILE DOES NOT EXIST YET, OR MUST BE REPLACED

             IF (NSTACKIN < 0) THEN
C                FLAG FOR INDEXED STACK
                 CALL RDPRI1S(NSTACK,NOT_USED,
     &           'HIGHEST IMAGE/VOLUME NUMBER ALLOWED IN STACK',IRTFLGT)
                 IF (IRTFLGT .NE. 0) RETURN
                 IF (NSTACK < 1) THEN
                     CALL ERRT(101,'HIGHEST NUMBER MUST BE > 0',NE)
                     RETURN                        
                  ENDIF
                  NSTACK = -NSTACK
              ELSE
C                 REGULAR NEW STACK
                  NSTACK = 2
              ENDIF

C             CREATE NEW STACK FILE, OPENFIL WILL RETURN NSTACK = 0
	      CALL OPENFIL(0,FILNOAT,LUN, NX,NY,NZ,NSTACK,
     &                     ITYPE,DISP,.FALSE.,IRTFLG)
              IF (IRTFLG .NE. 0) RETURN

              IF (NSTACKIN < 0) THEN
C                 CLEAR STACK INDEX IN NEW FILE
                  CALL LUNCLRINDX(LUN,NX,IRTFLGT)
              ENDIF

              IF (IMGNUM <= 0) THEN
C                ONLY WANT TO OPEN NEW BARE STACK
                 IRTFLG  = 0
                 RETURN
              ENDIF

           ELSE
C             OPEN EXISTING STACK FILE TO APPEND A NEW STACKED IMAGE
              ITYPEIN = ITYPE
	      CALL OPENFIL(0,FILNOAT,LUN, NXF,NYF,NZF,NSTACK,
     &                     ITYPE,'O',.FALSE.,IRTFLGT)
              IF (IRTFLGT .NE. 0)  RETURN

C             OPENFIL WILL RETURN NUMBER OF IMAGES IN STACK, OR -1
C             IF THIS IS A SPECIFIC IMAGE WITHIN THE STACK, -2 IS
C             FOR NON-STACK IMAGE.

              IF (NSTACK <= -2) THEN
C                EXISTING FILE IS NOT A STACK
                 CALL ERRT(101,'EXISTING FILE IS NOT A STACK',NE)
                 RETURN

              ELSEIF (NXF .NE. NX .OR. NYF .NE. NY .OR.
     &                NZF .NE. NZ) THEN
C                EXISTING FILE HAS DIFFERING DIMENSIONS
                 MSG = 'IMAGE DIMENSIONS NOT SAME AS IN STACK '//
     &                  FILNOAT(1:NLET) 

                 CALL ERRT(101,MSG,NE)
                 RETURN

              ELSEIF (ITYPEIN .NE. ITYPE) THEN
C                EXISTING STACK FILE FORMAT NOT SAME AS IMAGE FORMAT
                 CALL ERRT(101,
     &              'IMAGES IN STACK MUST HAVE SAME FILE FORMAT',NE)
                 RETURN
              ENDIF
           ENDIF

C          RECOVER MAXIM & ISTACK FROM OVERALL HEADER 
           CALL LUNGETSTK(LUN,ISTACK,MAXIM,IRTFLGT)
           IF (IRTFLGT .NE. 0) RETURN

           IF (IMGNUM > MAXIM) THEN
C             UPDATE OVERALL HEADER WITH MAXIMUM IMAGE NUMBER IN USE NOW
              CALL LUNSETMAXIM(LUN,IMGNUM,IRTFLGT)
              CALL LUNSETMAXALL(LUN,IMGNUM,IRTFLGT)
           ENDIF

           IF (ISTACK < 0) THEN
C             NEW INDEXED STACKED FILE, UPDATE INDX LOCATION
              CALL LUNWRTINDX(LUN,IMGNUM,NX,IRTFLGT)
              IF (IRTFLGT .NE. 0) RETURN
           ENDIF

           IF (IMGNUM > MAXIM .OR. ISTACK < 0) THEN
C             SAVE OVERALL HEADER NOW TO PRESERVE MAXIM & LASTINDX
              CALL LUNWRTHED(LUN,NX,0,IRTFLGT)
           ENDIF

C          CREATE HEADER FOR NEW STACKED IMAGE,
C          KEEPS STATIC ISBARE SETTING, MAXIM, AND STKALL SETTING
           ISTACK = 0
           CALL LUNSETHDR(LUNT,LUN,NX,NY,NZ,
     &                    ITYPE,ISTACK,IRTFLGT)

C          SET IMGNUM FOR THIS CURRENT IMAGE
           CALL LUNSETINUSE(LUN,IMGNUM,IRTFLGT)

C          PLACE NEW STACKED IMAGE HEADER INTO PROPER STACK LOCATION
           CALL LUNWRTHED(LUN,NX,IMGNUM,IRTFLGT)

C          SET PROPER OFFSET INTO LUNSTK FOR IMGNUM
           CALL LUNSETIMGOFF(LUN,IMGNUM,NX,IRTFLGT)

C          RETURNS NSTACK = -1 TO SIGNIFY THIS IS STACKED IMAGE
           NSTACK  = -1


C -------------------------------- OLD --------------------------------
           
	ELSEIF (DISP(1:1) == 'O' .OR. DISP(1:1) ==  'K' .OR.
     &          DISP(1:1) == 'Z' .OR. 
     &          DISP(1:1) == 'E' .OR. DISP(1:1) ==  'M') THEN
C          WANT AN EXISTING IMAGE FROM EXISTING STACK OR AN
C          EXISTING BARE STACK HEADER

           IF (.NOT. EX) THEN
C             STACK FILE DOES NOT EXIST YET, ERROR
              NLETE = lnblnkn(FILNOAT)
              WRITE(NOUT,*)'*** STACK FILE NOT FOUND: ',FILNOAT(:NLETE)
C	      FOR DISP=Z, DO NOT STOP THE BATCH JOB BY CALLING ERRT
              IF (DISP .NE. 'Z') CALL ERRT(100,'OPENSTK',NE)
              RETURN
           ENDIF

C          OPEN EXISTING OVERALL STACK FILE, RETURNS MAXIM IN NSTACK
	   CALL OPENFIL(0,FILNOAT,LUN, NX,NY,NZ,NSTACK,
     &                  ITYPE,'O',.FALSE.,IRTFLGT)
           IF (IRTFLGT .NE. 0)  RETURN

           IF (NSTACK <= -2) THEN
C             EXISTING FILE IS NOT A STACK FILE
              CALL ERRT(101,'EXISTING FILE IS NOT A STACK',NE)
              RETURN

           ELSEIF (IMGNUM <= 0) THEN
C             JUST WANT BARE STACK, RETURN NSTACK = MAX IMAGE IN STACK 
              IRTFLG = 0
              RETURN

           ELSEIF (IMGNUM > NSTACK) THEN
C             STOP IF REQUESTED IMAGE NOT IN STACK 
              IF (DISP .NE. 'Z') THEN
                 CALL ERRT(102,'THIS IMAGE NOT USED IN STACK',IMGNUM)
              ENDIF
              RETURN
           ENDIF

C          SET OFFSET INTO LUNSTK FOR THIS STACKED IMAGE

           CALL LUNSETIMGOFF(LUN,IMGNUM,NX,IRTFLGT)
           IF (IRTFLGT .NE. 0) RETURN

C          GET SPECIFIED IMAGE HEADER FROM STACK FILE LOCATION
           CALL LUNREDHED(LUN,NX,IMGNUM,CALLERRTRED,IRTFLGT)
           IF (IRTFLGT .NE. 0) RETURN

C          RECOVER IMAGE PARAMETERS FROM SPECIFIC IMAGE HEADER

C          GET IMUSED FOR THIS CURRENT IMAGE
           CALL LUNGETINUSE(LUN,IMUSED,IRTFLGT)


           !write(6,*) '  in openstk, imgnum,imused:',imgnum,imused

           IF (IMUSED .NE. IMGNUM) THEN
C             NO EXISTING IMAGE WITHIN STACK??

              IF (IMUSED == 0) THEN
C                SOME VERY OLD STACKS DID NOT HAVE IMGNUM IN THEM
                 CALL LUNGET25(LUN,IVAL,IRTFLGT)

                 IF (IVAL .NE. 1) THEN
C                   STACK MAY LACK IMAGE OR HAS BAD EM2EM HEADER

C                   GET RECORD INFO (CAN BE FROM OVERALL HEADER)
                    CALL LUNGETLAB(LUN,NDUM1,NDUM2,NRECS,
     &                                 NDUM3,NDUM4,IRTFLGT)

                    !write(6,*) '  imgnum,nrecs:',imgnum,nrecs,disp

                    IF (IMGNUM > 0 .AND. NRECS <= 0 .AND.
     &                   DISP == 'Z') THEN
C                      MAY BE BAD IREC IN STACKS CREATED WITH EM2EM!
c                      WRITE(NOUT,'(/,A,A)')
c    &                 ' *** IF IMAGE FROM EM2EM',
c    &                 ' USE OPERATION: <ST EM2> TO FIX HEADER.'

                       CALL LUNSETINUSE(LUN,IMGNUM,IRTFLGT)
                       IRTFLG = 5 
                       RETURN

                    ELSEIF (DISP == 'Z') THEN
C                      DO NOT STOP ON ERROR
                       WRITE(NOUT,'(A,I0)') ' *** MISSING IMAGE',IMGNUM
                       IRTFLG = 5 
                       RETURN

                    ELSE
                       CALL ERRT(102,'MISSING IMAGE',IMGNUM)
                       IRTFLG = 1
                       RETURN 
                   ENDIF
                   GOTO 999

                 ENDIF

                 IMUSED = IMGNUM
                 CALL LUNSETINUSE(LUN,IMUSED,IRTFLGT)
              ENDIF
           ENDIF

C          RETURN NSTACK = -1 (FOR STACKED IMAGE)
           NSTACK = -1

        ELSE
           CALL ERRT(101,'PGM. ERROR: UNKNOWN DISP IN OPENSTK',NE)
           RETURN
        ENDIF

C ------------------------------- BOTH --------------------------------

C       SET FLAG FOR NORMAL RETURN	
        IRTFLG = 0

999     CONTINUE
     
C       WRITE OUT FILE OPENING INFO
        CALL LUNSAYINFO(LUN,IRTFLGT)

C       SET COMMON BLOCK VARIABLES
        CALL LUNSETCOMMON(LUN,IRTFLGT)

C       SET FLAG FOR NORMAL RETURN	
        IRTFLG = 0

	END


@


1.96
log
@'FS' ON MISSING STACKED IMAGE bug,  ==
@
text
@d22 1
a22 1
C=* Email: spider@@wadsworth.org                                        *
@


1.95
log
@IF IMAGE COMES FROM EM2EM
@
text
@d4 11
a14 10
C OPENSTK.F -- CREATED                       DEC 96 -- ArDean Leith
C              USED LUNHDR                   FEB 99 -- ArDean Leith
C              INDEXED STACKS                JAN 03 -- ArDean Leith
C              HEADER COPY                   FEB 03 -- ArDean Leith
C              OPENFIL PARAMETERS            APR 04 -- ArDean Leith
C              BAD IRTFLG RETURN             AUG 04 -- ArDean Leith
C              ERROR MSG                     DEC 10 -- ArDean Leith
C              MPI ERROR MSG                 MAR 11 -- ArDean Leith
C              MSG                           FEB 12 -- ArDean Leith
C              'ST' MISSING STACKED IMAGE    AUG 14 -- ArDean Leith
d153 1
a153 1
             IF (NSTACKIN .LT. 0) THEN
d158 1
a158 1
                 IF (NSTACK .LT. 1) THEN
d173 1
a173 1
              IF (NSTACKIN .LT. 0) THEN
d227 1
a227 1
           IF (ISTACK .LT. 0) THEN
d233 1
a233 1
           IF (IMGNUM > MAXIM .OR. ISTACK .LT. 0) THEN
d259 3
a261 3
	ELSEIF (DISP(1:1)  ==  'O' .OR. DISP(1:1)  ==  'K' .OR.
     &          DISP(1:1)  ==  'Z' .OR. 
     &          DISP(1:1)  ==  'E' .OR. DISP(1:1)  ==  'M') THEN
d311 3
d316 1
d326 20
a345 1
     &                                NDUM3,NDUM4,IRTFLGT)
a346 16
                    IF (IMGNUM > 0 .AND. NRECS <= 0) THEN
C                      BAD IREC IN STACKS CREATED WITH EM2EM!
                          WRITE(NOUT,'(/,A,/,A,A)')
     &           ' *** IMAGE HAS NONSENSE IN HEADER OR DOES NOT EXIST',
     &                 ' *** IF IMAGE COMES FROM EM2EM',
     &                 ' USE OPERATION: <ST EM2> TO FIX HEADER.'

                       IF (DISP == 'Z') THEN
                          IRTFLG = 5 
                          CALL LUNSETINUSE(LUN,IMGNUM,IRTFLGT)

                       ELSE
                          IRTFLG = 1 
                          CALL ERRT(102,'BAD HEADER IN STACKED IMAGE',
     &                             IMGNUM)
                       ENDIF
d348 1
a348 2
C                      STACK LACKS IMAGE
                       CALL ERRT(102,'STACK LACKS IMAGE',IMGNUM)
d350 1
d353 1
@


1.94
log
@bad stack handling
@
text
@d19 1
a19 1
C=* Copyright 1985-2014  Health Research Inc.,                         *
d324 5
a328 5
C                      BAD IREC IN STACKS CREATED WITH EM2EM!)
                          WRITE(NOUT,'(/,A,A,/,A,A)')
     &                 ' *** IMAGE (PROBABLY FROM EM2EM) HAS NONSENSE',
     &                      ' IN SOME HEADER LOCATIONS.',
     &                 ' *** USE OPERATION: <ST EM2> TO FIX HEADER.'
@


1.93
log
@FOR USE WITH 'ST H' SETTING, disp==z altered
@
text
@d312 1
a312 1
              IF (IMUSED  ==  0) THEN
d317 1
a317 1
C                   STACK LACKS IMAGE
d319 20
a338 5
                    IF (DISP == 'Z') THEN
C                      FOR USE WITH 'ST H' SETTING
                       WRITE(NOUT,'(A,I0)')
     &                       ' STACK LACKS IMAGE:',IMGNUM
                       IRTFLG = 5  
d340 1
d343 2
a344 2
                     ENDIF
                    GOTO 999
@


1.92
log
@cosmetic
@
text
@d4 11
a14 9
C OPENSTK.F   -- CREATED                  DEC. 96   -- ArDean Leith
C                USED LUNHDR              FEB. 99   -- ArDean Leith
C                INDEXED STACKS           JAN. 03   -- ArDean Leith
C                HEADER COPY              FEB. 03   -- ArDean Leith
C                OPENFIL PARAMETERS       APR. 04   -- ArDean Leith
C                BAD IRTFLG RETURN        AUG. 04   -- ArDean Leith
C                ERROR MSG                DEC. 10   -- ArDean Leith
C                MPI ERROR MSG            MAR. 11   -- ArDean Leith
C                MSG                      FEB. 12   -- ArDean Leith
d19 1
a19 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d64 1
a64 1
C  CALL TREE:  SEE OPFIL
d104 1
a104 1
           IF (IMGNUM .LE. 0) THEN
d145 1
a145 1
	IF (DISP(1:1)  ==  'U' .OR. DISP(1:1)  ==  'N') THEN
d177 1
a177 1
              IF (IMGNUM .LE. 0) THEN
d194 1
a194 1
              IF (NSTACK .LE. -2) THEN
d220 1
a220 1
           IF (IMGNUM .GT. MAXIM) THEN
d232 1
a232 1
           IF (IMGNUM .GT. MAXIM .OR. ISTACK .LT. 0) THEN
d278 1
a278 1
           IF (NSTACK .LE. -2) THEN
d283 1
a283 1
           ELSEIF (IMGNUM .LE. 0) THEN
d288 1
a288 1
           ELSEIF (IMGNUM .GT. NSTACK) THEN
d297 1
d309 1
d315 1
d317 8
a324 1
                    IF (DISP .NE. 'Z') THEN
d326 3
a328 2
                    ENDIF
                    RETURN
d330 1
d346 5
a359 1
        RETURN
@


1.91
log
@error msg
@
text
@d4 3
a6 3
C OPENSTK.F   -- CREATED                  DEC. 96   --  ArDean Leith
C                USED LUNHDR              FEB. 99   --  ArDean Leith 
C                INDEXED STACKS           JAN. 03   --  ArDean Leith
d46 1
a46 1
C        ITYPE      IFORM                                    (SENT/RET.)                    
@


1.90
log
@IMAGE DIMENSIONS NOT SAME AS STACK msg
@
text
@d103 3
a105 1
              CALL ERRT(101,'STACKS START WITH IMAGE: 1',NE)
@


1.89
log
@comm mpi, need mpif.h
@
text
@d12 1
d17 1
a17 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d35 1
a35 1
C  OPENSTK(LUNT,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,ITYPE,DISP,IRTFLG)
d44 2
a45 2
C        NSAM,NROW  DIMENSIONS OF FILE                       (SENT/RET.)
C        NSLICE     NUMBER OF PLANES                         (SENT/RET.)
d67 1
a67 1
        SUBROUTINE OPENSTK(LUNT,FILNAM,LUN,NSAM,NROW,NSLICE,
d73 8
a80 3
        CHARACTER (LEN=*) ::      FILNAM,DISP
        CHARACTER (LEN=MAXNAM) :: FILNOAT,FILNPE
	LOGICAL ::                EX,ISDIGI,CALLERRTRED,INDXD
d141 1
a141 1
	IF (DISP(1:1) .EQ. 'U' .OR. DISP(1:1) .EQ. 'N') THEN
d145 1
a145 1
           IF (.NOT. EX .OR. IMGNUM .EQ. 0) THEN
d164 1
a164 1
	      CALL OPENFIL(0,FILNOAT,LUN, NSAM,NROW,NSLICE,NSTACK,
d170 1
a170 1
                  CALL LUNCLRINDX(LUN,NSAM,IRTFLGT)
d182 1
a182 1
	      CALL OPENFIL(0,FILNOAT,LUN, NSAMF,NROWF,NSLICEF,NSTACK,
d195 2
a196 2
              ELSEIF (NSAMF   .NE. NSAM .OR. NROWF .NE. NROW .OR.
     &                NSLICEF .NE. NSLICE) THEN
d198 4
a201 1
                 CALL ERRT(101,'IMAGE DIMENSIONS NOT SAME AS STACK',NE)
d224 1
a224 1
              CALL LUNWRTINDX(LUN,IMGNUM,NSAM,IRTFLGT)
d230 1
a230 1
              CALL LUNWRTHED(LUN,NSAM,0,IRTFLGT)
d236 1
a236 1
           CALL LUNSETHDR(LUNT,LUN,NSAM,NROW,NSLICE,
d243 1
a243 1
           CALL LUNWRTHED(LUN,NSAM,IMGNUM,IRTFLGT)
d246 1
a246 1
           CALL LUNSETIMGOFF(LUN,IMGNUM,NSAM,IRTFLGT)
d254 3
a256 3
	ELSEIF (DISP(1:1) .EQ. 'O' .OR. DISP(1:1) .EQ. 'K' .OR.
     &          DISP(1:1) .EQ. 'Z' .OR. 
     &          DISP(1:1) .EQ. 'E' .OR. DISP(1:1) .EQ. 'M') THEN
d270 1
a270 1
	   CALL OPENFIL(0,FILNOAT,LUN, NSAM,NROW,NSLICE,NSTACK,
d293 1
a293 1
           CALL LUNSETIMGOFF(LUN,IMGNUM,NSAM,IRTFLGT)
d297 1
a297 1
           CALL LUNREDHED(LUN,NSAM,IMGNUM,CALLERRTRED,IRTFLGT)
d306 1
a306 1
              IF (IMUSED .EQ. 0) THEN
@


1.88
log
@SET_MPI, STACK FILE NOT FOUND msg improved
@
text
@d11 1
d16 1
a16 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d76 4
d115 1
a115 1
        CALL MPI_BCAST(IER,1,MPI_INTEGER,0,COMM,MPIERR)
d117 1
a117 1
           WRITE(0,*) ' OPENFIL: FAILED TO BCAST IER'
d120 2
a121 1
        CALL MPI_BCAST(EX,1,MPI_LOGICAL,0,COMM,MPIERR)
d123 1
a123 1
           WRITE(0,*) ' OPENFIL: FAILED TO BCAST EX'
@


1.87
log
@GPL_2010
@
text
@d4 3
a6 3
C OPENSTK.F   -- CREATED                  DEC. 96 --  ArDean Leith
C                USED LUNHDR              FEB. 99 --  ArDean Leith 
C                INDEXED STACKS           JAN. 03 --  ArDean Leith
d10 1
a10 1
C
d74 2
a75 9
#ifdef USE_MPI
        include 'mpif.h' 
        INTEGER MYPID, COMM, MPIERR
        COMM   = MPI_COMM_WORLD 
        MPIERR = 0  
        CALL MPI_COMM_RANK(COMM, MYPID, MPIERR)
#else 
        MYPID = -1    
#endif    
d247 2
a248 1
              WRITE(NOUT,*) '*** STACK FILE NOT FOUND: ',FILNOAT
@


1.86
log
@GPL License fixed
@
text
@a11 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d13 5
a17 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d19 1
a19 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d24 1
a24 1
C=* This program is distributed in the hope that it will be useful,    *
d26 1
a26 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a27 1
C=*                                                                    *
d29 1
a29 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.85
log
@HRI GPL License used
@
text
@a11 1
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
d15 1
a15 1
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *  
a34 6

C * COPYRIGHT (C)1985, 2002. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.84
log
@mpi
@
text
@d13 24
@


1.83
log
@bad irtflg returned if no such image
@
text
@d61 9
d102 1
d104 13
a281 1

@


1.82
log
@IRTFLG input removed
@
text
@d9 1
d20 1
a20 1
C  OPENSTK(LUNT,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,ITYPE,DISP,IRTFLG
d175 1
a175 1
              CALL LUNSETMAXALL(LUN,IMGNUM,IRTFLG)
d264 1
a264 1
                 CALL LUNGET25(LUN,IVAL,IRTFLG)
a285 3
C       SET FLAG FOR NORMAL RETURN	
        IRTFLG = 0

d291 3
@


1.81
log
@endedness
@
text
@d8 1
d43 1
a43 1
C        IRTFLG     ERROR RETURN FLAG.                       (SENT/RET.)
d123 1
a123 1
     &                     ITYPE,DISP,IRTFLG)
d141 1
a141 1
     &                     ITYPE,'O',IRTFLGT)
d225 1
a225 1
     &                  ITYPE,'O',IRTFLGT)
@


1.80
log
@openfil needed lunt
@
text
@d39 2
d116 1
a116 1
C                 REBULAR NEW STACK
d122 2
a123 2
     &                     ITYPE,DISP,IRTFLGT)
              IF (IRTFLGT .NE. 0) RETURN
@


1.79
log
@opfilec
@
text
@d119 1
a119 1
	      CALL OPENFIL(FILNOAT,LUN, NSAM,NROW,NSLICE,NSTACK,
d137 1
a137 1
	      CALL OPENFIL(FILNOAT,LUN, NSAMF,NROWF,NSLICEF,NSTACK,
d221 1
a221 1
	   CALL OPENFIL(FILNOAT,LUN, NSAM,NROW,NSLICE,NSTACK,
@


1.78
log
@stack bug
@
text
@d7 1
d18 1
a18 1
C  OPENSTK(FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,ITYPE,DISP,IRTFLG
d24 1
d48 1
a48 1
        SUBROUTINE OPENSTK(FILNAM,LUN,NSAM,NROW,NSLICE,
d188 2
a189 1
           CALL LUNSETHDR(LUN,NSAM,NROW,NSLICE,ITYPE,ISTACK,IRTFLGT)
@


1.77
log
@indexed stacks
@
text
@d111 3
d264 2
@


1.76
log
@error msg. improved
@
text
@d6 2
a7 1
c
d9 6
a14 6
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK      *
C *  COPYRIGHT (C)1985, 1996 HEALTH RESEARCH INCORPORATED, ALBANY, NY. *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HEALTH            *
C * RESEARCH INC. AND ARE NOT TO BE DISCLOSED TO OTHERS OR USED        *
C * FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF       *
C * HEALTH RESEARCH INC.                                               *
d17 1
a17 1
C  OPENSTK(FILNAM,LUN,NSAM,NROW,NSLICE,NIMAG,NSTACK,ITYPE,DISP,IRTFLG
a26 1
C        NIMAGE     NUMBER OF IMAGES ALLOWED IN NEW STACK         (SENT)
d28 9
a36 5
C        NSTACK     STACK INDICATOR                               (RET.)
C                   -2 IS NOT STACK
C                   -1 STACKED IMAGE
C                    0 BARE STACK, CONTAINS NO IMAGE(S)
C                   >0 BARE STACK, VALUE IS MAX. IMAGE
d46 1
a46 1
        SUBROUTINE OPENSTK(FILNAM,LUN,NSAM,NROW,NSLICE,NIMAG,
d50 1
a50 5

        CHARACTER *(*)   FILNAM,DISP
        CHARACTER * 81   FILNOAT,FILNPE
        CHARACTER * 1    NULL,DISPF
	LOGICAL          EX,CALLERRT,ISDIGI,CALLERRTRED
d52 3
a54 1
        NULL = CHAR(0)
a55 3
C       ALLOW IT TO OPEN MALFORMED STACK IN COPY COMMAND ONLY
        CALLERRT = (IRTFLG .EQ. 88)

d60 2
a61 1
        IRTFLG = 1
d100 14
a113 2
C             CREATE A NEW STACK FILE, OPENFIL WILL RETURN NSTACK = 0
              NSTACK = 0
d115 1
a115 1
     &                     ITYPE,IMUSED,DISP,IRTFLGT)
d118 11
d130 1
a130 1
C             OPEN ALREADY EXISTING STACK FILE
a131 2
              DISPF   = 'O'
              NSTACK  = 0
d133 1
a133 1
     &                     ITYPE,IMUSED,DISPF,IRTFLGT)
a155 6

              ELSEIF (IMUSED .NE. -1) THEN
C                 THIS IS AN OLDER STACK IT MAY BE MALFORMED. ERROR
C                 IF TRYING TO CREATE NEW IMAGE IN A MALFORMED STACK
                  CALL CHECKSTACK(LUN,NSAM,.TRUE.,IRTFLGT)
                  IF (IRTFLGT .NE. 0) RETURN
d159 3
a161 3
           IF (IMGNUM .LE. 0) THEN
C             JUST WANT TO OPEN NEW BARE STACK, OPENFIL HAS ALREADY
C             RECOVERED RELEVANT HEADER VALUES
d163 5
a167 2
C             RETURN NSTACK =  0 FOR BARE STACK CONTAINING NO IMAGE(S)
              NSTACK  = 0
d169 4
a172 4
C             NORMAL RETURN
              IRTFLG  = 0
              RETURN
             
d175 3
a177 9
C          RECOVER MAXIM FROM OVERALL HEADER 
           CALL LUNGETMAXIM(LUN,MAXIM,IRTFLGT)
           IF (IRTFLGT .NE. 0) RETURN

           IF (IMGNUM .GT. MAXIM) THEN
C            UPDATE OVERALL HEADER WITH MAXIMUM IMAGE NUMBER IN USE
             CALL LUNSETMAXIM(LUN,IMGNUM,IRTFLGT)
             CALL LUNWRTHED(LUN,0,IRTFLGT)
             MAXIM = IMGNUM
d180 4
a183 6
C          CREATE HEADER FOR NEW STACKED IMAGE (ISTACK = 2)
C          KEEPS ISBARE SETTING
           CALL LUNSETHDR(LUN,NSAM,NROW,NSLICE,ITYPE,2,IRTFLGT)

C          SET INUSE FLAG FOR STACKED IMAGE HEADER
           CALL LUNSETINUSE(LUN,1,IRTFLGT)
d185 2
a186 2
C          PLACE NEW IMAGE HEADER INTO PROPER STACK LOCATION
           CALL LUNWRTHED(LUN,IMGNUM,IRTFLGT)
d188 2
a189 2
C          SET OFFSET INTO LUNSTK
           CALL LUNSETOFFSET(LUN,IRTFLGT)
d191 2
a192 2
C          UPDATE IMAGE HEADER WITH MAXIMUM IMAGE NUMBER IN USE
           CALL LUNSETMAXIM(LUN,MAXIM,IRTFLGT)
d203 2
a204 1
C          WANT AN EXISTING IMAGE FROM AN EXISTING STACK
d214 1
a214 2
C          OPEN THE EXISTING OVERALL STACK FILE
           DISPF  = 'O'
d216 1
a216 1
     &                  ITYPE,INUSE,DISPF,IRTFLGT)
a223 6
           ELSEIF (INUSE .NE. -1) THEN
C             STOP IF MALFORMED STACK (EXCEPT IF IRTFLGT = 88) 
              CALL CHECKSTACK(LUN,NSAM,CALLERRT,IRTFLGT)
C             MALFORMED STACK FOR "CP FIX" USE ONLY
              IF (IRTFLGT .EQ. 88) RETURN

d230 1
a230 1
C             STOP IF REQUESTED IMAGE > MAXIM 
d237 3
a239 5
C          RECOVER MAXIM FROM OVERALL HEADER
           CALL LUNGETMAXIM(LUN,MAXIM,IRTFLGT)

C          SET IMGNUM FOR CURRENT IMAGE
           CALL LUNSETIMGNUM(LUN,IMGNUM,IRTFLGT)
a240 3
C          SET OFFSET INTO LUNSTK
           CALL LUNSETOFFSET(LUN,IRTFLGT)

d242 1
a242 1
           CALL LUNIMGREDHED(LUN,NSAM,CALLERRTRED,IMGNUM,IRTFLGT)
d246 2
d250 11
a260 4
           IF (IMUSED .EQ. 0) THEN
C             NO EXISTING IMAGE WITHIN STACK
              IF (DISP .NE. 'Z') THEN
                 CALL ERRT(102,'EMPTY STACK, NO IMAGE',IMGNUM)
a261 1
              RETURN
a263 3
C          COPY MAXIM FROM OVERALL HEADER INTO CURRENT HEADER OBJECT
           CALL LUNSETMAXIM(LUN,MAXIM,IRTFLGT)

a286 49
C       ------------------- CHECKSTACK --------------------------------

        SUBROUTINE CHECKSTACK(LUN,NSAM,CALLERRT,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        COMMON /LUNARA/ LUNARA(100),LUNSTK(100),LUNARB(100)

        COMMON /IOBUF/ BUFCHK(NBUFSIZ)

        LOGICAL    CALLERRT

C       POINT LUNSTK TO RECORD FOLLOWING OVERALL HEADER
        LUNSTKT     = LUNSTK(LUN)
        LUNSTK(LUN) = LUNARA(LUN)
        NBUFSIZT    = NBUFSIZ

C       READ NEXT  RECORD AFTER OVERALL HEADER. IF THIS IS NOT A HEADER
C       THEN THIS IS A MALFORMED STACK

        CALL REDHED(LUN,BUFCHK,NBUFSIZT,NSAM,0,IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

C       CHECK NSLICE, NROW, NSAM, LABREC, LABBYT
        CALL  LUNGETSIZE(LUN,NSAM,NROW,NSLICE,ISTACK,IRTFLG)

C       GET RECORD INFO
        CALL LUNGETLAB(LUN,LABREC,NRECS,LABBYT,LENBYT,IRTFLG)

        IF (NSLICE  .NE. BUFCHK(1)  .OR. NROW  .NE. BUFCHK(2) .OR.  
     &      NSAM    .NE. BUFCHK(12) .OR.   
     &      LABBYT .NE. BUFCHK(22)) THEN
            IF (CALLERRT) THEN
               WRITE(NOUT,*) '*** ERROR: STACK NEEDS REFORMING'
               CALL ERRT(101,'USE  -CP FIX-  TO REFORM STACK',NE)
            ELSE
               WRITE(NOUT,*) '*** WARNING: STACK NEEDS REFORMING'
            ENDIF
            IRTFLG = 88
        ENDIF

C       RESTORE LUNSTK VALUE
        LUNSTK(LUN) = LUNSTKT

        IRTFLG = 0

        RETURN
        END
@


1.75
log
@getfilenum parameter added
@
text
@d228 1
a228 1
                 CALL ERRT(101,'THIS IMAGE NOT USED IN STACK',NE)
d252 1
a252 1
                 CALL ERRT(101,'THIS IMAGE NOT USED IN STACK',NE)
@


1.74
log
@added lunarb to common /lunara/
@
text
@d67 1
a67 1
           CALL GETFILENUM(FILNAM(ILOCAT:),IMGNUM,.TRUE.,IER)
@


1.73
log
@cosmetic.
@
text
@d290 1
a290 1
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
@


1.72
log
@CMLIMIT.INC
@
text
@d33 1
a33 1
C        DISP       FILE DISPOSITION, SEE OPENFB FOR VALUES       (SENT)
@


1.71
log
@maxim now set in all headers
@
text
@a51 2
        DATA NBUFSIZ/17000/

d288 1
d292 1
a292 2
        PARAMETER      (NBUFSIZT = 17008)
        COMMON /IOBUF/ BUFCHK(NBUFSIZT)
d299 1
a299 1
        NBUFSIZ     = NBUFSIZT
d304 1
a304 1
        CALL REDHED(LUN,BUFCHK,NBUFSIZ,NSAM,0,IRTFLG)
@


1.70
log
@irtflgt used , lablock removed
@
text
@d160 2
a161 2
           CALL LUNGETMAXIM(LUN,MAXIM,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d165 3
a167 2
             CALL LUNSETMAXIM(LUN,IMGNUM,IRTFLG)
             CALL LUNWRTHED(LUN,0,IRTFLG)
d172 1
a172 1
           CALL LUNSETHDR(LUN,NSAM,NROW,NSLICE,ITYPE,2,IRTFLG)
d175 1
a175 1
           CALL LUNSETINUSE(LUN,1,IRTFLG)
d178 1
a178 1
           CALL LUNWRTHED(LUN,IMGNUM,IRTFLG)
d181 4
a184 1
           CALL LUNSETOFFSET(LUN,IRTFLG)
d217 2
a218 2
C             STOP IF MALFORMED STACK (EXCEPT IF IRTFLG = 88) 
              CALL CHECKSTACK(LUN,NSAM,CALLERRT,IRTFLG)
d220 1
a220 1
              IF (IRTFLG .EQ. 88) RETURN
d235 3
d258 3
@


1.69
log
@nout undefined
@
text
@a45 2
        INCLUDE 'LABLOCK.INC'
CNO_SAVE
d85 2
a86 2
        CALL FILNAMANDEXT(FILNOAT,DATEXC,FILNPE,NLET,.TRUE.,IRTFLG)
	IF (IRTFLG .NE.0) RETURN
d141 2
a142 2
                  CALL CHECKSTACK(LUN,NSAM,.TRUE.,IRTFLG)
                  IF (IRTFLG .NE. 0) RETURN
d222 7
d232 1
a232 1
           CALL LUNSETIMGNUM(LUN,IMGNUM,IRTFLG)
d235 1
a235 1
           CALL LUNSETOFFSET(LUN,IRTFLG)
d238 2
a239 2
           CALL LUNIMGREDHED(LUN,NSAM,CALLERRTRED,IMGNUM,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d242 1
a242 1
           CALL LUNGETINUSE(LUN,IMUSED,IRTFLG)
@


1.68
log
@imgredhed needed
@
text
@d274 2
@


1.67
log
@needed lunsetcommon
@
text
@d226 3
@


1.66
log
@lunsethdr used
@
text
@d258 4
a261 1
        CALL LUNSAYINFO(LUN,IRTFLG)
@


1.65
log
@added paremeter to opengethdr call
@
text
@d4 3
a6 2
C OPENSTK.F   -- DEC. 96 al
C
d8 6
a13 7
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK        *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND     *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.  *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS *
C *    OR USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN        *
C *    APPROVAL OF THE CENTER FOR LABORATORIES AND RESEARCH            *
d16 1
a16 1
C  OPENSTK(BUF,FILNAM,LUN,NSAM,NROW,NSLICE,NIMAG,ITYPE,DISP,IRTFLG
d18 2
a19 1
C  PURPOSE:       TO OPEN A NEW OR EXISTING STACK FILE.
a21 1
C        BUF        WORKING BUFFER FOR READ/WRITE                 (SENT)
d28 5
d35 1
a35 9
C                   NF = 0    NORMAL RETURN
C
C  COMMON VARIABLES
C        NSTACK     FILE STACK SPECIFIER.                    (SENT/RET.)
C                     -2          NOT A STACK
C                     -1          STACKED IMAGE
C                      0          BARE STACK, CONTAINS NO IMAGE(S)
C                     >0          BARE STACK, VALUE IS MAX. IMAGE
C
d37 1
a37 1
C  CALL TREE:  SEE OPENFB
d42 2
a43 2
        SUBROUTINE OPENSTK(BUF,FILNAM,LUN,NSAM,NROW,NSLICE,NIMAG,
     &               ITYPE,DISP,IRTFLG)
a48 5
        COMMON /LUNARA/  LUNARA(100),LUNSTK(100)

        COMMON /STACKCOM/NSTACK

        DIMENSION        BUF(*)
d50 3
a52 3
        CHARACTER * 81   FILN,FILNPE,FILDUM
        CHARACTER * 1    NULL,DISPF,DSP
	LOGICAL          EX,ISERROR,ISDIGI
d59 1
a59 2
        ISERROR = .TRUE.
        IF (NF .EQ. 88) ISERROR = .FALSE.
d62 1
a62 2
        NOSTOP = 0
        IF (DISP .EQ. 'Z') NOSTOP = 1
d67 1
a67 2
C       MAKE SURE THE STACK OFFSET IS ALWAYS ZEROED
        LUNSTK(LUN) = 0
d69 4
a72 1
        ILOC        = INDEX(FILNAM,'@@')      
d74 1
a74 10
        IF (ISDIGI(FILNAM(ILOC + 1:ILOC + 1))) THEN
C          FIND IMAGE NUMBER WITHIN STACK FILE 
C          READ(FILNAM(ILOC+1:),*,IOSTAT=IER) IMGNUM -adjusted for osf-liy
           CALL FILCAD(FILNAM(ILOC:),FILDUM,IMGNUM,IER)
        
           IF (IER .NE. 0) THEN
C             ERROR CONVERTING STACK NUMBER
              CALL ERRT(101,'UNABLE TO INTERPRET IMAGE NUMBER',NE)
              RETURN
           ELSEIF (IMGNUM .EQ. 0) THEN
d83 2
a84 2
C       GET FILENAME WITHOUT DATEXC
        FILN = FILNAM(1:ILOC-1) // CHAR(0) 
d87 2
a88 5
        CALL FILCAN(FILNPE,NLET,NULL,NULL,FILN,DATEXC,IER)
	IF (IER .NE.0) THEN
            CALL ERRT(101,'ADDING EXTENSION TO FILENAME',NE)
            RETURN
        ENDIF
d93 2
a94 1
           CALL ERRT(101,'FILE INQUIRY FAILED',NE)
d97 1
a97 1

d106 3
a108 4
              IFORM  = ITYPE
	      CALL OPENFIL(BUF,FILN,LUN,
     &                     NSAM,NROW,NSLICE,NSTACK,IMUSED,DISP,NFT)
              IF (NFT .NE. 2) RETURN
d115 3
a117 4
	      CALL OPENFIL(BUF,FILN,LUN,
     &                  NSAMF,NROWF,NSLICEF,NSTACK,IMUSED,DISPF,NFT)
              IF (NFT .NE. 2)  RETURN
              ITYPE = IFORM
d143 1
a143 1
                  CALL CHECKSTACK(LUN,NSAM,BUF,.TRUE.,IRTFLG)
d151 5
a156 1
              NSTACK  = 0
d158 1
d161 2
a162 2
C          RECOVER OVERALL HEADER FROM THE STACK FILE
           CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,0,IRTFLG)
d165 4
a168 4
           IF (IMGNUM .GT. BUF(26)) THEN
C             UPDATE OVERALL HEADER WITH MAXIMUM IMAGE NUMBER
              BUF(26) = IMGNUM
              CALL WRTHED(LUN,BUF,NSAM,IRTFLG)
d171 6
a176 8
C          SET IMAGE SPECIFIC LOCATIONS IN IMAGE HEADER  
           IMAMI   = 0
           BUF(6)  = IMAMI
           IANGLE  = 0
           BUF(14) = IANGLE
           KANGLE  = 0
           BUF(30) = KANGLE
           LABBYT  = BUF(22)
d178 2
a179 14
C          THIS IS A STACK AND IMAGE IS IN USE
C          RETURNS NSTACK = -1
           NSTACK  = -1
           BUF(24) = 2        
           IMUSED  = 1
           BUF(25) = IMUSED         
           BUF(26) = 0         

C          PUT CURRENT DATE AND TIME INTO BUF
           CALL DATTIMTIT(BUF,.FALSE.,.TRUE.,LENTIT,IRTFLG)

C          ALL IMAGES MUST HAVE SAME IREC AS STACK HEADER.
C          GET IRECF FROM STACK FILE HEADER
           IRECF       = BUF(3)
d182 1
a182 1
           LUNSTK(LUN) = (IMGNUM-1) * IRECF + BUF(13)
d184 2
a185 2
C          PLACE THIS IMAGE HEADER INTO PROPER STACK LOCATION
           CALL WRTHED(LUN,BUF,NSAM,IRTFLG)
a186 1
           DSP = 'N'
d197 1
a197 2
              WRITE(NOUT,*) '*** STACK FILE NOT FOUND: ',FILN

d199 1
a199 3
              IF (DISP .EQ. 'Z' .AND. 
     &            (IPROC .NE. 0 .OR. COPT  .EQ. 'B')) RETURN
              CALL ERRT(100,'OPENFB',NE)
d205 4
a208 3
	   CALL OPENFIL(BUF,FILN,LUN,
     &                  NSAM,NROW,NSLICE,NSTACK,IMUSED,DISPF,NFT)
           IF (NFT .NE. 2)  RETURN
d210 1
a210 1
C             EXISTING FILE IS NOT A STACK
a212 6
           ENDIF
           ITYPE = IFORM

C          RECOVER OVERALL HEADER FROM THE STACK FILE
           CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,NOSTOP,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d214 1
a214 1
           IF (BUF(25) .NE. -1) THEN
d216 3
a218 8
              CALL CHECKSTACK(LUN,NSAM,BUF,ISERROR,IRTFLG)
              IF (IRTFLG .EQ. 88 .AND. ISERROR) RETURN
              IF (IRTFLG .EQ. 88) THEN
C                MALFORMED STACK FOR "CP FIX" USE ONLY
                 IRTFLG = 88
                 RETURN
              ENDIF
           ENDIF
d220 1
a220 1
           IF (IMGNUM .LE. 0) THEN
a221 2
C             (FROM OVERALL HEADER LOC: 26)
              NSTACK = BUF(26)
a225 3
C          ALL IMAGES HAVE SAME IREC AS HEADER VALUE
           IREC = BUF(3)

d227 1
a227 1
           LUNSTK(LUN) = (IMGNUM-1) * IREC + BUF(13)
d230 1
a230 1
           CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,NOSTOP,IRTFLG)
d234 1
a234 2
           CALL OPENGETHDR(BUF,NDUM,NDUM,NDUM,NDUM,NDUM,
     &                     NDUM,NDUM,NDUM,LABBYT,IMUSED,LENTIT)
a245 1
           DSP = 'O'
d248 1
a248 1
           CALL ERRT(101,'PGM. ERROR: UNKNOWN DISP IN OPENFB',NE)
d258 1
a258 3
        NLET = 0
        CALL OPENINFO(FILNAM,NLET,NSAM,NROW,NSLICE,IMGNUM,NSTACK,
     &                LENTIT,DSP,LABBYT,IRTFLG)
d266 1
a266 1
        SUBROUTINE CHECKSTACK(LUN,NSAM,BUF,ISERROR,IRTFLG)
d270 4
a273 4
        PARAMETER  (NBUFSIZT = 17000)
        DIMENSION  BUF(NBUFSIZT)
        DIMENSION  BUFCHK(NBUFSIZT)
        LOGICAL    ISERROR
d282 1
d286 5
a290 1
        IRTFLG = 0
d292 4
a295 5
C       CHECK NSLICE, NROW, NSAM, LABREC, LABBYT
        IF (BUF(1)  .NE. BUFCHK(1)  .OR. BUF(2)  .NE. BUFCHK(2) .OR.  
     &      BUF(12) .NE. BUFCHK(12) .OR. BUF(13) .NE. BUFCHK(13) .OR.  
     &      BUF(22) .NE. BUFCHK(22)) THEN
            IF (ISERROR) THEN
d306 2
@


1.64
log
@change READ for osf
@
text
@d284 1
a284 1
     &                     NDUM,NDUM,LABBYT,IMUSED,LENTIT)
@


1.63
log
@used opengethdr
@
text
@d58 1
a58 1
        CHARACTER * 81   FILN,FILNPE
d84 2
a85 1
           READ(FILNAM(ILOC+1:),*,IOSTAT=IER) IMGNUM
@


1.62
log
@split out from openfb.f
@
text
@d193 1
a193 1
           LENBYT  = BUF(23)
d271 2
a272 2
C          ALL IMAGES HAVE SAME IREC & LENBYT AS HEADER
           IREC   = BUF(3)
d282 2
a283 2
           CALL OPENGETHDR(BUF,NDUM,NDUM,NDUM,NDUM,
     &                     NDUM,LENBYT,IMUSED,LENTIT)
d310 1
a310 1
     &                LENTIT,DSP,LENBYT,IRTFLG)
@


1.61
log
@for nstack retrieval of max img. number
@
text
@d4 1
a4 4
C OPENFB.FOR  -- ADAPTED FROM OPEN3.FOR OCT 88 al
C             -- LONG FILENAMES al
C             -- STACKS ADDED 96 al
C             -- REWRITTEN WITH OPENFIL 96 al
d16 1
a16 1
C    OPENFB(BUF,FILNAM,LUN,NSAM,NROW,DISP,NF,NSLICE)
d18 1
a18 2
C    PURPOSE:       TO OPEN A NEW OR  EXISTING DATA FILE FOR RANDOM 
C                   ACCESS READING/WRITING.
d20 1
a20 1
C    PARAMETERS:
d25 13
a37 2
C        DISP(1:1)  CHARACTER  CONTAINING ONE OF THE              (SENT) 
C                   FOLLOWING DISPOSITION SPECIFICATIONS:
a38 17
C                   'O'    -    FILE IS ASSUMED TO EXIST.  NSAM AND
C                               NROW AND HEADER INFO (IN COMMON) ARE 
C                               RETURNED TO THE CALLING PROGRAM. 
C                   'Z/E'  -    THE FILE IS ASSUMED TO EXIST; NSAM AND
C                               NROW AND HEADER INFO (IN COMMON) ARE 
C                               RETURNED TO THE CALLING PROGRAM.
C                               IF FILE DOES NOT EXIST THEN BATCH DOES
C                               NOT STOP!!! (ONLY DIFFERENCE FROM 'O'). 
C                   'N'    -    WANT NEW FILE. NSAM, NROW, NSLICE, AND
C                               IFORM ARE SENT.
C                   'U'    -    IT IS NOT KNOWN IF THE FILE EXISTS.  
C                               IF IT DOES NOT EXIST, NON-ZERO NSAM &
C                               NROW VALUES HAVE TO BE SENT; THE
C                               FILE IS CREATED WITH THESE DIMENSIONS.
C                               IF THE FILE ALREADY EXISTS, IT WILL BE 
C                               REPLACED.
C                   'K & M'-    NO LONGER USED.
d40 1
a40 1
C        DISP(2:2)  CHARACTER  POSSIBLY CONTAINING THE FOLLOWING VALUE:
a41 55
C                   'S'   -     SAVE FILE NAME IN LIST OF OPENED FILES
C                               ON CURRENT LUN. 
C
C        NF                     ERROR RETURN FLAG.           (SENT/RET.)
C                               NF = 2    NORMAL RETURN
C                               NF = 1    ERROR RETURN
C
C        NSLICE     NUMBER OF PLANES, EACH CONTAINING        (SENT/RET.)
C                               NSAM * NROW ELEMENTS. 
C
C    CODING:   BASED ON NEW OR OLD PICTURE PARAMETERS NSAM,NROW, A
C              NEW FILE IS OPENED WITH IREC RECORDS, EACH NSAM*4 
C              BYTES LONG.  IREC ALLOWS SPACE FOR THE 2-D OR 3-D 
C              IMAGE  PLUS HEADER.  A STACK FILE CONTAINS AN OVERALL
C              HEADER PLUS NSTACK * IREC RECORDS. EACH IMAGE IN THE
C              STACK HAS ITS OWN HEADER RECORDS WHOSE FORMAT IS THE
C              SAME AS THE OVERALL HEADER RECORDS
C
C    COMMONT VARIABLES:
C              IFORM (TYPE)  FILE TYPE SPECIFIER.           (SENT/RET.)
C                0    D     DATA FILE (UNUSED)
C               +1    R     2-D IMAGE FILE
C               +3    R3    3-D IMAGE (VOLUME) FILE
C               -9    FS    3-D SIMPLE FORMAT FOURIER (MR'S FORMAT)
C               -11   FO    2-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -12   FE    2-D FOURIER TRANSFORM, MIXED RADIX EVEN
C               -21   FE    3-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -22   FE    3-D FOURIER TRANSFORM, MIXED RADIX EVEN
C
C              NSTACK    FILE STACK SPECIFIER.              (SENT/RET.)
C               -2          NOT A STACK
C               -1          STACKED IMAGE
C                0          BARE STACK, CONTAINS NO IMAGE(S)
C               >0          BARE STACK, VALUE IS MAX. IMAGE
C
C     CALL TREE:
C                                                     (regular)
C                               (not stack)            (file)
C          OPENF --> OPENFB  --------------> OPENFIL -------->
C            ^          |                      |
C            |          |                      `----------> INLNBUF
C         OPFIL         |                        (inline)   OPENINLN
C                       | (stack)                (file  )
C                       |
C                       |
C                       |    (inline stack)
C                       |-------------------> OPNINSTK -->      
C                       |
C                       |    (file stack)
C                       ` ------------------>  OPENFIL
C                                               V
C                       '------------------------
C                       V
C                    OPENFB
C
d45 2
a46 1
	SUBROUTINE OPENFB(BUF,FILNAM,LUN,NSAM,NROW,DISP,NF,NSLICE)
a51 2
        LOGICAL          USEINLN
        COMMON /LUNARB/  LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
d53 1
a53 2
        CHARACTER *81    FILSOPN(100)
        COMMON /LUNFILES/FILSOPN
d59 2
a60 5
        CHARACTER * 1    NULL,DISPF,FIRSTC,DSP
	LOGICAL          EX,STACKOPN,CHECKFORM,ISERROR,ISDIGI
        DIMENSION        ZBUF(45)
        CHARACTER *180   CLINE
        EQUIVALENCE      (CLINE,ZBUF)
d69 1
d75 1
a75 1
        NF = 1
a79 2
        IFORMIN     = IFORM
        FIRSTC      = FILNAM(1:1)
a80 48
        IF (ILOC .EQ. 0) THEN
C          NOT AN IMAGE STACK (MAY BE AN INLINE FILE).  NOTE:
C          THIS IS THE PATH FOR 'REGULAR' SPIDER IMAGE FILES.
           NSTACK = -2
	   CALL OPENFIL(BUF,FILNAM,LUN,NSAM,NROW,NSLICE,NSTACK,
     &                  IMUSED,DISP(1:1),NF)
           IF (NSTACK .GE. 0 ) THEN 
C             BARE STACK REFERENCE NOT ALLOWED WITHOUT '@@'
              CALL ERRT(101,'STACK INDICATOR (@@) MISSING',NE)
              NF = 1
           ENDIF
           RETURN

        ELSEIF (FIRSTC .EQ. '_') THEN
C           INLINE IMAGE STACK ACCESS WANTED
            NIMAG  = 0
            CALL OPENINSTK(BUF,FILNAM,LUN,NSAM,NROW,NSLICE,NIMAG,
     &                     IFORM,DISP(1:1),NF)
C           NOTE: OPENINSTK RETURNS NSTACK VALUE
            RETURN
        ENDIF

C       V-------------- ONLY FOR IMAGE STACK NOW ----------------V


C       WANT TO ACCESS AN IMAGE STACK, GET FILENAME WITHOUT DATEXC
        FILN = FILNAM(1:ILOC-1) // CHAR(0) 

C       CREATE FILE NAME WITH WITHOUT @@ BUT WITH EXTENSION
        CALL FILCAN(FILNPE,NLET,NULL,NULL,FILN,DATEXC,IER)
	IF (IER .NE.0) THEN
            CALL ERRT(101,'ADDING EXTENSION TO FILENAME',NE)
            RETURN
        ENDIF

C       SEE IF STACK EXISTS NOW
        IF (FILNPE .EQ. FILSOPN(LUN)) THEN
C          SEE IF FILE EXISTS NOW
           EX       = .TRUE.
           STACKOPN = .TRUE.
        ELSE
           STACKOPN = .FALSE.
	   INQUIRE(FILE=FILNPE,IOSTAT=IER,EXIST=EX)
           IF (IER .NE. 0) THEN
              CALL ERRT(101,'FILE INQUIRY FAILED',NE)
              RETURN
           ENDIF
        ENDIF
d99 17
d120 3
a122 8
           IF (EX .AND. .NOT. STACKOPN .AND. IMGNUM .EQ. 0) THEN
C             DELETE THE FILE
              EX = .FALSE.
           ENDIF

           IF (.NOT. EX) THEN
C             STACK FILE DOES NOT EXIST YET, CREATE STACK FILE
C             OPENFIL WILL RETURN NSTACK = 0
d124 1
d129 5
a133 4
           ELSEIF (.NOT. STACKOPN) THEN
C             OPEN AN EXISTING STACK FILE
              DISPF  = 'O'
              NSTACK = 0
d137 2
d140 3
a142 1
C             IF THIS IS A SPECIFIC IMAGE WITHIN THE STACK
d148 2
a149 2
              ELSEIF (NSAMF .NE. NSAM .OR. NROWF .NE. NROW .OR.
     &             NSLICEF .NE. NSLICE) THEN
d153 8
a160 2
              ENDIF
              IF (IMUSED .NE. -1) THEN
d164 1
a164 4
                  IF (IRTFLG .NE. 0) THEN
                     NF = 1
                     RETURN
                  ENDIF
d169 4
a172 5
C             JUST WANT TO OPEN NEW BARE STACK
C             SET DEFAULT OFFSET INTO LUNSTK FOR 1ST IMAGE (BARE STACK)
              LUNSTK(LUN) = 0
              NF          = 0
              NSTACK      = 0
d180 7
a186 2
C          SET IMAGE SPECIFIC LOCATIONS IN IMAGE HEADER -----
           BUF(5)  = IFORM
a194 14
C          DETERMINE TYPE OF FILES IN THIS STACK
           IF (IFORMIN .NE. IFORM) THEN
C             EXISTING STACK FILE FORMAT NOT SAME AS IMAGE FORMAT
              CALL ERRT(101,
     &            'EXISTING STACK FILE FORMAT NOT COMPATIBLE',NE)
              RETURN
           ENDIF

           IF (IMGNUM .GT. BUF(26)) THEN
C             UPDATE OVERALL HEADER WITH MAXIMUM IMAGE NUMBER
              BUF(26) = IMGNUM
              CALL WRTHED(LUN,BUF,NSAM,IRTFLG)
           ENDIF

a224 2
           CHECKFORM = .FALSE.

d234 1
d236 9
a244 12
           ELSEIF (.NOT. STACKOPN) THEN
C             OPEN THE EXISTING OVERALL STACK FILE
              DISPF  = 'O'
	      CALL OPENFIL(BUF,FILN,LUN,
     &                     NSAM,NROW,NSLICE,NSTACK,IMUSED,DISPF,NFT)
              IF (NFT .NE. 2)  RETURN
              IF (NSTACK .LE. -2) THEN
C                EXISTING FILE IS NOT A STACK
                 CALL ERRT(101,'EXISTING FILE IS NOT A STACK',NE)
                 RETURN
              ENDIF
              CHECKFORM = .TRUE.
d246 1
d252 1
a252 1
           IF (BUF(25) .NE. -1 .AND. CHECKFORM) THEN
d258 1
a258 2
                 LUNSTK(LUN) = 0
                 NF          = 88
a262 4
C          ASSUME ALL IMAGES HAVE SAME IREC AS HEADER
           IREC   = BUF(3)
           LENBYT = BUF(23)

d264 1
a264 3
C             JUST WANT BARE STACK 
              LUNSTK(LUN) = 0
C             RETURN NSTACK = MAX IMAGE IN STACK 
d267 1
a267 1
              NF     = 2
d269 7
a275 2
           ELSE
C             GET SPECIFIED IMAGE HEADER FROM STACK FILE LOCATION
d277 3
a279 2
C             ALL IMAGES HAVE SAME IREC AS HEADER
              IREC        = BUF(3)
d281 8
a288 13
C             SET OFFSET INTO LUNSTK
              LUNSTK(LUN) = (IMGNUM-1) * IREC + BUF(13)
              CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,NOSTOP,IRTFLG)
              IF (IRTFLG .NE. 0) RETURN
C             RETURN NSTACK = -1 (FOR STACKED IMAGE)
              NSTACK = -1
              IMUSED = BUF(25)
              IF (IMUSED .EQ. 0) THEN
C                NO EXISTING IMAGE WITHIN STACK
                 IF (DISP .NE. 'Z') THEN
                    CALL ERRT(101,'THIS IMAGE NOT USED IN STACK',NE)
                 ENDIF
                 RETURN
d290 1
d293 2
a294 29
C          BUF(4) USED TO CONTAIN NHISTREC
           IMAMI    = BUF(6)+0.5
           FMAX     = BUF(7)
           FMIN     = BUF(8)
           AV       = BUF(9)
           SIG      = BUF(10)
           IANGLE   = BUF(14)
           PHI      = BUF(15)
           THETA    = BUF(16)
           PSI      = BUF(17)
           XOFF     = BUF(18)
           YOFF     = BUF(19)
           ZOFF     = BUF(20)
           SCALE    = BUF(21)
           KANGLE   = BUF(30)
           PHI2     = BUF(31)
           THETA2   = BUF(32)
           PSI2     = BUF(33)
           PHI1     = BUF(34)
           THETA1   = BUF(35)
           PSI1     = BUF(36)

           DO I = 1,64
             HDR_VALS(I) = BUF(36+I)
           ENDDO

C          GET CURRENT DATE AND TIME FROM BUF
           CALL DATTIMTIT(BUF,.TRUE.,.FALSE.,LENTIT,IRTFLG)

d305 1
a305 1
        NF = 2
@


1.60
log
@comments
@
text
@d32 1
a32 1
C                   'O'   -     THE FILE IS ASSUMED TO EXIST; NSAM AND
d35 7
d44 1
a44 1
C                               NROW VALUES HAVE TO BE AVAILABLE; THE
d48 1
a48 5
C                   'Z'    -    THE FILE IS ASSUMED TO EXIST; NSAM AND
C                               NROW AND HEADER INFO (IN COMMON) ARE 
C                               RETURNED TO THE CALLING PROGRAM.
C                               IF FILE DOES NOT EXIST THEN BATCH DOES
C                               NOT STOP!!! (ONLY DIFFERENCE FROM 'O'). 
d70 2
a71 1
C    VARIABLES: IFORM (TYPE)  FILE TYPE SPECIFIER. 
d81 5
a85 4
C              NSTACK    FILE STACK SPECIFIER. 
C                0          NOT A STACK
C               <0          EMPTY (BARE) STACK
C               >0          STACK
d87 1
a87 2
C
C     CALLS:
a126 1
        CHARACTER * 2    TYPE
d153 3
a155 2
C          NOT AN IMAGE STACK (MAY BE AN INLINE FILE)
           NSTACK = 0
d158 2
a159 2
           IF (NSTACK .GT. 1) THEN 
C             STACK REFERENCE NOT ALLOWED WITHOUT '@@'
d170 1
d229 2
a230 1
              NSTACK = 2
d238 1
d242 3
a244 1
              IF (NSTACK .EQ. 0) THEN
d267 1
a267 1
C             JUST WANT TO OPEN BARE STACK
d271 1
a271 1
              NSTACK      = -1
d287 1
d297 6
d304 3
a306 2
           NSTACK  = 2
           BUF(24) = NSTACK        
d309 1
d346 1
a346 1
C             OPEN THE EXISTING STACK FILE
d351 1
a351 1
              IF (NSTACK .EQ. 0) THEN
d376 2
a377 3
C          SET OFFSET INTO LUNSTK
           IREC        = BUF(3)
           LUNSTK(LUN) = (IMGNUM-1) * IREC + BUF(13)
d379 9
a387 1
           IF (IMGNUM .GT. 0) THEN
d389 6
d397 3
a399 2

              IMUSED   = BUF(25)
a422 6
           NSTACK   = BUF(24)
           IF (IMGNUM .LE. 0) THEN
C             JUST WANT BARE STACK (HEADER POINTER)
              NSTACK      = -1
              LUNSTK(LUN) = 0
           ENDIF
a448 6
 
8888    IF (LEN(DISP) .GT. 1 .AND. DISP(2:2) .EQ. 'S') THEN
            FILSOPN(LUN) = FILNPE(1:NLET) // NULL
        ELSE
            FILSOPN(LUN) = ' '
        ENDIF
d450 4
a453 46
    	IF (IFORM .EQ. -2) THEN
            TYPE = 'P '
        ELSEIF (IFORM .EQ. -9) THEN
            TYPE = 'FS'
        ELSEIF (IFORM .EQ. -11) THEN
            TYPE = 'O2'
        ELSEIF (IFORM .EQ. -12) THEN
            TYPE = 'E2'
        ELSEIF (IFORM .EQ. -21) THEN
            TYPE = 'O3'
        ELSEIF (IFORM .EQ. -22) THEN
            TYPE = 'E3'
	ELSEIF (IFORM .EQ. 0)  THEN
            TYPE = 'D '
        ELSEIF (IFORM .EQ. 1 .AND. NSTACK .EQ. 2)  THEN
            TYPE = 'S2'
        ELSEIF (IFORM .EQ. 3 .AND. NSTACK .EQ. 3)  THEN
            TYPE = 'S3'
        ELSEIF (IFORM .EQ. 3)  THEN
            TYPE = 'R3'
        ELSE
            TYPE = 'R '
        ENDIF

	IF (N_VERBOSE .EQ. 1 .AND. IFOUND .NE. -4) THEN
C         PRINT STACK OPENING INFORMATION
          IF (LENTIT .GT. 0 .AND. LENTIT + NLET .LT. 70) THEN
             WRITE(NOUT,901) CTIT(:LENTIT)
901          FORMAT('     / ',A)
          ELSE
             LENT = MIN(80,LENTIT)
             WRITE(NOUT,902) CTIT(1:LENT)
             IF (LENTIT .GT. 80) WRITE(NOUT,902) CTIT(81:LENTIT)
902          FORMAT(A)
          ENDIF

          IF (NSLICE .GT. 1) THEN
             WRITE(NOUT,2098) TYPE,NSAM,NROW,NSLICE,IMGNUM,CDAT,CTIM,DSP
2098	     FORMAT(' (',A,')',3I5,' (@@',I6,')  CREATED ',A,' AT ',A,
     &               2X,A)
          ELSE
             WRITE(NOUT,2099)TYPE,NSAM,NROW,IMGNUM,CDAT,CTIM,DSP
2099         FORMAT(' (',A,')',2I5,' (@@',I6,')  CREATED ',A,' AT ',A,
     &              2X,A)
          ENDIF
        ENDIF
a454 8
        PARAM(2) = NSAM
	PARAM(3) = NROW
	PARAM(4) = FMAX
	PARAM(5) = FMIN
	PARAM(6) = AV
	PARAM(7) = SIG
	PARAM(8) = NSLICE

d456 1
a457 1
	END
@


1.59
log
@nstack for inline stacks fixed, comment improved
@
text
@d25 6
a30 7
C        BUF        WORKING BUFFER FOR READ/WRITE
C        FILNAM     CHARACTER ARRAY, CONTAINING FILE NAME 
C        LUN        LOGICAL UNIT NUMBER TO BE ASSIGNED TO FILNAM.
C        NSAM,NROW  DIMENSIONS OF FILE - INPUT OR OUTPUT PARAMETERS
C                       OF OPEN, DEPENDING ON DISP.
C        DISP(1:1)  CHARACTER  CONTAINING ONE OF THE FOLLOWING 
C                   DISPOSITION SPECIFICATIONS:
d52 1
a52 1
C        NF                     ERROR RETURN FLAG.
d56 1
a56 1
C        NSLICE                 NUMBER OF PLANES, EACH CONTAINING 
@


1.58
log
@trap for disp == z added to image not used
@
text
@a166 1
            NSTACK = 2
d198 1
a198 1
C          FIND IMAGE RECORD OFFSET WITHIN STACK FILE 
d203 1
a203 1
              CALL ERRT(101,'UNABLE TO INTERPRET STACK NUMBER',NE)
d228 1
a228 1
              IF (NFT .NE. 2)  RETURN
@


1.57
log
@used nostop
for redhed if disp == z
@
text
@d372 3
a374 1
                 CALL ERRT(101,'THIS IMAGE NOT USED IN STACK',NE)
@


1.56
log
@added NOSTOP parameter to redhed call
@
text
@d137 3
d344 1
a344 1
           CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,0,IRTFLG)
d366 1
a366 1
              CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,0,IRTFLG)
@


1.55
log
@lunstk wrong for bare stack
@
text
@d266 1
a266 1
           CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,IRTFLG)
d341 1
a341 1
           CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,IRTFLG)
d363 1
a363 1
              CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,IRTFLG)
d504 1
a504 1
        CALL REDHED(LUN,BUFCHK,NBUFSIZ,NSAM,IRTFLG)
@


1.54
log
@openfil now returns imused
@
text
@d391 2
a392 1
              NSTACK = -1
@


1.53
log
@nstack passed incommon
@
text
@d151 1
a151 1
     &                  DISP(1:1),NF)
d225 1
a225 1
     &                     NSAM,NROW,NSLICE,NSTACK,DISP,NFT)
d232 1
a232 1
     &                  NSAMF,NROWF,NSLICEF,NSTACK,DISPF,NFT)
d245 8
a252 5
C             ERROR IF TRYING TO CREATE NEW IMAGE IN A MALFORMED STACK
              CALL CHECKSTACK(LUN,NSAM,BUF,.TRUE.,IRTFLG)
              IF (IRTFLG .NE. 0) THEN
                 NF = 1
                 RETURN
d330 1
a330 1
     &                     NSAM,NROW,NSLICE,NSTACK,DISPF,NFT)
d389 4
@


1.52
log
@checkstack needed lunara in lunstk
@
text
@d79 3
a81 3
C               <0          NOT A STACK
C                0          EMPTY (BARE) STACK
C               >0          MAX NUMBER OF IMAGES CURRENTLY IN STACK
d113 4
a116 4
        LOGICAL         USEINLN
        COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
        COMMON /LUNARA/ LUNARA(100),LUNSTK(100)
        CHARACTER *81   FILSOPN(100)
d118 1
d120 9
a128 10
        DIMENSION      BUF(*)
        
        CHARACTER *(*) FILNAM,DISP
        CHARACTER * 81 FILN,FILNPE
        CHARACTER * 1  NULL,DISPF,FIRSTC,DSP
        CHARACTER * 2  TYPE
	LOGICAL        EX,STACKOPN,CHECKFORM,ISERROR,ISDIGI
        DIMENSION      ZBUF(45)
        CHARACTER *180 CLINE
        EQUIVALENCE    (CLINE,ZBUF)
d161 1
a161 1
            NIMAG = 0
d164 1
d223 1
a223 2
              NSTACKF = 2
              IF (IFORM .EQ. 3) NSTACKF = 3
d225 1
a225 1
     &                     NSAM,NROW,NSLICE,NSTACKF,DISP,NFT)
d232 1
a232 1
     &                  NSAMF,NROWF,NSLICEF,NSTACKF,DISPF,NFT)
d234 1
a234 1
              IF (NSTACKF .LE. 0) THEN
d258 1
d262 1
a262 1
C          RECOVER OVERALL HEADER FROM THE OLD OR NEW STACK FILE
d266 1
a266 3
C          GET SPECIFIED IMAGE HEADER FROM STACK FILE LOCATION

C          SET IMAGE SPECIFIC LOCATIONS IN IMAGE HEADER
d275 2
a276 4
C          DETERMINE TYPE OF STACK FOR THIS IMAGE
           NSTACKI = 2
           IF (NSLICE .GT. 1) NSTACKI = 3
           IF (IFORMIN .NE. IFORM .OR. NSTACKI .NE. NSTACKF) THEN
d283 3
a285 1
           BUF(24) = NSTACKI        
d292 1
a292 3
C          THIS ASSUMES ALL IMAGES HAVE SAME IREC AS STACK HEADER!
C          SET OFFSET INTO LUNSTK

d295 2
d341 1
a341 1
           IF (CHECKFORM) THEN
a352 1

d364 1
a364 1
              IF (IMUSED .LE. 0) THEN
a371 1
           NHISTREC = 0
a376 1
           IHIST    = 0
d385 1
d501 1
a501 1
C       CHECK NSLICE, NROW, NSAM, LABREC, LABBYT, NSTACK 
d504 1
a504 2
     &      BUF(22) .NE. BUFCHK(22) .OR. BUF(24) .NE. BUFCHK(24)) THEN
            WRITE(NOUT,*) '*** ERROR: STACK NEEDS REFORMING'
d506 1
d508 2
@


1.51
log
@handles bare stacks & malformed stacks now
@
text
@d494 1
a494 1
        LUNSTK(LUN) = 1
d505 1
a505 1
        IF (BUF(1)  .NE. BUFCHK(1) .OR. BUF(2) .NE. BUFCHK(2) .OR.  
@


1.50
log
@*** empty log message ***
@
text
@d5 4
a8 1
C                                           LONG FILENAMES
d58 1
a58 4
C                               NSAM * NROW ELEMENTS. IF NSLICE IS <0 
C                               (ON VMS VERSION) A SHORT HEADER 
C                               FORMAT FILE WAS DESIRED (NO LONGER 
C                               SUPPORTED).
d63 4
a66 1
C              IMAGE  PLUS HEADER.
d69 1
a69 1
C                0    D     DATA FILE (UNUSED?)
d71 2
a72 2
C               +3    R3    3-D (VOLUME) FILE
C               -9    FS    3-D SIMPLE FORMAT FOURIER (MICHAEL'S FORMAT)
d78 5
d84 2
a85 1
C                                                      (regular)
d87 4
a90 4
C  CALLS:   OPENF --> OPENFB  --------------> OPENFIL -------->
C                       |                      |
C                       |                      |----------> INLNBUF
C                       |                        (inline)   OPENINLN
d98 3
a100 1
C                       | ------------------>  OPENFIL
d102 1
a103 1
C
d125 1
a125 1
	LOGICAL        EX,STACKOPN
d134 4
d144 3
a146 4
        IFORMIN = IFORM
        FIRSTC  = FILNAM(1:1)

        ILOC = INDEX(FILNAM,'@@')      
d148 1
a148 1
C          NOT AN IMAGE STACK
d152 5
d167 3
d173 1
a173 1
C       CREATE FILE NAME WITH EXTENSION
d194 15
a208 7
C       FIND IMAGE RECORD OFFSET WITHIN STACK FILE 
        READ(FILNAM(ILOC+1:),*,IOSTAT=IER) IMGNUM

        IF (IER .NE. 0) THEN
C          ERROR CONVERTING STACK NUMBER
           CALL ERRT(101,'UNABLE TO INTERPRET STACK NUMBER',NE)
           RETURN
d215 5
d227 1
d238 1
d245 14
d261 1
a261 1
C          RECOVER HEADER FROM THE OLD OR NEW STACK FILE
d265 1
a265 2
C          GET IRECF FROM STACK FILE HEADER
           IRECF   = BUF(3)
d285 1
a285 1
C
d295 3
d300 1
a300 1
C          PLACE THIS IMAGE HEADER INTO STACK LOCATION
d312 2
d320 2
a321 2
     $            (IPROC .NE. 0 .OR. COPT  .EQ. 'B')) RETURN
               CALL ERRT(100,'OPENFB',NE)
d328 1
a328 1
     &                  NSAM,NROW,NSLICE,NSTACK,DISPF,NFT)
d335 1
d338 1
a338 1
C          RECOVER HEADER FROM THE STACK FILE
d342 12
a353 1
           IREC = BUF(3)
d357 1
a358 3
C          GET SPECIFIED IMAGE HEADER FROM STACK FILE LOCATION
           CALL REDHED(LUN,BUF,NBUFSIZ,NSAM,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
d360 11
a370 5
           IMUSED   = BUF(25)
           IF (IMUSED .LE. 0) THEN
C             NO EXISTING IMAGE WITHIN STACK
              CALL ERRT(101,'THIS IMAGE NOT USED IN STACK',NE)
              RETURN
d413 4
a416 1
        IF (LEN(DISP) .GT. 1 .AND. DISP(2:2) .EQ. 'S') THEN
d436 1
a436 1
        ELSEIF (IFORM .EQ. 1)  THEN
d438 1
a438 1
        ELSEIF (IFORM .EQ. 3)  THEN
a476 2
C       SET FLAG FOR NORMAL RETURN	
        NF = 2
d480 40
@


1.49
log
@correct the stack structure
@
text
@d385 2
a386 1
             WRITE(NOUT,2098) TYPE,NSAM,NROW,NSLICE,IMGNUM,CDAT,CTI                                ',3I5,' (@@',I6,')  CREATED ',A,' AT ',A,
d403 2
a404 1
C       SET FLA                                = 2
@


1.48
log
@kludge for disp == R
@
text
@d96 1
a96 1
	SUBROUTINE OPENFB(BUF,FILNAM,LUN,NSAM,NROW,DISPT,NF,NSLICE)
d110 1
a110 1
        CHARACTER *(*) FILNAM,DISPT
a111 1
        CHARACTER * 15 DISP
a125 4
C       KLUDGE FOR DISP == 'R'
        DISP = DISPT
        IF (DISPT(1:1) .EQ. 'R') DISP = 'O'

d245 1
a245 1
           LUNSTK(LUN) = IMGNUM * IRECF
d290 1
a290 2
           LUNSTK(LUN) = IMGNUM * IREC

d385 1
a385 2
             WRITE(NOUT,2098) TYPE,NSAM,NROW,NSLICE,IMGNUM,CDAT,CTIM,DSP
2098	     FORMAT(' (',A,')',3I5,' (@@',I6,')  CREATED ',A,' AT ',A,
d402 1
a402 2
C       SET FLAG FOR NORMAL RETURN	
        NF = 2
@


1.47
log
@bad test for disp = old
@
text
@d96 1
a96 1
	SUBROUTINE OPENFB(BUF,FILNAM,LUN,NSAM,NROW,DISP,NF,NSLICE)
d110 1
a110 1
        CHARACTER *(*) FILNAM,DISP
d112 1
d126 4
@


1.46
log
@null init. for f90
@
text
@d254 3
a256 3
	ELSEIF (DISP .EQ. 'O' .OR. DISP .EQ. 'K' .OR.
     &          DISP .EQ. 'Z' .OR. 
     &          DISP .EQ. 'E' .OR. DISP .EQ. 'M') THEN
@


1.45
log
@removed  I format
@
text
@d119 3
a121 1
        DATA NULL /0/,NBUFSIZ/17000/
@


1.44
log
@removed READONLY stuff
@
text
@d112 1
a112 1
        CHARACTER * 1  NULL,DISPF,FIRSTC
d171 2
a172 2
        READ(FILNAM(ILOC+1:),8000,IOSTAT=IER) IMGNUM
8000    FORMAT(I)
@


1.43
log
@altered disp=z handling
@
text
@a32 5
C                   'R'   -     THE FILE IS ASSUMED TO EXIST; NSAM AND
C                               NROW AND HEADER INFO (IN COMMON) ARE 
C                               RETURNED TO THE CALLING PROGRAM.
C                               FILE IS OPENED AS READONLY - MULTIREAD
C                               IS POSSIBLE. 
d253 1
a253 1
     &          DISP .EQ. 'Z' .OR. DISP .EQ. 'R' .OR.
@


1.42
log
@added a ZOLD format so that a missing file from the serie does not stop the processin errt.f
@
text
@d38 2
a39 2
C                   'U'    - IT IS NOT KNOWN IF THE FILE EXISTS.  
C                                 IF IT DOES NOT EXIST, NON-ZERO NSAM &
d42 1
a42 1
C                                 IF THE FILE ALREADY EXISTS, IT WILL BE 
d44 6
d253 1
a253 1
           DSP = 'O'
d257 3
a259 2
     	ELSEIF (DISP(1:1) .EQ. 'O' .OR. DISP(1:1) .EQ. 'M' .OR. 
     &          DISP(1:1) .EQ. 'Z' .OR. DISP(1:1) .EQ. 'K')THEN
d264 6
a269 1
              CALL ERRT(101,'STACK FILE DOES NOT EXIST',NE)
d271 1
@


1.41
log
@comments
@
text
@d252 1
a252 1
     &          DISP(1:1) .EQ. 'K')THEN
@


1.40
log
@added iniline stacks
@
text
@d74 18
@


1.39
log
@removed closefb
@
text
@d93 1
a93 1
        CHARACTER * 1  NULL,DISPF
d109 1
a117 1
        ENDIF
d119 5
a123 4

        IF (USEINLN .AND. FILNAM(1:1) .EQ. '_') THEN
            CALL ERRT(101,
     &           'STACKS CAN NOT BE STORED IN INILINE BUFFERS',NE)
@


1.38
log
@added capability to keep files open when stacks
@
text
@a379 13

	SUBROUTINE CLOSEFB(LUN,IRTFLG)
C DO NOT COMPILE WITH STATIC
CNO_SAVE

        CHARACTER *81    FILSOPN(100)
        COMMON /LUNFILES/FILSOPN

        FILSOPN(LUN) = ' '

        RETURN
        END

@


1.37
log
@stacks introduced
@
text
@d27 1
a27 1
C        DISP       CHARACTER  CONTAINING ONE OF THE FOLLOWING 
d44 1
d46 3
d86 3
d91 1
a91 1
        CHARACTER *(*) FILNAM
d93 1
a93 1
        CHARACTER * 1  NULL,DISP,DISPF
d95 1
a95 1
	LOGICAL        EX
d108 2
d115 1
a115 1
     &                  DISP,NF)
d137 11
a147 4
	INQUIRE(FILE=FILNPE,IOSTAT=IER,EXIST=EX)
        IF (IER .NE. 0) THEN
           CALL ERRT(101,'FILE INQUIRY FAILED',NE)
           RETURN
d159 1
a159 1
	IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d170 2
a171 2
           ELSE
C             OPEN EXISTING STACK FILE
d188 1
a188 1
C          RECOVER HEADER FROM THE STACK FILE
d207 1
a207 1
           IF (NSTACKI .NE. NSTACKF) THEN
d232 2
a233 1
     	ELSEIF (DISP .EQ. 'O' .OR. DISP .EQ. 'M' .OR. DISP .EQ. 'K')THEN
d240 4
a243 5
           ENDIF

C          OPEN EXISTING STACK FILE
           DISPF  = 'O'
	   CALL OPENFIL(BUF,FILN,LUN,
d245 6
a250 5
           IF (NFT .NE. 2)  RETURN
           IF (NSTACK .EQ. 0) THEN
C             EXISTING FILE IS NOT A STACK
              CALL ERRT(101,'EXISTING FILE IS NOT A STACK',NE)
              RETURN
d257 1
a257 1
           IREC     = BUF(3)
d314 6
d381 11
@


1.36
log
@for new fourier
@
text
@d5 1
a5 4
C                LONG FILENAMES         OCT 88 al
C                MERGED WITH OPENF      AUG 96 al
C                -1, -3 & -7 FOURIER FORMATS REMOVED  AUG 96 al
C
d18 1
a18 1
C    PURPOSE:       OPEN NEW OR EXISTING DATA FILE FOR RANDOM 
d30 1
a30 1
C                   'O'    -    FILE IS ASSUMED TO EXIST.  NSAM AND
d33 1
a33 1
C                   'R'    -    THE FILE IS ASSUMED TO EXIST; NSAM AND
d38 6
a43 7
C                   'N'    -    WANT NEW FILE. NSAM, NROW, NSLICE, AND
C                               IFORM ARE NEEDED.
C                   'U'    -    IT IS NOT KNOWN IF THE FILE EXISTS.  
C                               IF THE FILE EXISTS, IT WILL BE REPLACED.
C                               NSAM, NROW, NSLICE, AND IFORM VALUES 
C                               ARE NEEDED. 
C                   'K & M'-    NO LONGER USED.
d55 4
a58 4
C    CODING:   BASED ON IMAGE PARAMETERS NSAM,NROW, & NSLICE,  A
C              NEW FILE IS OPENED WITH IREC RECORDS, EACH NSAM * 4 
C              BYTES LONG.  IREC ALLOWS SPACE FOR THE 3-D DISTRIBUTION,
C              PLUS NORMAL IMAGE HEADER.
d61 3
a63 7
C                0     D    DATA FILE (UNUSED?)
C               +1     R    2-D IMAGE
C               +3     R3   3-D FILE
C               +8     8    8 BIT BLACK AND WHITE FILE (UNUSED)
C               +11    C    8 BIT COLOR FILE (UNUSED)
C               +12   -     8 BIT RUNLENGTH BLACK AND WHITE FILE (UNUSED?)
C               +16   16    16 BIT BLACK AND WHITE FILE (UNUSED)
d65 4
a68 4
C               -11   O2    2-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -12   E2    2-D FOURIER TRANSFORM, MIXED RADIX EVEN
C               -21   O3    3-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -22   E3    3-D FOURIER TRANSFORM, MIXED RADIX EVEN
a78 10
        COMMON /LUNARA/ LUNARA(100)

#ifdef SP_SUN4 
        INTEGER * 4     LOCLUN
#else
#ifdef SP_ALLOC
        INTEGER * 8     LOCLUN
#endif
#endif

d81 1
a81 2
        COMMON /IOERR/  IERR

d85 2
a86 1
        CHARACTER * 81 FILNM
d88 1
a88 3
        CHARACTER * 1  NULL,DISP,DSP,TDAT
        INTEGER        LABREC,LABBYT
	LOGICAL        EX,NEWDAT
d93 1
a93 29
        DATA NULL /0/
	DATA NSAMAX/16384/

C       TO KEEP OLD DATE
        NEWDAT = .TRUE.
        IF (NF .LT. 0) NEWDAT = .FALSE.

C       SET FLAG FOR ERRONEOUS RETURN
        NF     = 1
        IERR   = 0
       
        IF (LUN .LE. 0 .OR. LUN .GT. 100) THEN
           WRITE(NOUT,*)
     &     '*** PGM. ERROR: LUN MUST BE 1...100, SET TO 99'
           LUN = 99
        ENDIF

C	CHECK IF USER WANTS TO USE THE IN-LINE BUFFER.
        INLNED = 0
        IF (USEINLN .AND. FILNAM(1:1) .EQ. '_') THEN
           CALL INLNBUF(FILNAM,NLET,INLNED,IRTFLG)
           IF (IRTFLG .NE. 0)  RETURN

	   IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
	     EX = .FALSE.
	   ELSE
	     EX = .TRUE.
	   ENDIF
           FILNM = FILNAM(1:NLET)
d95 2
a96 15
        ELSE
C          USE REGULAR FILE
           INLNED      = 0
	   LUNC        = LUN
           LOCLUN(LUN) = 0

           IF (DATEXC .EQ. NULL) THEN
              FILNM = FILNAM
           ELSE
              CALL FILCAN(FILNM,NLET,NULL,NULL,FILNAM,DATEXC,IER)
	      IF (IER .NE.0) THEN
                 CALL ERRT(100,'OPENFB',NE)
                 RETURN
              ENDIF
          ENDIF
d98 2
a99 14
C         SEE IF FILE EXISTS NOW
#ifdef SP_VMS
	  INQUIRE(FILE=FILNM,IOSTAT=IER,EXIST=EX,RECL=NSAMO)
C         RECL RETURNED IS IN BYTES ON VAX/VMS
          NSAMO = NSAMO / 4
#else
	  INQUIRE(FILE=FILNM,IOSTAT=IER,EXIST=EX)
#endif
          IF (IER .NE. 0) THEN
             WRITE(NOUT,*) '*** FILE INQUIRY ERROR: ',FILNM(1:NLET)
             CALL ERRT(100,'OPENFB',NE)
             RETURN
          ENDIF
        ENDIF
d101 6
a106 5
	IF (.NOT. EX .AND. (DISP .EQ. 'O' .OR. DISP .EQ. 'M' .OR.
     &                      DISP .EQ. 'K')) THEN
C          ERROR -- FILE DOES NOT EXIST, BUT IS BEING OPENED WITH 'OLD'
           WRITE(NOUT,*) '*** NOT FOUND: ',FILNM(1:NLET)
           CALL ERRT(100,'OPENFB',NE)
a109 2
10	IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
C         USER WANTS A NEW FILE TO WRITE INTO ----------------------NEW
d111 3
a113 22
          IF (EX) THEN
C           FILE IS IS OPENED WITH 'UNKNOWN' BUT ALREADY EXISTS; IT WILL
C           BE REPLACED.  OLD FILES ARE DELETED FIRST 

#ifdef SP_VMS
            OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',DISPOSE='DELETE')
            CLOSE(UNIT=LUN,DISPOSE='DELETE',IOSTAT=IER)
#else
            OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD')
            CLOSE(UNIT=LUN,STATUS='DELETE',IOSTAT=IER)
#endif
	    IF (IER .NE. 0) THEN
               WRITE(NOUT,*) '*** ERROR DELETING FILE: ', FILNM(1:NLET)
               CALL ERRT(100,'OPENFB',NE)
               RETURN
            ENDIF
          ENDIF

	  IF (NSAM .EQ. 0 .OR. NROW .EQ. 0) THEN
C           FOR NEW FILES, NON-ZERO NSAM, NROW NEED TO BE SUPPLIED
2060	    WRITE(NOUT,*) '*** RECORD INFO MISSING: ',FILNM(1:NLET)
            CALL ERRT(100,'OPENFB',NE)
d115 1
d117 2
a118 5
          ELSEIF (NSAM .GT. NSAMAX) THEN
C           EXCESSIVE ROW LENGTH 
            WRITE(NOUT,*) '*** ROWLENGTH MUST BE <=:',NSAMAX
            CALL ERRT(100,'OPENFB',NE)
            RETURN
d120 4
a123 9
          ELSEIF (NSLICE .EQ. 0) THEN
C           NEW FILES NEED A NON ZERO SLICE NUMBER FOR FILE FORMAT FLAG
            NSLICE = 1

          ELSEIF (NSLICE .LT. 0) THEN
C           WANT TO CREATE OBSOLETE SHORT HEADER FILE
#ifdef SP_VMS
            CALL ERRT(100,
     &         'CAN NO LONGER CREATE OBSOLETE SHORT HEADER FILE',NE)
d125 1
a125 5
#else
            WRITE(NOUT,*) 'WARNING:  NO SHORT HEADER FILES ON UNIX.'
            NSLICE = -NSLICE
#endif
          ENDIF
d127 6
a132 6
          IF (IFORM .EQ. -1 .OR. IFORM .EQ. -3 .OR. IFORM .EQ. -7) THEN
C           WANT TO CREATE OBSOLETE FOURIER FILE
            CALL ERRT(101,
     &         'CAN NOT CREATE OBSOLETE FOURIER FORMAT FILE',NE)
            RETURN
          ENDIF
d134 8
a141 1
          DSP = 'N'
d143 28
a170 1
C         ADJUST NUMBER OF HEADER RECORDS TO HAVE .=256*4 BYTES IN HEADER
d172 108
a279 270
C         STANDARD SPIDER FLOATING POINT FILES
          LENBYT = NSAM * 4
          LABREC = 1024 / LENBYT
          IF (MOD(1024,LENBYT) .NE. 0) LABREC = LABREC + 1
          LABBYT = LABREC * LENBYT

          IREC = NROW * NSLICE + LABREC

	  IF (INLNED .EQ. 0) THEN
C	     REGULAR FILE
#ifdef SP_VMS
             CLOSE (LUN)
             NBLOCK = FLOAT(NSAM) / 512.0 * FLOAT(IREC) + 1.0

C            RECL IS IN UNITS OF FLOATS ON VAX
             LENREC = NSAM
	     OPEN(UNIT=LUN,FILE=FILNM,STATUS='NEW',RECORDTYPE='FIXED',
     &          ACCESS='DIRECT',FORM='UNFORMATTED',
     &          BLOCKSIZE=16384,BUFFERCOUNT=4, 
     &          RECL=LENREC,INITIALSIZE=NBLOCK,
     &          IOSTAT=IER)

C            ACTIVATE FOLLOWING LINE IF YOU NEED MORE INFO ON OPEN
C            ERROR. THE CALL TO LIB$SIGNAL STOPS THE PROGRAM AND 
C            PRINTS AN INFORMATIVE ERROR MESSAGE.
C            IF (IER .NE. 0) CALL LIB$SIGNAL(%VAL(IER))

#else
#ifdef __osf__
C            RECL IS IN UNITS OF FLOATS ON OSF 
             LENREC = NSAM
	     OPEN(LUN,FILE=FILNM,STATUS='NEW',FORM='UNFORMATTED',
     &            ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
#else
C            RECL IS IN UNITS OF BYTES ON SGI AND SUN
             LENREC = NSAM * 4
	     OPEN(LUN,FILE=FILNM,STATUS='NEW',FORM='UNFORMATTED',
     &            ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
#endif
#endif
             IF (IER .NE. 0) THEN        
                WRITE(NOUT,*) '*** ERROR OPENING FILE: ',FILNM(1:NLET)
                CALL ERRT(100,'OPENFB',NE)
                RETURN
             ENDIF

          ELSE
C            SET UP INLINE BUFFER AND TIE IT TO LUN
             NWORDS = IREC * LENBYT / 4
             CALL OPENINLN(LUN,INLNED,.TRUE.,NSAM,NWORDS,IRTFLG)
             IF (IRTFLG .NE. 0)  RETURN
	  ENDIF

#ifdef SP_VMS
          BUF(1) = -NSLICE
#else
          BUF(1) = NSLICE
#endif
          BUF(2) = NROW
          BUF(3) = IREC
C         BUF(4) USED TO CONTAIN NHISTREC
          BUF(4) = 0
          BUF(5) = IFORM
          IMAMI  = 0
          BUF(6) = IMAMI
          
          DO K= 6,212
C            ZERO UNUSED BUF VARIABLES
             BUF(K)=0
          ENDDO

          BUF(12) = NSAM
          BUF(13) = LABREC
          BUF(22) = LABBYT 
          BUF(23) = LENBYT

C         ADDED JULY 88 al
          IF (IANGLE .NE. 0) THEN
             BUF(14) = IANGLE
             BUF(15) = PHI
             BUF(16) = THETA
             BUF(17) = PSI
          ENDIF

          IF (KANGLE .NE.0) THEN
             BUF(30) = KANGLE
             BUF(31) = PHI2
             BUF(32) = THETA2
             BUF(33) = PSI2
             BUF(34) = PHI1
             BUF(35) = THETA1
             BUF(36) = PSI1
          ENDIF

C         COPY MOST RECENT HDR_VALS INTO LOCATIONS 37..101
          DO I = 1,64
             BUF(36+I) = HDR_VALS(I)
          ENDDO

          IF (NEWDAT) THEN
             CALL DATE(CDAT)
             CALL TIME(CTIM)
          ENDIF

C         DATE TAKES 2 & 1/4 FLOATING POINT VARIABLES IN BUF (9 CHAR)
          CLINE(1:12)  = CDAT(1:9) // '   '

C         TIME TAKES 2 FLOATING POINT VARIABLES IN BUF (8 CHAR.)
          CLINE(13:20) = CTIM(1:8)

C         TITLE TAKES 40 FLOATING POINT VARIABLES IN BUF (160 CHAR)
          CLINE(21:180) = CTIT(1:160)
          LENTIT        = MAX(0,(INDEX(CTIT,NULL) -1))

#if defined(__osf__) && defined(osf_ieee)    
C         ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE FOLLOWS

C         NOTE THAT THE ALPHA-NUMERICAL DATA (ABCD) WILL BE WRITTEN 
C         IN INVERTED ORDER (DCBA)
          DO K = 1, 180, 4
              TDAT = CLINE(K:K)
              CLINE(K:K) = CLINE(K+3:K+3)
              CLINE(K+3:K+3) = TDAT
              TDAT = CLINE(K+1:K+1)
              CLINE(K+1:K+1) = CLINE(K+2:K+2)
              CLINE(K+2:K+2) = TDAT
          END DO
C         END ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE
#endif

C         COPY CLINE STUFF INTO BUF
          DO  I = 1,45 
             BUF(I+211) = ZBUF(I) 
          ENDDO

C         WRITE HEADER RECORDS INTO FILE	    
          LUNARA(LUN) = 0

          ILOC = 1
          DO I = 1,LABREC
             CALL WRTLIN(LUN,BUF(ILOC),NSAM,I)
             ILOC = ILOC + NSAM
          ENDDO

C         SET FINAL LUNARA OFFSET VALUE FOR USE BY REDLIN/WRTLIN
          LUNARA(LUN) = LABREC

          GOTO 2000




	ELSEIF (DISP .EQ. 'O' .OR. DISP .EQ. 'K' .OR.
     &          DISP .EQ. 'R' ) THEN
C         --------------------------------------------------------- OLD
C         --------------------------------------------------------- OLD
C         FILE EXISTS, AND IS ACCESSED WITH 'OLD'
C         OPEN THE FILE

          IF (INLNED .NE. 0) THEN
C            USE EXISTING INLINE BUFFER, TIE IT TO LUN & RETRIEVE NSAM
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,0,IRTFLG)
             IF (IRTFLG .NE. 0)  RETURN
          ELSE
C            REGULAR FILE ACCESS

#ifdef SP_VMS
C            NSAM IS GOTTEN FROM INQUIRY ON VAX
             NSAM = NSAMO
             IF (DISP .EQ. 'O')  THEN
C               OPEN FOR READ / WRITE
                OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',
     &              RECORDTYPE='FIXED', ACCESS='DIRECT', IOSTAT=IER)
C               IF (IER .NE. 0) CALL LIB$SIGNAL(%VAL(IER))

             ELSEIF (DISP .EQ. 'R')  THEN
C               READ-ONLY
                OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',
     &               RECORDTYPE='FIXED', READONLY,ACCESS='DIRECT',
     &               IOSTAT=IER)
             ENDIF
             IF (IER .NE. 0) THEN         
                WRITE(NOUT,*) '*** ERROR OPENING FILE: ',FILNM(1:NLET)
                CALL ERRT(100,'OPENFB',NE)
                RETURN
             ENDIF
#else
C            REGULAR FILE ACCESS, RECL IS IN BYTES
             OPEN(LUN,FILE=FILNM,STATUS='OLD',ACCESS='DIRECT',
     &           FORM='UNFORMATTED',RECL=1024,IOSTAT=IER)
             IF (IER .NE. 0) THEN        
                WRITE(NOUT,*) '*** ERROR OPENING FILE: ',FILNM(1:NLET)
                CALL ERRT(100,'OPENFB',NE)
                RETURN
             ENDIF
#endif
     	  ENDIF

C         READ HEADER FROM FILE            	       
          LUNARA(LUN) = 0
          IERR        = 0

#ifdef SP_VMS
C         FIND NUMBER OF RECORDS IN HEADER
          LABREC = 256 / NSAM
          IF (MOD(256,NSAM) .NE. 0) LABREC = LABREC + 1

C         READ IN HEADER
          ILOC = 1
          DO I = 1,LABREC
             CALL REDLIN(LUN,BUF(ILOC),NSAM,I)
             ILOC = ILOC + NSAM
          ENDDO

          IF (BUF(1) .GT. 0) THEN
C            A POSITIVE VALUE FOR NSLICE ON VAX IS FLAG FOR OLD
C            OBSOLETE SHORT HEADER FORMAT
             WRITE(NOUT,*) 
     &           'WARNING, THIS MAY BE OBSOLETE SHORT HEADER FILE'
             WRITE(NOUT,*) 'USE "COPYFROM SHORT" TO CONVERT.'
             CALL ERRT(100,'OPENFB',NE)
          ENDIF
#else
C         ALL OF USED HEADER CAN BE READ IN ON UNIX IN ONE READ
          CALL REDLIN(LUN,BUF,256,1)
          IF (IERR .NE. 0) THEN
             WRITE(NOUT,*) '*** ERROR READING HEADER OF: ',FILNM(:NLET)
             CALL ERRT(100,'OPENFB',NE)
             RETURN
          ENDIF
#endif

          NSLICE   = ABS(BUF(1)) + 0.5
          NROW     = BUF(2) + 0.5
          IREC     = BUF(3) + 0.5
          IFORM    = BUF(5)
          IF (BUF(5) .LT. 0.0) IFORM = BUF(5) - 0.5

          IF (IFORM .EQ. -1 .OR. IFORM .EQ. -3 .OR. IFORM .EQ. -7) THEN
C           WANT TO READ OBSOLETE FORMAT FOURIER FILE
            WRITE(NOUT,96)
96          FORMAT(' *** CAN NOT READ OBSOLETE FOURIER FORMAT',/,
     &          '*** CONVERT FOURIER FILE TO REAL FORMAT USING ',
     &          'ORIGINAL VERSION OF SPIDER.'/)
             CALL ERRT(100, 'OPENFB',NE)
            RETURN
          ENDIF

          IF (IABS(IFORM) .EQ. 1) NSLICE = 1
          LENBYT   = BUF(23)
          IF (LENBYT .LE. 0) LENBYT = NSAM * 4
          LABBYT   = BUF(22)

#ifdef SP_VMS
C         CHECK TO SEE IF IREC IS REASONABLE
          IRECMIN = NROW * NSLICE + LABREC
          IF (IREC .LT. IRECMIN) IREC = IRECMIN
#else
C         ON UNIX MUST GET NSAM FROM HEADER LOCATION 12
          NSAM   = BUF(12)
          LABREC = BUF(13)

C         CORRECT UNREASONABLE LABREC (BAD VALUE ONCE)        
          LABRECT = 1024 / LENBYT
          IF (MOD(1024,LENBYT) .NE. 0) LABRECT = LABRECT + 1
          IF (LABRECT .LE. 0 .OR. LABREC .NE. LABRECT) THEN
C            UNREASONABLE LABREC NUMBER SO DEFAULT IT
             LABREC = LABRECT
          ENDIF
#endif
d281 1
a281 26
C         BUF(4) USED TO CONTAIN NHISTREC
          NHISTREC = 0
          IMAMI    = BUF(6) + 0.5
          FMAX     = BUF(7)
          FMIN     = BUF(8)
          AV       = BUF(9)
          SIG      = BUF(10)
C         IHIST NO LONGER USED
          IHIST    = 0
          IANGLE   = BUF(14)+ 0.5
          PHI      = BUF(15)
          THETA    = BUF(16)
          PSI      = BUF(17)
          XOFF     = BUF(18)
          YOFF     = BUF(19)
          ZOFF     = BUF(20)
          SCALE    = BUF(21)
          KANGLE   = BUF(30)+ 0.5
          PHI2     = BUF(31)
          THETA2   = BUF(32)
          PSI2     = BUF(33)
          PHI1     = BUF(34)
          THETA1   = BUF(35)
          PSI1     = BUF(36)

          DO I = 1,64
d283 1
a283 51
          ENDDO

C         MOVE ALPHA-NUMBERIC PART OF BUF TO ZBUF FOR CLINE ACCESS
          DO  I = 1,45 
             ZBUF(I) = BUF(I+211) 
          ENDDO

#if defined(__osf__) && defined(osf_ieee)
C         ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE FOLLOWS
C         NOTE THAT ALPHA-NUMERICAL DATA (ABCD) WILL BE WRITTEN (DCBA)
          DO K = 1, 180, 4
              TDAT           = CLINE(K:K)
              CLINE(K:K)     = CLINE(K+3:K+3)
              CLINE(K+3:K+3) = TDAT
              TDAT           = CLINE(K+1:K+1)
              CLINE(K+1:K+1) = CLINE(K+2:K+2)
              CLINE(K+2:K+2) = TDAT
          ENDDO
C         END ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE 
#endif

C         READ DATE, TIME & TITLE FROM HEADER
          CDAT    = CLINE(1:9) // ' '
          CTIM    = CLINE(13:20) 
          CTIT    = CLINE(21:180)
          LENTIT  = MAX(0,(INDEX(CTIT,NULL)-1))

#ifndef SP_VMS
C         ON UNIX, REOPEN THE FILE WITH FINAL RECORD LENGTH
          IF (INLNED .EQ. 0) THEN
             CLOSE(LUN)
#ifdef __osf__
C            ALPHA OSF (UNIX) SPECIFIC STATEMENTS FOLLOW
C            RECL IS IN UNITS OF FLOATS ON OSF
             LENREC = NSAM 
	     OPEN(LUN,FILE=FILNM,STATUS='OLD',FORM='UNFORMATTED',
     &             ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
#else
C            NON ALPHA OSF (UNIX) SPECIFIC STATEMENTS FOLLOW
C            RECL IS IN UNITS OF BYTES 
             LENREC = NSAM * 4
	     OPEN(LUN,FILE=FILNM,STATUS='OLD',FORM='UNFORMATTED',
     &             ACCESS='DIRECT',IOSTAT=IER,RECL=LENREC)
#endif
             IF (IER .NE. 0) THEN        
                WRITE(NOUT,*) '*** ERROR REOPENING FILE: ',FILNM(1:NLET)
                CALL ERRT(100,'OPENFB',NE)
                RETURN
             ENDIF
          ENDIF
#endif
d285 2
a286 2
C         SET HEADER RECORD OFFSET IN LUNARA
          LUNARA(LUN) = LABREC
d288 1
a288 1
          DSP = 'O'
d291 1
a291 1
           CALL ERRT(101,'PGM. ERROR: UNKNOWN DISP FOR OPENFB',NE)
d295 3
a297 1
2000	IF (IFORM .EQ. -2) THEN
d311 2
d314 2
d322 4
a325 5
C         PRINT FILE OPENING INFORMATION
          IF (LENTIT .LE. 0) THEN
             WRITE(NOUT,*) FILNM(:NLET)
          ELSEIF (LENTIT + NLET .LT. 70) THEN
             WRITE(NOUT,*) FILNM(:NLET),'     /',CTIT(:LENTIT)
a326 1
             WRITE(NOUT,*) FILNM(:NLET)
d328 3
a330 2
             WRITE(NOUT,*) CTIT(1:LENT)
             IF (LENTIT .GT. 80)  WRITE(NOUT,*) CTIT(81:LENTIT)
d334 3
a336 5
             WRITE(NOUT,2098) TYPE,NSAM,NROW,NSLICE,CDAT,CTIM,DSP,
     &                        LABBYT
2098	     FORMAT(' (',A,')',3I5,' CREATED ',A,' AT ',A,2X,A,
     &             ' HEADER BYTES:',I5)

d338 3
a340 3
             WRITE(NOUT,2099)TYPE,NSAM,NROW,CDAT,CTIM,DSP,LABBYT
2099         FORMAT(' (',A,')',2I5,' CREATED ',A,' AT ',A,2X,A,
     &             ' HEADER BYTES:',I5)
d357 2
@


1.35
log
@set openinln for old file to 0 words wanted
@
text
@d5 4
a8 1
C                                           LONG FILENAMES
d21 1
a21 1
C    PURPOSE:       TO OPEN A NEW OR  EXISTING DATA FILE FOR RANDOM 
d33 1
a33 1
C                   'O'   -     THE FILE IS ASSUMED TO EXIST; NSAM AND
d36 1
a36 1
C                   'R'   -     THE FILE IS ASSUMED TO EXIST; NSAM AND
d41 7
a47 10
C                   'U'    - IT IS NOT KNOWN IF THE FILE EXISTS.  
C                                 IF IT DOES NOT EXIST, NON-ZERO NSAM &
C                               NROW VALUES HAVE TO BE AVAILABLE; THE
C                               FILE IS CREATED WITH THESE DIMENSIONS.
C                               HEADER INFO IS COPIED INTO FILE FROM
C                               COMMON/MASTER/.
C                                 IF THE FILE ALREADY EXISTS, IT WILL BE 
C                               REPLACED.  HEADER INFO IN THE FILE IS 
C                               REPLACED BY INFO SUPPLIED IN:
C                               COMMON/MASTER/.
d54 1
a54 1
C                               NSAM*NROW ELEMENTS. IF NSLICE IS <0 
d59 2
a60 2
C    CODING:   BASED ON NEW OR OLD PICTURE PARAMETERS NSAM,NROW, A
C              NEW FILE IS OPENED WITH IREC RECORDS, EACH NSAM*4 
d62 1
a62 2
C              AN EXTRA PLANE FOR FOURIER OVERSPILL, PLUS NORMAL
C              PICTURE HEADER.
a71 3
C               -1    F     2-D FOURIER TRANSFORM
C               -3    F3    3-D FOURIER TRANSFORM
C               -7    FQ    3-D FOURIER TRANSFORM, PAUL'S FORMAT
d231 7
d248 1
a248 7
          IREC = NROW*NSLICE + LABREC
C         ADDITIONAL SPACE NEEDED FOR FOURIER RECORDS IS ALWAYS 
C         REQUESTED AS SOME FOURIER ROUTINES OVERWRITE EXISTING
C         FILES.  THIS IS AN UNSOLVED PROBLEM FOR INLINE FILES
          ITOP = IREC + ((NSAM + 2) * NROW) 
          IREC = IREC + ITOP / NSAM
          IF (MOD(ITOP,NSAM) .NE. 0) IREC = IREC + 1
d267 1
a267 1
             IF (IER .NE. 0) CALL LIB$SIGNAL(%VAL(IER))
d474 3
a476 3
          NSLICE   = ABS(BUF(1))+0.5
          NROW     = BUF(2)+0.5
          IREC     = BUF(3)+0.5
d478 12
a489 1
          IF (BUF(5) .LT. 0.0) IFORM = BUF(5)-0.5
d494 1
a497 6
          IF (IFORM .EQ. -1) THEN
C            ADDITIONAL SPACE NEEDED FOR FOURIER RECORDS
             ITOP    = IRECMIN + ((NSAM + 2) * NROW) 
             IRECMIN = IRECMIN + ITOP / NSAM
             IF (MOD(ITOP,NSAM) .NE. 0) IRECMIN = IRECMIN + 1
          ENDIF
d515 1
a515 1
          IMAMI    = BUF(6)+0.5
d522 1
a522 1
          IANGLE   = BUF(14)
d530 1
a530 1
          KANGLE   = BUF(30)
d602 1
a602 3
2000	IF (IFORM .EQ. -1) THEN
            TYPE = 'F '
	ELSEIF (IFORM .EQ. -2) THEN
a603 4
        ELSEIF (IFORM .EQ. -3) THEN
            TYPE = 'F3'
        ELSEIF (IFORM .EQ. -7) THEN
            TYPE = 'FQ'
@


1.34
log
@changed names for Fourier files.
@
text
@d405 2
a406 2
C            SET UP INLINE BUFFER AND TIE IT TO LUN, RETRIEVE NSAM
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,NDUM,IRTFLG)
d497 1
@


1.33
log
@added no_save
@
text
@d77 4
a80 2
C               -11   FO    2-D FOURIER TRANSFORM, MIXED RADIX ODD
C               -12   FE    2-D FOURIER TRANSFORM, MIXED RADIX EVEN
d609 1
a609 1
            TYPE = 'FO'
d611 1
a611 1
            TYPE = 'FE'
d613 1
a613 1
            TYPE = 'FO'
d615 1
a615 1
            TYPE = 'FE'
@


1.32
log
@added notes for new fourier formats
@
text
@d87 1
@


1.31
log
@bugs fixed
@
text
@d245 1
a245 1
C         FILES.  THIS IS A PROBLEM FOR INLINE FILES
d608 4
@


1.30
log
@revamped routine
@
text
@d35 2
a36 1
C                               RETURNED TO THE CALLING PROGRAM.C                               FILE IS OPENED AS READONLY - MULTIREAD
d90 1
a90 1
#ifdef SP_SUN4
d93 1
d96 1
d102 1
a102 1
        DIMENSION      BUF(*),ZBUF(45)
a104 1
        CHARACTER *180 CLINE
d110 2
a113 3
C       USE THIS WITH LIB$SIGNAL ON VAX
C       INTEGER * 4    STATUS

d135 1
a135 4
           IF (IRTFLG .NE. 0) THEN
              CALL ERRT(100,'OPENFB',NE)
              RETURN
           ENDIF
d162 1
a162 1
	  INQUIRE(FILE=FILNM,ERR=9997,EXIST=EX,RECL=NSAMO)
d164 1
a164 1
          NSAM = NSAMO / 4
d166 1
a166 1
	  INQUIRE(FILE=FILNM,ERR=9997,EXIST=EX)
d168 5
a189 1
            IER = 0
d198 3
a200 3
              WRITE(NOUT,*) '*** ERROR DELETING FILE', FILNM(1:NLET)
              CALL ERRT(100,'OPENFB',NE)
              RETURN
d206 1
a206 1
2060	    WRITE(NOUT,*) '***  RECORD INFO MISSING: ',FILNM(1:NLET)
d221 1
a221 1
C           WANT TO CREATE AN SHORT HEADER FORMAT FILE
d223 2
a224 4
C           WANT TO CREATE AN SHORT HEADER FORMAT FILE
            WRITE (NOUT,*) 
     &         '*** CAN NO LONGER CREATE OBSOLETE SHORT HEADER FILE'
            CALL ERRT(100,'OPENFB',NE)
d228 1
a229 1
            NSLICE = -NSLICE
d234 1
a234 20
C         ADJUST NUMBER OF HEADER RECORDS TO HAVE 256*4 BYTES IN HEADER
          IF (IFORM .LE. 6) THEN
C            STANDARD SPIDER FLOATING POINT FILES
             LENBYT = NSAM * 4
          ELSEIF (IFORM .EQ. 8) THEN 
C            FOR 8 BIT FILES
             LENBYT = NSAM 
          ELSEIF (IFORM .EQ. 10) THEN
C            PIXEL BY PIXEL 8 BIT COLOR IMAGE FILE
             LENBYT = NSAM * 3
          ELSEIF (IFORM .EQ. 11) THEN
C            COLOR BY COLOR 8 BIT COLOR IMAGE FILE
             LENBYT = NSAM * 3
          ELSEIF (IFORM .EQ. 12) THEN
C            8 BIT RUNLENGTH COLOR FILE
             LENBYT = NSAM * 4
          ELSEIF(IFORM .EQ. 16) THEN
C            FOR 16 BIT INTEGER FILES
             LENBYT = NSAM * 2
          ENDIF
d236 2
d241 1
a241 4
#ifdef SP_VMS
          LENREC = LENBYT / 4
          IF ((LENREC * 4) .LT. LABBYT) LENREC = LENREC + 1
#endif
d243 6
a248 7
          IF (IFORM .EQ. 11) IREC = IREC + 2 * NROW
          IF (IFORM .EQ. -1) THEN
C             ADDITIONAL SPACE NEEDED FOR FOURIER RECORDS
              ITOP = IREC + ((NSAM + 2) * NROW) 
              IREC = IREC + ITOP / NSAM
              IF (MOD(ITOP,NSAM) .NE. 0) IREC = IREC + 1
          ENDIF
d254 4
a257 2
             NBLOCK = FLOAT(LENREC) / 512.0 * FLOAT(IREC) + 1.0
             IF (IFORM .EQ. 8) NBLOCK = NBLOCK / 4 + 1
d259 1
a259 1
     &          ACCESS='DIRECT',FORM='UNFORMATTED',ERR=9999,
d261 2
a262 1
     &          RECL=LENREC,INITIALSIZE=NBLOCK)
d264 4
a267 7
C               REPLACE PREVIOUS LINE BY THE NEXT 2 LINES, IF YOU NEED
C               MORE INFO ON THE ERROR OF OPEN.
C               THE CALL TO LIB$SIGNAL STOPS THE PROGRAM AND PRINTS
C               AN INFORMATIVE ERROR MESSAGE.
C        &      IOSTAT=STATUS)
C               IF(STATUS.NE.0) CALL LIB$SIGNAL(%VAL(STATUS))
#endif
d269 1
a269 1
C            RECL IS IN UNITS OF BYTES ON SGI, FLOATS ON OSF & VAX
d271 4
a274 2
C            ONE LINE OF OSF UNIX SPECIFIC CODE FOLLOWS
             LABBY8 = LABBYT / 4
d276 4
a279 2
C            ONE LINE OF NON OSF UNIX SPECIFIC CODE FOLLOWS
             LABBY8 = LABBYT
d281 7
a287 2
	     OPEN(LUN,FILE=FILNM,STATUS='NEW',FORM='UNFORMATTED',
     &       ACCESS='DIRECT',ERR=9999,RECL=LABBY8)
d292 1
a292 4
             IF (IRTFLG .NE. 0) THEN
                CALL ERRT(100,'OPENFB',NE)
                RETURN
             ENDIF
d295 3
d299 1
d372 1
a379 1
#ifdef SP_VMS
d381 3
a383 3
          DO I =1,LABREC
             CALL WRTLIN(LUN,BUF(ILOC),LABBYT,I)
             ILOC = ILOC + LABBYT
a384 2
#else
          CALL WRTLIN(LUN,BUF,256,1)
d389 4
a392 15
C         REOPEN THE FILE WITH FINAL LENGTH
          IF (INLNED .EQ. 0) THEN
             CLOSE(LUN)
#ifdef __osf__
C            ALPHA OSF (UNIX) SPECIFIC STATEMENT FOLLOWS
             LENBY8 = LENBYT / 4
#else
C            NON ALPHA OSF (UNIX) SPECIFIC STATEMENT FOLLOWS
             LENBY8 = LENBYT 
#endif
	     OPEN(LUN,FILE=FILNM,STATUS='OLD',FORM='UNFORMATTED',
     &             ACCESS='DIRECT',ERR=9999,RECL=LENBY8)
           ENDIF
#endif
           GOTO 2000
d396 2
a397 1
C         -----------------------------------------------------------OLD
d401 7
d409 2
a410 2
          IF (INLNED .EQ. 0) THEN
C            REGULAR FILE ACCESS
d412 4
a415 2
               OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',RECORDTYPE='FIXED',
     1         ACCESS='DIRECT',ERR=9999)
d418 4
a421 2
               OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',RECORDTYPE='FIXED',
     1         READONLY,ACCESS='DIRECT',ERR=9999)
d423 2
a424 4
          ELSE
C            SET UP INLINE BUFFER AND TIE IT TO LUN, RETRIEVE NSAM
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,NDUM,IRTFLG)
             IF (IRTFLG .NE. 0) THEN
a427 1
          ENDIF
a428 1
          IF (INLNED .EQ. 0) THEN
d431 3
a433 5
     &           FORM='UNFORMATTED',RECL=1024,ERR=9999)
          ELSE
C            INLINE FILE BUFFER ACCESS
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,NDUM,IRTFLG)
             IF (IRTFLG .NE. 0) THEN
d437 1
a438 1
#endif
d445 1
a445 1
C         FIND NUMBER OF RECORDS IN LONG FORMAT HEADER
d461 1
a461 1
             WRITE(NOUT,*) 'USE "COPY FROMSHORT" TO CONVERT.'
a462 1
             RETURN
d465 1
a465 1
C         ALL OF HEADER READ IN ON UNIX IN ONE READ
d480 3
a485 1
          IF (IFORM .EQ. 11) IRECMIN = IRECMIN + 2 * NROW
a495 2
          LENBYT = BUF(23)
          IF (LENBYT .LE. 0) LENBYT = NSAM * 4
d500 1
a500 2
          IF (LABRECT .LE. 0 .OR. (IFORM .LT. 7 .AND. 
     &       LABREC .NE. LABRECT)) THEN
a503 2

          LABBYT = BUF(22)
d506 2
a507 1
C         BUF(4) USED TO CONTAIN HHISTREC
d535 5
a542 1
    
d560 2
a561 7
          DO  I = 1,45 
             ZBUF(I) = BUF(I+211) 
          ENDDO

C         SET HEADER RECORD OFFSET IN LUNARA
          LUNARA(LUN) = LABREC

d563 1
a563 1
C            REGULAR FILE ACCESS
d565 5
a569 2
C            ALPHA OSF/1 UNIX SPECIFIC STATEMENT FOLLOWS
             LENBY8 = LENBYT/4
d571 5
a575 2
C            NON ALPHA OSF/1 UNIX SPECIFIC STATEMENT FOLLOWS
             LENBY8 = LENBYT
d577 5
a581 3
             CLOSE (LUN)
             OPEN(LUN,FILE=FILNM,STATUS='OLD',ACCESS='DIRECT',
     &         FORM='UNFORMATTED',RECL=LENBY8,ERR=9999)
d583 4
d591 1
a591 2
           WRITE(NOUT,*)'*** PGM. ERROR: UNKNOWN DISP FOR OPENFB'
           CALL ERRT(100,'OPENFB',NE)
a612 10
        ELSEIF (IFORM .EQ. 8)  THEN
            TYPE = '8 '
        ELSEIF (IFORM .EQ. 10) THEN
            TYPE = 'CP'
        ELSEIF (IFORM .EQ. 11) THEN
            TYPE = 'CC'
        ELSEIF (IFORM .EQ. 12) THEN
            TYPE = 'CR'
        ELSEIF (IFORM .EQ. 16) THEN
            TYPE = '16'
a652 8
        RETURN

9997    WRITE(NOUT,*) '*** FILE INQUIRY ERROR: ',FILNM(1:NLET)
        CALL ERRT(100,'OPENFB',NE)
        RETURN

9999    WRITE(NOUT,*) '*** ERROR OPENING FILE',FILNM(1:NLET)
        CALL ERRT(100,'OPENFB',NE)
@


1.29
log
@removed short label stuff
@
text
@d16 1
a16 1
C    OPENFb(BUFFILNAM,LUN,NSAM,NROW,DISP,NF,NSLICE)
d22 1
a22 1
C        BUF        WORKING BUFFER
d31 1
a31 1
C                               NROW AND LABEL INFO (IN COMMON) ARE 
d34 1
a34 1
C                               NROW AND LABEL INFO (IN COMMON) ARE 
d41 1
a41 1
C                               LABEL INFO IS COPIED INTO FILE FROM
d44 1
a44 1
C                               REPLACED.  LABEL INFO IN THE FILE IS 
d54 3
a56 2
C                               (ON VMS VERSION) A SHORT LABEL 
C                               FORMAT FILE IS DESIRED.
d59 2
a60 2
C              NEW FILE IS OPENED WITH IREC RECORDS, EACH NSAM*2 
C              WORDS LONG.  IREC ALLOWS SPACE FOR THE 3-D DISTRIBUTION,
d62 1
a62 1
C              PICTURE LABEL.
d68 3
a70 3
C               +8     8    8 BIT BLACK AND WHITE FILE
C               +11    C    8 BIT COLOR FILE
C               +12   -     8 BIT RUNLENGTH BLACK AND WHITE FILEC
d87 1
a87 2
        COMMON /LUNARA/ LUNARA(100),LASLAB,NOFFSET,LUNOFF(100),
     &                  LUNFORM(100)
d106 2
a107 4

	LOGICAL        EX,NEWDAT,SPIFIL
        LOGICAL*2      L2TIM(4),L2DAT(5),L2TIT(20)
        EQUIVALENCE    (CDAT,L2DAT),(CTIM,L2TIM),(CTIT,L2TIT)
a108 1
        EQUIVALENCE    (HEAD2,IHEAD2)
d116 4
a122 1
        SPIFIL = .TRUE.
d126 1
a126 1
     &     ' *** PGM. ERROR: LUN MUST BE 1...100, SET TO 99'
d130 1
a130 1
C	CHECK IS USER WANTS TO USE THE INLINED BUFFER.
d134 4
a137 1
           IF (IRTFLG .NE. 0) RETURN
d143 1
a143 1
	   END IF
a145 3
C          SET RECORD LENGTH FOR READING HEADER (VAX/VMS)
           NSAMO = 256

d156 4
a159 1
	      IF (IER .NE.0) RETURN
d161 2
d164 3
a166 2
	   INQUIRE(FILE=FILNM,ERR=2096,EXIST=EX,RECL=NSAMO)
           NSAMO = NSAMO / 4
d168 1
a168 1
	   INQUIRE(FILE=FILNM,ERR=9997,EXIST=EX)
d175 2
a176 1
           WRITE(NOUT,*) ' *** NOT FOUND: ',FILNM(1:NLET)
d181 1
a181 1
C         USER WANTS A NEW FILE TO WRITE INTO ------------------------NEW
d185 1
a185 3
C           BE REPLACED.  OLD FILES ARE DELETED TO AVOID PROBLEMS WITH
C           CHANGE OF LENGTH DUE TO SHORT LABEL FORMAT UPON OVERWRITING IF
C           THE FILE WAS ORIGINALLY WRITTEN WITH LONG LABEL FORMAT
d196 2
a197 1
              WRITE(NOUT,*) '*** ERROR DELETING FILE',FILNM(1:NLET)
d204 2
a205 1
2060	    WRITE(NOUT,*) ' ***  RECORD INFO MISSING: ',FILNM(1:NLET)
d210 2
a211 2
2080        WRITE(NOUT,2081) NSAMAX
2081        FORMAT(' *** ROWLENGTH MUST BE <=:',I6/)
d219 1
a219 1
C           WANT TO CREATE AN SHORT LABEL FORMAT FILE
d221 1
a221 1
C           WANT TO CREATE AN SHORT LABEL FORMAT FILE
d223 2
a224 1
     &         'CAN NO LONGER CREATE OBSOLETE SHORT LABEL FILE'
d227 1
a227 1
            WRITE(NOUT,*)' WARNING:  NO SHORT LABEL FILES ON UNIX'
d232 1
a232 3
          NHISTREC = 256 / NSAM + 1
          IF (IFORM .EQ. 0 .OR. IFORM .EQ. -2) NHISTREC = -NROW*2/NSAM
          DSP    = 'N'
d234 1
a234 1
C         ADJUST NUMBER OF LABEL RECORDS TO HAVE 256*4 BYTES IN LABEL
a257 1
          LASLAB = LABREC
d262 1
a262 1
          IREC = NROW*NSLICE + NHISTREC + LABREC
d304 4
a307 1
             IF (IRTFLG .NE. 0) RETURN
d313 2
a314 1
          BUF(4) = NHISTREC
d320 2
a321 2
C              ZERO UNUSED BUF VARIABLES
               BUF(K)=0
d388 1
a388 1
          LUNARA(LUN) = 1
d392 1
a392 1
          DO I =0,LABREC-1
d395 1
a395 2
           ENDDO
 
d397 5
a401 1
          CALL WRTLIN(LUN,BUF,256,0)
a402 1

a411 1

a415 4


C          SET FINAL LUNARA OFFSET VALUE FOR USE BY REDLIN/WRTLIN
           LUNARA(LUN) = LABREC
d422 1
a422 1
C         RETRIEVE ALL LABEL INFO
d424 1
a426 2

#ifdef SP_VMS
d436 6
a441 3
C            SET UP INLINE BUFFER AND TIE IT TO LUN, RETRIEVE NSAMO
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAMO,NDUM,IRTFLG)
             IF (IRTFLG .NE. 0) RETURN
d444 2
d451 5
a455 1
             IF (IRTFLG .NE. 0) RETURN
a456 1
     	  ENDIF
d459 1
a459 1
          LUNARA(LUN) = 1
d461 1
d463 20
a482 2
C         FIRST RECORD OF HEADER READ IN ON VAX/VMS
          CALL REDLIN(LUN,BUF,NSAMO,0)
d484 2
a485 2
C         ALL OF HEADER READ IN ON UNIX
          CALL REDLIN(LUN,BUF,256,0)
d487 2
a488 2
             WRITE(NOUT,9002) FILNM(:NLET)
9002         FORMAT(' *** ERROR READING: ',A)
a492 57
C         CHECK FOR RAW IMAGE FILE
          HEAD2 = BUF(2)

          IF ((BUF(12) .LT. 1.0 .OR. BUF(12) .GT. 50000.0) .OR.
     &        (BUF(2)  .LT. 1.0 .OR. BUF(2)  .GT. 50000.0) .OR.
     &        (BUF(5)  .LT. -20.0 .OR. BUF(5)  .GT. 20.0) .OR.
     &        (IHEAD2  .EQ. -1  )) THEN
C             ASSUME THIS IS A DUMPED RAW 8 BIT IMAGE

              IF (DISP .NE. 'K' .OR. (NSAM .LE. 0 .OR.
     &            NROW .LE. 0 .OR. NSLICE .LE. 0)) THEN

33              CALL RDPRI3S(NSAM,NROW,NSLICE,NLOOP,ILOOP,
     &              'ENTER COLUMNS, ROWS AND SLICES IN IMAGE',
     &               IRTFLG)
                IF (IRTFLG .EQ. -1) RETURN

                CALL RDPRIS(NOFFSET,IDUM,NLOOP,ILOOP,
     &               'ENTER HEADER OFFSET (BYTES)',IRTFLG)
                IF (IRTFLG .EQ. -1) GOTO 33
              ENDIF

              IFORM  = 8
              IREC   = NROW * NSLICE 
              LENBYT = NSAM
              LABREC = 0
              LABBYT = NOFFSET
C             DO NOT SET NORMALIZATION NEEDED FLAG
              IMAMI  = 1
              FMIN   = 0.0
              FMAX   = 255.0
              AV     = 0.0
              SIG    = 0.0
              IHIST  = 0
              SPIFIL = .FALSE.
              GOTO 1050
          ENDIF

#ifdef SP_VMS
          IF (BUF(1) .LT. 0) THEN
C           A NEGATIVE VALUE FOR NSLICE IS FLAG FOR LONG LABEL FORMAT
C           FIND NUMBER OF RECORDS IN LONG FORMAT LABEL
            LABREC = 256 / NSAM
            IF (MOD(256,NSAM) .NE. 0) LABREC = LABREC + 1

C           READ IN REST OF LONG FORMAT LABEL
            ILOC = NSAM + 1
            DO I = 1,LABREC-1
               CALL REDLIN(LUN,BUF(ILOC),NSAM,I)
               ILOC = ILOC + NSAM
            ENDDO
	    
 	    LUNARA(LUN) = LABREC
            LASLAB = LABREC
          ENDIF
#endif

a498 1
          NHISTREC = BUF(4)+0.5
d501 1
a501 1
          IRECMIN = NROW * NSLICE + NHISTREC + LABREC
d504 4
a507 4
C             ADDITIONAL SPACE NEEDED FOR FOURIER RECORDS
              ITOP    = IRECMIN + ((NSAM + 2) * NROW) 
              IRECMIN = IRECMIN + ITOP / NSAM
              IF (MOD(ITOP,NSAM) .NE. 0) IRECMIN = IRECMIN + 1
a509 1

d512 1
d515 2
a516 2
          LABREC = BUF(13)
        
a518 1
           
d520 3
a522 3
     &        LABREC .NE. LABRECT)) THEN
C             UNREASONABLE LABREC NUMBER SO DEFAULT IT
              LABREC = LABRECT
a523 1
          LASLAB = LABREC
d528 23
a550 24
          IMAMI  = BUF(6)+0.5
          FMAX   = BUF(7)
          FMIN   = BUF(8)
          AV     = BUF(9)
          SIG    = BUF(10)
          IHIST  = BUF(11)+0.5

C         READ LONG LABEL FORMAT VARIABLES
          LABLEN= BUF(13)
          IANGLE = BUF(14)
          PHI    = BUF(15)
          THETA  = BUF(16)
          PSI    = BUF(17)
          XOFF   = BUF(18)
          YOFF   = BUF(19)
          ZOFF   = BUF(20)
          SCALE  = BUF(21)
          KANGLE = BUF(30)
          PHI2   = BUF(31)
          THETA2 = BUF(32)
          PSI2   = BUF(33)
          PHI1   = BUF(34)
          THETA1 = BUF(35)
          PSI1   = BUF(36)
d553 1
a553 1
               HDR_VALS(I) = BUF(36+I)
d561 2
a562 2
              TDAT = CLINE(K:K)
              CLINE(K:K) = CLINE(K+3:K+3)
d564 1
a564 1
              TDAT = CLINE(K+1:K+1)
d567 1
a567 1
          END DO
d571 1
a571 1
C         READLABEL FORMAT DATE, TIME & TITLE
d578 1
a578 1
            ZBUF(I) = BUF(I+211) 
d581 2
a582 7
1050      IF (NOFFSET .EQ. 0 .AND. .NOT. SPIFIL) THEN
             LUNARA(LUN) = -LABREC
          ELSE
             LUNARA(LUN) = LABREC
          ENDIF
          LUNOFF(LUN)  = NOFFSET
          LUNFORM(LUN) = IFORM
d598 1
a598 1
          DSP    = 'O'
d601 3
a603 2
          WRITE(NOUT,*)'*** PGM. ERROR: UNKNOWN DISP FOR OPENFB'
          RETURN
a638 1

d641 1
a641 1
            WRITE(NOUT,9091) FILNM(:NLET)
d643 1
a643 2
            WRITE(NOUT,9090) FILNM(:NLET),CTIT(:LENTIT)
9090        FORMAT(' ',A,'     /',A)
d645 4
a648 7
            WRITE(NOUT,*) FILNM(:NLET)
            LENT = MIN(80,LENTIT)
            WRITE(NOUT,9091) CTIT(1:LENT)
9091        FORMAT(' ',A)
            IF (LENTIT .GT. 80) THEN
              WRITE(NOUT,9091) CTIT(81:LENTIT)
            ENDIF
d651 4
a654 9
          IF (.NOT. SPIFIL) THEN
            WRITE(NOUT,2097) TYPE,NSAM,NROW,LABBYT
2097	    FORMAT(' (',A,')',2I5,' NON-SPIDER FILE,  ',
     &             'HEADER BYTES:',I5)

          ELSEIF (NSLICE .GT. 1) THEN
            WRITE(NOUT,2098) TYPE,NSAM,NROW,NSLICE,CDAT,CTIM,DSP,
     &      LABBYT
2098	    FORMAT(' (',A,')',3I5,' CREATED ',A,' AT ',A,2X,A,
d658 2
a659 2
            WRITE(NOUT,2099)TYPE,NSAM,NROW,CDAT,CTIM,DSP,LABBYT
2099        FORMAT(' (',A,')',2I5,' CREATED ',A,' AT ',A,2X,A,
d677 1
a677 3
        RETURN

9998    WRITE(NOUT,*) '*** ERROR READING FILE'
d680 2
a681 1
9999    WRITE(NOUT,*) '*** ERROR OPENING FILE'
@


1.28
log
@merged vax and unix
@
text
@d107 1
a107 1
	LOGICAL        EX,NEWFMT,NEWDAT,SPIFIL
a118 5
        NEWDAT = .TRUE.
#ifdef SP_VMS
        IF (NF .LT. 0) NEWDAT = .FALSE.
#endif

a195 1
          NEWFMT = .TRUE.
d214 5
a219 3
#else
C           WANT TO CREATE AN SHORT LABEL FORMAT FILE
            NEWFMT = .FALSE.
d228 15
a242 29
          IF (NEWFMT) THEN
C            WANT TO CREATE A LONG LABEL FORMAT FILE
C            ADJUST NUMBER OF LABEL RECORDS TO HAVE 256*4 BYTES IN LABEL
             IF (IFORM .LE. 6) THEN
C               STANDARD SPIDER FLOATING POINT FILES
                LENBYT = NSAM * 4
             ELSEIF (IFORM .EQ. 8) THEN 
C               FOR 8 BIT FILES
                LENBYT = NSAM 
             ELSEIF (IFORM .EQ. 10) THEN
C               PIXEL BY PIXEL 8 BIT COLOR IMAGE FILE
                LENBYT = NSAM * 3
             ELSEIF (IFORM .EQ. 11) THEN
C               COLOR BY COLOR 8 BIT COLOR IMAGE FILE
                LENBYT = NSAM * 3
             ELSEIF (IFORM .EQ. 12) THEN
C               8 BIT RUNLENGTH COLOR FILE
                LENBYT = NSAM * 4
             ELSEIF(IFORM .EQ. 16) THEN
C               FOR 16 BIT INTEGER FILES
                LENBYT = NSAM * 2
             ENDIF

             LABREC = 1024 / LENBYT
             IF (MOD(1024,LENBYT) .NE. 0) LABREC = LABREC + 1
             LABBYT = LABREC * LENBYT
             LASLAB = LABREC
          ELSE
C            WANT TO CREATE A SHORT LABEL FORMAT FILE
d244 3
a246 3
             LABREC = 1
             LABBYT = LABREC * LENBYT
             LASLAB = 0
d248 5
a265 1

d270 1
a270 1
             NBLOCK = FLOAT(LABBYT) / 512.0 * FLOAT(IREC) + 1.0
d275 1
a275 1
     &          RECL=LABBYT,INITIALSIZE=NBLOCK)
d285 1
a285 1
C            RECL IS IN UNITS OF BYTES ON SGI, FLOATS ON OSF
d310 1
a310 3
          IF (NEWFMT) THEN
C           A NEGATIVE NSLICE IS FLAG FOR SHORT LABEL FORMAT
            DO K= 6,212
d313 1
a313 1
            ENDDO
d315 42
a356 40
            BUF(12) = NSAM
            BUF(13) = LABREC
#ifdef SP_VMS
            BUF(22) = LABREC * LABBYT * 4
            BUF(23) = LABBYT * 4
#else
            BUF(22) = LABBYT
            BUF(23) = LENBYT
#endif

C           ADDED JULY 88 al
            IF (IANGLE .NE. 0) THEN
               BUF(14) = IANGLE
               BUF(15) = PHI
               BUF(16) = THETA
               BUF(17) = PSI
            ENDIF

            IF (KANGLE .NE.0) THEN
               BUF(30) = KANGLE
               BUF(31) = PHI2
               BUF(32) = THETA2
               BUF(33) = PSI2
               BUF(34) = PHI1
               BUF(35) = THETA1
               BUF(36) = PSI1
            ENDIF

C           COPY MOST RECENT HDR_VALS INTO LOCATIONS 37..101
            DO I = 1,64
               BUF(36+I) = HDR_VALS(I)
            ENDDO

            IF (NEWDAT) THEN
               CALL DATE(CDAT)
               CALL TIME(CTIM)
            ENDIF

C           DATE TAKES 2 & 1/4 FLOATING POINT VARIABLES IN BUF (9 CHAR)
            CLINE(1:12)  = CDAT(1:9) // '   '
a357 7
C           TIME TAKES 2 FLOATING POINT VARIABLES IN BUF (8 CHAR.)
            CLINE(13:20) = CTIM(1:8)

C           TITLE TAKES 40 FLOATING POINT VARIABLES IN BUF (160 CHAR)
            CLINE(21:180) = CTIT(1:160)
            LENTIT        = MAX(0,(INDEX(CTIT,NULL) -1))

d359 1
a359 1
C           ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE FOLLOWS
d361 3
a363 3
C           NOTE THAT THE ALPHA-NUMERICAL DATA (ABCD) WILL BE WRITTEN 
C           IN INVERTED ORDER (DCBA)
            DO K = 1, 180, 4
d370 2
a371 2
            END DO
C           END ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE
d374 3
a376 3
            DO  I = 1,45 
               BUF(I+211) = ZBUF(I) 
            ENDDO
d378 2
a379 2
C           WRITE HEADER RECORDS INTO FILE	    
            LUNARA(LUN) = 1
d382 5
a386 5
            ILOC = 1
            DO I =0,LABREC-1
              CALL WRTLIN(LUN,BUF(ILOC),LABBYT,I)
              ILOC = ILOC + LABBYT
            ENDDO
d389 2
a390 2
            CALL WRTLIN(LUN,BUF,256,0)
C           REOPEN THE FILE WITH FINAL LENGTH
d392 2
a393 2
            IF (INLNED .EQ. 0) THEN
               CLOSE(LUN)
d395 2
a396 2
C              ALPHA OSF (UNIX) SPECIFIC STATEMENT FOLLOWS
               LENBY8 = LENBYT/4
d398 2
a399 2
C              NON ALPHA OSF (UNIX) SPECIFIC STATEMENT FOLLOWS
               LENBY8 = LENBYT 
d402 1
a402 1
	       OPEN(LUN,FILE=FILNM,STATUS='OLD',FORM='UNFORMATTED',
d404 1
a404 1
             ENDIF
d408 3
a410 24
C            SET FINAL LUNARA OFFSET VALUE FOR USE BY REDLIN/WRTLIN
             LUNARA(LUN) = LABREC
             GOTO 2000

           ELSE
             CONTINUE
#ifdef SP_VMS
C           CREATE AN SHORT LABEL FORMAT FILE

            BUF(1) = NSLICE

            IF (NEWDAT) THEN
C              GET NEW DATE AND TIME FOR FILE
               CALL DATE(CDAT)
               CALL TIME(CTIM)
            ENDIF

            DO I=1,5
              BUF(11+I)=L2DAT(I)
            ENDDO
            DO I=1,4
              BUF(16+I)=L2TIM(I)
            ENDDO
            LENTIT = MIN(40,(INDEX(CTIT,NULL)-1))
a411 8
            DO I=1,20
              BUF(20+I)=L2TIT(I)
            ENDDO
	    
            LUNARA(LUN) = 1
            CALL WRTLIN(LUN,BUF,NSAM,0)
#endif
          ENDIF
a501 1
            NEWFMT = .TRUE.
d563 17
a579 18
          IF (NEWFMT) THEN
C           READ LONG LABEL FORMAT VARIABLES
            LABLEN= BUF(13)
            IANGLE = BUF(14)
            PHI    = BUF(15)
            THETA  = BUF(16)
            PSI    = BUF(17)
            XOFF   = BUF(18)
            YOFF   = BUF(19)
            ZOFF   = BUF(20)
            SCALE  = BUF(21)
            KANGLE = BUF(30)
            PHI2   = BUF(31)
            THETA2 = BUF(32)
            PSI2   = BUF(33)
            PHI1   = BUF(34)
            THETA1 = BUF(35)
            PSI1   = BUF(36)
d581 1
a581 1
            DO I = 1,64
d583 1
a583 1
            ENDDO
d586 2
a587 2
C           ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE FOLLOWS
C           NOTE THAT ALPHA-NUMERICAL DATA (ABCD) WILL BE WRITTEN (DCBA)
d589 1
a589 1
            DO K = 1, 180, 4
d596 2
a597 2
            END DO
C           END ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE 
d600 9
a608 51
C           READ LONG LABEL FORMAT DATE, TIME & TITLE
            CDAT    = CLINE(1:9) // ' '
            CTIM    = CLINE(13:20) 
            CTIT    = CLINE(21:180)
            LENTIT  = MAX(0,(INDEX(CTIT,NULL)-1))

            DO  I = 1,45 
              ZBUF(I) = BUF(I+211) 
            ENDDO

#ifdef SP_VMS
          ELSE
C           READ SHORT LABEL FORMAT DATE, TIME & TITLE
            LENTIT = 0
            IF (IFORM .EQ. -1 .OR. IFORM .EQ. -3 .OR. IFORM .EQ. -5
     &         .OR. IFORM .EQ. -7 .OR. IFORM .EQ. -9)  THEN
C              RECOVER FOURIER ANGLES FROM FMAX AND FMIN
               IANGLE = IMAMI
               PHI    = FMAX
               THETA  = FMIN
               SCALE  = AV
            ENDIF

            IF (NSAM .GT. 16) THEN
C             FULL DATE AVAILABLE
              DO I=1,5
                L2DAT(I) = BUF(11+I)+0.5
              ENDDO
              CDAT(10:10) = ' '
            ELSE
              CDAT = '         '
            ENDIF

            IF (NSAM .GT. 20) THEN
C             TIME AND AT LEAST SOME TITLE ARE AVAILABLE              
              DO I=1,4
                L2TIM(I) = BUF(16+I) + 0.5
              ENDDO
              DO I=1,20
                L2TIT(I) = BUF(20+I) + 0.5
              ENDDO
              LENTIT = MIN(40,(INDEX(CTIT,NULL)-1))

            ELSE
C             TIME NOT AVAILABLE IN SHORT LABEL LENGTH
              CTIM   = '        '
              CTIT   = '          '
              LENTIT = 0
            ENDIF
#endif
          ENDIF
a687 1
#ifdef SP_VMS
a688 4
          IF (.NOT. NEWFMT) THEN
            WRITE(NOUT,*)' OBSOLETE, SHORT LABEL SPIDER FILE!'
          ENDIF 
#endif
@


1.27
log
@gamma -> psi
@
text
@d5 1
a5 1
C                                          
d16 1
a16 1
C    OPENFB(BUF,FILNAM,LUN,NSAM,NROW,DISP,NF,NSLICE)
d26 1
a26 1
C                   OF OPEN, DEPENDING ON DISP.
d35 1
a35 2
C                               RETURNED TO THE CALLING PROGRAM.
C                               FILE IS OPENED AS READONLY - MULTIREAD
d41 1
a41 1
C		                LABEL INFO IS COPIED INTO FILE FROM
d52 1
a52 1
C	 NSLICE	                NUMBER OF PLANES, EACH CONTAINING 
d60 1
a60 1
C	       AN EXTRA PLANE FOR FOURIER OVERSPILL, PLUS NORMAL
d65 1
a65 1
C	        +1     R    2-D IMAGE
d69 2
a70 2
C               +12   -     8 BIT RUNLENGTH BLACK AND WHITE FILE
C               +16   16    16 BIT BLACK AND WHITE FILE
d81 1
a81 1
#ifdef SP_VMS
d83 2
a84 1
C       VMS SPECIFIC FILE FOLLOWS ***********************************
d86 2
a87 1
	SUBROUTINE OPENFB(BUF,FILNAM,LUN,NSAM,NROW,DISP,NF,NSLICE)
d89 5
a93 2
        INCLUDE 'COMMON1:CMBLOCK.INC'
        INCLUDE 'COMMON1:LABLOCK.INC'
a94 2
	DIMENSION  BUF(*),ZBUF(45)
        COMMON /LUNARA/ LUNARA(100),LASLAB
a95 1
        INTEGER * 4     LOCLUN
d97 1
a97 1
        COMMON /IOERR/IERR
d99 2
d105 1
a105 1
        CHARACTER * 1  NULL,DSP,DISP,FLEN
d107 1
a108 1
	LOGICAL        EX,NEWFMT,NEWDAT
d111 1
d113 4
a118 2
        NULL   = CHAR(0)

d120 1
d122 2
d125 4
a128 3
        NF   = 1
        IERR = 0
        
d130 2
a131 1
           WRITE(NOUT,*) '*** PGM. ERROR: LUN SET TO 99'
d136 1
d148 1
a148 1
C          SET RECORD LENGTH FOR READING HEADER
d163 1
a163 1

d165 4
a168 1
	   NSAMO = NSAMO / 4
d171 2
a172 2
	IF (.NOT.EX.AND.
     &     (DISP .EQ. 'O' .OR. DISP .EQ. 'R' .OR. DISP .EQ. 'M')) THEN
d174 1
a174 3

2096       WRITE(NOUT,2051) FILNM(1:NLET)
2051       FORMAT(' *** NOT FOUND: ',A)
d179 1
a179 1
C         USER WANTS A NEW FILE TO WRITE INTO --------------------- NEW
d188 1
d191 4
d196 1
a196 1
              WRITE(NOUT,*) '*** ERROR DELETING FILE'
d204 1
a204 2
2060	    WRITE(NOUT,2061) FILNM(1:NLET)
2061        FORMAT(' ***  RECORD INFO MISSING: ',A)
d210 1
a210 1
2081        FORMAT(' *** ROWLENGTH MUST BE <=:',I6)
d219 4
d224 1
d233 1
a233 1
C            WANT TO CREATE A NEW LONG LABEL FORMAT FILE
d235 18
a252 7
             IF (IFORM .EQ. 8 .OR. IFORM .EQ. 11) THEN
C              FOR 8 BIT FILES
               LENREC = NSAM / 4
               IF ((LENREC * 4) .LT. NSAM) LENREC = LENREC + 1
             ELSE
C              FOR NORMAL 32 BIT SPIDER FILES
               LENREC = NSAM
d254 4
a257 2
             LABREC  = 256 / LENREC
             IF (MOD(256,LENREC) .NE. 0) LABREC = LABREC + 1
d260 2
a261 1
C            WANT TO CREATE AN SHORT LABEL FORMAT FILE
d263 1
a263 1
             LENREC = NSAM
d266 5
a270 2

          IREC = NROW * NSLICE + NHISTREC + LABREC
d279 4
a282 1
          IF (INLNED .EQ. 0) THEN
d284 1
a284 1
             NBLOCK = FLOAT(LENREC) / 512.0 * FLOAT(IREC) + 1.0
d287 22
a308 3
     &       ACCESS='DIRECT',FORM='UNFORMATTED',ERR=9999,
     &       BLOCKSIZE=16384,BUFFERCOUNT=4, 
     &       RECL=LENREC,INITIALSIZE=NBLOCK)
d311 1
a311 1
             NWORDS = IREC * NSAM 
d316 1
a316 1
          BUF(1) = -NSLICE
d326 1
a326 1
            DO  K= 6,212
d330 1
d333 7
a340 3
            BUF(22) = LABREC * LENREC * 4
            BUF(23) = LENREC * 4

d370 1
a370 1
            CLINE(1:12) = CDAT(1:9) // '   '
d377 17
a393 1
            LENTIT = MAX(0,(INDEX(CTIT,NULL) -1))
d395 2
a396 2
            DO IT =1,45
               BUF(IT+211) = ZBUF(IT)
d401 2
a402 1
	    
d405 2
a406 2
              CALL WRTLIN(LUN,BUF(ILOC),LENREC,I)
              ILOC = ILOC + LENREC
d409 23
a431 3
C           SET LUNARA OFFSET TO FINAL VALUE           
            LUNARA(LUN) = LABREC
            GOTO 2000
d434 2
d460 1
d462 5
d468 2
a469 1
	ELSEIF (EX.AND.(DISP .EQ. 'O' .OR. DISP .EQ. 'R')) THEN
d471 1
a471 4
C         FILE EXISTS, AND IS ACCESSED WITH 'OLD', ---------------- OLD
C         RETRIEVE ALL LABEL INFO AND PUT IT INTO COMMON/MASTER/

          IF (INLNED .EQ. 0) THEN
d485 9
d495 1
a495 1
C         READER HEADER FROM FILE            	       
d497 3
d501 3
d509 39
a547 5
                 
          NSAM   = NSAMO
          NEWFMT = .FALSE.
          LABREC = 1
          LASLAB = 0
d549 1
a563 1
	    
d567 1
d569 4
a572 3
          NSLICE = ABS(BUF(1))+0.5
          IREC   = BUF(3)+0.5
          IFORM  = BUF(5)
a574 2
          NROW   = BUF(2)+0.5
          IF (IFORM .EQ. 8) NSAM = BUF(12)+0.5
d576 1
a576 1

d582 1
a582 1
              ITOP = IRECMIN + ((NSAM + 2) * NROW) 
d588 19
d617 15
a631 15
            IANGLE= BUF(14)
            PHI   = BUF(15)
            THETA = BUF(16)
            PSI   = BUF(17)
            XOFF  = BUF(18)
            YOFF  = BUF(19)
            ZOFF  = BUF(20)
            SCALE = BUF(21)
            KANGLE= BUF(30)
            PHI2  = BUF(31)
            THETA2= BUF(32)
            PSI2  = BUF(33)
            PHI1  = BUF(34)
            THETA1= BUF(35)
            PSI1  = BUF(36)
d637 15
d653 1
a653 2

	    CDAT    = CLINE(1:9) // ' '
d658 2
a659 2
            DO IT = 1,45
             ZBUF(IT) = BUF(IT+211)
d662 1
a700 360
          ENDIF
1050	  CONTINUE
          DSP    = 'O'

        ELSE
C         UNKNOWN DISP IN SUBROUTINE CALL
          WRITE(NOUT,*) '*** PGM. ERROR: UNKNOWN DISP TO OPENFB.'
          RETURN
        ENDIF


2000   	TYPE = 'R '
        IF (IFORM .EQ. -1) TYPE = 'F ' 
	IF (IFORM .EQ. -2) TYPE = 'P '
        IF (IFORM .EQ. -3) TYPE = 'F3' 
	IF (IFORM .EQ. -7) TYPE = 'FQ'
	IF (IFORM .EQ.-11) TYPE = 'FO'
        IF (IFORM .EQ. -9) TYPE = 'FS'
	IF (IFORM .EQ.-12) TYPE = 'FE'

	IF (IFORM .EQ. 0)  TYPE = 'D '
	IF (IFORM .EQ. 3)  TYPE = 'R3'
        IF (IFORM .EQ. 8)  TYPE = '8 '
        IF (IFORM .EQ. 11) TYPE = 'C '
        IF (IFORM .EQ. 16) TYPE = '16'
        FLEN = 'S'
        IF (NEWFMT) FLEN = 'L'

	IF (N_VERBOSE .EQ. 1 .AND. IFOUND .NE. -4) THEN
C         PRINT FILE OPENING INFORMATION

          IF (LENTIT .LE. 0) THEN

            WRITE(NOUT,9091) FILNM(:NLET)

          ELSEIF (LENTIT + NLET .LT. 70) THEN
            WRITE(NOUT,9090) FILNM(:NLET),CTIT(:LENTIT)
9090        FORMAT(' ',A,'     /',A)

          ELSE
            WRITE(NOUT,9091) FILNM(:NLET)

            LENT = MIN(80,LENTIT)
            WRITE(NOUT,9091) CTIT(1:LENT)
9091        FORMAT(' ',A)

            IF (LENTIT .GT. 80) THEN
               WRITE(NOUT,9091) CTIT(81:LENTIT)
            ENDIF
          ENDIF


          IF (NSLICE .GT. 1) THEN
            WRITE(NOUT,2099) TYPE,NSAM,NROW,NSLICE,CDAT,CTIM,DSP,FLEN
2099	    FORMAT(' (',A,')',3I5,' CREATED ',A,' AT ',A,2X,A,2X,A)

          ELSE
            WRITE(NOUT,2299)TYPE,NSAM,NROW,CDAT,CTIM,DSP,FLEN
2299        FORMAT(' (',A,')',2I5,' CREATED ',A,' AT ',A,2X,A,2X,A)
          ENDIF
        ENDIF

	PARAM(2) = NSAM
	PARAM(3) = NROW
	PARAM(4) = FMAX
	PARAM(5) = FMIN
	PARAM(6) = AV
	PARAM(7) = SIG
	PARAM(8) = NSLICE

C       SET FLAG FOR NORMAL RETURN	
        NF = 2
        RETURN

9999    WRITE(NOUT,9001) FILNM(:NLET)
9001    FORMAT(' *** ERROR OPENING: ',A)

        RETURN
	END

#else

C       UNIX SPECIFIC FILE FOLLOWS ***********************************

	SUBROUTINE OPENFB(BUF,FILNAM,LUN,NSAM,NROW,DISP,NF,NSLICE)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'LABLOCK.INC'

        COMMON /LUNARA/ LUNARA(100),LASLAB,NOFFSET,LUNOFF(100),
     &                  LUNFORM(100)

#ifdef SP_SUN4
        INTEGER * 4     LOCLUN
#else
        INTEGER * 8     LOCLUN
#endif

        LOGICAL         USEINLN
        COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100),USEINLN
        COMMON /IOERR/IERR

        DIMENSION      BUF(*),ZBUF(45)
        
        CHARACTER *(*) FILNAM
        CHARACTER *180 CLINE
        CHARACTER * 81 FILNM
        CHARACTER * 2  TYPE
        CHARACTER * 1  NULL,DISP,DSP, TDAT
        INTEGER        ITEMP(3)

	LOGICAL        EX,NEWDAT,SPIFIL
        EQUIVALENCE    (CLINE,ZBUF)
        EQUIVALENCE    (HEAD2,IHEAD2)

        DATA NULL /0/
	DATA NSAMAX/16384/,MAXINT/20000000/

        NEWDAT = .TRUE.
        IF (NF .LT. 0) NEWDAT = .FALSE.
C       SET FLAG FOR ERRONEOUS RETURN
        NF   = 1
        IERR = 0
        SPIFIL = .TRUE.
       
        IF (LUN .LE. 0 .OR. LUN .GT. 100) THEN
           WRITE(NOUT,*)
     &     ' *** PGM. ERROR: LUN MUST BE 1...100, SET TO 99'
           LUN = 99
        ENDIF

C	CHECK IS USER WANTS TO USE THE INLINED BUFFER.
        INLNED = 0
        IF (USEINLN .AND. FILNAM(1:1) .EQ. '_') THEN
           CALL INLNBUF(FILNAM,NLET,INLNED,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

	   IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
	     EX = .FALSE.
	   ELSE
	     EX = .TRUE.
	   END IF
           FILNM = FILNAM(1:NLET)

        ELSE
C          USE REGULAR FILE
	   LUNC        = LUN
           LOCLUN(LUN) = 0

           IF (DATEXC .EQ. NULL) THEN
              FILNM = FILNAM
           ELSE
              CALL FILCAN(FILNM,NLET,NULL,NULL,FILNAM,DATEXC,IER)
	      IF (IER .NE.0) RETURN
          ENDIF

	   INQUIRE(FILE=FILNM,ERR=9997,EXIST=EX)
        ENDIF

	IF (.NOT. EX .AND. (DISP .EQ. 'O' .OR. DISP .EQ. 'M' .OR.
     &                      DISP .EQ. 'K')) THEN
C          ERROR -- FILE DOES NOT EXIST, BUT IS BEING OPENED WITH 'OLD'
           WRITE(NOUT,*) ' *** NOT FOUND: ',FILNM(1:NLET)
2051       FORMAT(' *** NOT FOUND: ',A)
           RETURN
        ENDIF

10	IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
C         USER WANTS A NEW FILE TO WRITE INTO ------------------------NEW

          IF (EX) THEN
C           FILE IS IS OPENED WITH 'UNKNOWN' BUT ALREADY EXISTS; IT WILL
C           BE REPLACED.  OLD FILES ARE DELETED.
            IER = 0
            OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD')
            CLOSE(UNIT=LUN,STATUS='DELETE',IOSTAT=IER)
	    IF (IER .NE. 0) THEN
              WRITE(NOUT,*) ' *** ERROR DELETING FILE'
              RETURN
            ENDIF
          ENDIF

	  IF (NSAM .EQ. 0 .OR. NROW .EQ. 0) THEN
C           FOR NEW FILES, NON-ZERO NSAM, NROW NEED TO BE SUPPLIED
2060	    WRITE(NOUT,2061) FILNM(1:NLET)
2061        FORMAT(' ***  RECORD INFO MISSING: ',A)
            RETURN

          ELSEIF (NSAM .GT. NSAMAX) THEN
C           EXCESSIVE ROW LENGTH 
2080        WRITE(NOUT,2081) NSAMAX
2081        FORMAT(' *** ROWLENGTH MUST BE <=:',I6/)
            RETURN

          ELSEIF (NSLICE .EQ. 0) THEN
C           NEW FILES NEED A NON ZERO SLICE NUMBER FOR FILE FORMAT FLAG
            NSLICE = 1

          ELSEIF (NSLICE .LT. 0) THEN
C           WANT TO CREATE AN SHORT LABEL FORMAT FILE
            WRITE(NOUT,*)' WARNING:  NO SHORT LABEL FILES ON UNIX'
            NSLICE = -NSLICE
          ENDIF

          NHISTREC = 256 / NSAM + 1
          IF (IFORM .EQ. 0 .OR. IFORM .EQ. -2) NHISTREC = -NROW*2/NSAM
          DSP    = 'N'

C         WANT TO CREATE A LONG LABEL FORMAT FILE
C         ADJUST NUMBER OF LABEL RECORDS TO HAVE 256*4 BYTES IN LABEL
          IF (IFORM .LE. 6) THEN
C            STANDARD SPIDER FLOATING POINT FILES
             LENBYT = NSAM * 4

          ELSEIF (IFORM .EQ. 8) THEN 
C           FOR 8 BIT FILES
            LENBYT = NSAM 

          ELSEIF (IFORM .EQ. 10) THEN
C           PIXEL BY PIXEL 8 BIT COLOR IMAGE FILE
            LENBYT = NSAM * 3

          ELSEIF (IFORM .EQ. 11) THEN
C           COLOR BY COLOR 8 BIT COLOR IMAGE FILE
            LENBYT = NSAM * 3

          ELSEIF (IFORM .EQ. 12) THEN
C           8 BIT RUNLENGTH COLOR FILE
            LENBYT = NSAM * 4

          ELSEIF(IFORM .EQ. 16) THEN
C           FOR 16 BIT INTEGER FILES
            LENBYT = NSAM * 2

          ENDIF

          LABREC = 1024 / LENBYT
          IF (MOD(1024,LENBYT) .NE. 0) LABREC = LABREC + 1
          LABBYT = LABREC * LENBYT
          LASLAB = LABREC

          IREC = NROW*NSLICE + NHISTREC + LABREC
          IF (IFORM .EQ. 11) IREC = IREC + 2 * NROW
          IF (IFORM .EQ. -1) THEN
C             ADDITIONAL SPACE NEEDED FOR FOURIER RECORDS
              ITOP = IREC + ((NSAM + 2) * NROW) 
              IREC = IREC + ITOP / NSAM
              IF (MOD(ITOP,NSAM) .NE. 0) IREC = IREC + 1
          ENDIF


	  IF (INLNED .EQ. 0) THEN
C	     REGULAR FILE
C            RECL IS IN UNITS OF BYTES ON SGI, FLOATS ON OSF
#ifdef __osf__
C            ONE LINE OF OSF UNIX SPECIFIC CODE FOLLOWS
             LABBY8 = LABBYT / 4
#else
C            ONE LINE OF NON OSF UNIX SPECIFIC CODE FOLLOWS
             LABBY8 = LABBYT
#endif
	     OPEN(LUN,FILE=FILNM,STATUS='NEW',FORM='UNFORMATTED',
     &       ACCESS='DIRECT',ERR=9999,RECL=LABBY8)
          ELSE
C            SET UP INLINE BUFFER AND TIE IT TO LUN
             NWORDS = IREC * LENBYT / 4
             CALL OPENINLN(LUN,INLNED,.TRUE.,NSAM,NWORDS,IRTFLG)
             IF (IRTFLG .NE. 0) RETURN
	  ENDIF

          BUF(1) = NSLICE
          BUF(2) = NROW
          BUF(3) = IREC
          BUF(4) = NHISTREC
          BUF(5) = IFORM
          IMAMI  = 0
          BUF(6) = IMAMI
          
C         A NEGATIVE NSLICE IS FLAG FOR SHORT LABEL FORMAT
          DO K= 6,212
C           ZERO UNUSED BUF VARIABLES
            BUF(K)=0
          ENDDO

          BUF(12) = NSAM
          BUF(13) = LABREC
          BUF(22) = LABBYT
          BUF(23) = LENBYT

          IF (IANGLE .NE. 0) THEN
             BUF(14) = IANGLE
             BUF(15) = PHI
             BUF(16) = THETA
             BUF(17) = PSI
          ENDIF

          IF (KANGLE .NE.0) THEN
             BUF(30) = KANGLE
             BUF(31) = PHI2
             BUF(32) = THETA2
             BUF(33) = PSI2
             BUF(34) = PHI1
             BUF(35) = THETA1
             BUF(36) = PSI1
          ENDIF

C         COPY MOST RECENT HDR_VALS INTO LOCATIONS 37..101
          DO I = 1,64
             BUF(36+I) = HDR_VALS(I)
          ENDDO

          IF (NEWDAT) THEN
             CALL DATE(CDAT)
             CALL TIME(CTIM)
          ENDIF

C         DATE TAKES 2 & 1/4 FLOATING POINT VARIABLES IN BUF (9 CHAR)
          CLINE(1:12)  = CDAT(1:9) // '   '

C         TIME TAKES 2 FLOATING POINT VARIABLES IN BUF (8 CHAR.)
          CLINE(13:20) = CTIM(1:8)

C         TITLE TAKES 40 FLOATING POINT VARIABLES IN BUF (160 CHAR)
          CLINE(21:180) = CTIT(1:160)
          LENTIT        = MAX(0,(INDEX(CTIT,NULL) -1))

#if defined(__osf__) && defined(osf_ieee)    
C         ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE FOLLOWS

C         NOTE THAT THE ALPHA-NUMERICAL DATA (ABCD) WILL BE WRITTEN 
C         IN INVERTED ORDER (DCBA)
          DO K = 1, 180, 4
            TDAT = CLINE(K:K)
            CLINE(K:K) = CLINE(K+3:K+3)
            CLINE(K+3:K+3) = TDAT
            TDAT = CLINE(K+1:K+1)
            CLINE(K+1:K+1) = CLINE(K+2:K+2)
            CLINE(K+2:K+2) = TDAT
          END DO
C         END ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE
#endif

          DO  I = 1,45 
             BUF(I+211) = ZBUF(I) 
          ENDDO

C         WRITE HEADER INTO FILE
          LUNARA(LUN) = 1
          CALL WRTLIN(LUN,BUF,256,0)

C         REOPEN THE FILE WITH FINAL LENGTH

          IF (INLNED .EQ. 0) THEN
             CLOSE(LUN)
#ifdef __osf__
C            ALPHA OSF (UNIX) SPECIFIC STATEMENT FOLLOWS
             LENBY8 = LENBYT/4
#else
C            NON ALPHA OSF (UNIX) SPECIFIC STATEMENT FOLLOWS
             LENBY8 = LENBYT 
a701 90

	     OPEN(LUN,FILE=FILNM,STATUS='OLD',FORM='UNFORMATTED',
     &       ACCESS='DIRECT',ERR=9999,RECL=LENBY8)
          ENDIF

C         SET FINAL LUNARA OFFSET VALUE FOR USE BY REDLIN/WRTLIN
          LUNARA(LUN) = LABREC
          GOTO 2000

	ELSEIF (DISP .EQ. 'O' .OR. DISP .EQ. 'K' .OR.
     &          DISP .EQ. 'R' ) THEN
C         -----------------------------------------------------------OLD
C         FILE EXISTS, AND IS ACCESSED WITH 'OLD'
C         RETRIEVE ALL LABEL INFO

          IF (INLNED .EQ. 0) THEN
C            REGULAR FILE ACCESS
             OPEN(LUN,FILE=FILNM,STATUS='OLD',ACCESS='DIRECT',
     &         FORM='UNFORMATTED',RECL=1024,ERR=9999)
          ELSE
C            INLINE FILE BUFFER ACCESS
             CALL OPENINLN(LUN,INLNED,.FALSE.,NSAM,NDUM,IRTFLG)
             IF (IRTFLG .NE. 0) RETURN
     	  ENDIF

          LUNARA(LUN) = 1
          IERR        = 0
          CALL REDLIN(LUN,BUF,256,0)
          IF (IERR .NE. 0) GOTO 9998
          HEAD2 = BUF(2)

          IF ((BUF(12) .LT. 1.0 .OR. BUF(12) .GT. 50000.0) .OR.
     &        (BUF(2)  .LT. 1.0 .OR. BUF(2)  .GT. 50000.0) .OR.
     &        (BUF(5)  .LT. -20.0 .OR. BUF(5)  .GT. 20.0) .OR.
     &        (IHEAD2  .EQ. -1  )) THEN
C             ASSUME THIS IS A DUMPED RAW 8 BIT IMAGE

              IF (DISP .NE. 'K' .OR. (NSAM .LE. 0 .OR.
     &            NROW .LE. 0 .OR. NSLICE .LE. 0)) THEN

33              NUM = 3
                CALL RDPRAI(ITEMP,3,NUM,1,16000,
     &              'Enter columns, rows and slices in image',
     &               NULL,IRTFLG)
                IF (IRTFLG .EQ. -1) RETURN
                NSAM   = ITEMP(1)
                NROW   = ITEMP(2)
                NSLICE = ITEMP(3)

                CALL RDPRIS(NOFFSET,IDUM,NLOOP,ILOOP,
     &               'Enter header offset',IRTFLG)
                IF (IRTFLG .EQ. -1) GOTO 33
              ENDIF

              IFORM  = 8
              IREC   = NROW * NSLICE 
              LENBYT = NSAM
              LABREC = 0
              LABBYT = NOFFSET
C             DO NOT SET NORMALIZATION NEEDED FLAG
              IMAMI  = 1
              FMIN   = 0.0
              FMAX   = 255.0
              AV     = 0.0
              SIG    = 0.0
              IHIST  = 0
              SPIFIL = .FALSE.
              GOTO 1050
          ENDIF

          NSLICE   = ABS(BUF(1))+0.5
          NSAM     = BUF(12)
          NROW     = BUF(2)+0.5
          IREC     = BUF(3)+0.5
          NHISTREC = BUF(4)+0.5
          IFORM    = BUF(5)
          IF (BUF(5) .LT. 0.0) IFORM = BUF(5)-0.5
          IF (IABS(IFORM) .EQ. 1) NSLICE = 1
          LENBYT = BUF(23)
          IF (LENBYT .LE. 0) LENBYT = NSAM * 4
          LABREC = BUF(13)

          
          LABRECT = 1024 / LENBYT
          IF (MOD(1024,LENBYT) .NE. 0) LABRECT = LABRECT + 1
           
          IF (LABRECT .LE. 0 .OR. (IFORM .LT. 7 .AND. 
     &        LABREC .NE. LABRECT)) THEN
C             UNREASONABLE LABREC NUMBER SO DEFAULT IT
              LABREC = LABRECT
a702 3
          LASLAB = LABREC

          LABBYT = BUF(22)
a703 52
          IMAMI  = BUF(6)+0.5
          FMAX   = BUF(7)
          FMIN   = BUF(8)
          AV     = BUF(9)
          SIG    = BUF(10)
          IHIST  = BUF(11)+0.5

          IANGLE = BUF(14)
          PHI    = BUF(15)
          THETA  = BUF(16)
          PSI    = BUF(17)
          XOFF   = BUF(18)
          YOFF   = BUF(19)
          ZOFF   = BUF(20)
          SCALE  = BUF(21)
          KANGLE = BUF(30)
          PHI2   = BUF(31)
          THETA2 = BUF(32)
          PSI2   = BUF(33)
          PHI1   = BUF(34)
          THETA1 = BUF(35)
          PSI1   = BUF(36)

          DO I = 1,64
             HDR_VALS(I) = BUF(36+I)
          ENDDO

#if defined(__osf__) && defined(osf_ieee)
C         ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE FOLLOWS
C         NOTE THAT ALPHA-NUMERICAL DATA (ABCD) WILL BE WRITTEN (DCBA)
    
          DO K = 1, 180, 4
            TDAT = CLINE(K:K)
            CLINE(K:K) = CLINE(K+3:K+3)
            CLINE(K+3:K+3) = TDAT
            TDAT = CLINE(K+1:K+1)
            CLINE(K+1:K+1) = CLINE(K+2:K+2)
            CLINE(K+2:K+2) = TDAT
          END DO
C         END ALPHA OSF UNIX WITH IEEE TYPE DATA SPECIFIC CODE 
#endif

C         READ LONG LABEL FORMAT DATE, TIME & TITLE
          CDAT    = CLINE(1:9) // ' '
          CTIM    = CLINE(13:20) 
          CTIT    = CLINE(21:180)
          LENTIT  = MAX(0,(INDEX(CTIT,NULL)-1))

          DO  I = 1,45 
            ZBUF(I) = BUF(I+211) 
          ENDDO

a723 1

d782 1
d784 4
a827 1
#endif
@


1.26
log
@added HDR_VALS
@
text
@d802 1
a802 1
             BUF(17) = GAMMA
d975 1
a975 1
          GAMMA  = BUF(17)
@


1.25
log
@variable nsam0 is nsamo
@
text
@d284 7
a290 7
               BUF(30)=KANGLE
               BUF(31)=PHI2
               BUF(32)=THETA2
               BUF(33)=PSI2
               BUF(34)=PHI1
               BUF(35)=THETA1
               BUF(36)=PSI1
d293 5
d456 4
d571 1
a571 1
2230	PARAM(2) = NSAM
d805 15
d980 7
d988 3
@


1.24
log
@ NO INTEGER * 8 ON SUN
@
text
@d137 1
a137 1
           NSAM0 = 256
@


1.23
log
@remove extra dimension buf(*),zbuf statement
@
text
@d592 3
d596 2
d609 1
a609 1
        INTEGER        ITEMP(3),KM1,KM2
@


1.22
log
@laslab not set for old unix files, nneded for getang
@
text
@a588 2
	DIMENSION BUF(*),ZBUF(45)

@


1.21
log
@changed irec (for fourier)
@
text
@d924 1
d934 2
@


1.20
log
@bad NWORDS setting on unix
@
text
@d231 1
a231 2
          IREC = NROW*NSLICE + NROW*NSLICE / (NSAM/2) + NHISTREC +
     &             LABREC
d233 6
d415 8
a422 2
          IRECMIN   = NROW*NSLICE + NROW*NSLICE / (NSAM/2) + NHISTREC +
     &             LABREC
d738 1
a738 2
          IREC = NROW*NSLICE + NROW*NSLICE / (NSAM/2) + NHISTREC +
     &             LABREC
d740 6
a768 1
C         BUF(3) STILL CONTAINS IREC
@


1.19
log
@changed length to use irec for inline buffer sizing
@
text
@d746 1
a746 1
             NWORDS = IREC * NSAM * LENBYT / 4
@


1.18
log
@added useinln toggle
@
text
@d231 1
a231 1
          IREC   = NROW*NSLICE + NROW*NSLICE / (NSAM/2) + NHISTREC +
a233 2
          NBLOCK = FLOAT(LENREC) / 512.0 * FLOAT(IREC) + 1.0
          IF (IFORM .EQ. 8) NBLOCK = NBLOCK / 4 + 1
d237 2
d245 1
a245 1
             NWORDS = (LABREC + NHISTREC + NROW * NSLICE) * NSAM 
d727 3
d731 1
d746 1
a746 2
             NWORDS = (LABREC + NHISTREC + NROW * NSLICE) * 
     &                NSAM * LENBYT / 4
d753 2
a754 2
C         BUF(3) USED TO CONTAIN IREC
          BUF(3) = NROW * NSLICE + LABREC
d898 4
a901 4
          NSLICE = ABS(BUF(1))+0.5
          NSAM   = BUF(12)
          NROW   = BUF(2)+0.5
          IREC   = BUF(3)+0.5
d903 1
a903 1
          IFORM  = BUF(5)
d927 8
a934 8
          IANGLE= BUF(14)
          PHI   = BUF(15)
          THETA = BUF(16)
          GAMMA = BUF(17)
          XOFF  = BUF(18)
          YOFF  = BUF(19)
          ZOFF  = BUF(20)
          SCALE = BUF(21)
@


1.17
log
@fixed integer 8 in inline buffer (not available on non-alpha)
@
text
@d93 1
d95 1
a95 1
        COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)
d125 1
a125 1
        IF (FILNAM(1:1) .EQ. '_') THEN
d584 2
a585 1
        COMMON /LUNARB/ LOCLUN(100),NSAMLUN(100),NWORDLUN(100)
d619 1
a619 1
        IF (FILNAM(1:1) .EQ. '_') THEN
@


1.16
log
@used inlnbuf to get inline buffer name
@
text
@d93 1
a93 1
        INTEGER * 8     LOCLUN
@


1.15
log
@fixed IBUF equivalence
@
text
@d124 4
a127 3
        IF (FILNAM(1:3) .EQ. '___') THEN
           READ(FILNAM(4:4),8000) INLNED
8000       FORMAT(I1)
d133 2
a134 2
           FILNM = FILNAM
           NLET  = 4
d617 4
a620 3
        IF (FILNAM(1:3) .EQ. '___') THEN
           READ(FILNAM(4:4),8000) INLNED
8000       FORMAT(I1)
d626 1
a626 2
           FILNM = FILNAM
           NLET  = 4
@


1.14
log
@new runtime inline buffer alteration
@
text
@d577 1
d585 2
a586 1
        DIMENSION      BBUF(1),IBUF(1)
d596 1
a596 1
        EQUIVALENCE    (BBUF,BUF),(IBUF,BUF)
d851 1
d856 1
a856 1
     &        (IBUF(2)  .EQ. -1  )) THEN
@


1.13
log
@correct error message
@
text
@d2 1
a2 1
C++************************************************************************
d5 10
a14 10
C                                           
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *    THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR     *
C *    LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR  *
C *    USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF   *
C *    THE CENTER FOR LABORATORIES AND RESEARCH 			   *
C **************************************************************************
d18 2
a19 2
C    PURPOSE:       TO OPEN A NEW OR  EXISTING DATA FILE FOR RANDOM ACCESS
C                   READING/WRITING.
d39 1
a39 1
C                                 IF IT DOES NOT EXIST, NON-ZERO NSAM AND
d45 3
a47 2
C                               OVERWRITTEN. LABEL INFO IN THE FILE IS 
C                               REPLACED BY INFO SUPPLIED IN COMMON/MASTER/.
d53 4
a56 3
C	 NSLICE	                NUMBER OF PLANES, EACH CONTAINING NSAM*NROW 
C                               ELEMENTS. IF NSLICE IS <0 AN SHORT LABEL 
C                               FORMAT FILE IS DESIRED!
a63 1
C
d67 1
a67 1
C               +3     R    3-D FILE
d72 4
a75 4
C               -1     F    2-D FOURIER TRANSFORM
C               -3     F    3-D FOURIER TRANSFORM
C               -7     Q    3-D FOURIER TRANSFORM, PAUL'S FORMAT
C               -9     S    3-D SIMPLE FORMAT FOURIER (MICHAEL'S FORMAT)
d80 1
a80 1
C--********************************************************************
d84 2
d91 4
a94 1
        COMMON /LUNARA/ LUNARA(100),LASLAB,LUNINI(100)
a96 13
C	FBUF WILL BE DIVIDED INTO TWO ARRAYS 
	PARAMETER (ISZBUF = 500000)
	COMMON/SPI_FILEB/FBUF(ISZBUF)
C	INLNAM 1&2 ARE THE NAME ASSIGNED TO EACH INLINED ARRAY
	CHARACTER * 80 INLNAM1,INLNAM2
	COMMON/CINLN_NAMES/INLNAM1,INLNAM2
C	DEFAULT VALUE OF INLNSIZE = ISZBUF/2 
	INTEGER INLNSIZE, ISZBUF0, INLNED
	COMMON/INLN_FLAGS/INLNSIZE,ISZBUF0
	INTEGER ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
	COMMON/LUNYP/ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12

        DIMENSION      BUF(*),ZBUF(45)
d110 1
a110 1
        NULL = CHAR(0)
d124 3
a126 8
C       COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
        INLNED = 0
        NLET = LNBLNK(FILNAM)
        LENA = LNBLNK(INLNAM1)
C	USE FIRST INLINED BUFF ?
	IF(FILNAM(1:NLET) .EQ. INLNAM1(1:LENA)) THEN
	   INLNED = 1
	   ACT1= LUN
d132 10
a141 16
	   NSAMO = RECLN11
	   GOTO 10
        END IF
        LENA = LNBLNK(INLNAM2)
C	USE FIRST INLINED BUFF ?
	IF(FILNAM(1:NLET) .EQ. INLNAM2(1:LENA)) THEN
	   INLNED = 2
	   ACT2 = LUN
    	   NSAMO = RECLN12
	   IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
	     EX = .FALSE.
	   ELSE
	     EX = .TRUE.
	   END IF
	   GOTO 10
        END IF
d143 6
a148 3
	LUNC = LUN
	CALL FILCAN(FILNM,NLET,NULL,NULL,FILNAM,DATEXC,IER)
	IF (IER .NE.0) RETURN
d150 3
a152 2
	INQUIRE(FILE=FILNM,ERR=2096,EXIST=EX,RECL=NSAMO)
	NSAMO = NSAMO / 4
d155 1
a155 2
     &  (DISP .EQ. 'O' .OR. DISP .EQ. 'R' .OR. DISP .EQ. 'M'))
     &     THEN
d157 4
a160 1
           goto 2096
d164 1
a164 1
C         USER WANTS A NEW FILE TO WRITE INTO
d209 1
a209 1
C            WANT TO CREATE A LONG LABEL FORMAT FILE
a231 1
          CLOSE(LUN)
d235 12
a246 12
          IF(INLNED.EQ.0) THEN
	  OPEN(UNIT=LUN,FILE=FILNM,STATUS='NEW',RECORDTYPE='FIXED',
     &    ACCESS='DIRECT',FORM='UNFORMATTED',ERR=9999,
     &    BLOCKSIZE=16384,BUFFERCOUNT=4, 
     &    RECL=LENREC,INITIALSIZE=NBLOCK)
     	  ELSE IF(INLNED.EQ.1) THEN
	     RECLN01=LENREC
	     RECLN11=LENREC
	  ELSE
	     RECLN12=LENREC
	     RECLN02=LENREC
	  END IF
a247 1

a257 2

C           ZERO UNUSED BUF VARIABLES
d259 2
a260 1
              BUF(K)=0
d264 1
d275 1
d277 7
a283 7
             BUF(30)=KANGLE
             BUF(31)=PHI2
             BUF(32)=THETA2
             BUF(33)=PSI2
             BUF(34)=PHI1
             BUF(35)=THETA1
             BUF(36)=PSI1
d304 3
a306 8
            
            IF(INLNED.EQ.0) THEN
               LUNARA(LUN) = 1
	       LUNINI(LUN) = 0
	    ELSE
	       LUNARA(LUN) = 0
	       LUNINI(LUN) = 1
	    END IF
d313 3
a315 8
	    
            IF(INLNED.EQ.0) THEN
               LUNARA(LUN) = LABREC
	       LUNINI(LUN) = 0
	    ELSE
	       LUNARA(LUN) = 0
	       LUNINI(LUN) = LABREC
	    END IF
d320 1
d341 1
a341 8
	    IF(INLNED.EQ.0) THEN
               LUNARA(LUN) = 1
	       LUNINI(LUN) = 0
	    ELSE
	       LUNARA(LUN) = 0
	       LUNINI(LUN) = 1
	    END IF

a344 1

d347 1
a347 1
C         FILE EXISTS, AND IS ACCESSED WITH 'OLD', I.E., READ-ONLY
d349 18
a366 18
           IF(INLNED.EQ.0) THEN
          IF (DISP .EQ. 'O')  THEN
          OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',RECORDTYPE='FIXED',
     1    ACCESS='DIRECT',ERR=9999)

          ELSEIF (DISP .EQ. 'R')  THEN
          OPEN(UNIT=LUN,FILE=FILNM,STATUS='OLD',RECORDTYPE='FIXED',
     1    READONLY,ACCESS='DIRECT',ERR=9999)
          ENDIF
	  END IF
	  
          IF(INLNED.EQ.0) THEN
             LUNARA(LUN) = 1
	     LUNINI(LUN) = 0
	  ELSE
	     LUNARA(LUN) = 0
	     LUNINI(LUN) = 1
	  END IF
d369 3
a371 3
            WRITE(NOUT,9002) FILNM(:NLET)
9002        FORMAT(' *** ERROR READING: ',A)
            RETURN
a392 7
            IF(INLNED.EQ.0) THEN
               LUNARA(LUN) = LABREC
	       LUNINI(LUN) = 0
	     ELSE
	       LUNARA(LUN) = 0
	       LUNINI(LUN) = LABREC
	    END IF
d394 1
d464 1
a464 1
                 L2DAT(I) = BUF(11+I)+0.5
d477 1
a477 1
                 L2TIT(I) = BUF(20+I) + 0.5
d482 1
a487 1

d493 1
a493 1
          WRITE(NOUT,*) '*** PGM. ERROR: UNKNOWN DISP IN OPENFB'
d498 6
a503 6
2000    TYPE = 'R '
        IF (IFORM .EQ. -1) TYPE = 'F '
        IF (IFORM .EQ. -2) TYPE = 'P '
        IF (IFORM .EQ. -3) TYPE = 'F3'
        IF (IFORM .EQ. -7) TYPE = 'FQ'
        IF (IFORM .EQ.-11) TYPE = 'FO'
d505 1
a505 1
        IF (IFORM .EQ.-12) TYPE = 'FE'
d507 2
a508 2
        IF (IFORM .EQ. 0)  TYPE = 'D '
        IF (IFORM .EQ. 3)  TYPE = 'R3'
a511 1
   
d534 1
a534 1
              WRITE(NOUT,9091) CTIT(81:LENTIT)
a560 4
2096    WRITE(NOUT,2051) FILNM(1:NLET)
2051    FORMAT(' *** NOT FOUND: ',A)
        RETURN
	   
d567 1
d569 1
a570 1
#else
d576 3
d580 2
a581 2
        COMMON /LUNARA/ LUNARA(100),LASLAB,NOFFSET,
     &                  LUNOFF(100),LUNFORM(100),LUNINI(100)
d584 1
a584 13
C	ZBUF WILL BE DIVIDED INTO TWO ARRAYS 
	PARAMETER (ISZBUF = 500000)
	COMMON/SPI_FILEB/FBUF(ISZBUF)
C	INLNAM 1&2 ARE THE NAME ASSIGNED TO EACH INLINED ARRAY
	CHARACTER * 80 INLNAM1,INLNAM2
	COMMON/CINLN_NAMES/INLNAM1,INLNAM2
C	DEFAULT VALUE OF INLNSIZE = ISZBUF/2 
	INTEGER INLNSIZE, ISZBUF0, INLNED
	COMMON/INLN_FLAGS/INLNSIZE,ISZBUF0
	INTEGER ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
	COMMON/LUNYP/ACT1,RECLN01,RECLN11,ACT2,RECLN02,RECLN12
	
        DIMENSION      BUF(*),ZBUF(45)
d590 1
a590 1
        INTEGER        ITEMP(3)
d594 1
a612 1
C       COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
d614 3
a616 6
        NLET = LNBLNK(FILNAM)
        LENA = LNBLNK(INLNAM1)
C	USE FIRST INLINED BUFF ?
	IF(FILNAM(1:NLET) .EQ. INLNAM1(1:LENA)) THEN
	   INLNED = 1
	   ACT1 = LUN
d622 7
a628 14
	   GOTO 10
        END IF
        LENA = LNBLNK(INLNAM2)
C	USE FIRST INLINED BUFF ?
	IF(FILNAM(1:NLET) .EQ. INLNAM2(1:LENA)) THEN
	   INLNED = 2
	   ACT2 = LUN
	   IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
	     EX = .FALSE.
	   ELSE
	     EX = .TRUE.
	   END IF
	   GOTO 10
        END IF
d630 6
a635 3
	LUNC = LUN
	CALL FILCAN(FILNM,NLET,NULL,NULL,FILNAM,DATEXC,IER)
	IF (IER .NE.0) RETURN
d637 2
a638 1
	INQUIRE(FILE=FILNM,ERR=9997,EXIST=EX)
d640 2
a641 2
	IF (.NOT. EX .AND. (DISP .EQ. 'O' .OR. DISP .EQ. 'M'))
     &     THEN
d700 1
a700 1
C           COLOR BY COLOR 8 BIT COLOR IMAGE FILE
d704 1
a704 1
C           PIXEL BY PIXEL 8 BIT COLOR IMAGE FILE
d722 4
d727 2
a728 1
          LABBY8 = LABBYT / 4
d730 2
a731 1
          LABBY8 = LABBYT
a732 3

          IF(INLNED.EQ.0) THEN
C            RECL IS IN UNITS OF BYTES
d735 7
a741 5
          ELSE IF(INLNED.EQ.1) THEN
	     RECLN01=LABBY8
	  ELSE
	     RECLN02=LABBY8
	  END IF
d743 1
a743 1
          BUF(1) = -NSLICE
d753 1
a753 1
          DO  K= 6,212
d776 1
a776 1
          CLINE(1:12) = CDAT(1:9) // '   '
d783 4
a786 1
          LENTIT = MAX(0,(INDEX(CTIT,NULL) -1))
d788 2
a789 5
c     alpha osf (unix)
c
c     note that the alpha numerical data (abcd) will be written (dcba)
c 
#if defined(__osf__) && defined(osf_ieee)
d798 1
d805 2
a806 7
          IF(INLNED.EQ.0) THEN
             LUNARA(LUN) = 1
	     LUNINI(LUN) = 0
	  ELSE
	     LUNARA(LUN) = 0
	     LUNINI(LUN) = 1
	  END IF
a807 1
          IF (INLNED.EQ.0) CLOSE(LUN)
d809 4
a812 1
C   ALPHA OSF (UNIX)
d814 2
a815 1
          LENBY8 = LENBYT/4
d817 2
a818 1
          LENBY8 = LENBYT 
a820 1
          IF(INLNED.EQ.0) THEN
d823 1
a823 5
          ELSE IF (INLNED.EQ.1) THEN
	     RECLN11=LENBY8
	  ELSE
	     RECLN12=LENBY8
	  END IF
d825 2
a826 7
          IF(INLNED.EQ.0) THEN
             LUNARA(LUN) = LABREC
	     LUNINI(LUN) = 0
	  ELSE
	     LUNARA(LUN) = 0
	     LUNINI(LUN) = LABREC
	  END IF
d835 2
a836 1
          IF(INLNED.EQ.0) THEN
d839 5
a843 7

             LUNARA(LUN) = 1
	     LUNINI(LUN) = 0
	  ELSE
	     LUNARA(LUN) = 0
	     LUNINI(LUN) = 1
	  END IF
d845 2
a846 1
          IERR = 0
d851 3
a853 1
     &        (BUF(2)  .LT. 1.0 .OR. BUF(2)  .GT. 50000.0))THEN
d856 5
a860 2
33            NUM = 3
              CALL RDPRAI(ITEMP,3,NUM,1,16000,
d863 9
a871 9
              IF (IRTFLG .EQ. -1) RETURN
              NSAM   = ITEMP(1)
              NROW   = ITEMP(2)
              NSLICE = ITEMP(3)

              NOFFSET = 0
              CALL RDPRIS(NOFFSET,IDUM,NLOOP,ILOOP,
     &             'Enter header offset',IRTFLG)
              IF (IRTFLG .EQ. -1) GOTO 33
d927 1
a927 4
c     alpha osf/1 (unix)
c
c     note that the alpha numerical data (abcd) will be written (dcba)
c     
d929 3
d940 1
d944 1
a944 2

	  CDAT    = CLINE(1:9) // ' '
d953 1
a953 2
1050      IF(INLNED.EQ.0) CLOSE(LUN)
          IF (NOFFSET .EQ. 0 .AND. .NOT. SPIFIL) THEN
d958 2
a959 6
          IF(INLNED.EQ.0) THEN
	     LUNINI(LUN) = 0
	  ELSE
	     LUNARA(LUN) = 0
	     LUNINI(LUN) = LABREC
	  END IF
d961 2
a962 1
C      ALPHA OSF/1 UNIX
d964 2
a965 1
          LENBY8 = LENBYT/4
d967 2
a968 1
          LENBY8 = LENBYT
d970 1
a970 2

	  IF(INLNED.EQ.0) THEN
d973 3
a975 10
          ELSE IF(INLNED.EQ.1) THEN
	     IF(RECLN11.NE.LENBY8)
     &           WRITE(NOUT,*) ' ERROR IN OPENFB.F AAA1'
	     RECLN11=LENBY8
	  ELSE
	     IF(RECLN12.NE.LENBY8) 
     &            WRITE(NOUT,*)' ERROR IN OPENFB.F AAA2'
	     RECLN12=LENBY8
	  END IF
 
d979 1
a979 1
          WRITE(NOUT,*)' *** PGM. ERROR: UNKNOWN DISP FOR OPENFB'
a996 1

d1016 1
a1017 1

a1019 1

d1022 1
a1022 2
9090        FORMAT(A,'     /',A)

a1024 1

d1027 1
a1027 2
9091        FORMAT(A)

a1070 1

@


1.12
log
@allow use of inlined buff 1 and 2 simultaneously
@
text
@d1032 2
a1033 1
	     IF(RECLN11.NE.LENBY8) TYPE ' ERROR IN OPENFB.F AAA1'
d1036 2
a1037 1
	     IF(RECLN12.NE.LENBY8) TYPE ' ERROR IN OPENFB.F AAA2'
@


1.11
log
@changes for inlined buff by adding lunini array
@
text
@d100 2
a101 2
	INTEGER ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
	COMMON/LUNYP/ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
d138 1
a138 1
	   ACTIV = 1
d151 1
a151 1
	   ACTIV = 2
d630 3
a632 2
	INTEGER ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
	COMMON/LUNYP/ACTIV,RECLN01,RECLN11,RECLN02,RECLN12
d668 1
a668 1
	   ACTIV = 1
d680 1
a680 1
	   ACTIV = 2
@


1.10
log
@corrected goto inside if loop
@
text
@d88 1
a88 1
        COMMON /LUNARA/ LUNARA(100),LASLAB
d100 2
a101 3
C	FORTRAN UNIT ASSOCIATED WITH EACH inlined buff
	INTEGER INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
	COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
d138 7
a144 3
	   LUN = INLUN1
	   EX = .FALSE.
	   NSAMO = NSAMO / 4
d151 7
a157 3
	   LUN = INLUN2
	   EX = .FALSE.
    	   NSAMO = NSAMO / 4
d318 8
a325 1
            LUNARA(LUN) = 1
d331 8
a338 1
            LUNARA(LUN) = LABREC
d362 9
a370 1
            LUNARA(LUN) = 1
d390 7
a396 1
          LUNARA(LUN) = 1
d422 9
a430 1
            LUNARA(LUN) = LABREC
d616 3
a618 1
        COMMON /LUNARA/ LUNARA(100),LASLAB,NOFFSET
d630 2
a631 4
C	FORTRAN UNIT ASSOCIATED WITH EACH inlined buff
	INTEGER INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12
	COMMON/LUNYP/INLUN1,RECLN01,RECLN11,INLUN2,RECLN02,RECLN12

d667 6
a672 2
	   LUN = INLUN1
	   EX = .FALSE.
d679 6
a684 2
	   LUN = INLUN2
	   EX = .FALSE.
a848 1

d853 7
a859 1
          LUNARA(LUN) = 1
d861 1
a861 2

          CLOSE(LUN)
d870 8
a877 2
	  OPEN(LUN,FILE=FILNM,STATUS='OLD',FORM='UNFORMATTED',
     &    ACCESS='DIRECT',ERR=9999,RECL=LENBY8)
d879 7
a885 1
          LUNARA(LUN) = LABREC
d895 1
a895 1
          OPEN(LUN,FILE=FILNM,STATUS='OLD',ACCESS='DIRECT',
d897 6
a902 5
C	  SHOULD NOT BE NECESSARY,ALREADY STORED.
C	  ELSE IF  (INLNED.EQ.1) THEN
C	     RECLN01=1024
C	  ELSE
C	     RECLN02=1024
a904 1
          LUNARA(LUN) = 1
d1007 1
a1007 1
1050      CLOSE(LUN)
d1013 6
@


1.9
log
@added an inlined buffer
@
text
@d104 1
a104 1
        DIMENSION      BUF(*),FBUF(45)
d114 1
a114 1
        EQUIVALENCE    (CLINE,FBUF)
d165 1
a165 4

2096       WRITE(NOUT,2051) FILNM(1:NLET)
2051       FORMAT(' *** NOT FOUND: ',A)
           RETURN
d308 1
a308 1
               BUF(IT+211) = FBUF(IT)
d439 1
a439 1
             FBUF(IT) = BUF(IT+211)
d555 4
d576 1
a576 1
C	FBUF WILL BE DIVIDED INTO TWO ARRAYS 
d589 1
a589 1
        DIMENSION      BUF(*),FBUF(45)
d598 1
a598 1
        EQUIVALENCE    (CLINE,FBUF)
d800 1
a800 1
             BUF(I+211) = FBUF(I) 
d937 1
a937 1
            FBUF(I) = BUF(I+211) 
@


1.8
log
@.nlabel changed to nhistrec
@
text
@d91 13
d131 23
d171 1
a171 1
	IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d244 1
d249 8
a324 1

d353 1
a353 1

d362 2
a363 1

d404 2
a405 2
          IRECMIN   = NROW*NSLICE + NROW*NSLICE / (NSAM/2) + 
     &                NHISTREC +  LABREC
d575 13
d615 21
d650 1
a650 1
	IF (DISP .EQ. 'U' .OR. DISP .EQ. 'N') THEN
d730 9
a739 4
C         RECL IS IN UNITS OF BYTES
	  OPEN(LUN,FILE=FILNM,STATUS='NEW',FORM='UNFORMATTED',
     &    ACCESS='DIRECT',ERR=9999,RECL=LABBY8)

d826 1
d829 6
d953 2
a954 1
          OPEN(LUN,FILE=FILNM,STATUS='OLD',ACCESS='DIRECT',
d956 7
@


1.7
log
@remove spout()
@
text
@d176 2
a177 2
          NLABEL = 256 / NSAM + 1
          IF (IFORM .EQ. 0 .OR. IFORM .EQ. -2) NLABEL = -NROW*2/NSAM
d201 1
a201 1
          IREC   = NROW*NSLICE + NROW*NSLICE / (NSAM/2) + NLABEL +
d216 1
a216 1
          BUF(4) = NLABEL
d356 1
a356 1
          NLABEL = BUF(4)+0.5
d359 2
a360 2
          IRECMIN   = NROW*NSLICE + NROW*NSLICE / (NSAM/2) + NLABEL +
     &             LABREC
d608 2
a609 2
          NLABEL = 256 / NSAM + 1
          IF (IFORM .EQ. 0 .OR. IFORM .EQ. -2) NLABEL = -NROW*2/NSAM
d660 1
a660 1
          BUF(4) = NLABEL
d788 1
a788 1
          NLABEL = BUF(4)+0.5
@


1.6
log
@added if defined(__osf__) && defined()
@
text
@a94 1
        CHARACTER * 80 OUTSTR
d114 1
a114 1
           CALL SPOUT(0,'*** PGM. ERROR: LUN SET TO 99',0)
d130 1
a130 1
2096       WRITE(OUTSTR,2051) FILNM(1:NLET)
a131 1
           CALL SPOUT(0,OUTSTR,0)
d148 1
a148 1
              CALL SPOUT(0,'*** ERROR DELETING FILE',0)
d156 1
a156 1
2060	    WRITE(OUTSTR,2061) FILNM(1:NLET)
a157 1
            CALL SPOUT(0,OUTSTR,0)
d162 1
a162 1
2080        WRITE(OUTSTR,2081) NSAMAX
a163 1
            CALL SPOUT(0,OUTSTR,1)
d322 1
a322 1
            WRITE(OUTSTR,9002) FILNM(:NLET)
a323 1
            CALL SPOUT(0,OUTSTR,0)
d444 1
a444 1
          CALL SPOUT(0,'*** PGM. ERROR: UNKNOWN DISP IN OPENFB',1)
d472 1
a472 2
            WRITE(OUTSTR,9091) FILNM(:NLET)
            CALL SPOUT(-NDAT,OUTSTR,0)
d475 1
a475 1
            WRITE(OUTSTR,9090) FILNM(:NLET),CTIT(:LENTIT)
a476 1
            CALL SPOUT(-NDAT,OUTSTR,0)
d479 1
a479 2
            WRITE(OUTSTR,9091) FILNM(:NLET)
            CALL SPOUT(-NDAT,OUTSTR,0)
d482 1
a482 1
            WRITE(OUTSTR,9091) CTIT(1:LENT)
a483 1
            CALL SPOUT(-NDAT,OUTSTR,0)
d486 1
a486 2
              WRITE(OUTSTR,9091) CTIT(81:LENTIT)
              CALL SPOUT(-NDAT,OUTSTR,0)
d492 1
a492 1
            WRITE(OUTSTR,2099) TYPE,NSAM,NROW,NSLICE,CDAT,CTIM,DSP,FLEN
d496 1
a496 1
            WRITE(OUTSTR,2299)TYPE,NSAM,NROW,CDAT,CTIM,DSP,FLEN
a498 1
          CALL SPOUT(-NDAT,OUTSTR,0)
d513 1
a513 1
9999    WRITE(OUTSTR,9001) FILNM(:NLET)
a514 1
        CALL SPOUT(0,OUTSTR,0)
@


1.5
log
@fixed ifdef for cpp
@
text
@a1 1

d713 2
a714 2
c     
#ifdef __osf__ && osf_ieee
d838 1
a838 1
#ifdef  __osf__ && osf_ieee
@


1.4
log
@add __osf__ cpp option to port spider to DEC/OSF1(unix) machine
@
text
@d715 1
a715 1
#if __osf__ && osf_ieee
d839 1
a839 1
#if  __osf__ && osf_ieee
@


1.3
log
@fixed VMS
@
text
@d548 1
a548 1
        CHARACTER * 1  NULL,DISP,DSP
d658 7
d667 1
a667 1
     &    ACCESS='DIRECT',ERR=9999,RECL=LABBYT)
d711 16
d735 8
d744 1
a744 1
     &    ACCESS='DIRECT',ERR=9999,RECL=LENBYT)
d835 15
d868 7
d876 1
a876 1
     &         FORM='UNFORMATTED',RECL=LENBYT,ERR=9999)
@


1.2
log
@cpp_lines_added
@
text
@d1 2
a2 1
#ifdef VMS
d82 2
a85 3
#ifdef SP_UNIX
        INCLUDE 'CMBLOCK.INC'
#else
a86 4
#endif
#ifdef SP_UNIX
        INCLUDE 'LABLOCK.INC'
#else
d88 1
a88 1
#endif
d531 3
a536 2

#ifdef SP_UNIX
a537 4
#else
        INCLUDE 'COMMON1:CMBLOCK.INC'
#endif
#ifdef SP_UNIX
d539 1
a539 3
#else
        INCLUDE 'COMMON1:LABLOCK.INC'
#endif
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1

d83 3
d87 4
d92 1
d535 403
@
