head	1.24;
access;
symbols
	pre_getangas:1.11
	GPL2010:1.10
	pre_GPL2010:1.9
	pre_var_equation:1.9
	pre_fftwrings:1.8
	pre_opfiles:1.8
	src:1.8
	best-code:1.8
	x-named-regs:1.8
	x:1.8
	v13-00:1.8
	pre_GPL:1.7
	prec_CA:1.2;
locks; strict;
comment	@c @;


1.24
date	2016.11.16.18.52.21;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2012.10.26.14.59.32;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.08.15.46.23;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2012.01.13.17.17.20;	author leith;	state Exp;
branches;
next	1.20;

1.20
date	2012.01.11.14.37.42;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2011.12.29.17.43.13;	author leith;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.29.17.37.33;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2011.12.02.14.50.30;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2011.12.01.17.16.56;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2011.09.20.18.02.47;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.09.13.07.10;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	2011.08.29.17.37.14;	author leith;	state Exp;
branches;
next	1.12;

1.12
date	2011.08.29.17.36.22;	author leith;	state Exp;
branches;
next	1.11;

1.11
date	2011.02.08.16.54.44;	author leith;	state Exp;
branches;
next	1.10;

1.10
date	2010.06.24.13.25.04;	author leith;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.25.15.47.40;	author leith;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.17.21.06.50;	author leith;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.23.15.37.27;	author leith;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.23.15.34.14;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.18.14.34.00;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.10.19.58.59;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.28.19.39.37;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.05.14.22.33;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.27.14.33.11;	author leith;	state Exp;
branches;
next	;


desc
@new 'AP' op
@


1.24
log
@FQ_BUF REPLACED WITH FQ2
can denoise without  rotfist now
@
text
@
C++*********************************************************************
C
C    AP_GETDATA.F     EXTRACTED                 OCT. 2003 ARDEAN LEITH
C                     LS1... INTERNALIZED       DEC. 2003 ARDEAN LEITH
C                     CALLS NORM3               JUN  2004 ARDEAN LEITH
C                     REMOVED WINDOWING         MAR  2005 ARDEAN LEITH
C                     AVI & SIGI PARAMETERS     NOV  2008 ARDEAN LEITH
C                     ADDED GETDATS_RTSQ        FEB  2011 ARDEAN LEITH
C                     MERGED WITH AP_GETDAT     JUN  2011 ARDEAN LEITH
C                     PAD                       AUG  2011 ARDEAN LEITH
C                     AP_GETDATA_MASK           NOV  2011 ARDEAN LEITH
C                     AP_GETDATA_MASK_RTSQ      DEC  2011 ARDEAN LEITH
C                     RTSQ CALL                 DEC  2011 ARDEAN LEITH
C                     FQ_BUF REPLACED WITH FQ2  NOV  2016 ARDEAN LEITH
C                     DENOISE ONLY FOR _DEN     NOV  2016 ARDEAN LEITH
C
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2016  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@wadsworth.org                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  AP_GETDATA           (ILIST,NUMIMG, NX,NY,NXP,NYP,
C             NUMTH,EXPPAT,LUNIN,IGO,IEND,
C             MPIBCAST,BUFOUT,
C             WANTSTATS, AVI,SIGI, IRTFLG)
C
C  AP_GETDATA_RTSQ      (ILIST,NUMIMG, NX,NY, NXP,NYP, PADVAL,
C             NUMTH,EXPPAT,LUNIN, IGO,IEND,
C             ANGINHEADER,ANGEXP, 
C             MPIBCAST,BUFEXP,BUFOUT, 
C             WANTSTATS,AVI,SIGI,IRTFLG)
C
C  AP_GETDATA_MASK     (ILIST,NUMIMG, NX,NY, NXP,NYP, RADI,
C             NUMTH,EXPPAT,LUNIN, IGO,IEND,
C             MPIBCAST, BUFOUT, 
C             WANTSTATS,AVI,SIGI,  IRTFLG)
C
C  AP_GETDATA_MASK_RTSQ(ILIST,NUMIMG, NX,NY, NXP,NYP, RADI,
C             NUMTH,EXPPAT,LUNIN, IGO,IEND,
C             ANGINHEADER,ANGEXP, 
C             MPIBCAST,BUFEXP,BUFOUT,
C             WANTSTATS,AVI,SIGI,IRTFLG)
C
C  AP_GETDATA_DEN( ILIST,NUMIMG, NXT,NX,NY, N2XLD,N2X,N2Y, RADI,
C             NUMTH,EXPPAT,LUNIN, IGO,IEND,
C             ANGINHEADER,ANGEXP, MPIBCAST,
C             BUFEXP,BUFOUT,
C             FBS_WANTED,IRTFLG)
C
C PURPOSE:  RETURN SERIES OF IMAGE DATA IN ARRAY BUFOUT FOR 'AP' OPS.
C           CALLS NORM3 IF NEEDED. CAN LOAD MUTIPLE IMAGES.
C           RETURNS ARRAY OF IMAGE STATISTICS
C
C PARAMETERS:
C       ILIST               LIST OF IMAGE FILE NUMBERS        (INPUT)
C       NUMIMG              NO. OF IMAGES                     (INPUT)
C       NX,NY               IMAGE DIMENSIONS                  (INPUT)
C       NXP,NYP             PADDED IMAGE DIMENSIONS           (INPUT)
C       PADVAL              PAD VALUE                         (INPUT)
C       RADI                MASK RADIUS( OUTSIDE USE PADVAL)  (INPUT)
C       NUMTH               # THREADS                         (INPUT)
C       EXPPAT              IMAGE SERIES FILE TEMPLATE        (INPUT)
C       LUNIN               IMAGE FILE IO UNIT                (INPUT)
C       IGO,IEND            IMAGE INDEX RANGE                 (INPUT)
C       ANGINHEADER         ANGLES IN IMAGE HEADER            (INPUT)
C       MPIBCAST            USE MPI BCAST READ                (INPUT)
C       ANGEXP              ANGLES, ETC                       (IN/OUT)
C       BUFEXP              UNROTATED IMAGE ARRAY             (OUTPUT)
C       BUFOUT              FINAL IMAGE ARRAY                 (OUTPUT)
C       WANTSTATS           WANT STATISTICS                   (INPUT)
C       AVI,SIGI            STATISTICS ARRAYS                 (OUTPUT)
C       IRTFLG              ERROR FLAG                        (OUTPUT)
C
C--*********************************************************************

C       --------------------- AP_GETDATA ------------------------------

	SUBROUTINE AP_GETDATA(ILIST,NUMIMG, 
     &                       NX,NY, NXP,NYP, PADVAL,
     &                       NUMTH,EXPPAT,LUNIN, IGO,IEND,
     &                       MPIBCAST, BUFOUT, 
     &                       WANTSTATS,AVI,SIGI,  IRTFLG)

        IMPLICIT NONE

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER, INTENT(IN)          :: ILIST(NUMIMG)
        INTEGER, INTENT(IN)          :: NUMIMG
        INTEGER, INTENT(IN)          :: NX,NY,NUMTH, NXP,NYP
	REAL                         :: PADVAL
        CHARACTER (LEN=*),INTENT(IN) :: EXPPAT
        INTEGER, INTENT(IN)          :: LUNIN,IGO,IEND
	REAL                         :: BUFOUT(NXP,NYP,NUMTH)
        LOGICAL                      :: MPIBCAST
        LOGICAL                      :: WANTSTATS
	REAL,    INTENT(OUT)         :: AVI(NUMTH),SIGI(NUMTH)
        INTEGER, INTENT(OUT)         :: IRTFLG

        CHARACTER(LEN=MAXNAM)        :: FILNAM
        LOGICAL                      :: ONEIMAGE,PADIT
        INTEGER                      :: ITI,NLET,MAXIM,LX,LY
        INTEGER                      :: IFORMT,LZ,IT
        DOUBLE PRECISION             :: DAV,DSIG
        REAL                         :: UNUSED

        INTEGER                      :: INV
        INTEGER                      :: lnblnk
 
        !write(6,*) 'Reading images: ',igo,'...',iend,exppat(1:20)
        NLET   = lnblnk(EXPPAT)

        ONEIMAGE = (IGO <= 0 .OR. ILIST(IGO) <= 0)
        IF (ONEIMAGE) THEN
           FILNAM = EXPPAT
        ENDIF

        PADIT  = (NXP > NX .OR. NYP > NY)

        DO ITI=IGO,IEND

C          BUFOUT STARTING LOCATION
           IT = ITI - IGO + 1

           IF (.NOT. ONEIMAGE) THEN
              NLET = 0
              CALL FILGET(EXPPAT,FILNAM,NLET,ILIST(ITI),IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN
           ENDIF

           !write(6,*) 'Reading image: ',filnam(1:30),' ',oneimage,igo

C          OPEN EXISTING IMAGE FILE
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',IFORMT,
     &               LX,LY,LZ,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           CALL SIZCHK(UNUSED,LX,LY,  0,0,
     &                        NX, NY, 0,0,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
          
C          LOAD THE WHOLE IMAGE
           IF (PADIT) THEN
              CALL REDNPADVOL_SEL(LUNIN,PADVAL, 
     &                        NX, NY, 1,  NXP,NYP,1,MPIBCAST,
     &                        BUFOUT(1,1,IT), IRTFLG)
           ELSE
              CALL REDVOL_SEL(LUNIN,NX,NY,1,1,MPIBCAST, 
     &                        BUFOUT(1,1,IT), IRTFLG)
           ENDIF

           CLOSE(LUNIN)
           IF (IRTFLG .NE. 0) RETURN

           IF (WANTSTATS) THEN
              IF (IMAMI .NE. 1) THEN
C                FIND IMAGE STATISTICS, USE OPEN MP
                 CALL NORMVALSP(BUFOUT(1,1,IT), NX,NY,1, 
     &                          NXP,NYP,1,
     &                          DAV,DSIG,.TRUE.)
                 AV  = DAV     ! INTO COMMON
                 SIG = DSIG
              ENDIF
C             RECORD THE AVERAGE AND SD (FROM COMMON) FOR RETURN
              AVI(IT)  = AV
              SIGI(IT) = SIG
           ENDIF
        ENDDO

        IRTFLG = 0
        END

C       ************************** AP_GETDATA_RTSQ *******************
          
	SUBROUTINE AP_GETDATA_RTSQ(ILIST,NUMIMG, 
     &                          NX,NY, NXP,NYP, PADVAL,
     &                          NUMTH,EXPPAT,LUNIN, IGO,IEND,
     &                          ANGINHEADER,ANGEXP, 
     &                          MPIBCAST,BUFEXP,BUFOUT,
     &                          WANTSTATS,AVI,SIGI,FBS_WANTED,IRTFLG)

        IMPLICIT NONE
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER, INTENT(IN)   :: ILIST(NUMIMG)
        INTEGER, INTENT(IN)   :: NUMIMG
        INTEGER, INTENT(IN)   :: NX,NY,NUMTH,NXP,NYP
        CHARACTER (LEN=*)     :: EXPPAT
        INTEGER, INTENT(IN)   :: LUNIN, IGO,IEND
        LOGICAL, INTENT(IN)   :: ANGINHEADER
        REAL,    INTENT(IN)   :: ANGEXP(8,NUMIMG) 
        LOGICAL, INTENT(IN)   :: MPIBCAST
        REAL                  :: BUFEXP(NX,NY), PADVAL
	REAL,    INTENT(OUT)  :: BUFOUT(NXP,NYP,NUMTH)
        LOGICAL, INTENT(IN)   :: WANTSTATS
	REAL,    INTENT(OUT)  :: AVI(NUMTH),SIGI(NUMTH)
        LOGICAL, INTENT(IN)   :: FBS_WANTED
        INTEGER, INTENT(OUT)  :: IRTFLG

        INTEGER               :: ITI,NLET,MAXIM,IFORMT,LX,LY,LZ,IDUM,IT
        REAL                  :: SCALE,UNUSED,SHXI,SHYI,THETA
        CHARACTER(LEN=MAXNAM) :: FILNAM
        LOGICAL               :: ONEIMAGE,PADIT
        DOUBLE PRECISION      :: DAV,DSIG

        SCALE    = 1.0
        ONEIMAGE = (ILIST(IGO) <= 0)
        PADIT     = (NXP > NX .OR. NYP > NY)
        IF (PADIT) THEN
            CALL ERRT(101,'PGM ERROR, PADDING NOT IMPLEMENTED',IDUM)
            STOP
        ENDIF
C       write(6,*) 'Reading images: ',igo,'...',iend

        DO ITI=IGO,IEND
C          BUFOUT STARTING LOCATION
           IT = ITI-IGO+1

           IF (ONEIMAGE) THEN
              FILNAM = EXPPAT
           ELSE
              NLET = 0
              CALL FILGET(EXPPAT,FILNAM,NLET,ILIST(ITI),IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN
           ENDIF

C          OPEN EXISTING IMAGE FILE
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',IFORMT,
     &                  LX,LY,LZ, MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  RETURN

           CALL SIZCHK(UNUSED,LX,LY,0,0,
     &                        NX, NY, 0,0,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           IF (ANGINHEADER) THEN
C             GET ANGLES FROM IMAGE HEADER
              CALL LUNGETVALS(LUNIN,IAPLOC + 1,8,ANGEXP(1,ITI),IRTFLG)
              IF (IRTFLG .NE. 0) RETURN
           ENDIF

C          READ IN THE WHOLE IMAGE INTO BUFEXP
           CALL REDVOL_SEL(LUNIN,NX,NY,1,1, MPIBCAST,BUFEXP,IRTFLG)

           CLOSE(LUNIN)
           IF (IRTFLG .NE. 0) RETURN

C          SHIFT & ROTATE THE INPUT IMAGE --> BUFOUT  
           THETA = ANGEXP(4,ITI)
           SHXI  = ANGEXP(5,ITI)
           SHYI  = ANGEXP(6,ITI)

C          ROTATE AND SHIFT
           IF (FBS_WANTED) THEN
              CALL RTSF_PAD(BUFEXP,BUFOUT(1,1,IT),
     &                      NX,NY, NXP,NYP,
     &                      THETA,SCALE,SHXI,SHYI, IRTFLG)
           ELSE
              CALL RTSQ(BUFEXP,BUFOUT(1,1,IT),
     &                  NX,NY, NXP,NYP,
     &                  THETA,SCALE,SHXI,SHYI, IRTFLG)
           ENDIF

           IF (WANTSTATS) THEN
C             FIND IMAGE STATISTICS, (HAS MOVED SO NOT SAME)
              CALL NORMVALSP(BUFOUT(1,1,IT),NX,NY,1, 
     &                       NXP,NYP,1,
     &                       DAV,DSIG,.TRUE.)

C             RECORD THE AVERAGE AND SD 
              AVI(IT)  = DAV
              SIGI(IT) = DSIG
           ENDIF
        ENDDO

        IRTFLG = 0
        END

C       ************************** AP_GETDATA_MASK ***************

	SUBROUTINE AP_GETDATA_MASK(ILIST,NUMIMG, 
     &                       NX,NY, NXP,NYP, RADI,
     &                       NUMTH,EXPPAT,LUNIN, IGO,IEND,
     &                       MPIBCAST, BUFOUT, 
     &                       WANTSTATS,AVI,SIGI,  IRTFLG)

        IMPLICIT NONE

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER, INTENT(IN)          :: ILIST(NUMIMG)
        INTEGER, INTENT(IN)          :: NUMIMG
        INTEGER, INTENT(IN)          :: NX,NY,NUMTH, NXP,NYP
	REAL,    INTENT(IN)          :: RADI
        CHARACTER (LEN=*),INTENT(IN) :: EXPPAT
        INTEGER, INTENT(IN)          :: LUNIN,IGO,IEND
	REAL                         :: BUFOUT(NXP,NYP,NUMTH)
        LOGICAL                      :: MPIBCAST
        LOGICAL                      :: WANTSTATS
	REAL,    INTENT(OUT)         :: AVI(NUMTH),SIGI(NUMTH)
        INTEGER, INTENT(OUT)         :: IRTFLG

        CHARACTER(LEN=MAXNAM)        :: FILNAM
        LOGICAL                      :: ONEIMAGE,PADIT
        INTEGER                      :: ITI,NLET,MAXIM,LX,LY
        INTEGER                      :: IFORMT,LZ,IT
        DOUBLE PRECISION             :: DAV,DSIG
        REAL                         :: UNUSED

        INTEGER                      :: INV
        REAL                         :: XCEN,YCEN,RADISQ,RSQ,YSQTMP
        INTEGER                      :: IX,IY,IZ
 
        integer :: itype
        real :: avtmp

c       write(6,*) 'Reading images: ',igo,'...',iend

        ONEIMAGE = (IGO <= 0 .OR. ILIST(IGO) <= 0)
        IF (ONEIMAGE) THEN
           FILNAM = EXPPAT
        ENDIF

        PADIT  = (NXP > NX .OR. NYP > NY)

        IF (RADI > 0) THEN
           RADISQ = RADI **2

           XCEN   = NX/2 + 1
           YCEN   = NY/2 + 1
        ENDIF
 
        DO ITI=IGO,IEND

C          BUFOUT STARTING LOCATION
           IT = ITI - IGO + 1

           IF (.NOT. ONEIMAGE) THEN
              NLET = 0
              CALL FILGET(EXPPAT,FILNAM,NLET,ILIST(ITI),IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN
           ENDIF

C          OPEN EXISTING IMAGE FILE
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',IFORMT,
     &                  LX,LY,LZ,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           CALL SIZCHK(UNUSED,LX,LY,  0,0,
     &                        NX,NY,  0,0,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
          
           IF (WANTSTATS) THEN
              IF (IMAMI .NE. 1) THEN
C                FIND IMAGE STATISTICS
                 CALL NORM3(LUNIN,LX,LY,LZ, FMAX,FMIN,AV)
              ENDIF

C             RECORD THE AVERAGE AND SD (FROM COMMON)
              AVI(IT)  = AV
              SIGI(IT) = SIG ! IN COMMON
           ENDIF

C          LOAD THE WHOLE IMAGE
           IF (PADIT) THEN
              !write(6,*) ' padit; radi,av:',radi,av
              CALL REDMASKNPADVOL(LUNIN,AV,RADI, 
     &                            NX, NY, 1, NXP,NYP,1,MPIBCAST,
     &                            BUFOUT(1,1,IT),IRTFLG)
           ELSE
C             NOT PADDED
              CALL REDVOL_SEL(LUNIN,NX,NY,1,1,MPIBCAST, 
     &                        BUFOUT(1,1,IT),IRTFLG)
           ENDIF

#ifdef NEVER
           !write(6,*) ' radi,av:',radi,av,bufout(1,1,it)
           maxim = 0
           itype = 1
           call opfilec(0,.false.,'jnk0',98,'U',itype,
     &               nxp,nyp,1,maxim,' ',.true.,irtflg)
           call wrtvol(98,nxp,nyp, 1,1, bufout,irtflg)
           close(98)
#endif

           CLOSE(LUNIN)
           IF (IRTFLG .NE. 0) RETURN

           IF (.NOT. PADIT .AND. RADI > 0 .AND. WANTSTATS) THEN
C              MASK OUTSIDE CIRCLE USING AV
               AVTMP = AVI(IT)

               DO IY = 1,NY
                  YSQTMP = (FLOAT(IY) - YCEN) **2 
 
                  DO IX = 1,NX
                     RSQ = (FLOAT(IX) - XCEN) **2 + YSQTMP  
                     IF (RSQ > RADISQ) BUFOUT(IX,IY,IT) = AVTMP 
                  ENDDO
               ENDDO
            ENDIF

#ifdef NEVER
           maxim = 0
           itype = 1
           call opfilec(0,.false.,'jnk1',98,'U',itype,
     &               nxp,nyp,1,maxim,' ',.true.,irtflg)
           call wrtvol(98,nxp,nyp, 1,1, bufout,irtflg)
           close(98)
#endif

        ENDDO

        IRTFLG = 0
        END


C       ************************** AP_GETDATA_MASK_RTSQ ***************
    
	SUBROUTINE AP_GETDATA_MASK_RTSQ(ILIST,NUMIMG, 
     &                          NX,NY, NXP,NYP, RADI,
     &                          NUMTH,EXPPAT,LUNIN, IGO,IEND,
     &                          ANGINHEADER,ANGEXP, 
     &                          MPIBCAST,BUFEXP,BUFOUT,
     &                          WANTSTATS,AVI,SIGI,IRTFLG)

        IMPLICIT NONE
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER, INTENT(IN)   :: ILIST(NUMIMG)
        INTEGER, INTENT(IN)   :: NUMIMG
        INTEGER, INTENT(IN)   :: NX,NY,NUMTH,NXP,NYP
        REAL,    INTENT(IN)   :: RADI
        CHARACTER (LEN=*)     :: EXPPAT
        INTEGER, INTENT(IN)   :: LUNIN, IGO,IEND
        LOGICAL, INTENT(IN)   :: ANGINHEADER
        REAL,    INTENT(IN)   :: ANGEXP(8,NUMIMG) 
        LOGICAL, INTENT(IN)   :: MPIBCAST
        REAL                  :: BUFEXP(NX,NY)
	REAL,    INTENT(OUT)  :: BUFOUT(NXP,NYP,NUMTH)
        LOGICAL, INTENT(IN)   :: WANTSTATS
	REAL,    INTENT(OUT)  :: AVI(NUMTH),SIGI(NUMTH)
        INTEGER, INTENT(OUT)  :: IRTFLG

        INTEGER               :: ITI,NLET,MAXIM,IFORMT,LX,LY
        INTEGER               :: LZ,IT,IDUM
        REAL                  :: UNUSED,SHXI,SHYI,THETA,YSQTMP,AVTMP
        CHARACTER(LEN=MAXNAM) :: FILNAM
        LOGICAL               :: ONEIMAGE,PADIT
        DOUBLE PRECISION      :: DAV,DSIG
        REAL                  :: XCEN,YCEN,RADISQ,RSQ
        INTEGER               :: IX,IY,IZ

        REAL, PARAMETER       :: SCALE = 1.0

        ONEIMAGE = (ILIST(IGO) <= 0)
        IF (ONEIMAGE) THEN
           FILNAM = EXPPAT
        ENDIF
        PADIT    = (NXP > NX .OR. NYP > NY)

        IF (RADI > 0) THEN
           RADISQ = RADI **2

           XCEN   = NX/2 + 1
           YCEN   = NY/2 + 1
        ENDIF
  
C       write(6,*) 'Reading images: ',igo,'...',iend

        DO ITI=IGO,IEND

C          BUFOUT STARTING LOCATION
           IT = ITI - IGO + 1

           IF (.NOT. ONEIMAGE) THEN
              NLET = 0
              CALL FILGET(EXPPAT,FILNAM,NLET,ILIST(ITI),IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN
           ENDIF

C          OPEN EXISTING IMAGE FILE
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',IFORMT,
     &                  LX,LY,LZ, MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0)  RETURN

           CALL SIZCHK(UNUSED, LX,LY,0,0,  NX,NY,0,0, IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           IF (ANGINHEADER) THEN
C             GET ANGLES FROM IMAGE HEADER
              CALL LUNGETVALS(LUNIN,IAPLOC + 1,8,ANGEXP(1,ITI),IRTFLG)
              IF (IRTFLG .NE. 0) RETURN
           ENDIF

C          READ THE WHOLE IMAGE INTO: BUFEXP
           CALL REDVOL_SEL(LUNIN,NX,NY,1,1, MPIBCAST, BUFEXP,IRTFLG)

           CLOSE(LUNIN)
           IF (IRTFLG .NE. 0) RETURN

C          SHIFT & ROTATE THE INPUT IMAGE --> BUFOUT  
           THETA = ANGEXP(4,ITI)
           SHXI  = ANGEXP(5,ITI)
           SHYI  = ANGEXP(6,ITI)
           !print *,'rqs; thta,xy',THETA,SHXI,SHYI

C          ROTATE AND SHIFT
           CALL RTSQ(BUFEXP,BUFOUT(1,1,IT),
     &               NX,NY,NXP,NYP,
     &               THETA,SCALE,SHXI,SHYI,IDUM,0)

           IF (WANTSTATS) THEN
C             FIND IMAGE STATISTICS, (HAS MOVED SO NOT SAME)
              CALL NORMVALSP(BUFOUT(1,1,IT),NX,NY,1, 
     &                       NXP,NYP,1,
     &                       DAV,DSIG,.TRUE.)

C             RECORD THE AVERAGE AND SD 
              AVI(IT)  = DAV
              SIGI(IT) = DSIG

              IF (RADI > 0 ) THEN
C                MASK OUTSIDE CIRCLE USING: AV

                 AVTMP = AVI(IT)
                 DO IY = 1,NY
                    YSQTMP = (FLOAT(IY) - YCEN) **2 
 
                    DO IX = 1,NX
                       RSQ = (FLOAT(IX) - XCEN) **2 + YSQTMP
                       IF (RSQ > RADISQ) BUFEXP(IX,IY) = AVTMP 
                    ENDDO 
                 ENDDO     
              ENDIF
           ENDIF                
        ENDDO

        IRTFLG = 0
        END

          
C       ************************** AP_GETDATA_DEN *******************
          
C       INPUT: 2XFFT PAD, OUTPUT: UNPADDED    
	SUBROUTINE AP_GETDATA_DEN(ILIST,NUMIMG, 
     &                          NXT,NX,NY, N2XLD,N2X,N2Y, RADI,
     &                          NUMTH,EXPPAT,LUNIN, IGO,IEND,
     &                          ANGINHEADER,ANGEXP, MPIBCAST,
     &                          BUFEXP,BUFOUT,
     &                          FBS_WANTED,TRANSFORM,IRTFLG)

        IMPLICIT NONE

        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'CMBLOCK.INC'

        INTEGER, INTENT(IN)          :: ILIST(NUMIMG)
        INTEGER, INTENT(IN)          :: NUMIMG
        INTEGER, INTENT(IN)          :: NXT,NX,NY, N2XLD,N2X,N2Y
	REAL,    INTENT(IN)          :: RADI
        INTEGER, INTENT(IN)          :: NUMTH
        CHARACTER (LEN=*),INTENT(IN) :: EXPPAT
        INTEGER, INTENT(IN)          :: LUNIN,IGO,IEND
        LOGICAL, INTENT(IN)          :: ANGINHEADER
        REAL,    INTENT(IN)          :: ANGEXP(8,NUMIMG) 
        LOGICAL                      :: MPIBCAST
	REAL                         :: BUFEXP(N2XLD,N2Y) ! 2XFFT PAD
	REAL                         :: BUFOUT(NX,NY,NUMTH)
        LOGICAL, INTENT(IN)          :: FBS_WANTED,TRANSFORM
        INTEGER, INTENT(OUT)         :: IRTFLG

        CHARACTER(LEN=MAXNAM)        :: FILNAM
        LOGICAL                      :: ONEIMAGE,PADIT,MASKIT
        INTEGER                      :: ITI,NLET,MAXIM,LX,LY
        INTEGER                      :: IFORMT,LZ,IT,IDUM
        REAL                         :: UNUSED
        REAL                         :: BFPS(4),PARM1,PARM2,PARM3
        REAL                         :: THETA,SHXI,SHYI,SCALE
        INTEGER                      :: INV,IOPT
        INTEGER                      :: IX,IY,IZ

	REAL                         :: BUFTMP(NXT,NY)  ! UNPADDED
 
        !write(6,*) 'Reading images: ',igo,'...',iend,fbs_wanted

        ONEIMAGE = (IGO <= 0 .OR. ILIST(IGO) <= 0)
        IF (ONEIMAGE) FILNAM = EXPPAT

        MASKIT = (RADI > 0)
        IOPT   = 7            ! BUTTERWORTH LOW PASS FILTER
        PARM1  = 0.25         ! PASS-BAND FREQUENCY
        PARM2  = PARM1 + 0.15 ! STOP BAND FREQUENCY
        PARM3  = 0.0 
        BFPS   = 0.0 
        SCALE  = 1.0

        DO ITI=IGO,IEND

C          BUFOUT STARTING LOCATION
           IT = ITI - IGO + 1

           IF (.NOT. ONEIMAGE) THEN
              NLET = 0
              CALL FILGET(EXPPAT,FILNAM,NLET,ILIST(ITI),IRTFLG)
              IF (IRTFLG .NE. 0)  RETURN
           ENDIF

C          OPEN EXISTING IMAGE FILE
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',IFORMT,
     &                  LX,LY,LZ,MAXIM,' ',.FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           CALL SIZCHK(UNUSED,LX,LY,  0,0,
     &                        NX,NY,  0,0,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
          
           IF (ANGINHEADER) THEN
C             GET ANGLES FROM IMAGE HEADER
              CALL LUNGETVALS(LUNIN,IAPLOC + 1,8,ANGEXP(1,ITI),IRTFLG)
              IF (IRTFLG .NE. 0) RETURN
           ENDIF

           IF (MASKIT) THEN
C             PUTPUT: CIRCULAR MASKED, 2XFFT PADDED IMAGE
              !write(6,*) ' padit; radi,av:',radi,av
              CALL REDMASKNPADVOL(LUNIN,AV,RADI, 
     &                            NX, NY, 1, N2XLD,N2Y,1,MPIBCAST,
     &                            BUFEXP,IRTFLG)
           ELSE
C             OUTPUT: 2XFFT PADDED IMAGE
              CALL REDNPADVOL(LUNIN,AV, 
     &                        NX, NY, 1, N2XLD,N2Y,1,
     &                        BUFEXP,IRTFLG)
           ENDIF
           CLOSE(LUNIN)
           IF (IRTFLG .NE. 0) RETURN

           !write(6,*) ' radi,av:bufexp(50,50)',radi,av,bufexp(50,50)
           !call chkpadfile('jnkld',66,1, n2xld,n2y,1, nx,ny,1,bufexp,irtflg)

C          FORWARD FFT, 2XFFT PADDED
	   INV = 1
	   CALL FMRS_2(BUFEXP,N2X,N2Y,INV)
	   IF (INV == 0) THEN
	      IRTFLG = 1
	      RETURN
	   ENDIF

C          FOURIER LOWPASS BUTTERWORTH, 2XFFT PAD IN/OUT
           CALL FQ2(IOPT, PARM1,PARM2,PARM3,BFPS, 
     &              BUFEXP, N2XLD,N2X,N2Y, NX,NY, IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

C          REVERSE FFT, 2X PADDED
	   INV = -1
	   CALL FMRS_2(BUFEXP,N2X,N2Y,INV)

      !call chkpadfile('jnkfq2',66,1, n2xld,n2y,1, nx,ny,1,bufexp,irtflg)

           IF (TRANSFORM) THEN
C             SHIFT & ROTATE THE INPUT IMAGE --> BUFOUT  
              THETA = ANGEXP(4,ITI)
              SHXI  = ANGEXP(5,ITI)
              SHYI  = ANGEXP(6,ITI)

              !write(6,*) 'Theta,shifts',theta,shxi,shyi,fbs_wanted,numth,it

C             ROTATE AND SHIFT, FROM: 2xFFT PADDED TO: UNPADDED
              IF (FBS_WANTED) THEN
                 CALL RTSF_PADIN(BUFEXP,BUFOUT(1,1,IT),
     &                        NXT,NX,NY, N2XLD, 
     &                        THETA,SCALE, SHXI,SHYI, IRTFLG)
              ELSE
                 CALL RTSQ_PADIN(BUFEXP,BUFOUT(1,1,IT), 
     &                        N2XLD,N2Y, NX,NY,
     &                        THETA,SCALE, SHXI,SHYI, IRTFLG)
              ENDIF
           ELSE
C             UNPAD DENOISED IMAGE --> BUFOUT
              BUFOUT(1:NX,1:NY,IT) = BUFEXP(1:NX,1:NY)

           ENDIF

          !call chkfile('jnkrtsq',66,1,nx,ny,1, bufout(1,1,it),irtflg)

        ENDDO

        IRTFLG = 0

        END



@


1.23
log
@AP_GETDATA_DEN added
@
text
@d15 2
d22 1
a22 1
C=* Copyright 1985-2012  Health Research Inc.,                         *
d228 1
a228 1
        ONEIMAGE = (ILIST(IGO) .LE. 0)
a273 1
           !print *,'rtsq; thta,xy',THETA,SHXI,SHYI
d342 1
a342 1
        ONEIMAGE = (IGO .LE. 0 .OR. ILIST(IGO) .LE. 0)
d577 1
a577 1
     &                          FBS_WANTED,IRTFLG)
d596 1
a596 1
        LOGICAL, INTENT(IN)          :: FBS_WANTED
d604 1
a604 1
        REAL                         :: BFPS(4),FDUM
d613 1
a613 1
        ONEIMAGE = (IGO .LE. 0 .OR. ILIST(IGO) .LE. 0)
d616 7
a622 7
        MASKIT  = (RADI > 0)
        IOPT    = 7          ! BUTTERWORTH LOW PASS FILTER
        BFPS(1) = 0.25       ! PASS-BAND FREQUENCY
        BFPS(2) = 0.25 +0.15 ! STOP BAND FREQUENCY
        BFPS(3) = 0.0 
        BFPS(4) = 0.0 
        SCALE   = 1.0
d666 10
a675 2
           !write(6,*) ' radi,av:',radi,av,bufout(1,1,it)
           !call chkpadfile('jnkld',66,1, N2XLD,n2y,1, nx,ny,1,bufexp,irtflg)
d678 2
a679 2
           CALL FQ_BUF(IOPT,BFPS,FDUM,FDUM,FDUM,
     &                 BUFEXP, N2XLD,N2X,N2Y, NX,NY, IRTFLG)
d682 3
a684 2
           !call chkpadfile('jnkfq',66,1, N2XLD,n2y,1, nx,ny,1, bufexp,irtflg)
           !call chkfile('jnktmp',66,1,nx,ny,1, buftmp,irtflg)
d686 9
a694 5
C          SHIFT & ROTATE THE INPUT IMAGE --> BUFOUT  
           THETA = ANGEXP(4,ITI)
           SHXI  = ANGEXP(5,ITI)
           SHYI  = ANGEXP(6,ITI)
           !print *,'theta,shifts',theta,shxi,shyi,fbs_wanted
d696 3
a698 3
C          ROTATE AND SHIFT, FROM: 2xFFT PADDED  TO: UNPADDED
           IF (FBS_WANTED) THEN
              CALL RTSF_PADIN(BUFEXP,BUFOUT(1,1,IT),
d701 2
a702 2
           ELSE
              CALL RTSQ_PADIN(BUFEXP,BUFOUT(1,1,IT), 
d705 5
d712 1
a712 1
           !call chkfile('jnkout',66,1,nx,ny,1, BUFOUT(1,1,it),irtflg)
d719 2
@


1.22
log
@added comments; lnblnk defined; nlet set
@
text
@d60 6
d280 3
a282 3
              CALL RTSQ_PAD(BUFEXP,BUFOUT(1,1,IT),
     &                      NX,NY, NXP,NYP,
     &                      THETA,SCALE,SHXI,SHYI, IRTFLG)
d442 1
a442 1
        
d534 3
a536 3
           CALL RTSQ_PAD(BUFEXP,BUFOUT(1,1,IT),
     &                     NX,NY,NXP,NYP,
     &                     THETA,SCALE,SHXI,SHYI,IDUM,0)
d567 105
d673 27
a700 1
  
@


1.21
log
@removed IF (FBS_WANTED) WRITE(NOUT,*) 'USING FBS INTERPOLATI
@
text
@d20 1
a20 1
C=* Copyright 1985-2011  Health Research Inc.,                         *
d38 1
a38 1
C  AP_GETDATA(ILIST,NUMIMG, NX,NY,NXP,NYP,
d43 1
a43 1
C  AP_GETDATA_RTSQ(ILIST,NUMIMG, NX,NY, NXP,NYP, PADVAL,
d49 11
d119 1
d121 2
a122 1
c       write(6,*) 'Reading images: ',igo,'...',iend
d124 1
a124 1
        ONEIMAGE = (IGO .LE. 0 .OR. ILIST(IGO) .LE. 0)
d141 2
@


1.20
log
@added FBS_WANTED , RTSF_PAD
@
text
@a210 5

        IF (FBS_WANTED) THEN
          WRITE(NOUT,*) 'USING FBS INTERPOLATION IN RTSF TRANSFORM'
        ENDIF

d256 2
a257 2
     &                       NX,NY,NXP,NYP,
     &                       THETA,SCALE,SHXI,SHYI, IRTFLG)
d260 1
a260 1
     &                      NX,NY,NXP,NYP,
@


1.19
log
@rtqs --> rtsq
@
text
@a170 1

d177 1
a177 1
     &                          WANTSTATS,AVI,SIGI,IRTFLG)
d195 1
d212 4
d259 9
a267 3
           CALL RTSQ_PAD(BUFEXP,BUFOUT(1,1,IT),
     &                     NX,NY,NXP,NYP,
     &                     THETA,SCALE,SHXI,SHYI,IDUM,0)
@


1.18
log
@rtsq.f call, YSQTMP, rtsf call bug fixed
@
text
@d252 1
a252 1
           !print *,'rtqs; thta,xy',THETA,SHXI,SHYI
d255 1
a255 1
           CALL RTQS_PAD(BUFEXP,BUFOUT(1,1,IT),
d508 1
a508 1
           CALL RTQS_PAD(BUFEXP,BUFOUT(1,1,IT),
@


1.17
log
@comment
@
text
@d13 2
a74 1

d119 4
a138 3
C          BUFOUT STARTING LOCATION
           IT = ITI - IGO + 1

d161 1
a161 1
C             RECORD THE AVERAGE AND SD (FROM COMMON)
d215 3
d252 1
a252 4
           !print *,'rot2qs; thta,xy',THETA,SHXI,SHYI

C          XBUF STARTING LOCATION
           IT = ITI-IGO+1
d255 1
a255 1
           CALL ROT2QS_PAD(BUFEXP,BUFOUT(1,1,IT),
d307 1
a307 1
        REAL                         :: XCEN,YCEN,RADISQ,RSQ
d346 4
a360 4
           CALL SIZCHK(UNUSED,LX,LY,  0,0,
     &                        NX,NY,  0,0,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
          
d389 1
d391 2
d394 1
a394 2
                     RSQ = (FLOAT(IZ) - XCEN) **2 + 
     &                     (FLOAT(IY) - YCEN) **2  
d445 1
a445 1
        REAL                  :: SCALE,UNUSED,SHXI,SHYI,THETA
d452 5
a456 6
        SCALE    = 1.0
        ONEIMAGE = (ILIST(IGO) .LE. 0)
        PADIT     = (NXP > NX .OR. NYP > NY)
        IF (PADIT) THEN
            CALL ERRT(101,'PGM ERROR, PADDING NOT IMPLEMENTED',IDUM)
            STOP
d458 2
d471 2
a472 2
C          XBUF STARTING LOCATION
           IT = ITI-IGO+1
d474 1
a474 3
           IF (ONEIMAGE) THEN
              FILNAM = EXPPAT
           ELSE
d486 1
a486 10
           IF (WANTSTATS) THEN
              IF (IMAMI .NE. 1) CALL NORM3(LUNIN,LX,LY,1,FMAX,FMIN,AV)

C             RECORD THE AVERAGE AND SD (FROM COMMON)
              AVI(IT)  = AV
              SIGI(IT) = SIG  ! FROM COMMON
           ENDIF

           CALL SIZCHK(UNUSED,LX,LY,0,0,
     &                        NX, NY, 0,0,IRTFLG)
d495 1
a495 1
C          READ IN THE WHOLE IMAGE INTO BUFEXP
a500 11
           IF (RADI > 0 .AND. WANTSTATS) THEN
C             MASK OUTSIDE CIRCLE USING AV
              DO IY = 1,NY
                 DO IX = 1,NX
                    RSQ = (FLOAT(IZ) - XCEN) **2 + 
     &                    (FLOAT(IY) - YCEN) **2  
                    IF (RSQ > RADISQ) BUFEXP(IX,IY) = AV 
                 ENDDO
              ENDDO
           ENDIF                

d505 1
a505 1
           !print *,'rot2qs; thta,xy',THETA,SHXI,SHYI
d508 1
a508 1
           CALL ROT2QS_PAD(BUFEXP,BUFOUT(1,1,IT),
d511 25
@


1.16
log
@added: AP_GETDATA_MASK, AP_GETDATA_MASK_RTSQ REDVOL_SEL,
@
text
@d12 1
a12 1
C                     MASK                      NOV  2011 ARDEAN LEITH
@


1.15
log
@cosmetic
@
text
@d12 1
d36 1
a36 1
C  AP_GETDATA(ILIST,NUMIMG, NSAM,NROW,NSAMP,NROWP,
d38 1
a38 1
C             USEMPI,BUFOUT,
d41 1
a41 1
C  AP_GETDATA_RTSQ(ILIST,NUMIMG, NSAM,NROW, NSAMP,NROWP, PADVAL,
d44 1
a44 1
C             USEMPI,BUFEXP,BUFOUT, 
d54 4
a57 2
C       NSAM,NROW           IMAGE DIMENSIONS                  (INPUT)
C       NSAMP,NROWP         PADDED IMAGE DIMENSIONS           (INPUT)
d63 1
a63 1
C       USEMPI              USE MPI READ                      (INPUT)
d73 3
d77 1
a77 1
     &                       NSAM,NROW, NSAMP,NROWP, PADVAL,
d79 1
a79 1
     &                       USEMPI, BUFOUT, 
d89 1
a89 1
        INTEGER, INTENT(IN)          :: NSAM,NROW,NUMTH, NSAMP,NROWP
d93 2
a94 2
	REAL                         :: BUFOUT(NSAMP,NROWP,NUMTH)
        LOGICAL                      :: USEMPI
d101 2
a102 2
        INTEGER                      :: ITI,NLET,MAXIM,LSAM,LROW
        INTEGER                      :: IFORMT,LSLICE,IT
d115 1
a115 1
        PADIT  = (NSAMP > NSAM .OR. NROWP > NROW)
d127 1
a127 1
     &               LSAM,LROW,LSLICE,MAXIM,' ',.FALSE.,IRTFLG)
d130 2
a131 2
           CALL SIZCHK(UNUSED,LSAM,LROW,  0,0,
     &                        NSAM, NROW, 0,0,IRTFLG)
d138 4
a141 10
           IF (.NOT. USEMPI) THEN
              IF (PADIT) THEN
                 CALL REDNPADVOL(LUNIN,PADVAL, 
     &                           NSAM, NROW, 1,
     &                           NSAMP,NROWP,1,
     &                           BUFOUT(1,1,IT), IRTFLG)
              ELSE
                 CALL REDVOL(LUNIN,NSAM,NROW,1,1, 
     &                       BUFOUT(1,1,IT), IRTFLG)
              ENDIF
d143 4
a146 12
#ifdef USE_MPI
              IF (PADIT) THEN
                 CALL REDNPADVOL_1P(LUNIN,PADVAL, 
     &                              NSAM, NROW, 1,
     &                              NSAMP,NROWP,1,
     &                              BUFOUT(1,1,IT), IRTFLG)
              ELSE
                 CALL REDVOL1P(LUNIN,NSAM,NROW,1,1, 
     &                         BUFOUT(1,1,IT),IRTFLG)
              ENDIF
#endif
           ENDIF 
d153 2
a154 2
                 CALL NORMVALSP(BUFOUT(1,1,IT), NSAM,NROW,1, 
     &                          NSAMP,NROWP,1,
d172 1
a172 1
     &                          NSAM,NROW, NSAMP,NROWP, PADVAL,
d175 1
a175 1
     &                          USEMPI,BUFEXP,BUFOUT,
d184 1
a184 1
        INTEGER, INTENT(IN)   :: NSAM,NROW,NUMTH,NSAMP,NROWP
d189 3
a191 3
        LOGICAL, INTENT(IN)   :: USEMPI
        REAL                  :: BUFEXP(NSAM,NROW), PADVAL
	REAL,    INTENT(OUT)  :: BUFOUT(NSAMP,NROWP,NUMTH)
d196 1
a196 2
        INTEGER               :: ITI,NLET,MAXIM,IFORMT,LSAM,LROW
        INTEGER               :: LSLICE,IT,IDUM
d204 6
a209 2
        PADIT     = (NSAMP > NSAM .OR. NROWP > NROW)
         
d224 1
a224 1
     &                  LSAM,LROW,LSLICE, MAXIM,' ',.FALSE.,IRTFLG)
d227 2
a228 2
           CALL SIZCHK(UNUSED,LSAM,LROW,0,0,
     &                        NSAM, NROW, 0,0,IRTFLG)
d238 1
a238 9
           IF (.NOT. USEMPI) THEN
               CALL REDVOL(LUNIN,NSAM,NROW,1,1, 
     &                     BUFEXP, IRTFLG)
           ELSE
#ifdef USE_MPI
               CALL REDVOL1P(LUNIN,NSAM,NROW,1,1, 
     &                       BUFEXP,IRTFLG)
#endif
           ENDIF
d254 1
a254 1
     &                     NSAM,NROW,NSAMP,NROWP,
d259 2
a260 2
              CALL NORMVALSP(BUFOUT(1,1,IT),NSAM,NROW,1, 
     &                       NSAMP,NROWP,1,
d267 261
@


1.14
log
@normvalsp parameters increased
@
text
@d35 1
a35 1
C  AP_GETDATA(ILIST,NUMIMG,NSAM,NROW,NSAMP,NROWP,
d37 2
a38 1
C             USEMPI,XBUF,WANTSTATS,AVI,SIGI, IRTFLG)
d40 5
a44 3
C  AP_GETDATA_RTSQ(ILIST,NUMIMG,NSAM,NROW,NSAMP,NROWP,
C                  NUMTH,EXPPAT,LUNIN, IGO,IEND,
C                  ANGINHEADER,ANGEXP, BUFTMP,BUFOUT,AVI,SIGI,IRTFLG)
d46 2
a47 2
C PURPOSE:  READ SERIES OF IMAGE DATA INTO ARRAY XBUF FOR 'AP' OPS.
C           CALLS NORM3 IF NEEDED. CAN LOAD MUTIPLE IMAGES
d60 1
d62 2
a63 3
C       BUFTMP              WORKING IMAGE ARRAY               (OUTPUT)
C       USEMPI              USE MPI READ                      (INPUT)
C       BUFOUT              IMAGE ARRAY                       (OUTPUT)
d65 1
a65 1
C       AVI,SIGI            STATISTICS ARRAY                  (OUTPUT)
d73 1
a73 1
     &                       USEMPI, BUFIMG, 
d87 1
a87 1
	REAL                         :: BUFIMG(NSAMP,NROWP,NUMTH)
d128 1
a128 1
C          BUFIMG STARTING LOCATION
d137 1
a137 1
     &                           BUFIMG(1,1,IT), IRTFLG)
d140 1
a140 1
     &                       BUFIMG(1,1,IT), IRTFLG)
d148 1
a148 1
     &                              BUFIMG(1,1,IT), IRTFLG)
d151 1
a151 1
     &                         BUFIMG(1,1,IT),IRTFLG)
d161 1
a161 1
                 CALL NORMVALSP(BUFIMG(1,1,IT), NSAM,NROW,1, 
@


1.13
log
@removed some routines
@
text
@d158 2
a159 1
                 CALL NORMVALSP(BUFIMG(1,1,IT),NSAM,NROW, NSAMP,NROWP,
d269 2
a270 1
              CALL NORMVALSP(BUFOUT(1,1,IT),NSAM,NROW, NSAMP,NROWP,
@


1.12
log
@renamed, param changes, padding added
@
text
@d282 1
a282 75
         SUBROUTINE ROT2QS_PAD(XIMG,BUFOUT, NSAM,NROW, NSAMP,NROWP,
     &                     THETA,SCLI,SHXI,SHYI, IREC1,LUN)

         IMPLICIT NONE
         REAL            :: XIMG(NSAM,NROW)
         REAL            :: BUFOUT(NSAMP,NROWP)   ! Y MAY BE: 1
         INTEGER         :: NSAM,NROW, NSAMP,NROWP
         REAL            :: THETA,SCLI,SHXI,SHYI
         INTEGER         :: IREC1,LUN

	 REAL, PARAMETER :: QUADPI = 3.14159265358979323846
	 REAL, PARAMETER :: DGR_TO_RAD = (QUADPI/180)

         REAL            :: SHX,SHY,RN2,SN2,RW2,RS2,COD,SID,XI
         REAL            :: CODDSCLI,SIDDSCLI,FKCENTMSHX,FICENTMSHY 
         REAL            :: RE1,RE2,RF1,RF2,YI,YCOD,YSID,X1,YOLD,XOLD
         INTEGER         :: ICENT,KCENT,IT,I,K

         REAL            :: QUADRI


         SHX   = AMOD(SHXI,FLOAT(NSAM))
         SHY   = AMOD(SHYI,FLOAT(NROW))
         ICENT = NROW/2+1
         KCENT = NSAM/2+1
         RN2   = -NROW/2
         SN2   = -NSAM/2
         RW2   = -RN2
         RS2   = -SN2

         IF (MOD(NSAM,2) .EQ. 0) RW2 = RW2 - 1.0
         IF (MOD(NROW,2) .EQ. 0) RS2 = RS2 - 1.0

         COD        = COS(THETA * DGR_TO_RAD)
         SID        = SIN(THETA * DGR_TO_RAD)
         CODDSCLI   = COD / SCLI
         SIDDSCLI   = SID / SCLI

         FKCENTMSHX = -KCENT - SHX
         FICENTMSHY = -ICENT - SHY

         RE1        = RW2 - RN2 + 1.0
         RE2        = RN2 - RW2 - 1.0
         RF1        = RS2 - SN2 + 1.0
         RF2        = SN2 - RS2 - 1.0

         IT = 1             ! IF WRITING TO OUTPUT
         DO I=1,NROW
            IF (LUN .LE. 0) IT = I

            YI = I + FICENTMSHY
            IF (YI.LT.RN2) YI = MIN(YI+RE1, RW2)
            IF (YI.GT.RW2) YI = MAX(YI+RE2, RN2)

            YCOD =  YI * CODDSCLI + ICENT
            YSID = -YI * SIDDSCLI + KCENT

c$omp       parallel do private(k,xi,xold,yold)
            DO K=1,NSAM
               XI = K + FKCENTMSHX                           
               IF (XI .LT. SN2) XI = MIN(XI+RF1, RS2)   
               IF (XI .GT. RS2) XI = MAX(XI+RF2, SN2)  
               YOLD         = XI * SIDDSCLI + YCOD  
               XOLD         = XI * CODDSCLI + YSID  
               BUFOUT(K,IT) = QUADRI(XOLD, YOLD, NSAM, NROW, XIMG)
            ENDDO

            IF (LUN .GT. 0) THEN
C              WRITE CURRENT LINE TO FILE
               CALL WRTLIN(LUN,BUFOUT,NSAM,IREC1+I)
            ENDIF
         ENDDO
         END


@


1.11
log
@ADDED GETDATS_RTSQ
@
text
@d4 1
a4 1
C    AP_GETDATS.F     EXTRACTED                 OCT. 2003 ARDEAN LEITH
d10 2
d35 7
a41 2
C  AP_GETDATS(ILIST,NUMIMG,LSAM,LROW,NUMTH,EXPPAT,LUNIN, IGO,IEND,
C                 XBUF,AVI,SIGI, IRTFLG)
d50 3
a52 2
C       nSAM,nROW           IMAGE DIMENSIONS                  (INPUT)
C       numth               # threads                         (INPUT)
d59 1
d61 1
a64 2
C  VARIABLES:
C
d67 2
a68 1
	SUBROUTINE AP_GETDATS(ILIST,NUMIMG, LSAM,LROW,
d70 2
a71 1
     &                       XBUF,AVI,SIGI, IRTFLG)
d79 3
a81 2
        INTEGER,INTENT(IN)           :: NUMIMG
        INTEGER,INTENT(IN)           :: LSAM,LROW,NUMTH
d83 6
a88 4
        INTEGER,INTENT(IN)           :: LUNIN,IGO,IEND
	REAL                         :: XBUF(LSAM,LROW,NUMTH)
	REAL,  INTENT(OUT)           :: AVI(NUMTH),SIGI(NUMTH)
        INTEGER,INTENT(OUT)          :: IRTFLG
d91 4
a94 4
        LOGICAL                      :: ONEIMAGE
        INTEGER                      :: ITI,NLET,MAXIM,LSAMT,LROWT
        INTEGER                      :: NSLICE,IT
        DOUBLE PRECISION             :: AVD,VRD
d97 2
d102 5
d109 1
a109 3
           IF (ONEIMAGE) THEN
              FILNAM = EXPPAT
           ELSE
d117 2
a118 2
           CALL OPFILEC(0,.FALSE.,FILNAM,LUNIN,'O',IFORM,
     &               LSAMT,LROWT,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
d121 2
a122 2
           CALL SIZCHK(UNUSED,LSAMT,LROWT,0,0,
     &                        LSAM, LROW, 0,0,IRTFLG)
d125 2
a126 2
C          XBUF STARTING LOCATION
           IT = ITI-IGO+1
d129 23
a151 1
           CALL REDVOL(LUNIN,LSAM,LROW,1,1, XBUF(1,1,IT),IRTFLG) 
d155 9
a163 7
           IF (IMAMI .NE. 1) THEN
C             FIND IMAGE STATISTICS, USE OPEN MP
              CALL NORMVALS(XBUF(1,1,IT),LSAM,LROW,AVD,VRD,.TRUE.)
              AVI(IT)  = AVD
              SIGI(IT) = VRD
           ELSE
C             RECORD THE AVERAGE AND SD (IN COMMON)
d172 1
a172 1
C       ************************** AP_GETDATS_RTSQ *******************
d174 3
a176 1
	SUBROUTINE AP_GETDATS_RTSQ(ILIST,NUMIMG,NSAM,NROW,
d179 2
a180 1
     &                          BUFTMP,BUFOUT,AVI,SIGI,IRTFLG)
d188 1
a188 1
        INTEGER, INTENT(IN)   :: NSAM,NROW,NUMTH
d192 6
a197 4
        REAL, INTENT(IN)      :: ANGEXP(8,NUMIMG) 
        REAL                  :: BUFTMP(NSAM,NROW)
	REAL, INTENT(OUT)     :: BUFOUT(NSAM,NROW,NUMTH)
	REAL, INTENT(OUT)     :: AVI(NUMTH),SIGI(NUMTH)
d200 2
a201 2
        INTEGER               :: ITI,NLET,MAXIM,IFORMT,LSAMT,LROWT
        INTEGER               :: NSLICE,IT,IDUM
d204 2
a205 2
        LOGICAL               :: ONEIMAGE
        DOUBLE PRECISION      :: AVT,SIGT
d209 1
d225 1
a225 1
     &                  LSAMT,LROWT,NSLICE,MAXIM,' ',.FALSE.,IRTFLG)
d228 1
a228 1
           CALL SIZCHK(UNUSED,LSAMT,LROWT,0,0,
d238 11
a248 2
C          READ IN THE WHOLE IMAGE
           CALL REDVOL(LUNIN,NSAM,NROW,1,1, BUFTMP,IRTFLG) 
d262 14
a275 2
           CALL ROT2QS(BUFTMP,BUFOUT(1,1,IT),NSAM,NROW,
     &                 THETA,SCALE,SHXI,SHYI,IDUM,0)
d277 2
a278 2
C          FIND IMAGE STATISTICS, (HAS MOVED SO NOT SAME)
           CALL NORMVALS(BUFTMP,NSAM,NROW, AVT,SIGT,.TRUE.)
a279 3
C          RECORD THE AVERAGE AND SD 
           AVI(IT)  = AVT
           SIGI(IT) = SIGT
a280 1
        ENDDO
d282 2
a283 2
        IRTFLG = 0
        END
d285 70
@


1.10
log
@GPL_2010
@
text
@d4 6
a9 5
C    AP_GETDATS.F       EXTRACTED                 OCT. 2003 ARDEAN LEITH
C                       LS1... INTERNALIZED       DEC. 2003 ARDEAN LEITH
C                       CALLS NORM3               JUN  2004 ARDEAN LEITH
C                       REMOVED WINDOWING         MAR  2005 ARDEAN LEITH
C                       AVI & SIGI PARAMETERS     NOV  2008 ARDEAN LEITH
d15 1
a15 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d33 1
a33 1
C  AP_GETDATS(ILIST,NUMIMG,LSAM,LROW,NUMTH,EXPPAT,INPIC, IGO,IEND,
d43 2
a44 1
C       LSAM,LROW           IMAGE DIMENSIONS                  (INPUT)
d46 1
a46 1
C       INPIC               IMAGE FILE IO UNIT                (INPUT)
d48 4
a51 1
C       XBUF                IMAGE ARRAY                       (OUTPUT)
a52 1
C       XBUF                OUTPUT ARRAY                      (OUTPUT)
d60 1
a60 1
     &                       NUMTH,EXPPAT,INPIC, IGO,IEND,
d63 2
d68 15
a82 13
        INTEGER, DIMENSION(NUMIMG),INTENT(IN)        :: ILIST
        INTEGER,INTENT(IN)                           :: NUMIMG
        INTEGER,INTENT(IN)                           :: LSAM,LROW,NUMTH
        CHARACTER (LEN=*),INTENT(IN)                 :: EXPPAT
        INTEGER,INTENT(IN)                           :: INPIC,IGO,IEND
	REAL, DIMENSION(LSAM,LROW,NUMTH)             :: XBUF
	REAL, DIMENSION(NUMTH),INTENT(OUT)           :: AVI,SIGI
        INTEGER,INTENT(OUT)                          :: IRTFLG

        CHARACTER(LEN=MAXNAM)                        :: FILNAM
        LOGICAL                                      :: ONEIMAGE

        IRTFLG = 1
d99 1
a99 1
           CALL OPFILEC(0,.FALSE.,FILNAM,INPIC,'O',IFORM,
d101 77
d180 8
a187 4
           IF (LSAMT.NE.LSAM .OR. LROWT.NE.LROW)  THEN
              CALL ERRT(102,'INCONSISTENT IMAGE SIZE',LSAMT)
              IRTFLG = 1
              RETURN
d189 12
a200 5
           IF (IMAMI .NE. 1) THEN
C             FIND IMAGE STATISTICS
              CALL NORM3(INPIC,LSAM,LROW,NSLICE,FMAX,FMIN,AV)
           ENDIF
           
d204 10
a213 3
C          RECORD THE AVERAGE AND SD (IN COMMON)
           AVI(IT)  = AV
           SIGI(IT) = SIG
a214 4
C          LOAD THE WHOLE IMAGE
           CALL REDVOL(INPIC,LSAM,LROW,1,1, XBUF(1,1,IT),IRTFLG) 
           CLOSE(INPIC)
           IF (IRTFLG .NE. 0) RETURN
d219 2
@


1.9
log
@ added avi,sigi
@
text
@a10 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2008  Health Research Inc.                      *
d12 5
a16 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d18 1
a18 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d23 1
a23 1
C=* This program is distributed in the hope that it will be useful,    *
d25 1
a25 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a26 1
C=*                                                                    *
d28 1
a28 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.8
log
@GPL License fixed
@
text
@d8 1
d12 1
a12 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d36 2
a37 2
C  AP_GETDATS(ILIP,NIMA,LSAM,LROW,NUMTH,EXPPAT,INPIC, IGO,IEND,
C                 X, IRTFLG)
d39 1
a39 1
C PURPOSE:  READ IMAGE DATA INTO ARRAY X FOR 'AP' OPS.
d41 1
d44 2
a45 2
C       ILIP                LIST OF IMAGE FILE NUMBERS        (INPUT)
C       NIMA                NO. OF IMAGES                     (INPUT)
d50 3
a52 1
C       X                   OUTPUT ARRAY                      (OUTPUT)
d59 1
a59 1
	SUBROUTINE AP_GETDATS(ILIP,NIMA,LSAM,LROW,
d61 1
a61 1
     &                       X,IRTFLG)
d66 8
a73 3
	REAL, DIMENSION(LSAM,LROW,NUMTH)             :: X
        INTEGER, DIMENSION(NIMA)                     :: ILIP
        CHARACTER (LEN=*)                            :: EXPPAT
d82 1
a82 2
        ONEIMAGE = (IGO .LE. 0 .OR. ILIP(IGO) .LE. 0)
c       write(6,*) 'ONEIMAGE: ',ONEIMAGE,NIMA
d89 1
a89 1
              CALL FILGET(EXPPAT,FILNAM,NLET,ILIP(ITI),IRTFLG)
d93 1
d104 7
a110 2
           IF (IMAMI .NE. 1) 
     &         CALL NORM3(INPIC,LSAM,LROW,NSLICE,FMAX,FMIN,AV)
d112 3
a114 1
           IT = ITI-IGO+1
d116 2
a117 2
C          READ IN THE WHOLE IMAGE
           CALL REDVOL(INPIC,LSAM,LROW,1,1, X(1,1,IT),IRTFLG) 
@


1.7
log
@removed windowing
@
text
@d10 23
a32 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 2003. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.6
log
@removed windowing
@
text
@d31 1
a31 1
       X                   OUTPUT ARRAY                      (OUTPUT)
d36 1
a36 1
C--************************************************************************
@


1.5
log
@CALLS NORM3 IF NEEDED
@
text
@d6 2
a7 1
C                       CALLS NORM#               JUN  2004 ARDEAN LEITH
d18 1
a18 1
C  AP_GETDATS(ILIP,NIMA,LSAM,LROW,NSAM,NROW,NUMTH,EXPPAT,INPIC, IGO,IEND,
d21 2
a22 2
C PURPOSE:  READ WINDOWED IMAGE DATE INTO ARRAY X FOR 'AP' OPS.
C           CALLS NORM3 IF NEEDED
a27 1
C       NSAM,NROW           OUTPUT IMAGE DIMENSIONS           (INPUT)
d31 1
a31 2
C       LR1,LR2,LS1,LS2     OUTPUT IMAGE WINDOW               (INPUT)
C       X                   OUTPUT ARRAY                      (OUTPUT)
a34 1
C       LR1,LR2,LS1,LS2     OUTPUT IMAGE WINDOW                
d38 1
a38 1
	SUBROUTINE AP_GETDATS(ILIP,NIMA,LSAM,LROW,NSAM,NROW,
d45 1
a45 3
        COMMON /IOBUF/ BUFIN(NBUFSIZ)

	REAL, DIMENSION(NSAM,NROW,NUMTH)             :: X
a49 1
        LOGICAL                                      :: WINDOW
a51 2
C       AUTOMATIC ARRAY

a53 17
        WINDOW = (NROW .NE. LROW .OR. NSAM .NE. LSAM) 
        IF (WINDOW) THEN
           LQ   = LROW/2+1
           LR1  = (NROW-1)/2
           LR2  = LQ+LR1
           LR1  = LQ-LR1
           LQ   = LSAM/2+1
           LS1  = (NSAM-1)/2
           LS2  = LQ+LS1
           LS1  = LQ-LS1
        ELSE
           LS1  = 1
           LS2  = LSAM
           LR1  = 1
           LR2  = LROW
       ENDIF 

d79 1
a79 1
     &         CALL NORM3(INPIC,LSAMT,LROWT,NSLICE,FMAX,FMIN,AV)
d82 3
a84 14
           IF (WINDOW) THEN
C             READ IN CENTRAL WINDOW FROM THE WHOLE IMAGE
              DO K2=LR1,LR2
                 CALL REDLIN(INPIC,BUFIN,LSAM,K2)
                 KT = K2-LR1+1
                 DO K3=LS1,LS2
                    X(K3-LS1+1,KT,IT) = BUFIN(K3)
                 ENDDO
              ENDDO
           ELSE
C             READ IN THE WHOLE IMAGE
              CALL REDVOL(INPIC,LSAM,LROW,1,1, X(1,1,IT),IRTFLG) 
              IF (IRTFLG .NE. 0) RETURN
           ENDIF
d86 1
@


1.4
log
@oneimage error
@
text
@d6 1
d21 1
d102 2
d125 1
@


1.3
log
@cosmetic & lsamt output on errt
@
text
@d2 1
a2 1
C++************************************************************************
d4 2
a5 1
C    AP_GETDAT.F
d16 2
a17 2
C  AP_GETDAT(ILIP,NIMA,LSAM,LROW,NSAM,NROW,NUMTH,EXPPAT,INPIC, IGO,IEND,
C                 LR1,LR2,LS1,LS2, X, IRTFLG)
d19 1
a19 1
C PURPOSE:       READ READ WINDOWED IMAGE DATE INTO ARRAY X FOR 'AP' OPS.
d33 3
d38 1
a38 1
	SUBROUTINE AP_GETDAT(ILIP,NIMA,LSAM,LROW,NSAM,NROW,
d40 1
a40 2
     &                       LR1,LR2,LS1,LS2, X,
     &                       IRTFLG)
d45 2
a55 1
        REAL, DIMENSION(LSAM)                        :: BUFIN
d59 16
a74 2
        WINDOW = (LR1 .NE. 1    .OR. LS1 .NE. 1 .OR.
     &            LR2 .NE. LROW .OR. LS2 .NE. LSAM) 
d76 1
a76 1
C       write(6,*) 'Reading images: ',igo,'...',iend
d78 2
a79 1
        ONEIMAGE = (ILIP(IGO) .LE. 0)
@


1.2
log
@'OR MQ' support
@
text
@d77 1
a77 1
              CALL ERRT(101,'INCONSISTENT IMAGE SIZE',LSAMT)
d83 1
a83 1
           IF (WINDOW)  THEN
d86 1
a86 1
                 CALL  REDLIN(INPIC,BUFIN,LSAM,K2)
d95 1
a95 1
              IF (IRTFLG .NE. 0)  RETURN
@


1.1
log
@Initial revision
@
text
@d6 8
a13 9
C **************************************************************************
C *  SPIDER - MODULAR IMAGE PROCESSING SYSTEM.  AUTHOR: J.FRANK            *
C *  COPYRIGHT (C)1981,1987, WADSWORTH CENTER FOR LABORATORIES AND         *
C *  RESEARCH, NEW YORK STATE DEPARTMENT OF HEALTH, ALBANY, NY 12201.      *
C *  THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO THE CENTER FOR       *
C *  LABORATORIES AND RESEARCH AND ARE NOT TO BE DISCLOSED TO OTHERS OR    *
C *  USED FOR PURPOSES OTHER THAN INTENDED WITHOUT WRITTEN APPROVAL OF     *
C *  THE CENTER FOR LABORATORIES AND RESEARCH   			   *
C **************************************************************************
d21 1
a21 1
C       ILIST               LIST OF IMAGE FILE NUMBERS        (INPUT)
d23 2
d27 2
d60 1
a60 7
        IGOT  = IGO
        IENDT = IEND
        ONEIMAGE = (IGOT .EQ. 0)
        IF (ONEIMAGE) THEN
           IGOT = 1  
           IENDT = 1
        ENDIF
d62 1
a62 1
        DO ITI=IGOT,IENDT
d82 1
a82 1
           IT = ITI-IGOT+1
@
