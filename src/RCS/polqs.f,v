head	1.30;
access;
symbols
	pre_mrcs:1.30
	healthdept_2018:1.30
	pre_getangas:1.28
	GPL2010:1.28
	pre_GPL2010:1.27
	pre_var_equation:1.27
	pre_fftwrings:1.27
	pre_opfiles:1.26
	src:1.26
	best-code:1.26
	x-named-regs:1.26
	x:1.26
	v13-00:1.25
	pre_GPL:1.24
	prec_CA:1.23
	noindx:1.22
	Bproc:1.17
	oct21:1.12
	last77:1.7;
locks; strict;
comment	@c @;


1.30
date	2018.10.03.14.34.12;	author leith;	state Exp;
branches;
next	1.29;

1.29
date	2014.07.29.15.44.26;	author leith;	state Exp;
branches;
next	1.28;

1.28
date	2010.06.24.13.26.30;	author leith;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.26.18.58.42;	author leith;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.02.14.16.05;	author leith;	state Exp;
branches;
next	1.25;

1.25
date	2005.10.17.20.58.57;	author leith;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.15.16.39.24;	author leith;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.19.20.51.39;	author leith;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.11.14.08.55;	author leith;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.13.22.02.42;	author pawel;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.13.15.33.49;	author leith;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.21.22.34.49;	author pawel;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.18.17.47.15;	author leith;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.07.13.30.28;	author leith;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.06.21.04.34;	author leith;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.06.18.40.20;	author leith;	state Exp;
branches;
next	1.14;

1.14
date	99.12.07.19.14.04;	author leith;	state Exp;
branches;
next	1.13;

1.13
date	99.11.10.16.53.50;	author pawel;	state Exp;
branches;
next	1.12;

1.12
date	99.08.23.20.23.07;	author pawel;	state Exp;
branches;
next	1.11;

1.11
date	99.07.30.14.14.11;	author pawel;	state Exp;
branches;
next	1.10;

1.10
date	99.07.27.19.15.17;	author pawel;	state Exp;
branches;
next	1.9;

1.9
date	99.07.14.21.12.09;	author pawel;	state Exp;
branches;
next	1.8;

1.8
date	99.06.03.20.50.55;	author pawel;	state Exp;
branches;
next	1.7;

1.7
date	99.03.17.16.43.41;	author pawel;	state Exp;
branches;
next	1.6;

1.6
date	99.03.16.20.04.07;	author pawel;	state Exp;
branches;
next	1.5;

1.5
date	99.03.16.20.02.30;	author pawel;	state Exp;
branches;
next	1.4;

1.4
date	99.03.01.15.05.00;	author pawel;	state Exp;
branches;
next	1.3;

1.3
date	99.02.11.16.48.17;	author pawel;	state Exp;
branches;
next	1.2;

1.2
date	98.12.23.21.10.33;	author pawel;	state Exp;
branches;
next	1.1;

1.1
date	98.12.23.19.46.36;	author pawel;	state Exp;
branches;
next	;


desc
@OP
@


1.30
log
@email_health_dept
@
text
@C ++********************************************************************
C                                                                      *
C  POLQS.F                                                             *
C                  OPFILEC                        FEB  03 ARDEAN LEITH *
C                  FILELIST                       FEB  06 ARDEAN LEITH *
C                  MAXNAM                         JUL  14 ARDEAN LEITH *
C                                                                      *
C **********************************************************************
C=*                                                                    *
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* SPIDER System Authors:  Joachim Frank & ArDean Leith               *
C=* Copyright 1985-2014  Health Research Inc.,                         *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* merchantability or fitness for a particular purpose.  See the GNU  *
C=* General Public License for more details.                           *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C                                                                      *
C  POLQS(MAXMEM)                                                       *
C                                                                      *
C  PURPOSE:                                                            *
C                                                                      *
C  PARAMETERS:                                                         *
C                                                                      *
C   02/22/07   USED FILELIST 
C
C   07/14/05   Corrected minor bug with 1D projection
C              OpenMP switched off - it does not work on Linux
C
C   07/29/99   PARALLEL, F90 VERSION; CORRECTED ON 02/13/02
C
C   02/11/99   TRIGONOMETRIC FUNCTIONS CHANGED TO F90.
C
C                                     08/28/97
C  DISTRIBUTION OF ANGLES IN ANGTAB CHANGED TO AGREE WITH CURRENT VO EA
C                                     10/3/96
C  COMPLETE VERSION FOR SPIDER
C  CALCULATES THE 1D PROJECTIONS OF 2D IMAGES (NOT NORMALIZED).
C                                                  11/19/90
C                                     05/16/95
C  SAME AS POLQT, BUT FOURIER VERSION ...
C  WEIGHTS ON CIRCLE AS IN POLQW
C  PROBLEM OF DUPLICATED LINES IN WEIGHTING SOLVED
C  WEIGHTS TAKEN OUT OF THE DO-LOOP
C  CORRECT LINE CALCULATION, EXCLUSION OF IDENTICAL DIRECTIONS ...
C
C **********************************************************************

	SUBROUTINE POLQS(MAXMEM)

	PARAMETER  (NILMAX=4000)
        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'
        INCLUDE 'F90ALLOC.INC'

	CHARACTER(LEN=MAXNAM) :: FINPAT,FINPIC,FINFO,FINDOC
	COMMON  /F_SPEC/         FINPAT,FINPIC,FINFO,FINDOC,NLET

	CHARACTER*1  MODIS
	COMMON  /POLS/ MODIS

	COMMON  BUF(1024)
	COMMON /PAR/  LDP,NM,LDPNM
	DIMENSION  TARRAY(2)

	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  PRJ
	REAL, ALLOCATABLE, DIMENSION(:,:)   ::  P
	REAL,  DIMENSION(:,:), POINTER      ::  IPQ

	DATA  INPIC/99/,INDOC/96/,NDOC/95/

C       N - LINEAR DIMENSION OF 2D IMAGE
C       NANG - NUMBER OF ANGLES
C       NIMA - NUMBER OF 2D IMAGES

	NMAX   = NIMAX
        CALL FILELIST(.TRUE.,NDOC,FINPAT,NLET,INUMBR,NMAX,NIMA,
     &                'INPUT FILE TEMPLATE (E.G. PIC****)',IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
C       GET FIRST PICTURE TO DETERMINE DIMS
        CALL FILGET(FINPAT,FINPIC,NLET,INUMBR(1),IRTFLG)
        IF (IRTFLG .NE. 0) RETURN

	MAXIM = 0
	CALL OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &              N,NROW,NSL,MAXIM,' ',.FALSE.,IRTFLG)
 	IF (IRTFLG.NE.0)  RETURN
	CLOSE(INPIC)

C       NANG - TOTAL NUMBER OF ANGLES
	CALL RDPRMI(LENPROJ,NANG,NOT_USED,'LENGTH OF LINE PROJECTION')
	CALL RDPRM2(F1,F2,NOT_USED,'MINIMUM, MAXIMUM FREQUENCY')

	IF (F1.LT.0.0 .OR. F2.GT.0.5 .OR. F1.GT.F2)  THEN
	   CALL ERRT(14,'OP',IER)
	   RETURN
	ENDIF
	IF (F1.EQ.0.0 .AND. F2.EQ.0.0)  THEN
	   F1=0.0
	   F2=0.5
	ENDIF
	CALL  RDPRMI(IDPSI,NANG,NOT_USED, 'ACCURACY OF THETA')

C  PAP  07/14/05
C  I cannot fix the code for arbitrary NANG (number of psi angles).
C  The reason is that in too many places the code depends on the assumption that NANG=180.
C  The main problem is in SPIN, where the spin step is IDPSI, which again can be any...
C  Since all angles are coded by their integer numbers (i.e., l1=3 means angle 3*180/NANG)
C   the corrections are virtually impossible without major rewriting of the code.
C	IF (NANG.EQ.0)  THEN
C          DEFAULT 1 DEGREE ACCURACY FOR PSI
	   NANG=180
C	ELSE
C	   IDUM=180/NANG
C	   IF(IDUM*NANG.NE.180)  THEN
C	   	WRITE(NOUT,*)  '  180 has to be divisible by NANG'
C	   	CALL  ERRT(14,'OP',NE)
C		GOTO 991
C	   ENDIF
C	   NANG=IDUM
C	ENDIF

C       DEFAULT 5 DEGREES ACCURACY FOR THETA
	IF (IDPSI.EQ.0)  IDPSI=5 

	CALL RDPRMI(MAXIT,IDUM,NOT_USED, 'MAXIMUM NUMBER OF CYCLES')

	DPSI=IDPSI
	CALL  GENAT(BUF,DPSI,NANGT,.FALSE.)

	MODIS = 'E'

        RI      = LENPROJ/2
	LENPROJ = LENPROJ/2
	LENPROJ = LENPROJ*2+1
	IF (LENPROJ .GT. N-2) THEN
	   LENRPOJ = N-2
	   IF (MOD(N,2) .EQ. 0)  LENRPOJ = LENRPOJ-1
	   WRITE(NOUT,*)  
     &	      'LENGTH OF PROJECTION TOO LARGE!  LIMITED TO ',LENRPOJ
	ENDIF

C       ALWAYS SKIP (0) TERM, LENB has to be odd to fall on the real part
	LENB=MAX(NINT(2*F1*LENPROJ+1),3)
	LENB=LENB+MOD(LENB+1,2)
	LENE=MIN(NINT(2*F2*LENPROJ),LENPROJ-1)
	LENF=LENE-LENB+1

        LDP=N/2+1
        LDPNM=LENPROJ/2+1

	ALLOCATE(PRJ(LENF,2*NANG,NIMA),STAT=IRTFLG)
	IF (IRTFLG.NE.0) THEN
            CALL ERRT(46,'OP, PRJ',IER)
            RETURN
        ENDIF

	TM1 = ETIME(TARRAY)
 	CALL RDL_P(N,NANG,LENPROJ,RI,INUMBR,NIMA,PRJ,LENB,LENF)

	TM2 = ETIME(TARRAY)
	WRITE(NOUT,*) ' TIME FOR READING PROJECTIONS = ',TM2-TM1

	MAXKEY = NIMA
	MAXREG = 4
	CALL GETDOCDAT('DOCUMENT WITH INITIAL ANGLES',.TRUE.,FINDOC,
     &		INDOC,.FALSE.,MAXREG,MAXKEY,IPQ,IRTFLG)
	IF (IRTFLG.NE.0) RETURN

	ALLOCATE(P(MAXREG-1,NIMA),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL ERRT(46,'OP, P',IER)

	DO I=1,MAXKEY
	   DO J=1,3
              P(J,I) = IPQ(J+1,I)
	   ENDDO
	ENDDO
C       IPQ NO LONGER NEEDED
	DEALLOCATE(IPQ)

	TM3 = ETIME(TARRAY)
	CALL FCANG(NANG,NIMA,LENF,MAXIT,P,PRJ,NANGT,IDPSI)

	TM4 = ETIME(TARRAY)

	WRITE(NOUT,*) ' TIME FOR ANGLE SEARCH = ',TM4-TM3

991	IF(ALLOCATED(P))    DEALLOCATE(P)
	IF(ALLOCATED(PRJ))  DEALLOCATE(PRJ)
	END


	SUBROUTINE FCANG(NANG,NIMA,LENPROJ,MAXIT,
     &		         P,PRJ,NANGT,IDPSI)

        INCLUDE 'CMBLOCK.INC' 

	PARAMETER  (NDLI=4)
	DIMENSION  DLIST(NDLI)
	DIMENSION  P(3,NIMA)
	DIMENSION  PRJ(LENPROJ,2*NANG,NIMA)
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  ANGTAB
	CHARACTER*8 CTIME
	DOUBLE PRECISION  DIS(NIMA)
	DOUBLE PRECISION  DIST

	DATA  NDOC/77/

C       NEW TABLES.
C       ANGTAB(1  - THETA
C       ANGTAB(2  - PHI
	LOGICAL CHANGE,CHANGEPOS
C       SET FIRST THREE ANGLES TO ZERO FOREVER ...
C	P(1,1)=0.0
C	P(2,1)=0.0
C	P(3,1)=0.0

	ALLOCATE(ANGTAB(2,NANGT),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'OP, ANGTAB',IER)

	DPSI=IDPSI
	CALL GENAT(ANGTAB,DPSI,NANGT,.TRUE.)

	FVALUE=DIST(NIMA,NANG,LENPROJ,PRJ,P)
	WRITE(NOUT,2177)  FVALUE
2177	FORMAT(' INITIAL DISCREPANCY ',1PE10.3)
	WRITE(NOUT,2178)
2178	FORMAT(' INITIAL ANGLES',5X,'PSI',7X,'THETA',5X,'PHI')

C       TRY TO SPIN
	ITER=0
507	CHANGE=.TRUE.
	CHANGEPOS=.FALSE.
	ITER=ITER+1
	DO  I=1,NIMA
	   WRITE(NOUT,2179)  I,(P(J,I),J=1,3)
	ENDDO

2179	FORMAT(I15,3(3X,F7.2))
	CALL  MYTIME(CTIME)

	WRITE(NOUT,777)  CTIME
777	FORMAT(' ENTERED SPIN : ',A8)

	DO  ISPIN=1,NIMA

C	   CALL  SPINSPIN
C     &	      (NIMA,NANG,LENPROJ,PRJ,P,
C     &		ISPIN,IDPSI,ANGTAB,NANGT,IPSIM,IANGMIN,CHANGE,
C     &		L1,L2,LT,LT1,LT2,LORD,W)

	    CALL  SPIN(NIMA,NANG,LENPROJ,PRJ,P,
     &		ISPIN,IDPSI,ANGTAB,NANGT,IPSIM,IANGMIN,CHANGE)
	    IF (CHANGE)  THEN
	       CHANGEPOS=.TRUE.
	       P(1,ISPIN)=IPSIM
	       P(2,ISPIN)=ANGTAB(1,IANGMIN)
	       P(3,ISPIN)=ANGTAB(2,IANGMIN)
	   ENDIF
	ENDDO
	IF (CHANGEPOS)  THEN
	   FVALUE=DIST(NIMA,NANG,LENPROJ,PRJ,P)
	   WRITE(NOUT,2181)  ITER,FVALUE
2181	   FORMAT(' CYCLE',I9,'  NEW VALUE=',1PE10.3)
	   DLIST(1)=-1
	   DLIST(2)=ITER
	   DLIST(3)=FVALUE
	   CALL SAVD(NDOC,DLIST,3,IRTFLG)
	   DO I=1,NIMA
	      DLIST(1)=I
	      DO J=1,3
	        DLIST(J+1)=P(J,I)
	      ENDDO
	      CALL SAVD(NDOC,DLIST,NDLI,IRTFLG)
	   ENDDO
	ENDIF
	IF (CHANGEPOS.AND.(MAXIT.EQ.0.OR.ITER.LT.MAXIT))  GOTO  507
        CLOSE(NDOC)
	CALL  SAVDC
	DEALLOCATE(ANGTAB)
	END



	SUBROUTINE SPIN(NIMA,NANG,LENPROJ,PRJ,P,
     &		ISPIN,IDPSI,ANGTAB,NANGT,MMIN,LMIN,CHANGE)

	DIMENSION  P(3,NIMA),PRJ(LENPROJ,2*NANG,NIMA)
	DIMENSION  ANGTAB(2,NANGT)
	DOUBLE PRECISION DMI(NANGT),DMIN
	DIMENSION  LMI(NANGT),MMI(NANGT)
C,EDL1
	LOGICAL CHANGE
C       LENGTH OF ARRAYS NEEDED IN DWTG
	LNM2=NIMA*(NIMA-1)/2

C       SPIN
Cc$omp parallel do private(l)
	DO  L=1,NANGT
	   CALL  DWTG(P,ANGTAB(1,L),PRJ,ISPIN,NIMA,NANG,LENPROJ,
     &		    L,IDPSI,DMI(L),LMI(L),MMI(L),LNM2)
	ENDDO

	DMIN=1.0D23
	LMIN=-1
	MMIN=-1
	DO  2 L=1,NANGT
	   DO I=1,NIMA
	     IF(I.NE.ISPIN.AND.
     &	       P(2,I).EQ.ANGTAB(1,L).AND.P(3,I).EQ.ANGTAB(2,L)) GOTO 2
	   ENDDO
	   IF (DMI(L).LT.DMIN)  THEN
	      DMIN=DMI(L)
	      LMIN=LMI(L)
	      MMIN=MMI(L)
	   ENDIF
2	CONTINUE

C       CHECK WHETHER POSITION CHANGED
C	PRINT  *,NANGT,DMIN,LMIN,MMIN
C	PRINT  *,FLOAT(MMIN),ANGTAB(1,LMIN),ANGTAB(2,LMIN)
	IF (P(1,ISPIN).EQ.FLOAT(MMIN))  THEN
	   IF (P(2,ISPIN).EQ.ANGTAB(1,LMIN))  THEN
	      IF (P(3,ISPIN).EQ.ANGTAB(2,LMIN))  THEN
	         CHANGE = .FALSE.
	         RETURN
	      ENDIF
	   ENDIF
	ENDIF
	CHANGE = .TRUE.
	END



	SUBROUTINE  DWTG(PP,ANGTAB,PRJ,ISPIN,NIMA,NANG,LENPROJ,
     &		         L,IDPSI,DMIN,LMIN,MMIN,LNM2)

	DIMENSION  PP(3,NIMA),ANGTAB(2),PRJ(LENPROJ,2*NANG,NIMA)

C       AUTOMATIC ARRAYS
	DIMENSION  L1(LNM2),L2(LNM2),LT(LNM2)
	DIMENSION  W(LNM2),LT1(LNM2),LT2(LNM2),LORD(LNM2)
	DIMENSION  P(3,NIMA)
	DOUBLE PRECISION DMIN,DID,DIST

	DMIN=1.0D23
	LMIN=-1
	MMIN=-1
	DO I=1,NIMA
	   IF(I.NE.ISPIN.AND.
     &	    PP(2,I).EQ.ANGTAB(1).AND.PP(3,I).EQ.ANGTAB(2)) RETURN
	ENDDO

	P=PP

	NIM=NIMA-1

	P(2,ISPIN)=ANGTAB(1)
	P(3,ISPIN)=ANGTAB(2)
	P(1,ISPIN)=0.0	

	K=0
	DO I=1,NIMA-1
	   DO J=I+1,NIMA
	      IF(I.EQ.ISPIN.OR.J.EQ.ISPIN) THEN
	        K=K+1
	        LORD(K)=K
	        CALL  CALDILW1(P(1,I),P(1,J),NANG,L1(K),L2(K))
	       ENDIF
	   ENDDO
	ENDDO

	K=0
	DO I=1,NIMA-1
	   DO J=I+1,NIMA
	       IF(I.EQ.ISPIN) THEN
	          K=K+1
	          LT(K)=L1(K)
	          IF(LT(K).GT.NANG)  LT(K)=LT(K)-NANG
	       ELSEIF(J.EQ.ISPIN)  THEN
	          K=K+1
	          LT(K)=L2(K)
	          IF(LT(K).GT.NANG)  LT(K)=LT(K)-NANG
	       ENDIF
	   ENDDO
	ENDDO

C       FROM SMALL TO LARGE
	CALL SORT2(LT,LORD,NIM)

	QT=1.0
	DO K=2,NIM-1
	   IF (LT(K).NE.LT(K-1))  THEN
	      W(LORD(K))=FLOAT(LT(K+1)-LT(K-1))/2
	      QT=1.0
	   ELSE
	      QT=QT+1.0
	      W(LORD(K))=-QT
	   ENDIF
	ENDDO

	IF (LT(NIM).NE.LT(NIM-1))  THEN
            W(LORD(NIM))=FLOAT(LT(1)+NANG-LT(NIM-1))/2
	ELSE
            QT=QT+1
	    W(LORD(NIM))=-QT
	ENDIF
	W(LORD(1))=FLOAT(LT(2)-LT(NIM)+NANG)/2

	K=1
105	K=K+1
	IF (W(LORD(K)).LT.0.0)  THEN
	   KB=K-1
	   K=KB
106	   K=K+1
	   IF(W(LORD(K)).LT.0.0)  THEN
              IF(K.NE.NIM) GOTO 106
	   ELSE
	      K=K-1
	   ENDIF
	   W(LORD(KB))=-W(LORD(KB))/W(LORD(K))
	   DO   KK=KB+1,K
	      W(LORD(KK))=W(LORD(KB))
	   ENDDO
	ENDIF
	IF(K.LT.NIM) GOTO  105

	WT=0.0
	DO K=1,NIM
	    WT=WT+W(K)
	ENDDO
	DO K=1,NIM
	   W(K)=W(K)/WT
	ENDDO

	DO  M=0,359,IDPSI
	   P(1,ISPIN) = M	

C          GET LINES ROTATED BY PSI ANGLE
           K=0
           DO I=1,NIMA-1
              DO J=I+1,NIMA
                 IF (I.EQ.ISPIN.OR.J.EQ.ISPIN) THEN
                    K=K+1
                    IF (L1(K).EQ.NANG/2+1.OR.L1(K).EQ.271 .OR. 
     &                 L2(K).EQ.91.OR.L2(K).EQ.271)  THEN
                       CALL CALDILW1(P(1,I),P(1,J),NANG,LT1(K),LT2(K))
                    ELSE
                       IF(I.EQ.ISPIN)  THEN
                          LT1(K)=MOD(L1(K)-M+2*NANG-1,2*NANG)+1
                          LT2(K)=L2(K)
                       ELSE
                          LT1(K)=L1(K)
                          LT2(K)=MOD(L2(K)-M+2*NANG-1,2*NANG)+1
                       ENDIF
                    ENDIF
                 ENDIF
              ENDDO
	   ENDDO
 
C          DO THE DISTANCE WITH WEIGHTING
	   DIST=0.0D0
	   K=0
	   DO I=1,NIMA-1
	      DO J=I+1,NIMA
	        IF (I.EQ.ISPIN.OR.J.EQ.ISPIN) THEN
	           K=K+1
	   	   if (w(k).le.0.0)  then
		      print *,' incorrect weight',k,w(k)
		      stop
		   endif
	           DIST = DIST+EDL1(PRJ(1,LT1(K),I),
     &                   PRJ(1,LT2(K),J),LENPROJ)*W(K)
               ENDIF
            ENDDO
         ENDDO

	IF (DIST.LT.DMIN)  THEN
            DMIN=DIST
            LMIN=L
            MMIN=M
            ENDIF
         ENDDO
C       END OF DO-LOOP OVER M (PSI ANGLE)
	END
	

	SUBROUTINE  SPINSPIN(NIMA,NANG,LENPROJ,PRJ,P,
     &		ISPIN,IDPSI,ANGTAB,NANGT,MMIN,LMIN,CHANGE,
     &		L1,L2,LT,LT1,LT2,LORD,W)

	DIMENSION  P(3,NIMA),PRJ(LENPROJ,2*NANG,NIMA),PTMP(3)
	DIMENSION  ANGTAB(2,NANGT)
	DOUBLE PRECISION DMIN,DID,DIST
C,EDL1
	LOGICAL CHANGE

	DIMENSION  L1(*),L2(*),LT(*),LT1(*),LT2(*),LORD(*)
	DIMENSION  W(*)
	NIM=NIMA-1
C       SPIN
	DMIN=1.0E23
	LMIN=-1
	MMIN=-1
	DO  1  L=1,NANGT
	DO  I=1,NIMA
	IF(I.NE.ISPIN.AND.
     &	P(2,I).EQ.ANGTAB(1,L).AND.P(3,I).EQ.ANGTAB(2,L)) GOTO 1
	ENDDO
	PTMP(2)=P(2,ISPIN)	
	PTMP(3)=P(3,ISPIN)
	PTMP(1)=P(1,ISPIN)	
	P(2,ISPIN)=ANGTAB(1,L)
	P(3,ISPIN)=ANGTAB(2,L)
	P(1,ISPIN)=0.0	

	K=0
	DO  14  I=1,NIMA-1
	DO  14  J=I+1,NIMA
	IF (I.EQ.ISPIN.OR.J.EQ.ISPIN) THEN
	   K=K+1
	   LORD(K)=K
	   CALL  CALDILW1(P(1,I),P(1,J),NANG,L1(K),L2(K))
	ENDIF
14	CONTINUE

	K=0
	DO  101  I=1,NIMA-1
	DO  101  J=I+1,NIMA
	IF (I.EQ.ISPIN) THEN
	   K=K+1
	   LT(K)=L1(K)
	   IF (LT(K).GT.NANG)  LT(K)=LT(K)-NANG
	ELSEI F(J.EQ.ISPIN)  THEN
	   K=K+1
	   LT(K)=L2(K)
	   IF(LT(K).GT.NANG)  LT(K)=LT(K)-NANG
	ENDIF
101	CONTINUE

C       FROM SMALL TO LARGE
	CALL  SORT2(LT,LORD,NIM)

	QT=1.0
	DO  102  K=2,NIM-1
	IF(LT(K).NE.LT(K-1))  THEN
	W(LORD(K))=FLOAT(LT(K+1)-LT(K-1))/2
	QT=1.0
	ELSE
	QT=QT+1.0
	W(LORD(K))=-QT
	ENDIF
102	CONTINUE
	IF(LT(NIM).NE.LT(NIM-1))  THEN
	W(LORD(NIM))=FLOAT(LT(1)+NANG-LT(NIM-1))/2
	ELSE
	QT=QT+1
	W(LORD(NIM))=-QT
	ENDIF
	W(LORD(1))=FLOAT(LT(2)-LT(NIM)+NANG)/2
C
	K=1
105	K=K+1
	IF (W(LORD(K)).LT.0.0)  THEN
	   KB=K-1
	   K=KB
106	   K=K+1
	   IF (W(LORD(K)).LT.0.0)  THEN
              IF(K.NE.NIM) GOTO 106
	   ELSE
	      K=K-1
	   ENDIF
	   W(LORD(KB))=-W(LORD(KB))/W(LORD(K))
	   DO  107  KK=KB+1,K
107	   W(LORD(KK))=W(LORD(KB))
	ENDIF
	IF (K.LT.NIM) GOTO  105
	
	WT=0.0
	DO K=1,NIM
	   WT=WT+W(K)
	ENDDO
	DO K=1,NIM
	   W(K)=W(K)/WT
	ENDDO

	DO  2  M=0,359,IDPSI
	P(1,ISPIN)=M	

C  GET LINES ROTATED BY PSI ANGLE
	K=0
	DO   I=1,NIMA-1
	 DO   J=I+1,NIMA
	  IF(I.EQ.ISPIN.OR.J.EQ.ISPIN) THEN
	   K=K+1
	IF(L1(K).EQ.91.OR.L1(K).EQ.271.OR.L2(K).EQ.91.OR.L2(K).EQ.271)
     &      THEN
	    CALL  CALDILW1(P(1,I),P(1,J),NANG,LT1(K),LT2(K))
	ELSE
	    IF(I.EQ.ISPIN)  THEN
	     LT1(K)=MOD(L1(K)-M+2*NANG-1,2*NANG)+1
	     LT2(K)=L2(K)
	    ELSE
	     LT1(K)=L1(K)
	     LT2(K)=MOD(L2(K)-M+2*NANG-1,2*NANG)+1
	    ENDIF
	ENDIF
	   ENDIF
	 ENDDO
	ENDDO
 
C       DO THE DISTANCE WITH WEIGHTING
	DIST=0.0D0
	K=0
	DO   I=1,NIMA-1
	 DO   J=I+1,NIMA
	  IF(I.EQ.ISPIN.OR.J.EQ.ISPIN) THEN
	   K=K+1
	   DID=EDL1(PRJ(1,LT1(K),I),PRJ(1,LT2(K),J),LENPROJ)
	   DIST=DIST+DID*W(K)
	  ENDIF
	 ENDDO
	ENDDO
C
	IF(DIST.LT.DMIN)  THEN
	 DMIN=DIST
	 LMIN=L
	 MMIN=M
	ENDIF
2	CONTINUE
	P(2,ISPIN)=PTMP(2)	
	P(3,ISPIN)=PTMP(3)
	P(1,ISPIN)=PTMP(1)
1	CONTINUE
C       CHECK WHETHER POSITION CHANGED
C	PRINT  *,NANGT,DMIN,LMIN,MMIN
C	PRINT  *,FLOAT(MMIN),ANGTAB(1,LMIN),ANGTAB(2,LMIN)
	IF(P(1,ISPIN).EQ.FLOAT(MMIN))  THEN
	 IF(P(2,ISPIN).EQ.ANGTAB(1,LMIN))  THEN
	  IF(P(3,ISPIN).EQ.ANGTAB(2,LMIN))  THEN
	   CHANGE=.FALSE.
	   RETURN
	  ENDIF
	 ENDIF
	ENDIF
	CHANGE=.TRUE.
	END

	
	DOUBLE PRECISION FUNCTION  DIST
     &	   (NIMA,NANG,LENPROJ,PRJ,P)
	DIMENSION  P(3,NIMA),PRJ(LENPROJ,2*NANG,NIMA)
	DOUBLE PRECISION  DIN,DIN1,DIN2,DID

	DIN=0.0D0
C#ifdef SP_MP
C	NTR=NIMA*(NIMA-1)/2
Cc$omp parallel do private(k,i,j,did)
Cc$omp+reduction(+:din)
C	DO  K=1,NTR
C	   CALL DECO(K,NIMA,I,J)
C	   CALL  CALDIL
C     &	     (PRJ(1,1,I),P(1,I),PRJ(1,1,J),P(1,J),LENPROJ,NANG,DID)
C	   DIN=DIN+DID
C#else
	DO  I=1,NIMA-1
	 DO  J=I+1,NIMA
	  CALL  CALDIL
     &	  (PRJ(1,1,I),P(1,I),PRJ(1,1,J),P(1,J),LENPROJ,NANG,DID)
	  DIN=DIN+DID
	 ENDDO
C#endif
	ENDDO
	DIST=DIN
	END


	SUBROUTINE  DECO(M,N,I,J)
CCCCCCCCCCCCCCCCCCCCCCCCCCC  I<J
	k=0
	DO  IN=1,N-1
	 DO  JN=IN+1,N
	  k=k+1
		IF(k.eq.m)  THEN
		 I=IN
		 J=JN
		 return
		ENDIF
	 ENDDO
	 ENDDO
	END

	SUBROUTINE  CALDIL(PRJ1,FI1,PRJ2,FI2,LENPROJ,NANG,DID)

C  CALCULATES DISTANCE DID USING COMMON LINE
C  WARNING - THE RESULT IS NOT THE SAME AFTER CHANGING THE ORDER
C            OF ARGUMENTS:  FI1<->FI2 !!
C            SUCH CHANGE MEANS THAT ANGLES FOUND SHOULD BE REVERSED TOO:
C                        ALPHA1<->ALPHA2

	DIMENSION  PRJ1(LENPROJ,2*NANG),FI1(3),
     &             PRJ2(LENPROJ,2*NANG),FI2(3)
C	DOUBLE PRECISION  EDL1,EDL2,EDL3,DID,R1(3,3),R2(3,3),R3(3,3)
	DOUBLE PRECISION  EDL2,EDL3,DID,R1(3,3),R2(3,3),R3(3,3)
	DOUBLE PRECISION  ECL1,ECL2,ECL3
	DOUBLE PRECISION  PSI,THETA,PHI,DEPS
	CHARACTER*1  MODIS
	COMMON  /POLS/ MODIS
	DOUBLE PRECISION  QUADPI,RAD_TO_DGR
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (RAD_TO_DGR = (180.0/QUADPI))
	PARAMETER (DEPS = 1.0D-7)

	CALL  BLDR(R1,-FI1(3),-FI1(2),-FI1(1))
	CALL  BLDR(R2,FI2(1),FI2(2),FI2(3))
	DO  1  I=1,3
	   DO  1  J=1,3
	      R3(I,J)=0.0
	      DO  1  K=1,3
1	R3(I,J)=R3(I,J)+R2(I,K)*R1(K,J)

C<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
C  LIMIT PRECISION
         DO  5  J=1,3
            DO  5  I=1,3
               IF(DABS(R3(I,J)).LT.DEPS)  R3(I,J)=0.0D0
               IF(R3(I,J)-1.0D0.GT.-DEPS)  R3(I,J)=1.0D0
               IF(R3(I,J)+1.0D0.LT.DEPS)  R3(I,J)=-1.0D0
5        CONTINUE

         IF (R3(3,3).EQ.1.0)  THEN
            THETA=0.0
            PSI=0.0
            IF (R3(1,1).EQ.0.0)  THEN
               PHI=RAD_TO_DGR*DASIN(R3(1,2))
            ELSE
               PHI=RAD_TO_DGR*DATAN2(R3(1,2),R3(1,1))
            ENDIF

         ELSEIF(R3(3,3).EQ.-1.0)  THEN
            THETA=180.0
            PSI=0.0
            IF (R3(1,1).EQ.0.0)  THEN
               PHI=RAD_TO_DGR*DASIN(-R3(1,2))
            ELSE
               PHI=RAD_TO_DGR*DATAN2(-R3(1,2),-R3(1,1))
            ENDIF
         ELSE
            THETA=RAD_TO_DGR*DACOS(R3(3,3))
            ST=DSIGN(1.0D0,THETA)
            IF (R3(3,1).EQ.0.0)  THEN
               IF(ST.NE.DSIGN(1.0D0,R3(3,2)))  THEN
                  PHI=270.0
               ELSE
                  PHI=90.0
               ENDIF
            ELSE
               PHI=RAD_TO_DGR*DATAN2(R3(3,2)*ST,R3(3,1)*ST)
            ENDIF
            IF (R3(1,3).EQ.0.0)  THEN
               IF(ST.NE.DSIGN(1.0D0,R3(2,3)))  THEN
                  PSI=270.0
               ELSE
                  PSI=90.0
               ENDIF
            ELSE
               PSI=RAD_TO_DGR*DATAN2(R3(2,3)*ST,-R3(1,3)*ST)
            ENDIF
         ENDIF
         IF (PSI.LT.0.0)  PSI=PSI+360.0
         IF (THETA.LT.0.0)  THETA=THETA+360.0
         IF (PHI.LT.0.0)  PHI=PHI+360.0
C<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
C	IF(DABS(R3(3,1)).LT.DEPS .AND. DABS(R3(3,2)).LT.DEPS)  THEN
C	PRINT *,'  ALPHA 1  CANNOT BE CALCULATED'
C	DID=2.0
C	RETURN
C	ENDIF
C	IF(DABS(R3(1,3)).LT.DEPS .AND. DABS(R3(2,3)).LT.DEPS)  THEN
C	PRINT *,'  ALPHA 2  CANNOT BE CALCULATED'
C	DID=2.0
C	RETURN
C	ENDIF

	ALPHA1=90.0+PHI
	ALPHA2=90.0-PSI

	IF (ALPHA1.GE.0.0)  THEN
	   L1=MOD(INT(NANG*ALPHA1/180.0),2*NANG)+1
	ELSE
	   L1=MOD(INT(NANG*(360.0+ALPHA1)/180.0),2*NANG)+1
	ENDIF
	IF (ALPHA2.GE.0.0)  THEN
	   L2=MOD(INT(NANG*ALPHA2/180.0),2*NANG)+1
	ELSE
	   L2=MOD(INT(NANG*(360.0+ALPHA2)/180.0),2*NANG)+1
	ENDIF

	IF (MODIS.EQ.'E')  THEN
	   DID = EDL1(PRJ1(1,L1),PRJ2(1,L2),LENPROJ)

	ELSEIF (MODIS.EQ.'C')  THEN

	   IF (L1.GT.NANG)  THEN
              L1=L1-NANG
              IF(L2.GT.NANG)  THEN
		   L2=L2-NANG
		   DID=ECL1(PRJ1(1,L1),PRJ2(1,L2),LENPROJ)
              ELSE
		   DID=ECL2(PRJ1(1,L1),PRJ2(1,L2),LENPROJ)
              ENDIF
	   ELSE
              IF (L2.GT.NANG)  THEN
		   L2=L2-NANG
		   DID=ECL3(PRJ1(1,L1),PRJ2(1,L2),LENPROJ)
              ELSE
		   DID=ECL1(PRJ1(1,L1),PRJ2(1,L2),LENPROJ)
              ENDIF
           ENDIF
	ELSE
	   STOP
	ENDIF

C	PRINT  *,ALPHA1,L1,ALPHA2,L2,DID
	END


	SUBROUTINE  CALDILW1(FI1,FI2,NANG,L1,L2)

C       CALCULATES DISTANCE DID USING COMMON LINE
C       WARNING - THE RESULT IS NOT THE SAME AFTER CHANGING THE ORDER
C            OF ARGUMENTS:  FI1<->FI2 !!
C            SUCH CHANGE MEANS THAT ANGLES FOUND SHOULD BE REVERSED TOO:
C                        ALPHA1<->ALPHA2

	DIMENSION         FI1(3),FI2(3)
	DOUBLE PRECISION  R1(3,3),R2(3,3),R3(3,3)
	DOUBLE PRECISION  PSI,THETA,PHI,DEPS
	CHARACTER*1       MODIS
	COMMON  /POLS/ MODIS

	DOUBLE PRECISION  QUADPI,RAD_TO_DGR
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
	PARAMETER (RAD_TO_DGR = (180.0/QUADPI))
	PARAMETER (DEPS = 1.0D-7)

	CALL  BLDR(R1,-FI1(3),-FI1(2),-FI1(1))
	CALL  BLDR(R2,FI2(1),FI2(2),FI2(3))
	DO  1  I=1,3
	DO  1  J=1,3
	R3(I,J)=0.0
	DO  1  K=1,3
1	R3(I,J)=R3(I,J)+R2(I,K)*R1(K,J)

C<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
C        LIMIT PRECISION
         DO  5  J=1,3
         DO  5  I=1,3
         IF(DABS(R3(I,J)).LT.DEPS)  R3(I,J)=0.0D0
         IF(R3(I,J)-1.0D0.GT.-DEPS)  R3(I,J)=1.0D0
         IF(R3(I,J)+1.0D0.LT.DEPS)  R3(I,J)=-1.0D0
5        CONTINUE

         IF(R3(3,3).EQ.1.0)  THEN
         THETA=0.0
         PSI=0.0
         IF(R3(1,1).EQ.0.0)  THEN
         PHI=RAD_TO_DGR*DASIN(R3(1,2))
         ELSE
         PHI=RAD_TO_DGR*DATAN2(R3(1,2),R3(1,1))
         ENDIF
         ELSEIF(R3(3,3).EQ.-1.0)  THEN
         THETA=180.0
         PSI=0.0
         IF(R3(1,1).EQ.0.0)  THEN
         PHI=RAD_TO_DGR*DASIN(-R3(1,2))
         ELSE
         PHI=RAD_TO_DGR*DATAN2(-R3(1,2),-R3(1,1))
         ENDIF
         ELSE
         THETA=RAD_TO_DGR*DACOS(R3(3,3))
         ST=DSIGN(1.0D0,THETA)
         IF(R3(3,1).EQ.0.0)  THEN
         IF(ST.NE.DSIGN(1.0D0,R3(3,2)))  THEN
         PHI=270.0
         ELSE
         PHI=90.0
         ENDIF
         ELSE
            PHI=RAD_TO_DGR*DATAN2(R3(3,2)*ST,R3(3,1)*ST)
         ENDIF
         IF(R3(1,3).EQ.0.0)  THEN
         IF(ST.NE.DSIGN(1.0D0,R3(2,3)))  THEN
            PSI=270.0
         ELSE
            PSI=90.0
         ENDIF
         ELSE
            PSI=RAD_TO_DGR*DATAN2(R3(2,3)*ST,-R3(1,3)*ST)
         ENDIF
         ENDIF
         IF (PSI.LT.0.0)  PSI=PSI+360.0
         IF (THETA.LT.0.0)  THETA=THETA+360.0
         IF (PHI.LT.0.0)  PHI=PHI+360.0
C<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
C	IF(DABS(R3(3,1)).LT.DEPS .AND. DABS(R3(3,2)).LT.DEPS)  THEN
C	PRINT *,'  ALPHA 1  CANNOT BE CALCULATED'
C	DID=2.0
C	RETURN
C	ENDIF
C	IF(DABS(R3(1,3)).LT.DEPS .AND. DABS(R3(2,3)).LT.DEPS)  THEN
C	PRINT *,'  ALPHA 2  CANNOT BE CALCULATED'
C	DID=2.0
C	RETURN
C	ENDIF

	ALPHA1=90.0+PHI
	ALPHA2=90.0-PSI

	IF(ALPHA1.GE.0.0)  THEN
	L1=MOD(INT(NANG*ALPHA1/180.0),2*NANG)+1
	ELSE
	L1=MOD(INT(NANG*(360.0+ALPHA1)/180.0),2*NANG)+1
	ENDIF
	IF(ALPHA2.GE.0.0)  THEN
	L2=MOD(INT(NANG*ALPHA2/180.0),2*NANG)+1
	ELSE
	L2=MOD(INT(NANG*(360.0+ALPHA2)/180.0),2*NANG)+1
	ENDIF

	END



	FUNCTION  EDL1(X1,X2,N)
	DIMENSION  X1(N),X2(N)
	TDL1=0.0
	DO  1  I=1,N
1       TDL1=TDL1+(X1(I)-X2(I))*(X1(I)-X2(I))
	EDL1=TDL1
	END


	DOUBLE  PRECISION  FUNCTION  EDL1_(X1,X2,N)
	DIMENSION  X1(N),X2(N)
	DOUBLE PRECISION  TDL1
	TDL1=0.0
	DO  1  I=1,N
1	TDL1=TDL1+(X1(I)-X2(I))*DBLE(X1(I)-X2(I))
	EDL1_=TDL1
	END
C
	DOUBLE  PRECISION  FUNCTION  EDL2(X1,X2,N)
	DIMENSION  X1(N),X2(N)
	DOUBLE PRECISION  TDL2
	TDL2=0.0
	DO  1  I=1,N,2
	TDL2=TDL2+(X1(I)-X2(I))*DBLE(X1(I)-X2(I))
1	TDL2=TDL2+(X1(I+1)-X2(I+1))*DBLE(X1(I+1)+X2(I+1))
	EDL2=TDL2
	END
C
	DOUBLE  PRECISION  FUNCTION  EDL3(X1,X2,N)
	DIMENSION  X1(N),X2(N)
	DOUBLE PRECISION  TDL3
	TDL3=0.0
	DO  1  I=1,N,2
	TDL3=TDL3+(X1(I)-X2(I))*DBLE(X1(I)-X2(I))
1	TDL3=TDL3+(X1(I+1)-X2(I+1))*DBLE(X1(I+1)+X2(I+1))
	EDL3=TDL3
	END
C
	DOUBLE  PRECISION  FUNCTION  ECL1(X1,X2,N)
	DIMENSION  X1(N),X2(N)
	DOUBLE PRECISION  TCL1
	TCL1=1.0D0
	DO  1  I=1,N
1	TCL1=TCL1-X1(I)*X2(I)
	ECL1=TCL1
	END
C
	DOUBLE  PRECISION  FUNCTION  ECL2(X1,X2,N)
	DIMENSION  X1(N),X2(N)
	DOUBLE PRECISION  TCL2
	TCL2=1.0D0
	DO  1  I=1,N
1	TCL2=TCL2-X1(N-I+1)*X2(I)
	ECL2=TCL2
	END
C
	DOUBLE  PRECISION  FUNCTION  ECL3(X1,X2,N)
	DIMENSION  X1(N),X2(N)
	DOUBLE PRECISION  TEMP
	TEMP=1.0D0
	DO  1  I=1,N
1	TEMP=TEMP-X1(I)*X2(N-I+1)
	ECL3=TEMP
	END
C
	SUBROUTINE  NRL(X,M)
	DIMENSION   X(M)
	DOUBLE PRECISION  A,S
	A=0.0
	S=0.0
	A=SUM(X)
	S=DOT_PRODUCT(X,X)
	A=A/M
	S=DSQRT(S-M*A*A)
	X=(X-A)/S
	END
 


      SUBROUTINE SORT2(RA,RB,N)

      INTEGER RA(N),RB(N),RRA,RRB

      L=N/2+1
      IR=N
10    CONTINUE
        IF (L.GT.1)THEN
          L=L-1
          RRA=RA(L)
          RRB=RB(L)
        ELSE
          RRA=RA(IR)
          RRB=RB(IR)
          RA(IR)=RA(1)
          RB(IR)=RB(1)
          IR=IR-1
          IF(IR.EQ.1)THEN
            RA(1)=RRA
            RB(1)=RRB
            RETURN
          ENDIF
        ENDIF
        I=L
        J=L+L
20      IF(J.LE.IR)THEN
          IF(J.LT.IR)THEN
            IF(RA(J).LT.RA(J+1))J=J+1
          ENDIF
          IF(RRA.LT.RA(J))THEN
            RA(I)=RA(J)
            RB(I)=RB(J)
            I=J
            J=J+J
          ELSE
            J=IR+1
          ENDIF
        GO TO 20
        ENDIF
        RA(I)=RRA
        RB(I)=RRB
      GO TO 10
      END



	SUBROUTINE  PREPANG(DM,NANG)

	DIMENSION   DM(2,NANG)
	DOUBLE PRECISION  PHI

	PHI=4.0D0*DATAN(1.0D0)/NANG
	DO  I=1,NANG
	   DM(1,I)=DCOS(PHI*(I-1))
	   DM(2,I)=DSIN(PHI*(I-1))
	ENDDO

C       USE NEXT TWO LINES TO GET THE SAME SINOGRAM AS IN _RM 2D_

C	DM(1,I)=-DSIN(PHI*(I-1))
C1	DM(2,I)=DCOS(PHI*(I-1))
	END



	SUBROUTINE  RDL_P(N,NANG,LENPROJ,RI,INUMBRT,NIMA,PRJ,LENB,LENF)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

 	DIMENSION  PRJ(LENF,2*NANG,NIMA)

	DIMENSION  INUMBRT(NIMA)
C       AUTOMATIC ARRAYS, PROJECTION IS ASSUMED TO HAVE ODD LENGTH
	DIMENSION  B1(LENPROJ+1),B2(LENPROJ+15),BT(LENPROJ+1)

	REAL, ALLOCATABLE, DIMENSION(:,:)    :: X,PROJ,DM
	INTEGER, ALLOCATABLE, DIMENSION(:,:) :: IPCUBE
	LOGICAL      BREAK

	CHARACTER(LEN=MAXNAM) :: FINPAT,FINPIC,FINFO,FINDOC
	COMMON  /F_SPEC/         FINPAT,FINPIC,FINFO,FINDOC,NLET

	!COMMON  /F_SPEC/  FINPAT,FINPIC,FINFO,FINDOC,NLET
	!CHARACTER*80      FINPAT,FINPIC,FINFO,FINDOC

	COMMON  /PI/ PI

	DATA  INPIC/99/
	DATA  NDOUT/89/

	PI=4.0*DATAN(1.0D0)
C       CALCULATE DIMENSIONS FOR NORMAS
        NSB=-N/2
        NSE=-NSB-1+MOD(N,2)
        NRB=-N/2
        NRE=-NRB-1+MOD(N,2)
C       RADIUS FOR NORMAS
	IR1=0
	IR2=LENPROJ/2

	ALLOCATE(DM(2,NANG),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'OP, DM',IER)

	ALLOCATE(X(N,N),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'OP, X',IER)

	ALLOCATE(PROJ(LENPROJ,NANG),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL  ERRT(46,'OP, PROJ',IER)

	CALL PREPANG(DM,NANG)

C       FIRST CALL JUST FIGURES NN, INUMBRT HERE IS A DUMMY ARGUMENT
	CALL  PSQU_P(N,NN,INUMBRT,RI,.FALSE.)

	ALLOCATE(IPCUBE(3,NN),STAT=IRTFLG)
	IF (IRTFLG.NE.0) CALL ERRT(46,'OP, IPCUBE',IER)

	CALL  PSQU_P(N,NN,IPCUBE,RI,.TRUE.)

#ifdef SP_LIBFFT
	LDA=1
	CALL  SCFFT1DUI(LENPROJ,B2)
#endif
	DO  8  K=1,NIMA

C       READ ONE IMAGE
	CALL FILGET(FINPAT,FINPIC,NLET,INUMBRT(K),INTFLAG)
	MAXIM = 0
	CALL  OPFILEC(0,.FALSE.,FINPIC,INPIC,'O',IFORM,
     &                LSAM,LROW,NSL,MAXIM,' ',.FALSE.,NF)
	IF (NF.NE.0)  RETURN

	DO  J=1,N
           CALL  REDLIN(INPIC,X(1,J),N,J)
	ENDDO
	CLOSE(INPIC)

C       NORMALIZE UNDER THE MASK
        CALL NORMAS(X,NSB,NSE,NRB,NRE,IR1,IR2)

C       CALCULATE LINE PROJECTIONS
	CALL  PRJC2_P(X,N,DM,NANG,PROJ,LENPROJ,IPCUBE,NN)
C--------------------------------------------------------------
	BREAK=.FALSE.
Cc$omp parallel do private(j,b1,bt),shared(break)
	DO  1  J=1,NANG
	 B1(1:LENPROJ)=PROJ(1:LENPROJ,J)

C        NORMALIZE THE LINE
	 CALL  NRL(B1,LENPROJ)

C        MIRROR THE LINES
	 DO  L=1,LENPROJ
	    BT(L)=B1(LENPROJ-L+1)
	 ENDDO
	 INV=+1

#ifdef SP_LIBFFT
	 CALL  SCFFT1DU(INV,LENPROJ,B1,LDA,B2)
#else
	 CALL FMR_1(B1,LENPROJ,B2,INV)
#endif
	 IF (INV.NE.1)  THEN
	    BREAK=.TRUE.
	 ELSE
	    DO  L=LENB,LENB+LENF-1
	       PRJ(L-LENB+1,J,K)=B1(L)
	    ENDDO
	 ENDIF
	 INV=+1
#ifdef SP_LIBFFT
	 CALL  SCFFT1DU(INV,LENPROJ,BT,LDA,B2)
#else
	 CALL FMR_1(BT,LENPROJ,B2,INV)
#endif
	 DO  L=LENB,LENB+LENF-1
	    PRJ(L-LENB+1,J+NANG,K)=BT(L)
	 ENDDO
1	CONTINUE

	IF (BREAK) THEN
	    CALL ERRT(38,'OP',NE)
	    RETURN
	ENDIF

8	CONTINUE
	DEALLOCATE(IPCUBE)
	DEALLOCATE(PROJ)
	DEALLOCATE(X)
	DEALLOCATE(DM)
	END


	SUBROUTINE  PRJC2_P (SQUARE,N,DM,NANG,PROJ,LENPROJ,IPCUBE,NN)

        DIMENSION  DM(2,NANG)
	DIMENSION  SQUARE(N,N),PROJ(LENPROJ,NANG)
	INTEGER    IPCUBE(3,NN)

	COMMON /PAR/  LDP,NM,LDPNM

	PROJ=0.0
CC$OMP PARALLEL DO PRIVATE(I)
	DO  I=1,NANG
	  CALL  PRJC11_P(SQUARE,N,DM(1,I),PROJ(1,I),LENPROJ,IPCUBE,NN)
	ENDDO
	END



	SUBROUTINE  PRJC11_P(SQUARE,N,DM,PROJ,LENPROJ,IPCUBE,NN)

        DIMENSION  DM(2)
	DIMENSION  SQUARE(N,N),PROJ(LENPROJ)
	INTEGER  IPCUBE(3,NN)
	COMMON /PAR/  LDP,NM,LDPNM

	DO  1  I=1,NN
           IY=IPCUBE(2,I)
           XB=(IPCUBE(1,I)-LDP)*DM(1)+(IY-LDP)*DM(2)
           DO  1  J=IPCUBE(1,I),IPCUBE(3,I)
              IQX=IFIX(XB+FLOAT(LDPNM))
	      IF(IQX.GT.0 .AND.  IQX.LT.LENPROJ) THEN
               DIPX=XB+LDPNM-IQX
               PROJ(IQX)=PROJ(IQX)+(1.0-DIPX)*SQUARE(J,IY)
               PROJ(IQX+1)=PROJ(IQX+1)+DIPX*SQUARE(J,IY)
	      ENDIF
1	XB=XB+DM(1)
	END



	SUBROUTINE  PSQU_P(N,NN,IPCUBE,RI,FILL)

	INTEGER  IPCUBE(3,*)
	LOGICAL  FIRST,FILL
	COMMON /PAR/  LDP

C       IPCUBE: 
C       1 - IX
C       2 - IY
C       3 - END OF IX

	R=RI*RI

	NN=0

	DO  25  I1=1,N
	T=I1-LDP
	XX=T*T
	FIRST=.TRUE.
	DO 20 I2=1,N
           T=I2-LDP
           RC=T*T+XX
           IF (FIRST)  THEN
              IF (RC.GT.R)  GOTO 14
              FIRST = .FALSE.
              NN = NN+1
              IF (FILL) THEN
                 IPCUBE(1,NN)=I2
                 IPCUBE(2,NN)=I1
                 IPCUBE(3,NN)=I2
              ENDIF
           ELSE
              IF (FILL)  IPCUBE(3,NN)=I2
              IF (RC.GT.R)  GOTO  16
           ENDIF
14	   CONTINUE
20	CONTINUE
16	CONTINUE
25	CONTINUE

	END


	SUBROUTINE  GENAT(ANGTAB,DPSI,NANGT,FILL)

	DIMENSION  ANGTAB(2,*)
	LOGICAL FILL
	PARAMETER (QUADPI = 3.141592653589793238462643383279502884197)
        PARAMETER (DGR_TO_RAD = (QUADPI/180))

C       ANGTAB(1  - THETA
C       ANGTAB(2  - PHI
	NANGT=0
	P1=0.0
	P2=359.9
	DO THETA=0.,179.999,DPSI
           IF (THETA.EQ.0.0.OR.THETA.EQ.180.0)  THEN
	      DETPHI=360.0
	      LT=1
           ELSE
	      DETPHI=DPSI/SIN(DGR_TO_RAD*THETA)
	      LT=MAX0(INT((P2-P1)/DETPHI)-1,1)
	      DETPHI=(P2-P1)/LT
           ENDIF
C	   DO 1  PHI=P1,P2,DETPHI
           DO I=1,LT
              PHI   = P1+(I-1)*DETPHI
              NANGT = NANGT+1
	      IF (FILL)  THEN
	         ANGTAB(1,NANGT)=THETA
	         ANGTAB(2,NANGT)=PHI
	      ENDIF
           ENDDO
        ENDDO
	END

#ifdef SP_IBMSP3
        REAL FUNCTION ETIME(TARRAY)

        DIMENSION TARRAY(2)

C       CLOCK RESETS AT ICMAX!!
        CALL SYSTEM_CLOCK(ICOUNT,ICPSEC,ICMAX)

        ETIME = ICOUNT / ICPSEC

        RETURN
        END


#endif
@


1.29
log
@LEN=MAXNAM on F_SPEC
@
text
@d14 1
a14 1
C=* Email: spider@@wadsworth.org                                        *
@


1.28
log
@GPL_2010
@
text
@d6 1
d12 1
a12 1
C=* Copyright 1985-2010  Health Research Inc.,                         *
d67 2
a68 2
	CHARACTER*80      FINPAT,FINPIC,FINFO,FINDOC
	COMMON  /F_SPEC/  FINPAT,FINPIC,FINFO,FINDOC,NLET
d76 1
d1105 6
a1110 2
	COMMON  /F_SPEC/  FINPAT,FINPIC,FINFO,FINDOC,NLET
	CHARACTER*80      FINPAT,FINPIC,FINFO,FINDOC
@


1.27
log
@list for files added
@
text
@a7 2
C=* FROM: SPIDER - MODULAR IMAGE PROCESSING SYSTEM.   AUTHOR: J.FRANK  *
C=* Copyright (C) 1985-2007  Health Research Inc.                      *
d9 5
a13 2
C=* HEALTH RESEARCH INCORPORATED (HRI),                                *   
C=* ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
d15 1
a15 3
C=* Email:  spider@@wadsworth.org                                       *
C=*                                                                    *
C=* This program is free software; you can redistribute it and/or      *
d20 1
a20 1
C=* This program is distributed in the hope that it will be useful,    *
d22 1
a22 1
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
a23 1
C=*                                                                    *
d25 1
a25 3
C=* along with this program; if not, write to the                      *
C=* Free Software Foundation, Inc.,                                    *
C=* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.      *
@


1.26
log
@overlength line 456
@
text
@d4 2
a5 1
C                  OPFILEC                         FEB  03 ARDEAN LEITH
d9 1
a9 1
C=* Copyright (C) 1985-2005  Health Research Inc.                      *
d39 2
d67 1
d76 1
a76 1
	COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX)
d83 1
a83 2
	DATA  INPIC/99/,INDOC/96/

d89 7
a95 7
	NMAX = NILMAX
 	CALL FILSEQP(FINPAT,NLET,ILIST,NMAX,NIMA,
     &               'TEMPLATE FOR IMAGES',IRTFLG)
 	IF (IRTFLG.NE.0)  RETURN
	
 	CALL FILGET(FINPAT,FINPIC,NLET,ILIST(1),IRTFLG)
 	IF (IRTFLG.NE.0)  RETURN
d104 1
a104 2
	CALL  RDPRMI(LENPROJ,NANG,NOT_USED,
     &	     'LENGTH OF LINE PROJECTION')
d115 1
a115 2
	CALL  RDPRMI(IDPSI,NANG,NOT_USED,
     &	     'ACCURACY OF THETA')
d135 1
d139 2
a140 2
	CALL  RDPRMI(MAXIT,IDUM,NOT_USED,
     &	    'MAXIMUM NUMBER OF CYCLES')
d172 1
a172 1
 	CALL RDL_P(N,NANG,LENPROJ,RI,ILIST,NIMA,PRJ,LENB,LENF)
d206 1
a206 1
	SUBROUTINE  FCANG(NANG,NIMA,LENPROJ,MAXIT,
d1092 1
a1092 1
	SUBROUTINE  RDL_P(N,NANG,LENPROJ,RI,ILIST,NIMA,PRJ,LENB,LENF)
d1095 1
a1095 1
	DIMENSION  PRJ(LENF,2*NANG,NIMA)
d1097 3
a1099 1
	DIMENSION  ILIST(NIMA)
d1103 2
a1104 3
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  X,PROJ,DM
	INTEGER, ALLOCATABLE, DIMENSION(:,:) ::  IPCUBE
        INTEGER      IR1,IR2
d1108 1
a1108 1
	CHARACTER*80    FINPAT,FINPIC,FINFO,FINDOC
d1135 2
a1136 2
C       FIRST CALL JUST FIGURES NN, ILIST HERE IS A DUMMY ARGUMENT
	CALL  PSQU_P(N,NN,ILIST,RI,.FALSE.)
d1150 1
a1150 1
	CALL FILGET(FINPAT,FINPIC,NLET,ILIST(K),INTFLAG)
@


1.25
log
@GPL License fixed
@
text
@d39 1
a39 1
C              OpenMP switched off - it does nto work on Linux
d448 1
a448 1
	P(1,ISPIN)=M	
d450 21
a470 21
C       GET LINES ROTATED BY PSI ANGLE
	K=0
	DO   I=1,NIMA-1
	 DO   J=I+1,NIMA
	  IF(I.EQ.ISPIN.OR.J.EQ.ISPIN) THEN
	   K=K+1
	IF(L1(K).EQ.NANG/2+1.OR.L1(K).EQ.271.OR.L2(K).EQ.91.OR.L2(K).EQ.271) 
     &     THEN
	    CALL  CALDILW1(P(1,I),P(1,J),NANG,LT1(K),LT2(K))
	ELSE
	    IF(I.EQ.ISPIN)  THEN
	     LT1(K)=MOD(L1(K)-M+2*NANG-1,2*NANG)+1
	     LT2(K)=L2(K)
	    ELSE
	     LT1(K)=L1(K)
	     LT2(K)=MOD(L2(K)-M+2*NANG-1,2*NANG)+1
	    ENDIF
	ENDIF
	  ENDIF
	 ENDDO
	ENDDO
d472 23
a494 22
C       DO THE DISTANCE WITH WEIGHTING
	DIST=0.0D0
	K=0
	DO   I=1,NIMA-1
	 DO   J=I+1,NIMA
	  IF(I.EQ.ISPIN.OR.J.EQ.ISPIN) THEN
	   K=K+1
	   	if(w(k).le.0.0)  then
		print *,' incorrect weight',k,w(k)
		stop
		endif
	   DIST=DIST+EDL1(PRJ(1,LT1(K),I),PRJ(1,LT2(K),J),LENPROJ)*W(K)
	  ENDIF
	 ENDDO
	ENDDO
C
	IF(DIST.LT.DMIN)  THEN
	 DMIN=DIST
	 LMIN=L
	 MMIN=M
	ENDIF
	ENDDO
@


1.24
log
@Pawels bug fix for removing mp and nang
@
text
@d7 23
a29 6
C * SPIDER - MODULAR IMAGE PROCESSING SYSTEM.    AUTHOR: J.FRANK       *
C * COPYRIGHT (C)1985, 1999. HEALTH RESEARCH INCORPORATED (HRI),       *
C * ONE UNIVERSITY PLACE, RENSSELAER, NY 12144-3455.                   *
C * THE CONTENTS OF THIS DOCUMENT ARE PROPRIETARY TO HRI AND ARE NOT   *
C * TO BE DISCLOSED TO OTHERS OR USED FOR PURPOSES OTHER THAN INTENDED *
C * WITHOUT WRITTEN APPROVAL OF HRI.                                   *
@


1.23
log
@opfilec
@
text
@d3 1
a3 1
C  POLQS.F                                                                    *
d15 1
a15 1
C  POLQS(MAXMEM)                                                                    *
d21 2
d96 2
a97 2
	CALL  RDPRMI(NANG,IDPSI,NOT_USED,
     &	     'ACCURACY OF PSI AND THETA')
d99 7
a105 1
	IF (NANG.EQ.0)  THEN
d108 9
a116 3
	ELSE
	   NANG=180/NANG
	ENDIF
d182 2
a183 2
	DEALLOCATE(P)
	DEALLOCATE(PRJ)
d292 1
a292 1
c$omp parallel do private(l)
d439 1
a439 1
	IF(L1(K).EQ.91.OR.L1(K).EQ.271.OR.L2(K).EQ.91.OR.L2(K).EQ.271) 
d444 1
a444 1
	     LT1(K)=MOD(L1(K)-M+360-1,360)+1
d448 1
a448 1
	     LT2(K)=MOD(L2(K)-M+360-1,360)+1
d462 4
d594 1
a594 1
	     LT1(K)=MOD(L1(K)-M+360-1,360)+1
d598 1
a598 1
	     LT2(K)=MOD(L2(K)-M+360-1,360)+1
d649 10
a658 10
#ifdef SP_MP
	NTR=NIMA*(NIMA-1)/2
c$omp parallel do private(k,i,j,did)
c$omp+reduction(+:din)
	DO  K=1,NTR
	   CALL DECO(K,NIMA,I,J)
	   CALL  CALDIL
     &	     (PRJ(1,1,I),P(1,I),PRJ(1,1,J),P(1,J),LENPROJ,NANG,DID)
	   DIN=DIN+DID
#else
d665 1
a665 1
#endif
d1147 1
a1147 1
c$omp parallel do private(j,b1,bt),shared(break)
d1205 1
a1205 1
C$OMP PARALLEL DO PRIVATE(I)
d1225 5
a1229 3
              DIPX=XB+LDPNM-IQX
              PROJ(IQX)=PROJ(IQX)+(1.0-DIPX)*SQUARE(J,IY)
              PROJ(IQX+1)=PROJ(IQX+1)+DIPX*SQUARE(J,IY)
@


1.22
log
@nloop,iloop_removed
@
text
@d4 1
d50 1
a50 1
	CHARACTER*1  NULL,MODIS
a61 1
	NULL = CHAR(0)
d76 2
a77 2
	CALL OPFIL(.FALSE.,FINPIC,INPIC,'O',N,NROW,NSL,MAXIM,' ',
     &	            .FALSE.,IRTFLG)
a1065 1
	CHARACTER*1  NULL
a1074 1
	NULL=CHAR(0)
d1113 2
a1114 2
	CALL  OPFIL(.FALSE.,FINPIC,INPIC,'O',LSAM,LROW,NSL,MAXIM,' ',
     &	            .FALSE.,NF)
@


1.21
log
@corrected || in DECO
@
text
@d82 1
a82 1
	CALL  RDPRMI(LENPROJ,NANG,NLOOP,ILOOP,
d84 1
a84 1
	CALL RDPRM2(F1,F2,NLOOP,ILOOP,'MINIMUM, MAXIMUM FREQUENCY')
d94 1
a94 1
	CALL  RDPRMI(NANG,IDPSI,NLOOP,ILOOP,
d106 1
a106 1
	CALL  RDPRMI(MAXIT,IDUM,NLOOP,ILOOP,
@


1.20
log
@cosmetic
@
text
@d21 1
a21 1
C   07/29/99   PARALLEL, F90 VERSION; CORRECTED ON 02/21/01
d123 1
a123 1
C       ALWAYS SKIP (0) TERM
d125 1
d132 1
a132 1
	ALLOCATE(PRJ(LENPROJ,2*NANG,NIMA),STAT=IRTFLG)
d162 1
a162 1
cc	CALL FCANG(NANG,NIMA,LENF,MAXIT,P,PRJ,NANGT,IDPSI)
a631 1
	KPREV=-1
d633 1
a633 1
c$omp parallel do private(k,i,j,did),firstprivate(kprev)
d636 1
a636 2
	   IF (K/=KPREV+1)  CALL DECO(K,NIMA,I,J)
	   KPREV=K
a652 1

d655 11
a665 7
	L=1
	DO  J=2,N
	 IF(L+J-1>M)  THEN
	  I=M-L+1
          RETURN
	 ENDIF
	ENDDO
a667 1

d1152 1
a1152 2
C !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	    DO  L=LENB,LENB+LENF-1,2
a1153 1
               PRJ(L-LENB,J,K)=B1(L+1)
a1156 2
C !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

d1162 1
a1162 1
	 DO  L=LENB,LENB+LENF-1,2
a1163 1
	    PRJ(L-LENB,J+NANG,K)=BT(L+1)
@


1.19
log
@|| fixed
@
text
@d3 1
a4 1
C                                                                      *
d14 1
a14 1
C                                                                      *
d21 1
a21 1
C   07/29/99   Parallel, f90 version; corrected on 02/21/01
d23 1
a23 1
C   02/11/99  Trigonometric functions changed to f90.
d26 1
a26 1
C distribution of angles in angtab changed to agree with current VO EA
d28 2
a29 2
C complete version for spider
C    Calculates the 1D projections of 2D images (not normalized).
d32 5
a36 5
c  same as polqt, but Fourier version ...
c  weights on circle as in polqw
c  problem of duplicated lines in weighting solved
c  weights taken out of the do-loop
c  Correct line calculation, exclusion of identical directions ...
d45 2
d48 4
a51 2
	CHARACTER*80  FINPAT,FINPIC,FINFO,FINDOC
	CHARACTER*1  NULL,modis
a53 1
	COMMON  /pols/ modis
d55 3
a57 3
	REAL, ALLOCATABLE, DIMENSION(:,:,:) ::  prj
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  P
	REAL,  DIMENSION(:,:), POINTER ::  IPQ
d60 2
a61 1
	NULL=CHAR(0)
d63 16
a78 14
C       N - linear dimension of 2d image
C       NANG - number of angles
C       NIMA - number of 2D images

	NMAX=NILMAX
 	CALL  FILSEQP(FINPAT,NLET,ILIST,NMAX,NIMA,'Images',IRTFLG)
 	CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(1),INTFLG)
	MAXIM=0
	CALL  OPFIL(.FALSE.,FINPIC,INPIC,'O',N,NROW,NSL,MAXIM,' ',
     &	            .FALSE.,NF)
 	IF(NF.NE.0)  THEN
	 CALL ERRT(18,'OP',NE)
	 RETURN
	ENDIF
d81 1
a81 2
C       NANG - total number of angles

d86 1
a86 1
	IF(F1.LT.0.0 .OR. F2.GT.0.5 .OR. F1.GT.F2)  THEN
d96 1
d104 2
a105 1
	IF(IDPSI.EQ.0)  IDPSI=5 
d111 1
a111 1
	MODIS='E'
d113 6
a118 6
        RI=LENPROJ/2
	LENPROJ=LENPROJ/2
	LENPROJ=LENPROJ*2+1
	IF(LENPROJ.GT.N-2) THEN
	LENRPOJ=N-2
	IF (MOD(N,2).EQ.0)  LENRPOJ=LENRPOJ-1
d120 1
a120 1
     &	   'Length of projection too large!  Limited to ',LENRPOJ
d123 1
a123 1
C       Always skip (0) term
d132 4
a135 1
	IF (IRTFLG.NE.0) CALL  ERRT(46,'OP, PRJ',IER)
d138 2
a139 1
	CALL  RDL_P(N,NANG,LENPROJ,RI,ILIST,NIMA,prj,LENB,LENF)
d141 1
a141 1
	WRITE(NOUT,*) ' Time for reading projections = ',TM2-TM1
d143 3
a145 3
	MAXKEY=NIMA
	MAXREG=4
	CALL  GETDOCDAT('DOCUMENT WITH INITIAL ANGLES',.TRUE.,FINDOC,
d150 1
a150 1
	IF (IRTFLG.NE.0) CALL  ERRT(46,'OP, P',IER)
d152 3
a154 3
	DO  I=1,MAXKEY
	   DO  J=1,3
              P(J,I)=IPQ(J+1,I)
d157 1
a157 1
C       IPQ no longer needed
d160 2
a161 3
	TM3=ETIME(TARRAY)
	CALL  FCANG(NANG,NIMA,LENF,MAXIT,P,prj,NANGT,IDPSI)
	TM4=ETIME(TARRAY)
d163 1
a163 1
	WRITE(NOUT,*) ' Time for angle search = ',TM4-TM3
d165 2
d168 1
a168 1
	DEALLOCATE(prj)
d173 1
a173 1
     &		P,PRJ,NANGT,IDPSI)
d176 1
d178 1
d180 3
a182 4
	DIMENSION  prj(lenproj,2*nang,nima)
	REAL, ALLOCATABLE, DIMENSION(:,:) ::  angtab
	DIMENSION  DLIST(NDLI)
	character*8 CTIME
d185 1
d187 12
a198 11
c       new tables.
c       angtab(1  - theta
c       angtab(2  - phi
	logical change,changepos
c       set first three angles to zero forever ...
C	p(1,1)=0.0
c	p(2,1)=0.0
c	p(3,1)=0.0
c
	ALLOCATE(angtab(2,nangt),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'OP, angtab',IER)
d201 5
a205 4
	CALL  GENAT(ANGTAB,DPSI,NANGT,.TRUE.)
	fvalue=DIST(NIMA,nang,lenproj,prj,P)
	WRITE(NOUT,2177)  fvalue
2177	FORMAT(1X,'Initial discrepancy ',1PE10.3)
d207 3
a209 2
2178	FORMAT(1X,'Initial angles',5X,'PSI',7X,'THETA',5X,'PHI')
c       try to spin
d211 2
a212 2
507	change=.true.
	changepos=.false.
d214 4
a217 3
	do  i=1,NIMA
	   WRITE(NOUT,2179)  i,(p(j,i),j=1,3)
	enddo
d220 1
d223 1
d225 1
d230 2
a231 2
	    CALL  SPIN
     &	       (NIMA,NANG,LENPROJ,PRJ,P,
d240 1
a240 1
	IF(CHANGEPOS)  THEN
d243 1
a243 1
2181	   FORMAT(1X,'Cycle',I9,'  New value=',1PE10.3)
d247 2
a248 2
	   CALL  SAVD(NDOC,DLIST,3,IRTFLG)
	   DO  I=1,NIMA
d250 1
a250 1
	      DO  J=1,3
d253 1
a253 1
	      CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
d256 1
a256 1
	IF(CHANGEPOS.AND.(MAXIT.EQ.0.OR.ITER.LT.MAXIT))  GOTO  507
d264 7
a270 8
	SUBROUTINE  SPIN
     &	(nima,nang,lenproj,prj,p,
     &		ispin,IDPSI,angtab,nangt,mmin,lmin,change)

	DIMENSION  P(3,nima),prj(lenproj,2*nang,nima)
	dimension  angtab(2,nangt)
	double precision dmi(nangt),dmin
	dimension  lmi(nangt),mmi(nangt)
d272 5
a276 4
	logical change
C       length of arrays needed in dwtg
	lnm2=nima*(nima-1)/2
c       Spin
d278 173
a450 134
	do  l=1,nangt
	   call  dwtg(p,angtab(1,l),prj,ispin,nima,nang,lenproj,
     &		    l,IDPSI,dmi(l),lmi(l),mmi(l),lnm2)
	enddo
	dmin=1.0D23
	lmin=-1
	mmin=-1
	do  2 l=1,nangt
	 do    i=1,nima
	  if(i.ne.ispin.and.
     &	  p(2,i).eq.angtab(1,l).and.p(3,i).eq.angtab(2,l)) goto 2
	 enddo
	 if(dmi(l).lt.dmin)  then
	  dmin=dmi(l)
	  lmin=lmi(l)
	  mmin=mmi(l)
	 endif
2	continue
c       check whether position changed
C	print  *,nangt,dmin,lmin,mmin
C	print  *,float(mmin),angtab(1,lmin),angtab(2,lmin)
	if(p(1,ispin).eq.float(mmin))  then
	 if(p(2,ispin).eq.angtab(1,lmin))  then
	  if(p(3,ispin).eq.angtab(2,lmin))  then
	   change=.false.
	   return
	  endif
	 endif
	endif
	change=.true.
	END


	subroutine  dwtg(pp,angtab,prj,ispin,nima,nang,lenproj,
     &		l,IDPSI,dmin,lmin,mmin,lnm2)
	dimension  pp(3,nima),angtab(2),prj(lenproj,2*nang,nima)
c automatic arrays
	dimension  l1(lnm2),l2(lnm2),lt(lnm2)
	dimension  w(lnm2),lt1(lnm2),lt2(lnm2),lord(lnm2)
	dimension  p(3,nima)
	double precision dmin,did,dist

	dmin=1.0D23
	lmin=-1
	mmin=-1
	do    i=1,nima
	 if(i.ne.ispin.and.
     &	  pp(2,i).eq.angtab(1).and.pp(3,i).eq.angtab(2)) return
	enddo

	p=pp

	nim=nima-1

	p(2,ispin)=angtab(1)
	p(3,ispin)=angtab(2)
	p(1,ispin)=0.0	

	k=0
	do   i=1,nima-1
	 do   j=i+1,nima
	  if(i.eq.ispin.or.j.eq.ispin) then
	   k=k+1
	   lord(k)=k
	   CALL  CALDILW1(p(1,i),p(1,j),nang,l1(k),l2(k))
	  endif
	 enddo
	enddo

	k=0
	do   i=1,nima-1
	 do   j=i+1,nima
	  if(i.eq.ispin) then
	   k=k+1
	   lt(k)=l1(k)
	   if(lt(k).gt.nang)  lt(k)=lt(k)-nang
	   elseif(j.eq.ispin)  then
	    k=k+1
	    lt(k)=l2(k)
	    if(lt(k).gt.nang)  lt(k)=lt(k)-nang
	   endif
	 enddo
	enddo
c
c  from small to large
	CALL  SORT2(lt,lord,nim)
c
	qt=1.0
	do   k=2,nim-1
	 if(lt(k).ne.lt(k-1))  then
	  w(lord(k))=float(lt(k+1)-lt(k-1))/2
	  qt=1.0
	 else
	  qt=qt+1.0
	  w(lord(k))=-qt
	 endif
	enddo
c
	if(lt(nim).ne.lt(nim-1))  then
	 w(lord(nim))=float(lt(1)+nang-lt(nim-1))/2
	else
	 qt=qt+1
	 w(lord(nim))=-qt
	endif
	w(lord(1))=float(lt(2)-lt(nim)+nang)/2
c
	k=1
105	k=k+1
	if(w(lord(k)).lt.0.0)  then
	kb=k-1
	k=kb
106	k=k+1
	if(w(lord(k)).lt.0.0)  then
         if(k.ne.nim) goto 106
	else
	 k=k-1
	endif
	 w(lord(kb))=-w(lord(kb))/w(lord(k))
	 do   kk=kb+1,k
	  w(lord(kk))=w(lord(kb))
	 enddo
	endif
	if(k.lt.nim) goto  105
c
	wt=0.0
	do   k=1,nim
	 wt=wt+w(k)
	enddo
	do   k=1,nim
	 w(k)=w(k)/wt
	enddo
c
	do  m=0,359,IDPSI
	p(1,ispin)=m	
d452 17
a468 50
c  get lines rotated by psi angle
	k=0
	do   i=1,nima-1
	 do   j=i+1,nima
	  if(i.eq.ispin.or.j.eq.ispin) then
	   k=k+1
	if(l1(k).eq.91.or.l1(k).eq.271.or.l2(k).eq.91.or.l2(k).eq.271) 
     &     then
	    CALL  CALDILW1(p(1,i),p(1,j),nang,lt1(k),lt2(k))
	else
	    if(i.eq.ispin)  then
	     lt1(k)=mod(l1(k)-m+360-1,360)+1
	     lt2(k)=l2(k)
	    else
	     lt1(k)=l1(k)
	     lt2(k)=mod(l2(k)-m+360-1,360)+1
	    endif
	endif
	  endif
	 enddo
	enddo
c... 
c do the distance with weighting
	dist=0.0d0
	k=0
	do   i=1,nima-1
	 do   j=i+1,nima
	  if(i.eq.ispin.or.j.eq.ispin) then
	   k=k+1
	   dist=dist+EDL1(prj(1,lt1(k),i),prj(1,lt2(k),j),lenproj)*w(k)
	  endif
	 enddo
	enddo
c
	if(dist.lt.dmin)  then
	 dmin=dist
	 lmin=l
	 mmin=m
	endif
	enddo
c end of do-loop over m (PSI angle)
	end
C	
	SUBROUTINE  SPINSPIN
     &	(nima,nang,lenproj,prj,p,
     &		ispin,IDPSI,angtab,nangt,mmin,lmin,change,
     &		l1,l2,lt,lt1,lt2,lord,w)
	DIMENSION  P(3,nima),prj(lenproj,2*nang,nima),ptmp(3)
	dimension  angtab(2,nangt)
	double precision dmin,did,dist
d470 128
a597 93
	logical change
c
	dimension  l1(*),l2(*),lt(*),lt1(*),lt2(*),lord(*)
	dimension  w(*)
	nim=nima-1
c  Spin
	dmin=1.0e23
	lmin=-1
	mmin=-1
	do  1  l=1,nangt
	do  i=1,nima
	if(i.ne.ispin.and.
     &	p(2,i).eq.angtab(1,l).and.p(3,i).eq.angtab(2,l)) goto 1
	enddo
	ptmp(2)=p(2,ispin)	
	ptmp(3)=p(3,ispin)
	ptmp(1)=p(1,ispin)	
	p(2,ispin)=angtab(1,l)
	p(3,ispin)=angtab(2,l)
	p(1,ispin)=0.0	
c
	k=0
	do  14  i=1,nima-1
	do  14  j=i+1,nima
	if(i.eq.ispin.or.j.eq.ispin) then
	k=k+1
	lord(k)=k
	CALL  CALDILW1(p(1,i),p(1,j),nang,l1(k),l2(k))
	endif
14	continue
c
	k=0
	do  101  i=1,nima-1
	do  101  j=i+1,nima
	if(i.eq.ispin) then
	k=k+1
	lt(k)=l1(k)
	if(lt(k).gt.nang)  lt(k)=lt(k)-nang
	elseif(j.eq.ispin)  then
	k=k+1
	lt(k)=l2(k)
	if(lt(k).gt.nang)  lt(k)=lt(k)-nang
	endif
101	continue
c
c  from small to large
	CALL  SORT2(lt,lord,nim)
c
	qt=1.0
	do  102  k=2,nim-1
	if(lt(k).ne.lt(k-1))  then
	w(lord(k))=float(lt(k+1)-lt(k-1))/2
	qt=1.0
	else
	qt=qt+1.0
	w(lord(k))=-qt
	endif
102	continue
	if(lt(nim).ne.lt(nim-1))  then
	w(lord(nim))=float(lt(1)+nang-lt(nim-1))/2
	else
	qt=qt+1
	w(lord(nim))=-qt
	endif
	w(lord(1))=float(lt(2)-lt(nim)+nang)/2
c
	k=1
105	k=k+1
	if(w(lord(k)).lt.0.0)  then
	kb=k-1
	k=kb
106	k=k+1
	if(w(lord(k)).lt.0.0)  then
        if(k.ne.nim) goto 106
	else
	k=k-1
	endif
	w(lord(kb))=-w(lord(kb))/w(lord(k))
	do  107  kk=kb+1,k
107	w(lord(kk))=w(lord(kb))
	endif
	if(k.lt.nim) goto  105
c	
	wt=0.0
	do   k=1,nim
	 wt=wt+w(k)
	enddo
	do   k=1,nim
	 w(k)=w(k)/wt
	enddo
c
	do  2  m=0,359,IDPSI
	p(1,ispin)=m	
d599 22
a620 57
c  get lines rotated by psi angle
	k=0
	do   i=1,nima-1
	 do   j=i+1,nima
	  if(i.eq.ispin.or.j.eq.ispin) then
	   k=k+1
	if(l1(k).eq.91.or.l1(k).eq.271.or.l2(k).eq.91.or.l2(k).eq.271)
     &      then
	    CALL  CALDILW1(p(1,i),p(1,j),nang,lt1(k),lt2(k))
	else
	    if(i.eq.ispin)  then
	     lt1(k)=mod(l1(k)-m+360-1,360)+1
	     lt2(k)=l2(k)
	    else
	     lt1(k)=l1(k)
	     lt2(k)=mod(l2(k)-m+360-1,360)+1
	    endif
	endif
	   endif
	 enddo
	enddo
c... 
c do the distance with weighting
	dist=0.0d0
	k=0
	do   i=1,nima-1
	 do   j=i+1,nima
	  if(i.eq.ispin.or.j.eq.ispin) then
	   k=k+1
	   did=EDL1(prj(1,lt1(k),i),prj(1,lt2(k),j),lenproj)
	   dist=dist+did*w(k)
	  endif
	 enddo
	enddo
c
	if(dist.lt.dmin)  then
	 dmin=dist
	 lmin=l
	 mmin=m
	endif
2	continue
	p(2,ispin)=ptmp(2)	
	p(3,ispin)=ptmp(3)
	p(1,ispin)=ptmp(1)
1	continue
c  check whether position changed
C	print  *,nangt,dmin,lmin,mmin
C	print  *,float(mmin),angtab(1,lmin),angtab(2,lmin)
	if(p(1,ispin).eq.float(mmin))  then
	 if(p(2,ispin).eq.angtab(1,lmin))  then
	  if(p(3,ispin).eq.angtab(2,lmin))  then
	   change=.false.
	   return
	  endif
	 endif
	endif
	change=.true.
d622 2
a623 1
C	
d625 5
a629 5
     &	(nima,nang,lenproj,prj,p)
	DIMENSION  P(3,nima),prj(lenproj,2*nang,nima)
	double precision  din,din1,din2,did
c
	din=0.0d0
d631 2
a632 2
	kprev=-1
	Ntr=nima*(nima-1)/2
d635 6
a640 6
	do  k=1,Ntr
	 if(k/=kprev+1)  call DECO(k,nima,i,j)
	 kprev=k
	  CALL  CALDIL
     &	  (prj(1,1,i),p(1,i),prj(1,1,j),p(1,j),lenproj,nang,did)
	  din=din+did
d642 2
a643 2
	do  i=1,nima-1
	 do  j=i+1,nima
d645 3
a647 3
     &	  (prj(1,1,i),p(1,i),prj(1,1,j),p(1,j),lenproj,nang,did)
	  din=din+did
	 enddo
d649 2
a650 2
	enddo
	dist=din
d652 9
a660 7
C
	SUBROUTINE  DECO(m,n,i,j)
Ccccccccccccccccccccccccccc  i<j
	l=1
	do  j=2,n
	 if(l+j-1>m)  then
	  i=m-l+1
d662 2
a663 2
	 endif
	enddo
d665 18
a682 17
c
	SUBROUTINE  CALDIL(prj1,fi1,prj2,fi2,lenproj,nang,did)
c
c  Calculates distance did using common line
c  Warning - the result is not the same after changing the order
c            of arguments:  fi1<->fi2 !!
c            Such change means that angles found should be reversed too:
c                        alpha1<->alpha2
c
	dimension  prj1(lenproj,2*nang),fi1(3),
     &             prj2(lenproj,2*nang),fi2(3)
c	double precision  edl1,edl2,edl3,did,r1(3,3),r2(3,3),r3(3,3)
	double precision  edl2,edl3,did,r1(3,3),r2(3,3),r3(3,3)
	double precision  ecl1,ecl2,ecl3
	double precision  psi,theta,phi,deps
	CHARACTER*1  modis
	common  /pols/ modis
d687 9
a695 8
	call  bldr(r1,-fi1(3),-fi1(2),-fi1(1))
	call  bldr(r2,fi2(1),fi2(2),fi2(3))
	do  1  i=1,3
	do  1  j=1,3
	r3(i,j)=0.0
	do  1  k=1,3
1	r3(i,j)=r3(i,j)+r2(i,k)*r1(k,j)
C
d697 1
a697 1
C  Limit precision
d699 4
a702 4
         DO  5  I=1,3
         IF(DABS(R3(I,J)).LT.DEPS)  R3(I,J)=0.0D0
         IF(R3(I,J)-1.0D0.GT.-DEPS)  R3(I,J)=1.0D0
         IF(R3(I,J)+1.0D0.LT.DEPS)  R3(I,J)=-1.0D0
d704 10
a713 9
C
         IF(R3(3,3).EQ.1.0)  THEN
         THETA=0.0
         PSI=0.0
         IF(R3(1,1).EQ.0.0)  THEN
         PHI=RAD_TO_DGR*DASIN(R3(1,2))
         ELSE
         PHI=RAD_TO_DGR*DATAN2(R3(1,2),R3(1,1))
         ENDIF
d715 7
a721 25
         THETA=180.0
         PSI=0.0
         IF(R3(1,1).EQ.0.0)  THEN
         PHI=RAD_TO_DGR*DASIN(-R3(1,2))
         ELSE
         PHI=RAD_TO_DGR*DATAN2(-R3(1,2),-R3(1,1))
         ENDIF
         ELSE
         THETA=RAD_TO_DGR*DACOS(R3(3,3))
         ST=DSIGN(1.0D0,THETA)
         IF(R3(3,1).EQ.0.0)  THEN
         IF(ST.NE.DSIGN(1.0D0,R3(3,2)))  THEN
         PHI=270.0
         ELSE
         PHI=90.0
         ENDIF
         ELSE
         PHI=RAD_TO_DGR*DATAN2(R3(3,2)*ST,R3(3,1)*ST)
         ENDIF
         IF(R3(1,3).EQ.0.0)  THEN
         IF(ST.NE.DSIGN(1.0D0,R3(2,3)))  THEN
         PSI=270.0
         ELSE
         PSI=90.0
         ENDIF
d723 20
a742 1
         PSI=RAD_TO_DGR*DATAN2(R3(2,3)*ST,-R3(1,3)*ST)
d744 3
a746 4
         ENDIF
         IF(PSI.LT.0.0)  PSI=PSI+360.0
         IF(THETA.LT.0.0)  THETA=THETA+360.0
         IF(PHI.LT.0.0)  PHI=PHI+360.0
d748 68
a815 68
c	if(dabs(r3(3,1)).lt.deps .and. dabs(r3(3,2)).lt.deps)  then
c	print *,'  Alpha 1  cannot be calculated'
c	did=2.0
c	return
c	endif
c	if(dabs(r3(1,3)).lt.deps .and. dabs(r3(2,3)).lt.deps)  then
c	print *,'  Alpha 2  cannot be calculated'
c	did=2.0
c	return
c	endif
c
	alpha1=90.0+phi
	alpha2=90.0-psi
c
	if(alpha1.ge.0.0)  then
	l1=mod(int(nang*alpha1/180.0),2*nang)+1
	else
	l1=mod(int(nang*(360.0+alpha1)/180.0),2*nang)+1
	endif
	if(alpha2.ge.0.0)  then
	l2=mod(int(nang*alpha2/180.0),2*nang)+1
	else
	l2=mod(int(nang*(360.0+alpha2)/180.0),2*nang)+1
	endif

	if(modis.eq.'E')  then

	did=edl1(prj1(1,l1),prj2(1,l2),lenproj)

	elseif(modis.eq.'C')  then

	if(l1.gt.nang)  then
	l1=l1-nang
		if(l2.gt.nang)  then
		l2=l2-nang
		did=ecl1(prj1(1,l1),prj2(1,l2),lenproj)
		else
		did=ecl2(prj1(1,l1),prj2(1,l2),lenproj)
		endif
	else
		if(l2.gt.nang)  then
		l2=l2-nang
		did=ecl3(prj1(1,l1),prj2(1,l2),lenproj)
		else
		did=ecl1(prj1(1,l1),prj2(1,l2),lenproj)
		endif
	endif
	else
	   stop
	endif
c	print  *,alpha1,l1,alpha2,l2,did
	end



	SUBROUTINE  CALDILW1(fi1,fi2,nang,l1,l2)

c  Calculates distance did using common line
c  Warning - the result is not the same after changing the order
c            of arguments:  fi1<->fi2 !!
c            Such change means that angles found should be reversed too:
c                        alpha1<->alpha2
c
	dimension  fi1(3),fi2(3)
	double precision  r1(3,3),r2(3,3),r3(3,3)
	double precision  psi,theta,phi,deps
	CHARACTER*1  modis
	common  /pols/ modis
d820 9
a828 8
	CALL  BLDR(r1,-fi1(3),-fi1(2),-fi1(1))
	CALL  BLDR(r2,fi2(1),fi2(2),fi2(3))
	do  1  i=1,3
	do  1  j=1,3
	r3(i,j)=0.0
	do  1  k=1,3
1	r3(i,j)=r3(i,j)+r2(i,k)*r1(k,j)
C
d830 1
a830 1
C  Limit precision
d837 1
a837 1
C
d864 1
a864 1
         PHI=RAD_TO_DGR*DATAN2(R3(3,2)*ST,R3(3,1)*ST)
d868 1
a868 1
         PSI=270.0
d870 1
a870 1
         PSI=90.0
d873 1
a873 1
         PSI=RAD_TO_DGR*DATAN2(R3(2,3)*ST,-R3(1,3)*ST)
d876 3
a878 3
         IF(PSI.LT.0.0)  PSI=PSI+360.0
         IF(THETA.LT.0.0)  THETA=THETA+360.0
         IF(PHI.LT.0.0)  PHI=PHI+360.0
d880 108
a987 102
c	if(dabs(r3(3,1)).lt.deps .and. dabs(r3(3,2)).lt.deps)  then
c	print *,'  Alpha 1  cannot be calculated'
c	did=2.0
c	return
c	endif
c	if(dabs(r3(1,3)).lt.deps .and. dabs(r3(2,3)).lt.deps)  then
c	print *,'  Alpha 2  cannot be calculated'
c	did=2.0
c	return
c	endif
c
	alpha1=90.0+phi
	alpha2=90.0-psi
c
	if(alpha1.ge.0.0)  then
	l1=mod(int(nang*alpha1/180.0),2*nang)+1
	else
	l1=mod(int(nang*(360.0+alpha1)/180.0),2*nang)+1
	endif
	if(alpha2.ge.0.0)  then
	l2=mod(int(nang*alpha2/180.0),2*nang)+1
	else
	l2=mod(int(nang*(360.0+alpha2)/180.0),2*nang)+1
	endif
c
	END
c
	FUNCTION  EDL1(x1,x2,n)
	dimension  x1(n),x2(n)
	tdl1=0.0
	do  1  i=1,n
1	tdl1=tdl1+(x1(i)-x2(i))*(x1(i)-x2(i))
	edl1=tdl1
	end
	DOUBLE  PRECISION  FUNCTION  EDL1_(x1,x2,n)
	dimension  x1(n),x2(n)
	double precision  tdl1
	tdl1=0.0
	do  1  i=1,n
1	tdl1=tdl1+(x1(i)-x2(i))*dble(x1(i)-x2(i))
	edl1_=tdl1
	end
c
	DOUBLE  PRECISION  FUNCTION  EDL2(x1,x2,n)
	dimension  x1(n),x2(n)
	double precision  tdl2
	tdl2=0.0
	do  1  i=1,n,2
	tdl2=tdl2+(x1(i)-x2(i))*dble(x1(i)-x2(i))
1	tdl2=tdl2+(x1(i+1)-x2(i+1))*dble(x1(i+1)+x2(i+1))
	edl2=tdl2
	end
c
	DOUBLE  PRECISION  FUNCTION  EDL3(x1,x2,n)
	dimension  x1(n),x2(n)
	double precision  tdl3
	tdl3=0.0
	do  1  i=1,n,2
	tdl3=tdl3+(x1(i)-x2(i))*dble(x1(i)-x2(i))
1	tdl3=tdl3+(x1(i+1)-x2(i+1))*dble(x1(i+1)+x2(i+1))
	edl3=tdl3
	end
c
	DOUBLE  PRECISION  FUNCTION  ECL1(x1,x2,n)
	dimension  x1(n),x2(n)
	double precision  tcl1
	tcl1=1.0d0
	do  1  i=1,n
1	tcl1=tcl1-x1(i)*x2(i)
	ecl1=tcl1
	end
c
	DOUBLE  PRECISION  FUNCTION  ECL2(x1,x2,n)
	dimension  x1(n),x2(n)
	double precision  tcl2
	tcl2=1.0d0
	do  1  i=1,n
1	tcl2=tcl2-x1(n-i+1)*x2(i)
	ecl2=tcl2
	end
c
	DOUBLE  PRECISION  FUNCTION  ECL3(x1,x2,n)
	dimension  x1(n),x2(n)
	double precision  temp
	temp=1.0d0
	do  1  i=1,n
1	temp=temp-x1(i)*x2(n-i+1)
	ecl3=temp
	end
c
	SUBROUTINE  NRL(x,m)
	dimension   x(m)
	double precision  a,s
	a=0.0
	s=0.0
	a=sum(x)
	s=dot_product(x,x)
	a=a/m
	s=dsqrt(s-m*a*a)
	x=(x-a)/s
	end
c
d989 1
d991 1
d995 1
a995 1
        IF(L.GT.1)THEN
d1031 22
a1052 16
c
	SUBROUTINE  PREPANG(dm,nang)
	dimension   dm(2,nang)
	double precision  phi
	phi=4.0d0*datan(1.0d0)/nang
	do  i=1,nang
	 dm(1,i)=dcos(phi*(i-1))
	 dm(2,i)=dsin(phi*(i-1))
	enddo
c
c Use next two lines to get the same sinogram as in _RM 2D_
c
c	dm(1,i)=-dsin(phi*(i-1))
c1	dm(2,i)=dcos(phi*(i-1))
	end
C
d1054 1
d1057 1
a1057 1
C
d1059 1
a1059 1
C automatic arrays, projection is assumed to have odd length
d1061 1
d1064 1
a1064 1
        INTEGER    IR1,IR2
d1066 4
a1069 4
	LOGICAL  BREAK
C
	COMMON  /F_SPEC/  FINPAT,FINPIC,finfo,findoc,NLET
	CHARACTER*80    FINPAT,FINPIC,finfo,findoc
d1071 1
d1074 1
a1074 1
C
d1077 1
a1077 1
C  Calculate dimensions for NORMAS
d1082 1
a1082 1
C  Radius for NORMAS
d1085 1
a1085 1
C
d1087 2
a1088 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'OP, DM',IER)
d1090 2
a1091 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'OP, X',IER)
d1093 2
a1094 2
	IF(IRTFLG.NE.0) CALL  ERRT(46,'OP, PROJ',IER)
C
d1096 2
a1097 1
C First call just figures NN, ILIST here is a dummy argument
d1099 1
d1101 2
a1102 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'OP, IPCUBE',IER)
d1104 1
a1104 1
C
d1107 1
a1107 1
	CALL  SCFFT1DUI(lenproj,b2)
d1109 5
a1113 4
	DO  8  K=1,nima
C Read one IMAGE
	CALL  FILGET(FINPAT,FINPIC,NLET,ILIST(K),INTFLAG)
	MAXIM=0
d1116 5
a1120 7
	IF(NF.NE.0)  THEN
	CALL ERRT(18,'OP',NE)
	RETURN
	ENDIF
	do  J=1,N
	 CALL  REDLIN(INPIC,X(1,J),N,J)
	enddo
d1122 2
a1123 3
C
C  Normalize under the mask
C
d1125 2
a1126 1
C Calculate line projections
d1128 1
a1128 1
c--------------------------------------------------------------
d1130 13
a1142 10
c$omp parallel do private(j,b1,bt),shared(BREAK)
	do  1  j=1,nang
	 b1(1:lenproj)=proj(1:lenproj,j)
C Normalize the line
	 CALL  NRL(b1,lenproj)
C Mirror the lines
	 do  l=1,lenproj
	  bt(l)=b1(lenproj-l+1)
	 enddo
	 inv=+1
d1144 1
a1144 1
	 CALL  SCFFT1DU(inv,lenproj,b1,LDA,b2)
d1146 1
a1146 1
	 CALL FMR_1(b1,lenproj,b2,inv)
d1148 12
a1159 9
	 if(inv.ne.1)  then
	  BREAK=.TRUE.
	 else
	  do  l=LENB,LENB+LENF-1,2
	   prj(l-LENB+1,j,k)=b1(l)
           prj(l-LENB,j,k)=b1(l+1)
	  enddo
	 endif
	inv=+1
d1161 1
a1161 1
	CALL  SCFFT1DU(inv,lenproj,bt,LDA,b2)
d1163 1
a1163 1
	CALL FMR_1(bt,lenproj,b2,inv)
d1165 11
a1175 9
	 do  l=LENB,LENB+LENF-1,2
	  prj(l-LENB+1,j+nang,k)=bt(l)
	  prj(l-LENB,j+nang,k)=bt(l+1)
	 enddo
1	continue
	if(BREAK)  then
	 CALL ERRT(38,'OP',NE)
	 RETURN
	endif
d1182 8
a1189 6
C
	SUBROUTINE  PRJC2_P
     &  (square,N,DM,nang,proj,lenproj,IPCUBE,nn)
        DIMENSION DM(2,nang)
	DIMENSION  square(n,n),proj(lenproj,nang)
	INTEGER  IPCUBE(3,NN)
d1191 6
a1196 6
C
	proj=0.0
c$omp parallel do private(i)
	DO  I=1,nang
	CALL  PRJC11_P(square,N,DM(1,I),proj(1,i),lenproj,IPCUBE,NN)
	enddo
d1198 5
a1202 2
C
	SUBROUTINE  PRJC11_P(square,n,DM,proj,lenproj,IPCUBE,NN)
d1204 1
a1204 1
	DIMENSION  square(n,n),proj(lenproj)
d1207 1
d1209 7
a1215 7
	iy=ipcube(2,i)
	XB=(IPCUBE(1,I)-LDP)*DM(1)+(iy-LDP)*DM(2)
	DO  1  J=IPCUBE(1,I),IPCUBE(3,I)
	IQX=IFIX(XB+FLOAT(LDPNM))
	dipx=xb+ldpnm-iqx
	proj(iqx)=proj(iqx)+(1.0-dipx)*square(j,iy)
	proj(iqx+1)=proj(iqx+1)+dipx*square(j,iy)
d1218 3
a1220 1
C
d1222 1
d1226 6
a1231 6
C
C IPCUBE: 
C         1 - ix
C         2 - iy
c         3 - end of ix
C
d1233 1
a1233 1
C
d1235 1
a1235 1
C
d1240 17
a1256 17
	DO  20  I2=1,N
	T=I2-LDP
	RC=T*T+XX
	IF(FIRST)  THEN
	 IF(RC.GT.R)  GOTO 14
	 FIRST=.FALSE.
	 NN=NN+1
	 IF(FILL)  THEN
	  IPCUBE(1,NN)=I2
	  IPCUBE(2,NN)=I1
	  IPCUBE(3,NN)=I2
	 ENDIF
	ELSE
	 IF(FILL)  IPCUBE(3,NN)=I2
	 IF(RC.GT.R)  GOTO  16
	ENDIF
14	CONTINUE
d1271 2
a1272 2
c       angtab(1  - theta
c       angtab(2  - phi
d1276 2
a1277 2
	DO  THETA=0.,179.999,DPSI
           IF(THETA.EQ.0.0.OR.THETA.EQ.180.0)  THEN
d1285 5
a1289 5
C	   DO  1  PHI=P1,P2,DETPHI
           DO  I=1,LT
              PHI=P1+(I-1)*DETPHI
              NANGT=NANGT+1
	      IF(FILL)  THEN
d1306 1
a1306 1
 
@


1.18
log
@time --> mytime
@
text
@a0 1

d21 1
a21 1
C   07/29/99   Parallel, f90 version.
d602 12
a613 1
c$omp parallel do private(i,j,did),reduction(+:din)
d620 1
d624 11
d1075 1
a1075 1
c$omp parallel do private(j,b1,bt)
d1077 1
a1077 3
	do  l=1,lenproj
	 b1(l)=proj(l,j)
	enddo
d1079 1
a1079 1
	CALL  NRL(b1,lenproj)
d1081 4
a1084 4
	do  l=1,lenproj
	 bt(l)=b1(lenproj-l+1)
	enddo
	inv=+1
d1086 1
a1086 1
	CALL  SCFFT1DU(inv,lenproj,b1,LDA,b2)
d1088 1
a1088 1
	CALL FMR_1(b1,lenproj,b2,inv)
d1090 8
a1097 8
	if(inv.ne.1)  then
	 BREAK=.TRUE.
	else
	 do  l=LENB,LENB+LENF-1,2
	  prj(l-LENB+1,j,k)=b1(l)
          prj(l-LENB,j,k)=b1(l+1)
	 enddo
	endif
d1104 4
a1107 4
	do  l=LENB,LENB+LENF-1,2
	 prj(l-LENB+1,j+nang,k)=bt(l)
	 prj(l-LENB,j+nang,k)=bt(l+1)
	enddo
@


1.17
log
@for ibm
@
text
@d51 1
a51 1
	common  /pols/ modis
d60 4
a63 4
C  N - linear dimension of 2d image
C  NANG - number of angles
C  NIMA - number of 2D images
C
d76 1
a76 1
C  NANG - total number of angles
d81 1
d83 2
a84 2
	 CALL ERRT(14,'OP',IER)
	 RETURN
d86 3
a88 3
	IF(F1.EQ.0.0 .AND. F2.EQ.0.0)  THEN
	F1=0.0
	F2=0.5
d92 3
a94 3
	IF(NANG.EQ.0)  THEN
C DEFAULT 1 DEGREE ACCURACY FOR PSI
	 NANG=180
d96 1
a96 1
	 NANG=180/NANG
d98 1
a98 1
C DEFAULT 5 DEGREES ACCURACY FOR THETA
d101 1
a101 1
     &	'MAXIMUM NUMBER OF CYCLES')
d104 1
a104 1
C
d106 1
a106 1
C
d112 3
a114 3
	IF(MOD(N,2).EQ.0)  LENRPOJ=LENRPOJ-1
	WRITE(NOUT,*)  
     &	'Length of projection too large!  Limited to ',LENRPOJ
d116 2
a117 2
C
C  Always skip (0) term
d121 1
a121 1
C
d124 1
a124 1
C
d126 3
a128 3
	IF(IRTFLG.NE.0) CALL  ERRT(46,'OP, PRJ',IER)
C
	TM1=ETIME(TARRAY)
d130 1
a130 1
	TM2=ETIME(TARRAY)
d132 1
a132 1
C
d137 2
a138 1
	IF(IRTFLG.NE.0) RETURN
d140 2
a141 1
	IF(IRTFLG.NE.0) CALL  ERRT(46,'OP, P',IER)
d143 3
a145 3
	 DO  J=1,3
          P(J,I)=IPQ(J+1,I)
	 ENDDO
d147 1
a147 1
C IPQ no longer needed
d149 1
a149 1
C
d153 1
d155 1
a155 1
C
d159 5
a163 4
C
	SUBROUTINE  FCANG(NANG,NIMA,lenproj,MAXIT,
     &		P,prj,nangt,IDPSI)
c
d174 3
a176 3
c   new tables.
c angtab(1  - theta
c angtab(2  - phi
d178 1
a178 1
c  set first three angles to zero forever ...
d185 1
d193 1
a193 1
c  try to spin
d199 1
a199 1
	 WRITE(NOUT,2179)  i,(p(j,i),j=1,3)
d202 1
a202 1
	CALL  TIME(CTIME)
d204 30
a233 28
777	format(' Entered spin : ',a8)
	do  ISPIN=1,NIMA
c	CALL  SPINSPIN
c     &	(nima,nang,lenproj,prj,p,
c     &		ispin,IDPSI,angtab,nangt,ipsim,iangmin,change,
c     &		l1,l2,lt,lt1,lt2,lord,w)
	 CALL  SPIN
     &	       (nima,nang,lenproj,prj,p,
     &		ispin,IDPSI,angtab,nangt,ipsim,iangmin,change)
	 if(change)  then
	  changepos=.true.
	  p(1,ispin)=ipsim
	  p(2,ispin)=angtab(1,iangmin)
	  p(3,ispin)=angtab(2,iangmin)
	 endif
	enddo
	IF(changepos)  THEN
	 fvalue=DIST(NIMA,nang,lenproj,prj,p)
	 WRITE(NOUT,2181)  ITER,FVALUE
2181	 FORMAT(1X,'Cycle',I9,'  New value=',1PE10.3)
	 DLIST(1)=-1
	 DLIST(2)=ITER
	 DLIST(3)=FVALUE
	 CALL  SAVD(NDOC,DLIST,3,IRTFLG)
	 DO  I=1,NIMA
	  DLIST(1)=I
	   DO  J=1,3
	    DLIST(J+1)=P(J,I)
a234 2
	  CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
	 ENDDO
d236 1
a236 1
	if(changepos.AND.(MAXIT.EQ.0.OR.ITER.LT.MAXIT))  GOTO  507
d241 3
a243 1
C	
d247 1
d254 1
a254 1
C  length of arrays needed in dwtg
d256 1
a256 1
c  Spin
d259 1
a259 1
	 call  dwtg(p,angtab(1,l),prj,ispin,nima,nang,lenproj,
d276 1
a276 1
c  check whether position changed
d289 2
a290 1
C
d299 1
a299 1
c
d307 1
a307 1
c
d309 1
a309 1
c
d311 1
a311 1
c
d315 1
a315 1
c
d326 1
a326 1
c
d717 1
a717 1
c
d719 1
a719 1
c
d721 1
a721 1
c
d723 1
a723 1
c
d741 1
a741 1
	stop
d745 3
a747 1
c
d749 1
a749 1
c
d1168 1
a1168 1
C  
d1170 2
a1171 1
C
d1173 1
d1178 3
a1180 2
c angtab(1  - theta
c angtab(2  - phi
d1185 18
a1202 18
	 IF(THETA.EQ.0.0.OR.THETA.EQ.180.0)  THEN
	  DETPHI=360.0
	  LT=1
	 ELSE
	  DETPHI=DPSI/SIN(DGR_TO_RAD*THETA)
	  LT=MAX0(INT((P2-P1)/DETPHI)-1,1)
	  DETPHI=(P2-P1)/LT
	 ENDIF
C	DO  1  PHI=P1,P2,DETPHI
          DO  I=1,LT
           PHI=P1+(I-1)*DETPHI
	   NANGT=NANGT+1
	   IF(FILL)  THEN
	    ANGTAB(1,NANGT)=THETA
	    ANGTAB(2,NANGT)=PHI
	   ENDIF
	  ENDDO
	ENDDO
@


1.16
log
@for ibm
@
text
@d1198 1
a1198 1
        ETIME = ICOUNT / IPSEC
@


1.15
log
@line length exceeded
@
text
@d1189 16
@


1.14
log
@header
@
text
@d389 2
a390 1
	if(l1(k).eq.91.or.l1(k).eq.271.or.l2(k).eq.91.or.l2(k).eq.271) then
d534 2
a535 1
	if(l1(k).eq.91.or.l1(k).eq.271.or.l2(k).eq.91.or.l2(k).eq.271) then
d612 2
a613 1
	dimension  prj1(lenproj,2*nang),fi1(3),prj2(lenproj,2*nang),fi2(3)
@


1.13
log
@getdocdat changed
@
text
@d1 20
a20 1
C++************************************************************************
d39 2
d42 1
d56 1
a56 1
C
d59 1
a59 1
C
d75 1
a75 1
C
d77 1
a77 1
C
d79 2
a80 2
     &	'Length of line projection')
	CALL RDPRM2(F1,F2,NLOOP,ILOOP,'Minimum, Maximum frequency')
d90 1
a90 1
     &	'Accuracy of psi and theta')
d92 1
a92 1
C Default 1 degree accuracy for psi
d97 1
a97 1
C Default 5 degrees accuracy for theta
d100 1
a100 1
     &	'Maximum number of cycles')
d103 2
a104 2
c
	modis='E'
d123 3
a125 3
c
	ALLOCATE(prj(lenproj,2*nang,nima),STAT=IRTFLG)
	IF(IRTFLG.NE.0) CALL  ERRT(46,'OP, prj',IER)
d134 1
a134 1
	CALL  GETDOCDAT('Document with initial angles',.TRUE.,FINDOC,
@


1.12
log
@*** empty log message ***
@
text
@d33 1
a33 2
	REAL,  DIMENSION(:), POINTER ::  IPQ
	integer shape
a116 1
	K=0
a117 1
	K=K+1
d119 1
a119 2
	  K=K+1
          P(J,I)=IPQ(K)
@


1.11
log
@Parallel, f90 version.
@
text
@d599 1
a599 1
	DOUBLE PRECISION  QUADPI,RAD_TO_DGR,RAD_TO_DGR
d728 1
a728 1
	DOUBLE PRECISION  QUADPI,RAD_TO_DGR,RAD_TO_DGR
@


1.10
log
@trigonometry fixed
@
text
@d2 3
d22 2
a23 1
        INCLUDE 'CMBLOCK.INC' 
d27 1
a27 1
	COMMON  DUMMY(80),BUF(1024),ILIST(NILMAX),Q(1)
a29 2
	common  /pointers/  
     &	nima,nang,lenproj,k_prj,k_dis,k_fi,k_p,k_g,k_s
d31 4
d46 6
a51 4
 	CALL  OPENFB(BUF,FINPIC,INPIC,N,NROW,'O',NF,NSL)
 	IF(NF.NE.2)  THEN
	CALL ERRT(18,'OP',NE)
	RETURN
d57 11
a67 2
	CALL  RDPRMI(LENPROJ,LENF,NLOOP,ILOOP,
     &	'Length of projection, number of Fourier coeffs.')
d72 1
a72 1
	NANG=180
d74 1
a74 1
	NANG=180/NANG
d81 1
a81 2
	LENF=LENF*2
	CALL  GENAT(Q(1),DPSI,NANGT)
d84 1
a84 1
	nc=1
d95 4
a98 6
	IF(LENF.GT.LENPROJ-1)  THEN
	LENF=LENPROJ-1
	WRITE(NOUT,*)    
     &	'Number of Fourier coeffs. too large!  Limited to ',LENF/2
	ENDIF

a101 9
C
 	K_DM=1
	K_IPCUBE=IPALIGN64(K_DM+2*NANG+NANG)
C
	CALL  PREPANG(q(k_dm),nang)
c
	CALL  PSQU_P(N,NN,Q(K_IPCUBE),RI)
C
	K_PROJ=IPALIGN64(K_IPCUBE+4*NN)
d103 2
a104 30
	k_prj=IPALIGN64(K_proj+nang*lenproj)
	k_dis=IPALIGN64(k_prj+lenf*2*nang*nima)
	k_fi=IPALIGN64(k_dis+2*nima)
	k_p=IPALIGN64(K_fi+3*nima)
	k_b1=IPALIGN64(k_p+3*NIMA)
c lenproj increased for libfft
	k_b2=IPALIGN64(k_b1+lenproj+1)
	k_bt=IPALIGN64(k_b2+lenproj+15)
	k_angtab=IPALIGN64(k_bt+lenproj+1)
	k_l1=IPALIGN64(k_angtab+2*nangt)
	K_X=K_angtab
		lenl=nima*(nima-1)/2
	k_l2=IPALIGN64(k_l1+lenl)
	k_lt=IPALIGN64(k_l2+lenl)
	k_lt1=IPALIGN64(k_lt+lenl)
	k_lt2=IPALIGN64(k_lt1+lenl)
	k_lord=IPALIGN64(k_lt2+lenl)
	k_w=IPALIGN64(k_lord+lenl)
	MEMTOT=max(IPALIGN64(k_w+lenl),IPALIGN64(k_x+n*n))
	WRITE(NOUT,1001)  MEMTOT
	IF(MEMTOT.GT.MAXMEM)  THEN
	CALL ERRT(6,'OP',NE)
1001	FORMAT
     1  (//'           Calculation of angles',/,
     2     '           Memory needed - ',I8,/)
	WRITE(NOUT,1002)  MAXMEM
1002	FORMAT('  Sorry, your buffer length is only',I9,/,
     1      '  Program cannot be run')
	RETURN
	ENDIF
d107 1
a107 3
	CALL  RDL_P(N,NANG,Q(K_X),Q(K_PROJ),LENPROJ,
     1		Q(K_IPCUBE),NN,Q(K_DM),RI,
     2		ILIST,NIMA,BUF,q(k_b1),q(k_b2),q(k_bt),q(k_prj),LENF)
a110 6
	NULL = CHAR(0)
	NA = 80
	CALL FILERD(FINDOC,NA,NULL,
     &      'Document with initial angles', IRTFLG)
	ICALL=0
	IKEY=1
d113 12
a124 6
	CALL FILCAN(FINFO,NLET,NULL,NULL,FINDOC,DATEXC,IER)
	CALL UNSDAL(FINFO,ICALL,INDOC,IKEY,Q(K_P),3,
     &	            BUF,MAXKEY,MAXREG,NKEY,LERR)
	DO  I=1,NIMA
	DO  J=1,3
	Q(K_P-1+J+(I-1)*3)=BUF(J+1+(I-1)*4)
d126 3
a128 2
	ENDDO
c
d130 1
a130 3
	CALL  FCANG(NANG,NIMA,LENF,MAXIT,
     &	Q(K_p),Q(K_prj),Q(K_dis),Q(K_angtab),NANGT,IDPSI,
     &	Q(K_l1),Q(K_l2),Q(K_lt),Q(K_lt1),Q(K_lt2),Q(K_lord),Q(K_w))
d134 2
a135 4
c         CALL  FILERD(FINFO,NLET1,NULL,
c     &   'Document with resulting angles',IRTFLG)
c	FInfo=FInfo(1:NLET1)//'.'//datexc(1:3)
C
d138 2
a139 3
	SUBROUTINE  FCANG(nang,nima,lenproj,MAXIT,
     &		p,prj,dis,angtab,nangt,IDPSI,
     &		l1,l2,lt,lt1,lt2,lord,w)
d145 1
a145 3
	DIMENSION  angtab(2,nangt)
	DIMENSION  l1(*),l2(*),lt(*),lt1(*),lt2(*),lord(*)
	DIMENSION  w(*)
d160 2
d163 2
a164 2
	CALL  GENAT(ANGTAB,DPSI,NANGT)
	fvalue=DIST(NIMA,nang,lenproj,prj,dis,p)
d174 3
a176 2
	do  711  i=1,NIMA
711	WRITE(NOUT,2179)  i,(p(j,i),j=1,3)
d181 30
a210 25
	do  50 ISPIN=1,NIMA
	CALL  SPIN
     &	(nima,nang,lenproj,prj,p,
     &		ispin,IDPSI,angtab,nangt,ipsim,iangmin,change,
     &		l1,l2,lt,lt1,lt2,lord,w)
	if(change)  then
	changepos=.true.
	p(1,ispin)=ipsim
	p(2,ispin)=angtab(1,iangmin)
	p(3,ispin)=angtab(2,iangmin)
	endif
50	continue
	if(changepos)  THEN
	fvalue=DIST(NIMA,nang,lenproj,prj,dis,p)
	WRITE(NOUT,2181)  ITER,FVALUE
2181	FORMAT(1X,'Cycle',I9,'  New value=',1PE10.3)
	DLIST(1)=-1
	DLIST(2)=ITER
	DLIST(3)=FVALUE
	CALL  SAVD(NDOC,DLIST,3,IRTFLG)
	do  71  I=1,NIMA
	DLIST(1)=I
	DO  72  J=1,3
72	DLIST(J+1)=P(J,I)
71	CALL  SAVD(NDOC,DLIST,NDLI,IRTFLG)
d215 1
d218 1
a218 1
	SUBROUTINE  SPINSPIN
d220 1
a220 2
     &		ispin,IDPSI,angtab,nangt,mmin,lmin,change,
     &		l1,l2,lt,lt1,lt2,lord,w)
d223 2
a224 2
	double precision dmi(10000),dmin
	dimension  lmi(10000),mmi(10000)
d227 2
a228 1
	print  *,' SPINSPIN'
d230 4
a233 5
cc$omp parallel do private(i)
	do  1  l=1,nangt
	do    i=1,nima
	if(i.ne.ispin.and.
     &	p(2,i).eq.angtab(1,l).and.p(3,i).eq.angtab(2,l)) goto 1
d235 1
a235 4
	call  dwtg(p,angtab(1,l),prj,ispin,nima,nang,lenproj,
     &		IDPSI,dmi(i),lmi(i),mmi(i))
1	continue
	dmin=1.0d23
d238 10
a247 10
	do  2  l=1,nangt
	do    i=1,nima
	if(i.ne.ispin.and.
     &	p(2,i).eq.angtab(1,l).and.p(3,i).eq.angtab(2,l)) goto 2
	enddo
	if(dmi(i).lt.dmin)  then
	dmin=dmi(i)
	lmin=lmi(i)
	mmin=mmi(i)
	endif
d253 6
a258 6
	if(p(2,ispin).eq.angtab(1,lmin))  then
	if(p(3,ispin).eq.angtab(2,lmin))  then
	change=.false.
	return
	endif
	endif
d263 2
a264 4
	subroutine  dwtg(pp,angtab,prj,ispin,nima,nang,lenproj,IDPSI,
     &		dmin,lmin,mmin)
	dimension  l1(1000),l2(1000),lt(1000),lt1(1000),lt2(1000),lord(1000)
	dimension  w(1000),p(3,100)
d266 4
d272 6
a277 4
	do  j=1,nima
	do  i=1,3
	p(i,j)=pp(i,j)
	enddo
d280 1
a280 3
	dmin=1.0e23
	lmin=-1
	mmin=-1
d289 9
a297 8
	do  14  i=1,nima-1
	do  14  j=i+1,nima
	if(i.eq.ispin.or.j.eq.ispin) then
	k=k+1
	lord(k)=k
	CALL  CALDILW1(p(1,i),p(1,j),nang,l1(k),l2(k))
	endif
14	continue
d300 13
a312 12
	do  101  i=1,nima-1
	do  101  j=i+1,nima
	if(i.eq.ispin) then
	k=k+1
	lt(k)=l1(k)
	if(lt(k).gt.nang)  lt(k)=lt(k)-nang
	elseif(j.eq.ispin)  then
	k=k+1
	lt(k)=l2(k)
	if(lt(k).gt.nang)  lt(k)=lt(k)-nang
	endif
101	continue
d318 10
a327 9
	do  102  k=2,nim-1
	if(lt(k).ne.lt(k-1))  then
	w(lord(k))=float(lt(k+1)-lt(k-1))/2
	qt=1.0
	else
	qt=qt+1.0
	w(lord(k))=-qt
	endif
102	continue
d329 1
a329 1
	w(lord(nim))=float(lt(1)+nang-lt(nim-1))/2
d331 2
a332 2
	qt=qt+1
	w(lord(nim))=-qt
d343 1
a343 1
        if(k.ne.nim) goto 106
d345 1
a345 1
	k=k-1
d347 4
a350 3
	w(lord(kb))=-w(lord(kb))/w(lord(k))
	do  107  kk=kb+1,k
107	w(lord(kk))=w(lord(kb))
d353 1
a353 1
c	
d355 6
a360 5
	do  103  k=1,nim
103	wt=wt+w(k)
	do  104  k=1,nim
104	w(k)=w(k)/wt
cendif
d362 1
a362 1
	do  2  m=0,359,IDPSI
d367 4
a370 4
	do  141  i=1,nima-1
	do  141  j=i+1,nima
	if(i.eq.ispin.or.j.eq.ispin) then
	k=k+1
d372 1
a372 5
	CALL  CALDILW1(p(1,i),p(1,j),nang,lt1(k),lt2(k))
	else
	if(i.eq.ispin)  then
	lt1(k)=mod(l1(k)-m+360-1,360)+1
	lt2(k)=l2(k)
d374 7
a380 2
	lt1(k)=l1(k)
	lt2(k)=mod(l2(k)-m+360-1,360)+1
d382 3
a384 3
	endif
	endif
141	continue
d389 8
a396 8
	do  15  i=1,nima-1
	do  15  j=i+1,nima
	if(i.eq.ispin.or.j.eq.ispin) then
	k=k+1
	did=EDL1(prj(1,lt1(k),i),prj(1,lt2(k),j),lenproj)
	dist=dist+did*w(k)
	endif
15	continue
d399 3
a401 5
	dmin=dist
C  l is not defined???
				l=-100
	lmin=l
	mmin=m
d403 2
a404 1
2	continue
d407 1
a407 1
	SUBROUTINE  SPIN
d499 6
a504 5
	do  103  k=1,nim
103	wt=wt+w(k)
	do  104  k=1,nim
104	w(k)=w(k)/wt
cendif
d511 4
a514 4
	do  141  i=1,nima-1
	do  141  j=i+1,nima
	if(i.eq.ispin.or.j.eq.ispin) then
	k=k+1
d516 1
a516 1
	CALL  CALDILW1(p(1,i),p(1,j),nang,lt1(k),lt2(k))
d518 7
a524 6
	if(i.eq.ispin)  then
	lt1(k)=mod(l1(k)-m+360-1,360)+1
	lt2(k)=l2(k)
	else
	lt1(k)=l1(k)
	lt2(k)=mod(l2(k)-m+360-1,360)+1
d526 3
a528 3
	endif
	endif
141	continue
d533 9
a541 8
	do  15  i=1,nima-1
	do  15  j=i+1,nima
	if(i.eq.ispin.or.j.eq.ispin) then
	k=k+1
	did=EDL1(prj(1,lt1(k),i),prj(1,lt2(k),j),lenproj)
	dist=dist+did*w(k)
	endif
15	continue
d544 3
a546 3
	dmin=dist
	lmin=l
	mmin=m
d557 6
a562 6
	if(p(2,ispin).eq.angtab(1,lmin))  then
	if(p(3,ispin).eq.angtab(2,lmin))  then
	change=.false.
	return
	endif
	endif
d568 3
a570 3
     &	(nima,nang,lenproj,prj,dis,p)
	DIMENSION  P(3,nima),prj(lenproj,2*nang,nima),ptmp(3)
	double precision  din,din1,din2,did,dis(nima),gd(2,3)
d573 8
a580 6
cc$omp parallel do private(i,j,did),reduction(+:din)
	do  15  i=1,nima-1
	do  15  j=i+1,nima
	CALL  CALDIL
     &	(prj(1,1,i),p(1,i),prj(1,1,j),p(1,j),lenproj,nang,did)
15	din=din+did
d886 2
a887 3
	do  1  i=1,m
	a=a+x(i)
1	s=s+x(i)*x(i)
d890 1
a890 2
	do  2  i=1,m
2	x(i)=(x(i)-a)/s
d939 4
a942 3
	do  1  i=1,nang
	dm(1,i)=dcos(phi*(i-1))
1	dm(2,i)=dsin(phi*(i-1))
d950 1
a950 3
	SUBROUTINE  RDL_P(N,NANG,X,PROJ,LENPROJ,
     &			IPCUBE,NN,DM,RI,ILIST,NIMA,BUF,
     &			B1,B2,BT,PRJ,LENF)
a951 3
	DIMENSION X(N,N),PROJ(LENPROJ,NANG)
	DIMENSION  IPCUBE(3,NN),DM(2,NANG)
	DIMENSION  B1(LENPROJ+1),B2(LENPROJ+15),BT(LENPROJ+1)
d954 5
a958 1
	DIMENSION  ILIST(NIMA),BUF(1024)
d961 1
d980 14
d1001 4
a1004 2
	CALL  OPENFB(BUF,FINPIC,INPIC,LSAM,LROW,'O',NF,NSL)
	IF(NF.NE.2)  THEN
d1008 3
a1010 2
	do  88  J=1,N
88 	CALL  REDLIN(INPIC,X(1,J),N,J)
d1016 1
a1016 1
C
d1019 2
d1022 9
a1030 5
	do  21  l=1,lenproj
21	b1(l)=proj(l,j)
	call  nrl(b1,lenproj)
	do  7  l=1,lenproj
7	bt(l)=b1(lenproj-l+1)
d1038 1
a1038 2
	CALL ERRT(38,'OP',NE)
	STOP
d1040 4
a1043 3
	do  11  l=1,lenf,2
	prj(l,j,k)=b1(l+2)
11	prj(l+1,j,k)=b1(l+3)
d1051 4
a1054 3
	do  12  l=1,lenf,2
	prj(l,j+nang,k)=bt(l+2)
12	prj(l+1,j+nang,k)=bt(l+3)
d1056 4
d1061 4
d1074 5
a1078 4
	DO  1  I=1,nang
	DO  5  j=1,lenproj
5	proj(j,i)=0.0
1	CALL  PRJC11_P(square,N,DM(1,I),proj(1,i),lenproj,IPCUBE,NN)
d1097 1
a1097 1
	SUBROUTINE  PSQU_P(N,NN,IPCUBE,RI)
d1099 1
a1099 1
	LOGICAL  FIRST
d1119 8
a1126 6
	IF(RC-R)  80  ,80,14
80	FIRST=.FALSE.
	NN=NN+1
	IPCUBE(1,NN)=I2
	IPCUBE(2,NN)=I1
	IPCUBE(3,NN)=I2
d1128 2
a1129 2
	IPCUBE(3,NN)=I2
	IF(RC.GT.R)  GOTO  16
d1138 1
a1138 1
	SUBROUTINE  GENAT(ANGTAB,DPSI,NANGT)
d1140 1
d1148 9
a1156 9
	DO  1  THETA=0.,179.999,DPSI
	IF(THETA.EQ.0.0.OR.THETA.EQ.180.0)  THEN
	DETPHI=360.0
	LT=1
	ELSE
	DETPHI=DPSI/SIN(DGR_TO_RAD*THETA)
	LT=MAX0(INT((P2-P1)/DETPHI)-1,1)
	DETPHI=(P2-P1)/LT
	ENDIF
d1158 9
a1166 6
        DO  1  I=1,LT
        PHI=P1+(I-1)*DETPHI
	NANGT=NANGT+1
	ANGTAB(1,NANGT)=THETA
	ANGTAB(2,NANGT)=PHI
1	CONTINUE
@


1.9
log
@doc file logical unit number fixed
@
text
@d613 1
a613 1
	DOUBLE PRECISION  QUADPI,DGR_TO_RAD,RAD_TO_DGR
d615 1
a615 1
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
d638 1
a638 1
         PHI=DGR_TO_RAD*DASIN(R3(1,2))
d640 1
a640 1
         PHI=DGR_TO_RAD*DATAN2(R3(1,2),R3(1,1))
d646 1
a646 1
         PHI=DGR_TO_RAD*DASIN(-R3(1,2))
d648 1
a648 1
         PHI=DGR_TO_RAD*DATAN2(-R3(1,2),-R3(1,1))
d651 1
a651 1
         THETA=DGR_TO_RAD*DACOS(R3(3,3))
d660 1
a660 1
         PHI=DGR_TO_RAD*DATAN2(R3(3,2)*ST,R3(3,1)*ST)
d669 1
a669 1
         PSI=DGR_TO_RAD*DATAN2(R3(2,3)*ST,-R3(1,3)*ST)
d742 1
a742 1
	DOUBLE PRECISION  QUADPI,DGR_TO_RAD,RAD_TO_DGR
d744 1
a744 1
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
d767 1
a767 1
         PHI=DGR_TO_RAD*DASIN(R3(1,2))
d769 1
a769 1
         PHI=DGR_TO_RAD*DATAN2(R3(1,2),R3(1,1))
d775 1
a775 1
         PHI=DGR_TO_RAD*DASIN(-R3(1,2))
d777 1
a777 1
         PHI=DGR_TO_RAD*DATAN2(-R3(1,2),-R3(1,1))
d780 1
a780 1
         THETA=DGR_TO_RAD*DACOS(R3(3,3))
d789 1
a789 1
         PHI=DGR_TO_RAD*DATAN2(R3(3,2)*ST,R3(3,1)*ST)
d798 1
a798 1
         PSI=DGR_TO_RAD*DATAN2(R3(2,3)*ST,-R3(1,3)*ST)
d1121 1
a1121 1
	PARAMETER (DGR_TO_RAD = (QUADPI/180))
@


1.8
log
@OpenMP
@
text
@d30 1
a30 1
	DATA  INPIC/99/
d146 1
a146 1
     &	BUF,MAXKEY,MAXREG,NKEY,LERR)
@


1.7
log
@*** empty log message ***
@
text
@d252 1
a252 1
cc$doacross local(i)
d589 1
a589 1
cc$doacross local(i,j,did),reduction(din)
@


1.6
log
@*** empty log message ***
@
text
@a419 1
				m=-100
@


1.5
log
@*** empty log message ***
@
text
@d419 2
@


1.4
log
@ff
@
text
@d418 1
@


1.3
log
@trig
@
text
@a30 1
CNO_SAVE
d973 1
a973 1
        INTEGER*2  IR1,IR2
@


1.2
log
@*** empty log message ***
@
text
@d2 2
d612 4
a615 5
#ifdef SP_F90
        DOUBLE PRECISION  DCOSD,DSIND,DATAN2D,DASIND,DACOSD
#endif
c	data  deps/1.0d-7/
	deps=1.0d-7
d637 1
a637 1
         PHI=DASIND(R3(1,2))
d639 1
a639 1
         PHI=DATAN2D(R3(1,2),R3(1,1))
d645 1
a645 1
         PHI=DASIND(-R3(1,2))
d647 1
a647 1
         PHI=DATAN2D(-R3(1,2),-R3(1,1))
d650 1
a650 1
         THETA=DACOSD(R3(3,3))
d659 1
a659 1
         PHI=DATAN2D(R3(3,2)*ST,R3(3,1)*ST)
d668 1
a668 1
         PSI=DATAN2D(R3(2,3)*ST,-R3(1,3)*ST)
d741 4
a744 8
c#ifdef SP_MP
c	deps=1.0d-7
c#else
	data  deps/1.0d-7/
c#endif
#ifdef SP_F90
        DOUBLE PRECISION  DCOSD,DSIND,DATAN2D,DASIND,DACOSD
#endif
d766 1
a766 1
         PHI=DASIND(R3(1,2))
d768 1
a768 1
         PHI=DATAN2D(R3(1,2),R3(1,1))
d774 1
a774 1
         PHI=DASIND(-R3(1,2))
d776 1
a776 1
         PHI=DATAN2D(-R3(1,2),-R3(1,1))
d779 1
a779 1
         THETA=DACOSD(R3(3,3))
d788 1
a788 1
         PHI=DATAN2D(R3(3,2)*ST,R3(3,1)*ST)
d797 1
a797 1
         PSI=DATAN2D(R3(2,3)*ST,-R3(1,3)*ST)
d1119 2
d1131 1
a1131 1
	DETPHI=DPSI/SIND(THETA)
@


1.1
log
@Initial revision
@
text
@d564 1
a564 1
	p(1,ispin)=ptmp(1)	
d610 3
d745 3
@
