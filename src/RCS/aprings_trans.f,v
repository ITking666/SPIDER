head	1.6;
access;
symbols
	pre_mrcs:1.6
	healthdept_2018:1.6
	pre_getangas:1.5;
locks; strict;
comment	@c @;


1.6
date	2018.10.03.14.33.55;	author leith;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.14.14.18.01;	author leith;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.13.18.44.49;	author leith;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.29.18.12.20;	author leith;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.29.17.44.24;	author leith;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.24.15.00.27;	author leith;	state Exp;
branches;
next	;


desc
@creates transformed rings using coeff
@


1.6
log
@email_health_dept
@
text
@
C++*********************************************************************
C
C APRINGS_TRANS     ADAPTED FOR TRANS             JUN 10 ARDEAN LEITH
C **********************************************************************
C=* This file is part of:   SPIDER - Modular Image Processing System.  *
C=* Authors: J. Frank & A. Leith                                        *
C=* Copyright 1985-2010  Health Research Inc.                          *
C=* Riverview Center, 150 Broadway, Suite 560, Menands, NY 12204.      *
C=* Email: spider@@health.ny.gov                                        *
C=*                                                                    *
C=* SPIDER is free software; you can redistribute it and/or            *
C=* modify it under the terms of the GNU General Public License as     *
C=* published by the Free Software Foundation; either version 2 of the *
C=* License, or (at your option) any later version.                    *
C=*                                                                    *
C=* SPIDER is distributed in the hope that it will be useful,          *
C=* but WITHOUT ANY WARRANTY; without even the implied warranty of     *
C=* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU  *
C=* General Public License for more details.                           *
C=*                                                                    *
C=* You should have received a copy of the GNU General Public License  *
C=* along with this program. If not, see <http://www.gnu.org/licenses> *
C=*                                                                    *
C **********************************************************************
C
C  APRINGS_TRANS_REFORM
C
C  PURPOSE: CONVERTS RING ORDER 'RINGS' ARRAY TO A RAY ORDER ARRAY
C
C  PARAMETERS: 
C23456789012345678901234567890123456789012345678901234567890123456789012
C--*********************************************************************

cpgi$g opt=O3

      SUBROUTINE APRINGS_TRANS_REFORM(NUMR,NRING,  NLOCS,NRAYSC,
     &                                COLD,LCIRCOD2, CNEW,LCIRCND2, WR)

      IMPLICIT NONE

      INCLUDE 'CMBLOCK.INC'

      INTEGER, INTENT(IN)      :: NUMR(3,NRING)
      INTEGER, INTENT(IN)      :: NRING
      INTEGER, INTENT(IN)      :: NLOCS(2,NRAYSC+1)
      INTEGER, INTENT(IN)      :: NRAYSC  
      INTEGER, INTENT(IN)      :: LCIRCOD2,LCIRCND2
      COMPLEX, INTENT(IN)      :: COLD(LCIRCOD2)
      COMPLEX, INTENT(OUT)     :: CNEW(LCIRCND2)
      REAL,    INTENT(IN)      :: WR(NRING)

      INTEGER                  :: MAXRIN,J,IRING,NR,IRAY,IT,ILOC,I
      LOGICAL                  :: WEIGHT
      REAL                     :: WRT

      WEIGHT = (WR(1) .NE. 0)            ! WEIGHTING FLAG
      MAXRIN = NUMR(3,NRING)/2           ! # CMPLX RAYS ON LONGEST RING
      J      = 0                         ! ZERO COLD INDEX
      DO IRING = 1,NRING                 ! LOOP OVER ALL RINGS

         NR  = NUMR(3,IRING) / 2         ! # CMPLX RAYS ON THIS RING
         WRT = WR(IRING)                 ! WEIGHT FOR THIS RING

         DO IRAY = 1,NR                  ! LOOP OVER RAYS ON RING
            J   = J + 1                  ! COLD INDEX

            IT  = IRING - (NRING - NLOCS(1,IRAY))

C           NLOCS IS INDEXED FOR COMPLEX NUMBER PAIRS
            ILOC = NLOCS(2,IRAY)+IT-1        ! CNEW INDEX

            IF (.NOT. WEIGHT) THEN
               CNEW(ILOC) = COLD(J)          ! MOVE
            ELSE
               CNEW(ILOC) = COLD(J)  * WRT   ! MOVE & WEIGHT
            ENDIF

            !if(iray == 1 )write(6,90)nr,it, j,iloc, cold(j) 
            !if(iring == 1 .and. iray == 1)write(6,90)nr,it,j,iloc,cold(j)
90          format(i5,i6,i6,' -->',i6,' (',f10.2,',',f10.2,')')

         ENDDO   ! END OF: DO IRAY  = 1,NR

         IF (WEIGHT .AND. NR .NE. MAXRIN) THEN
C           IF RING LENGTH IS LESS THAN THE MAX. RING LENGTH THEN
C           WEIGHT OF FINAL FFT COEF FOR THIS RING IS HALF USUAL WEIGHT.
C           WHY? al
            !write(6,*) ' wr:',nr,maxrin,j,iloc
            CNEW(ILOC) = CNEW(ILOC) * 0.5 
         ENDIF

       ENDDO     ! END OF: DO IRING = 1, NRING

       END

C     --------------------- APRINGS_TRANS_LOCS ------------------------

      SUBROUTINE APRINGS_TRANS_LOCS(NUMR,NRING, NLOCS,NRAYSC)

      IMPLICIT NONE

      INTEGER, INTENT(IN )     :: NRING,NRAYSC
      INTEGER, INTENT(IN)      :: NUMR(3,NRING)
      INTEGER, INTENT(OUT)     :: NLOCS(2,NRAYSC+1)

      INTEGER                  :: ILOC,IRING,NVT,IRAY

      NVT   = 0                        ! NUMBER OF VALUES TO CC
      NLOCS = 0                        ! ZERO WHOLE NLOC ARRAY

C     FIND NUMBER OF RINGS ON EACH RAY (1...NRAYSC)
      DO ILOC = 1,NRAYSC               ! LOOP OVER RAYS
         DO IRING = 1,NRING            ! LOOP OVER RINGS
            IF (ILOC .LE. (NUMR(3,IRING) / 2))
     &         NLOCS(1,ILOC) = NLOCS(1,ILOC)+1
         ENDDO
         !write(6,'i4,": ",i5,i6') iloc,nloc(iloc,1)
         NVT = NVT + NLOCS(1,ILOC)
      ENDDO

      !WRITE(6,97)'NUMBER OF RINGS:',MAXVAL(NLOCS(1,:))
      !WRITE(6,97)'NUMBER OF RING POINTS:',NVT
 97   FORMAT('  ',A,T30,I10)

C     FIND STARTING LOCATION OF EACH RAY (1...MAXRAY) AND FINAL RAY LEN.
      ILOC = 1 

      DO IRAY = 1,NRAYSC
         !IM = MOD(ILOC-1,2)
         !IF (IM == 0) THEN
         !NLOCS(2,IRAY) = ILOC
         !ELSE
         !IPAD = 2 - IM
         !NLOCS(2,IRAY) = ILOC + IPAD
         !ENDIF

         NLOCS(2,IRAY) = ILOC
         ILOC          = ILOC + NLOCS(1,IRAY) ! NEXT RAY START INDEX
      ENDDO
      NLOCS(2,NRAYSC+1  )= ILOC               ! TO FIND LENGTH OF LAST RA

      !write (6,*)'  nlocs(1,:) -- (# of rings on ray) --nraysc:',nraysc
      !write(6,*) nlocs(1,:)
      !write (6,97) '-------------------------'
      !write (6,*) '  nlocs(2,:) -- (starting index) ---------'
      !write(6,*) nlocs(2,:)
      !write (6,97) '-------------------------'

      END


C     --------------------- APRINGS_TRANS_ONE ------------------------

C       PURPOSE: USED FOR TRANSFORMED DATA WITHOUT COEF
C                USED WHEN ONLY ONE USAGE OF COEF WOULD BE INEFFICIENT

        SUBROUTINE APRINGS_TRANS_ONE(XIM,  NSAM,NROW, CNS2,CNR2, 
     &                       NUMR,NRING,   NLOCS,NRAYSC,
     &                       MODE,USE_OMP, WR, FFTW_PLANS,
     &                       CIRC,LCIRC,   CIRCN,LCIRCC)

        IMPLICIT  NONE

        REAL,        INTENT(IN)      :: XIM(NSAM,NROW)
        INTEGER,     INTENT(IN)      :: NSAM,NROW
        REAL,        INTENT(IN)      :: CNS2,CNR2
        INTEGER,     INTENT(IN)      :: NUMR(3,NRING),NRING
        INTEGER,     INTENT(IN)      :: NLOCS(2,NRAYSC+1),NRAYSC
        CHARACTER*1, INTENT(IN)      :: MODE
        LOGICAL,     INTENT(IN)      :: USE_OMP
        REAL,        INTENT(IN)      :: WR(*)
        INTEGER*8,   INTENT(IN)      :: FFTW_PLANS(*) ! STRUCTURE POINTERS
        REAL,        INTENT(OUT)     :: CIRC(LCIRC)   ! WORK ARRAY
        INTEGER,     INTENT(IN)      :: LCIRC
        COMPLEX,     INTENT(OUT)     :: CIRCN(LCIRCC)
        INTEGER,     INTENT(IN)      :: LCIRCC


        DOUBLE PRECISION             :: AVO,VRINV
        DOUBLE PRECISION             :: PI,DFI
        REAL                         :: CIRCT
        INTEGER                      :: NSB,NSE,NRB,NRE,IT,INR,IGO,NVAL
        INTEGER                      :: LT,LTIGO,LTLTIGO,LTLTLTIGO,NSIM
        INTEGER                      :: NE,JT,INDX,IRTFLG
        REAL                         :: YQ,X,Y,FI,XT,YT

        REAL                         :: QUADRI_FAST
        INTEGER                      :: LOG2

        LOGICAL, PARAMETER           :: SPIDER_SIGN = .FALSE.

        INCLUDE 'CMBLOCK.INC'

C       FIND PARAMETERS TO NORMALIZE UNDER THE MASK,  
C       TRIED DOING THIS COMPLETELY ON THE
C       POLAR RINGS BUT IT GIVES SOME DIFFERENT REF. CHOICES. al

C       CNS2 AND CNR2 ARE PREDEFINED CENTERS
C       CALCULATE DIMENSIONS FOR NORMALIZING MASK
	NSB  = -CNS2
	NSE  =  NSB + NSAM - 1
	NRB  = -CNR2
	NRE  =  NRB + NROW - 1

C       GET PARAMETERS AVO & VRINV TO NORMALIZE UNDER CIRCULAR MASK
        CALL NORMASC(XIM, NSB,NSE,NRB,NRE, NUMR,NUMR(1,NRING),
     &               AVO,VRINV,USE_OMP)

C       INTERPOLATE INTO POLAR COORDINATES & APPLY NORMALIZATION
C       CREATING CIRC (RADIAL IMAGE CIRCLES) FOR THIS IMAGE POSITION
C       FOURIER TRANSFORM CIRC RINGS
C       OPTIONAL: WEIGHT TRANSFORMED CIRC RINGS USING  FACTORS FROM WR

        PI = 2 * DATAN(1.0D0)

C       FILL ALL THE RINGS

        IF (USE_OMP) THEN

c$omp      parallel do private(it,inr,yq,igo,nval,lt,ltigo,ltltigo,
c$omp&                     ltltltigo,nsim,dfi,x,y,circt,jt,fi,indx)
           DO  IT=1,NRING 

              INR  = NUMR(1,IT)        ! RADIUS OF THE CURRENT RING
              YQ   = INR               ! FLOATING POINT RADIUS
              IGO  = NUMR(2,IT)        ! STARTING LOCATION FOR RING 
              NVAL = NUMR(3,IT)        ! LENGTH OF THIS RING

C             ACTUAL, POWER-OF-TWO LENGTH IS NUMR(3,I)-2, ADDITIONAL
C             TWO LOCATIONS ARE ONLY FOR THE NEW FFT.
              CIRC(IGO+NVAL-1) = 0.0
              CIRC(IGO+NVAL-2) = 0.0
              NVAL             = NVAL - 2

              IF (MODE .EQ. 'H')    THEN
                 LT = NVAL / 2
              ELSEIF (MODE .EQ.'F') THEN
                 LT = NVAL / 4
              ENDIF

              LTIGO     = LT + IGO
              LTLTIGO   = LT + LT + IGO
              LTLTLTIGO = LT + LT + LT + IGO

              NSIM      = LT - 1
              DFI       = PI / (NSIM+1)

C             AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
              X         = CNS2
              Y         = INR + CNR2
              IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &            Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                 WRITE(NOUT,*) 'For image size1: ',NSAM,NROW,INR
                 WRITE(NOUT,90) X,Y
90               FORMAT('  FOR LOCATION: (',F7.1,',',F7.1,')')
                 CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
C                RETURN NOT POSSIBLE WITH INTEL PARALLEL COMPILER
                 STOP
              ENDIF

              CIRCT     = QUADRI_FAST(X,Y,NSAM,NROW,XIM)
              CIRC(IGO) = (CIRCT - AVO) * VRINV

C             AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
              X  = INR + CNS2
              Y  =     + CNR2
              IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &            Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                 WRITE(NOUT,*) 'For image size2: ',NSAM,NROW,INR
                 WRITE(NOUT,90) X,Y
                 CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
C                RETURN NOT POSSIBLE WITH INTEL PARALLEL COMPILER
                 STOP
              ENDIF

              CIRCT       = QUADRI_FAST(X,Y,NSAM,NROW,XIM)
              CIRC(LTIGO) = (CIRCT - AVO) * VRINV

              IF (MODE .EQ. 'F')  THEN
C                FILL OTHER HALF OF CIRCLE

C                TO AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
                 X  = 0.0  + CNS2
                 Y  = -INR + CNR2
                 IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &               Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                    WRITE(NOUT,*) 'For image size3: ',NSAM,NROW,INR
                    WRITE(NOUT,90) X,Y
                    CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
C                   RETURN NOT POSSIBLE WITH INTEL PARALLEL COMPILER
                    STOP
                 ENDIF

                 CIRCT         =  QUADRI_FAST(X,Y,NSAM,NROW,XIM)
                 CIRC(LTLTIGO) = (CIRCT - AVO) * VRINV

C                AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
                 X = -INR + CNS2
                 Y =  0.0 + CNR2
                 IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &               Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                    WRITE(NOUT,*) 'For image size4: ',NSAM,NROW,INR
                    WRITE(NOUT,90) X,Y
                    CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
C                   RETURN NOT POSSIBLE WITH INTEL PARALLEL COMPILER
                    STOP
                 ENDIF
                 CIRCT           = QUADRI_FAST(X,Y,NSAM,NROW,XIM)
                 CIRC(LTLTLTIGO) = (CIRCT - AVO) * VRINV
              ENDIF

              DO JT=1,NSIM     ! LOOP NSIM TIMES TO FILL RING
                 FI           = DFI * JT
                 X            = SIN(FI) * YQ
                 Y            = COS(FI) * YQ

                 CIRCT        = QUADRI_FAST(X+CNS2,Y+CNR2,NSAM,NROW,XIM)
                 CIRC(JT+IGO) = (CIRCT - AVO) * VRINV

                 CIRCT        = 
     &                         QUADRI_FAST(Y+CNS2,-X+CNR2,NSAM,NROW,XIM)
                 CIRC(JT+LTIGO) = (CIRCT - AVO) * VRINV

                 IF (MODE .EQ. 'F')  THEN
C                   FILL OTHER HALF OF CIRCLE
                    CIRCT = QUADRI_FAST(-X+CNS2,-Y+CNR2,NSAM,NROW,XIM)
                    CIRC(JT+LTLTIGO) = (CIRCT - AVO) * VRINV

                    CIRCT = QUADRI_FAST(-Y+CNS2,X+CNR2,NSAM,NROW,XIM)
                    CIRC(JT+LTLTLTIGO) = (CIRCT - AVO) * VRINV
                 ENDIF
	      ENDDO

C             INPLACE FORWARD FOURIER TRANSFORM ON THIS CIRC RING
              INDX = LOG2(NVAL) - 1       ! INDEX FOR PLAN
              
              CALL FMRS(CIRC(IGO), NVAL,1,1, FFTW_PLANS(INDX),
     &                  SPIDER_SIGN,.FALSE.,+1,IRTFLG)
              !write(6,*) ' fftd circ(1):',circ(1)
	   ENDDO
       ELSE

C          FILL ALL THE RINGS
           DO IT=1,NRING 

              INR  = NUMR(1,IT)        ! RADIUS OF THE CURRENT RING
              YQ   = INR               ! FLOATING POINT RADIUS
              IGO  = NUMR(2,IT)        ! STARTING LOCATION FOR RING 
              NVAL = NUMR(3,IT)        ! LENGTH OF THIS RING

C             THE ACTUAL, POWER-OF-TWO LENGTH IS NUMR(3,I)-2, ADDED
C             TWO LOCATIONS ARE ONLY FOR THE NEW FFT.
              CIRC(IGO+NVAL-1) = 0.0
              CIRC(IGO+NVAL-2) = 0.0
              NVAL             = NVAL - 2

              IF (MODE .EQ. 'H')  THEN
                 LT = NVAL / 2
              ELSEIF (MODE.EQ.'F') THEN
                 LT = NVAL / 4
              ENDIF

              LTIGO      = LT + IGO
              LTLTIGO    = LT + LT + IGO
              LTLTLTIGO  = LT + LT + LT + IGO

              NSIM       = LT - 1
              DFI        = PI / (NSIM+1)

C             AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
              X  = CNS2
              Y  = INR + CNR2
              IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &            Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                 !WRITE(NOUT,*) 'For image size1: ',NSAM,NROW,INR
                 WRITE(NOUT,90) X,Y
                 CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
                 RETURN
              ENDIF

              CIRCT     = QUADRI_FAST(X,Y,NSAM,NROW,XIM)
              CIRC(IGO) = (CIRCT - AVO) * VRINV
              !write(6,*)it,':1',igo,circ(igo)

C             AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
              X  = INR + CNS2
              Y  =     + CNR2
              IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &            Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                 !WRITE(NOUT,*) 'For image size2: ',NSAM,NROW,INR
                 WRITE(NOUT,90) X,Y
                 CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
                 STOP
              ENDIF

              CIRCT       = QUADRI_FAST(X,Y,NSAM,NROW,XIM)
              CIRC(LTIGO) = (CIRCT - AVO) * VRINV
              !write(6,*)it,':',ltigo,circ(ltigo)

              IF (MODE .EQ. 'F')  THEN
C                FILL OTHER HALF OF CIRCLE

C                AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
                 X  = 0.0  + CNS2
                 Y  = -INR + CNR2
                 IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &               Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                    !WRITE(NOUT,*) 'For image size3: ',NSAM,NROW,INR
                    WRITE(NOUT,90) X,Y
                    CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
                    STOP
                 ENDIF
  
                 CIRCT         =  QUADRI_FAST(X,Y,NSAM,NROW,XIM)
                 CIRC(LTLTIGO) = (CIRCT - AVO) * VRINV
                 !write(6,*)it,':',ltltigo,circ(ltltigo)

C                VOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
                 X  = -INR + CNS2
                 Y  =  0.0 + CNR2
                 IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &               Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                    !WRITE(NOUT,*) 'For image size4: ',NSAM,NROW,INR
                    WRITE(NOUT,90) X,Y
                    CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
                    STOP
                 ENDIF
                 CIRCT           = QUADRI_FAST(X,Y,NSAM,NROW,XIM)
                 CIRC(LTLTLTIGO) = (CIRCT - AVO) * VRINV
                 !write(6,*)it,':',ltltltigo,circ(ltltltigo)

              ENDIF
          
              DO JT=1,NSIM     ! LOOP NSIM TIMES TO FILL RING
                 FI             = DFI * JT
                 X              = SIN(FI) * YQ
                 Y              = COS(FI) * YQ

                 XT             = X+CNS2
                 YT             = Y+CNR2
                 CIRCT          = QUADRI_FAST(XT,YT,NSAM,NROW,XIM)
                 CIRC(JT+IGO)   = (CIRCT - AVO) * VRINV
 
                 XT             =  Y+CNS2
                 YT             = -X+CNR2

                 CIRCT          = QUADRI_FAST(XT,YT,NSAM,NROW,XIM)
                 CIRC(JT+LTIGO) = (CIRCT - AVO) * VRINV

                 IF (MODE .EQ. 'F')  THEN
C                   FILL OTHER HALF OF CIRCLE
                    XT                 = -X+CNS2
                    YT                 = -Y+CNR2
                    CIRCT              = QUADRI_FAST
     &                                   (XT,YT,NSAM,NROW,XIM)
                    CIRC(JT+LTLTIGO)   = (CIRCT - AVO) * VRINV

                    XT                 = -Y+CNS2
                    YT                 =  X+CNR2

                    CIRCT              = QUADRI_FAST
     &                                   (XT,YT,NSAM,NROW,XIM)
                    CIRC(JT+LTLTLTIGO) = (CIRCT - AVO) * VRINV
                 ENDIF
	      ENDDO

C             INPLACE FORWARD FOURIER TRANSFORM ON THIS CIRC RING
              INDX = LOG2(NVAL) - 1       ! INDEX FOR PLAN
              
              CALL FMRS(CIRC(IGO), NVAL,1,1, FFTW_PLANS(INDX),
     &                  SPIDER_SIGN,.FALSE.,+1,IRTFLG)
              !write(6,*) ' fftd circ(1):',circ(1)

 	   ENDDO
        ENDIF

C       REFORM RINGS BY RAY ORDER AND APPLY OPTIONAL WEIGHTING
        CALL APRINGS_TRANS_REFORM(NUMR,NRING, NLOCS,NRAYSC,  
     &                            CIRC,LCIRC/2, CIRCN,LCIRCC, WR)

        END

@


1.5
log
@taken from aprings_coef  (trans files only)
@
text
@d10 1
a10 1
C=* Email: spider@@wadsworth.org                                        *
@


1.4
log
@TRANS / un TRANS support
@
text
@d4 1
a4 12
C APRINGS_*_COEF    USED CMLIMIT                  AUG 00 ARDEAN LEITH
C                   ADDED REF_CIRC FILE           APR 01 ARDEAN LEITH
C                   NORMASS -> NORMAS             OCT 01 ARDEAN LEITH
C                   PROMPTS                       JAN 02 ARDEAN LEITH
C                   AUTO REF RINGS FILE           DEC 04 ARDEAN LEITH
C                   SPIDER REF RINGS FILE         FEB 05 ARDEAN LEITH
C                   INULL  = lnblnkn(SCRFILE)     APR 05 ARDEAN LEITH
C                   REWRITE FOR SPEED             MAR 08 ARDEAN LEITH
C                   BCAST_MPI                     NOV 08 ARDEAN LEITH
C                   OUTPUT TO NOUT                AUG 09 ARDEAN LEITH
C                   ADAPTED FOR COEFFS            MAY 10 ARDEAN LEITH
C                   ADAPTED FOR TRANS             JUN 10 ARDEAN LEITH
d27 1
a27 11
C  APRINGS_NEW_COEF(ILIST,NUMIMG, NSAM,NROW, 
C                    NRING,LCIRC,NUMR, MODE,FFTW_PLANS, 
C                    FILPAT,LUNIMG, CIRC,CIRC_IN_CORE,
C                    LUNRING,SCRFILE,WEIGHT,TRANS,IRTFLG)
C  
C  PARAMETERS: ILIST          LIST OF IMAGE FILE NUMBERS        (INPUT)
C              NIMREF         NO. OF IMAGES                     (INPUT)
C              NSAM,NROW      IMAGE DIMENSIONS                  (INPUT)
C              FILPAT         IMAGE SERIES FILE TEMPLATE        (INPUT)
C              LUNIMG         IMAGE FILE IO UNIT                (INPUT)
C              CIRC           OUTPUT ARRAY                      (OUTPUT)
d29 1
a29 6
C              CIRC_IN_CORE   NO OUTPUT ARRAY FLAG              (OUTPUT)
C              LUNRING        RINGS FILE IO UNIT                (INPUT)
C              SCRFILE        RINGS FILE                        (INPUT)
C              WEIGHT         WEIGHT THE FFT'D RINGS            (INPUT)
C              WEIGHT         TRANSFORM RING RAY ORDER          (INPUT)
C              IRTFLG         ERROR FLAG                        (OUTPUT)
d31 1
d35 1
a35 665
        SUBROUTINE APRINGS_NEW_COEF(ILIST,NUMIMG,  NSAM,NROW,
     &                         NRING,LCIRC,NUMR, NLOCS,NRAYSC,
     &                         COEFFS,IXY,
     &                         MODE,FFTW_PLANS,
     &                         FILPAT,LUNIMG,CIRC,CIRC_IN_CORE,
     &                         LUNRING,SCRFILE, WEIGHT,TRANS,IRTFLG)

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        INTEGER,   INTENT(IN)    :: ILIST(NUMIMG) 
        INTEGER,   INTENT(IN)    :: NUMIMG,NSAM,NROW 
        INTEGER,   INTENT(IN)    :: NUMR(3,NRING)
        INTEGER,   INTENT(IN)    :: NLOCS(2,NRAYSC+1)
        INTEGER,   INTENT(IN)    :: NRING,LCIRC,NRAYSC 
        REAL,      INTENT(OUT)   :: COEFFS(6,LCIRC)
        INTEGER,   INTENT(OUT)   :: IXY(2,LCIRC)
        CHARACTER(LEN=1)         :: MODE
        INTEGER*8, INTENT(IN)    :: FFTW_PLANS(*) ! STRUCTURE POINTERS
        CHARACTER(LEN=*)         :: FILPAT,SCRFILE
        INTEGER,   INTENT(IN)    :: LUNIMG,LUNRING   ! CONSTANTS
        REAL,      INTENT(OUT)   :: CIRC(LCIRC,NUMIMG)
        LOGICAL,   INTENT(IN)    :: CIRC_IN_CORE
        INTEGER,   INTENT(OUT)   :: IRTFLG 
        LOGICAL,   INTENT(IN)    :: WEIGHT     ! REF WEIGHTED, EXP NOT!
        LOGICAL,   INTENT(IN)    :: TRANS      ! TRANSFORMED RINGS

        CHARACTER(LEN=MAXNAM)    :: FILNAM
        LOGICAL                  :: ISOPEN
        LOGICAL                  :: USERINGFILE

        CALL SET_MPI(ICOMM,MYPID,MPIERR) ! SETS ICOMM AND MYPID

C       SEE IF THIS FILE EXISTS, (RETURNS EX, ISOPEN, LUNOP)

C       SEE IF SCRATCH "FILE" EXISTS (MAY BE INCORE FILE)
        ILOCAT = INDEX(SCRFILE,'@@')
        INULL  = lnblnkn(SCRFILE)
        IF (INULL .GT. 0 .AND. SCRFILE(1:1) .NE. '_' .AND.
     &      ILOCAT .EQ. 0) THEN
C          ADD EXTENSION TO PHYSICAL FILENAME
           CALL FILNAMANDEXT(SCRFILE,DATEXC,FILNAM,NLET,.TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN
        ELSE
           FILNAM = SCRFILE
           NLET   = lnblnk(FILNAM)
        ENDIF
#ifdef USE_MPI
        IF (MYPID .LE. 0) THEN
           INQUIRE(FILE=FILNAM,EXIST=USERINGFILE,OPENED=ISOPEN,
     &             NUMBER=LUNOP,IOSTAT=IRTFLG)
        ENDIF
        CALL BCAST_MPI('APRINGS','USERINGFILE',USERINGFILE,1, 'L',ICOMM)
#else
        USERINGFILE = .FALSE.
        IF (INULL .GT. 0) THEN
           CALL INQUIREIF1(LUNRING,FILNAM,DUM,NDUM,USERINGFILE,ISOPEN,
     &                     LUNOP,INLNED,IMGNUM,IRTFLG)
        ENDIF
#endif

        IF (USERINGFILE .AND. MYPID .LE. 0) THEN
           WRITE(NOUT,*) ' Using existing rings file: ',FILNAM(1:NLET)
        ELSEIF (MYPID .LE. 0) THEN
           WRITE(NOUT,*) ' No existing rings file: ',FILNAM(1:NLET)
        ENDIF

        IF (CIRC_IN_CORE  .AND. .NOT. USERINGFILE) THEN !-------------
C          CALCULATE RINGS DATA AND FILL CIRC ARRAY WITH IT

C          CALCULATE RINGS DATA COEFFS (HAS OMP PARALLEL LOOP)
           CALL APRINGS_FIND_COEF(NSAM,NROW, LCIRC, NUMR,NRING, 
     &                            MODE, COEFFS,IXY, IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

C          USE COEFFS TO CALCULATE RINGS AND FILL CIRC ARRAY
C          HAS OMP PARALLEL LOOPS
           CALL APRINGS_FILL_COEF(ILIST,NUMIMG, FILPAT,LUNIMG,
     &                            NSAM,NROW, 
     &                            0,0,1,
     &                            NUMR,NRING, NLOCS,NRAYSC, 
     &                            COEFFS,IXY, FFTW_PLANS,
     &                            CIRC,LCIRC,NUMIMG,
     &                            1, NCIRCGOT,
     &                            0,WEIGHT, MODE, TRANS,IRTFLG)
   
           IF (MYPID .LE. 0) WRITE(NOUT,*) ' Created incore rings file'

        ELSEIF (CIRC_IN_CORE .AND. USERINGFILE) THEN !----------------
C          READ EXISTING RINGS FILE AND FILL CIRC ARRAY WITH ITS DATA

C          OPEN AN EXISTING RINGS FILE
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'O',IFORM,
     &                 LCIRCT,NUMIMGT,NSLICE,MAXIM,' ', .TRUE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           IF (LCIRCT .NE. LCIRC .OR. NUMIMGT .NE. NUMIMG) THEN
               CALL ERRT(101,'RINGS FILE HAS WRONG SIZE',NE)
               IRTFLG = 1
               RETURN
           ENDIF

C          FILL CIRC WITH EXISTING RINGS DATA FROM FILE AND RETURN.
           DO IREF=1,NUMIMG
              CALL REDLIN(LUNRING,CIRC(1,IREF),LCIRC,IREF)
           ENDDO

           IF (MYPID .LE. 0)  WRITE(NOUT,*)' Loaded rings file incore'

        ELSEIF (.NOT. CIRC_IN_CORE .AND. USERINGFILE) THEN !-----------
C          OPEN AN EXISTING RINGS FILE SO THAT CAN READ RINGS DATA LATER
           MAXIM = 0
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'O',IFORM,
     &                 LCIRCT,NUMIMGT,NSLICE,MAXIM,' ', .FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

           IF (LCIRCT .NE. LCIRC .OR. NUMIMGT .NE. NUMIMG) THEN
              CALL ERRT(101,'EXISTING RINGS FILE HAS WRONG SIZE',NE)
              IRTFLG = 1
              RETURN
           ENDIF

        ELSEIF (.NOT. CIRC_IN_CORE .AND. .NOT. USERINGFILE) THEN !-----
C          CALCULATE RINGS DATA AND FILL RINGS FILE WITH DATA

C          CREATE RINGS OUTPUT FILE
           NSL = 1
           CALL OPFILEC(0,.FALSE.,SCRFILE,LUNRING,'B',IFORM,
     &                  LCIRC,NUMIMG,NSL,MAXIM,' ', .FALSE.,IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

C          CALCULATE RINGS DATA COEFFS (HAS OMP PARALLEL LOOP)
           CALL APRINGS_FIND_COEF(NSAM,NROW, LCIRC, NUMR,NRING, 
     &                            MODE, COEFFS,IXY, IRTFLG)
           IF (IRTFLG .NE. 0) RETURN

C          FILL CIRC RINGS FILE WITH RINGS DATA
C          HAS OMP PARALLEL SECTION
           CALL APRINGS_FILL_COEF(ILIST,NUMIMG, FILPAT,LUNIMG,
     &                            NSAM,NROW, 
     &                            0,0,1,
     &                            NUMR,NRING,  NLOCS,NRAYSC, 
     &                            COEFFS,IXY,  FFTW_PLANS,
     &                            CIRC,LCIRC,NUMIMG,
     &                            1, NCIRCGOT,
     &                            LUNRING,WEIGHT, MODE,TRANS,IRTFLG)

           IF (MYPID .LE. 0) WRITE (NOUT,92) SCRFILE
92         FORMAT ('  Filled rings file: ',A )

        ENDIF

        END

C       --------------------- APRINGS_FILL_COEF --------------------------


        SUBROUTINE APRINGS_FILL_COEF(IMGLIST,NUMIMG, IMGPAT,LUNIMG,
     &                               NSAM,NROW,
     &                               ISHRANGEX,ISHRANGEY,ISTEP,
     &                               NUMR,NRING,  NLOCS,NRAYSC,
     &                               COEFFS,IXY,  FFTW_PLANS,
     &                               CIRC,LCIRC,NCIRC,
     &                               IGOCIRC, NCIRCGOT,
     &                               LUNRING,WEIGHT, MODE, TRANS,IRTFLG)

        IMPLICIT NONE

        INCLUDE 'CMBLOCK.INC'
        INCLUDE 'CMLIMIT.INC'

        INTEGER,  INTENT(IN)    :: IMGLIST(NUMIMG)
        INTEGER,  INTENT(IN)    :: NUMIMG 
        CHARACTER(LEN=*)        :: IMGPAT
        INTEGER,  INTENT(IN)    :: LUNIMG, NSAM,NROW
        INTEGER,  INTENT(IN)    :: ISHRANGEX,ISHRANGEY,ISTEP
        INTEGER,  INTENT(IN)    :: NUMR(3,NRING)
        INTEGER,  INTENT(IN)    :: NRING
        INTEGER,  INTENT(IN)    :: NLOCS(2,NRAYSC+1)
        INTEGER,  INTENT(IN)    :: NRAYSC
        REAL,     INTENT(OUT)   :: COEFFS(6,LCIRC)
        INTEGER,  INTENT(OUT)   :: IXY(2,LCIRC)
        INTEGER*8,INTENT(IN)    :: FFTW_PLANS(*) ! STRUCTURE POINTERS
        REAL,     INTENT(OUT)   :: CIRC(LCIRC,NCIRC)
        INTEGER,  INTENT(IN)    :: LCIRC,NCIRC
        INTEGER,  INTENT(IN)    :: IGOCIRC
        INTEGER,  INTENT(INOUT) :: NCIRCGOT
        INTEGER,  INTENT(IN)    :: LUNRING
        LOGICAL,  INTENT(IN)    :: WEIGHT
        CHARACTER(LEN=1)        :: MODE
        LOGICAL,  INTENT(IN)    :: TRANS      ! TRANSFORMED RINGS/RAYS
        INTEGER,  INTENT(OUT)   :: IRTFLG

        REAL, ALLOCATABLE       :: XIM(:,:),CIRCO(:)
        INTEGER                 :: ICOMM,MYPID,MPIERR,MAXRIN
        INTEGER                 :: ISHX,ISHY,IMI,MWANT
        REAL                    :: CNS2,CNR2,CNS2C,CNR2C
        REAL                    :: WR(NRING)

        LOGICAL, PARAMETER      :: USE_OMP = .TRUE.

        CALL SET_MPI(ICOMM,MYPID,MPIERR)   ! SETS ICOMM AND MYPID

        IF (WEIGHT) THEN
           MAXRIN = NUMR(3,NRING)
#ifdef SP_LIBFFTW3
           MAXRIN = NUMR(3,NRING) - 2
#endif

C          RINGWE RETURNS WR WEIGHTS
	   CALL RINGWE_NEW(WR,NUMR,NRING,MAXRIN)
           IF (MODE .EQ. 'H') WR = WR * 0.5
        ELSE
           WR(1) = 0.0
        ENDIF

C       FILL COEFFS ARRAY WITH RINGS DEFINITIONS  (HAS OMP || LOOP)
        CALL APRINGS_FIND_COEF(NSAM,NROW, LCIRC, 
     &                         NUMR,NRING, MODE, COEFFS,IXY, IRTFLG)
        IF (IRTFLG .NE. 0) RETURN
  
        IF (TRANS) THEN
           MWANT = NSAM*NROW+LCIRC 
           ALLOCATE(XIM(NSAM,NROW),
     &              CIRCO(LCIRC), STAT=IRTFLG)
        ELSE
           MWANT = NSAM*NROW + 1
           ALLOCATE(XIM(NSAM,NROW), CIRCO(1),STAT=IRTFLG)
        ENDIF

        IF (IRTFLG.NE.0) THEN
            CALL ERRT(46,'XIM & CIRCO',MWANT)
            RETURN
        ENDIF

C       CALCULATE CENTERS
	CNS2C = (NSAM / 2 + 1) 
	CNR2C = (NROW / 2 + 1)

        NCIRCGOT = IGOCIRC -1

C       PREPARE CIRCULAR RINGS DATA FOR ALL IMAGES FROM IMGLIST
        DO IMI=1,NUMIMG            ! LOOP OVER ALL IMAGES
 
C          LOAD ONE IMAGE (IMI) INTO XIM
           CALL AP_GETDAT(IMGLIST,NUMIMG, NSAM,NROW,NSAM,NROW,
     &                    1,IMGPAT,LUNIMG, IMI,IMI,
     &                    1,NROW,1,NSAM, XIM, IRTFLG)
           IF (IRTFLG .NE. 0) GOTO 9999

C          LOOP OVER ANY SHIFTS (CAN LOAD A SET OF SHIFTS)

           DO ISHY=-ISHRANGEY,ISHRANGEY,ISTEP
C             LOOP OVER SHIFTED CENTERS IN Y
 	      CNR2 = CNR2C + ISHY
 
              DO ISHX=-ISHRANGEX,ISHRANGEX,ISTEP
C                LOOP OVER SHIFTED CENTERS IN X
	         CNS2     = CNS2C + ISHX 

                 NCIRCGOT = NCIRCGOT + 1      ! CURRENT CIRC # TO FILL

C                CONVERT XIM TO POLAR RINGS, NORMALIZE UNDER MASK,
C                FFT, & WEIGHT THE RINGS
                 CALL APRINGS_ONE_COEF(XIM, NSAM,NROW, CNS2,CNR2, 
     &                       NUMR,NRING, NLOCS,NRAYSC,
     &                       COEFFS,IXY,
     &                       USE_OMP, WR, FFTW_PLANS, TRANS,
     &                       CIRCO,LCIRC, CIRC(1,NCIRCGOT),IRTFLG)
                 IF (IRTFLG .NE. 0) GOTO 9999

                 IF (LUNRING .GT. 0) THEN
C                   SAVE CIRC IN FILE OPENED ON LUNRING
                    CALL WRTLIN(LUNRING,CIRC(1,NCIRCGOT),
     &                          LCIRC,NCIRCGOT)
                 ENDIF
              ENDDO      ! END OF: ISHX=-ISHRANGEX....
           ENDDO         ! END OF: ISHY=-ISHRANGEY....
        ENDDO            ! END OF: DO IMI=1,NUMIMG


9999    CONTINUE
C       DEALLOCATE ARRAY
        IF (ALLOCATED(XIM))   DEALLOCATE(XIM)
        IF (ALLOCATED(CIRCO)) DEALLOCATE(CIRCO)

        END


C       --------------------- APRINGS_ONE_COEF --------------------------

        SUBROUTINE APRINGS_ONE_COEF(XIM, NSAM,NROW, CNS2,CNR2, 
     &                       NUMR,NRING, NLOCS,NRAYSC,
     &                       COEFFS,IXY,
     &                       USE_OMP, WR, FFTW_PLANS, TRANS,
     &                       CIRCT,LCIRC, CIRC, IRTFLG)

        IMPLICIT NONE

        REAL,      INTENT(IN)    :: XIM(NSAM,NROW)
        INTEGER,   INTENT(IN)    :: NSAM,NROW
        REAL,      INTENT(IN)    :: CNS2,CNR2
        INTEGER,   INTENT(IN)    :: LCIRC        ! CIRCS LENGTH (REAL)
        INTEGER,   INTENT(IN)    :: NUMR(3,NRING)
        INTEGER,   INTENT(IN)    :: NRING
        INTEGER,   INTENT(IN)    :: NLOCS(2,NRAYSC+1)
        INTEGER,   INTENT(IN)    :: NRAYSC
        REAL,      INTENT(IN)    :: COEFFS(6,LCIRC)
        INTEGER,   INTENT(IN)    :: IXY(2,LCIRC)
        LOGICAL,   INTENT(IN)    :: USE_OMP
        REAL,      INTENT(IN)    :: WR(NRING)
        INTEGER*8, INTENT(IN)    :: FFTW_PLANS(*) ! STRUCTURE POINTERS
        LOGICAL,   INTENT(IN)    :: TRANS         ! REFORM RINGS/RAYS
        REAL,      INTENT(OUT)   :: CIRCT(LCIRC)  ! TEMP WORK ARRAY
        REAL,      INTENT(OUT)   :: CIRC(LCIRC)
        INTEGER,   INTENT(OUT)   :: IRTFLG
 
        DOUBLE PRECISION         :: AVT,VRINV
        LOGICAL, PARAMETER       :: SPIDER_SIGN = .FALSE.

        INTEGER                  :: ISHX,ISHY
        INTEGER                  :: NSB,NSE,NRB,NRE   ,I

C       CNS2 AND CNR2 ARE PREDEFINED CENTERS
C       CALCULATE DIMENSIONS FOR NORMALIZING MASK
	NSB  = -CNS2
	NSE  =  NSB + NSAM - 1
	NRB  = -CNR2
	NRE  =  NRB + NROW - 1

C       FIND PARAMETERS TO NORMALIZE UNDER THE MASK,  
C       GET PARAMETERS AVT & VRINV TO NORMALIZE UNDER CIRCULAR MASK
        CALL NORMASC(XIM, NSB,NSE,NRB,NRE, NUMR(1,1),NUMR(1,NRING),
     &               AVT,VRINV, USE_OMP)

        ISHX = CNS2 - (NSAM / 2 + 1)
        ISHY = CNR2 - (NROW / 2 + 1)

        !write(6,'f7.2,2i4') (coeffs(1,i), ixy(1:2,I),i=1,30)

        IF (TRANS) THEN
C          INTERPOLATE IMAGE INTO POLAR COORDINATES & APPLY NORMALIZATION
C          CREATING: CIRC  (RADIAL RINGS) FOR THIS IMAGE POSITION

           CALL APRINGS_USE_COEF(XIM,NSAM,NROW, ISHX,ISHY,
     &                  COEFFS,IXY, AVT,VRINV, CIRCT,LCIRC, USE_OMP)
           !call chkreal('real circt',circt,lcirc, 32006,1000, 1)

C          FOURIER TRANSFORM WHOLE SET OF CIRCT RINGS
           CALL FRNGS_NEWT(CIRCT,LCIRC, NUMR,NRING, SPIDER_SIGN,
     &                     FFTW_PLANS, USE_OMP)
           !call chkcmplx('fftd coeft',circt,lcirc, 32006,1000, 1000)
           !call chkray(1,.false., circt,lcirc, numr,nring, nlocs,nraysc)

C          REFORM RINGS BY RAY ORDER AND APPLY OPTIONAL WEIGHTING
           CALL APRINGS_TRANS_REFORM(NUMR,NRING, NLOCS,NRAYSC,  
     &                               CIRCT,LCIRC/2, CIRC,LCIRC/2, WR)
         ELSE
C          INTERPOLATE IMAGE INTO POLAR COORDINATES & APPLY NORMALIZATION
C          CREATING: CIRC (RADIAL RINGS) FOR THIS IMAGE POSITION

           CALL APRINGS_USE_COEF(XIM,NSAM,NROW, ISHX,ISHY,
     &                      COEFFS,IXY, AVT,VRINV, CIRC,LCIRC, USE_OMP)
           !call chkreal('real circ',circ,lcirc, 32006,1000, 1)

C          FOURIER TRANSFORM WHOLE SET OF CIRC RINGS
           CALL FRNGS_NEWT(CIRC, LCIRC, NUMR,NRING, SPIDER_SIGN,
     &                     FFTW_PLANS, USE_OMP)
           !call chkcmplx('fftd coef',circ,lcirc, 32006,1000, 1000)
           !call chkray(1,.false., circ,lcirc, numr,nring, nlocs,nraysc)

           IF (WR(1) > 0.0) THEN
C             WEIGHT TRANSFORMED CIRC RINGS USING  FACTORS FROM: WR
              CALL APPLYWS_NEW(CIRC,LCIRC, NUMR,WR,NRING)
           ENDIF
        ENDIF

        !write(6,*)' --- transformed wr coeft ------------'  
        !call chkcmplx('wr coef',circ,lcirc, 32006,2000, 17)  
        !call chkray(1,.true.,   circ,lcirc, numr,nring, nlocs,nraysc) 
        !call chkring(113,.true.,circ,lcirc, numr,nring, nlocs,nraysc) 

        IRTFLG = 0

        END

C     ------------------------- APRINGS_USE_COEF ------------------------

       SUBROUTINE APRINGS_USE_COEF(XIM,NSAM,NROW,  IXSH,IYSH,
     &                COEFFS,IXY,   AVT,VRINV,      CIRC,LCIRC, USE_OMP)

C      PURPOSE: GIVEN VALUES FOR: GRIDDED LOCATIONS: F0,F1,F2,F3,F4,FC
C              AND INTERPOLATION COEFF'S: C0,C1,C2,C3,C4,CC
C              RETURNS INTERPOLATED VALUE FOR POINT WHERE COEFFS DERIVED
C          F4
C       F2 F0 F1
C          F3 FC

        IMPLICIT NONE

        INTEGER, INTENT(IN)    :: NSAM,NROW,LCIRC
        REAL,    INTENT(IN)    :: XIM(NSAM,NROW)
        INTEGER, INTENT(IN)    :: IXSH,IYSH
        LOGICAL, INTENT(IN)    :: USE_OMP

        REAL,    INTENT(IN)    :: COEFFS(6,LCIRC)
        INTEGER, INTENT(IN)    :: IXY(2,LCIRC)
        REAL,    INTENT(INOUT) :: CIRC(LCIRC) 
        DOUBLE PRECISION       :: AVT,VRINV

        INTEGER                :: I,IX,IY 

        IF (USE_OMP) THEN
C          FILL THE RINGS WITH ACTUAL IMAGE VALUES

c$omp      parallel do private(i,ix,iy)
           DO  I=1,LCIRC  ! LOOP OVER ALL POINTS ON THE RING SET

              IF (IXY(1,I) .EQ. -100 ) THEN
                 CIRC(I) = 0.0   ! THIS IS UNUSED FFT PAD LOCATION
                 CYCLE
              ENDIF

              IX      = IXY(1,I) + IXSH 
              IY      = IXY(2,I) + IYSH

              CIRC(I) = (XIM(IX,  IY)   * COEFFS(1,I) +
     &                   XIM(IX+1,IY)   * COEFFS(2,I) +
     &                   XIM(IX-1,IY)   * COEFFS(3,I) +
     &                   XIM(IX,  IY-1) * COEFFS(4,I) +
     &                   XIM(IX,  IY+1) * COEFFS(5,I) +
     &                   XIM(IX+1,IY+1) * COEFFS(6,I) - AVT) * VRINV
	   ENDDO
        ELSE
C          FILL THE RINGS WITH ACTUAL IMAGE VALUES
           DO  I=1,LCIRC  ! LOOP OVER ALL POINTS ON THE RING SET

              IF (IXY(1,I) .EQ. -100 ) THEN
                 CIRC(I) = 0.0   ! THIS IS UNUSED FFT PAD LOCATION
                 CYCLE
              ENDIF

              IX      = IXY(1,I) + IXSH 
              IY      = IXY(2,I) + IYSH

              CIRC(I) = (XIM(IX,  IY)   * COEFFS(1,I) +
     &                   XIM(IX+1,IY)   * COEFFS(2,I) +
     &                   XIM(IX-1,IY)   * COEFFS(3,I) +
     &                   XIM(IX,  IY-1) * COEFFS(4,I) +
     &                   XIM(IX,  IY+1) * COEFFS(5,I) +
     &                   XIM(IX+1,IY+1) * COEFFS(6,I) - AVT) * VRINV
	   ENDDO
        ENDIF

        END

C++***************************APRINGS_FIND_COEF ************************
C
C APRINGS_FIND_COEF.F   MODIFIED FROM ALRQ_MS    MAY 2010 ARDEAN LEITH
C PURPOSE: CREATES ARRAY OF COEFFICIENTS USED TO CREATE POLAR CIRCULAR
C          RINGS. FFT WILL BE USED ON RINGS.

        SUBROUTINE APRINGS_FIND_COEF(NSAM,NROW, LCIRC, 
     &                               NUMR,NRING, MODE, 
     &                               COEFFS,IXY, IRTFLG)

        IMPLICIT NONE

        INTEGER,     INTENT(IN)  :: NSAM,NROW,NRING,LCIRC
        INTEGER,     INTENT(IN)  :: NUMR(3,NRING)
        CHARACTER*1, INTENT(IN)  :: MODE
        REAL,        INTENT(OUT) :: COEFFS(6,LCIRC)
        INTEGER,     INTENT(OUT) :: IXY(2,LCIRC)
        INTEGER,     INTENT(OUT) :: IRTFLG

        REAL                     :: CNS2,CNR2
        REAL                     :: X, Y 
        DOUBLE PRECISION         :: PI,DFI
        INTEGER                  :: IT,INR,IGO,NVAL,LT,NE
        INTEGER                  :: LTIGO,LTLTIGO,LTLTLTIGO,NSIM,JT
        REAL                     :: YQ,FI

        INCLUDE 'CMBLOCK.INC'


C       CNS2 AND CNR2 ARE PREDEFINED CENTERS
	CNS2  = (NSAM / 2 + 1) 
	CNR2  = (NROW / 2 + 1)

        PI    = 2 * DATAN(1.0D0)

C       FIND COEFFICIENTS FOR ALL THE RINGS OVER THE IMAGE

c$omp   parallel do private(it,inr,yq,igo,nval,lt,ltigo,ltltigo,
c$omp&                      ltltltigo,nsim,dfi,x,y,jt,fi)

        DO  IT=1,NRING 

           INR  = NUMR(1,IT)        ! RADIUS OF THE CURRENT RING
           YQ   = INR               ! FLOATING POINT RADIUS
           IGO  = NUMR(2,IT)        ! STARTING LOCATION FOR RING 

C          THE ACTUAL, POWER-OF-TWO LENGTH IS NUMR(3,I)-2, ADDITIONAL
C          TWO LOCATIONS ARE ONLY FOR THE NEW FFT.
           NVAL = NUMR(3,IT) - 2    ! LENGTH OF THIS RING

           IF (MODE .EQ. 'H')   THEN
              LT = NVAL / 2
           ELSEIF (MODE.EQ.'F') THEN
              LT = NVAL / 4
           ENDIF

           LTIGO        = LT + IGO
           LTLTIGO      = LT + LT + IGO
           LTLTLTIGO    = LT + LT + LT + IGO

           NSIM         = LT - 1
           DFI          = PI / (NSIM+1)

C          TO AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
           X            = CNS2
           Y            = INR + CNR2
           IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &         Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
               WRITE(NOUT,*) 'For image size1: ',NSAM,NROW,INR
               WRITE(NOUT,90) X,Y
90             FORMAT('  FOR LOCATION: (',F7.1,',',F7.1,')')
               CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
C              RETURN NOT POSSIBLE WITH INTEL PARALLEL COMPILER
               IRTFLG = 1
               EXIT
           ENDIF

           CALL QUADRI_COEFFS(X,Y, COEFFS(1,IGO),IXY(1,IGO))

C          TO AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
           X = INR + CNS2
           Y =     + CNR2
           IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &         Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
               WRITE(NOUT,*) 'For image size2: ',NSAM,NROW,INR
               WRITE(NOUT,90) X,Y
               CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
C              RETURN NOT POSSIBLE WITH INTEL PARALLEL COMPILER
               IRTFLG = 1
               EXIT
           ENDIF

           CALL QUADRI_COEFFS(X,Y, COEFFS(1,LTIGO),IXY(1,LTIGO))

           IF (MODE .EQ. 'F')  THEN
C             FILL OTHER HALF OF RING

C             TO AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
              X = 0.0  + CNS2
              Y = -INR + CNR2
              IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &            Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                  WRITE(NOUT,*) 'For image size3: ',NSAM,NROW,INR
                  WRITE(NOUT,90) X,Y
                  CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
C                 RETURN NOT POSSIBLE WITH INTEL PARALLEL COMPILER
                  IRTFLG = 1
                  EXIT
              ENDIF

              CALL QUADRI_COEFFS(X, Y, COEFFS(1,LTLTIGO),IXY(1,LTLTIGO))

C             TO AVOID SLOW BOUNDARY TESTS IN QUADRI_FAST, PUT THEM HERE
              X = -INR + CNS2
              Y =  0.0 + CNR2
              IF (X .LE. 2.0 .OR. X .GE. (FLOAT(NSAM)-1.0) .OR. 
     &            Y .LE. 2.0 .OR. Y .GE. (FLOAT(NROW)-1.0) ) THEN
                  WRITE(NOUT,*) 'For image size4: ',NSAM,NROW,INR
                  WRITE(NOUT,90) X,Y
                  CALL ERRT(101,'RING GOES OUTSIDE IMAGE',NE)
C                 RETURN NOT POSSIBLE WITH INTEL PARALLEL COMPILER
                  IRTFLG = 1
                  EXIT
              ENDIF

              CALL QUADRI_COEFFS(X,Y,COEFFS(1,LTLTLTIGO),
     &                                  IXY(1,LTLTLTIGO))
           ENDIF

           DO JT=1,NSIM     ! LOOP NSIM TIMES TO FILL RING
              FI = DFI * JT
              X  = SIN(FI) * YQ
              Y  = COS(FI) * YQ

              CALL QUADRI_COEFFS(X+CNS2, Y+CNR2,
     &                           COEFFS(1,JT+IGO),  IXY(1,JT+IGO))
              CALL QUADRI_COEFFS(Y+CNS2, -X+CNR2,
     &                           COEFFS(1,JT+LTIGO),IXY(1,JT+LTIGO))
 
              IF (MODE .EQ. 'F')  THEN
C                FILL OTHER HALF OF RING
                 CALL QUADRI_COEFFS(-X+CNS2, -Y+CNR2,
     &                       COEFFS(1,JT+LTLTIGO), IXY(1,JT+LTLTIGO))
                 CALL QUADRI_COEFFS(-Y+CNS2, X+CNR2,
     &                       COEFFS(1,JT+LTLTLTIGO),IXY(1,JT+LTLTLTIGO))

             ENDIF
	   ENDDO

 	ENDDO

        END

C     ------------------------- QUADRI_COEFFS ------------------------

      SUBROUTINE QUADRI_COEFFS(X, Y, COEFFS, IXY) 

C     PURPOSE: GIVEN A VALUE FOR: X,Y THIS SUBROUTINE RETURNS
C              COEFF FOR 'QUADRATIC INTERPOLATION': C0,C1,C2,C3,C4,CC
C              ALSO SETS: IXY CONTAINING VALUES OF: X & Y

      IMPLICIT NONE

      REAL, INTENT(IN)     :: X,Y
      REAL, INTENT(OUT)    :: COEFFS(0:5)
      INTEGER, INTENT(OUT) :: IXY(2)

      INTEGER              :: IX,IY
      REAL                 :: DX0,DY0,DXB,DYB

      IX        = IFIX(X)       ! TRUNCATES
      IY        = IFIX(Y)

      DX0       = X - IX        ! DIFFERENCE X (NON INTEGER PART OF X)
      DY0       = Y - IY        ! DIFFERENCE Y (NON INTEGER PART OF Y)

      DXB       = DX0 - 1       ! <= 0
      DYB       = DY0 - 1       ! <= 0

      COEFFS(0) = 1 -DX0 -DY0 -DX0*DXB -DY0*DYB +DX0*DY0
      COEFFS(5) = DX0*DY0
      COEFFS(1) = DX0*(1 +DXB*0.5 -DY0)
      COEFFS(2) = DX0*0.5*DXB
      COEFFS(3) = DY0*0.5*DYB
      COEFFS(4) = DY0*(1 +DYB*0.5 -DX0)

      IXY(1)    = IX
      IXY(2)    = IY

#ifdef NEVER
      if (ix < 1 ) then
         write(6,*)'ix,x:',ix,x
         call errt(102,'Bad ix in coeffs',ix)
         stop
      endif
      if (iy < 1 ) then
         write(6,*)'iy,y:',iy,y
         call errt(102,'Bad iy in coeffs',iy)
         stop
      endif

      !WRITE(6,90) IXY,COEFFS
   90 FORMAT('  (',I5,',',I5,') :',7F8.3)
#endif

      END

C     --------------------- APRINGS_TRANS_REFORM ---------------------
@


1.3
log
@normasc needed omp flag
@
text
@d38 1
a38 1
C  APRINGS_NEW_COEFT(ILIST,NUMIMG, NSAM,NROW, 
d41 1
a41 1
C                    LUNRING,SCRFILE,WEIGHT,IRTFLG)
d54 1
d60 1
a60 3
C     -------------------- APRINGS_NEW_COEFT ----------------------------

        SUBROUTINE APRINGS_NEW_COEFT(ILIST,NUMIMG,  NSAM,NROW,
d65 1
a65 1
     &                         LUNRING,SCRFILE, WEIGHT,IRTFLG)
d85 1
d137 1
a137 1
           CALL APRINGS_FILL_COEFT(ILIST,NUMIMG, FILPAT,LUNIMG,
d144 1
a144 1
     &                            0,WEIGHT, MODE, IRTFLG)
d199 1
a199 1
           CALL APRINGS_FILL_COEFT(ILIST,NUMIMG, FILPAT,LUNIMG,
d206 1
a206 1
     &                            LUNRING,WEIGHT, MODE,IRTFLG)
d215 1
a215 1
C       --------------------- APRINGS_FILL_COEFT --------------------------
d218 1
a218 1
        SUBROUTINE APRINGS_FILL_COEFT(IMGLIST,NUMIMG, IMGPAT,LUNIMG,
d225 1
a225 1
     &                               LUNRING,WEIGHT, MODE, IRTFLG)
d251 1
d256 1
a256 1
        INTEGER                 :: ISHX,ISHY,IMI
d282 9
a290 2
        ALLOCATE(XIM(NSAM,NROW),
     &           CIRCO(LCIRC), STAT=IRTFLG)
d292 1
a292 1
            CALL ERRT(46,'XIM & CIRCO',NSAM*NROW+LCIRC)
d325 1
a325 2

                 CALL APRINGS_ONE_COEFT(XIM, NSAM,NROW, CNS2,CNR2, 
d328 1
a328 1
     &                       USE_OMP, WR, FFTW_PLANS, 
d330 1
a330 1
                IF (IRTFLG .NE. 0) GOTO 9999
a348 1
C       --------------------- APRINGS_ONE_COEFT --------------------------
d350 3
a352 1
        SUBROUTINE APRINGS_ONE_COEFT(XIM, NSAM,NROW, CNS2,CNR2, 
d355 1
a355 1
     &                       USE_OMP, WR, FFTW_PLANS, 
d363 1
a363 1
        INTEGER,   INTENT(IN)    :: LCIRC
d373 2
a374 1
        REAL,      INTENT(OUT)   :: CIRCT(LCIRC)  !  TEMP WORK ARRAY
d401 41
a441 26
C       INTERPOLATE IMAGE INTO POLAR COORDINATES & APPLY NORMALIZATION
C       CREATING: CIRCT (RADIAL RINGS) FOR THIS IMAGE POSITION
        CALL APRINGS_USE_COEFT(XIM,NSAM,NROW, ISHX,ISHY,
     &               COEFFS,IXY, AVT,VRINV, CIRCT,LCIRC, USE_OMP)
        !CALL CHKREAL('real circt',CIRCT,LCIRC, 32006,1000, 1)

C       FOURIER TRANSFORM WHOLE SET OF CIRCT RINGS
        CALL FRNGS_NEWT(CIRCT,LCIRC, NUMR,NRING, SPIDER_SIGN,
     &                  FFTW_PLANS, USE_OMP)

        !CALL CHKcmplx('fftd coeft',CIRCT,LCIRC, 32006,1000, 1000)
        !CALL CHKRAY(1,.FALSE., CIRCT,LCIRC, NUMR,NRING, NLOCS,NRAYSC)

C       WEIGHT TRANSFORMED CIRC RINGS  USING  FACTORS FROM: WR
        !CALL APPLYWS_NEW(CIRCT,LCIRC*2,NUMR,WR,NRING)
        !CALL CHKcmplx('wr coef',CIRCT,LCIRC, 32006,2000, 17)
        !CALL CHKRAY(1,.FALSE.,  CIRCT,LCIRC/2, NUMR,NRING, NLOCS,NRAYSC) 

C       REFORM RINGS BY RAY ORDER AND APPLY OPTIONAL WEIGHTING
        CALL APRINGS_TRANS_REFORM(NUMR,NRING, NLOCS,NRAYSC,  
     &                            CIRCT,LCIRC/2, CIRC,LCIRC/2, WR)

       !write(6,*)' --- transformed wr coeft ------------'  
       !CALL CHKcmplx('wr coeft',CIRC,LCIRC, 32006,2000, 17)  
       !CALL CHKRAY(1,.TRUE.,   CIRC,LCIRC/2, NUMR,NRING, NLOCS,NRAYSC) 
       !CALL CHKRING(113,.TRUE.,CIRC,LCIRC/2, NUMR,NRING, NLOCS,NRAYSC) 
d447 1
a447 1
C     ------------------------- APRINGS_USE_COEFT ------------------------
d449 1
a449 1
       SUBROUTINE APRINGS_USE_COEFT(XIM,NSAM,NROW,  IXSH,IYSH,
d452 1
a452 1
C     PURPOSE: GIVEN VALUES FOR: GRIDDED LOCATIONS: F0,F1,F2,F3,F4,FC
d455 3
a457 3
C       F4
C    F2 F0 F1
C       F3 FC
d519 1
a519 1
C APRINGS_FIND_COEF.F   MODIFIED FROM ALRQ_MS            MAY 2010 ARDEAN LEITH
a845 1

@


1.2
log
@indx in ||, deallocate leak fixed
@
text
@d874 1
a874 1
     &               AVO,VRINV)
@


1.1
log
@Initial revision
@
text
@d337 2
a338 1
        IF (ALLOCATED(XIM)) DEALLOCATE(XIM)
d831 1
a831 1
        REAL,        INTENT(INOUT)   :: XIM(NSAM,NROW)
d888 1
a888 1
c$omp&                         ltltltigo,nsim,dfi,x,y,circt,jt,fi)
@
